{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS c[0..8] with c[i] in {1..k}, contiguous labels {1..k}. Vertex i corresponds to V=i+1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for constraint violations and non-contiguous labels.\n    # Lower is better. Returns numeric fitness.\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Graph definition (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n    # Base objective k\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Fallback to a known feasible seed if input malformed\n    if not isinstance(solution, list) or len(solution) != 9:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if int(x) > 0 else 1 for x in solution]\n    new = current[:]\n    maxc = 1\n    for x in new:\n        if x > maxc:\n            maxc = x\n    i = random.randrange(9)\n    candidate_colors = list(range(1, maxc + 2))\n    try:\n        candidate_colors.remove(new[i])\n    except ValueError:\n        pass\n    if not candidate_colors:\n        candidate_colors = [1] if new[i] != 1 else [2]\n    new_color = random.choice(candidate_colors)\n    new[i] = new_color\n    # Compress labels to contiguous {1..k}\n    mapping = {}\n    nextc = 1\n    for x in new:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n    new = [mapping[x] for x in new]\n    return new, \"local\", \"recolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move random perturbation with label compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        new = [1,2,3,1,2,3,2,1,3]\n    else:\n        new = [int(x) if int(x) > 0 else 1 for x in solution]\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        i = random.randrange(9)\n        maxc = 1\n        for x in new:\n            if x > maxc:\n                maxc = x\n        choices = list(range(1, maxc + 2))\n        try:\n            choices.remove(new[i])\n        except ValueError:\n            pass\n        if not choices:\n            continue\n        new[i] = random.choice(choices)\n    # Optional color relabel swap\n    maxc = 1\n    for x in new:\n        if x > maxc:\n            maxc = x\n    if maxc >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, maxc + 1), 2)\n        new = [a if x == b else b if x == a else x for x in new]\n    # Compress labels to contiguous {1..k}\n    mapping = {}\n    nextc = 1\n    for x in new:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n    new = [mapping[x] for x in new]\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000538266}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS c[0..8] with c[i] in {1..k}, contiguous labels {1..k}. Vertex i corresponds to V=i+1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for constraint violations and non-contiguous labels.\n    # Lower is better. Returns numeric fitness.\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Graph definition (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n    # Base objective k\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Fallback to a known feasible seed if input malformed\n    if not isinstance(solution, list) or len(solution) != 9:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if int(x) > 0 else 1 for x in solution]\n    new = current[:]\n    maxc = 1\n    for x in new:\n        if x > maxc:\n            maxc = x\n    i = random.randrange(9)\n    candidate_colors = list(range(1, maxc + 2))\n    try:\n        candidate_colors.remove(new[i])\n    except ValueError:\n        pass\n    if not candidate_colors:\n        candidate_colors = [1] if new[i] != 1 else [2]\n    new_color = random.choice(candidate_colors)\n    new[i] = new_color\n    # Compress labels to contiguous {1..k}\n    mapping = {}\n    nextc = 1\n    for x in new:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n    new = [mapping[x] for x in new]\n    return new, \"local\", \"recolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move random perturbation with label compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        new = [1,2,3,1,2,3,2,1,3]\n    else:\n        new = [int(x) if int(x) > 0 else 1 for x in solution]\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        i = random.randrange(9)\n        maxc = 1\n        for x in new:\n            if x > maxc:\n                maxc = x\n        choices = list(range(1, maxc + 2))\n        try:\n            choices.remove(new[i])\n        except ValueError:\n            pass\n        if not choices:\n            continue\n        new[i] = random.choice(choices)\n    # Optional color relabel swap\n    maxc = 1\n    for x in new:\n        if x > maxc:\n            maxc = x\n    if maxc >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, maxc + 1), 2)\n        new = [a if x == b else b if x == a else x for x in new]\n    # Compress labels to contiguous {1..k}\n    mapping = {}\n    nextc = 1\n    for x in new:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n    new = [mapping[x] for x in new]\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000663068}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS c[0..8] with c[i] in {1..k}, contiguous labels {1..k}. Vertex i corresponds to V=i+1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for constraint violations and non-contiguous labels.\n    # Lower is better. Returns numeric fitness.\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    # Graph definition (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n    # Base objective k\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = float(k)\n    # Contiguity check: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Fallback to a known feasible seed if input malformed\n    if not isinstance(solution, list) or len(solution) != 9:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if int(x) > 0 else 1 for x in solution]\n    new = current[:]\n    maxc = 1\n    for x in new:\n        if x > maxc:\n            maxc = x\n    i = random.randrange(9)\n    candidate_colors = list(range(1, maxc + 2))\n    try:\n        candidate_colors.remove(new[i])\n    except ValueError:\n        pass\n    if not candidate_colors:\n        candidate_colors = [1] if new[i] != 1 else [2]\n    new_color = random.choice(candidate_colors)\n    new[i] = new_color\n    # Compress labels to contiguous {1..k}\n    mapping = {}\n    nextc = 1\n    for x in new:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n    new = [mapping[x] for x in new]\n    return new, \"local\", \"recolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move random perturbation with label compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        new = [1,2,3,1,2,3,2,1,3]\n    else:\n        new = [int(x) if int(x) > 0 else 1 for x in solution]\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        i = random.randrange(9)\n        maxc = 1\n        for x in new:\n            if x > maxc:\n                maxc = x\n        choices = list(range(1, maxc + 2))\n        try:\n            choices.remove(new[i])\n        except ValueError:\n            pass\n        if not choices:\n            continue\n        new[i] = random.choice(choices)\n    # Optional color relabel swap\n    maxc = 1\n    for x in new:\n        if x > maxc:\n            maxc = x\n    if maxc >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, maxc + 1), 2)\n        new = [a if x == b else b if x == a else x for x in new]\n    # Compress labels to contiguous {1..k}\n    mapping = {}\n    nextc = 1\n    for x in new:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n    new = [mapping[x] for x in new]\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000623547}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; solution[i] in {1..k}; vertex i corresponds to V=i+1; labels can be non-contiguous during search but evaluation penalizes gaps; objective minimize k with feasibility c(u)!=c(v) on edges.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    HARD_PEN = 10**9\n    PEN_GAP = 10**4\n    PEN_EDGE = 10**6\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    for x in solution:\n        if not isinstance(x, int):\n            return HARD_PEN\n        if x < 1:\n            return HARD_PEN\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = float(k)\n    seen = set(solution)\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Conflict-focused min-conflicts recolor; avoids increasing k unless necessary.\n    # Internal graph definition\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Helper: compute vertex conflict count\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if v_conflicts(current, i) > 0]\n    # Candidate vertex selection\n    if conflicted:\n        # Focus on most conflicted vertices\n        maxc = max(v_conflicts(current, i) for i in conflicted)\n        cand_vertices = [i for i in conflicted if v_conflicts(current, i) == maxc]\n        v = random.choice(cand_vertices)\n    else:\n        # No conflicts: try to reduce k by recoloring a vertex with the highest color\n        k = max(current)\n        cand_vertices = [i for i,x in enumerate(current) if x == k]\n        if not cand_vertices:\n            v = random.randrange(n)\n        else:\n            v = random.choice(cand_vertices)\n    # Min-conflicts recolor for v\n    k = max(current)\n    colors = list(range(1, k+1))\n    # Evaluate conflicts for each color option\n    best_colors = []\n    best_score = None\n    for col in colors:\n        if col == current[v]:\n            continue\n        tmp_conf = 0\n        for w in adj[v]:\n            if current[w] == col:\n                tmp_conf += 1\n        if best_score is None or tmp_conf < best_score:\n            best_score = tmp_conf\n            best_colors = [col]\n        elif tmp_conf == best_score:\n            best_colors.append(col)\n    # Consider k+1 only if all existing colors tie at best_score and do not reduce conflicts\n    allow_new = False\n    if best_score is None:\n        allow_new = True\n    elif best_score > 0 and not conflicted:\n        # In a feasible state but trying to reduce k: avoid introducing conflicts; disallow new color\n        allow_new = False\n    elif conflicted and best_score > 0:\n        allow_new = True\n    # If allowed, add k+1 as candidate with its conflict score\n    if allow_new:\n        tmp_conf_new = 0  # new color has no neighbors yet\n        if best_score is None or tmp_conf_new < best_score:\n            best_colors = [k+1]\n            best_score = tmp_conf_new\n        elif tmp_conf_new == best_score:\n            best_colors.append(k+1)\n    if not best_colors:\n        # Fallback: random different color\n        best_colors = [random.choice([c for c in range(1, k+1) if c != current[v]] or [k+1])]\n    chosen_color = random.choice(best_colors)\n    new = current[:]\n    new[v] = chosen_color\n    return new, \"local\", \"min-conflicts\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style perturbation with optional block recolors; maintains stable labels\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def vertex_conflicted(sol, v):\n        c = sol[v]\n        for w in adj[v]:\n            if sol[w] == c:\n                return True\n        return False\n    # Choose a seed vertex: prefer conflicted\n    conflicted = [i for i in range(n) if vertex_conflicted(curr, i)]\n    if conflicted:\n        v0 = random.choice(conflicted)\n    else:\n        v0 = random.randrange(n)\n    k = max(curr)\n    # Choose alternate color a\n    alt_colors = list(range(1, k+1))\n    if curr[v0] in alt_colors:\n        alt_colors.remove(curr[v0])\n    if not alt_colors:\n        alt_colors = [k+1]\n    a = random.choice(alt_colors)\n    c0 = curr[v0]\n    # Build (c0,a)-Kempe chain containing v0\n    in_chain = [False]*n\n    dq = deque([v0])\n    in_chain[v0] = True\n    while dq:\n        u = dq.popleft()\n        for w in adj[u]:\n            if not in_chain[w] and (curr[w] == c0 or curr[w] == a):\n                in_chain[w] = True\n                dq.append(w)\n    # Swap colors on the chain\n    new = curr[:]\n    for i in range(n):\n        if in_chain[i]:\n            if new[i] == c0:\n                new[i] = a\n            elif new[i] == a:\n                new[i] = c0\n    # With small probability, perform extra random recolors to diversify\n    extra_steps = random.randint(1, 3)\n    for _ in range(extra_steps):\n        i = random.randrange(n)\n        k_now = max(new)\n        choices = [c for c in range(1, k_now+1)]\n        if new[i] in choices:\n            choices.remove(new[i])\n        if random.random() < 0.2:\n            choices.append(k_now+1)\n        if choices:\n            new[i] = random.choice(choices)\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00084715}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; solution[i] in {1..k}; vertex i corresponds to V=i+1; labels can be non-contiguous during search but evaluation penalizes gaps; objective minimize k with feasibility c(u)!=c(v) on edges.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    HARD_PEN = 10**9\n    PEN_GAP = 10**4\n    PEN_EDGE = 10**6\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    for x in solution:\n        if not isinstance(x, int):\n            return HARD_PEN\n        if x < 1:\n            return HARD_PEN\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = float(k)\n    seen = set(solution)\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Conflict-focused min-conflicts recolor; avoids increasing k unless necessary.\n    # Internal graph definition\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Helper: compute vertex conflict count\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if v_conflicts(current, i) > 0]\n    # Candidate vertex selection\n    if conflicted:\n        # Focus on most conflicted vertices\n        maxc = max(v_conflicts(current, i) for i in conflicted)\n        cand_vertices = [i for i in conflicted if v_conflicts(current, i) == maxc]\n        v = random.choice(cand_vertices)\n    else:\n        # No conflicts: try to reduce k by recoloring a vertex with the highest color\n        k = max(current)\n        cand_vertices = [i for i,x in enumerate(current) if x == k]\n        if not cand_vertices:\n            v = random.randrange(n)\n        else:\n            v = random.choice(cand_vertices)\n    # Min-conflicts recolor for v\n    k = max(current)\n    colors = list(range(1, k+1))\n    # Evaluate conflicts for each color option\n    best_colors = []\n    best_score = None\n    for col in colors:\n        if col == current[v]:\n            continue\n        tmp_conf = 0\n        for w in adj[v]:\n            if current[w] == col:\n                tmp_conf += 1\n        if best_score is None or tmp_conf < best_score:\n            best_score = tmp_conf\n            best_colors = [col]\n        elif tmp_conf == best_score:\n            best_colors.append(col)\n    # Consider k+1 only if all existing colors tie at best_score and do not reduce conflicts\n    allow_new = False\n    if best_score is None:\n        allow_new = True\n    elif best_score > 0 and not conflicted:\n        # In a feasible state but trying to reduce k: avoid introducing conflicts; disallow new color\n        allow_new = False\n    elif conflicted and best_score > 0:\n        allow_new = True\n    # If allowed, add k+1 as candidate with its conflict score\n    if allow_new:\n        tmp_conf_new = 0  # new color has no neighbors yet\n        if best_score is None or tmp_conf_new < best_score:\n            best_colors = [k+1]\n            best_score = tmp_conf_new\n        elif tmp_conf_new == best_score:\n            best_colors.append(k+1)\n    if not best_colors:\n        # Fallback: random different color\n        best_colors = [random.choice([c for c in range(1, k+1) if c != current[v]] or [k+1])]\n    chosen_color = random.choice(best_colors)\n    new = current[:]\n    new[v] = chosen_color\n    return new, \"local\", \"min-conflicts\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style perturbation with optional block recolors; maintains stable labels\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def vertex_conflicted(sol, v):\n        c = sol[v]\n        for w in adj[v]:\n            if sol[w] == c:\n                return True\n        return False\n    # Choose a seed vertex: prefer conflicted\n    conflicted = [i for i in range(n) if vertex_conflicted(curr, i)]\n    if conflicted:\n        v0 = random.choice(conflicted)\n    else:\n        v0 = random.randrange(n)\n    k = max(curr)\n    # Choose alternate color a\n    alt_colors = list(range(1, k+1))\n    if curr[v0] in alt_colors:\n        alt_colors.remove(curr[v0])\n    if not alt_colors:\n        alt_colors = [k+1]\n    a = random.choice(alt_colors)\n    c0 = curr[v0]\n    # Build (c0,a)-Kempe chain containing v0\n    in_chain = [False]*n\n    dq = deque([v0])\n    in_chain[v0] = True\n    while dq:\n        u = dq.popleft()\n        for w in adj[u]:\n            if not in_chain[w] and (curr[w] == c0 or curr[w] == a):\n                in_chain[w] = True\n                dq.append(w)\n    # Swap colors on the chain\n    new = curr[:]\n    for i in range(n):\n        if in_chain[i]:\n            if new[i] == c0:\n                new[i] = a\n            elif new[i] == a:\n                new[i] = c0\n    # With small probability, perform extra random recolors to diversify\n    extra_steps = random.randint(1, 3)\n    for _ in range(extra_steps):\n        i = random.randrange(n)\n        k_now = max(new)\n        choices = [c for c in range(1, k_now+1)]\n        if new[i] in choices:\n            choices.remove(new[i])\n        if random.random() < 0.2:\n            choices.append(k_now+1)\n        if choices:\n            new[i] = random.choice(choices)\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001125813}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; solution[i] in {1..k}; vertex i corresponds to V=i+1; labels can be non-contiguous during search but evaluation penalizes gaps; objective minimize k with feasibility c(u)!=c(v) on edges.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    HARD_PEN = 10**9\n    PEN_GAP = 10**4\n    PEN_EDGE = 10**6\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    for x in solution:\n        if not isinstance(x, int):\n            return HARD_PEN\n        if x < 1:\n            return HARD_PEN\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = float(k)\n    seen = set(solution)\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Conflict-focused min-conflicts recolor; avoids increasing k unless necessary.\n    # Internal graph definition\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Helper: compute vertex conflict count\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if v_conflicts(current, i) > 0]\n    # Candidate vertex selection\n    if conflicted:\n        # Focus on most conflicted vertices\n        maxc = max(v_conflicts(current, i) for i in conflicted)\n        cand_vertices = [i for i in conflicted if v_conflicts(current, i) == maxc]\n        v = random.choice(cand_vertices)\n    else:\n        # No conflicts: try to reduce k by recoloring a vertex with the highest color\n        k = max(current)\n        cand_vertices = [i for i,x in enumerate(current) if x == k]\n        if not cand_vertices:\n            v = random.randrange(n)\n        else:\n            v = random.choice(cand_vertices)\n    # Min-conflicts recolor for v\n    k = max(current)\n    colors = list(range(1, k+1))\n    # Evaluate conflicts for each color option\n    best_colors = []\n    best_score = None\n    for col in colors:\n        if col == current[v]:\n            continue\n        tmp_conf = 0\n        for w in adj[v]:\n            if current[w] == col:\n                tmp_conf += 1\n        if best_score is None or tmp_conf < best_score:\n            best_score = tmp_conf\n            best_colors = [col]\n        elif tmp_conf == best_score:\n            best_colors.append(col)\n    # Consider k+1 only if all existing colors tie at best_score and do not reduce conflicts\n    allow_new = False\n    if best_score is None:\n        allow_new = True\n    elif best_score > 0 and not conflicted:\n        # In a feasible state but trying to reduce k: avoid introducing conflicts; disallow new color\n        allow_new = False\n    elif conflicted and best_score > 0:\n        allow_new = True\n    # If allowed, add k+1 as candidate with its conflict score\n    if allow_new:\n        tmp_conf_new = 0  # new color has no neighbors yet\n        if best_score is None or tmp_conf_new < best_score:\n            best_colors = [k+1]\n            best_score = tmp_conf_new\n        elif tmp_conf_new == best_score:\n            best_colors.append(k+1)\n    if not best_colors:\n        # Fallback: random different color\n        best_colors = [random.choice([c for c in range(1, k+1) if c != current[v]] or [k+1])]\n    chosen_color = random.choice(best_colors)\n    new = current[:]\n    new[v] = chosen_color\n    return new, \"local\", \"min-conflicts\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style perturbation with optional block recolors; maintains stable labels\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def vertex_conflicted(sol, v):\n        c = sol[v]\n        for w in adj[v]:\n            if sol[w] == c:\n                return True\n        return False\n    # Choose a seed vertex: prefer conflicted\n    conflicted = [i for i in range(n) if vertex_conflicted(curr, i)]\n    if conflicted:\n        v0 = random.choice(conflicted)\n    else:\n        v0 = random.randrange(n)\n    k = max(curr)\n    # Choose alternate color a\n    alt_colors = list(range(1, k+1))\n    if curr[v0] in alt_colors:\n        alt_colors.remove(curr[v0])\n    if not alt_colors:\n        alt_colors = [k+1]\n    a = random.choice(alt_colors)\n    c0 = curr[v0]\n    # Build (c0,a)-Kempe chain containing v0\n    in_chain = [False]*n\n    dq = deque([v0])\n    in_chain[v0] = True\n    while dq:\n        u = dq.popleft()\n        for w in adj[u]:\n            if not in_chain[w] and (curr[w] == c0 or curr[w] == a):\n                in_chain[w] = True\n                dq.append(w)\n    # Swap colors on the chain\n    new = curr[:]\n    for i in range(n):\n        if in_chain[i]:\n            if new[i] == c0:\n                new[i] = a\n            elif new[i] == a:\n                new[i] = c0\n    # With small probability, perform extra random recolors to diversify\n    extra_steps = random.randint(1, 3)\n    for _ in range(extra_steps):\n        i = random.randrange(n)\n        k_now = max(new)\n        choices = [c for c in range(1, k_now+1)]\n        if new[i] in choices:\n            choices.remove(new[i])\n        if random.random() < 0.2:\n            choices.append(k_now+1)\n        if choices:\n            new[i] = random.choice(choices)\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001056502}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; vertices i=1..9 map to indices i-1; entry values are positive integers representing colors; labels may be non-contiguous during search; normalization may compress labels to contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    HARD_PEN = 10**9\n    PEN_GAP = 10**4\n    PEN_EDGE = 10**6\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != n:\n        return HARD_PEN\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return HARD_PEN\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = k  # integer accumulation\n    seen = set(solution)\n    if len(seen) != k:\n        fitness += PEN_GAP\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    def normalize_colors(sol):\n        # Map unique labels in sorted order to 1..k\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n    # sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    current = normalize_colors(current)\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    conflicted = [i for i in range(n) if v_conflicts(current, i) > 0]\n    if conflicted:\n        maxc = max(v_conflicts(current, i) for i in conflicted)\n        cand_vertices = [i for i in conflicted if v_conflicts(current, i) == maxc]\n        v = random.choice(cand_vertices)\n    else:\n        k = max(current)\n        cand_vertices = [i for i,x in enumerate(current) if x == k]\n        v = random.choice(cand_vertices) if cand_vertices else random.randrange(n)\n    k = max(current)\n    neighbor_colors = set(current[w] for w in adj[v])\n    # Prefer colors not used by neighbors (conflict-free options)\n    conflict_free = [c for c in range(1, k+1) if c != current[v] and c not in neighbor_colors]\n    if conflict_free:\n        # tie-breaker: prefer lowest color to promote compression\n        chosen_color = min(conflict_free)\n    else:\n        # evaluate conflict counts per color within 1..k\n        best_colors = []\n        best_score = None\n        for col in range(1, k+1):\n            if col == current[v]:\n                continue\n            tmp_conf = 0\n            for w in adj[v]:\n                if current[w] == col:\n                    tmp_conf += 1\n            if best_score is None or tmp_conf < best_score:\n                best_score = tmp_conf\n                best_colors = [col]\n            elif tmp_conf == best_score:\n                best_colors.append(col)\n        # Allow k+1 only if it strictly reduces conflicts vs best existing option\n        allow_new = False\n        if best_score is None:\n            allow_new = True\n        elif best_score > 0 and conflicted:\n            allow_new = True\n        if allow_new:\n            tmp_conf_new = 0\n            if best_score is None or tmp_conf_new < best_score:\n                best_colors = [k+1]\n            elif tmp_conf_new == best_score:\n                best_colors.append(k+1)\n        chosen_color = random.choice(best_colors) if best_colors else (k+1 if conflicted else max(1, current[v]-1))\n    new = current[:]\n    new[v] = chosen_color\n    new = normalize_colors(new)\n    return (new, \"local\", \"min-conflicts\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    def normalize_colors(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n    if not isinstance(solution, list) or len(solution) != n:\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    curr = normalize_colors(curr)\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    def is_conflicted(sol, i):\n        c = sol[i]\n        for w in adj[i]:\n            if sol[w] == c:\n                return True\n        return False\n    conflicted = [i for i in range(n) if is_conflicted(curr, i)]\n    if conflicted:\n        v0 = random.choice(conflicted)\n    else:\n        # target highest color block to attempt color drop\n        k = max(curr)\n        high = [i for i,x in enumerate(curr) if x == k]\n        v0 = random.choice(high) if high else random.randrange(n)\n    k = max(curr)\n    alt_colors = [c for c in range(1, k+1) if c != curr[v0]]\n    if not alt_colors:\n        alt_colors = [k+1]\n    a = random.choice(alt_colors)\n    c0 = curr[v0]\n    in_chain = [False]*n\n    dq = deque([v0])\n    in_chain[v0] = True\n    while dq:\n        u = dq.popleft()\n        for w in adj[u]:\n            if not in_chain[w] and (curr[w] == c0 or curr[w] == a):\n                in_chain[w] = True\n                dq.append(w)\n    new = curr[:]\n    for i in range(n):\n        if in_chain[i]:\n            new[i] = a if new[i] == c0 else (c0 if new[i] == a else new[i])\n    # small diversification: recolor 1-2 random vertices with least-used colors\n    steps = 1 + (0 if random.random() < 0.5 else 1)\n    for _ in range(steps):\n        i = random.randrange(n)\n        k_now = max(new)\n        # compute color frequencies\n        freq = [0]*(k_now+1)\n        for x in new:\n            freq[x] += 1\n        candidates = list(range(1, k_now+1))\n        random.shuffle(candidates)\n        candidates.sort(key=lambda c: (freq[c], c))\n        # choose the least-used color that is not equal to current and conflicts least\n        best_col = None\n        best_conf = None\n        for col in candidates:\n            if col == new[i]:\n                continue\n            tmp = 0\n            for w in adj[i]:\n                if new[w] == col:\n                    tmp += 1\n            if best_conf is None or tmp < best_conf or (tmp == best_conf and col < (best_col or col)):\n                best_conf = tmp\n                best_col = col\n            if best_conf == 0:\n                break\n        if best_col is None:\n            best_col = k_now if k_now > 1 else 1\n        new[i] = best_col\n    new = normalize_colors(new)\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000962612}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; vertices i=1..9 map to indices i-1; entry values are positive integers representing colors; labels may be non-contiguous during search; normalization may compress labels to contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    HARD_PEN = 10**9\n    PEN_GAP = 10**4\n    PEN_EDGE = 10**6\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != n:\n        return HARD_PEN\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return HARD_PEN\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = k  # integer accumulation\n    seen = set(solution)\n    if len(seen) != k:\n        fitness += PEN_GAP\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    def normalize_colors(sol):\n        # Map unique labels in sorted order to 1..k\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n    # sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    current = normalize_colors(current)\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    conflicted = [i for i in range(n) if v_conflicts(current, i) > 0]\n    if conflicted:\n        maxc = max(v_conflicts(current, i) for i in conflicted)\n        cand_vertices = [i for i in conflicted if v_conflicts(current, i) == maxc]\n        v = random.choice(cand_vertices)\n    else:\n        k = max(current)\n        cand_vertices = [i for i,x in enumerate(current) if x == k]\n        v = random.choice(cand_vertices) if cand_vertices else random.randrange(n)\n    k = max(current)\n    neighbor_colors = set(current[w] for w in adj[v])\n    # Prefer colors not used by neighbors (conflict-free options)\n    conflict_free = [c for c in range(1, k+1) if c != current[v] and c not in neighbor_colors]\n    if conflict_free:\n        # tie-breaker: prefer lowest color to promote compression\n        chosen_color = min(conflict_free)\n    else:\n        # evaluate conflict counts per color within 1..k\n        best_colors = []\n        best_score = None\n        for col in range(1, k+1):\n            if col == current[v]:\n                continue\n            tmp_conf = 0\n            for w in adj[v]:\n                if current[w] == col:\n                    tmp_conf += 1\n            if best_score is None or tmp_conf < best_score:\n                best_score = tmp_conf\n                best_colors = [col]\n            elif tmp_conf == best_score:\n                best_colors.append(col)\n        # Allow k+1 only if it strictly reduces conflicts vs best existing option\n        allow_new = False\n        if best_score is None:\n            allow_new = True\n        elif best_score > 0 and conflicted:\n            allow_new = True\n        if allow_new:\n            tmp_conf_new = 0\n            if best_score is None or tmp_conf_new < best_score:\n                best_colors = [k+1]\n            elif tmp_conf_new == best_score:\n                best_colors.append(k+1)\n        chosen_color = random.choice(best_colors) if best_colors else (k+1 if conflicted else max(1, current[v]-1))\n    new = current[:]\n    new[v] = chosen_color\n    new = normalize_colors(new)\n    return (new, \"local\", \"min-conflicts\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    def normalize_colors(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n    if not isinstance(solution, list) or len(solution) != n:\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    curr = normalize_colors(curr)\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    def is_conflicted(sol, i):\n        c = sol[i]\n        for w in adj[i]:\n            if sol[w] == c:\n                return True\n        return False\n    conflicted = [i for i in range(n) if is_conflicted(curr, i)]\n    if conflicted:\n        v0 = random.choice(conflicted)\n    else:\n        # target highest color block to attempt color drop\n        k = max(curr)\n        high = [i for i,x in enumerate(curr) if x == k]\n        v0 = random.choice(high) if high else random.randrange(n)\n    k = max(curr)\n    alt_colors = [c for c in range(1, k+1) if c != curr[v0]]\n    if not alt_colors:\n        alt_colors = [k+1]\n    a = random.choice(alt_colors)\n    c0 = curr[v0]\n    in_chain = [False]*n\n    dq = deque([v0])\n    in_chain[v0] = True\n    while dq:\n        u = dq.popleft()\n        for w in adj[u]:\n            if not in_chain[w] and (curr[w] == c0 or curr[w] == a):\n                in_chain[w] = True\n                dq.append(w)\n    new = curr[:]\n    for i in range(n):\n        if in_chain[i]:\n            new[i] = a if new[i] == c0 else (c0 if new[i] == a else new[i])\n    # small diversification: recolor 1-2 random vertices with least-used colors\n    steps = 1 + (0 if random.random() < 0.5 else 1)\n    for _ in range(steps):\n        i = random.randrange(n)\n        k_now = max(new)\n        # compute color frequencies\n        freq = [0]*(k_now+1)\n        for x in new:\n            freq[x] += 1\n        candidates = list(range(1, k_now+1))\n        random.shuffle(candidates)\n        candidates.sort(key=lambda c: (freq[c], c))\n        # choose the least-used color that is not equal to current and conflicts least\n        best_col = None\n        best_conf = None\n        for col in candidates:\n            if col == new[i]:\n                continue\n            tmp = 0\n            for w in adj[i]:\n                if new[w] == col:\n                    tmp += 1\n            if best_conf is None or tmp < best_conf or (tmp == best_conf and col < (best_col or col)):\n                best_conf = tmp\n                best_col = col\n            if best_conf == 0:\n                break\n        if best_col is None:\n            best_col = k_now if k_now > 1 else 1\n        new[i] = best_col\n    new = normalize_colors(new)\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001368886}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; vertices i=1..9 map to indices i-1; entry values are positive integers representing colors; labels may be non-contiguous during search; normalization may compress labels to contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    HARD_PEN = 10**9\n    PEN_GAP = 10**4\n    PEN_EDGE = 10**6\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != n:\n        return HARD_PEN\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return HARD_PEN\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return HARD_PEN\n    fitness = k  # integer accumulation\n    seen = set(solution)\n    if len(seen) != k:\n        fitness += PEN_GAP\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    def normalize_colors(sol):\n        # Map unique labels in sorted order to 1..k\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n    # sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        current = [1,2,3,1,2,3,2,1,3]\n    else:\n        current = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    current = normalize_colors(current)\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    conflicted = [i for i in range(n) if v_conflicts(current, i) > 0]\n    if conflicted:\n        maxc = max(v_conflicts(current, i) for i in conflicted)\n        cand_vertices = [i for i in conflicted if v_conflicts(current, i) == maxc]\n        v = random.choice(cand_vertices)\n    else:\n        k = max(current)\n        cand_vertices = [i for i,x in enumerate(current) if x == k]\n        v = random.choice(cand_vertices) if cand_vertices else random.randrange(n)\n    k = max(current)\n    neighbor_colors = set(current[w] for w in adj[v])\n    # Prefer colors not used by neighbors (conflict-free options)\n    conflict_free = [c for c in range(1, k+1) if c != current[v] and c not in neighbor_colors]\n    if conflict_free:\n        # tie-breaker: prefer lowest color to promote compression\n        chosen_color = min(conflict_free)\n    else:\n        # evaluate conflict counts per color within 1..k\n        best_colors = []\n        best_score = None\n        for col in range(1, k+1):\n            if col == current[v]:\n                continue\n            tmp_conf = 0\n            for w in adj[v]:\n                if current[w] == col:\n                    tmp_conf += 1\n            if best_score is None or tmp_conf < best_score:\n                best_score = tmp_conf\n                best_colors = [col]\n            elif tmp_conf == best_score:\n                best_colors.append(col)\n        # Allow k+1 only if it strictly reduces conflicts vs best existing option\n        allow_new = False\n        if best_score is None:\n            allow_new = True\n        elif best_score > 0 and conflicted:\n            allow_new = True\n        if allow_new:\n            tmp_conf_new = 0\n            if best_score is None or tmp_conf_new < best_score:\n                best_colors = [k+1]\n            elif tmp_conf_new == best_score:\n                best_colors.append(k+1)\n        chosen_color = random.choice(best_colors) if best_colors else (k+1 if conflicted else max(1, current[v]-1))\n    new = current[:]\n    new[v] = chosen_color\n    new = normalize_colors(new)\n    return (new, \"local\", \"min-conflicts\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    def normalize_colors(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n    if not isinstance(solution, list) or len(solution) != n:\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    curr = normalize_colors(curr)\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    def is_conflicted(sol, i):\n        c = sol[i]\n        for w in adj[i]:\n            if sol[w] == c:\n                return True\n        return False\n    conflicted = [i for i in range(n) if is_conflicted(curr, i)]\n    if conflicted:\n        v0 = random.choice(conflicted)\n    else:\n        # target highest color block to attempt color drop\n        k = max(curr)\n        high = [i for i,x in enumerate(curr) if x == k]\n        v0 = random.choice(high) if high else random.randrange(n)\n    k = max(curr)\n    alt_colors = [c for c in range(1, k+1) if c != curr[v0]]\n    if not alt_colors:\n        alt_colors = [k+1]\n    a = random.choice(alt_colors)\n    c0 = curr[v0]\n    in_chain = [False]*n\n    dq = deque([v0])\n    in_chain[v0] = True\n    while dq:\n        u = dq.popleft()\n        for w in adj[u]:\n            if not in_chain[w] and (curr[w] == c0 or curr[w] == a):\n                in_chain[w] = True\n                dq.append(w)\n    new = curr[:]\n    for i in range(n):\n        if in_chain[i]:\n            new[i] = a if new[i] == c0 else (c0 if new[i] == a else new[i])\n    # small diversification: recolor 1-2 random vertices with least-used colors\n    steps = 1 + (0 if random.random() < 0.5 else 1)\n    for _ in range(steps):\n        i = random.randrange(n)\n        k_now = max(new)\n        # compute color frequencies\n        freq = [0]*(k_now+1)\n        for x in new:\n            freq[x] += 1\n        candidates = list(range(1, k_now+1))\n        random.shuffle(candidates)\n        candidates.sort(key=lambda c: (freq[c], c))\n        # choose the least-used color that is not equal to current and conflicts least\n        best_col = None\n        best_conf = None\n        for col in candidates:\n            if col == new[i]:\n                continue\n            tmp = 0\n            for w in adj[i]:\n                if new[w] == col:\n                    tmp += 1\n            if best_conf is None or tmp < best_conf or (tmp == best_conf and col < (best_col or col)):\n                best_conf = tmp\n                best_col = col\n            if best_conf == 0:\n                break\n        if best_col is None:\n            best_col = k_now if k_now > 1 else 1\n        new[i] = best_col\n    new = normalize_colors(new)\n    return new\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001308736}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; index i-1 corresponds to vertex i; each entry is a positive int color label; labels may be non-contiguous during search; normalization maps unique labels to contiguous {1..k} in order of appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Hardened, label-invariant evaluator. Minimizes k with heavy edge-conflict penalties.\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**6\n    # Validate input type\/length\/positivity\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    n = 9\n    if len(solution) != n:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n    # Normalize labels to contiguous {1..k} in stable order of first appearance\n    mapping = {}\n    nextc = 1\n    norm = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        norm.append(mapping[x])\n    # Compute k and conflicts\n    k = len(mapping)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for (u, v) in edges:\n        if norm[u-1] == norm[v-1]:\n            conflicts += 1\n    fitness = PEN_EDGE * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if (isinstance(x, int) and x > 0) else 1 for x in solution]\n    # Helper: conflicts per vertex\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    # Select vertex: prioritize conflicted with tie-break on degree then random\n    conflicted = [i for i in range(n) if v_conflicts(curr, i) > 0]\n    if conflicted:\n        best_cf = max(v_conflicts(curr, i) for i in conflicted)\n        pool = [i for i in conflicted if v_conflicts(curr, i) == best_cf]\n        # degree tie-break\n        degs = [len(adj[i]) for i in pool]\n        maxdeg = max(degs)\n        pool2 = [i for i in pool if len(adj[i]) == maxdeg]\n        v = random.choice(pool2)\n    else:\n        # No conflicts: try compressing highest color class\n        k = max(curr)\n        candidates = [i for i, x in enumerate(curr) if x == k]\n        v = random.choice(candidates) if candidates else random.randrange(n)\n    k = max(curr)\n    # Try min-conflicts recolor on v within existing colors\n    neighbor_colors = set(curr[w] for w in adj[v])\n    # Prefer colors not present in neighborhood\n    candidates = [c for c in range(1, k+1) if c != curr[v] and c not in neighbor_colors]\n    move_type = \"min-conflicts\"\n    if not candidates:\n        # Evaluate colors by induced conflicts; gate introduction of k+1\n        best_cols = []\n        best_conf = None\n        for col in range(1, k+1):\n            if col == curr[v]:\n                continue\n            tmp = 0\n            for w in adj[v]:\n                if curr[w] == col:\n                    tmp += 1\n            if best_conf is None or tmp < best_conf:\n                best_conf = tmp\n                best_cols = [col]\n            elif tmp == best_conf:\n                best_cols.append(col)\n        # Allow k+1 only if v is conflicted and best existing option still leaves conflict\n        if v_conflicts(curr, v) > 0 and (best_conf is None or best_conf > 0):\n            best_cols.append(k+1)\n        candidates = best_cols if best_cols else [max(1, curr[v]-1)]\n    # With small probability, attempt a small Kempe-chain flip between current[v] and chosen color\n    chosen = random.choice(candidates)\n    new = curr[:]\n    if chosen != curr[v] and random.random() < 0.25:\n        from collections import deque\n        c0, c1 = curr[v], chosen\n        in_chain = [False]*n\n        dq = deque([v])\n        in_chain[v] = True\n        while dq:\n            u = dq.popleft()\n            for w in adj[u]:\n                if not in_chain[w] and (curr[w] == c0 or curr[w] == c1):\n                    in_chain[w] = True\n                    dq.append(w)\n        for i in range(n):\n            if in_chain[i]:\n                new[i] = c1 if curr[i] == c0 else (c0 if curr[i] == c1 else curr[i])\n        move_type = \"kempe-swap\"\n    else:\n        new[v] = chosen\n    # Normalize labels to contiguous 1..k' preserving relative order of first appearance\n    mapping = {}\n    nextc = 1\n    for i in range(n):\n        x = new[i]\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        new[i] = mapping[x]\n    return (new, \"local\", move_type)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Returns a diversified solution of the same representation (LIST_INT_LEN9)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if (isinstance(x, int) and x > 0) else 1 for x in solution]\n    # Helper\n    def conflicts_at(sol, i):\n        c = sol[i]\n        for w in adj[i]:\n            if sol[w] == c:\n                return True\n        return False\n    new = curr[:]\n    # Step 1: random recolors on t vertices (biased to conflicted if any)\n    t = 2\n    for _ in range(t):\n        conflicted = [i for i in range(n) if conflicts_at(new, i)]\n        if conflicted:\n            i = random.choice(conflicted)\n        else:\n            i = random.randrange(n)\n        k = max(new)\n        # Try a random existing color different from current; fallback k+1\n        choices = [c for c in range(1, k+1) if c != new[i]]\n        if not choices:\n            choices = [k+1]\n        col = random.choice(choices)\n        new[i] = col\n    # Step 2: Kempe-chain swap along a random edge or around a random vertex\n    if random.random() < 0.9:\n        # pick an edge with endpoints having different colors if possible\n        diff_edges = []\n        for (u, v) in edges:\n            if new[u-1] != new[v-1]:\n                diff_edges.append((u-1, v-1))\n        if diff_edges:\n            a, b = random.choice(diff_edges)\n            c0, c1 = new[a], new[b]\n        else:\n            v = random.randrange(n)\n            k = max(new)\n            c0 = new[v]\n            c1 = random.choice([c for c in range(1, k+1) if c != c0]) if k > 1 else c0\n        # BFS over Kempe chain of colors c0 and c1 starting at a\n        start = a if diff_edges else v\n        in_chain = [False]*n\n        dq = deque([start])\n        in_chain[start] = True\n        while dq:\n            u = dq.popleft()\n            for w in adj[u]:\n                if not in_chain[w] and (new[w] == c0 or new[w] == c1):\n                    in_chain[w] = True\n                    dq.append(w)\n        for i in range(n):\n            if in_chain[i]:\n                new[i] = c1 if new[i] == c0 else (c0 if new[i] == c1 else new[i])\n    # Step 3: optional color-class merge attempt to reduce k\n    if random.random() < 0.5:\n        k = max(new)\n        if k >= 2:\n            # try to relabel highest color to a lower feasible color greedily\n            target_color = k\n            verts = [i for i, x in enumerate(new) if x == target_color]\n            random.shuffle(verts)\n            for v in verts:\n                # choose lowest feasible color in 1..k-1\n                for col in range(1, k):\n                    if col == new[v]:\n                        continue\n                    feas = True\n                    for w in adj[v]:\n                        if new[w] == col:\n                            feas = False\n                            break\n                    if feas:\n                        new[v] = col\n                        break\n    # Normalize labels to contiguous 1..k' in order of first appearance\n    mapping = {}\n    nextc = 1\n    for i in range(n):\n        x = new[i]\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        new[i] = mapping[x]\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001141023}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; index i-1 corresponds to vertex i; each entry is a positive int color label; labels may be non-contiguous during search; normalization maps unique labels to contiguous {1..k} in order of appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Hardened, label-invariant evaluator. Minimizes k with heavy edge-conflict penalties.\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**6\n    # Validate input type\/length\/positivity\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    n = 9\n    if len(solution) != n:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n    # Normalize labels to contiguous {1..k} in stable order of first appearance\n    mapping = {}\n    nextc = 1\n    norm = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        norm.append(mapping[x])\n    # Compute k and conflicts\n    k = len(mapping)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for (u, v) in edges:\n        if norm[u-1] == norm[v-1]:\n            conflicts += 1\n    fitness = PEN_EDGE * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if (isinstance(x, int) and x > 0) else 1 for x in solution]\n    # Helper: conflicts per vertex\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    # Select vertex: prioritize conflicted with tie-break on degree then random\n    conflicted = [i for i in range(n) if v_conflicts(curr, i) > 0]\n    if conflicted:\n        best_cf = max(v_conflicts(curr, i) for i in conflicted)\n        pool = [i for i in conflicted if v_conflicts(curr, i) == best_cf]\n        # degree tie-break\n        degs = [len(adj[i]) for i in pool]\n        maxdeg = max(degs)\n        pool2 = [i for i in pool if len(adj[i]) == maxdeg]\n        v = random.choice(pool2)\n    else:\n        # No conflicts: try compressing highest color class\n        k = max(curr)\n        candidates = [i for i, x in enumerate(curr) if x == k]\n        v = random.choice(candidates) if candidates else random.randrange(n)\n    k = max(curr)\n    # Try min-conflicts recolor on v within existing colors\n    neighbor_colors = set(curr[w] for w in adj[v])\n    # Prefer colors not present in neighborhood\n    candidates = [c for c in range(1, k+1) if c != curr[v] and c not in neighbor_colors]\n    move_type = \"min-conflicts\"\n    if not candidates:\n        # Evaluate colors by induced conflicts; gate introduction of k+1\n        best_cols = []\n        best_conf = None\n        for col in range(1, k+1):\n            if col == curr[v]:\n                continue\n            tmp = 0\n            for w in adj[v]:\n                if curr[w] == col:\n                    tmp += 1\n            if best_conf is None or tmp < best_conf:\n                best_conf = tmp\n                best_cols = [col]\n            elif tmp == best_conf:\n                best_cols.append(col)\n        # Allow k+1 only if v is conflicted and best existing option still leaves conflict\n        if v_conflicts(curr, v) > 0 and (best_conf is None or best_conf > 0):\n            best_cols.append(k+1)\n        candidates = best_cols if best_cols else [max(1, curr[v]-1)]\n    # With small probability, attempt a small Kempe-chain flip between current[v] and chosen color\n    chosen = random.choice(candidates)\n    new = curr[:]\n    if chosen != curr[v] and random.random() < 0.25:\n        from collections import deque\n        c0, c1 = curr[v], chosen\n        in_chain = [False]*n\n        dq = deque([v])\n        in_chain[v] = True\n        while dq:\n            u = dq.popleft()\n            for w in adj[u]:\n                if not in_chain[w] and (curr[w] == c0 or curr[w] == c1):\n                    in_chain[w] = True\n                    dq.append(w)\n        for i in range(n):\n            if in_chain[i]:\n                new[i] = c1 if curr[i] == c0 else (c0 if curr[i] == c1 else curr[i])\n        move_type = \"kempe-swap\"\n    else:\n        new[v] = chosen\n    # Normalize labels to contiguous 1..k' preserving relative order of first appearance\n    mapping = {}\n    nextc = 1\n    for i in range(n):\n        x = new[i]\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        new[i] = mapping[x]\n    return (new, \"local\", move_type)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Returns a diversified solution of the same representation (LIST_INT_LEN9)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if (isinstance(x, int) and x > 0) else 1 for x in solution]\n    # Helper\n    def conflicts_at(sol, i):\n        c = sol[i]\n        for w in adj[i]:\n            if sol[w] == c:\n                return True\n        return False\n    new = curr[:]\n    # Step 1: random recolors on t vertices (biased to conflicted if any)\n    t = 2\n    for _ in range(t):\n        conflicted = [i for i in range(n) if conflicts_at(new, i)]\n        if conflicted:\n            i = random.choice(conflicted)\n        else:\n            i = random.randrange(n)\n        k = max(new)\n        # Try a random existing color different from current; fallback k+1\n        choices = [c for c in range(1, k+1) if c != new[i]]\n        if not choices:\n            choices = [k+1]\n        col = random.choice(choices)\n        new[i] = col\n    # Step 2: Kempe-chain swap along a random edge or around a random vertex\n    if random.random() < 0.9:\n        # pick an edge with endpoints having different colors if possible\n        diff_edges = []\n        for (u, v) in edges:\n            if new[u-1] != new[v-1]:\n                diff_edges.append((u-1, v-1))\n        if diff_edges:\n            a, b = random.choice(diff_edges)\n            c0, c1 = new[a], new[b]\n        else:\n            v = random.randrange(n)\n            k = max(new)\n            c0 = new[v]\n            c1 = random.choice([c for c in range(1, k+1) if c != c0]) if k > 1 else c0\n        # BFS over Kempe chain of colors c0 and c1 starting at a\n        start = a if diff_edges else v\n        in_chain = [False]*n\n        dq = deque([start])\n        in_chain[start] = True\n        while dq:\n            u = dq.popleft()\n            for w in adj[u]:\n                if not in_chain[w] and (new[w] == c0 or new[w] == c1):\n                    in_chain[w] = True\n                    dq.append(w)\n        for i in range(n):\n            if in_chain[i]:\n                new[i] = c1 if new[i] == c0 else (c0 if new[i] == c1 else new[i])\n    # Step 3: optional color-class merge attempt to reduce k\n    if random.random() < 0.5:\n        k = max(new)\n        if k >= 2:\n            # try to relabel highest color to a lower feasible color greedily\n            target_color = k\n            verts = [i for i, x in enumerate(new) if x == target_color]\n            random.shuffle(verts)\n            for v in verts:\n                # choose lowest feasible color in 1..k-1\n                for col in range(1, k):\n                    if col == new[v]:\n                        continue\n                    feas = True\n                    for w in adj[v]:\n                        if new[w] == col:\n                            feas = False\n                            break\n                    if feas:\n                        new[v] = col\n                        break\n    # Normalize labels to contiguous 1..k' in order of first appearance\n    mapping = {}\n    nextc = 1\n    for i in range(n):\n        x = new[i]\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        new[i] = mapping[x]\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001582439}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN9; index i-1 corresponds to vertex i; each entry is a positive int color label; labels may be non-contiguous during search; normalization maps unique labels to contiguous {1..k} in order of appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Hardened, label-invariant evaluator. Minimizes k with heavy edge-conflict penalties.\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**6\n    # Validate input type\/length\/positivity\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    n = 9\n    if len(solution) != n:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n    # Normalize labels to contiguous {1..k} in stable order of first appearance\n    mapping = {}\n    nextc = 1\n    norm = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        norm.append(mapping[x])\n    # Compute k and conflicts\n    k = len(mapping)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for (u, v) in edges:\n        if norm[u-1] == norm[v-1]:\n            conflicts += 1\n    fitness = PEN_EDGE * conflicts + k\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if (isinstance(x, int) and x > 0) else 1 for x in solution]\n    # Helper: conflicts per vertex\n    def v_conflicts(sol, v):\n        c = sol[v]\n        cnt = 0\n        for w in adj[v]:\n            if sol[w] == c:\n                cnt += 1\n        return cnt\n    # Select vertex: prioritize conflicted with tie-break on degree then random\n    conflicted = [i for i in range(n) if v_conflicts(curr, i) > 0]\n    if conflicted:\n        best_cf = max(v_conflicts(curr, i) for i in conflicted)\n        pool = [i for i in conflicted if v_conflicts(curr, i) == best_cf]\n        # degree tie-break\n        degs = [len(adj[i]) for i in pool]\n        maxdeg = max(degs)\n        pool2 = [i for i in pool if len(adj[i]) == maxdeg]\n        v = random.choice(pool2)\n    else:\n        # No conflicts: try compressing highest color class\n        k = max(curr)\n        candidates = [i for i, x in enumerate(curr) if x == k]\n        v = random.choice(candidates) if candidates else random.randrange(n)\n    k = max(curr)\n    # Try min-conflicts recolor on v within existing colors\n    neighbor_colors = set(curr[w] for w in adj[v])\n    # Prefer colors not present in neighborhood\n    candidates = [c for c in range(1, k+1) if c != curr[v] and c not in neighbor_colors]\n    move_type = \"min-conflicts\"\n    if not candidates:\n        # Evaluate colors by induced conflicts; gate introduction of k+1\n        best_cols = []\n        best_conf = None\n        for col in range(1, k+1):\n            if col == curr[v]:\n                continue\n            tmp = 0\n            for w in adj[v]:\n                if curr[w] == col:\n                    tmp += 1\n            if best_conf is None or tmp < best_conf:\n                best_conf = tmp\n                best_cols = [col]\n            elif tmp == best_conf:\n                best_cols.append(col)\n        # Allow k+1 only if v is conflicted and best existing option still leaves conflict\n        if v_conflicts(curr, v) > 0 and (best_conf is None or best_conf > 0):\n            best_cols.append(k+1)\n        candidates = best_cols if best_cols else [max(1, curr[v]-1)]\n    # With small probability, attempt a small Kempe-chain flip between current[v] and chosen color\n    chosen = random.choice(candidates)\n    new = curr[:]\n    if chosen != curr[v] and random.random() < 0.25:\n        from collections import deque\n        c0, c1 = curr[v], chosen\n        in_chain = [False]*n\n        dq = deque([v])\n        in_chain[v] = True\n        while dq:\n            u = dq.popleft()\n            for w in adj[u]:\n                if not in_chain[w] and (curr[w] == c0 or curr[w] == c1):\n                    in_chain[w] = True\n                    dq.append(w)\n        for i in range(n):\n            if in_chain[i]:\n                new[i] = c1 if curr[i] == c0 else (c0 if curr[i] == c1 else curr[i])\n        move_type = \"kempe-swap\"\n    else:\n        new[v] = chosen\n    # Normalize labels to contiguous 1..k' preserving relative order of first appearance\n    mapping = {}\n    nextc = 1\n    for i in range(n):\n        x = new[i]\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        new[i] = mapping[x]\n    return (new, \"local\", move_type)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Returns a diversified solution of the same representation (LIST_INT_LEN9)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Sanitize\/seed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        curr = [1,2,3,1,2,3,2,1,3]\n    else:\n        curr = [int(x) if (isinstance(x, int) and x > 0) else 1 for x in solution]\n    # Helper\n    def conflicts_at(sol, i):\n        c = sol[i]\n        for w in adj[i]:\n            if sol[w] == c:\n                return True\n        return False\n    new = curr[:]\n    # Step 1: random recolors on t vertices (biased to conflicted if any)\n    t = 2\n    for _ in range(t):\n        conflicted = [i for i in range(n) if conflicts_at(new, i)]\n        if conflicted:\n            i = random.choice(conflicted)\n        else:\n            i = random.randrange(n)\n        k = max(new)\n        # Try a random existing color different from current; fallback k+1\n        choices = [c for c in range(1, k+1) if c != new[i]]\n        if not choices:\n            choices = [k+1]\n        col = random.choice(choices)\n        new[i] = col\n    # Step 2: Kempe-chain swap along a random edge or around a random vertex\n    if random.random() < 0.9:\n        # pick an edge with endpoints having different colors if possible\n        diff_edges = []\n        for (u, v) in edges:\n            if new[u-1] != new[v-1]:\n                diff_edges.append((u-1, v-1))\n        if diff_edges:\n            a, b = random.choice(diff_edges)\n            c0, c1 = new[a], new[b]\n        else:\n            v = random.randrange(n)\n            k = max(new)\n            c0 = new[v]\n            c1 = random.choice([c for c in range(1, k+1) if c != c0]) if k > 1 else c0\n        # BFS over Kempe chain of colors c0 and c1 starting at a\n        start = a if diff_edges else v\n        in_chain = [False]*n\n        dq = deque([start])\n        in_chain[start] = True\n        while dq:\n            u = dq.popleft()\n            for w in adj[u]:\n                if not in_chain[w] and (new[w] == c0 or new[w] == c1):\n                    in_chain[w] = True\n                    dq.append(w)\n        for i in range(n):\n            if in_chain[i]:\n                new[i] = c1 if new[i] == c0 else (c0 if new[i] == c1 else new[i])\n    # Step 3: optional color-class merge attempt to reduce k\n    if random.random() < 0.5:\n        k = max(new)\n        if k >= 2:\n            # try to relabel highest color to a lower feasible color greedily\n            target_color = k\n            verts = [i for i, x in enumerate(new) if x == target_color]\n            random.shuffle(verts)\n            for v in verts:\n                # choose lowest feasible color in 1..k-1\n                for col in range(1, k):\n                    if col == new[v]:\n                        continue\n                    feas = True\n                    for w in adj[v]:\n                        if new[w] == col:\n                            feas = False\n                            break\n                    if feas:\n                        new[v] = col\n                        break\n    # Normalize labels to contiguous 1..k' in order of first appearance\n    mapping = {}\n    nextc = 1\n    for i in range(n):\n        x = new[i]\n        if x not in mapping:\n            mapping[x] = nextc\n            nextc += 1\n        new[i] = mapping[x]\n    return new\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001809732}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE. A solution is a Python list of 9 positive integers [x1,...,x9], 1-indexed to students.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution) -> int:\n    # Lower is better. Penalize any constraint violation heavily.\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed students)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000","Vecindad":"from typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Deterministic greedy-repair\/improve neighbor.\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: 'GreedyRecolor'\n    \"\"\"\n    # Validate input defensively and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s = solution[:]  # clone\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def smallest_feasible_color(node: int, cur: List[int]) -> int:\n        used = {cur[v-1] for v in adj[node]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n\n    # Step 1: if any conflict, repair first in lexicographic edge order\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            # Recolor the endpoint that yields the smaller new color (tie-break by node id)\n            cu = smallest_feasible_color(u, s)\n            cv = smallest_feasible_color(v, s)\n            if cu < cv or (cu == cv and u < v):\n                s[u-1] = cu\n            else:\n                s[v-1] = cv\n            return s, (\"Local\", \"GreedyRecolor\")\n\n    # Step 2: try to reduce number of colors by relabeling a high label downwards\n    # Identify current colors and attempt to lower labels where feasible\n    colors_sorted = sorted(set(s), reverse=True)\n    for color in colors_sorted:\n        # Try to move a node from this color down to a smaller feasible color\n        nodes = [i for i in range(1, n+1) if s[i-1] == color]\n        for u in nodes:\n            target = 1\n            used = {s[v-1] for v in adj[u]}\n            while target in used and target < color:\n                target += 1\n            if target < color and target not in used:\n                s[u-1] = target\n                return s, (\"Local\", \"GreedyRecolor\")\n\n    # Step 3: if no improvement possible, apply a neutral recolor to change basin\n    # Choose the highest-index node and recolor to smallest feasible color (may be same)\n    u = n\n    s[u-1] = smallest_feasible_color(u, s)\n    return s, (\"Local\", \"GreedyRecolor\")","Perturbacion":"from typing import List, Tuple\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger deterministic shake: two-phase recolor and optional color compression.\n    Returns a perturbed solution (same representation).\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def smallest_feasible_color(node: int, cur: List[int]) -> int:\n        used = {cur[v-1] for v in adj[node]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n\n    # Phase 1: re-color two strategically chosen nodes\n    # a) Node with largest degree, push to smallest feasible color\n    degrees = {i: len(adj[i]) for i in range(1, n+1)}\n    u1 = max(range(1, n+1), key=lambda i: (degrees[i], i))\n    s[u1-1] = smallest_feasible_color(u1, s)\n\n    # b) Highest-index node not adjacent to u1, recolor as well (or fallback to highest-index)\n    candidates = [i for i in range(n, 0, -1) if i != u1 and i not in adj[u1]]\n    u2 = candidates[0] if candidates else (n if n != u1 else n-1)\n    if u2 >= 1:\n        s[u2-1] = smallest_feasible_color(u2, s)\n\n    # Phase 2: Color compression (relabel downwards when safe)\n    colors = sorted(set(s))\n    mapping = {}\n    next_label = 1\n    for c in colors:\n        # Attempt to map to the lowest available label maintaining feasibility greedily\n        # Build temporary reassignment check per color class\n        mapping[c] = next_label\n        next_label += 1\n    # Apply mapping then try a greedy pass to lower labels further where possible\n    s = [mapping[c] for c in s]\n\n    # Greedy lowering sweep\n    changed = True\n    while changed:\n        changed = False\n        for u in range(1, n+1):\n            used = {s[v-1] for v in adj[u]}\n            best = s[u-1]\n            c = 1\n            while c < best:\n                if c not in used:\n                    best = c\n                    break\n                c += 1\n            if best < s[u-1]:\n                s[u-1] = best\n                changed = True\n    return s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000617118}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE. A solution is a Python list of 9 positive integers [x1,...,x9], 1-indexed to students.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution) -> int:\n    # Lower is better. Penalize any constraint violation heavily.\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed students)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000","Vecindad":"from typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Deterministic greedy-repair\/improve neighbor.\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: 'GreedyRecolor'\n    \"\"\"\n    # Validate input defensively and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s = solution[:]  # clone\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def smallest_feasible_color(node: int, cur: List[int]) -> int:\n        used = {cur[v-1] for v in adj[node]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n\n    # Step 1: if any conflict, repair first in lexicographic edge order\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            # Recolor the endpoint that yields the smaller new color (tie-break by node id)\n            cu = smallest_feasible_color(u, s)\n            cv = smallest_feasible_color(v, s)\n            if cu < cv or (cu == cv and u < v):\n                s[u-1] = cu\n            else:\n                s[v-1] = cv\n            return s, (\"Local\", \"GreedyRecolor\")\n\n    # Step 2: try to reduce number of colors by relabeling a high label downwards\n    # Identify current colors and attempt to lower labels where feasible\n    colors_sorted = sorted(set(s), reverse=True)\n    for color in colors_sorted:\n        # Try to move a node from this color down to a smaller feasible color\n        nodes = [i for i in range(1, n+1) if s[i-1] == color]\n        for u in nodes:\n            target = 1\n            used = {s[v-1] for v in adj[u]}\n            while target in used and target < color:\n                target += 1\n            if target < color and target not in used:\n                s[u-1] = target\n                return s, (\"Local\", \"GreedyRecolor\")\n\n    # Step 3: if no improvement possible, apply a neutral recolor to change basin\n    # Choose the highest-index node and recolor to smallest feasible color (may be same)\n    u = n\n    s[u-1] = smallest_feasible_color(u, s)\n    return s, (\"Local\", \"GreedyRecolor\")","Perturbacion":"from typing import List, Tuple\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger deterministic shake: two-phase recolor and optional color compression.\n    Returns a perturbed solution (same representation).\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def smallest_feasible_color(node: int, cur: List[int]) -> int:\n        used = {cur[v-1] for v in adj[node]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n\n    # Phase 1: re-color two strategically chosen nodes\n    # a) Node with largest degree, push to smallest feasible color\n    degrees = {i: len(adj[i]) for i in range(1, n+1)}\n    u1 = max(range(1, n+1), key=lambda i: (degrees[i], i))\n    s[u1-1] = smallest_feasible_color(u1, s)\n\n    # b) Highest-index node not adjacent to u1, recolor as well (or fallback to highest-index)\n    candidates = [i for i in range(n, 0, -1) if i != u1 and i not in adj[u1]]\n    u2 = candidates[0] if candidates else (n if n != u1 else n-1)\n    if u2 >= 1:\n        s[u2-1] = smallest_feasible_color(u2, s)\n\n    # Phase 2: Color compression (relabel downwards when safe)\n    colors = sorted(set(s))\n    mapping = {}\n    next_label = 1\n    for c in colors:\n        # Attempt to map to the lowest available label maintaining feasibility greedily\n        # Build temporary reassignment check per color class\n        mapping[c] = next_label\n        next_label += 1\n    # Apply mapping then try a greedy pass to lower labels further where possible\n    s = [mapping[c] for c in s]\n\n    # Greedy lowering sweep\n    changed = True\n    while changed:\n        changed = False\n        for u in range(1, n+1):\n            used = {s[v-1] for v in adj[u]}\n            best = s[u-1]\n            c = 1\n            while c < best:\n                if c not in used:\n                    best = c\n                    break\n                c += 1\n            if best < s[u-1]:\n                s[u-1] = best\n                changed = True\n    return s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000923671}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE. A solution is a Python list of 9 positive integers [x1,...,x9], 1-indexed to students.","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution) -> int:\n    # Lower is better. Penalize any constraint violation heavily.\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed students)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000","Vecindad":"from typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Deterministic greedy-repair\/improve neighbor.\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: 'GreedyRecolor'\n    \"\"\"\n    # Validate input defensively and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s = solution[:]  # clone\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def smallest_feasible_color(node: int, cur: List[int]) -> int:\n        used = {cur[v-1] for v in adj[node]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n\n    # Step 1: if any conflict, repair first in lexicographic edge order\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            # Recolor the endpoint that yields the smaller new color (tie-break by node id)\n            cu = smallest_feasible_color(u, s)\n            cv = smallest_feasible_color(v, s)\n            if cu < cv or (cu == cv and u < v):\n                s[u-1] = cu\n            else:\n                s[v-1] = cv\n            return s, (\"Local\", \"GreedyRecolor\")\n\n    # Step 2: try to reduce number of colors by relabeling a high label downwards\n    # Identify current colors and attempt to lower labels where feasible\n    colors_sorted = sorted(set(s), reverse=True)\n    for color in colors_sorted:\n        # Try to move a node from this color down to a smaller feasible color\n        nodes = [i for i in range(1, n+1) if s[i-1] == color]\n        for u in nodes:\n            target = 1\n            used = {s[v-1] for v in adj[u]}\n            while target in used and target < color:\n                target += 1\n            if target < color and target not in used:\n                s[u-1] = target\n                return s, (\"Local\", \"GreedyRecolor\")\n\n    # Step 3: if no improvement possible, apply a neutral recolor to change basin\n    # Choose the highest-index node and recolor to smallest feasible color (may be same)\n    u = n\n    s[u-1] = smallest_feasible_color(u, s)\n    return s, (\"Local\", \"GreedyRecolor\")","Perturbacion":"from typing import List, Tuple\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger deterministic shake: two-phase recolor and optional color compression.\n    Returns a perturbed solution (same representation).\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def smallest_feasible_color(node: int, cur: List[int]) -> int:\n        used = {cur[v-1] for v in adj[node]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n\n    # Phase 1: re-color two strategically chosen nodes\n    # a) Node with largest degree, push to smallest feasible color\n    degrees = {i: len(adj[i]) for i in range(1, n+1)}\n    u1 = max(range(1, n+1), key=lambda i: (degrees[i], i))\n    s[u1-1] = smallest_feasible_color(u1, s)\n\n    # b) Highest-index node not adjacent to u1, recolor as well (or fallback to highest-index)\n    candidates = [i for i in range(n, 0, -1) if i != u1 and i not in adj[u1]]\n    u2 = candidates[0] if candidates else (n if n != u1 else n-1)\n    if u2 >= 1:\n        s[u2-1] = smallest_feasible_color(u2, s)\n\n    # Phase 2: Color compression (relabel downwards when safe)\n    colors = sorted(set(s))\n    mapping = {}\n    next_label = 1\n    for c in colors:\n        # Attempt to map to the lowest available label maintaining feasibility greedily\n        # Build temporary reassignment check per color class\n        mapping[c] = next_label\n        next_label += 1\n    # Apply mapping then try a greedy pass to lower labels further where possible\n    s = [mapping[c] for c in s]\n\n    # Greedy lowering sweep\n    changed = True\n    while changed:\n        changed = False\n        for u in range(1, n+1):\n            used = {s[v-1] for v in adj[u]}\n            best = s[u-1]\n            c = 1\n            while c < best:\n                if c not in used:\n                    best = c\n                    break\n                c += 1\n            if best < s[u-1]:\n                s[u-1] = best\n                changed = True\n    return s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000989541}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = solution[:]\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        # Map labels to 1..k in ascending order of appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        # Search up to current max+1\n        kmax = max(cur) + 1\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    def has_conflicts(cur: List[int]) -> bool:\n        for u, v in edges:\n            if cur[u-1] == cur[v-1]:\n                return True\n        return False\n\n    # Step 1: If conflicts, repair a random conflicting edge by recoloring one endpoint\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        # Choose endpoint by higher degree or random tie\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        # Prefer smallest colors to limit palette\n        if feas:\n            # Randomize among minimal colors that are <= current color if available\n            curc = s[target-1]\n            leq = [c for c in feas if c <= curc]\n            pick_from = leq if leq else feas\n            s[target-1] = random.choice(pick_from)\n            s = normalize_labels(s)\n            return s, (\"Local\", \"Repair\")\n        # Fallback: swap color with a neighbor if possible (rare)\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: Try color reduction by moving a vertex from the highest color down\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                # Random among the smallest few to diversify\n                feas_below.sort()\n                pick = random.choice(feas_below[:min(2, len(feas_below))])\n                s[u-1] = pick\n                s = normalize_labels(s)\n                return s, (\"Local\", \"ReduceColor\")\n\n    # Step 3: Kempe-chain swap between two colors to unlock reductions\n    # Pick two different colors present; if only one, skip\n    colors = list(sorted(set(s)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Choose a random pivot vertex colored c1 or c2\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {c1, c2}\n            # Build Kempe chain component induced by colors c1 and c2\n            visited: Set[int] = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                visited.add(u)\n                for v in adj[u]:\n                    if s[v-1] in target_colors and v not in visited:\n                        stack.append(v)\n            # Swap colors within the component\n            for u in visited:\n                s[u-1] = c1 if s[u-1] == c2 else (c2 if s[u-1] == c1 else s[u-1])\n            s = normalize_labels(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor on a random vertex to an alternative feasible color\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    if len(feas) >= 2:\n        # Choose a feasible color different from current, bias toward small\n        alt = [c for c in feas if c != s[u-1]]\n        alt.sort()\n        pick = random.choice(alt[:min(2, len(alt))])\n        s[u-1] = pick\n    else:\n        # If only one feasible (possibly equal), force smallest feasible\n        if feas:\n            s[u-1] = min(feas)\n    s = normalize_labels(s)\n    return s, (\"Local\", \"Diversify\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using multiple randomized moves:\n    - Random Kempe-chain swaps (1-2 times)\n    - Random recolor of a high-label vertex\n    - Label compression\/normalization\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = solution[:]\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap_once(cur: List[int]) -> List[int]:\n        colors = list(sorted(set(cur)))\n        if len(colors) < 2:\n            return cur\n        c1, c2 = random.sample(colors, 2)\n        # Pick pivot among vertices colored c1 or c2\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        start = random.choice(candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        # Swap within component\n        for u in visited:\n            cur[u-1] = c1 if cur[u-1] == c2 else (c2 if cur[u-1] == c1 else cur[u-1])\n        return cur\n\n    # Apply 1-2 Kempe swaps\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s)\n        s = normalize_labels(s)\n\n    # Recolor a high-label vertex to a feasible alternative if possible\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        candidates = [i for i in range(1, n+1) if s[i-1] == high]\n        if candidates:\n            u = random.choice(candidates)\n            # Compute feasible colors up to max+1\n            used = {s[v-1] for v in adj[u]}\n            kmax = max(s) + 1\n            feas = [c for c in range(1, kmax+1) if c not in used]\n            alt = [c for c in feas if c < high] or [c for c in feas if c != s[u-1]]\n            if alt:\n                # Bias toward smaller labels\n                alt.sort()\n                s[u-1] = random.choice(alt[:min(2, len(alt))])\n\n    # Final normalization\/compression\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001108783}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = solution[:]\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        # Map labels to 1..k in ascending order of appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        # Search up to current max+1\n        kmax = max(cur) + 1\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    def has_conflicts(cur: List[int]) -> bool:\n        for u, v in edges:\n            if cur[u-1] == cur[v-1]:\n                return True\n        return False\n\n    # Step 1: If conflicts, repair a random conflicting edge by recoloring one endpoint\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        # Choose endpoint by higher degree or random tie\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        # Prefer smallest colors to limit palette\n        if feas:\n            # Randomize among minimal colors that are <= current color if available\n            curc = s[target-1]\n            leq = [c for c in feas if c <= curc]\n            pick_from = leq if leq else feas\n            s[target-1] = random.choice(pick_from)\n            s = normalize_labels(s)\n            return s, (\"Local\", \"Repair\")\n        # Fallback: swap color with a neighbor if possible (rare)\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: Try color reduction by moving a vertex from the highest color down\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                # Random among the smallest few to diversify\n                feas_below.sort()\n                pick = random.choice(feas_below[:min(2, len(feas_below))])\n                s[u-1] = pick\n                s = normalize_labels(s)\n                return s, (\"Local\", \"ReduceColor\")\n\n    # Step 3: Kempe-chain swap between two colors to unlock reductions\n    # Pick two different colors present; if only one, skip\n    colors = list(sorted(set(s)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Choose a random pivot vertex colored c1 or c2\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {c1, c2}\n            # Build Kempe chain component induced by colors c1 and c2\n            visited: Set[int] = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                visited.add(u)\n                for v in adj[u]:\n                    if s[v-1] in target_colors and v not in visited:\n                        stack.append(v)\n            # Swap colors within the component\n            for u in visited:\n                s[u-1] = c1 if s[u-1] == c2 else (c2 if s[u-1] == c1 else s[u-1])\n            s = normalize_labels(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor on a random vertex to an alternative feasible color\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    if len(feas) >= 2:\n        # Choose a feasible color different from current, bias toward small\n        alt = [c for c in feas if c != s[u-1]]\n        alt.sort()\n        pick = random.choice(alt[:min(2, len(alt))])\n        s[u-1] = pick\n    else:\n        # If only one feasible (possibly equal), force smallest feasible\n        if feas:\n            s[u-1] = min(feas)\n    s = normalize_labels(s)\n    return s, (\"Local\", \"Diversify\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using multiple randomized moves:\n    - Random Kempe-chain swaps (1-2 times)\n    - Random recolor of a high-label vertex\n    - Label compression\/normalization\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = solution[:]\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap_once(cur: List[int]) -> List[int]:\n        colors = list(sorted(set(cur)))\n        if len(colors) < 2:\n            return cur\n        c1, c2 = random.sample(colors, 2)\n        # Pick pivot among vertices colored c1 or c2\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        start = random.choice(candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        # Swap within component\n        for u in visited:\n            cur[u-1] = c1 if cur[u-1] == c2 else (c2 if cur[u-1] == c1 else cur[u-1])\n        return cur\n\n    # Apply 1-2 Kempe swaps\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s)\n        s = normalize_labels(s)\n\n    # Recolor a high-label vertex to a feasible alternative if possible\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        candidates = [i for i in range(1, n+1) if s[i-1] == high]\n        if candidates:\n            u = random.choice(candidates)\n            # Compute feasible colors up to max+1\n            used = {s[v-1] for v in adj[u]}\n            kmax = max(s) + 1\n            feas = [c for c in range(1, kmax+1) if c not in used]\n            alt = [c for c in feas if c < high] or [c for c in feas if c != s[u-1]]\n            if alt:\n                # Bias toward smaller labels\n                alt.sort()\n                s[u-1] = random.choice(alt[:min(2, len(alt))])\n\n    # Final normalization\/compression\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001420896}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = solution[:]\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        # Map labels to 1..k in ascending order of appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        # Search up to current max+1\n        kmax = max(cur) + 1\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    def has_conflicts(cur: List[int]) -> bool:\n        for u, v in edges:\n            if cur[u-1] == cur[v-1]:\n                return True\n        return False\n\n    # Step 1: If conflicts, repair a random conflicting edge by recoloring one endpoint\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        # Choose endpoint by higher degree or random tie\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        # Prefer smallest colors to limit palette\n        if feas:\n            # Randomize among minimal colors that are <= current color if available\n            curc = s[target-1]\n            leq = [c for c in feas if c <= curc]\n            pick_from = leq if leq else feas\n            s[target-1] = random.choice(pick_from)\n            s = normalize_labels(s)\n            return s, (\"Local\", \"Repair\")\n        # Fallback: swap color with a neighbor if possible (rare)\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: Try color reduction by moving a vertex from the highest color down\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                # Random among the smallest few to diversify\n                feas_below.sort()\n                pick = random.choice(feas_below[:min(2, len(feas_below))])\n                s[u-1] = pick\n                s = normalize_labels(s)\n                return s, (\"Local\", \"ReduceColor\")\n\n    # Step 3: Kempe-chain swap between two colors to unlock reductions\n    # Pick two different colors present; if only one, skip\n    colors = list(sorted(set(s)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Choose a random pivot vertex colored c1 or c2\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {c1, c2}\n            # Build Kempe chain component induced by colors c1 and c2\n            visited: Set[int] = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                visited.add(u)\n                for v in adj[u]:\n                    if s[v-1] in target_colors and v not in visited:\n                        stack.append(v)\n            # Swap colors within the component\n            for u in visited:\n                s[u-1] = c1 if s[u-1] == c2 else (c2 if s[u-1] == c1 else s[u-1])\n            s = normalize_labels(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor on a random vertex to an alternative feasible color\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    if len(feas) >= 2:\n        # Choose a feasible color different from current, bias toward small\n        alt = [c for c in feas if c != s[u-1]]\n        alt.sort()\n        pick = random.choice(alt[:min(2, len(alt))])\n        s[u-1] = pick\n    else:\n        # If only one feasible (possibly equal), force smallest feasible\n        if feas:\n            s[u-1] = min(feas)\n    s = normalize_labels(s)\n    return s, (\"Local\", \"Diversify\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using multiple randomized moves:\n    - Random Kempe-chain swaps (1-2 times)\n    - Random recolor of a high-label vertex\n    - Label compression\/normalization\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = solution[:]\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap_once(cur: List[int]) -> List[int]:\n        colors = list(sorted(set(cur)))\n        if len(colors) < 2:\n            return cur\n        c1, c2 = random.sample(colors, 2)\n        # Pick pivot among vertices colored c1 or c2\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        start = random.choice(candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        # Swap within component\n        for u in visited:\n            cur[u-1] = c1 if cur[u-1] == c2 else (c2 if cur[u-1] == c1 else cur[u-1])\n        return cur\n\n    # Apply 1-2 Kempe swaps\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s)\n        s = normalize_labels(s)\n\n    # Recolor a high-label vertex to a feasible alternative if possible\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        candidates = [i for i in range(1, n+1) if s[i-1] == high]\n        if candidates:\n            u = random.choice(candidates)\n            # Compute feasible colors up to max+1\n            used = {s[v-1] for v in adj[u]}\n            kmax = max(s) + 1\n            feas = [c for c in range(1, kmax+1) if c not in used]\n            alt = [c for c in feas if c < high] or [c for c in feas if c != s[u-1]]\n            if alt:\n                # Bias toward smaller labels\n                alt.sort()\n                s[u-1] = random.choice(alt[:min(2, len(alt))])\n\n    # Final normalization\/compression\n    s = normalize_labels(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001484828}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE. A feasible coloring is a list of 9 positive integers [x1,...,x9], 1-indexed to students, where xi is the color label for vertex i.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Large penalty to enforce feasibility\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Primary objective: minimize groups; conflicts are prohibitive\n    return num_groups + conflicts * 100000","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        kmax = max(cur) + 1\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    # Step 1: Repair conflicting edge if any\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        if feas:\n            curc = s[target-1]\n            leq = [c for c in feas if c <= curc]\n            pick_from = leq if leq else feas\n            s[target-1] = random.choice(pick_from)\n            s = normalize_labels(s)\n            return s, (\"Local\", \"Repair\")\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: Try color reduction from highest label\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                feas_below.sort()\n                pick = random.choice(feas_below[:min(2, len(feas_below))])\n                s[u-1] = pick\n                s = normalize_labels(s)\n                return s, (\"Local\", \"ReduceColor\")\n\n    # Step 3: Kempe-chain swap between two colors\n    colors = list(sorted(set(s)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {c1, c2}\n            visited: Set[int] = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                visited.add(u)\n                for v in adj[u]:\n                    if s[v-1] in target_colors and v not in visited:\n                        stack.append(v)\n            for u in visited:\n                if s[u-1] == c1:\n                    s[u-1] = c2\n                elif s[u-1] == c2:\n                    s[u-1] = c1\n            s = normalize_labels(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    if len(feas) >= 2:\n        alt = [c for c in feas if c != s[u-1]]\n        alt.sort()\n        pick = random.choice(alt[:min(2, len(alt))])\n        s[u-1] = pick\n    else:\n        if feas:\n            s[u-1] = min(feas)\n    s = normalize_labels(s)\n    return s, (\"Local\", \"Diversify\")","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using randomized moves:\n    - 1-2 Kempe-chain swaps between random color pairs\n    - Recolor a random vertex from the highest color to a feasible alternative if possible\n    - Normalize labels to compress palette\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap_once(cur: List[int]) -> List[int]:\n        colors = list(sorted(set(cur)))\n        if len(colors) < 2:\n            return cur\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        start = random.choice(candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == c1:\n                cur[u-1] = c2\n            elif cur[u-1] == c2:\n                cur[u-1] = c1\n        return cur\n\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s)\n        s = normalize_labels(s)\n\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        candidates = [i for i in range(1, n+1) if s[i-1] == high]\n        if candidates:\n            u = random.choice(candidates)\n            used = {s[v-1] for v in adj[u]}\n            kmax = max(s) + 1\n            feas = [c for c in range(1, kmax+1) if c not in used]\n            alt = [c for c in feas if c < high]\n            if not alt:\n                alt = [c for c in feas if c != s[u-1]]\n            if alt:\n                alt.sort()\n                s[u-1] = random.choice(alt[:min(2, len(alt))])\n\n    s = normalize_labels(s)\n    return s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001134113}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE. A feasible coloring is a list of 9 positive integers [x1,...,x9], 1-indexed to students, where xi is the color label for vertex i.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Large penalty to enforce feasibility\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Primary objective: minimize groups; conflicts are prohibitive\n    return num_groups + conflicts * 100000","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        kmax = max(cur) + 1\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    # Step 1: Repair conflicting edge if any\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        if feas:\n            curc = s[target-1]\n            leq = [c for c in feas if c <= curc]\n            pick_from = leq if leq else feas\n            s[target-1] = random.choice(pick_from)\n            s = normalize_labels(s)\n            return s, (\"Local\", \"Repair\")\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: Try color reduction from highest label\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                feas_below.sort()\n                pick = random.choice(feas_below[:min(2, len(feas_below))])\n                s[u-1] = pick\n                s = normalize_labels(s)\n                return s, (\"Local\", \"ReduceColor\")\n\n    # Step 3: Kempe-chain swap between two colors\n    colors = list(sorted(set(s)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {c1, c2}\n            visited: Set[int] = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                visited.add(u)\n                for v in adj[u]:\n                    if s[v-1] in target_colors and v not in visited:\n                        stack.append(v)\n            for u in visited:\n                if s[u-1] == c1:\n                    s[u-1] = c2\n                elif s[u-1] == c2:\n                    s[u-1] = c1\n            s = normalize_labels(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    if len(feas) >= 2:\n        alt = [c for c in feas if c != s[u-1]]\n        alt.sort()\n        pick = random.choice(alt[:min(2, len(alt))])\n        s[u-1] = pick\n    else:\n        if feas:\n            s[u-1] = min(feas)\n    s = normalize_labels(s)\n    return s, (\"Local\", \"Diversify\")","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using randomized moves:\n    - 1-2 Kempe-chain swaps between random color pairs\n    - Recolor a random vertex from the highest color to a feasible alternative if possible\n    - Normalize labels to compress palette\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap_once(cur: List[int]) -> List[int]:\n        colors = list(sorted(set(cur)))\n        if len(colors) < 2:\n            return cur\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        start = random.choice(candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == c1:\n                cur[u-1] = c2\n            elif cur[u-1] == c2:\n                cur[u-1] = c1\n        return cur\n\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s)\n        s = normalize_labels(s)\n\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        candidates = [i for i in range(1, n+1) if s[i-1] == high]\n        if candidates:\n            u = random.choice(candidates)\n            used = {s[v-1] for v in adj[u]}\n            kmax = max(s) + 1\n            feas = [c for c in range(1, kmax+1) if c not in used]\n            alt = [c for c in feas if c < high]\n            if not alt:\n                alt = [c for c in feas if c != s[u-1]]\n            if alt:\n                alt.sort()\n                s[u-1] = random.choice(alt[:min(2, len(alt))])\n\n    s = normalize_labels(s)\n    return s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001411337}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE. A feasible coloring is a list of 9 positive integers [x1,...,x9], 1-indexed to students, where xi is the color label for vertex i.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Large penalty to enforce feasibility\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Primary objective: minimize groups; conflicts are prohibitive\n    return num_groups + conflicts * 100000","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        kmax = max(cur) + 1\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    # Step 1: Repair conflicting edge if any\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        if feas:\n            curc = s[target-1]\n            leq = [c for c in feas if c <= curc]\n            pick_from = leq if leq else feas\n            s[target-1] = random.choice(pick_from)\n            s = normalize_labels(s)\n            return s, (\"Local\", \"Repair\")\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: Try color reduction from highest label\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                feas_below.sort()\n                pick = random.choice(feas_below[:min(2, len(feas_below))])\n                s[u-1] = pick\n                s = normalize_labels(s)\n                return s, (\"Local\", \"ReduceColor\")\n\n    # Step 3: Kempe-chain swap between two colors\n    colors = list(sorted(set(s)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {c1, c2}\n            visited: Set[int] = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                visited.add(u)\n                for v in adj[u]:\n                    if s[v-1] in target_colors and v not in visited:\n                        stack.append(v)\n            for u in visited:\n                if s[u-1] == c1:\n                    s[u-1] = c2\n                elif s[u-1] == c2:\n                    s[u-1] = c1\n            s = normalize_labels(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    if len(feas) >= 2:\n        alt = [c for c in feas if c != s[u-1]]\n        alt.sort()\n        pick = random.choice(alt[:min(2, len(alt))])\n        s[u-1] = pick\n    else:\n        if feas:\n            s[u-1] = min(feas)\n    s = normalize_labels(s)\n    return s, (\"Local\", \"Diversify\")","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using randomized moves:\n    - 1-2 Kempe-chain swaps between random color pairs\n    - Recolor a random vertex from the highest color to a feasible alternative if possible\n    - Normalize labels to compress palette\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels(cur: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap_once(cur: List[int]) -> List[int]:\n        colors = list(sorted(set(cur)))\n        if len(colors) < 2:\n            return cur\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        start = random.choice(candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == c1:\n                cur[u-1] = c2\n            elif cur[u-1] == c2:\n                cur[u-1] = c1\n        return cur\n\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s)\n        s = normalize_labels(s)\n\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        candidates = [i for i in range(1, n+1) if s[i-1] == high]\n        if candidates:\n            u = random.choice(candidates)\n            used = {s[v-1] for v in adj[u]}\n            kmax = max(s) + 1\n            feas = [c for c in range(1, kmax+1) if c not in used]\n            alt = [c for c in feas if c < high]\n            if not alt:\n                alt = [c for c in feas if c != s[u-1]]\n            if alt:\n                alt.sort()\n                s[u-1] = random.choice(alt[:min(2, len(alt))])\n\n    s = normalize_labels(s)\n    return s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001289735}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Large penalty to enforce feasibility\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Primary objective: minimize groups; conflicts are prohibitive\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels_canonical(cur: List[int]) -> List[int]:\n        uniq = sorted(set(cur))\n        mapping = {c:i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in cur]\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        kmax = max(cur)\n        # Restrict to existing palette to avoid inflation\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    def kempe_swap(cur: List[int], color_a: int, color_b: int, start_vertex: int) -> List[int]:\n        target_colors = {color_a, color_b}\n        visited: Set[int] = set()\n        stack = [start_vertex]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == color_a:\n                cur[u-1] = color_b\n            elif cur[u-1] == color_b:\n                cur[u-1] = color_a\n        return cur\n\n    # Step 1: Repair conflicting edge if any (without increasing palette)\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        # Prefer higher degree vertex to recolor\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        if feas:\n            # Bias toward lower colors\n            feas.sort()\n            s[target-1] = random.choice(feas[:min(3, len(feas))])\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"Repair\")\n        # If no feasible within palette, try targeted Kempe with a lower color\n        curc = s[target-1]\n        lower = [c for c in sorted(set(s)) if c < curc]\n        if lower:\n            c2 = random.choice(lower)\n            s = kempe_swap(s, curc, c2, target)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"Repair\")\n        # Fallback: swap colors with a neighbor\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels_canonical(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: ReduceColor sweep focused on highest color\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                feas_below.sort()\n                s[u-1] = random.choice(feas_below[:min(3, len(feas_below))])\n                s = normalize_labels_canonical(s)\n                return s, (\"Local\", \"ReduceColor\")\n        # If direct recolor failed, attempt targeted Kempe between high and a lower color touching a high node\n        if high_nodes and len(colors) >= 2:\n            c2 = random.choice(colors[:-1])\n            start = random.choice(high_nodes)\n            s = kempe_swap(s, high, c2, start)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 3: Generic Kempe swap between two existing colors\n    colors = sorted(set(s))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            s = kempe_swap(s, c1, c2, start)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor within palette\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    alt = [c for c in feas if c != s[u-1]]\n    if alt:\n        s[u-1] = random.choice(alt)\n    s = normalize_labels_canonical(s)\n    return s, (\"Local\", \"Diversify\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using randomized moves:\n    - 1-2 Kempe-chain swaps biased to involve the highest color\n    - Attempt recolor of a random vertex from the highest color to a lower feasible color\n    - Normalize labels canonically to compress palette\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels_canonical(cur: List[int]) -> List[int]:\n        uniq = sorted(set(cur))\n        mapping = {c:i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in cur]\n\n    def kempe_swap_once(cur: List[int], prefer_high: bool = True) -> List[int]:\n        colors = sorted(set(cur))\n        if len(colors) < 2:\n            return cur\n        if prefer_high and len(colors) >= 2:\n            c1 = colors[-1]\n            c2 = random.choice(colors[:-1])\n        else:\n            c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        # Bias start to a vertex currently colored with c1 when possible\n        candidates_c1 = [i for i in candidates if cur[i-1] == c1]\n        start = random.choice(candidates_c1 if candidates_c1 else candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == c1:\n                cur[u-1] = c2\n            elif cur[u-1] == c2:\n                cur[u-1] = c1\n        return cur\n\n    # 1-2 Kempe swaps\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s, prefer_high=True)\n        s = normalize_labels_canonical(s)\n\n    # Attempt to recolor one vertex from highest color to a lower feasible color\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        if high_nodes:\n            u = random.choice(high_nodes)\n            used = {s[v-1] for v in adj[u]}\n            feas = [c for c in colors if c not in used and c < high]\n            if not feas:\n                feas = [c for c in colors if c not in used and c != s[u-1]]\n            if feas:\n                s[u-1] = random.choice(feas)\n\n    s = normalize_labels_canonical(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001090533}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Large penalty to enforce feasibility\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Primary objective: minimize groups; conflicts are prohibitive\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels_canonical(cur: List[int]) -> List[int]:\n        uniq = sorted(set(cur))\n        mapping = {c:i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in cur]\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        kmax = max(cur)\n        # Restrict to existing palette to avoid inflation\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    def kempe_swap(cur: List[int], color_a: int, color_b: int, start_vertex: int) -> List[int]:\n        target_colors = {color_a, color_b}\n        visited: Set[int] = set()\n        stack = [start_vertex]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == color_a:\n                cur[u-1] = color_b\n            elif cur[u-1] == color_b:\n                cur[u-1] = color_a\n        return cur\n\n    # Step 1: Repair conflicting edge if any (without increasing palette)\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        # Prefer higher degree vertex to recolor\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        if feas:\n            # Bias toward lower colors\n            feas.sort()\n            s[target-1] = random.choice(feas[:min(3, len(feas))])\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"Repair\")\n        # If no feasible within palette, try targeted Kempe with a lower color\n        curc = s[target-1]\n        lower = [c for c in sorted(set(s)) if c < curc]\n        if lower:\n            c2 = random.choice(lower)\n            s = kempe_swap(s, curc, c2, target)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"Repair\")\n        # Fallback: swap colors with a neighbor\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels_canonical(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: ReduceColor sweep focused on highest color\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                feas_below.sort()\n                s[u-1] = random.choice(feas_below[:min(3, len(feas_below))])\n                s = normalize_labels_canonical(s)\n                return s, (\"Local\", \"ReduceColor\")\n        # If direct recolor failed, attempt targeted Kempe between high and a lower color touching a high node\n        if high_nodes and len(colors) >= 2:\n            c2 = random.choice(colors[:-1])\n            start = random.choice(high_nodes)\n            s = kempe_swap(s, high, c2, start)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 3: Generic Kempe swap between two existing colors\n    colors = sorted(set(s))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            s = kempe_swap(s, c1, c2, start)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor within palette\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    alt = [c for c in feas if c != s[u-1]]\n    if alt:\n        s[u-1] = random.choice(alt)\n    s = normalize_labels_canonical(s)\n    return s, (\"Local\", \"Diversify\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using randomized moves:\n    - 1-2 Kempe-chain swaps biased to involve the highest color\n    - Attempt recolor of a random vertex from the highest color to a lower feasible color\n    - Normalize labels canonically to compress palette\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels_canonical(cur: List[int]) -> List[int]:\n        uniq = sorted(set(cur))\n        mapping = {c:i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in cur]\n\n    def kempe_swap_once(cur: List[int], prefer_high: bool = True) -> List[int]:\n        colors = sorted(set(cur))\n        if len(colors) < 2:\n            return cur\n        if prefer_high and len(colors) >= 2:\n            c1 = colors[-1]\n            c2 = random.choice(colors[:-1])\n        else:\n            c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        # Bias start to a vertex currently colored with c1 when possible\n        candidates_c1 = [i for i in candidates if cur[i-1] == c1]\n        start = random.choice(candidates_c1 if candidates_c1 else candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == c1:\n                cur[u-1] = c2\n            elif cur[u-1] == c2:\n                cur[u-1] = c1\n        return cur\n\n    # 1-2 Kempe swaps\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s, prefer_high=True)\n        s = normalize_labels_canonical(s)\n\n    # Attempt to recolor one vertex from highest color to a lower feasible color\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        if high_nodes:\n            u = random.choice(high_nodes)\n            used = {s[v-1] for v in adj[u]}\n            feas = [c for c in colors if c not in used and c < high]\n            if not feas:\n                feas = [c for c in colors if c not in used and c != s[u-1]]\n            if feas:\n                s[u-1] = random.choice(feas)\n\n    s = normalize_labels_canonical(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001448017}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN_9_POSITIVE","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution) -> int:\n    # Large penalty to enforce feasibility\n    LARGE = 10**9\n    # Validate representation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Primary objective: minimize groups; conflicts are prohibitive\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\nfrom typing import List, Tuple, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type: 'Local'\n    Movement_Type: one of {'Repair','ReduceColor','KempeSwap','Diversify'}\n    \"\"\"\n    # Validate input and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    # Problem data\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels_canonical(cur: List[int]) -> List[int]:\n        uniq = sorted(set(cur))\n        mapping = {c:i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in cur]\n\n    def feasible_colors(u: int, cur: List[int]) -> List[int]:\n        used = {cur[v-1] for v in adj[u]}\n        kmax = max(cur)\n        # Restrict to existing palette to avoid inflation\n        return [c for c in range(1, kmax+1) if c not in used]\n\n    def kempe_swap(cur: List[int], color_a: int, color_b: int, start_vertex: int) -> List[int]:\n        target_colors = {color_a, color_b}\n        visited: Set[int] = set()\n        stack = [start_vertex]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == color_a:\n                cur[u-1] = color_b\n            elif cur[u-1] == color_b:\n                cur[u-1] = color_a\n        return cur\n\n    # Step 1: Repair conflicting edge if any (without increasing palette)\n    conflicts = [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n    if conflicts:\n        u, v = random.choice(conflicts)\n        # Prefer higher degree vertex to recolor\n        du, dv = len(adj[u]), len(adj[v])\n        target = u if (du > dv or (du == dv and random.random() < 0.5)) else v\n        feas = feasible_colors(target, s)\n        if feas:\n            # Bias toward lower colors\n            feas.sort()\n            s[target-1] = random.choice(feas[:min(3, len(feas))])\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"Repair\")\n        # If no feasible within palette, try targeted Kempe with a lower color\n        curc = s[target-1]\n        lower = [c for c in sorted(set(s)) if c < curc]\n        if lower:\n            c2 = random.choice(lower)\n            s = kempe_swap(s, curc, c2, target)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"Repair\")\n        # Fallback: swap colors with a neighbor\n        nb = random.choice(list(adj[target]))\n        s[target-1], s[nb-1] = s[nb-1], s[target-1]\n        s = normalize_labels_canonical(s)\n        return s, (\"Local\", \"Repair\")\n\n    # Step 2: ReduceColor sweep focused on highest color\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        random.shuffle(high_nodes)\n        for u in high_nodes:\n            feas = feasible_colors(u, s)\n            feas_below = [c for c in feas if c < high]\n            if feas_below:\n                feas_below.sort()\n                s[u-1] = random.choice(feas_below[:min(3, len(feas_below))])\n                s = normalize_labels_canonical(s)\n                return s, (\"Local\", \"ReduceColor\")\n        # If direct recolor failed, attempt targeted Kempe between high and a lower color touching a high node\n        if high_nodes and len(colors) >= 2:\n            c2 = random.choice(colors[:-1])\n            start = random.choice(high_nodes)\n            s = kempe_swap(s, high, c2, start)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 3: Generic Kempe swap between two existing colors\n    colors = sorted(set(s))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if s[i-1] in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            s = kempe_swap(s, c1, c2, start)\n            s = normalize_labels_canonical(s)\n            return s, (\"Local\", \"KempeSwap\")\n\n    # Step 4: Diversification recolor within palette\n    u = random.randint(1, n)\n    feas = feasible_colors(u, s)\n    alt = [c for c in feas if c != s[u-1]]\n    if alt:\n        s[u-1] = random.choice(alt)\n    s = normalize_labels_canonical(s)\n    return s, (\"Local\", \"Diversify\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Set\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong feasible perturbation using randomized moves:\n    - 1-2 Kempe-chain swaps biased to involve the highest color\n    - Attempt recolor of a random vertex from the highest color to a lower feasible color\n    - Normalize labels canonically to compress palette\n    Returns a new perturbed solution list of length 9.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        raise ValueError(\"solution must be a list of 9 positive integers\")\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            raise ValueError(\"solution entries must be positive integers\")\n    s: List[int] = list(solution)\n\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    n = 9\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_labels_canonical(cur: List[int]) -> List[int]:\n        uniq = sorted(set(cur))\n        mapping = {c:i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in cur]\n\n    def kempe_swap_once(cur: List[int], prefer_high: bool = True) -> List[int]:\n        colors = sorted(set(cur))\n        if len(colors) < 2:\n            return cur\n        if prefer_high and len(colors) >= 2:\n            c1 = colors[-1]\n            c2 = random.choice(colors[:-1])\n        else:\n            c1, c2 = random.sample(colors, 2)\n        candidates = [i for i in range(1, n+1) if cur[i-1] in (c1, c2)]\n        if not candidates:\n            return cur\n        # Bias start to a vertex currently colored with c1 when possible\n        candidates_c1 = [i for i in candidates if cur[i-1] == c1]\n        start = random.choice(candidates_c1 if candidates_c1 else candidates)\n        target_colors = {c1, c2}\n        visited: Set[int] = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if cur[v-1] in target_colors and v not in visited:\n                    stack.append(v)\n        for u in visited:\n            if cur[u-1] == c1:\n                cur[u-1] = c2\n            elif cur[u-1] == c2:\n                cur[u-1] = c1\n        return cur\n\n    # 1-2 Kempe swaps\n    for _ in range(1 + int(random.random() < 0.5)):\n        s = kempe_swap_once(s, prefer_high=True)\n        s = normalize_labels_canonical(s)\n\n    # Attempt to recolor one vertex from highest color to a lower feasible color\n    colors = sorted(set(s))\n    if colors:\n        high = colors[-1]\n        high_nodes = [i for i in range(1, n+1) if s[i-1] == high]\n        if high_nodes:\n            u = random.choice(high_nodes)\n            used = {s[v-1] for v in adj[u]}\n            feas = [c for c in colors if c not in used and c < high]\n            if not feas:\n                feas = [c for c in colors if c not in used and c != s[u-1]]\n            if feas:\n                s[u-1] = random.choice(feas)\n\n    s = normalize_labels_canonical(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001385327}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED: solution is a Python list of length 9 with integers >=1 representing colors for vertices 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Validate type and domain\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000*conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return a default random feasible-domain neighbor from minimal domain\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Recolor-Vertex\")\n    new_sol = solution[:]\n    # Determine current palette size\n    current_K = max(max(new_sol), 3)\n    i = random.randrange(n)\n    # Recolor vertex i to a different color within 1..current_K (ensure change)\n    old_c = new_sol[i]\n    if current_K == 1:\n        new_c = 1\n    else:\n        choices = list(range(1, current_K+1))\n        if old_c in choices:\n            choices.remove(old_c)\n        new_c = random.choice(choices) if choices else old_c\n    new_sol[i] = new_c\n    # With small probability attempt palette compression by relabeling to remove gaps\n    if random.random() < 0.2:\n        # Normalize colors to consecutive starting at 1 based on order of appearance\n        mapping = {}\n        nxt = 1\n        for c in new_sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n        new_sol = [mapping[c] for c in new_sol]\n    return new_sol, (\"Local\", \"Recolor-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [random.randint(1, 3) for _ in range(n)]\n    new_sol = solution[:]\n    current_K = max(max(new_sol), 3)\n    # Apply multiple random recolors to diversify\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        old_c = new_sol[i]\n        choices = list(range(1, current_K+1))\n        if old_c in choices:\n            choices.remove(old_c)\n        if choices:\n            new_sol[i] = random.choice(choices)\n    # Random color relabeling to escape color symmetry\n    palette = sorted(set(new_sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    new_sol = [relabel[c] for c in new_sol]\n    # Normalize to start at 1 and be consecutive\n    mapping = {}\n    nxt = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000478755}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED: solution is a Python list of length 9 with integers >=1 representing colors for vertices 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Validate type and domain\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000*conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return a default random feasible-domain neighbor from minimal domain\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Recolor-Vertex\")\n    new_sol = solution[:]\n    # Determine current palette size\n    current_K = max(max(new_sol), 3)\n    i = random.randrange(n)\n    # Recolor vertex i to a different color within 1..current_K (ensure change)\n    old_c = new_sol[i]\n    if current_K == 1:\n        new_c = 1\n    else:\n        choices = list(range(1, current_K+1))\n        if old_c in choices:\n            choices.remove(old_c)\n        new_c = random.choice(choices) if choices else old_c\n    new_sol[i] = new_c\n    # With small probability attempt palette compression by relabeling to remove gaps\n    if random.random() < 0.2:\n        # Normalize colors to consecutive starting at 1 based on order of appearance\n        mapping = {}\n        nxt = 1\n        for c in new_sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n        new_sol = [mapping[c] for c in new_sol]\n    return new_sol, (\"Local\", \"Recolor-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [random.randint(1, 3) for _ in range(n)]\n    new_sol = solution[:]\n    current_K = max(max(new_sol), 3)\n    # Apply multiple random recolors to diversify\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        old_c = new_sol[i]\n        choices = list(range(1, current_K+1))\n        if old_c in choices:\n            choices.remove(old_c)\n        if choices:\n            new_sol[i] = random.choice(choices)\n    # Random color relabeling to escape color symmetry\n    palette = sorted(set(new_sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    new_sol = [relabel[c] for c in new_sol]\n    # Normalize to start at 1 and be consecutive\n    mapping = {}\n    nxt = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000568397}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED: solution is a Python list of length 9 with integers >=1 representing colors for vertices 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Validate type and domain\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000*conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return a default random feasible-domain neighbor from minimal domain\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Recolor-Vertex\")\n    new_sol = solution[:]\n    # Determine current palette size\n    current_K = max(max(new_sol), 3)\n    i = random.randrange(n)\n    # Recolor vertex i to a different color within 1..current_K (ensure change)\n    old_c = new_sol[i]\n    if current_K == 1:\n        new_c = 1\n    else:\n        choices = list(range(1, current_K+1))\n        if old_c in choices:\n            choices.remove(old_c)\n        new_c = random.choice(choices) if choices else old_c\n    new_sol[i] = new_c\n    # With small probability attempt palette compression by relabeling to remove gaps\n    if random.random() < 0.2:\n        # Normalize colors to consecutive starting at 1 based on order of appearance\n        mapping = {}\n        nxt = 1\n        for c in new_sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n        new_sol = [mapping[c] for c in new_sol]\n    return new_sol, (\"Local\", \"Recolor-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return [random.randint(1, 3) for _ in range(n)]\n    new_sol = solution[:]\n    current_K = max(max(new_sol), 3)\n    # Apply multiple random recolors to diversify\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        old_c = new_sol[i]\n        choices = list(range(1, current_K+1))\n        if old_c in choices:\n            choices.remove(old_c)\n        if choices:\n            new_sol[i] = random.choice(choices)\n    # Random color relabeling to escape color symmetry\n    palette = sorted(set(new_sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    new_sol = [relabel[c] for c in new_sol]\n    # Normalize to start at 1 and be consecutive\n    mapping = {}\n    nxt = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000562447}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Problem data embedded locally\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type\/domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    if conflicts > 0:\n        # Strong penalty with clear gradient in conflicts, then K as tie-breaker\n        return 1_000_000 + 10_000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Fallback to random minimal-domain solution if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Recolor-Vertex\")\n\n    def vertex_conflicts(sol, v_idx):\n        c = sol[v_idx]\n        count = 0\n        for (u, w) in E:\n            if u-1 == v_idx:\n                if sol[w-1] == c:\n                    count += 1\n            elif w-1 == v_idx:\n                if sol[u-1] == c:\n                    count += 1\n        return count\n\n    def min_conflict_color(sol, v_idx, palette):\n        # choose color in palette minimizing conflicts; break ties randomly\n        best_colors = []\n        best_val = 10**9\n        orig = sol[v_idx]\n        for col in palette:\n            if col == orig:\n                continue\n            cnt = 0\n            for (u, w) in E:\n                if u-1 == v_idx:\n                    cnt += 1 if sol[w-1] == col else 0\n                elif w-1 == v_idx:\n                    cnt += 1 if sol[u-1] == col else 0\n            if cnt < best_val:\n                best_val = cnt\n                best_colors = [col]\n            elif cnt == best_val:\n                best_colors.append(col)\n        if not best_colors:\n            return orig\n        return random.choice(best_colors)\n\n    def kempe_chain_swap(sol, start_v, c1, c2):\n        # BFS on subgraph induced by colors {c1, c2}, starting at start_v\n        if c1 == c2:\n            return sol[:]\n        if sol[start_v] != c1:\n            return sol[:]\n        adj = [[] for _ in range(n)]\n        for (u, w) in E:\n            adj[u-1].append(w-1)\n            adj[w-1].append(u-1)\n        allowed = {c1, c2}\n        visited = [False]*n\n        stack = [start_v]\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if not visited[nb] and sol[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_sol = sol[:]\n        for v in component:\n            new_sol[v] = c2 if sol[v] == c1 else c1\n        return new_sol\n\n    sol = solution[:]\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = []\n    for i in range(n):\n        if vertex_conflicts(sol, i) > 0:\n            conflict_vertices.append(i)\n\n    move_type = (\"Local\", \"Recolor-Vertex\")\n\n    if conflict_vertices:\n        # Pick vertex with highest conflict degree; tie-break by random\n        degrees = [(vertex_conflicts(sol, i), i) for i in conflict_vertices]\n        max_conf = max(d for d, _ in degrees)\n        candidates = [i for d, i in degrees if d == max_conf]\n        v = random.choice(candidates)\n        palette = list(range(1, current_K + 1))\n        # Prefer colors not used by neighbors first (min-conflict)\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        # Occasionally use Kempe chain to escape local minima\n        if random.random() < 0.15:\n            other = random.choice([c for c in palette if c != sol[v]]) if len(palette) > 1 else sol[v]\n            new_sol = kempe_chain_swap(sol, v, sol[v], other)\n            move_type = (\"Local\", \"Kempe-Chain\")\n        return new_sol, move_type\n    else:\n        # No conflicts: try to reduce K by recoloring a vertex of max color\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_K]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n            lower_palette = list(range(1, current_K)) if current_K > 1 else [1]\n            if lower_palette:\n                new_color = min_conflict_color(sol, v, lower_palette)\n                new_sol = sol[:]\n                new_sol[v] = new_color\n                # If we successfully eliminate use of current_K, compress palette\n                if current_K not in new_sol:\n                    # Relabel colors to consecutive starting at 1\n                    mapping = {}\n                    nxt = 1\n                    for c in new_sol:\n                        if c not in mapping:\n                            mapping[c] = nxt\n                            nxt += 1\n                    new_sol = [mapping[c] for c in new_sol]\n                return new_sol, (\"Local\", \"Recolor-Vertex\")\n        # Otherwise perform a neutral diversification move: Kempe swap between two random colors\n        if current_K >= 2:\n            c1, c2 = random.sample(list(range(1, current_K+1)), 2)\n            # pick a vertex of color c1, if none pick any\n            idxs = [i for i, c in enumerate(sol) if c == c1]\n            if not idxs:\n                idxs = list(range(n))\n            v = random.choice(idxs)\n            new_sol = kempe_chain_swap(sol, v, c1, c2)\n            return new_sol, (\"Local\", \"Kempe-Chain\")\n        # Fallback minor recolor\n        v = random.randrange(n)\n        new_color = random.randint(1, max(1, current_K))\n        if new_color == sol[v]:\n            new_color = 1 if sol[v] != 1 else 2\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        return new_sol, (\"Local\", \"Recolor-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # If invalid, return a random starting point\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [random.randint(1, 3) for _ in range(n)]\n\n    sol = solution[:]\n    current_K = max(sol)\n\n    # Helpers\n    adj = [[] for _ in range(n)]\n    for (u, w) in E:\n        adj[u-1].append(w-1)\n        adj[w-1].append(u-1)\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        visited = [False]*n\n        stack = [start_v]\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if not visited[nb] and s[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_s = s[:]\n        for v in component:\n            new_s[v] = c2 if s[v] == c1 else c1\n        return new_s\n\n    # Strength proportional to problem size\n    k = max(3, n \/\/ 3)\n\n    for _ in range(k):\n        move_pick = random.random()\n        if move_pick < 0.6:\n            # Random recolor differing from current\n            i = random.randrange(n)\n            palette = list(range(1, max(2, current_K))) if current_K > 1 else [1, 2]\n            new_c = random.choice(palette)\n            if new_c == sol[i]:\n                new_c = (new_c % (max(palette))) + 1\n            sol[i] = new_c\n        else:\n            # Kempe chain between two random colors (may include current_K+1 to diversify)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.3:\n                palette.append(current_K + 1)\n            c1, c2 = random.sample(palette, 2)\n            idxs = [idx for idx, c in enumerate(sol) if c == c1]\n            if not idxs:\n                idxs = list(range(n))\n            v = random.choice(idxs)\n            sol = kempe_chain_swap_local(sol, v, c1, c2)\n\n    # Random color relabeling to break symmetry\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    sol = [relabel[c] for c in sol]\n\n    # Normalize to consecutive labels starting at 1\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001168734}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Problem data embedded locally\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type\/domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    if conflicts > 0:\n        # Strong penalty with clear gradient in conflicts, then K as tie-breaker\n        return 1_000_000 + 10_000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Fallback to random minimal-domain solution if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Recolor-Vertex\")\n\n    def vertex_conflicts(sol, v_idx):\n        c = sol[v_idx]\n        count = 0\n        for (u, w) in E:\n            if u-1 == v_idx:\n                if sol[w-1] == c:\n                    count += 1\n            elif w-1 == v_idx:\n                if sol[u-1] == c:\n                    count += 1\n        return count\n\n    def min_conflict_color(sol, v_idx, palette):\n        # choose color in palette minimizing conflicts; break ties randomly\n        best_colors = []\n        best_val = 10**9\n        orig = sol[v_idx]\n        for col in palette:\n            if col == orig:\n                continue\n            cnt = 0\n            for (u, w) in E:\n                if u-1 == v_idx:\n                    cnt += 1 if sol[w-1] == col else 0\n                elif w-1 == v_idx:\n                    cnt += 1 if sol[u-1] == col else 0\n            if cnt < best_val:\n                best_val = cnt\n                best_colors = [col]\n            elif cnt == best_val:\n                best_colors.append(col)\n        if not best_colors:\n            return orig\n        return random.choice(best_colors)\n\n    def kempe_chain_swap(sol, start_v, c1, c2):\n        # BFS on subgraph induced by colors {c1, c2}, starting at start_v\n        if c1 == c2:\n            return sol[:]\n        if sol[start_v] != c1:\n            return sol[:]\n        adj = [[] for _ in range(n)]\n        for (u, w) in E:\n            adj[u-1].append(w-1)\n            adj[w-1].append(u-1)\n        allowed = {c1, c2}\n        visited = [False]*n\n        stack = [start_v]\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if not visited[nb] and sol[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_sol = sol[:]\n        for v in component:\n            new_sol[v] = c2 if sol[v] == c1 else c1\n        return new_sol\n\n    sol = solution[:]\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = []\n    for i in range(n):\n        if vertex_conflicts(sol, i) > 0:\n            conflict_vertices.append(i)\n\n    move_type = (\"Local\", \"Recolor-Vertex\")\n\n    if conflict_vertices:\n        # Pick vertex with highest conflict degree; tie-break by random\n        degrees = [(vertex_conflicts(sol, i), i) for i in conflict_vertices]\n        max_conf = max(d for d, _ in degrees)\n        candidates = [i for d, i in degrees if d == max_conf]\n        v = random.choice(candidates)\n        palette = list(range(1, current_K + 1))\n        # Prefer colors not used by neighbors first (min-conflict)\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        # Occasionally use Kempe chain to escape local minima\n        if random.random() < 0.15:\n            other = random.choice([c for c in palette if c != sol[v]]) if len(palette) > 1 else sol[v]\n            new_sol = kempe_chain_swap(sol, v, sol[v], other)\n            move_type = (\"Local\", \"Kempe-Chain\")\n        return new_sol, move_type\n    else:\n        # No conflicts: try to reduce K by recoloring a vertex of max color\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_K]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n            lower_palette = list(range(1, current_K)) if current_K > 1 else [1]\n            if lower_palette:\n                new_color = min_conflict_color(sol, v, lower_palette)\n                new_sol = sol[:]\n                new_sol[v] = new_color\n                # If we successfully eliminate use of current_K, compress palette\n                if current_K not in new_sol:\n                    # Relabel colors to consecutive starting at 1\n                    mapping = {}\n                    nxt = 1\n                    for c in new_sol:\n                        if c not in mapping:\n                            mapping[c] = nxt\n                            nxt += 1\n                    new_sol = [mapping[c] for c in new_sol]\n                return new_sol, (\"Local\", \"Recolor-Vertex\")\n        # Otherwise perform a neutral diversification move: Kempe swap between two random colors\n        if current_K >= 2:\n            c1, c2 = random.sample(list(range(1, current_K+1)), 2)\n            # pick a vertex of color c1, if none pick any\n            idxs = [i for i, c in enumerate(sol) if c == c1]\n            if not idxs:\n                idxs = list(range(n))\n            v = random.choice(idxs)\n            new_sol = kempe_chain_swap(sol, v, c1, c2)\n            return new_sol, (\"Local\", \"Kempe-Chain\")\n        # Fallback minor recolor\n        v = random.randrange(n)\n        new_color = random.randint(1, max(1, current_K))\n        if new_color == sol[v]:\n            new_color = 1 if sol[v] != 1 else 2\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        return new_sol, (\"Local\", \"Recolor-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # If invalid, return a random starting point\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [random.randint(1, 3) for _ in range(n)]\n\n    sol = solution[:]\n    current_K = max(sol)\n\n    # Helpers\n    adj = [[] for _ in range(n)]\n    for (u, w) in E:\n        adj[u-1].append(w-1)\n        adj[w-1].append(u-1)\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        visited = [False]*n\n        stack = [start_v]\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if not visited[nb] and s[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_s = s[:]\n        for v in component:\n            new_s[v] = c2 if s[v] == c1 else c1\n        return new_s\n\n    # Strength proportional to problem size\n    k = max(3, n \/\/ 3)\n\n    for _ in range(k):\n        move_pick = random.random()\n        if move_pick < 0.6:\n            # Random recolor differing from current\n            i = random.randrange(n)\n            palette = list(range(1, max(2, current_K))) if current_K > 1 else [1, 2]\n            new_c = random.choice(palette)\n            if new_c == sol[i]:\n                new_c = (new_c % (max(palette))) + 1\n            sol[i] = new_c\n        else:\n            # Kempe chain between two random colors (may include current_K+1 to diversify)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.3:\n                palette.append(current_K + 1)\n            c1, c2 = random.sample(palette, 2)\n            idxs = [idx for idx, c in enumerate(sol) if c == c1]\n            if not idxs:\n                idxs = list(range(n))\n            v = random.choice(idxs)\n            sol = kempe_chain_swap_local(sol, v, c1, c2)\n\n    # Random color relabeling to break symmetry\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    sol = [relabel[c] for c in sol]\n\n    # Normalize to consecutive labels starting at 1\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001488888}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Problem data embedded locally\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type\/domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    if conflicts > 0:\n        # Strong penalty with clear gradient in conflicts, then K as tie-breaker\n        return 1_000_000 + 10_000 * conflicts + K\n    return K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Fallback to random minimal-domain solution if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Recolor-Vertex\")\n\n    def vertex_conflicts(sol, v_idx):\n        c = sol[v_idx]\n        count = 0\n        for (u, w) in E:\n            if u-1 == v_idx:\n                if sol[w-1] == c:\n                    count += 1\n            elif w-1 == v_idx:\n                if sol[u-1] == c:\n                    count += 1\n        return count\n\n    def min_conflict_color(sol, v_idx, palette):\n        # choose color in palette minimizing conflicts; break ties randomly\n        best_colors = []\n        best_val = 10**9\n        orig = sol[v_idx]\n        for col in palette:\n            if col == orig:\n                continue\n            cnt = 0\n            for (u, w) in E:\n                if u-1 == v_idx:\n                    cnt += 1 if sol[w-1] == col else 0\n                elif w-1 == v_idx:\n                    cnt += 1 if sol[u-1] == col else 0\n            if cnt < best_val:\n                best_val = cnt\n                best_colors = [col]\n            elif cnt == best_val:\n                best_colors.append(col)\n        if not best_colors:\n            return orig\n        return random.choice(best_colors)\n\n    def kempe_chain_swap(sol, start_v, c1, c2):\n        # BFS on subgraph induced by colors {c1, c2}, starting at start_v\n        if c1 == c2:\n            return sol[:]\n        if sol[start_v] != c1:\n            return sol[:]\n        adj = [[] for _ in range(n)]\n        for (u, w) in E:\n            adj[u-1].append(w-1)\n            adj[w-1].append(u-1)\n        allowed = {c1, c2}\n        visited = [False]*n\n        stack = [start_v]\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if not visited[nb] and sol[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_sol = sol[:]\n        for v in component:\n            new_sol[v] = c2 if sol[v] == c1 else c1\n        return new_sol\n\n    sol = solution[:]\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = []\n    for i in range(n):\n        if vertex_conflicts(sol, i) > 0:\n            conflict_vertices.append(i)\n\n    move_type = (\"Local\", \"Recolor-Vertex\")\n\n    if conflict_vertices:\n        # Pick vertex with highest conflict degree; tie-break by random\n        degrees = [(vertex_conflicts(sol, i), i) for i in conflict_vertices]\n        max_conf = max(d for d, _ in degrees)\n        candidates = [i for d, i in degrees if d == max_conf]\n        v = random.choice(candidates)\n        palette = list(range(1, current_K + 1))\n        # Prefer colors not used by neighbors first (min-conflict)\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        # Occasionally use Kempe chain to escape local minima\n        if random.random() < 0.15:\n            other = random.choice([c for c in palette if c != sol[v]]) if len(palette) > 1 else sol[v]\n            new_sol = kempe_chain_swap(sol, v, sol[v], other)\n            move_type = (\"Local\", \"Kempe-Chain\")\n        return new_sol, move_type\n    else:\n        # No conflicts: try to reduce K by recoloring a vertex of max color\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_K]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n            lower_palette = list(range(1, current_K)) if current_K > 1 else [1]\n            if lower_palette:\n                new_color = min_conflict_color(sol, v, lower_palette)\n                new_sol = sol[:]\n                new_sol[v] = new_color\n                # If we successfully eliminate use of current_K, compress palette\n                if current_K not in new_sol:\n                    # Relabel colors to consecutive starting at 1\n                    mapping = {}\n                    nxt = 1\n                    for c in new_sol:\n                        if c not in mapping:\n                            mapping[c] = nxt\n                            nxt += 1\n                    new_sol = [mapping[c] for c in new_sol]\n                return new_sol, (\"Local\", \"Recolor-Vertex\")\n        # Otherwise perform a neutral diversification move: Kempe swap between two random colors\n        if current_K >= 2:\n            c1, c2 = random.sample(list(range(1, current_K+1)), 2)\n            # pick a vertex of color c1, if none pick any\n            idxs = [i for i, c in enumerate(sol) if c == c1]\n            if not idxs:\n                idxs = list(range(n))\n            v = random.choice(idxs)\n            new_sol = kempe_chain_swap(sol, v, c1, c2)\n            return new_sol, (\"Local\", \"Kempe-Chain\")\n        # Fallback minor recolor\n        v = random.randrange(n)\n        new_color = random.randint(1, max(1, current_K))\n        if new_color == sol[v]:\n            new_color = 1 if sol[v] != 1 else 2\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        return new_sol, (\"Local\", \"Recolor-Vertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # If invalid, return a random starting point\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [random.randint(1, 3) for _ in range(n)]\n\n    sol = solution[:]\n    current_K = max(sol)\n\n    # Helpers\n    adj = [[] for _ in range(n)]\n    for (u, w) in E:\n        adj[u-1].append(w-1)\n        adj[w-1].append(u-1)\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        visited = [False]*n\n        stack = [start_v]\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if not visited[nb] and s[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_s = s[:]\n        for v in component:\n            new_s[v] = c2 if s[v] == c1 else c1\n        return new_s\n\n    # Strength proportional to problem size\n    k = max(3, n \/\/ 3)\n\n    for _ in range(k):\n        move_pick = random.random()\n        if move_pick < 0.6:\n            # Random recolor differing from current\n            i = random.randrange(n)\n            palette = list(range(1, max(2, current_K))) if current_K > 1 else [1, 2]\n            new_c = random.choice(palette)\n            if new_c == sol[i]:\n                new_c = (new_c % (max(palette))) + 1\n            sol[i] = new_c\n        else:\n            # Kempe chain between two random colors (may include current_K+1 to diversify)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.3:\n                palette.append(current_K + 1)\n            c1, c2 = random.sample(palette, 2)\n            idxs = [idx for idx, c in enumerate(sol) if c == c1]\n            if not idxs:\n                idxs = list(range(n))\n            v = random.choice(idxs)\n            sol = kempe_chain_swap_local(sol, v, c1, c2)\n\n    # Random color relabeling to break symmetry\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    sol = [relabel[c] for c in sol]\n\n    # Normalize to consecutive labels starting at 1\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001422126}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Safe K\n    K = max(solution) if solution else 10**9\n    # Cost: lexicographic emulate with weighted sum\n    # Keep dynamic range moderate for SA acceptance\n    return 1000 * conflicts + K\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency once\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Fallback to random valid-like solution if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Init-Random\")\n\n    sol = solution[:]\n\n    def conflicts_of_vertex(sol_local, v):\n        cv = sol_local[v]\n        cnt = 0\n        for nb in adj[v]:\n            if sol_local[nb] == cv:\n                cnt += 1\n        return cnt\n\n    def min_conflict_color(sol_local, v, palette):\n        best = None\n        best_cnt = 10**9\n        for col in palette:\n            if col == sol_local[v]:\n                continue\n            cnt = 0\n            for nb in adj[v]:\n                if sol_local[nb] == col:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best = [col]\n            elif cnt == best_cnt:\n                best.append(col)\n        if best is None:\n            return sol_local[v]\n        return random.choice(best)\n\n    def kempe_chain_swap(sol_local, start_v, c1, c2):\n        if c1 == c2:\n            return sol_local[:]\n        if sol_local[start_v] not in (c1, c2):\n            return sol_local[:]\n        allowed = {c1, c2}\n        stack = [start_v]\n        visited = [False] * n\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (sol_local[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_sol = sol_local[:]\n        for v in component:\n            new_sol[v] = c2 if sol_local[v] == c1 else c1\n        return new_sol\n\n    def normalize(sol_local):\n        # Map to consecutive labels 1..q in sorted order to stabilize\n        uniq = sorted(set(sol_local))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = [i for i in range(n) if conflicts_of_vertex(sol, i) > 0]\n\n    # If conflicts exist: repair-focused moves\n    if conflict_vertices:\n        # Pick vertex of maximum conflicts (break ties randomly)\n        best_conf = -1\n        cand = []\n        for i in conflict_vertices:\n            c = conflicts_of_vertex(sol, i)\n            if c > best_conf:\n                best_conf = c\n                cand = [i]\n            elif c == best_conf:\n                cand.append(i)\n        v = random.choice(cand)\n        # Palette bias: neighbor colors first, plus try new color if necessary\n        neighbor_colors = sorted({sol[u] for u in adj[v]})\n        palette = list(range(1, current_K + 1))\n        # Try min-conflict recolor within 1..K\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        # If still conflicting, try introducing K+1\n        if conflicts_of_vertex(new_sol, v) > 0:\n            new_color2 = current_K + 1\n            new_sol[v] = new_color2\n            # Normalize after potential increase\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"Recolor-Expand\")\n        # Occasionally use a targeted Kempe chain with neighbor colors\n        if neighbor_colors and random.random() < 0.3:\n            c1 = sol[v]\n            c2 = random.choice(neighbor_colors)\n            ksol = kempe_chain_swap(sol, v, c1, c2)\n            ksol = normalize(ksol)\n            return ksol, (\"Local\", \"Kempe-Chain\")\n        new_sol = normalize(new_sol)\n        return new_sol, (\"Local\", \"Recolor-MinConflict\")\n\n    # No conflicts: try to reduce K\n    max_color = current_K\n    max_vertices = [i for i, c in enumerate(sol) if c == max_color]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        feasible = [c for c in range(1, max_color) if all(sol[u] != c for u in adj[v])]\n        if feasible:\n            new_sol = sol[:]\n            # DSATUR-like: pick smallest feasible color\n            new_sol[v] = min(feasible)\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"ReduceK-Recolor\")\n        # If no direct feasible recolor, try Kempe between max_color and a lower color\n        if max_color >= 2:\n            c2 = random.randint(1, max_color - 1)\n            new_sol = kempe_chain_swap(sol, v, max_color, c2)\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"ReduceK-Kempe\")\n\n    # Diversification: random Kempe between two colors\n    if current_K >= 2:\n        c1, c2 = random.sample(list(range(1, current_K + 1)), 2)\n        idxs = [i for i, c in enumerate(sol) if c == c1]\n        v = random.choice(idxs) if idxs else random.randrange(n)\n        new_sol = kempe_chain_swap(sol, v, c1, c2)\n        new_sol = normalize(new_sol)\n        return new_sol, (\"Local\", \"Kempe-Random\")\n\n    # Fallback: simple recolor\n    v = random.randrange(n)\n    nc = 1 if sol[v] != 1 else 2\n    new_sol = sol[:]\n    new_sol[v] = nc\n    new_sol = normalize(new_sol)\n    return new_sol, (\"Local\", \"Recolor-Fallback\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Side-effect free perturbation producing a valid solution\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = solution[:]\n\n    def normalize(sol_local):\n        uniq = sorted(set(sol_local))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        nloc = len(s)\n        visited = [False] * nloc\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and s[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = s[:]\n        for v in comp:\n            out[v] = c2 if s[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n\n    # Strength k\n    k = max(3, n \/\/ 3)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.55:\n            # Random recolor biased to 1..current_K\n            i = random.randrange(n)\n            palette = list(range(1, max(2, current_K + (1 if random.random() < 0.25 else 0))))\n            nc = random.choice(palette)\n            if nc == sol[i]:\n                nc = (nc % max(palette)) + 1\n            sol[i] = nc\n        else:\n            # Kempe swap between two colors (possibly introducing a new color)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.3:\n                palette.append(current_K + 1)\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                idxs = [idx for idx, c in enumerate(sol) if c == c1]\n                v = random.choice(idxs) if idxs else random.randrange(n)\n                sol = kempe_chain_swap_local(sol, v, c1, c2)\n        current_K = max(sol)\n\n    # Random relabel to break symmetry, then canonicalize\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    sol = [relabel[c] for c in sol]\n    sol = normalize(sol)\n    return sol\n","Resultados":[[2,3,1,2,3,1,3,2,1],3,[1,3,2,3,1,2,3,3,2],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001763781}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Safe K\n    K = max(solution) if solution else 10**9\n    # Cost: lexicographic emulate with weighted sum\n    # Keep dynamic range moderate for SA acceptance\n    return 1000 * conflicts + K\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency once\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Fallback to random valid-like solution if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Init-Random\")\n\n    sol = solution[:]\n\n    def conflicts_of_vertex(sol_local, v):\n        cv = sol_local[v]\n        cnt = 0\n        for nb in adj[v]:\n            if sol_local[nb] == cv:\n                cnt += 1\n        return cnt\n\n    def min_conflict_color(sol_local, v, palette):\n        best = None\n        best_cnt = 10**9\n        for col in palette:\n            if col == sol_local[v]:\n                continue\n            cnt = 0\n            for nb in adj[v]:\n                if sol_local[nb] == col:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best = [col]\n            elif cnt == best_cnt:\n                best.append(col)\n        if best is None:\n            return sol_local[v]\n        return random.choice(best)\n\n    def kempe_chain_swap(sol_local, start_v, c1, c2):\n        if c1 == c2:\n            return sol_local[:]\n        if sol_local[start_v] not in (c1, c2):\n            return sol_local[:]\n        allowed = {c1, c2}\n        stack = [start_v]\n        visited = [False] * n\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (sol_local[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_sol = sol_local[:]\n        for v in component:\n            new_sol[v] = c2 if sol_local[v] == c1 else c1\n        return new_sol\n\n    def normalize(sol_local):\n        # Map to consecutive labels 1..q in sorted order to stabilize\n        uniq = sorted(set(sol_local))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = [i for i in range(n) if conflicts_of_vertex(sol, i) > 0]\n\n    # If conflicts exist: repair-focused moves\n    if conflict_vertices:\n        # Pick vertex of maximum conflicts (break ties randomly)\n        best_conf = -1\n        cand = []\n        for i in conflict_vertices:\n            c = conflicts_of_vertex(sol, i)\n            if c > best_conf:\n                best_conf = c\n                cand = [i]\n            elif c == best_conf:\n                cand.append(i)\n        v = random.choice(cand)\n        # Palette bias: neighbor colors first, plus try new color if necessary\n        neighbor_colors = sorted({sol[u] for u in adj[v]})\n        palette = list(range(1, current_K + 1))\n        # Try min-conflict recolor within 1..K\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        # If still conflicting, try introducing K+1\n        if conflicts_of_vertex(new_sol, v) > 0:\n            new_color2 = current_K + 1\n            new_sol[v] = new_color2\n            # Normalize after potential increase\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"Recolor-Expand\")\n        # Occasionally use a targeted Kempe chain with neighbor colors\n        if neighbor_colors and random.random() < 0.3:\n            c1 = sol[v]\n            c2 = random.choice(neighbor_colors)\n            ksol = kempe_chain_swap(sol, v, c1, c2)\n            ksol = normalize(ksol)\n            return ksol, (\"Local\", \"Kempe-Chain\")\n        new_sol = normalize(new_sol)\n        return new_sol, (\"Local\", \"Recolor-MinConflict\")\n\n    # No conflicts: try to reduce K\n    max_color = current_K\n    max_vertices = [i for i, c in enumerate(sol) if c == max_color]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        feasible = [c for c in range(1, max_color) if all(sol[u] != c for u in adj[v])]\n        if feasible:\n            new_sol = sol[:]\n            # DSATUR-like: pick smallest feasible color\n            new_sol[v] = min(feasible)\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"ReduceK-Recolor\")\n        # If no direct feasible recolor, try Kempe between max_color and a lower color\n        if max_color >= 2:\n            c2 = random.randint(1, max_color - 1)\n            new_sol = kempe_chain_swap(sol, v, max_color, c2)\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"ReduceK-Kempe\")\n\n    # Diversification: random Kempe between two colors\n    if current_K >= 2:\n        c1, c2 = random.sample(list(range(1, current_K + 1)), 2)\n        idxs = [i for i, c in enumerate(sol) if c == c1]\n        v = random.choice(idxs) if idxs else random.randrange(n)\n        new_sol = kempe_chain_swap(sol, v, c1, c2)\n        new_sol = normalize(new_sol)\n        return new_sol, (\"Local\", \"Kempe-Random\")\n\n    # Fallback: simple recolor\n    v = random.randrange(n)\n    nc = 1 if sol[v] != 1 else 2\n    new_sol = sol[:]\n    new_sol[v] = nc\n    new_sol = normalize(new_sol)\n    return new_sol, (\"Local\", \"Recolor-Fallback\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Side-effect free perturbation producing a valid solution\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = solution[:]\n\n    def normalize(sol_local):\n        uniq = sorted(set(sol_local))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        nloc = len(s)\n        visited = [False] * nloc\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and s[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = s[:]\n        for v in comp:\n            out[v] = c2 if s[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n\n    # Strength k\n    k = max(3, n \/\/ 3)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.55:\n            # Random recolor biased to 1..current_K\n            i = random.randrange(n)\n            palette = list(range(1, max(2, current_K + (1 if random.random() < 0.25 else 0))))\n            nc = random.choice(palette)\n            if nc == sol[i]:\n                nc = (nc % max(palette)) + 1\n            sol[i] = nc\n        else:\n            # Kempe swap between two colors (possibly introducing a new color)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.3:\n                palette.append(current_K + 1)\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                idxs = [idx for idx, c in enumerate(sol) if c == c1]\n                v = random.choice(idxs) if idxs else random.randrange(n)\n                sol = kempe_chain_swap_local(sol, v, c1, c2)\n        current_K = max(sol)\n\n    # Random relabel to break symmetry, then canonicalize\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    sol = [relabel[c] for c in sol]\n    sol = normalize(sol)\n    return sol\n","Resultados":[[4,2,3,2,1,4,1,3,2],4003,[2,1,3,2,1,3,1,2,3],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003380289}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Safe K\n    K = max(solution) if solution else 10**9\n    # Cost: lexicographic emulate with weighted sum\n    # Keep dynamic range moderate for SA acceptance\n    return 1000 * conflicts + K\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency once\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Fallback to random valid-like solution if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        base = [random.randint(1, 3) for _ in range(n)]\n        return base, (\"Local\", \"Init-Random\")\n\n    sol = solution[:]\n\n    def conflicts_of_vertex(sol_local, v):\n        cv = sol_local[v]\n        cnt = 0\n        for nb in adj[v]:\n            if sol_local[nb] == cv:\n                cnt += 1\n        return cnt\n\n    def min_conflict_color(sol_local, v, palette):\n        best = None\n        best_cnt = 10**9\n        for col in palette:\n            if col == sol_local[v]:\n                continue\n            cnt = 0\n            for nb in adj[v]:\n                if sol_local[nb] == col:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best = [col]\n            elif cnt == best_cnt:\n                best.append(col)\n        if best is None:\n            return sol_local[v]\n        return random.choice(best)\n\n    def kempe_chain_swap(sol_local, start_v, c1, c2):\n        if c1 == c2:\n            return sol_local[:]\n        if sol_local[start_v] not in (c1, c2):\n            return sol_local[:]\n        allowed = {c1, c2}\n        stack = [start_v]\n        visited = [False] * n\n        visited[start_v] = True\n        component = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (sol_local[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    component.append(nb)\n        new_sol = sol_local[:]\n        for v in component:\n            new_sol[v] = c2 if sol_local[v] == c1 else c1\n        return new_sol\n\n    def normalize(sol_local):\n        # Map to consecutive labels 1..q in sorted order to stabilize\n        uniq = sorted(set(sol_local))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = [i for i in range(n) if conflicts_of_vertex(sol, i) > 0]\n\n    # If conflicts exist: repair-focused moves\n    if conflict_vertices:\n        # Pick vertex of maximum conflicts (break ties randomly)\n        best_conf = -1\n        cand = []\n        for i in conflict_vertices:\n            c = conflicts_of_vertex(sol, i)\n            if c > best_conf:\n                best_conf = c\n                cand = [i]\n            elif c == best_conf:\n                cand.append(i)\n        v = random.choice(cand)\n        # Palette bias: neighbor colors first, plus try new color if necessary\n        neighbor_colors = sorted({sol[u] for u in adj[v]})\n        palette = list(range(1, current_K + 1))\n        # Try min-conflict recolor within 1..K\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        # If still conflicting, try introducing K+1\n        if conflicts_of_vertex(new_sol, v) > 0:\n            new_color2 = current_K + 1\n            new_sol[v] = new_color2\n            # Normalize after potential increase\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"Recolor-Expand\")\n        # Occasionally use a targeted Kempe chain with neighbor colors\n        if neighbor_colors and random.random() < 0.3:\n            c1 = sol[v]\n            c2 = random.choice(neighbor_colors)\n            ksol = kempe_chain_swap(sol, v, c1, c2)\n            ksol = normalize(ksol)\n            return ksol, (\"Local\", \"Kempe-Chain\")\n        new_sol = normalize(new_sol)\n        return new_sol, (\"Local\", \"Recolor-MinConflict\")\n\n    # No conflicts: try to reduce K\n    max_color = current_K\n    max_vertices = [i for i, c in enumerate(sol) if c == max_color]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        feasible = [c for c in range(1, max_color) if all(sol[u] != c for u in adj[v])]\n        if feasible:\n            new_sol = sol[:]\n            # DSATUR-like: pick smallest feasible color\n            new_sol[v] = min(feasible)\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"ReduceK-Recolor\")\n        # If no direct feasible recolor, try Kempe between max_color and a lower color\n        if max_color >= 2:\n            c2 = random.randint(1, max_color - 1)\n            new_sol = kempe_chain_swap(sol, v, max_color, c2)\n            new_sol = normalize(new_sol)\n            return new_sol, (\"Local\", \"ReduceK-Kempe\")\n\n    # Diversification: random Kempe between two colors\n    if current_K >= 2:\n        c1, c2 = random.sample(list(range(1, current_K + 1)), 2)\n        idxs = [i for i, c in enumerate(sol) if c == c1]\n        v = random.choice(idxs) if idxs else random.randrange(n)\n        new_sol = kempe_chain_swap(sol, v, c1, c2)\n        new_sol = normalize(new_sol)\n        return new_sol, (\"Local\", \"Kempe-Random\")\n\n    # Fallback: simple recolor\n    v = random.randrange(n)\n    nc = 1 if sol[v] != 1 else 2\n    new_sol = sol[:]\n    new_sol[v] = nc\n    new_sol = normalize(new_sol)\n    return new_sol, (\"Local\", \"Recolor-Fallback\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Side-effect free perturbation producing a valid solution\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = solution[:]\n\n    def normalize(sol_local):\n        uniq = sorted(set(sol_local))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol_local]\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        nloc = len(s)\n        visited = [False] * nloc\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and s[nb] in allowed:\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = s[:]\n        for v in comp:\n            out[v] = c2 if s[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n\n    # Strength k\n    k = max(3, n \/\/ 3)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.55:\n            # Random recolor biased to 1..current_K\n            i = random.randrange(n)\n            palette = list(range(1, max(2, current_K + (1 if random.random() < 0.25 else 0))))\n            nc = random.choice(palette)\n            if nc == sol[i]:\n                nc = (nc % max(palette)) + 1\n            sol[i] = nc\n        else:\n            # Kempe swap between two colors (possibly introducing a new color)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.3:\n                palette.append(current_K + 1)\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                idxs = [idx for idx, c in enumerate(sol) if c == c1]\n                v = random.choice(idxs) if idxs else random.randrange(n)\n                sol = kempe_chain_swap_local(sol, v, c1, c2)\n        current_K = max(sol)\n\n    # Random relabel to break symmetry, then canonicalize\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    relabel = {c: perm[j] for j, c in enumerate(palette)}\n    sol = [relabel[c] for c in sol]\n    sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001597179}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Safe K\n    K = max(solution) if solution else 10**12\n    # Cost: strict lexicographic emulate with large weight to dominate K\n    return conflicts * (10**6) + K\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n        return sol, (\"Local\", \"Init-Random\")\n    sol = solution[:]\n\n    def conflicts_of_vertex(sol_local, v):\n        cv = sol_local[v]\n        return sum(1 for nb in adj[v] if sol_local[nb] == cv)\n\n    def min_conflict_color(sol_local, v, palette):\n        best_cols = []\n        best_cnt = 10**9\n        for col in palette:\n            if col == sol_local[v]:\n                continue\n            cnt = 0\n            for nb in adj[v]:\n                if sol_local[nb] == col:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_cols = [col]\n            elif cnt == best_cnt:\n                best_cols.append(col)\n        if not best_cols:\n            return sol_local[v]\n        return random.choice(best_cols)\n\n    def kempe_chain_swap(sol_local, start_v, c1, c2):\n        if c1 == c2:\n            return sol_local[:]\n        if sol_local[start_v] not in (c1, c2):\n            return sol_local[:]\n        allowed = {c1, c2}\n        visited = [False] * n\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (sol_local[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = sol_local[:]\n        for v in comp:\n            out[v] = c2 if sol_local[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = [i for i in range(n) if conflicts_of_vertex(sol, i) > 0]\n\n    # If conflicts exist: prioritize repair moves\n    if conflict_vertices:\n        # Pick vertex with highest conflicts (tie-break random)\n        max_conf = -1\n        cand = []\n        for i in conflict_vertices:\n            c = conflicts_of_vertex(sol, i)\n            if c > max_conf:\n                max_conf = c\n                cand = [i]\n            elif c == max_conf:\n                cand.append(i)\n        v = random.choice(cand)\n        palette = list(range(1, current_K + 1))\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        if conflicts_of_vertex(new_sol, v) > 0:\n            # Try targeted Kempe with a neighbor color\n            nb_cols = [sol[nb] for nb in adj[v]]\n            if nb_cols:\n                c2 = random.choice(nb_cols)\n                ksol = kempe_chain_swap(sol, v, sol[v], c2)\n                return ksol, (\"Local\", \"Kempe-Repair\")\n            # As last resort, allow K+1 introduction with small prob\n            if random.random() < 0.2:\n                new_sol[v] = current_K + 1\n                return new_sol, (\"Local\", \"Recolor-Expand\")\n        return new_sol, (\"Local\", \"Recolor-MinConflict\")\n\n    # No conflicts: attempt to reduce K\n    max_vertices = [i for i, c in enumerate(sol) if c == current_K]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        # Try to recolor v to a lower feasible color\n        feasible = [c for c in range(1, current_K) if all(sol[nb] != c for nb in adj[v])]\n        if feasible:\n            new_sol = sol[:]\n            new_sol[v] = min(feasible)\n            return new_sol, (\"Local\", \"ReduceK-Recolor\")\n        # If not directly feasible, try Kempe between max_color and random lower color\n        if current_K >= 2:\n            c2 = random.randint(1, current_K - 1)\n            new_sol = kempe_chain_swap(sol, v, current_K, c2)\n            return new_sol, (\"Local\", \"ReduceK-Kempe\")\n\n    # Diversification: random Kempe or recolor\n    if current_K >= 2:\n        c1, c2 = random.sample(list(range(1, current_K + 1)), 2)\n        idxs = [i for i, c in enumerate(sol) if c == c1]\n        v = random.choice(idxs) if idxs else random.randrange(n)\n        new_sol = kempe_chain_swap(sol, v, c1, c2)\n        return new_sol, (\"Local\", \"Kempe-Random\")\n\n    # Fallback: simple recolor\n    v = random.randrange(n)\n    nc = 1 if sol[v] != 1 else 2\n    new_sol = sol[:]\n    new_sol[v] = nc\n    return new_sol, (\"Local\", \"Recolor-Fallback\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution (same representation)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = solution[:]\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        visited = [False] * n\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (s[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = s[:]\n        for v in comp:\n            out[v] = c2 if s[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n    k = random.randint(2, 4)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.5:\n            # Random recolor with slight chance to introduce new color\n            i = random.randrange(n)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.2:\n                palette.append(current_K + 1)\n            nc = random.choice(palette)\n            if nc == sol[i]:\n                nc = ((nc) % max(palette)) + 1\n            sol[i] = nc\n        else:\n            # Random Kempe swap\n            palette = list(range(1, current_K + 1))\n            if len(palette) < 2:\n                palette.append(current_K + 1)\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                idxs = [idx for idx, c in enumerate(sol) if c == c1]\n                v = random.choice(idxs) if idxs else random.randrange(n)\n                sol = kempe_chain_swap_local(sol, v, c1, c2)\n        current_K = max(sol)\n\n    return sol\n","Resultados":[[2,1,3,2,1,3,1,2,3],3,[3,2,1,3,2,1,2,3,1],3],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001780551}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Safe K\n    K = max(solution) if solution else 10**12\n    # Cost: strict lexicographic emulate with large weight to dominate K\n    return conflicts * (10**6) + K\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n        return sol, (\"Local\", \"Init-Random\")\n    sol = solution[:]\n\n    def conflicts_of_vertex(sol_local, v):\n        cv = sol_local[v]\n        return sum(1 for nb in adj[v] if sol_local[nb] == cv)\n\n    def min_conflict_color(sol_local, v, palette):\n        best_cols = []\n        best_cnt = 10**9\n        for col in palette:\n            if col == sol_local[v]:\n                continue\n            cnt = 0\n            for nb in adj[v]:\n                if sol_local[nb] == col:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_cols = [col]\n            elif cnt == best_cnt:\n                best_cols.append(col)\n        if not best_cols:\n            return sol_local[v]\n        return random.choice(best_cols)\n\n    def kempe_chain_swap(sol_local, start_v, c1, c2):\n        if c1 == c2:\n            return sol_local[:]\n        if sol_local[start_v] not in (c1, c2):\n            return sol_local[:]\n        allowed = {c1, c2}\n        visited = [False] * n\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (sol_local[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = sol_local[:]\n        for v in comp:\n            out[v] = c2 if sol_local[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = [i for i in range(n) if conflicts_of_vertex(sol, i) > 0]\n\n    # If conflicts exist: prioritize repair moves\n    if conflict_vertices:\n        # Pick vertex with highest conflicts (tie-break random)\n        max_conf = -1\n        cand = []\n        for i in conflict_vertices:\n            c = conflicts_of_vertex(sol, i)\n            if c > max_conf:\n                max_conf = c\n                cand = [i]\n            elif c == max_conf:\n                cand.append(i)\n        v = random.choice(cand)\n        palette = list(range(1, current_K + 1))\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        if conflicts_of_vertex(new_sol, v) > 0:\n            # Try targeted Kempe with a neighbor color\n            nb_cols = [sol[nb] for nb in adj[v]]\n            if nb_cols:\n                c2 = random.choice(nb_cols)\n                ksol = kempe_chain_swap(sol, v, sol[v], c2)\n                return ksol, (\"Local\", \"Kempe-Repair\")\n            # As last resort, allow K+1 introduction with small prob\n            if random.random() < 0.2:\n                new_sol[v] = current_K + 1\n                return new_sol, (\"Local\", \"Recolor-Expand\")\n        return new_sol, (\"Local\", \"Recolor-MinConflict\")\n\n    # No conflicts: attempt to reduce K\n    max_vertices = [i for i, c in enumerate(sol) if c == current_K]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        # Try to recolor v to a lower feasible color\n        feasible = [c for c in range(1, current_K) if all(sol[nb] != c for nb in adj[v])]\n        if feasible:\n            new_sol = sol[:]\n            new_sol[v] = min(feasible)\n            return new_sol, (\"Local\", \"ReduceK-Recolor\")\n        # If not directly feasible, try Kempe between max_color and random lower color\n        if current_K >= 2:\n            c2 = random.randint(1, current_K - 1)\n            new_sol = kempe_chain_swap(sol, v, current_K, c2)\n            return new_sol, (\"Local\", \"ReduceK-Kempe\")\n\n    # Diversification: random Kempe or recolor\n    if current_K >= 2:\n        c1, c2 = random.sample(list(range(1, current_K + 1)), 2)\n        idxs = [i for i, c in enumerate(sol) if c == c1]\n        v = random.choice(idxs) if idxs else random.randrange(n)\n        new_sol = kempe_chain_swap(sol, v, c1, c2)\n        return new_sol, (\"Local\", \"Kempe-Random\")\n\n    # Fallback: simple recolor\n    v = random.randrange(n)\n    nc = 1 if sol[v] != 1 else 2\n    new_sol = sol[:]\n    new_sol[v] = nc\n    return new_sol, (\"Local\", \"Recolor-Fallback\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution (same representation)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = solution[:]\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        visited = [False] * n\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (s[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = s[:]\n        for v in comp:\n            out[v] = c2 if s[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n    k = random.randint(2, 4)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.5:\n            # Random recolor with slight chance to introduce new color\n            i = random.randrange(n)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.2:\n                palette.append(current_K + 1)\n            nc = random.choice(palette)\n            if nc == sol[i]:\n                nc = ((nc) % max(palette)) + 1\n            sol[i] = nc\n        else:\n            # Random Kempe swap\n            palette = list(range(1, current_K + 1))\n            if len(palette) < 2:\n                palette.append(current_K + 1)\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                idxs = [idx for idx, c in enumerate(sol) if c == c1]\n                v = random.choice(idxs) if idxs else random.randrange(n)\n                sol = kempe_chain_swap_local(sol, v, c1, c2)\n        current_K = max(sol)\n\n    return sol\n","Resultados":[[4,4,3,2,4,3,2,1,3],10000003,[3,2,2,4,1,3,1,2,4],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002435759}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Safe K\n    K = max(solution) if solution else 10**12\n    # Cost: strict lexicographic emulate with large weight to dominate K\n    return conflicts * (10**6) + K\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n        return sol, (\"Local\", \"Init-Random\")\n    sol = solution[:]\n\n    def conflicts_of_vertex(sol_local, v):\n        cv = sol_local[v]\n        return sum(1 for nb in adj[v] if sol_local[nb] == cv)\n\n    def min_conflict_color(sol_local, v, palette):\n        best_cols = []\n        best_cnt = 10**9\n        for col in palette:\n            if col == sol_local[v]:\n                continue\n            cnt = 0\n            for nb in adj[v]:\n                if sol_local[nb] == col:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_cols = [col]\n            elif cnt == best_cnt:\n                best_cols.append(col)\n        if not best_cols:\n            return sol_local[v]\n        return random.choice(best_cols)\n\n    def kempe_chain_swap(sol_local, start_v, c1, c2):\n        if c1 == c2:\n            return sol_local[:]\n        if sol_local[start_v] not in (c1, c2):\n            return sol_local[:]\n        allowed = {c1, c2}\n        visited = [False] * n\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (sol_local[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = sol_local[:]\n        for v in comp:\n            out[v] = c2 if sol_local[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n\n    # Identify conflicting vertices\n    conflict_vertices = [i for i in range(n) if conflicts_of_vertex(sol, i) > 0]\n\n    # If conflicts exist: prioritize repair moves\n    if conflict_vertices:\n        # Pick vertex with highest conflicts (tie-break random)\n        max_conf = -1\n        cand = []\n        for i in conflict_vertices:\n            c = conflicts_of_vertex(sol, i)\n            if c > max_conf:\n                max_conf = c\n                cand = [i]\n            elif c == max_conf:\n                cand.append(i)\n        v = random.choice(cand)\n        palette = list(range(1, current_K + 1))\n        new_color = min_conflict_color(sol, v, palette)\n        new_sol = sol[:]\n        new_sol[v] = new_color\n        if conflicts_of_vertex(new_sol, v) > 0:\n            # Try targeted Kempe with a neighbor color\n            nb_cols = [sol[nb] for nb in adj[v]]\n            if nb_cols:\n                c2 = random.choice(nb_cols)\n                ksol = kempe_chain_swap(sol, v, sol[v], c2)\n                return ksol, (\"Local\", \"Kempe-Repair\")\n            # As last resort, allow K+1 introduction with small prob\n            if random.random() < 0.2:\n                new_sol[v] = current_K + 1\n                return new_sol, (\"Local\", \"Recolor-Expand\")\n        return new_sol, (\"Local\", \"Recolor-MinConflict\")\n\n    # No conflicts: attempt to reduce K\n    max_vertices = [i for i, c in enumerate(sol) if c == current_K]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        # Try to recolor v to a lower feasible color\n        feasible = [c for c in range(1, current_K) if all(sol[nb] != c for nb in adj[v])]\n        if feasible:\n            new_sol = sol[:]\n            new_sol[v] = min(feasible)\n            return new_sol, (\"Local\", \"ReduceK-Recolor\")\n        # If not directly feasible, try Kempe between max_color and random lower color\n        if current_K >= 2:\n            c2 = random.randint(1, current_K - 1)\n            new_sol = kempe_chain_swap(sol, v, current_K, c2)\n            return new_sol, (\"Local\", \"ReduceK-Kempe\")\n\n    # Diversification: random Kempe or recolor\n    if current_K >= 2:\n        c1, c2 = random.sample(list(range(1, current_K + 1)), 2)\n        idxs = [i for i, c in enumerate(sol) if c == c1]\n        v = random.choice(idxs) if idxs else random.randrange(n)\n        new_sol = kempe_chain_swap(sol, v, c1, c2)\n        return new_sol, (\"Local\", \"Kempe-Random\")\n\n    # Fallback: simple recolor\n    v = random.randrange(n)\n    nc = 1 if sol[v] != 1 else 2\n    new_sol = sol[:]\n    new_sol[v] = nc\n    return new_sol, (\"Local\", \"Recolor-Fallback\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution (same representation)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Validate \/ initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = solution[:]\n\n    def kempe_chain_swap_local(s, start_v, c1, c2):\n        if c1 == c2:\n            return s[:]\n        if s[start_v] not in (c1, c2):\n            return s[:]\n        allowed = {c1, c2}\n        visited = [False] * n\n        stack = [start_v]\n        visited[start_v] = True\n        comp = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if (not visited[nb]) and (s[nb] in allowed):\n                    visited[nb] = True\n                    stack.append(nb)\n                    comp.append(nb)\n        out = s[:]\n        for v in comp:\n            out[v] = c2 if s[v] == c1 else c1\n        return out\n\n    current_K = max(sol)\n    k = random.randint(2, 4)\n    for _ in range(k):\n        r = random.random()\n        if r < 0.5:\n            # Random recolor with slight chance to introduce new color\n            i = random.randrange(n)\n            palette = list(range(1, current_K + 1))\n            if random.random() < 0.2:\n                palette.append(current_K + 1)\n            nc = random.choice(palette)\n            if nc == sol[i]:\n                nc = ((nc) % max(palette)) + 1\n            sol[i] = nc\n        else:\n            # Random Kempe swap\n            palette = list(range(1, current_K + 1))\n            if len(palette) < 2:\n                palette.append(current_K + 1)\n            if len(palette) >= 2:\n                c1, c2 = random.sample(palette, 2)\n                idxs = [idx for idx, c in enumerate(sol) if c == c1]\n                v = random.choice(idxs) if idxs else random.randrange(n)\n                sol = kempe_chain_swap_local(sol, v, c1, c2)\n        current_K = max(sol)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001225324}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"JSON list of length 9 with positive integers >=1. Index i-1 stores the color of vertex i. Example: [1,2,3,1,2,3,2,1,3]. Objective is to minimize max(color) subject to proper coloring on given edges.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Proper coloring constraint\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective: minimize number of colors used\n    return max(solution)\n","Vecindad":"import random\nimport copy\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven single-vertex recolor; else color compaction move.\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    s = solution if isinstance(solution, list) else []\n    if not isinstance(s, list) or len(s) != n:\n        # Fallback: create a trivial feasible-like starting point (random colors 1..3)\n        s = [random.randint(1, 3) for _ in range(n)]\n    new_s = s[:]\n    max_col = max(new_s) if new_s else 3\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if new_s[u-1] == new_s[v-1]:\n            conflicts.append((u,v))\n    if conflicts:\n        # Pick one endpoint from a random conflicting edge and try to recolor to lowest feasible color\n        u, v = random.choice(conflicts)\n        vertex = random.choice([u, v])\n        # Neighbor colors\n        neigh = {w for (a,b) in E for w in ([b] if a == vertex else ([a] if b == vertex else []))}\n        used = {new_s[w-1] for w in neigh}\n        # Try colors 1..max_col, else introduce max_col+1\n        chosen = None\n        for c in range(1, max_col + 1):\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = max_col + 1\n        new_s[vertex-1] = chosen\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN\")\n    else:\n        # No conflicts: try to reduce palette by moving a max-color vertex to a lower feasible color\n        max_vertices = [i+1 for i, c in enumerate(new_s) if c == max_col]\n        if max_vertices:\n            vertex = random.choice(max_vertices)\n            neigh = {w for (a,b) in E for w in ([b] if a == vertex else ([a] if b == vertex else []))}\n            used = {new_s[w-1] for w in neigh}\n            # Try to assign the lowest color < max_col\n            lower_colors = [c for c in range(1, max_col) if c not in used]\n            if lower_colors:\n                new_s[vertex-1] = random.choice(lower_colors)\n                return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION\")\n        # If cannot compact, swap colors between two random vertices to diversify\n        i, j = random.sample(range(n), 2)\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        return (new_s, \"SWAP_TWO_VERTICES\", \"DIVERSIFYING\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger randomization: reassign colors of a random subset; may introduce a new color with small probability\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    s = solution if isinstance(solution, list) and len(solution) == n else [random.randint(1, 3) for _ in range(n)]\n    new_s = s[:]\n    max_col = max(new_s) if new_s else 3\n    # Choose a random subset size\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # With small probability, allow a new color; otherwise pick among existing colors\n        allow_new = random.random() < 0.25\n        palette_max = max_col + 1 if allow_new else max_col\n        # Try multiple attempts to find a color that reduces conflicts locally\n        neigh = {w for (a,b) in E for w in ([b] if a == (idx+1) else ([a] if b == (idx+1) else []))}\n        used = {new_s[w-1] for w in neigh}\n        candidates = [c for c in range(1, palette_max+1)]\n        random.shuffle(candidates)\n        chosen = None\n        for c in candidates:\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = random.randint(1, palette_max)\n        new_s[idx] = chosen\n        max_col = max(max_col, chosen)\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000665318}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"JSON list of length 9 with positive integers >=1. Index i-1 stores the color of vertex i. Example: [1,2,3,1,2,3,2,1,3]. Objective is to minimize max(color) subject to proper coloring on given edges.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Proper coloring constraint\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective: minimize number of colors used\n    return max(solution)\n","Vecindad":"import random\nimport copy\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven single-vertex recolor; else color compaction move.\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    s = solution if isinstance(solution, list) else []\n    if not isinstance(s, list) or len(s) != n:\n        # Fallback: create a trivial feasible-like starting point (random colors 1..3)\n        s = [random.randint(1, 3) for _ in range(n)]\n    new_s = s[:]\n    max_col = max(new_s) if new_s else 3\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if new_s[u-1] == new_s[v-1]:\n            conflicts.append((u,v))\n    if conflicts:\n        # Pick one endpoint from a random conflicting edge and try to recolor to lowest feasible color\n        u, v = random.choice(conflicts)\n        vertex = random.choice([u, v])\n        # Neighbor colors\n        neigh = {w for (a,b) in E for w in ([b] if a == vertex else ([a] if b == vertex else []))}\n        used = {new_s[w-1] for w in neigh}\n        # Try colors 1..max_col, else introduce max_col+1\n        chosen = None\n        for c in range(1, max_col + 1):\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = max_col + 1\n        new_s[vertex-1] = chosen\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN\")\n    else:\n        # No conflicts: try to reduce palette by moving a max-color vertex to a lower feasible color\n        max_vertices = [i+1 for i, c in enumerate(new_s) if c == max_col]\n        if max_vertices:\n            vertex = random.choice(max_vertices)\n            neigh = {w for (a,b) in E for w in ([b] if a == vertex else ([a] if b == vertex else []))}\n            used = {new_s[w-1] for w in neigh}\n            # Try to assign the lowest color < max_col\n            lower_colors = [c for c in range(1, max_col) if c not in used]\n            if lower_colors:\n                new_s[vertex-1] = random.choice(lower_colors)\n                return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION\")\n        # If cannot compact, swap colors between two random vertices to diversify\n        i, j = random.sample(range(n), 2)\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        return (new_s, \"SWAP_TWO_VERTICES\", \"DIVERSIFYING\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger randomization: reassign colors of a random subset; may introduce a new color with small probability\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    s = solution if isinstance(solution, list) and len(solution) == n else [random.randint(1, 3) for _ in range(n)]\n    new_s = s[:]\n    max_col = max(new_s) if new_s else 3\n    # Choose a random subset size\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # With small probability, allow a new color; otherwise pick among existing colors\n        allow_new = random.random() < 0.25\n        palette_max = max_col + 1 if allow_new else max_col\n        # Try multiple attempts to find a color that reduces conflicts locally\n        neigh = {w for (a,b) in E for w in ([b] if a == (idx+1) else ([a] if b == (idx+1) else []))}\n        used = {new_s[w-1] for w in neigh}\n        candidates = [c for c in range(1, palette_max+1)]\n        random.shuffle(candidates)\n        chosen = None\n        for c in candidates:\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = random.randint(1, palette_max)\n        new_s[idx] = chosen\n        max_col = max(max_col, chosen)\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00082993}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"JSON list of length 9 with positive integers >=1. Index i-1 stores the color of vertex i. Example: [1,2,3,1,2,3,2,1,3]. Objective is to minimize max(color) subject to proper coloring on given edges.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Proper coloring constraint\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    # Fitness equals objective: minimize number of colors used\n    return max(solution)\n","Vecindad":"import random\nimport copy\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven single-vertex recolor; else color compaction move.\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    s = solution if isinstance(solution, list) else []\n    if not isinstance(s, list) or len(s) != n:\n        # Fallback: create a trivial feasible-like starting point (random colors 1..3)\n        s = [random.randint(1, 3) for _ in range(n)]\n    new_s = s[:]\n    max_col = max(new_s) if new_s else 3\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if new_s[u-1] == new_s[v-1]:\n            conflicts.append((u,v))\n    if conflicts:\n        # Pick one endpoint from a random conflicting edge and try to recolor to lowest feasible color\n        u, v = random.choice(conflicts)\n        vertex = random.choice([u, v])\n        # Neighbor colors\n        neigh = {w for (a,b) in E for w in ([b] if a == vertex else ([a] if b == vertex else []))}\n        used = {new_s[w-1] for w in neigh}\n        # Try colors 1..max_col, else introduce max_col+1\n        chosen = None\n        for c in range(1, max_col + 1):\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = max_col + 1\n        new_s[vertex-1] = chosen\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN\")\n    else:\n        # No conflicts: try to reduce palette by moving a max-color vertex to a lower feasible color\n        max_vertices = [i+1 for i, c in enumerate(new_s) if c == max_col]\n        if max_vertices:\n            vertex = random.choice(max_vertices)\n            neigh = {w for (a,b) in E for w in ([b] if a == vertex else ([a] if b == vertex else []))}\n            used = {new_s[w-1] for w in neigh}\n            # Try to assign the lowest color < max_col\n            lower_colors = [c for c in range(1, max_col) if c not in used]\n            if lower_colors:\n                new_s[vertex-1] = random.choice(lower_colors)\n                return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION\")\n        # If cannot compact, swap colors between two random vertices to diversify\n        i, j = random.sample(range(n), 2)\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        return (new_s, \"SWAP_TWO_VERTICES\", \"DIVERSIFYING\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger randomization: reassign colors of a random subset; may introduce a new color with small probability\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    s = solution if isinstance(solution, list) and len(solution) == n else [random.randint(1, 3) for _ in range(n)]\n    new_s = s[:]\n    max_col = max(new_s) if new_s else 3\n    # Choose a random subset size\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # With small probability, allow a new color; otherwise pick among existing colors\n        allow_new = random.random() < 0.25\n        palette_max = max_col + 1 if allow_new else max_col\n        # Try multiple attempts to find a color that reduces conflicts locally\n        neigh = {w for (a,b) in E for w in ([b] if a == (idx+1) else ([a] if b == (idx+1) else []))}\n        used = {new_s[w-1] for w in neigh}\n        candidates = [c for c in range(1, palette_max+1)]\n        random.shuffle(candidates)\n        chosen = None\n        for c in candidates:\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = random.randint(1, palette_max)\n        new_s[idx] = chosen\n        max_col = max(max_col, chosen)\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000793619}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS:c[i-1] is color of vertex i; objective minimize max(c).","Evaluacion":"# Imports included as required\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Graph definition (embedded)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Build adjacency for early exit\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Proper coloring constraint check\n    for u in range(1, n+1):\n        cu = solution[u-1]\n        for v in adj[u]:\n            if v > u and cu == solution[v-1]:\n                return PENALTY\n    # Fitness equals number of colors used (minimize)\n    return max(solution)","Vecindad":"# Imports included as required\nimport random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Defensive copy and basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    # Precompute adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(arr: List[int]) -> List[int]:\n        # Relabel colors to 1..k by order of first occurrence\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(arr: List[int]) -> List[Tuple[int,int]]:\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    new_s = s[:]\n    max_col = max(new_s)\n\n    confs = conflicts_list(new_s)\n    if confs:\n        # Conflict-driven recolor: pick vertex with max saturation from conflicting vertices\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Saturation: number of distinct neighbor colors\n        sat = {}\n        for u in cand_vertices:\n            neigh_colors = {new_s[v-1] for v in adj[u]}\n            sat[u] = len(neigh_colors)\n        max_sat = max(sat.values())\n        best_cands = [u for u in cand_vertices if sat[u] == max_sat]\n        vertex = random.choice(best_cands)\n        used = {new_s[v-1] for v in adj[vertex]}\n        # Try smallest feasible color <= max_col; only use new color if all used\n        chosen = None\n        for c in range(1, max_col + 0):\n            if c >= 1 and c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            # allow keeping same color if it reduces number of conflicts via tie-breaking\n            for c in range(1, max_col + 1):\n                if c not in used:\n                    chosen = c\n                    break\n        if chosen is None:\n            chosen = max_col + 1\n        old = new_s[vertex-1]\n        new_s[vertex-1] = chosen\n        new_s = normalize_colors(new_s)\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN_DSATUR\")\n    else:\n        # No conflicts: try color compaction from max color class\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    new_s = normalize_colors(new_s)\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION_FIRST_FIT\")\n        # If compaction not possible, perform a targeted two-color Kempe-like swap on random colors a,b\n        colors = list({c for c in new_s})\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a vertex with color a or b to define component; here simplified: flip all a<->b on neighbors of a random seed\n            seed = random.choice([i for i, c in enumerate(new_s, start=1) if c in (a, b)])\n            queue = [seed]\n            visited = set()\n            comp = set()\n            while queue:\n                u = queue.pop()\n                if u in visited or new_s[u-1] not in (a, b):\n                    continue\n                visited.add(u)\n                comp.add(u)\n                for v in adj[u]:\n                    if new_s[v-1] in (a, b) and v not in visited:\n                        queue.append(v)\n            for u in comp:\n                new_s[u-1] = a if new_s[u-1] == b else (b if new_s[u-1] == a else new_s[u-1])\n            new_s = normalize_colors(new_s)\n            return (new_s, \"KEMPE_SWAP\", \"DIVERSIFYING_COMPONENT_FLIP\")\n        # Fallback minor shuffle among max color and a random other vertex\n        i = random.choice([idx-1 for idx in max_vertices])\n        j = random.randrange(0, n)\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        new_s = normalize_colors(new_s)\n        return (new_s, \"SWAP_TWO_VERTICES\", \"FALLBACK_DIVERSIFY\")","Perturbacion":"# Imports included as required\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # k-vertex kick focused on highest colors; maintains list structure\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    # Precompute adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(arr: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    max_col = max(s)\n    top_vertices = [i for i, c in enumerate(s, start=1) if c == max_col]\n    others = [i for i in range(1, n+1) if i not in top_vertices]\n    k = min(n, max(2, len(top_vertices)))\n    chosen = top_vertices[:]\n    random.shuffle(chosen)\n    chosen = chosen[:k]\n    # Ensure at least 2 distinct vertices perturbed\n    while len(chosen) < 2 and others:\n        chosen.append(random.choice(others))\n    new_s = s[:]\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # Prefer low colors to aid compaction\n        palette = list(range(1, max_col+1))\n        random.shuffle(palette)\n        chosen_c = None\n        for c in sorted(palette):\n            if c not in used:\n                chosen_c = c\n                break\n        if chosen_c is None:\n            chosen_c = random.randint(1, max_col)\n        new_s[u-1] = chosen_c\n    new_s = normalize_colors(new_s)\n    return new_s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001007772}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS:c[i-1] is color of vertex i; objective minimize max(c).","Evaluacion":"# Imports included as required\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Graph definition (embedded)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Build adjacency for early exit\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Proper coloring constraint check\n    for u in range(1, n+1):\n        cu = solution[u-1]\n        for v in adj[u]:\n            if v > u and cu == solution[v-1]:\n                return PENALTY\n    # Fitness equals number of colors used (minimize)\n    return max(solution)","Vecindad":"# Imports included as required\nimport random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Defensive copy and basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    # Precompute adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(arr: List[int]) -> List[int]:\n        # Relabel colors to 1..k by order of first occurrence\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(arr: List[int]) -> List[Tuple[int,int]]:\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    new_s = s[:]\n    max_col = max(new_s)\n\n    confs = conflicts_list(new_s)\n    if confs:\n        # Conflict-driven recolor: pick vertex with max saturation from conflicting vertices\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Saturation: number of distinct neighbor colors\n        sat = {}\n        for u in cand_vertices:\n            neigh_colors = {new_s[v-1] for v in adj[u]}\n            sat[u] = len(neigh_colors)\n        max_sat = max(sat.values())\n        best_cands = [u for u in cand_vertices if sat[u] == max_sat]\n        vertex = random.choice(best_cands)\n        used = {new_s[v-1] for v in adj[vertex]}\n        # Try smallest feasible color <= max_col; only use new color if all used\n        chosen = None\n        for c in range(1, max_col + 0):\n            if c >= 1 and c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            # allow keeping same color if it reduces number of conflicts via tie-breaking\n            for c in range(1, max_col + 1):\n                if c not in used:\n                    chosen = c\n                    break\n        if chosen is None:\n            chosen = max_col + 1\n        old = new_s[vertex-1]\n        new_s[vertex-1] = chosen\n        new_s = normalize_colors(new_s)\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN_DSATUR\")\n    else:\n        # No conflicts: try color compaction from max color class\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    new_s = normalize_colors(new_s)\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION_FIRST_FIT\")\n        # If compaction not possible, perform a targeted two-color Kempe-like swap on random colors a,b\n        colors = list({c for c in new_s})\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a vertex with color a or b to define component; here simplified: flip all a<->b on neighbors of a random seed\n            seed = random.choice([i for i, c in enumerate(new_s, start=1) if c in (a, b)])\n            queue = [seed]\n            visited = set()\n            comp = set()\n            while queue:\n                u = queue.pop()\n                if u in visited or new_s[u-1] not in (a, b):\n                    continue\n                visited.add(u)\n                comp.add(u)\n                for v in adj[u]:\n                    if new_s[v-1] in (a, b) and v not in visited:\n                        queue.append(v)\n            for u in comp:\n                new_s[u-1] = a if new_s[u-1] == b else (b if new_s[u-1] == a else new_s[u-1])\n            new_s = normalize_colors(new_s)\n            return (new_s, \"KEMPE_SWAP\", \"DIVERSIFYING_COMPONENT_FLIP\")\n        # Fallback minor shuffle among max color and a random other vertex\n        i = random.choice([idx-1 for idx in max_vertices])\n        j = random.randrange(0, n)\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        new_s = normalize_colors(new_s)\n        return (new_s, \"SWAP_TWO_VERTICES\", \"FALLBACK_DIVERSIFY\")","Perturbacion":"# Imports included as required\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # k-vertex kick focused on highest colors; maintains list structure\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    # Precompute adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(arr: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    max_col = max(s)\n    top_vertices = [i for i, c in enumerate(s, start=1) if c == max_col]\n    others = [i for i in range(1, n+1) if i not in top_vertices]\n    k = min(n, max(2, len(top_vertices)))\n    chosen = top_vertices[:]\n    random.shuffle(chosen)\n    chosen = chosen[:k]\n    # Ensure at least 2 distinct vertices perturbed\n    while len(chosen) < 2 and others:\n        chosen.append(random.choice(others))\n    new_s = s[:]\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # Prefer low colors to aid compaction\n        palette = list(range(1, max_col+1))\n        random.shuffle(palette)\n        chosen_c = None\n        for c in sorted(palette):\n            if c not in used:\n                chosen_c = c\n                break\n        if chosen_c is None:\n            chosen_c = random.randint(1, max_col)\n        new_s[u-1] = chosen_c\n    new_s = normalize_colors(new_s)\n    return new_s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001227374}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS:c[i-1] is color of vertex i; objective minimize max(c).","Evaluacion":"# Imports included as required\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Graph definition (embedded)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    # Build adjacency for early exit\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Proper coloring constraint check\n    for u in range(1, n+1):\n        cu = solution[u-1]\n        for v in adj[u]:\n            if v > u and cu == solution[v-1]:\n                return PENALTY\n    # Fitness equals number of colors used (minimize)\n    return max(solution)","Vecindad":"# Imports included as required\nimport random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Defensive copy and basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    # Precompute adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(arr: List[int]) -> List[int]:\n        # Relabel colors to 1..k by order of first occurrence\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(arr: List[int]) -> List[Tuple[int,int]]:\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    new_s = s[:]\n    max_col = max(new_s)\n\n    confs = conflicts_list(new_s)\n    if confs:\n        # Conflict-driven recolor: pick vertex with max saturation from conflicting vertices\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Saturation: number of distinct neighbor colors\n        sat = {}\n        for u in cand_vertices:\n            neigh_colors = {new_s[v-1] for v in adj[u]}\n            sat[u] = len(neigh_colors)\n        max_sat = max(sat.values())\n        best_cands = [u for u in cand_vertices if sat[u] == max_sat]\n        vertex = random.choice(best_cands)\n        used = {new_s[v-1] for v in adj[vertex]}\n        # Try smallest feasible color <= max_col; only use new color if all used\n        chosen = None\n        for c in range(1, max_col + 0):\n            if c >= 1 and c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            # allow keeping same color if it reduces number of conflicts via tie-breaking\n            for c in range(1, max_col + 1):\n                if c not in used:\n                    chosen = c\n                    break\n        if chosen is None:\n            chosen = max_col + 1\n        old = new_s[vertex-1]\n        new_s[vertex-1] = chosen\n        new_s = normalize_colors(new_s)\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN_DSATUR\")\n    else:\n        # No conflicts: try color compaction from max color class\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    new_s = normalize_colors(new_s)\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION_FIRST_FIT\")\n        # If compaction not possible, perform a targeted two-color Kempe-like swap on random colors a,b\n        colors = list({c for c in new_s})\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a vertex with color a or b to define component; here simplified: flip all a<->b on neighbors of a random seed\n            seed = random.choice([i for i, c in enumerate(new_s, start=1) if c in (a, b)])\n            queue = [seed]\n            visited = set()\n            comp = set()\n            while queue:\n                u = queue.pop()\n                if u in visited or new_s[u-1] not in (a, b):\n                    continue\n                visited.add(u)\n                comp.add(u)\n                for v in adj[u]:\n                    if new_s[v-1] in (a, b) and v not in visited:\n                        queue.append(v)\n            for u in comp:\n                new_s[u-1] = a if new_s[u-1] == b else (b if new_s[u-1] == a else new_s[u-1])\n            new_s = normalize_colors(new_s)\n            return (new_s, \"KEMPE_SWAP\", \"DIVERSIFYING_COMPONENT_FLIP\")\n        # Fallback minor shuffle among max color and a random other vertex\n        i = random.choice([idx-1 for idx in max_vertices])\n        j = random.randrange(0, n)\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        new_s = normalize_colors(new_s)\n        return (new_s, \"SWAP_TWO_VERTICES\", \"FALLBACK_DIVERSIFY\")","Perturbacion":"# Imports included as required\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # k-vertex kick focused on highest colors; maintains list structure\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    # Precompute adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(arr: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    max_col = max(s)\n    top_vertices = [i for i, c in enumerate(s, start=1) if c == max_col]\n    others = [i for i in range(1, n+1) if i not in top_vertices]\n    k = min(n, max(2, len(top_vertices)))\n    chosen = top_vertices[:]\n    random.shuffle(chosen)\n    chosen = chosen[:k]\n    # Ensure at least 2 distinct vertices perturbed\n    while len(chosen) < 2 and others:\n        chosen.append(random.choice(others))\n    new_s = s[:]\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # Prefer low colors to aid compaction\n        palette = list(range(1, max_col+1))\n        random.shuffle(palette)\n        chosen_c = None\n        for c in sorted(palette):\n            if c not in used:\n                chosen_c = c\n                break\n        if chosen_c is None:\n            chosen_c = random.randint(1, max_col)\n        new_s[u-1] = chosen_c\n    new_s = normalize_colors(new_s)\n    return new_s","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001162044}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS:c[i-1] is the color of vertex i in {1,...,k}; objective minimize max(solution).","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # Feasible: cost is number of colors used (minimize)\n    return max(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(arr: List[int]) -> List[Tuple[int,int]]:\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    def degree(u: int, adj) -> int:\n        return len(adj[u])\n\n    # Defensive copy\/initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    max_col = max(new_s)\n    confs = conflicts_list(new_s)\n\n    if confs:\n        # Conflict-driven DSATUR: pick vertex among conflicting ones with highest saturation, tie-break by conflict degree then graph degree\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Compute saturation (distinct neighbor colors)\n        sat = {}\n        conf_deg = {u: 0 for u in cand_vertices}\n        for (u, v) in confs:\n            if u in conf_deg:\n                conf_deg[u] += 1\n            if v in conf_deg:\n                conf_deg[v] += 1\n        for u in cand_vertices:\n            neigh_colors = {new_s[v-1] for v in adj[u]}\n            sat[u] = len(neigh_colors)\n        max_sat = max(sat[u] for u in cand_vertices)\n        best_cands = [u for u in cand_vertices if sat[u] == max_sat]\n        # tie-break by larger conf_deg, then by larger degree\n        best_cands.sort(key=lambda u: (conf_deg.get(u,0), degree(u, adj)), reverse=True)\n        vertex = best_cands[0]\n        used = {new_s[v-1] for v in adj[vertex]}\n        # Try smallest feasible color in 1..max_col; if none, allow introducing max_col+1\n        chosen = None\n        for c in range(1, max_col+1):\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = max_col + 1\n        new_s[vertex-1] = chosen\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN_DSATUR\")\n    else:\n        # No conflicts: attempt color compaction by reassigning vertices with max color to lower feasible colors\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION_FIRST_FIT\")\n        # If compaction not possible, perform a small two-vertex swap of colors to diversify (ensure non-noop)\n        indices = list(range(n))\n        i = random.choice(indices)\n        j = random.choice([idx for idx in indices if idx != i and new_s[idx] != new_s[i]])\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        return (new_s, \"SWAP_TWO_VERTICES\", \"DIVERSIFY_SWAP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution list\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    max_col = max(new_s)\n    top_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n    others = [i for i in range(1, n+1) if i not in top_vertices]\n\n    # Choose a kick size focusing on the top color class\n    k = max(2, min(len(top_vertices) + 1, 4))  # small controlled perturbation\n    pool = list(set(top_vertices + random.sample(others, k=min(len(others), max(0, k - len(top_vertices))))))\n    random.shuffle(pool)\n    chosen = pool[:k]\n\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # bias towards lower colors to aid compaction\n        candidate_colors = list(range(1, max_col+1))\n        random.shuffle(candidate_colors)\n        candidate_colors.sort()\n        assigned = None\n        for c in candidate_colors:\n            if c not in used:\n                assigned = c\n                break\n        if assigned is None:\n            assigned = random.randint(1, max_col)\n        new_s[u-1] = assigned\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000896546}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS:c[i-1] is the color of vertex i in {1,...,k}; objective minimize max(solution).","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # Feasible: cost is number of colors used (minimize)\n    return max(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(arr: List[int]) -> List[Tuple[int,int]]:\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    def degree(u: int, adj) -> int:\n        return len(adj[u])\n\n    # Defensive copy\/initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    max_col = max(new_s)\n    confs = conflicts_list(new_s)\n\n    if confs:\n        # Conflict-driven DSATUR: pick vertex among conflicting ones with highest saturation, tie-break by conflict degree then graph degree\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Compute saturation (distinct neighbor colors)\n        sat = {}\n        conf_deg = {u: 0 for u in cand_vertices}\n        for (u, v) in confs:\n            if u in conf_deg:\n                conf_deg[u] += 1\n            if v in conf_deg:\n                conf_deg[v] += 1\n        for u in cand_vertices:\n            neigh_colors = {new_s[v-1] for v in adj[u]}\n            sat[u] = len(neigh_colors)\n        max_sat = max(sat[u] for u in cand_vertices)\n        best_cands = [u for u in cand_vertices if sat[u] == max_sat]\n        # tie-break by larger conf_deg, then by larger degree\n        best_cands.sort(key=lambda u: (conf_deg.get(u,0), degree(u, adj)), reverse=True)\n        vertex = best_cands[0]\n        used = {new_s[v-1] for v in adj[vertex]}\n        # Try smallest feasible color in 1..max_col; if none, allow introducing max_col+1\n        chosen = None\n        for c in range(1, max_col+1):\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = max_col + 1\n        new_s[vertex-1] = chosen\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN_DSATUR\")\n    else:\n        # No conflicts: attempt color compaction by reassigning vertices with max color to lower feasible colors\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION_FIRST_FIT\")\n        # If compaction not possible, perform a small two-vertex swap of colors to diversify (ensure non-noop)\n        indices = list(range(n))\n        i = random.choice(indices)\n        j = random.choice([idx for idx in indices if idx != i and new_s[idx] != new_s[i]])\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        return (new_s, \"SWAP_TWO_VERTICES\", \"DIVERSIFY_SWAP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution list\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    max_col = max(new_s)\n    top_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n    others = [i for i in range(1, n+1) if i not in top_vertices]\n\n    # Choose a kick size focusing on the top color class\n    k = max(2, min(len(top_vertices) + 1, 4))  # small controlled perturbation\n    pool = list(set(top_vertices + random.sample(others, k=min(len(others), max(0, k - len(top_vertices))))))\n    random.shuffle(pool)\n    chosen = pool[:k]\n\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # bias towards lower colors to aid compaction\n        candidate_colors = list(range(1, max_col+1))\n        random.shuffle(candidate_colors)\n        candidate_colors.sort()\n        assigned = None\n        for c in candidate_colors:\n            if c not in used:\n                assigned = c\n                break\n        if assigned is None:\n            assigned = random.randint(1, max_col)\n        new_s[u-1] = assigned\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00111913}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS:c[i-1] is the color of vertex i in {1,...,k}; objective minimize max(solution).","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    # Entry validation\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # Feasible: cost is number of colors used (minimize)\n    return max(solution)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(arr: List[int]) -> List[Tuple[int,int]]:\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    def degree(u: int, adj) -> int:\n        return len(adj[u])\n\n    # Defensive copy\/initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    max_col = max(new_s)\n    confs = conflicts_list(new_s)\n\n    if confs:\n        # Conflict-driven DSATUR: pick vertex among conflicting ones with highest saturation, tie-break by conflict degree then graph degree\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Compute saturation (distinct neighbor colors)\n        sat = {}\n        conf_deg = {u: 0 for u in cand_vertices}\n        for (u, v) in confs:\n            if u in conf_deg:\n                conf_deg[u] += 1\n            if v in conf_deg:\n                conf_deg[v] += 1\n        for u in cand_vertices:\n            neigh_colors = {new_s[v-1] for v in adj[u]}\n            sat[u] = len(neigh_colors)\n        max_sat = max(sat[u] for u in cand_vertices)\n        best_cands = [u for u in cand_vertices if sat[u] == max_sat]\n        # tie-break by larger conf_deg, then by larger degree\n        best_cands.sort(key=lambda u: (conf_deg.get(u,0), degree(u, adj)), reverse=True)\n        vertex = best_cands[0]\n        used = {new_s[v-1] for v in adj[vertex]}\n        # Try smallest feasible color in 1..max_col; if none, allow introducing max_col+1\n        chosen = None\n        for c in range(1, max_col+1):\n            if c not in used:\n                chosen = c\n                break\n        if chosen is None:\n            chosen = max_col + 1\n        new_s[vertex-1] = chosen\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DRIVEN_DSATUR\")\n    else:\n        # No conflicts: attempt color compaction by reassigning vertices with max color to lower feasible colors\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION_FIRST_FIT\")\n        # If compaction not possible, perform a small two-vertex swap of colors to diversify (ensure non-noop)\n        indices = list(range(n))\n        i = random.choice(indices)\n        j = random.choice([idx for idx in indices if idx != i and new_s[idx] != new_s[i]])\n        new_s[i], new_s[j] = new_s[j], new_s[i]\n        return (new_s, \"SWAP_TWO_VERTICES\", \"DIVERSIFY_SWAP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution list\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    max_col = max(new_s)\n    top_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n    others = [i for i in range(1, n+1) if i not in top_vertices]\n\n    # Choose a kick size focusing on the top color class\n    k = max(2, min(len(top_vertices) + 1, 4))  # small controlled perturbation\n    pool = list(set(top_vertices + random.sample(others, k=min(len(others), max(0, k - len(top_vertices))))))\n    random.shuffle(pool)\n    chosen = pool[:k]\n\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # bias towards lower colors to aid compaction\n        candidate_colors = list(range(1, max_col+1))\n        random.shuffle(candidate_colors)\n        candidate_colors.sort()\n        assigned = None\n        for c in candidate_colors:\n            if c not in used:\n                assigned = c\n                break\n        if assigned is None:\n            assigned = random.randint(1, max_col)\n        new_s[u-1] = assigned\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001100471}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS: solution[i-1] is the color (1..k) of vertex i; objective minimize k=max(solution). Colors are normalized to 1..k in moves to reduce symmetry.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph (undirected)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**5\n    CONFLICT_WEIGHT = 100\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    # Entry validation (restrict labels to 1..n to bound space)\n    for x in solution:\n        if not isinstance(x, int) or x < 1 or x > n:\n            return PENALTY_BASE\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + CONFLICT_WEIGHT * conflicts\n    # Feasible: cost is number of colors used (minimize)\n    return max(solution) if solution else PENALTY_BASE\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(arr):\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    def normalize_colors(arr):\n        # Relabel colors to 1..k preserving relative order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def smallest_feasible_color(u, arr, adj, limit_color=None):\n        used = {arr[v-1] for v in adj[u]}\n        max_try = (limit_color if limit_color is not None else max(arr))\n        for c in range(1, max_try+1):\n            if c not in used:\n                return c\n        return None\n\n    # Defensive copy\/initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    new_s = normalize_colors(new_s)\n    max_col = max(new_s)\n    confs = conflicts_list(new_s)\n\n    if confs:\n        # Conflict-driven recoloring with DSATUR-like priority\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Saturation: number of distinct neighbor colors\n        sat = {}\n        deg = {}\n        for u in cand_vertices:\n            sat[u] = len({new_s[v-1] for v in adj[u]})\n            deg[u] = len(adj[u])\n        # pick vertex with highest (sat, deg), tie-break random\n        best_sat = max(sat[u] for u in cand_vertices)\n        best_cands = [u for u in cand_vertices if sat[u] == best_sat]\n        best_cands.sort(key=lambda u: deg[u], reverse=True)\n        vertex = best_cands[0]\n        # Try recolor using existing palette only\n        chosen = smallest_feasible_color(vertex, new_s, adj, limit_color=max_col)\n        if chosen is None:\n            # As last resort, introduce a new color (bounded by n)\n            chosen = min(max_col + 1, n)\n        new_s[vertex-1] = chosen\n        new_s = normalize_colors(new_s)\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DSATUR\")\n    else:\n        # Feasible: try to compact by moving a max-color vertex to a lower color\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    new_s = normalize_colors(new_s)\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION\")\n        # Kempe-chain interchange on colors (max_col, b)\n        vertex = random.choice(max_vertices)\n        a = new_s[vertex-1]\n        if a == 1:\n            # pick any other color present if max_col==1 (degenerate), else keep\n            return (new_s, \"NOOP\", \"STABLE\")\n        b = random.randint(1, a-1)\n        # Build component in subgraph induced by colors {a,b}\n        stack = [vertex]\n        visited = set()\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if new_s[v-1] in (a, b) and v not in visited:\n                    stack.append(v)\n        # Swap colors a<->b in the component\n        for u in visited:\n            new_s[u-1] = b if new_s[u-1] == a else (a if new_s[u-1] == b else new_s[u-1])\n        new_s = normalize_colors(new_s)\n        return (new_s, \"KEMPE_SWAP\", \"FEASIBLE_DIVERSIFY\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution list (pure, side-effect-free)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(arr):\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    # Defensive copy\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = normalize_colors(s)\n    max_col = max(new_s)\n\n    # Select vertices for perturbation: prioritize conflicts and high degree\n    confs = conflicts_list(new_s)\n    conf_vertices = set([u for u, _ in confs] + [v for _, v in confs])\n    degrees = {i: len(adj[i]) for i in range(1, n+1)}\n\n    pool = list(conf_vertices)\n    if len(pool) < 3:\n        # add some high-degree vertices from max color class\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        max_vertices.sort(key=lambda u: degrees[u], reverse=True)\n        pool.extend([u for u in max_vertices if u not in pool])\n    # choose up to k vertices\n    k = min(4, max(2, len(pool)))\n    random.shuffle(pool)\n    chosen = pool[:k]\n\n    # Recolor chosen vertices to smallest feasible color (bias to lower colors)\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # Try lower colors first\n        assigned = None\n        for c in range(1, max_col):\n            if c not in used:\n                assigned = c\n                break\n        if assigned is None:\n            # allow current max color; avoid introducing larger palette during perturb\n            for c in range(1, max_col+1):\n                if c not in used:\n                    assigned = c\n                    break\n        if assigned is None:\n            assigned = min(max_col, new_s[u-1])\n        new_s[u-1] = assigned\n\n    new_s = normalize_colors(new_s)\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000986607}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS: solution[i-1] is the color (1..k) of vertex i; objective minimize k=max(solution). Colors are normalized to 1..k in moves to reduce symmetry.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph (undirected)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**5\n    CONFLICT_WEIGHT = 100\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    # Entry validation (restrict labels to 1..n to bound space)\n    for x in solution:\n        if not isinstance(x, int) or x < 1 or x > n:\n            return PENALTY_BASE\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + CONFLICT_WEIGHT * conflicts\n    # Feasible: cost is number of colors used (minimize)\n    return max(solution) if solution else PENALTY_BASE\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(arr):\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    def normalize_colors(arr):\n        # Relabel colors to 1..k preserving relative order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def smallest_feasible_color(u, arr, adj, limit_color=None):\n        used = {arr[v-1] for v in adj[u]}\n        max_try = (limit_color if limit_color is not None else max(arr))\n        for c in range(1, max_try+1):\n            if c not in used:\n                return c\n        return None\n\n    # Defensive copy\/initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    new_s = normalize_colors(new_s)\n    max_col = max(new_s)\n    confs = conflicts_list(new_s)\n\n    if confs:\n        # Conflict-driven recoloring with DSATUR-like priority\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Saturation: number of distinct neighbor colors\n        sat = {}\n        deg = {}\n        for u in cand_vertices:\n            sat[u] = len({new_s[v-1] for v in adj[u]})\n            deg[u] = len(adj[u])\n        # pick vertex with highest (sat, deg), tie-break random\n        best_sat = max(sat[u] for u in cand_vertices)\n        best_cands = [u for u in cand_vertices if sat[u] == best_sat]\n        best_cands.sort(key=lambda u: deg[u], reverse=True)\n        vertex = best_cands[0]\n        # Try recolor using existing palette only\n        chosen = smallest_feasible_color(vertex, new_s, adj, limit_color=max_col)\n        if chosen is None:\n            # As last resort, introduce a new color (bounded by n)\n            chosen = min(max_col + 1, n)\n        new_s[vertex-1] = chosen\n        new_s = normalize_colors(new_s)\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DSATUR\")\n    else:\n        # Feasible: try to compact by moving a max-color vertex to a lower color\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    new_s = normalize_colors(new_s)\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION\")\n        # Kempe-chain interchange on colors (max_col, b)\n        vertex = random.choice(max_vertices)\n        a = new_s[vertex-1]\n        if a == 1:\n            # pick any other color present if max_col==1 (degenerate), else keep\n            return (new_s, \"NOOP\", \"STABLE\")\n        b = random.randint(1, a-1)\n        # Build component in subgraph induced by colors {a,b}\n        stack = [vertex]\n        visited = set()\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if new_s[v-1] in (a, b) and v not in visited:\n                    stack.append(v)\n        # Swap colors a<->b in the component\n        for u in visited:\n            new_s[u-1] = b if new_s[u-1] == a else (a if new_s[u-1] == b else new_s[u-1])\n        new_s = normalize_colors(new_s)\n        return (new_s, \"KEMPE_SWAP\", \"FEASIBLE_DIVERSIFY\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution list (pure, side-effect-free)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(arr):\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    # Defensive copy\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = normalize_colors(s)\n    max_col = max(new_s)\n\n    # Select vertices for perturbation: prioritize conflicts and high degree\n    confs = conflicts_list(new_s)\n    conf_vertices = set([u for u, _ in confs] + [v for _, v in confs])\n    degrees = {i: len(adj[i]) for i in range(1, n+1)}\n\n    pool = list(conf_vertices)\n    if len(pool) < 3:\n        # add some high-degree vertices from max color class\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        max_vertices.sort(key=lambda u: degrees[u], reverse=True)\n        pool.extend([u for u in max_vertices if u not in pool])\n    # choose up to k vertices\n    k = min(4, max(2, len(pool)))\n    random.shuffle(pool)\n    chosen = pool[:k]\n\n    # Recolor chosen vertices to smallest feasible color (bias to lower colors)\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # Try lower colors first\n        assigned = None\n        for c in range(1, max_col):\n            if c not in used:\n                assigned = c\n                break\n        if assigned is None:\n            # allow current max color; avoid introducing larger palette during perturb\n            for c in range(1, max_col+1):\n                if c not in used:\n                    assigned = c\n                    break\n        if assigned is None:\n            assigned = min(max_col, new_s[u-1])\n        new_s[u-1] = assigned\n\n    new_s = normalize_colors(new_s)\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001309222}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS: solution[i-1] is the color (1..k) of vertex i; objective minimize k=max(solution). Colors are normalized to 1..k in moves to reduce symmetry.","Evaluacion":"from typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph (undirected)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**5\n    CONFLICT_WEIGHT = 100\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    # Entry validation (restrict labels to 1..n to bound space)\n    for x in solution:\n        if not isinstance(x, int) or x < 1 or x > n:\n            return PENALTY_BASE\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + CONFLICT_WEIGHT * conflicts\n    # Feasible: cost is number of colors used (minimize)\n    return max(solution) if solution else PENALTY_BASE\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(arr):\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    def normalize_colors(arr):\n        # Relabel colors to 1..k preserving relative order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def smallest_feasible_color(u, arr, adj, limit_color=None):\n        used = {arr[v-1] for v in adj[u]}\n        max_try = (limit_color if limit_color is not None else max(arr))\n        for c in range(1, max_try+1):\n            if c not in used:\n                return c\n        return None\n\n    # Defensive copy\/initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = s[:]\n    new_s = normalize_colors(new_s)\n    max_col = max(new_s)\n    confs = conflicts_list(new_s)\n\n    if confs:\n        # Conflict-driven recoloring with DSATUR-like priority\n        cand_vertices = set()\n        for (u, v) in confs:\n            cand_vertices.add(u)\n            cand_vertices.add(v)\n        # Saturation: number of distinct neighbor colors\n        sat = {}\n        deg = {}\n        for u in cand_vertices:\n            sat[u] = len({new_s[v-1] for v in adj[u]})\n            deg[u] = len(adj[u])\n        # pick vertex with highest (sat, deg), tie-break random\n        best_sat = max(sat[u] for u in cand_vertices)\n        best_cands = [u for u in cand_vertices if sat[u] == best_sat]\n        best_cands.sort(key=lambda u: deg[u], reverse=True)\n        vertex = best_cands[0]\n        # Try recolor using existing palette only\n        chosen = smallest_feasible_color(vertex, new_s, adj, limit_color=max_col)\n        if chosen is None:\n            # As last resort, introduce a new color (bounded by n)\n            chosen = min(max_col + 1, n)\n        new_s[vertex-1] = chosen\n        new_s = normalize_colors(new_s)\n        return (new_s, \"RECOLOR_ONE_VERTEX\", \"CONFLICT_DSATUR\")\n    else:\n        # Feasible: try to compact by moving a max-color vertex to a lower color\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        random.shuffle(max_vertices)\n        for vertex in max_vertices:\n            used = {new_s[v-1] for v in adj[vertex]}\n            for c in range(1, max_col):\n                if c not in used:\n                    new_s[vertex-1] = c\n                    new_s = normalize_colors(new_s)\n                    return (new_s, \"RECOLOR_ONE_VERTEX\", \"COLOR_COMPACTION\")\n        # Kempe-chain interchange on colors (max_col, b)\n        vertex = random.choice(max_vertices)\n        a = new_s[vertex-1]\n        if a == 1:\n            # pick any other color present if max_col==1 (degenerate), else keep\n            return (new_s, \"NOOP\", \"STABLE\")\n        b = random.randint(1, a-1)\n        # Build component in subgraph induced by colors {a,b}\n        stack = [vertex]\n        visited = set()\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in adj[u]:\n                if new_s[v-1] in (a, b) and v not in visited:\n                    stack.append(v)\n        # Swap colors a<->b in the component\n        for u in visited:\n            new_s[u-1] = b if new_s[u-1] == a else (a if new_s[u-1] == b else new_s[u-1])\n        new_s = normalize_colors(new_s)\n        return (new_s, \"KEMPE_SWAP\", \"FEASIBLE_DIVERSIFY\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution list (pure, side-effect-free)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def make_adj():\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(arr):\n        conf = []\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u, v))\n        return conf\n\n    # Defensive copy\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        s = [random.randint(1, 3) for _ in range(n)]\n    else:\n        s = list(solution)\n\n    adj = make_adj()\n    new_s = normalize_colors(s)\n    max_col = max(new_s)\n\n    # Select vertices for perturbation: prioritize conflicts and high degree\n    confs = conflicts_list(new_s)\n    conf_vertices = set([u for u, _ in confs] + [v for _, v in confs])\n    degrees = {i: len(adj[i]) for i in range(1, n+1)}\n\n    pool = list(conf_vertices)\n    if len(pool) < 3:\n        # add some high-degree vertices from max color class\n        max_vertices = [i for i, c in enumerate(new_s, start=1) if c == max_col]\n        max_vertices.sort(key=lambda u: degrees[u], reverse=True)\n        pool.extend([u for u in max_vertices if u not in pool])\n    # choose up to k vertices\n    k = min(4, max(2, len(pool)))\n    random.shuffle(pool)\n    chosen = pool[:k]\n\n    # Recolor chosen vertices to smallest feasible color (bias to lower colors)\n    for u in chosen:\n        used = {new_s[v-1] for v in adj[u]}\n        # Try lower colors first\n        assigned = None\n        for c in range(1, max_col):\n            if c not in used:\n                assigned = c\n                break\n        if assigned is None:\n            # allow current max color; avoid introducing larger palette during perturb\n            for c in range(1, max_col+1):\n                if c not in used:\n                    assigned = c\n                    break\n        if assigned is None:\n            assigned = min(max_col, new_s[u-1])\n        new_s[u-1] = assigned\n\n    new_s = normalize_colors(new_s)\n    return new_s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001223341}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"from typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Fitness = objective + explicit constraint penalties; lower is better\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6  # safeguard to avoid zero objective on invalid input\n\n    # Build fitness: strong penalties dominate feasibility; then minimize colors\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\"\n    Movement_Type: \"Recolor-One-Vertex\"\n    \"\"\"\n    # Defensive copy and basic guards\n    if not isinstance(solution, list):\n        solution = list(solution)\n    n = len(solution)\n    if n == 0:\n        return solution, \"Local\", \"Recolor-One-Vertex\"\n\n    neighbor = solution[:]\n\n    # Determine current max color (fallback to 1)\n    current_colors = [c for c in neighbor if isinstance(c, int) and c >= 1]\n    k_used = max(current_colors) if current_colors else 1\n\n    # Pick a random vertex to recolor\n    idx = random.randrange(n)\n\n    # Choose a new color from 1..k_used+1, ensuring change\n    candidate_colors = list(range(1, k_used + 2))\n    current = neighbor[idx] if isinstance(neighbor[idx], int) and neighbor[idx] >= 1 else None\n    if current in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(current)\n    new_color = random.choice(candidate_colors) if candidate_colors else (k_used if k_used >= 1 else 1)\n\n    neighbor[idx] = int(new_color)\n\n    return neighbor, \"Local\", \"Recolor-One-Vertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger move: multiple random recolors plus color compaction.\n    Returns a new perturbed solution (list of ints >= 1 when possible).\n    \"\"\"\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = max(valid_colors) if valid_colors else 1\n\n    # Number of perturbation edits\n    edits = max(2, n \/\/ 3)\n\n    for _ in range(edits):\n        i = random.randrange(n)\n        # Allow exploration to k_used+2\n        new_c = random.randint(1, max(2, k_used + 2))\n        work[i] = int(new_c)\n\n    # Color compaction: remap colors to consecutive 1..m preserving relative order of first appearance\n    seen = {}\n    next_c = 1\n    for i in range(n):\n        c = work[i]\n        if not (isinstance(c, int) and c >= 1):\n            c = 1\n        if c not in seen:\n            seen[c] = next_c\n            next_c += 1\n        work[i] = seen[c]\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000758573}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"from typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Fitness = objective + explicit constraint penalties; lower is better\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6  # safeguard to avoid zero objective on invalid input\n\n    # Build fitness: strong penalties dominate feasibility; then minimize colors\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\"\n    Movement_Type: \"Recolor-One-Vertex\"\n    \"\"\"\n    # Defensive copy and basic guards\n    if not isinstance(solution, list):\n        solution = list(solution)\n    n = len(solution)\n    if n == 0:\n        return solution, \"Local\", \"Recolor-One-Vertex\"\n\n    neighbor = solution[:]\n\n    # Determine current max color (fallback to 1)\n    current_colors = [c for c in neighbor if isinstance(c, int) and c >= 1]\n    k_used = max(current_colors) if current_colors else 1\n\n    # Pick a random vertex to recolor\n    idx = random.randrange(n)\n\n    # Choose a new color from 1..k_used+1, ensuring change\n    candidate_colors = list(range(1, k_used + 2))\n    current = neighbor[idx] if isinstance(neighbor[idx], int) and neighbor[idx] >= 1 else None\n    if current in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(current)\n    new_color = random.choice(candidate_colors) if candidate_colors else (k_used if k_used >= 1 else 1)\n\n    neighbor[idx] = int(new_color)\n\n    return neighbor, \"Local\", \"Recolor-One-Vertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger move: multiple random recolors plus color compaction.\n    Returns a new perturbed solution (list of ints >= 1 when possible).\n    \"\"\"\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = max(valid_colors) if valid_colors else 1\n\n    # Number of perturbation edits\n    edits = max(2, n \/\/ 3)\n\n    for _ in range(edits):\n        i = random.randrange(n)\n        # Allow exploration to k_used+2\n        new_c = random.randint(1, max(2, k_used + 2))\n        work[i] = int(new_c)\n\n    # Color compaction: remap colors to consecutive 1..m preserving relative order of first appearance\n    seen = {}\n    next_c = 1\n    for i in range(n):\n        c = work[i]\n        if not (isinstance(c, int) and c >= 1):\n            c = 1\n        if c not in seen:\n            seen[c] = next_c\n            next_c += 1\n        work[i] = seen[c]\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000788713}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"from typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Fitness = objective + explicit constraint penalties; lower is better\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6  # safeguard to avoid zero objective on invalid input\n\n    # Build fitness: strong penalties dominate feasibility; then minimize colors\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\"\n    Movement_Type: \"Recolor-One-Vertex\"\n    \"\"\"\n    # Defensive copy and basic guards\n    if not isinstance(solution, list):\n        solution = list(solution)\n    n = len(solution)\n    if n == 0:\n        return solution, \"Local\", \"Recolor-One-Vertex\"\n\n    neighbor = solution[:]\n\n    # Determine current max color (fallback to 1)\n    current_colors = [c for c in neighbor if isinstance(c, int) and c >= 1]\n    k_used = max(current_colors) if current_colors else 1\n\n    # Pick a random vertex to recolor\n    idx = random.randrange(n)\n\n    # Choose a new color from 1..k_used+1, ensuring change\n    candidate_colors = list(range(1, k_used + 2))\n    current = neighbor[idx] if isinstance(neighbor[idx], int) and neighbor[idx] >= 1 else None\n    if current in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(current)\n    new_color = random.choice(candidate_colors) if candidate_colors else (k_used if k_used >= 1 else 1)\n\n    neighbor[idx] = int(new_color)\n\n    return neighbor, \"Local\", \"Recolor-One-Vertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger move: multiple random recolors plus color compaction.\n    Returns a new perturbed solution (list of ints >= 1 when possible).\n    \"\"\"\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = max(valid_colors) if valid_colors else 1\n\n    # Number of perturbation edits\n    edits = max(2, n \/\/ 3)\n\n    for _ in range(edits):\n        i = random.randrange(n)\n        # Allow exploration to k_used+2\n        new_c = random.randint(1, max(2, k_used + 2))\n        work[i] = int(new_c)\n\n    # Color compaction: remap colors to consecutive 1..m preserving relative order of first appearance\n    seen = {}\n    next_c = 1\n    for i in range(n):\n        c = work[i]\n        if not (isinstance(c, int) and c >= 1):\n            c = 1\n        if c not in seen:\n            seen[c] = next_c\n            next_c += 1\n        work[i] = seen[c]\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000779393}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Feasibility enforced via heavy penalties.\n    - If feasible, objective equals number of colors used (k).\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks (mutually exclusive counting)\n    non_int = 0\n    non_pos_only = 0\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else 0\n\n    # Fitness assembly: heavy penalties dominate; if feasible, fitness = k_used\n    penalty = 0\n    penalty += non_int * 10**7\n    penalty += non_pos_only * 10**6\n    penalty += violations * 10**5\n\n    if penalty == 0:\n        return k_used if k_used > 0 else 10**6\n    else:\n        return penalty\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\". Movement types vary among a small set to improve exploration.\n    Movement types implemented:\n      - Recolor-Conflict-Vertex: Greedy recolor of a randomly chosen conflicting vertex.\n      - Swap-Colors: Swap two randomly chosen colors across all vertices.\n      - Kempe-Two-Color-Flip: Flip between two colors on vertices incident to conflicts.\n      - Vertex-Color-Swap: Swap colors of two random vertices.\n    \"\"\"\n    # Defensive copy\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            if isinstance(sol[u], int) and isinstance(sol[v], int) and sol[u] >= 1 and sol[v] >= 1 and sol[u] == sol[v]:\n                conf.add(u); conf.add(v)\n        return list(conf)\n\n    def current_k(sol: List[int]) -> int:\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        return max(valid) if valid else 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used = current_k(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Two-Color-Flip\"])  # bias to resolve conflicts\n    move_choices.extend([\"Swap-Colors\", \"Vertex-Color-Swap\", \"Recolor-Conflict-Vertex\"])  # general moves\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        # Pick a conflicting vertex if any, else random\n        if conflict_vertices:\n            i = random.choice(conflict_vertices)\n        else:\n            i = random.randrange(n)\n        # Try colors from 1..k_used+1, pick one that minimizes immediate conflicts\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        candidate_colors = list(range(1, k_used + 2))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            if c == work[i]:\n                continue\n            # Count conflicts if vertex i is colored c\n            conf = 0\n            for (u, v) in edges0:\n                if u == i:\n                    if isinstance(work[v], int) and work[v] >= 1 and work[v] == c:\n                        conf += 1\n                elif v == i:\n                    if isinstance(work[u], int) and work[u] >= 1 and work[u] == c:\n                        conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Swap-Colors\":\n        if k_used >= 2:\n            a, b = random.sample(range(1, k_used + 1), 2)\n            for i in range(n):\n                if work[i] == a:\n                    work[i] = b\n                elif work[i] == b:\n                    work[i] = a\n        return work, \"Local\", \"Swap-Colors\"\n\n    if move == \"Kempe-Two-Color-Flip\":\n        # Choose two colors involved in conflicts if possible; else any two colors\n        if conflict_vertices:\n            involved_colors = list({work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1})\n            if len(involved_colors) >= 2:\n                c1, c2 = random.sample(involved_colors, 2)\n            else:\n                c1 = involved_colors[0] if involved_colors else 1\n                c2 = random.randint(1, max(2, k_used))\n                if c2 == c1:\n                    c2 = (c2 % max(2, k_used)) + 1\n        else:\n            if k_used >= 2:\n                c1, c2 = random.sample(range(1, k_used + 1), 2)\n            else:\n                c1, c2 = 1, 2\n        # Flip colors c1 <-> c2 on vertices touching any conflict edge endpoints\n        touched = set(conflict_vertices)\n        if not touched:\n            # fallback: flip on all vertices\n            touched = set(range(n))\n        for i in touched:\n            if work[i] == c1:\n                work[i] = c2\n            elif work[i] == c2:\n                work[i] = c1\n        return work, \"Local\", \"Kempe-Two-Color-Flip\"\n\n    if move == \"Vertex-Color-Swap\":\n        i, j = random.sample(range(n), 2) if n >= 2 else (0, 0)\n        work[i], work[j] = int(work[j]) if isinstance(work[j], int) else 1, int(work[i]) if isinstance(work[i], int) else 1\n        return work, \"Local\", \"Vertex-Color-Swap\"\n\n    # Fallback: random recolor\n    i = random.randrange(n)\n    new_c = random.randint(1, max(2, k_used + 1))\n    work[i] = int(new_c)\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation combining multiple random recolors and color compaction.\n    Returns a new solution list of positive integers when possible.\n    \"\"\"\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Determine current color span\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = max(valid_colors) if valid_colors else 1\n\n    # Apply several random edits to escape local minima\n    edits = max(3, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(3, k_used + 2)))\n\n    # Color compaction: remap used colors to consecutive 1..m preserving first-appearance order\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        c = work[i]\n        if not (isinstance(c, int) and c >= 1):\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        work[i] = mapping[c]\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001316761}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Feasibility enforced via heavy penalties.\n    - If feasible, objective equals number of colors used (k).\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks (mutually exclusive counting)\n    non_int = 0\n    non_pos_only = 0\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else 0\n\n    # Fitness assembly: heavy penalties dominate; if feasible, fitness = k_used\n    penalty = 0\n    penalty += non_int * 10**7\n    penalty += non_pos_only * 10**6\n    penalty += violations * 10**5\n\n    if penalty == 0:\n        return k_used if k_used > 0 else 10**6\n    else:\n        return penalty\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\". Movement types vary among a small set to improve exploration.\n    Movement types implemented:\n      - Recolor-Conflict-Vertex: Greedy recolor of a randomly chosen conflicting vertex.\n      - Swap-Colors: Swap two randomly chosen colors across all vertices.\n      - Kempe-Two-Color-Flip: Flip between two colors on vertices incident to conflicts.\n      - Vertex-Color-Swap: Swap colors of two random vertices.\n    \"\"\"\n    # Defensive copy\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            if isinstance(sol[u], int) and isinstance(sol[v], int) and sol[u] >= 1 and sol[v] >= 1 and sol[u] == sol[v]:\n                conf.add(u); conf.add(v)\n        return list(conf)\n\n    def current_k(sol: List[int]) -> int:\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        return max(valid) if valid else 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used = current_k(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Two-Color-Flip\"])  # bias to resolve conflicts\n    move_choices.extend([\"Swap-Colors\", \"Vertex-Color-Swap\", \"Recolor-Conflict-Vertex\"])  # general moves\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        # Pick a conflicting vertex if any, else random\n        if conflict_vertices:\n            i = random.choice(conflict_vertices)\n        else:\n            i = random.randrange(n)\n        # Try colors from 1..k_used+1, pick one that minimizes immediate conflicts\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        candidate_colors = list(range(1, k_used + 2))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            if c == work[i]:\n                continue\n            # Count conflicts if vertex i is colored c\n            conf = 0\n            for (u, v) in edges0:\n                if u == i:\n                    if isinstance(work[v], int) and work[v] >= 1 and work[v] == c:\n                        conf += 1\n                elif v == i:\n                    if isinstance(work[u], int) and work[u] >= 1 and work[u] == c:\n                        conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Swap-Colors\":\n        if k_used >= 2:\n            a, b = random.sample(range(1, k_used + 1), 2)\n            for i in range(n):\n                if work[i] == a:\n                    work[i] = b\n                elif work[i] == b:\n                    work[i] = a\n        return work, \"Local\", \"Swap-Colors\"\n\n    if move == \"Kempe-Two-Color-Flip\":\n        # Choose two colors involved in conflicts if possible; else any two colors\n        if conflict_vertices:\n            involved_colors = list({work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1})\n            if len(involved_colors) >= 2:\n                c1, c2 = random.sample(involved_colors, 2)\n            else:\n                c1 = involved_colors[0] if involved_colors else 1\n                c2 = random.randint(1, max(2, k_used))\n                if c2 == c1:\n                    c2 = (c2 % max(2, k_used)) + 1\n        else:\n            if k_used >= 2:\n                c1, c2 = random.sample(range(1, k_used + 1), 2)\n            else:\n                c1, c2 = 1, 2\n        # Flip colors c1 <-> c2 on vertices touching any conflict edge endpoints\n        touched = set(conflict_vertices)\n        if not touched:\n            # fallback: flip on all vertices\n            touched = set(range(n))\n        for i in touched:\n            if work[i] == c1:\n                work[i] = c2\n            elif work[i] == c2:\n                work[i] = c1\n        return work, \"Local\", \"Kempe-Two-Color-Flip\"\n\n    if move == \"Vertex-Color-Swap\":\n        i, j = random.sample(range(n), 2) if n >= 2 else (0, 0)\n        work[i], work[j] = int(work[j]) if isinstance(work[j], int) else 1, int(work[i]) if isinstance(work[i], int) else 1\n        return work, \"Local\", \"Vertex-Color-Swap\"\n\n    # Fallback: random recolor\n    i = random.randrange(n)\n    new_c = random.randint(1, max(2, k_used + 1))\n    work[i] = int(new_c)\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation combining multiple random recolors and color compaction.\n    Returns a new solution list of positive integers when possible.\n    \"\"\"\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Determine current color span\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = max(valid_colors) if valid_colors else 1\n\n    # Apply several random edits to escape local minima\n    edits = max(3, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(3, k_used + 2)))\n\n    # Color compaction: remap used colors to consecutive 1..m preserving first-appearance order\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        c = work[i]\n        if not (isinstance(c, int) and c >= 1):\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        work[i] = mapping[c]\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001172169}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Feasibility enforced via heavy penalties.\n    - If feasible, objective equals number of colors used (k).\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks (mutually exclusive counting)\n    non_int = 0\n    non_pos_only = 0\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else 0\n\n    # Fitness assembly: heavy penalties dominate; if feasible, fitness = k_used\n    penalty = 0\n    penalty += non_int * 10**7\n    penalty += non_pos_only * 10**6\n    penalty += violations * 10**5\n\n    if penalty == 0:\n        return k_used if k_used > 0 else 10**6\n    else:\n        return penalty\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\". Movement types vary among a small set to improve exploration.\n    Movement types implemented:\n      - Recolor-Conflict-Vertex: Greedy recolor of a randomly chosen conflicting vertex.\n      - Swap-Colors: Swap two randomly chosen colors across all vertices.\n      - Kempe-Two-Color-Flip: Flip between two colors on vertices incident to conflicts.\n      - Vertex-Color-Swap: Swap colors of two random vertices.\n    \"\"\"\n    # Defensive copy\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            if isinstance(sol[u], int) and isinstance(sol[v], int) and sol[u] >= 1 and sol[v] >= 1 and sol[u] == sol[v]:\n                conf.add(u); conf.add(v)\n        return list(conf)\n\n    def current_k(sol: List[int]) -> int:\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        return max(valid) if valid else 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used = current_k(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Two-Color-Flip\"])  # bias to resolve conflicts\n    move_choices.extend([\"Swap-Colors\", \"Vertex-Color-Swap\", \"Recolor-Conflict-Vertex\"])  # general moves\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        # Pick a conflicting vertex if any, else random\n        if conflict_vertices:\n            i = random.choice(conflict_vertices)\n        else:\n            i = random.randrange(n)\n        # Try colors from 1..k_used+1, pick one that minimizes immediate conflicts\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        candidate_colors = list(range(1, k_used + 2))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            if c == work[i]:\n                continue\n            # Count conflicts if vertex i is colored c\n            conf = 0\n            for (u, v) in edges0:\n                if u == i:\n                    if isinstance(work[v], int) and work[v] >= 1 and work[v] == c:\n                        conf += 1\n                elif v == i:\n                    if isinstance(work[u], int) and work[u] >= 1 and work[u] == c:\n                        conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Swap-Colors\":\n        if k_used >= 2:\n            a, b = random.sample(range(1, k_used + 1), 2)\n            for i in range(n):\n                if work[i] == a:\n                    work[i] = b\n                elif work[i] == b:\n                    work[i] = a\n        return work, \"Local\", \"Swap-Colors\"\n\n    if move == \"Kempe-Two-Color-Flip\":\n        # Choose two colors involved in conflicts if possible; else any two colors\n        if conflict_vertices:\n            involved_colors = list({work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1})\n            if len(involved_colors) >= 2:\n                c1, c2 = random.sample(involved_colors, 2)\n            else:\n                c1 = involved_colors[0] if involved_colors else 1\n                c2 = random.randint(1, max(2, k_used))\n                if c2 == c1:\n                    c2 = (c2 % max(2, k_used)) + 1\n        else:\n            if k_used >= 2:\n                c1, c2 = random.sample(range(1, k_used + 1), 2)\n            else:\n                c1, c2 = 1, 2\n        # Flip colors c1 <-> c2 on vertices touching any conflict edge endpoints\n        touched = set(conflict_vertices)\n        if not touched:\n            # fallback: flip on all vertices\n            touched = set(range(n))\n        for i in touched:\n            if work[i] == c1:\n                work[i] = c2\n            elif work[i] == c2:\n                work[i] = c1\n        return work, \"Local\", \"Kempe-Two-Color-Flip\"\n\n    if move == \"Vertex-Color-Swap\":\n        i, j = random.sample(range(n), 2) if n >= 2 else (0, 0)\n        work[i], work[j] = int(work[j]) if isinstance(work[j], int) else 1, int(work[i]) if isinstance(work[i], int) else 1\n        return work, \"Local\", \"Vertex-Color-Swap\"\n\n    # Fallback: random recolor\n    i = random.randrange(n)\n    new_c = random.randint(1, max(2, k_used + 1))\n    work[i] = int(new_c)\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation combining multiple random recolors and color compaction.\n    Returns a new solution list of positive integers when possible.\n    \"\"\"\n    if not isinstance(solution, list):\n        work = list(solution)\n    else:\n        work = solution[:]\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Determine current color span\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = max(valid_colors) if valid_colors else 1\n\n    # Apply several random edits to escape local minima\n    edits = max(3, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(3, k_used + 2)))\n\n    # Color compaction: remap used colors to consecutive 1..m preserving first-appearance order\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        c = work[i]\n        if not (isinstance(c, int) and c >= 1):\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        work[i] = mapping[c]\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001066487}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Heavy penalties for infeasibility\/type errors.\n    - If feasible, objective equals 1e5 * number of colors used (k), for smoother acceptance vs penalties.\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks\n    non_int = 0\n    non_pos_only = 0\n    valid_colors = []\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n            else:\n                valid_colors.append(x)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1:\n            if cu == cv:\n                violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(valid_colors)) if valid_colors else 0\n\n    # Fitness assembly: heavy penalties dominate; if feasible, fitness = 1e5 * k_used\n    penalty = 0\n    penalty += non_int * 10**8\n    penalty += non_pos_only * 10**7\n    penalty += violations * 10**6\n\n    if penalty == 0:\n        return (k_used * 100000) if k_used > 0 else 10**6\n    else:\n        return penalty\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\". Movement types: Recolor-Conflict-Vertex, Swap-Colors, Kempe-Chain-Flip, Vertex-Color-Swap.\n    The function is self-contained and embeds problem data. Colors are normalized after global moves.\n    \"\"\"\n    # Defensive copy\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if not (isinstance(c, int) and c >= 1):\n                c = 1\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            cu = sol[u]\n            cv = sol[v]\n            if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1 and cu == cv:\n                conf.add(u)\n                conf.add(v)\n        return list(conf)\n\n    def distinct_k(sol: List[int]) -> int:\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        return len(set(valid)) if valid else 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used = distinct_k(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Chain-Flip\"])  # bias to resolve conflicts\n    move_choices.extend([\"Swap-Colors\", \"Vertex-Color-Swap\", \"Recolor-Conflict-Vertex\"])  # general moves\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        # Pick a conflicting vertex if any, else random\n        i = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        # Try colors from 1..k_used+1, pick one that minimizes conflicts around i\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        candidate_colors = list(range(1, max(2, k_used + 2)))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            if c == work[i]:\n                continue\n            conf = 0\n            for nb in adj[i]:\n                cv = work[nb]\n                if isinstance(cv, int) and cv >= 1 and cv == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Swap-Colors\":\n        if k_used >= 2:\n            used = sorted(list(set([c for c in work if isinstance(c, int) and c >= 1])))\n            a, b = random.sample(used, 2)\n            for i in range(n):\n                if work[i] == a:\n                    work[i] = b\n                elif work[i] == b:\n                    work[i] = a\n            normalize_colors(work)\n        return work, \"Local\", \"Swap-Colors\"\n\n    if move == \"Kempe-Chain-Flip\":\n        # Choose two colors; prefer involved in conflicts\n        if conflict_vertices:\n            involved = list({work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1})\n            if len(involved) >= 2:\n                c1, c2 = random.sample(involved, 2)\n            elif len(involved) == 1:\n                c1 = involved[0]\n                pool = list({c for c in work if isinstance(c, int) and c >= 1 and c != c1})\n                c2 = random.choice(pool) if pool else (c1 % 2) + 1\n            else:\n                c1, c2 = 1, 2\n        else:\n            used = list({c for c in work if isinstance(c, int) and c >= 1})\n            if len(used) >= 2:\n                c1, c2 = random.sample(used, 2)\n            else:\n                c1, c2 = 1, 2\n        # Pick a start vertex in {c1,c2}\n        candidates = [i for i in range(n) if work[i] in (c1, c2)]\n        if not candidates:\n            return work, \"Local\", \"Kempe-Chain-Flip\"\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors {c1,c2}\n        target_colors = {c1, c2}\n        visited = [False] * n\n        stack = [start]\n        comp = []\n        visited[start] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and work[v] in target_colors:\n                    visited[v] = True\n                    stack.append(v)\n        # Flip colors within the Kempe chain component\n        for u in comp:\n            if work[u] == c1:\n                work[u] = c2\n            elif work[u] == c2:\n                work[u] = c1\n        normalize_colors(work)\n        return work, \"Local\", \"Kempe-Chain-Flip\"\n\n    if move == \"Vertex-Color-Swap\":\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            ci = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n            cj = work[j] if isinstance(work[j], int) and work[j] >= 1 else 1\n            work[i], work[j] = int(cj), int(ci)\n        else:\n            i = 0\n        return work, \"Local\", \"Vertex-Color-Swap\"\n\n    # Fallback: random recolor\n    i = random.randrange(n)\n    new_c = random.randint(1, max(2, k_used + 1))\n    work[i] = int(new_c)\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multiple random recolors + optional Kempe flip + color normalization.\n    Returns a new solution list of positive integers when possible.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if not (isinstance(c, int) and c >= 1):\n                c = 1\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n\n    # Determine current color span\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = len(set(valid_colors)) if valid_colors else 1\n\n    # Apply several random edits to escape local minima\n    edits = max(3, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(3, k_used + 2)))\n\n    # Optional Kempe chain flip to diversify\n    used = list({c for c in work if isinstance(c, int) and c >= 1})\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        # Pick a start vertex in {c1,c2}\n        cand = [i for i in range(n) if work[i] in (c1, c2)]\n        if cand:\n            start = random.choice(cand)\n            visited = [False] * n\n            stack = [start]\n            visited[start] = True\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and work[v] in (c1, c2):\n                        visited[v] = True\n                        stack.append(v)\n            for u in comp:\n                work[u] = c2 if work[u] == c1 else (c1 if work[u] == c2 else work[u])\n\n    # Color compaction\n    normalize_colors(work)\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001453022}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Heavy penalties for infeasibility\/type errors.\n    - If feasible, objective equals 1e5 * number of colors used (k), for smoother acceptance vs penalties.\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks\n    non_int = 0\n    non_pos_only = 0\n    valid_colors = []\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n            else:\n                valid_colors.append(x)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1:\n            if cu == cv:\n                violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(valid_colors)) if valid_colors else 0\n\n    # Fitness assembly: heavy penalties dominate; if feasible, fitness = 1e5 * k_used\n    penalty = 0\n    penalty += non_int * 10**8\n    penalty += non_pos_only * 10**7\n    penalty += violations * 10**6\n\n    if penalty == 0:\n        return (k_used * 100000) if k_used > 0 else 10**6\n    else:\n        return penalty\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\". Movement types: Recolor-Conflict-Vertex, Swap-Colors, Kempe-Chain-Flip, Vertex-Color-Swap.\n    The function is self-contained and embeds problem data. Colors are normalized after global moves.\n    \"\"\"\n    # Defensive copy\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if not (isinstance(c, int) and c >= 1):\n                c = 1\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            cu = sol[u]\n            cv = sol[v]\n            if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1 and cu == cv:\n                conf.add(u)\n                conf.add(v)\n        return list(conf)\n\n    def distinct_k(sol: List[int]) -> int:\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        return len(set(valid)) if valid else 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used = distinct_k(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Chain-Flip\"])  # bias to resolve conflicts\n    move_choices.extend([\"Swap-Colors\", \"Vertex-Color-Swap\", \"Recolor-Conflict-Vertex\"])  # general moves\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        # Pick a conflicting vertex if any, else random\n        i = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        # Try colors from 1..k_used+1, pick one that minimizes conflicts around i\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        candidate_colors = list(range(1, max(2, k_used + 2)))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            if c == work[i]:\n                continue\n            conf = 0\n            for nb in adj[i]:\n                cv = work[nb]\n                if isinstance(cv, int) and cv >= 1 and cv == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Swap-Colors\":\n        if k_used >= 2:\n            used = sorted(list(set([c for c in work if isinstance(c, int) and c >= 1])))\n            a, b = random.sample(used, 2)\n            for i in range(n):\n                if work[i] == a:\n                    work[i] = b\n                elif work[i] == b:\n                    work[i] = a\n            normalize_colors(work)\n        return work, \"Local\", \"Swap-Colors\"\n\n    if move == \"Kempe-Chain-Flip\":\n        # Choose two colors; prefer involved in conflicts\n        if conflict_vertices:\n            involved = list({work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1})\n            if len(involved) >= 2:\n                c1, c2 = random.sample(involved, 2)\n            elif len(involved) == 1:\n                c1 = involved[0]\n                pool = list({c for c in work if isinstance(c, int) and c >= 1 and c != c1})\n                c2 = random.choice(pool) if pool else (c1 % 2) + 1\n            else:\n                c1, c2 = 1, 2\n        else:\n            used = list({c for c in work if isinstance(c, int) and c >= 1})\n            if len(used) >= 2:\n                c1, c2 = random.sample(used, 2)\n            else:\n                c1, c2 = 1, 2\n        # Pick a start vertex in {c1,c2}\n        candidates = [i for i in range(n) if work[i] in (c1, c2)]\n        if not candidates:\n            return work, \"Local\", \"Kempe-Chain-Flip\"\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors {c1,c2}\n        target_colors = {c1, c2}\n        visited = [False] * n\n        stack = [start]\n        comp = []\n        visited[start] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and work[v] in target_colors:\n                    visited[v] = True\n                    stack.append(v)\n        # Flip colors within the Kempe chain component\n        for u in comp:\n            if work[u] == c1:\n                work[u] = c2\n            elif work[u] == c2:\n                work[u] = c1\n        normalize_colors(work)\n        return work, \"Local\", \"Kempe-Chain-Flip\"\n\n    if move == \"Vertex-Color-Swap\":\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            ci = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n            cj = work[j] if isinstance(work[j], int) and work[j] >= 1 else 1\n            work[i], work[j] = int(cj), int(ci)\n        else:\n            i = 0\n        return work, \"Local\", \"Vertex-Color-Swap\"\n\n    # Fallback: random recolor\n    i = random.randrange(n)\n    new_c = random.randint(1, max(2, k_used + 1))\n    work[i] = int(new_c)\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multiple random recolors + optional Kempe flip + color normalization.\n    Returns a new solution list of positive integers when possible.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if not (isinstance(c, int) and c >= 1):\n                c = 1\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n\n    # Determine current color span\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = len(set(valid_colors)) if valid_colors else 1\n\n    # Apply several random edits to escape local minima\n    edits = max(3, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(3, k_used + 2)))\n\n    # Optional Kempe chain flip to diversify\n    used = list({c for c in work if isinstance(c, int) and c >= 1})\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        # Pick a start vertex in {c1,c2}\n        cand = [i for i in range(n) if work[i] in (c1, c2)]\n        if cand:\n            start = random.choice(cand)\n            visited = [False] * n\n            stack = [start]\n            visited[start] = True\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and work[v] in (c1, c2):\n                        visited[v] = True\n                        stack.append(v)\n            for u in comp:\n                work[u] = c2 if work[u] == c1 else (c1 if work[u] == c2 else work[u])\n\n    # Color compaction\n    normalize_colors(work)\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001688586}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Heavy penalties for infeasibility\/type errors.\n    - If feasible, objective equals 1e5 * number of colors used (k), for smoother acceptance vs penalties.\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks\n    non_int = 0\n    non_pos_only = 0\n    valid_colors = []\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n            else:\n                valid_colors.append(x)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1:\n            if cu == cv:\n                violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(valid_colors)) if valid_colors else 0\n\n    # Fitness assembly: heavy penalties dominate; if feasible, fitness = 1e5 * k_used\n    penalty = 0\n    penalty += non_int * 10**8\n    penalty += non_pos_only * 10**7\n    penalty += violations * 10**6\n\n    if penalty == 0:\n        return (k_used * 100000) if k_used > 0 else 10**6\n    else:\n        return penalty\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Local\". Movement types: Recolor-Conflict-Vertex, Swap-Colors, Kempe-Chain-Flip, Vertex-Color-Swap.\n    The function is self-contained and embeds problem data. Colors are normalized after global moves.\n    \"\"\"\n    # Defensive copy\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if not (isinstance(c, int) and c >= 1):\n                c = 1\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            cu = sol[u]\n            cv = sol[v]\n            if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1 and cu == cv:\n                conf.add(u)\n                conf.add(v)\n        return list(conf)\n\n    def distinct_k(sol: List[int]) -> int:\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        return len(set(valid)) if valid else 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used = distinct_k(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Chain-Flip\"])  # bias to resolve conflicts\n    move_choices.extend([\"Swap-Colors\", \"Vertex-Color-Swap\", \"Recolor-Conflict-Vertex\"])  # general moves\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        # Pick a conflicting vertex if any, else random\n        i = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        # Try colors from 1..k_used+1, pick one that minimizes conflicts around i\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        candidate_colors = list(range(1, max(2, k_used + 2)))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            if c == work[i]:\n                continue\n            conf = 0\n            for nb in adj[i]:\n                cv = work[nb]\n                if isinstance(cv, int) and cv >= 1 and cv == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Swap-Colors\":\n        if k_used >= 2:\n            used = sorted(list(set([c for c in work if isinstance(c, int) and c >= 1])))\n            a, b = random.sample(used, 2)\n            for i in range(n):\n                if work[i] == a:\n                    work[i] = b\n                elif work[i] == b:\n                    work[i] = a\n            normalize_colors(work)\n        return work, \"Local\", \"Swap-Colors\"\n\n    if move == \"Kempe-Chain-Flip\":\n        # Choose two colors; prefer involved in conflicts\n        if conflict_vertices:\n            involved = list({work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1})\n            if len(involved) >= 2:\n                c1, c2 = random.sample(involved, 2)\n            elif len(involved) == 1:\n                c1 = involved[0]\n                pool = list({c for c in work if isinstance(c, int) and c >= 1 and c != c1})\n                c2 = random.choice(pool) if pool else (c1 % 2) + 1\n            else:\n                c1, c2 = 1, 2\n        else:\n            used = list({c for c in work if isinstance(c, int) and c >= 1})\n            if len(used) >= 2:\n                c1, c2 = random.sample(used, 2)\n            else:\n                c1, c2 = 1, 2\n        # Pick a start vertex in {c1,c2}\n        candidates = [i for i in range(n) if work[i] in (c1, c2)]\n        if not candidates:\n            return work, \"Local\", \"Kempe-Chain-Flip\"\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors {c1,c2}\n        target_colors = {c1, c2}\n        visited = [False] * n\n        stack = [start]\n        comp = []\n        visited[start] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and work[v] in target_colors:\n                    visited[v] = True\n                    stack.append(v)\n        # Flip colors within the Kempe chain component\n        for u in comp:\n            if work[u] == c1:\n                work[u] = c2\n            elif work[u] == c2:\n                work[u] = c1\n        normalize_colors(work)\n        return work, \"Local\", \"Kempe-Chain-Flip\"\n\n    if move == \"Vertex-Color-Swap\":\n        if n >= 2:\n            i, j = random.sample(range(n), 2)\n            ci = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n            cj = work[j] if isinstance(work[j], int) and work[j] >= 1 else 1\n            work[i], work[j] = int(cj), int(ci)\n        else:\n            i = 0\n        return work, \"Local\", \"Vertex-Color-Swap\"\n\n    # Fallback: random recolor\n    i = random.randrange(n)\n    new_c = random.randint(1, max(2, k_used + 1))\n    work[i] = int(new_c)\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multiple random recolors + optional Kempe flip + color normalization.\n    Returns a new solution list of positive integers when possible.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Problem data (embedded)\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        mapping = {}\n        next_c = 1\n        for i in range(len(sol)):\n            c = sol[i]\n            if not (isinstance(c, int) and c >= 1):\n                c = 1\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            sol[i] = mapping[c]\n\n    # Determine current color span\n    valid_colors = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = len(set(valid_colors)) if valid_colors else 1\n\n    # Apply several random edits to escape local minima\n    edits = max(3, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(3, k_used + 2)))\n\n    # Optional Kempe chain flip to diversify\n    used = list({c for c in work if isinstance(c, int) and c >= 1})\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        # Pick a start vertex in {c1,c2}\n        cand = [i for i in range(n) if work[i] in (c1, c2)]\n        if cand:\n            start = random.choice(cand)\n            visited = [False] * n\n            stack = [start]\n            visited[start] = True\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and work[v] in (c1, c2):\n                        visited[v] = True\n                        stack.append(v)\n            for u in comp:\n                work[u] = c2 if work[u] == c1 else (c1 if work[u] == c2 else work[u])\n\n    # Color compaction\n    normalize_colors(work)\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001695926}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Penalize structural\/type errors.\n    - Penalize edge conflicts with moderate weight to allow exploratory infeasible steps.\n    - Primary objective: minimize number of colors k_used.\n    - Tie-breaker within same k: favor balanced color classes via sum(size^2) scaled small.\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    Returns an integer fitness.\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and collect valid colors\n    non_int = 0\n    non_pos_only = 0\n    valid_colors = []\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n            else:\n                valid_colors.append(x)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1:\n            if cu == cv:\n                violations += 1\n\n    # Colors used and class sizes\n    if valid_colors:\n        k_used = len(set(valid_colors))\n        k_max = max(valid_colors)\n    else:\n        k_used = 0\n        k_max = 0\n\n    # Color class balance tie-breaker: sum of squares of class sizes (smaller is better)\n    class_sizes = {}\n    for c in valid_colors:\n        class_sizes[c] = class_sizes.get(c, 0) + 1\n    sum_sq = sum(sz * sz for sz in class_sizes.values()) if class_sizes else 0\n\n    # Penalties and objective assembly\n    penalty = 0\n    penalty += non_int * 5 * 10**7\n    penalty += non_pos_only * 10**7\n    # Moderate conflict penalty to permit exploratory steps\n    penalty += violations * 200000  # 2 * 1e5 per conflict\n\n    # Primary objective component (k_used), scaled\n    obj_k = k_used * 100000\n\n    # Tie within same k: compact palette and balanced classes; ensure < 1e5\n    tie = (max(0, k_max - k_used) * 1000) + min(90000, sum_sq * 1000)\n\n    # If no valid colors at all, force a large value but finite\n    if k_used == 0:\n        obj_k = 5 * 100000\n\n    return int(penalty + obj_k + tie)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Local neighbor generator for graph coloring on V={1..9}.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {\"Local\"}; Movement_Type in {\"Recolor-Conflict-Vertex\",\"Kempe-Chain-Flip\",\"Drop-Color-Attempt\",\"Conflict-Driven-Vertex-Swap\"}\n    Design choices:\n    - Disables pure color relabeling (Swap-Colors) as it doesn't change objective.\n    - Recolor-Conflict-Vertex only allows k+1 when conflicts exist; otherwise confines to 1..k.\n    - Drop-Color-Attempt tries to reduce k by recoloring the smallest color class without introducing new colors.\n    - Kempe-Chain-Flip biased to start from conflicting vertices when present.\n    - Normalization is applied only when a color is eliminated.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Embedded problem data\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            cu = sol[u]\n            cv = sol[v]\n            if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1 and cu == cv:\n                conf.add(u)\n                conf.add(v)\n        return list(conf)\n\n    def k_used_and_classes(sol: List[int]):\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        classes = {}\n        for i, c in enumerate(sol):\n            if isinstance(c, int) and c >= 1:\n                classes.setdefault(c, []).append(i)\n        return (len(set(valid)) if valid else 1), classes\n\n    def normalize_if_eliminated(sol: List[int]):\n        # Compact colors to 1..k if there are gaps; used after successful drop\n        used = sorted(list({c for c in sol if isinstance(c, int) and c >= 1}))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        for i in range(len(sol)):\n            c = sol[i]\n            if isinstance(c, int) and c >= 1:\n                sol[i] = mapping[c]\n            else:\n                sol[i] = 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used, classes = k_used_and_classes(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Chain-Flip\", \"Conflict-Driven-Vertex-Swap\"])  # conflict-focused\n    move_choices.append(\"Drop-Color-Attempt\")  # occasional k reduction attempt\n    if not move_choices:\n        move_choices = [\"Recolor-Conflict-Vertex\"]\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        i = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        # Candidate colors: if conflicts exist, allow k+1; else restrict to 1..k\n        max_c = k_used + 1 if conflict_vertices else max(1, k_used)\n        candidates = list(range(1, max_c + 1))\n        random.shuffle(candidates)\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        for c in candidates:\n            if c == work[i]:\n                continue\n            conf = 0\n            for nb in adj[i]:\n                cv = work[nb]\n                if isinstance(cv, int) and cv >= 1 and cv == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Kempe-Chain-Flip\":\n        # Choose two colors; bias to those involved in conflicts\n        involved = [work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1]\n        used_colors = list({c for c in work if isinstance(c, int) and c >= 1})\n        if len(set(involved)) >= 2:\n            c1, c2 = random.sample(list(set(involved)), 2)\n        elif len(used_colors) >= 2:\n            c1, c2 = random.sample(used_colors, 2)\n        else:\n            c1, c2 = 1, 2\n        # Start vertex: prefer conflicting vertices with color in {c1,c2}\n        cand = [i for i in (conflict_vertices if conflict_vertices else range(n)) if work[i] in (c1, c2)]\n        if not cand:\n            return work, \"Local\", \"Kempe-Chain-Flip\"\n        start = random.choice(cand)\n        # DFS on subgraph induced by colors {c1,c2}\n        target = {c1, c2}\n        visited = [False] * n\n        stack = [start]\n        comp = []\n        visited[start] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and work[v] in target:\n                    visited[v] = True\n                    stack.append(v)\n        # Flip\n        for u in comp:\n            if work[u] == c1:\n                work[u] = c2\n            elif work[u] == c2:\n                work[u] = c1\n        return work, \"Local\", \"Kempe-Chain-Flip\"\n\n    if move == \"Drop-Color-Attempt\":\n        # Pick smallest color class; attempt to recolor its vertices using existing colors excluding that color\n        if classes:\n            smallest_color = min(classes.keys(), key=lambda c: len(classes[c]))\n            verts = classes[smallest_color][:]\n            other_colors = [c for c in classes.keys() if c != smallest_color]\n            success = True\n            for v in verts:\n                # Try greedy recolor to a color not used by neighbors\n                random.shuffle(other_colors)\n                placed = False\n                for c in other_colors:\n                    ok = True\n                    for nb in adj[v]:\n                        cv = work[nb]\n                        if isinstance(cv, int) and cv >= 1 and cv == c:\n                            ok = False\n                            break\n                    if ok:\n                        work[v] = c\n                        placed = True\n                        break\n                if not placed:\n                    success = False\n                    break\n            if success:\n                # Eliminate the color and normalize\n                normalize_if_eliminated(work)\n                return work, \"Local\", \"Drop-Color-Attempt\"\n        # Fallback to a conflict-driven recolor if drop not possible\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(2, k_used)))\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Conflict-Driven-Vertex-Swap\":\n        # Swap colors between a conflicting vertex and a random neighbor, if it may reduce local conflicts\n        if conflict_vertices:\n            i = random.choice(conflict_vertices)\n            nb_list = adj[i]\n            if nb_list:\n                j = random.choice(nb_list)\n                ci = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n                cj = work[j] if isinstance(work[j], int) and work[j] >= 1 else 1\n                if ci != cj:\n                    # Evaluate local conflicts before and after\n                    def local_conf(u, color):\n                        cnt = 0\n                        for t in adj[u]:\n                            cv = work[t]\n                            if isinstance(cv, int) and cv >= 1 and cv == color and t != u:\n                                cnt += 1\n                        return cnt\n                    before = local_conf(i, ci) + local_conf(j, cj)\n                    after = local_conf(i, cj) + local_conf(j, ci)\n                    if after <= before:\n                        work[i], work[j] = cj, ci\n        return work, \"Local\", \"Conflict-Driven-Vertex-Swap\"\n\n    # Fallback: random recolor within current palette\n    i = random.randrange(n)\n    work[i] = int(random.randint(1, max(1, k_used)))\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation for graph coloring:\n    - Multiple random recolors (allowing introduction of a new color with small probability).\n    - One Kempe-chain flip on random color pair.\n    - Final normalization to compact color labels.\n    Returns a new solution list of positive integers.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Embedded problem data\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        used = sorted(list({c for c in sol if isinstance(c, int) and c >= 1}))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        for i in range(len(sol)):\n            c = sol[i]\n            if isinstance(c, int) and c >= 1:\n                sol[i] = mapping[c]\n            else:\n                sol[i] = 1\n\n    valid = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = len(set(valid)) if valid else 1\n\n    # Random recolors\n    edits = max(4, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        # With small probability, allow adding a new color to escape local minima\n        allow_new = (random.random() < 0.25)\n        max_c = k_used + 1 if allow_new else max(1, k_used)\n        work[i] = int(random.randint(1, max(2, max_c)))\n\n    # Kempe-chain flip\n    used = list({c for c in work if isinstance(c, int) and c >= 1})\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        cand = [i for i in range(n) if work[i] in (c1, c2)]\n        if cand:\n            start = random.choice(cand)\n            visited = [False] * n\n            stack = [start]\n            comp = []\n            visited[start] = True\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and work[v] in (c1, c2):\n                        visited[v] = True\n                        stack.append(v)\n            for u in comp:\n                work[u] = c2 if work[u] == c1 else (c1 if work[u] == c2 else work[u])\n\n    # Normalize labels\n    normalize_colors(work)\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001602003}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Penalize structural\/type errors.\n    - Penalize edge conflicts with moderate weight to allow exploratory infeasible steps.\n    - Primary objective: minimize number of colors k_used.\n    - Tie-breaker within same k: favor balanced color classes via sum(size^2) scaled small.\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    Returns an integer fitness.\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and collect valid colors\n    non_int = 0\n    non_pos_only = 0\n    valid_colors = []\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n            else:\n                valid_colors.append(x)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1:\n            if cu == cv:\n                violations += 1\n\n    # Colors used and class sizes\n    if valid_colors:\n        k_used = len(set(valid_colors))\n        k_max = max(valid_colors)\n    else:\n        k_used = 0\n        k_max = 0\n\n    # Color class balance tie-breaker: sum of squares of class sizes (smaller is better)\n    class_sizes = {}\n    for c in valid_colors:\n        class_sizes[c] = class_sizes.get(c, 0) + 1\n    sum_sq = sum(sz * sz for sz in class_sizes.values()) if class_sizes else 0\n\n    # Penalties and objective assembly\n    penalty = 0\n    penalty += non_int * 5 * 10**7\n    penalty += non_pos_only * 10**7\n    # Moderate conflict penalty to permit exploratory steps\n    penalty += violations * 200000  # 2 * 1e5 per conflict\n\n    # Primary objective component (k_used), scaled\n    obj_k = k_used * 100000\n\n    # Tie within same k: compact palette and balanced classes; ensure < 1e5\n    tie = (max(0, k_max - k_used) * 1000) + min(90000, sum_sq * 1000)\n\n    # If no valid colors at all, force a large value but finite\n    if k_used == 0:\n        obj_k = 5 * 100000\n\n    return int(penalty + obj_k + tie)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Local neighbor generator for graph coloring on V={1..9}.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {\"Local\"}; Movement_Type in {\"Recolor-Conflict-Vertex\",\"Kempe-Chain-Flip\",\"Drop-Color-Attempt\",\"Conflict-Driven-Vertex-Swap\"}\n    Design choices:\n    - Disables pure color relabeling (Swap-Colors) as it doesn't change objective.\n    - Recolor-Conflict-Vertex only allows k+1 when conflicts exist; otherwise confines to 1..k.\n    - Drop-Color-Attempt tries to reduce k by recoloring the smallest color class without introducing new colors.\n    - Kempe-Chain-Flip biased to start from conflicting vertices when present.\n    - Normalization is applied only when a color is eliminated.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Embedded problem data\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            cu = sol[u]\n            cv = sol[v]\n            if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1 and cu == cv:\n                conf.add(u)\n                conf.add(v)\n        return list(conf)\n\n    def k_used_and_classes(sol: List[int]):\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        classes = {}\n        for i, c in enumerate(sol):\n            if isinstance(c, int) and c >= 1:\n                classes.setdefault(c, []).append(i)\n        return (len(set(valid)) if valid else 1), classes\n\n    def normalize_if_eliminated(sol: List[int]):\n        # Compact colors to 1..k if there are gaps; used after successful drop\n        used = sorted(list({c for c in sol if isinstance(c, int) and c >= 1}))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        for i in range(len(sol)):\n            c = sol[i]\n            if isinstance(c, int) and c >= 1:\n                sol[i] = mapping[c]\n            else:\n                sol[i] = 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used, classes = k_used_and_classes(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Chain-Flip\", \"Conflict-Driven-Vertex-Swap\"])  # conflict-focused\n    move_choices.append(\"Drop-Color-Attempt\")  # occasional k reduction attempt\n    if not move_choices:\n        move_choices = [\"Recolor-Conflict-Vertex\"]\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        i = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        # Candidate colors: if conflicts exist, allow k+1; else restrict to 1..k\n        max_c = k_used + 1 if conflict_vertices else max(1, k_used)\n        candidates = list(range(1, max_c + 1))\n        random.shuffle(candidates)\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        for c in candidates:\n            if c == work[i]:\n                continue\n            conf = 0\n            for nb in adj[i]:\n                cv = work[nb]\n                if isinstance(cv, int) and cv >= 1 and cv == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Kempe-Chain-Flip\":\n        # Choose two colors; bias to those involved in conflicts\n        involved = [work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1]\n        used_colors = list({c for c in work if isinstance(c, int) and c >= 1})\n        if len(set(involved)) >= 2:\n            c1, c2 = random.sample(list(set(involved)), 2)\n        elif len(used_colors) >= 2:\n            c1, c2 = random.sample(used_colors, 2)\n        else:\n            c1, c2 = 1, 2\n        # Start vertex: prefer conflicting vertices with color in {c1,c2}\n        cand = [i for i in (conflict_vertices if conflict_vertices else range(n)) if work[i] in (c1, c2)]\n        if not cand:\n            return work, \"Local\", \"Kempe-Chain-Flip\"\n        start = random.choice(cand)\n        # DFS on subgraph induced by colors {c1,c2}\n        target = {c1, c2}\n        visited = [False] * n\n        stack = [start]\n        comp = []\n        visited[start] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and work[v] in target:\n                    visited[v] = True\n                    stack.append(v)\n        # Flip\n        for u in comp:\n            if work[u] == c1:\n                work[u] = c2\n            elif work[u] == c2:\n                work[u] = c1\n        return work, \"Local\", \"Kempe-Chain-Flip\"\n\n    if move == \"Drop-Color-Attempt\":\n        # Pick smallest color class; attempt to recolor its vertices using existing colors excluding that color\n        if classes:\n            smallest_color = min(classes.keys(), key=lambda c: len(classes[c]))\n            verts = classes[smallest_color][:]\n            other_colors = [c for c in classes.keys() if c != smallest_color]\n            success = True\n            for v in verts:\n                # Try greedy recolor to a color not used by neighbors\n                random.shuffle(other_colors)\n                placed = False\n                for c in other_colors:\n                    ok = True\n                    for nb in adj[v]:\n                        cv = work[nb]\n                        if isinstance(cv, int) and cv >= 1 and cv == c:\n                            ok = False\n                            break\n                    if ok:\n                        work[v] = c\n                        placed = True\n                        break\n                if not placed:\n                    success = False\n                    break\n            if success:\n                # Eliminate the color and normalize\n                normalize_if_eliminated(work)\n                return work, \"Local\", \"Drop-Color-Attempt\"\n        # Fallback to a conflict-driven recolor if drop not possible\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(2, k_used)))\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Conflict-Driven-Vertex-Swap\":\n        # Swap colors between a conflicting vertex and a random neighbor, if it may reduce local conflicts\n        if conflict_vertices:\n            i = random.choice(conflict_vertices)\n            nb_list = adj[i]\n            if nb_list:\n                j = random.choice(nb_list)\n                ci = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n                cj = work[j] if isinstance(work[j], int) and work[j] >= 1 else 1\n                if ci != cj:\n                    # Evaluate local conflicts before and after\n                    def local_conf(u, color):\n                        cnt = 0\n                        for t in adj[u]:\n                            cv = work[t]\n                            if isinstance(cv, int) and cv >= 1 and cv == color and t != u:\n                                cnt += 1\n                        return cnt\n                    before = local_conf(i, ci) + local_conf(j, cj)\n                    after = local_conf(i, cj) + local_conf(j, ci)\n                    if after <= before:\n                        work[i], work[j] = cj, ci\n        return work, \"Local\", \"Conflict-Driven-Vertex-Swap\"\n\n    # Fallback: random recolor within current palette\n    i = random.randrange(n)\n    work[i] = int(random.randint(1, max(1, k_used)))\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation for graph coloring:\n    - Multiple random recolors (allowing introduction of a new color with small probability).\n    - One Kempe-chain flip on random color pair.\n    - Final normalization to compact color labels.\n    Returns a new solution list of positive integers.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Embedded problem data\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        used = sorted(list({c for c in sol if isinstance(c, int) and c >= 1}))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        for i in range(len(sol)):\n            c = sol[i]\n            if isinstance(c, int) and c >= 1:\n                sol[i] = mapping[c]\n            else:\n                sol[i] = 1\n\n    valid = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = len(set(valid)) if valid else 1\n\n    # Random recolors\n    edits = max(4, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        # With small probability, allow adding a new color to escape local minima\n        allow_new = (random.random() < 0.25)\n        max_c = k_used + 1 if allow_new else max(1, k_used)\n        work[i] = int(random.randint(1, max(2, max_c)))\n\n    # Kempe-chain flip\n    used = list({c for c in work if isinstance(c, int) and c >= 1})\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        cand = [i for i in range(n) if work[i] in (c1, c2)]\n        if cand:\n            start = random.choice(cand)\n            visited = [False] * n\n            stack = [start]\n            comp = []\n            visited[start] = True\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and work[v] in (c1, c2):\n                        visited[v] = True\n                        stack.append(v)\n            for u in comp:\n                work[u] = c2 if work[u] == c1 else (c1 if work[u] == c2 else work[u])\n\n    # Normalize labels\n    normalize_colors(work)\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001915318}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_9","Evaluacion":"import random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    \"\"\"\n    Fitness: lower is better.\n    - Penalize structural\/type errors.\n    - Penalize edge conflicts with moderate weight to allow exploratory infeasible steps.\n    - Primary objective: minimize number of colors k_used.\n    - Tie-breaker within same k: favor balanced color classes via sum(size^2) scaled small.\n    Graph: V={1..9}\n    E={(1,4),(1,5),(1,6),(1,8),(1,9),(2,5),(2,6),(2,7),(2,8),(2,9),(3,4),(3,6),(3,7),(4,5),(4,7),(4,8),(4,9),(5,6),(5,9),(6,9),(7,8)}\n    Returns an integer fitness.\n    \"\"\"\n    n = 9\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and collect valid colors\n    non_int = 0\n    non_pos_only = 0\n    valid_colors = []\n    for x in solution:\n        if not isinstance(x, int):\n            non_int += 1\n        else:\n            if x < 1:\n                non_pos_only += 1\n            else:\n                valid_colors.append(x)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1:\n            if cu == cv:\n                violations += 1\n\n    # Colors used and class sizes\n    if valid_colors:\n        k_used = len(set(valid_colors))\n        k_max = max(valid_colors)\n    else:\n        k_used = 0\n        k_max = 0\n\n    # Color class balance tie-breaker: sum of squares of class sizes (smaller is better)\n    class_sizes = {}\n    for c in valid_colors:\n        class_sizes[c] = class_sizes.get(c, 0) + 1\n    sum_sq = sum(sz * sz for sz in class_sizes.values()) if class_sizes else 0\n\n    # Penalties and objective assembly\n    penalty = 0\n    penalty += non_int * 5 * 10**7\n    penalty += non_pos_only * 10**7\n    # Moderate conflict penalty to permit exploratory steps\n    penalty += violations * 200000  # 2 * 1e5 per conflict\n\n    # Primary objective component (k_used), scaled\n    obj_k = k_used * 100000\n\n    # Tie within same k: compact palette and balanced classes; ensure < 1e5\n    tie = (max(0, k_max - k_used) * 1000) + min(90000, sum_sq * 1000)\n\n    # If no valid colors at all, force a large value but finite\n    if k_used == 0:\n        obj_k = 5 * 100000\n\n    return int(penalty + obj_k + tie)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Local neighbor generator for graph coloring on V={1..9}.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {\"Local\"}; Movement_Type in {\"Recolor-Conflict-Vertex\",\"Kempe-Chain-Flip\",\"Drop-Color-Attempt\",\"Conflict-Driven-Vertex-Swap\"}\n    Design choices:\n    - Disables pure color relabeling (Swap-Colors) as it doesn't change objective.\n    - Recolor-Conflict-Vertex only allows k+1 when conflicts exist; otherwise confines to 1..k.\n    - Drop-Color-Attempt tries to reduce k by recoloring the smallest color class without introducing new colors.\n    - Kempe-Chain-Flip biased to start from conflicting vertices when present.\n    - Normalization is applied only when a color is eliminated.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work, \"Local\", \"No-Op\"\n\n    # Embedded problem data\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of(sol: List[int]):\n        conf = set()\n        for u, v in edges0:\n            cu = sol[u]\n            cv = sol[v]\n            if isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1 and cu == cv:\n                conf.add(u)\n                conf.add(v)\n        return list(conf)\n\n    def k_used_and_classes(sol: List[int]):\n        valid = [c for c in sol if isinstance(c, int) and c >= 1]\n        classes = {}\n        for i, c in enumerate(sol):\n            if isinstance(c, int) and c >= 1:\n                classes.setdefault(c, []).append(i)\n        return (len(set(valid)) if valid else 1), classes\n\n    def normalize_if_eliminated(sol: List[int]):\n        # Compact colors to 1..k if there are gaps; used after successful drop\n        used = sorted(list({c for c in sol if isinstance(c, int) and c >= 1}))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        for i in range(len(sol)):\n            c = sol[i]\n            if isinstance(c, int) and c >= 1:\n                sol[i] = mapping[c]\n            else:\n                sol[i] = 1\n\n    conflict_vertices = conflicts_of(work)\n    k_used, classes = k_used_and_classes(work)\n\n    move_choices = []\n    if conflict_vertices:\n        move_choices.extend([\"Recolor-Conflict-Vertex\", \"Kempe-Chain-Flip\", \"Conflict-Driven-Vertex-Swap\"])  # conflict-focused\n    move_choices.append(\"Drop-Color-Attempt\")  # occasional k reduction attempt\n    if not move_choices:\n        move_choices = [\"Recolor-Conflict-Vertex\"]\n\n    move = random.choice(move_choices)\n\n    if move == \"Recolor-Conflict-Vertex\":\n        i = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        # Candidate colors: if conflicts exist, allow k+1; else restrict to 1..k\n        max_c = k_used + 1 if conflict_vertices else max(1, k_used)\n        candidates = list(range(1, max_c + 1))\n        random.shuffle(candidates)\n        best_c = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n        best_conf = n + 1\n        for c in candidates:\n            if c == work[i]:\n                continue\n            conf = 0\n            for nb in adj[i]:\n                cv = work[nb]\n                if isinstance(cv, int) and cv >= 1 and cv == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        work[i] = int(best_c)\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Kempe-Chain-Flip\":\n        # Choose two colors; bias to those involved in conflicts\n        involved = [work[i] for i in conflict_vertices if isinstance(work[i], int) and work[i] >= 1]\n        used_colors = list({c for c in work if isinstance(c, int) and c >= 1})\n        if len(set(involved)) >= 2:\n            c1, c2 = random.sample(list(set(involved)), 2)\n        elif len(used_colors) >= 2:\n            c1, c2 = random.sample(used_colors, 2)\n        else:\n            c1, c2 = 1, 2\n        # Start vertex: prefer conflicting vertices with color in {c1,c2}\n        cand = [i for i in (conflict_vertices if conflict_vertices else range(n)) if work[i] in (c1, c2)]\n        if not cand:\n            return work, \"Local\", \"Kempe-Chain-Flip\"\n        start = random.choice(cand)\n        # DFS on subgraph induced by colors {c1,c2}\n        target = {c1, c2}\n        visited = [False] * n\n        stack = [start]\n        comp = []\n        visited[start] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and work[v] in target:\n                    visited[v] = True\n                    stack.append(v)\n        # Flip\n        for u in comp:\n            if work[u] == c1:\n                work[u] = c2\n            elif work[u] == c2:\n                work[u] = c1\n        return work, \"Local\", \"Kempe-Chain-Flip\"\n\n    if move == \"Drop-Color-Attempt\":\n        # Pick smallest color class; attempt to recolor its vertices using existing colors excluding that color\n        if classes:\n            smallest_color = min(classes.keys(), key=lambda c: len(classes[c]))\n            verts = classes[smallest_color][:]\n            other_colors = [c for c in classes.keys() if c != smallest_color]\n            success = True\n            for v in verts:\n                # Try greedy recolor to a color not used by neighbors\n                random.shuffle(other_colors)\n                placed = False\n                for c in other_colors:\n                    ok = True\n                    for nb in adj[v]:\n                        cv = work[nb]\n                        if isinstance(cv, int) and cv >= 1 and cv == c:\n                            ok = False\n                            break\n                    if ok:\n                        work[v] = c\n                        placed = True\n                        break\n                if not placed:\n                    success = False\n                    break\n            if success:\n                # Eliminate the color and normalize\n                normalize_if_eliminated(work)\n                return work, \"Local\", \"Drop-Color-Attempt\"\n        # Fallback to a conflict-driven recolor if drop not possible\n        i = random.randrange(n)\n        work[i] = int(random.randint(1, max(2, k_used)))\n        return work, \"Local\", \"Recolor-Conflict-Vertex\"\n\n    if move == \"Conflict-Driven-Vertex-Swap\":\n        # Swap colors between a conflicting vertex and a random neighbor, if it may reduce local conflicts\n        if conflict_vertices:\n            i = random.choice(conflict_vertices)\n            nb_list = adj[i]\n            if nb_list:\n                j = random.choice(nb_list)\n                ci = work[i] if isinstance(work[i], int) and work[i] >= 1 else 1\n                cj = work[j] if isinstance(work[j], int) and work[j] >= 1 else 1\n                if ci != cj:\n                    # Evaluate local conflicts before and after\n                    def local_conf(u, color):\n                        cnt = 0\n                        for t in adj[u]:\n                            cv = work[t]\n                            if isinstance(cv, int) and cv >= 1 and cv == color and t != u:\n                                cnt += 1\n                        return cnt\n                    before = local_conf(i, ci) + local_conf(j, cj)\n                    after = local_conf(i, cj) + local_conf(j, ci)\n                    if after <= before:\n                        work[i], work[j] = cj, ci\n        return work, \"Local\", \"Conflict-Driven-Vertex-Swap\"\n\n    # Fallback: random recolor within current palette\n    i = random.randrange(n)\n    work[i] = int(random.randint(1, max(1, k_used)))\n    return work, \"Local\", \"Recolor-Random\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation for graph coloring:\n    - Multiple random recolors (allowing introduction of a new color with small probability).\n    - One Kempe-chain flip on random color pair.\n    - Final normalization to compact color labels.\n    Returns a new solution list of positive integers.\n    \"\"\"\n    work = list(solution) if isinstance(solution, list) else list(solution)\n\n    n = len(work)\n    if n == 0:\n        return work\n\n    # Embedded problem data\n    edges = [\n        (1, 4), (1, 5), (1, 6), (1, 8), (1, 9),\n        (2, 5), (2, 6), (2, 7), (2, 8), (2, 9),\n        (3, 4), (3, 6), (3, 7),\n        (4, 5), (4, 7), (4, 8), (4, 9),\n        (5, 6), (5, 9),\n        (6, 9),\n        (7, 8)\n    ]\n    edges0 = [(u - 1, v - 1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize_colors(sol: List[int]) -> None:\n        used = sorted(list({c for c in sol if isinstance(c, int) and c >= 1}))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        for i in range(len(sol)):\n            c = sol[i]\n            if isinstance(c, int) and c >= 1:\n                sol[i] = mapping[c]\n            else:\n                sol[i] = 1\n\n    valid = [c for c in work if isinstance(c, int) and c >= 1]\n    k_used = len(set(valid)) if valid else 1\n\n    # Random recolors\n    edits = max(4, n \/\/ 2)\n    for _ in range(edits):\n        i = random.randrange(n)\n        # With small probability, allow adding a new color to escape local minima\n        allow_new = (random.random() < 0.25)\n        max_c = k_used + 1 if allow_new else max(1, k_used)\n        work[i] = int(random.randint(1, max(2, max_c)))\n\n    # Kempe-chain flip\n    used = list({c for c in work if isinstance(c, int) and c >= 1})\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        cand = [i for i in range(n) if work[i] in (c1, c2)]\n        if cand:\n            start = random.choice(cand)\n            visited = [False] * n\n            stack = [start]\n            comp = []\n            visited[start] = True\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and work[v] in (c1, c2):\n                        visited[v] = True\n                        stack.append(v)\n            for u in comp:\n                work[u] = c2 if work[u] == c1 else (c1 if work[u] == c2 else work[u])\n\n    # Normalize labels\n    normalize_colors(work)\n\n    return work\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002362094}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9: comma-separated string of 9 positive integers representing colors [c1,...,c9] for nodes 1..9.","Evaluacion":"import math\nfrom typing import List, Union\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # minimality check by exact k-colorability backtracking for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_key is None or key > best_key:\n                    best_key = key; best_u = u\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a tuple of two strings: (new_solution_encoded, movement_description)\n    # Representation: CSV of 9 positive integers\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*9\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != 9:\n        colors = (colors + [1]*9)[:9]\n    # Neighborhood: recolor one random vertex to a different color in {1..max_color+1}\n    n = 9\n    max_c = max(colors) if colors else 1\n    u = random.randrange(n)\n    # candidate colors exclude current color\n    cand = [c for c in range(1, max_c+2) if c != colors[u]]\n    new_c = random.choice(cand)\n    new_sol = colors[:]\n    new_sol[u] = new_c\n    return encode(new_sol), \"Recolor-1-vertex\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution):\n    # Stronger random shake: recolor 2-4 random vertices, possibly introducing up to max_color+1\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*9\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != 9:\n        colors = (colors + [1]*9)[:9]\n    n = 9\n    max_c = max(colors) if colors else 1\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), k=t)\n    for u in idxs:\n        cand = [c for c in range(1, max_c+2) if c != colors[u]]\n        colors[u] = random.choice(cand)\n        max_c = max(max_c, colors[u])\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001196217}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9: comma-separated string of 9 positive integers representing colors [c1,...,c9] for nodes 1..9.","Evaluacion":"import math\nfrom typing import List, Union\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # minimality check by exact k-colorability backtracking for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_key is None or key > best_key:\n                    best_key = key; best_u = u\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a tuple of two strings: (new_solution_encoded, movement_description)\n    # Representation: CSV of 9 positive integers\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*9\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != 9:\n        colors = (colors + [1]*9)[:9]\n    # Neighborhood: recolor one random vertex to a different color in {1..max_color+1}\n    n = 9\n    max_c = max(colors) if colors else 1\n    u = random.randrange(n)\n    # candidate colors exclude current color\n    cand = [c for c in range(1, max_c+2) if c != colors[u]]\n    new_c = random.choice(cand)\n    new_sol = colors[:]\n    new_sol[u] = new_c\n    return encode(new_sol), \"Recolor-1-vertex\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution):\n    # Stronger random shake: recolor 2-4 random vertices, possibly introducing up to max_color+1\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*9\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != 9:\n        colors = (colors + [1]*9)[:9]\n    n = 9\n    max_c = max(colors) if colors else 1\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), k=t)\n    for u in idxs:\n        cand = [c for c in range(1, max_c+2) if c != colors[u]]\n        colors[u] = random.choice(cand)\n        max_c = max(max_c, colors[u])\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001287869}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9: comma-separated string of 9 positive integers representing colors [c1,...,c9] for nodes 1..9.","Evaluacion":"import math\nfrom typing import List, Union\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # minimality check by exact k-colorability backtracking for k < k_hat\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_key is None or key > best_key:\n                    best_key = key; best_u = u\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a tuple of two strings: (new_solution_encoded, movement_description)\n    # Representation: CSV of 9 positive integers\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*9\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != 9:\n        colors = (colors + [1]*9)[:9]\n    # Neighborhood: recolor one random vertex to a different color in {1..max_color+1}\n    n = 9\n    max_c = max(colors) if colors else 1\n    u = random.randrange(n)\n    # candidate colors exclude current color\n    cand = [c for c in range(1, max_c+2) if c != colors[u]]\n    new_c = random.choice(cand)\n    new_sol = colors[:]\n    new_sol[u] = new_c\n    return encode(new_sol), \"Recolor-1-vertex\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution):\n    # Stronger random shake: recolor 2-4 random vertices, possibly introducing up to max_color+1\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*9\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != 9:\n        colors = (colors + [1]*9)[:9]\n    n = 9\n    max_c = max(colors) if colors else 1\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), k=t)\n    for u in idxs:\n        cand = [c for c in range(1, max_c+2) if c != colors[u]]\n        colors[u] = random.choice(cand)\n        max_c = max(max_c, colors[u])\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001578612}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # conflict-guided penalty\n        return 5000000.0 + violations\n\n    k_hat = max(colors) if colors else 0\n\n    # exact omega by brute force (n=9)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # check if improvable to smaller k\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        order = sorted(range(1,n+1), key=lambda u: -len(adj[u]))\n        def available(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def backtrack(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            u = order[idx]\n            opts = available(u)\n            # least-constraining order\n            opts.sort(key=lambda c: sum(1 for v in adj[u] if col[v]==0 and c in [x for x in range(1,k+1) if x not in set(col[w] for w in adj[v] if col[w]!=0)]))\n            for c in opts:\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if not ok:\n                    continue\n                col[u] = c\n                if backtrack(idx+1):\n                    return True\n                col[u] = 0\n            return False\n        return backtrack(0)\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            out = (out + [1]*n)[:n]\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def normalize(sol_list: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        norm = []\n        for c in sol_list:\n            if c not in remap:\n                remap[c] = next_c\n                next_c += 1\n            norm.append(remap[c])\n        return norm\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    move_types = []\n\n    # Select a random move type among: single-vertex recolor within 1..k, color-pair swap, 2-vertex recolor\n    mt = random.choice([\"recolor1\", \"swap_pair\", \"recolor2\"])\n\n    if mt == \"recolor1\":\n        u = random.randrange(n)\n        current = colors[u]\n        # restrict within existing colors to avoid bloat\n        cand = [c for c in range(1, k+0) if c != current]\n        if not cand:\n            cand = [c for c in range(1, k+1) if c != current]\n        if not cand:\n            cand = [current]\n        new_c = random.choice(cand)\n        colors[u] = new_c\n        move_desc = \"Recolor-1-vertex\"\n    elif mt == \"swap_pair\":\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if colors[i] == a:\n                    colors[i] = b\n                elif colors[i] == b:\n                    colors[i] = a\n            move_desc = \"Swap-color-pair\"\n        else:\n            u = random.randrange(n)\n            colors[u] = 1\n            move_desc = \"Noop-to-1\"\n    else:  # recolor2\n        idxs = random.sample(range(n), k=min(2, n))\n        for u in idxs:\n            cur = colors[u]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                cand = [cur]\n            colors[u] = random.choice(cand)\n        move_desc = \"Recolor-2-vertices\"\n\n    colors = normalize(colors)\n    return encode(colors), move_desc\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution):\n    # Stronger shake via random Kempe-chain on a random color pair, repeated 1-2 times\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            out = (out + [1]*n)[:n]\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def normalize(sol_list: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        norm = []\n        for c in sol_list:\n            if c not in remap:\n                remap[c] = next_c\n                next_c += 1\n            norm.append(remap[c])\n        return norm\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    def kempe_chain_swap(colors_list, start_node, ca, cb):\n        # BFS over nodes colored ca\/cb connected by edges\n        from collections import deque\n        target = set([ca, cb])\n        visited = set()\n        comp = []\n        dq = deque([start_node])\n        visited.add(start_node)\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        # swap colors in component\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    repetitions = random.randint(1, 2)\n    for _ in range(repetitions):\n        k = max(colors) if colors else 1\n        if k < 2:\n            # simple recolors if only one color present\n            idxs = random.sample(range(n), k=min(3, n))\n            for u in idxs:\n                colors[u] = 1\n            continue\n        ca, cb = random.sample(range(1, k+1), 2)\n        # pick a start node having color ca or cb\n        cand_nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n        if not cand_nodes:\n            continue\n        start = random.choice(cand_nodes)\n        kempe_chain_swap(colors, start, ca, cb)\n        # occasional random recolor within existing palette for 1-2 vertices\n        t = random.randint(1, 2)\n        idxs = random.sample(range(n), k=t)\n        for u in idxs:\n            cur = colors[u]\n            avail = [c for c in range(1, k+1) if c != cur]\n            if avail:\n                colors[u] = random.choice(avail)\n\n    colors = normalize(colors)\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001631773}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # conflict-guided penalty\n        return 5000000.0 + violations\n\n    k_hat = max(colors) if colors else 0\n\n    # exact omega by brute force (n=9)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # check if improvable to smaller k\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        order = sorted(range(1,n+1), key=lambda u: -len(adj[u]))\n        def available(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def backtrack(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            u = order[idx]\n            opts = available(u)\n            # least-constraining order\n            opts.sort(key=lambda c: sum(1 for v in adj[u] if col[v]==0 and c in [x for x in range(1,k+1) if x not in set(col[w] for w in adj[v] if col[w]!=0)]))\n            for c in opts:\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if not ok:\n                    continue\n                col[u] = c\n                if backtrack(idx+1):\n                    return True\n                col[u] = 0\n            return False\n        return backtrack(0)\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            out = (out + [1]*n)[:n]\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def normalize(sol_list: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        norm = []\n        for c in sol_list:\n            if c not in remap:\n                remap[c] = next_c\n                next_c += 1\n            norm.append(remap[c])\n        return norm\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    move_types = []\n\n    # Select a random move type among: single-vertex recolor within 1..k, color-pair swap, 2-vertex recolor\n    mt = random.choice([\"recolor1\", \"swap_pair\", \"recolor2\"])\n\n    if mt == \"recolor1\":\n        u = random.randrange(n)\n        current = colors[u]\n        # restrict within existing colors to avoid bloat\n        cand = [c for c in range(1, k+0) if c != current]\n        if not cand:\n            cand = [c for c in range(1, k+1) if c != current]\n        if not cand:\n            cand = [current]\n        new_c = random.choice(cand)\n        colors[u] = new_c\n        move_desc = \"Recolor-1-vertex\"\n    elif mt == \"swap_pair\":\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if colors[i] == a:\n                    colors[i] = b\n                elif colors[i] == b:\n                    colors[i] = a\n            move_desc = \"Swap-color-pair\"\n        else:\n            u = random.randrange(n)\n            colors[u] = 1\n            move_desc = \"Noop-to-1\"\n    else:  # recolor2\n        idxs = random.sample(range(n), k=min(2, n))\n        for u in idxs:\n            cur = colors[u]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                cand = [cur]\n            colors[u] = random.choice(cand)\n        move_desc = \"Recolor-2-vertices\"\n\n    colors = normalize(colors)\n    return encode(colors), move_desc\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution):\n    # Stronger shake via random Kempe-chain on a random color pair, repeated 1-2 times\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            out = (out + [1]*n)[:n]\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def normalize(sol_list: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        norm = []\n        for c in sol_list:\n            if c not in remap:\n                remap[c] = next_c\n                next_c += 1\n            norm.append(remap[c])\n        return norm\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    def kempe_chain_swap(colors_list, start_node, ca, cb):\n        # BFS over nodes colored ca\/cb connected by edges\n        from collections import deque\n        target = set([ca, cb])\n        visited = set()\n        comp = []\n        dq = deque([start_node])\n        visited.add(start_node)\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        # swap colors in component\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    repetitions = random.randint(1, 2)\n    for _ in range(repetitions):\n        k = max(colors) if colors else 1\n        if k < 2:\n            # simple recolors if only one color present\n            idxs = random.sample(range(n), k=min(3, n))\n            for u in idxs:\n                colors[u] = 1\n            continue\n        ca, cb = random.sample(range(1, k+1), 2)\n        # pick a start node having color ca or cb\n        cand_nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n        if not cand_nodes:\n            continue\n        start = random.choice(cand_nodes)\n        kempe_chain_swap(colors, start, ca, cb)\n        # occasional random recolor within existing palette for 1-2 vertices\n        t = random.randint(1, 2)\n        idxs = random.sample(range(n), k=t)\n        for u in idxs:\n            cur = colors[u]\n            avail = [c for c in range(1, k+1) if c != cur]\n            if avail:\n                colors[u] = random.choice(avail)\n\n    colors = normalize(colors)\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001948907}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # conflict-guided penalty\n        return 5000000.0 + violations\n\n    k_hat = max(colors) if colors else 0\n\n    # exact omega by brute force (n=9)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # check if improvable to smaller k\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k: int) -> bool:\n        col = {i:0 for i in range(1,n+1)}\n        order = sorted(range(1,n+1), key=lambda u: -len(adj[u]))\n        def available(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def backtrack(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            u = order[idx]\n            opts = available(u)\n            # least-constraining order\n            opts.sort(key=lambda c: sum(1 for v in adj[u] if col[v]==0 and c in [x for x in range(1,k+1) if x not in set(col[w] for w in adj[v] if col[w]!=0)]))\n            for c in opts:\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if not ok:\n                    continue\n                col[u] = c\n                if backtrack(idx+1):\n                    return True\n                col[u] = 0\n            return False\n        return backtrack(0)\n\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            out = (out + [1]*n)[:n]\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def normalize(sol_list: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        norm = []\n        for c in sol_list:\n            if c not in remap:\n                remap[c] = next_c\n                next_c += 1\n            norm.append(remap[c])\n        return norm\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    move_types = []\n\n    # Select a random move type among: single-vertex recolor within 1..k, color-pair swap, 2-vertex recolor\n    mt = random.choice([\"recolor1\", \"swap_pair\", \"recolor2\"])\n\n    if mt == \"recolor1\":\n        u = random.randrange(n)\n        current = colors[u]\n        # restrict within existing colors to avoid bloat\n        cand = [c for c in range(1, k+0) if c != current]\n        if not cand:\n            cand = [c for c in range(1, k+1) if c != current]\n        if not cand:\n            cand = [current]\n        new_c = random.choice(cand)\n        colors[u] = new_c\n        move_desc = \"Recolor-1-vertex\"\n    elif mt == \"swap_pair\":\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if colors[i] == a:\n                    colors[i] = b\n                elif colors[i] == b:\n                    colors[i] = a\n            move_desc = \"Swap-color-pair\"\n        else:\n            u = random.randrange(n)\n            colors[u] = 1\n            move_desc = \"Noop-to-1\"\n    else:  # recolor2\n        idxs = random.sample(range(n), k=min(2, n))\n        for u in idxs:\n            cur = colors[u]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                cand = [cur]\n            colors[u] = random.choice(cand)\n        move_desc = \"Recolor-2-vertices\"\n\n    colors = normalize(colors)\n    return encode(colors), move_desc\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution):\n    # Stronger shake via random Kempe-chain on a random color pair, repeated 1-2 times\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            out = (out + [1]*n)[:n]\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def normalize(sol_list: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        norm = []\n        for c in sol_list:\n            if c not in remap:\n                remap[c] = next_c\n                next_c += 1\n            norm.append(remap[c])\n        return norm\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    def kempe_chain_swap(colors_list, start_node, ca, cb):\n        # BFS over nodes colored ca\/cb connected by edges\n        from collections import deque\n        target = set([ca, cb])\n        visited = set()\n        comp = []\n        dq = deque([start_node])\n        visited.add(start_node)\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        # swap colors in component\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    repetitions = random.randint(1, 2)\n    for _ in range(repetitions):\n        k = max(colors) if colors else 1\n        if k < 2:\n            # simple recolors if only one color present\n            idxs = random.sample(range(n), k=min(3, n))\n            for u in idxs:\n                colors[u] = 1\n            continue\n        ca, cb = random.sample(range(1, k+1), 2)\n        # pick a start node having color ca or cb\n        cand_nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n        if not cand_nodes:\n            continue\n        start = random.choice(cand_nodes)\n        kempe_chain_swap(colors, start, ca, cb)\n        # occasional random recolor within existing palette for 1-2 vertices\n        t = random.randint(1, 2)\n        idxs = random.sample(range(n), k=t)\n        for u in idxs:\n            cur = colors[u]\n            avail = [c for c in range(1, k+1) if c != cur]\n            if avail:\n                colors[u] = random.choice(avail)\n\n    colors = normalize(colors)\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001967738}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns float cost.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        return out\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n\n    # feasible: objective is k with small tie-break preference for fewer colors used densely packed\n    k_hat = max(colors) if colors else 0\n\n    # Compute clique lower bound omega\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n    lb_penalty = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n\n    # small tie-break that prefers tighter palettes but never overrides k\n    tie = 0.0001 * (len(set(colors)) - k_hat)\n    return float(k_hat) + lb_penalty + tie\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution_str, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            # Strict: do not pad\/truncate silently; repair by clipping or extending with 1s deterministically\n            if len(out) > n:\n                out = out[:n]\n            else:\n                out = out + [1]*(n - len(out))\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> Tuple[int, List[Tuple[int,int]]]:\n        confl = []\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                confl.append((u,v))\n                cnt += 1\n        return cnt, confl\n\n    def legal_for(u: int, c: int, colors: List[int]) -> bool:\n        for v in adj[u]:\n            if colors[v-1] == c:\n                return False\n        return True\n\n    def try_eliminate_top_color(colors: List[int]) -> bool:\n        k = max(colors)\n        target = k\n        changed = False\n        # attempt to reassign vertices with color k into 1..k-1 greedily\n        verts = [i+1 for i in range(n) if colors[i] == target]\n        if not verts:\n            return False\n        for u in verts:\n            # choose a color that doesn't conflict, prefer lowest\n            for c in range(1, target):\n                if legal_for(u, c, colors):\n                    colors[u-1] = c\n                    changed = True\n                    break\n            else:\n                # failed to recolor one vertex -> rollback and return False\n                for w in range(n):\n                    if w+1 in verts and colors[w] == target:\n                        pass\n                return False\n        # success: drop k by renormalizing labels (no-op needed, but keep consistent)\n        return changed\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    total_conf, confl_edges = conflicts_of(colors)\n\n    # If feasible, attempt color elimination move first with small probability to keep it as a neighbour move\n    if total_conf == 0:\n        if k > 1 and random.random() < 0.7:\n            colors_copy = list(colors)\n            if try_eliminate_top_color(colors_copy):\n                return encode(colors_copy), \"Eliminate-top-color\"\n        # Otherwise, small recolor move of a random vertex to another existing color while keeping feasibility\n        trials = 0\n        max_trials = 20\n        while trials < max_trials:\n            trials += 1\n            u = random.randrange(1, n+1)\n            cur = colors[u-1]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                continue\n            cnew = random.choice(cand)\n            if legal_for(u, cnew, colors):\n                colors[u-1] = cnew\n                return encode(colors), \"Feasible-recolor\"\n        # fallback: color-pair Kempe chain that preserves feasibility\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (a,b)]\n            if nodes:\n                start = random.choice(nodes)\n                colors2 = list(colors)\n                kempe_chain_swap(colors2, start, a, b)\n                # ensure feasibility\n                conf2, _ = conflicts_of(colors2)\n                if conf2 == 0:\n                    return encode(colors2), \"Feasible-Kempe-swap\"\n        return encode(colors), \"Noop-feasible\"\n\n    # Infeasible: target conflicting vertices with highest degree\/saturation\n    conflict_vertices = set()\n    for (u,v) in confl_edges:\n        conflict_vertices.add(u); conflict_vertices.add(v)\n    # choose vertex by degree then saturation degree\n    def sat_deg(u: int, cols: List[int]) -> int:\n        return len({cols[v-1] for v in adj[u]})\n    cand_vs = sorted(list(conflict_vertices), key=lambda u: (-len(adj[u]), -sat_deg(u, colors)))\n    u = cand_vs[0]\n    cur = colors[u-1]\n    # try recolor to reduce conflicts; allow existing colors 1..k and occasionally introduce k+1 to escape\n    palette = list(range(1, k+1)) + ([k+1] if random.random() < 0.05 else [])\n    best_c = cur\n    best_conf = 10**9\n    random.shuffle(palette)\n    for c in palette:\n        if c == cur:\n            continue\n        tmp = list(colors)\n        tmp[u-1] = c\n        conf, _ = conflicts_of(tmp)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n            if conf == total_conf - 1:\n                # good immediate improvement; early accept\n                pass\n    if best_c != cur:\n        colors[u-1] = best_c\n        return encode(colors), \"Conflict-recolor\"\n\n    # If recolor didn't help, try Kempe chain on a conflicting edge's colors\n    (a_u, a_v) = confl_edges[0]\n    ca, cb = colors[a_u-1], colors[a_v-1]\n    start = random.choice([a_u, a_v])\n    colors2 = list(colors)\n    kempe_chain_swap(colors2, start, ca, cb)\n    return encode(colors2), \"Kempe-chain\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\n\ndef perturb_solution(solution):\n    # Stronger diversification via multiple Kempe-chain swaps and random feasible-biased recolors\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            if len(out) > n:\n                out = out[:n]\n            else:\n                out = out + [1]*(n - len(out))\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    reps = random.randint(2, 4)\n    for _ in range(reps):\n        k = max(colors) if colors else 1\n        if k >= 2:\n            ca, cb = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n            if nodes:\n                start = random.choice(nodes)\n                kempe_chain_swap(colors, start, ca, cb)\n        # random recolor a few vertices within palette (allow k+1 rarely to escape)\n        t = random.randint(1, 3)\n        for _j in range(t):\n            u = random.randrange(1, n+1)\n            pal = list(range(1, (max(colors) if colors else 1)+1))\n            if random.random() < 0.05:\n                pal.append((max(colors) if colors else 1)+1)\n            cur = colors[u-1]\n            if pal:\n                choices = [c for c in pal if c != cur]\n                if choices:\n                    colors[u-1] = random.choice(choices)\n\n    # small greedy repair bias if conflicts exploded\n    if conflicts_of(colors) > 0:\n        for u in range(1, n+1):\n            cur = colors[u-1]\n            best = cur\n            best_conf = conflicts_of(colors)\n            for c in range(1, max(colors)+1):\n                if c == cur:\n                    continue\n                tmp = list(colors)\n                tmp[u-1] = c\n                conf = conflicts_of(tmp)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n            colors[u-1] = best\n\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001676163}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns float cost.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        return out\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n\n    # feasible: objective is k with small tie-break preference for fewer colors used densely packed\n    k_hat = max(colors) if colors else 0\n\n    # Compute clique lower bound omega\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n    lb_penalty = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n\n    # small tie-break that prefers tighter palettes but never overrides k\n    tie = 0.0001 * (len(set(colors)) - k_hat)\n    return float(k_hat) + lb_penalty + tie\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution_str, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            # Strict: do not pad\/truncate silently; repair by clipping or extending with 1s deterministically\n            if len(out) > n:\n                out = out[:n]\n            else:\n                out = out + [1]*(n - len(out))\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> Tuple[int, List[Tuple[int,int]]]:\n        confl = []\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                confl.append((u,v))\n                cnt += 1\n        return cnt, confl\n\n    def legal_for(u: int, c: int, colors: List[int]) -> bool:\n        for v in adj[u]:\n            if colors[v-1] == c:\n                return False\n        return True\n\n    def try_eliminate_top_color(colors: List[int]) -> bool:\n        k = max(colors)\n        target = k\n        changed = False\n        # attempt to reassign vertices with color k into 1..k-1 greedily\n        verts = [i+1 for i in range(n) if colors[i] == target]\n        if not verts:\n            return False\n        for u in verts:\n            # choose a color that doesn't conflict, prefer lowest\n            for c in range(1, target):\n                if legal_for(u, c, colors):\n                    colors[u-1] = c\n                    changed = True\n                    break\n            else:\n                # failed to recolor one vertex -> rollback and return False\n                for w in range(n):\n                    if w+1 in verts and colors[w] == target:\n                        pass\n                return False\n        # success: drop k by renormalizing labels (no-op needed, but keep consistent)\n        return changed\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    total_conf, confl_edges = conflicts_of(colors)\n\n    # If feasible, attempt color elimination move first with small probability to keep it as a neighbour move\n    if total_conf == 0:\n        if k > 1 and random.random() < 0.7:\n            colors_copy = list(colors)\n            if try_eliminate_top_color(colors_copy):\n                return encode(colors_copy), \"Eliminate-top-color\"\n        # Otherwise, small recolor move of a random vertex to another existing color while keeping feasibility\n        trials = 0\n        max_trials = 20\n        while trials < max_trials:\n            trials += 1\n            u = random.randrange(1, n+1)\n            cur = colors[u-1]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                continue\n            cnew = random.choice(cand)\n            if legal_for(u, cnew, colors):\n                colors[u-1] = cnew\n                return encode(colors), \"Feasible-recolor\"\n        # fallback: color-pair Kempe chain that preserves feasibility\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (a,b)]\n            if nodes:\n                start = random.choice(nodes)\n                colors2 = list(colors)\n                kempe_chain_swap(colors2, start, a, b)\n                # ensure feasibility\n                conf2, _ = conflicts_of(colors2)\n                if conf2 == 0:\n                    return encode(colors2), \"Feasible-Kempe-swap\"\n        return encode(colors), \"Noop-feasible\"\n\n    # Infeasible: target conflicting vertices with highest degree\/saturation\n    conflict_vertices = set()\n    for (u,v) in confl_edges:\n        conflict_vertices.add(u); conflict_vertices.add(v)\n    # choose vertex by degree then saturation degree\n    def sat_deg(u: int, cols: List[int]) -> int:\n        return len({cols[v-1] for v in adj[u]})\n    cand_vs = sorted(list(conflict_vertices), key=lambda u: (-len(adj[u]), -sat_deg(u, colors)))\n    u = cand_vs[0]\n    cur = colors[u-1]\n    # try recolor to reduce conflicts; allow existing colors 1..k and occasionally introduce k+1 to escape\n    palette = list(range(1, k+1)) + ([k+1] if random.random() < 0.05 else [])\n    best_c = cur\n    best_conf = 10**9\n    random.shuffle(palette)\n    for c in palette:\n        if c == cur:\n            continue\n        tmp = list(colors)\n        tmp[u-1] = c\n        conf, _ = conflicts_of(tmp)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n            if conf == total_conf - 1:\n                # good immediate improvement; early accept\n                pass\n    if best_c != cur:\n        colors[u-1] = best_c\n        return encode(colors), \"Conflict-recolor\"\n\n    # If recolor didn't help, try Kempe chain on a conflicting edge's colors\n    (a_u, a_v) = confl_edges[0]\n    ca, cb = colors[a_u-1], colors[a_v-1]\n    start = random.choice([a_u, a_v])\n    colors2 = list(colors)\n    kempe_chain_swap(colors2, start, ca, cb)\n    return encode(colors2), \"Kempe-chain\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\n\ndef perturb_solution(solution):\n    # Stronger diversification via multiple Kempe-chain swaps and random feasible-biased recolors\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            if len(out) > n:\n                out = out[:n]\n            else:\n                out = out + [1]*(n - len(out))\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    reps = random.randint(2, 4)\n    for _ in range(reps):\n        k = max(colors) if colors else 1\n        if k >= 2:\n            ca, cb = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n            if nodes:\n                start = random.choice(nodes)\n                kempe_chain_swap(colors, start, ca, cb)\n        # random recolor a few vertices within palette (allow k+1 rarely to escape)\n        t = random.randint(1, 3)\n        for _j in range(t):\n            u = random.randrange(1, n+1)\n            pal = list(range(1, (max(colors) if colors else 1)+1))\n            if random.random() < 0.05:\n                pal.append((max(colors) if colors else 1)+1)\n            cur = colors[u-1]\n            if pal:\n                choices = [c for c in pal if c != cur]\n                if choices:\n                    colors[u-1] = random.choice(choices)\n\n    # small greedy repair bias if conflicts exploded\n    if conflicts_of(colors) > 0:\n        for u in range(1, n+1):\n            cur = colors[u-1]\n            best = cur\n            best_conf = conflicts_of(colors)\n            for c in range(1, max(colors)+1):\n                if c == cur:\n                    continue\n                tmp = list(colors)\n                tmp[u-1] = c\n                conf = conflicts_of(tmp)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n            colors[u-1] = best\n\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00218752}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns float cost.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        return out\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n\n    # feasible: objective is k with small tie-break preference for fewer colors used densely packed\n    k_hat = max(colors) if colors else 0\n\n    # Compute clique lower bound omega\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n    lb_penalty = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n\n    # small tie-break that prefers tighter palettes but never overrides k\n    tie = 0.0001 * (len(set(colors)) - k_hat)\n    return float(k_hat) + lb_penalty + tie\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution_str, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            # Strict: do not pad\/truncate silently; repair by clipping or extending with 1s deterministically\n            if len(out) > n:\n                out = out[:n]\n            else:\n                out = out + [1]*(n - len(out))\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> Tuple[int, List[Tuple[int,int]]]:\n        confl = []\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                confl.append((u,v))\n                cnt += 1\n        return cnt, confl\n\n    def legal_for(u: int, c: int, colors: List[int]) -> bool:\n        for v in adj[u]:\n            if colors[v-1] == c:\n                return False\n        return True\n\n    def try_eliminate_top_color(colors: List[int]) -> bool:\n        k = max(colors)\n        target = k\n        changed = False\n        # attempt to reassign vertices with color k into 1..k-1 greedily\n        verts = [i+1 for i in range(n) if colors[i] == target]\n        if not verts:\n            return False\n        for u in verts:\n            # choose a color that doesn't conflict, prefer lowest\n            for c in range(1, target):\n                if legal_for(u, c, colors):\n                    colors[u-1] = c\n                    changed = True\n                    break\n            else:\n                # failed to recolor one vertex -> rollback and return False\n                for w in range(n):\n                    if w+1 in verts and colors[w] == target:\n                        pass\n                return False\n        # success: drop k by renormalizing labels (no-op needed, but keep consistent)\n        return changed\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    total_conf, confl_edges = conflicts_of(colors)\n\n    # If feasible, attempt color elimination move first with small probability to keep it as a neighbour move\n    if total_conf == 0:\n        if k > 1 and random.random() < 0.7:\n            colors_copy = list(colors)\n            if try_eliminate_top_color(colors_copy):\n                return encode(colors_copy), \"Eliminate-top-color\"\n        # Otherwise, small recolor move of a random vertex to another existing color while keeping feasibility\n        trials = 0\n        max_trials = 20\n        while trials < max_trials:\n            trials += 1\n            u = random.randrange(1, n+1)\n            cur = colors[u-1]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                continue\n            cnew = random.choice(cand)\n            if legal_for(u, cnew, colors):\n                colors[u-1] = cnew\n                return encode(colors), \"Feasible-recolor\"\n        # fallback: color-pair Kempe chain that preserves feasibility\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (a,b)]\n            if nodes:\n                start = random.choice(nodes)\n                colors2 = list(colors)\n                kempe_chain_swap(colors2, start, a, b)\n                # ensure feasibility\n                conf2, _ = conflicts_of(colors2)\n                if conf2 == 0:\n                    return encode(colors2), \"Feasible-Kempe-swap\"\n        return encode(colors), \"Noop-feasible\"\n\n    # Infeasible: target conflicting vertices with highest degree\/saturation\n    conflict_vertices = set()\n    for (u,v) in confl_edges:\n        conflict_vertices.add(u); conflict_vertices.add(v)\n    # choose vertex by degree then saturation degree\n    def sat_deg(u: int, cols: List[int]) -> int:\n        return len({cols[v-1] for v in adj[u]})\n    cand_vs = sorted(list(conflict_vertices), key=lambda u: (-len(adj[u]), -sat_deg(u, colors)))\n    u = cand_vs[0]\n    cur = colors[u-1]\n    # try recolor to reduce conflicts; allow existing colors 1..k and occasionally introduce k+1 to escape\n    palette = list(range(1, k+1)) + ([k+1] if random.random() < 0.05 else [])\n    best_c = cur\n    best_conf = 10**9\n    random.shuffle(palette)\n    for c in palette:\n        if c == cur:\n            continue\n        tmp = list(colors)\n        tmp[u-1] = c\n        conf, _ = conflicts_of(tmp)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n            if conf == total_conf - 1:\n                # good immediate improvement; early accept\n                pass\n    if best_c != cur:\n        colors[u-1] = best_c\n        return encode(colors), \"Conflict-recolor\"\n\n    # If recolor didn't help, try Kempe chain on a conflicting edge's colors\n    (a_u, a_v) = confl_edges[0]\n    ca, cb = colors[a_u-1], colors[a_v-1]\n    start = random.choice([a_u, a_v])\n    colors2 = list(colors)\n    kempe_chain_swap(colors2, start, ca, cb)\n    return encode(colors2), \"Kempe-chain\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\n\ndef perturb_solution(solution):\n    # Stronger diversification via multiple Kempe-chain swaps and random feasible-biased recolors\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                out = [1]*n\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                out = [1]*n\n        else:\n            out = [1]*n\n        if len(out) != n:\n            if len(out) > n:\n                out = out[:n]\n            else:\n                out = out + [1]*(n - len(out))\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    k = max(colors) if colors else 1\n\n    reps = random.randint(2, 4)\n    for _ in range(reps):\n        k = max(colors) if colors else 1\n        if k >= 2:\n            ca, cb = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n            if nodes:\n                start = random.choice(nodes)\n                kempe_chain_swap(colors, start, ca, cb)\n        # random recolor a few vertices within palette (allow k+1 rarely to escape)\n        t = random.randint(1, 3)\n        for _j in range(t):\n            u = random.randrange(1, n+1)\n            pal = list(range(1, (max(colors) if colors else 1)+1))\n            if random.random() < 0.05:\n                pal.append((max(colors) if colors else 1)+1)\n            cur = colors[u-1]\n            if pal:\n                choices = [c for c in pal if c != cur]\n                if choices:\n                    colors[u-1] = random.choice(choices)\n\n    # small greedy repair bias if conflicts exploded\n    if conflicts_of(colors) > 0:\n        for u in range(1, n+1):\n            cur = colors[u-1]\n            best = cur\n            best_conf = conflicts_of(colors)\n            for c in range(1, max(colors)+1):\n                if c == cur:\n                    continue\n                tmp = list(colors)\n                tmp[u-1] = c\n                conf = conflicts_of(tmp)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n            colors[u-1] = best\n\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002068408}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns float cost.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Precomputed clique lower bound for this graph (omega=4) to avoid exponential recomputation\n    omega_const = 4\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        return out\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + float(abs(len(colors)-n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n\n    # feasible objective: minimize k\n    k_hat = max(colors) if colors else 0\n\n    lb_penalty = 0.0 if k_hat >= omega_const else (omega_const - k_hat) * 1000.0\n\n    # No stochastic tie-breaker to keep acceptance neutral for equal-k\n    return float(k_hat) + lb_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution_str, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> Union[List[int], None]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        if len(out) != n:\n            return None\n        if any((not isinstance(x, int)) or (x < 1) for x in out):\n            return None\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> Tuple[int, List[Tuple[int,int]]]:\n        confl = []\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                confl.append((u,v))\n                cnt += 1\n        return cnt, confl\n\n    def legal_for(u: int, c: int, colors: List[int]) -> bool:\n        for v in adj[u]:\n            if colors[v-1] == c:\n                return False\n        return True\n\n    def try_eliminate_top_color(colors: List[int]) -> bool:\n        # Transactional recoloring of vertices with color k into lower colors (DSATUR-guided)\n        k = max(colors)\n        target = k\n        verts = [i+1 for i in range(n) if colors[i] == target]\n        if not verts:\n            return False\n        # Order verts by descending saturation degree and degree\n        def sat_deg(u: int, cols: List[int]) -> int:\n            return len({cols[v-1] for v in adj[u]})\n        order = sorted(verts, key=lambda u: (-sat_deg(u, colors), -len(adj[u])))\n        new_colors = list(colors)\n        for u in order:\n            moved = False\n            for c in range(1, target):\n                if legal_for(u, c, new_colors):\n                    new_colors[u-1] = c\n                    moved = True\n                    break\n            if not moved:\n                return False  # Abort fully; no partial mutation\n        # Commit\n        for idx in range(n):\n            colors[idx] = new_colors[idx]\n        return True\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    if colors is None:\n        # Return a safe default and label as invalid-input repair\n        return \",\".join([\"1\"]*n), \"Invalid-input-repair\"\n\n    k = max(colors) if colors else 1\n    total_conf, confl_edges = conflicts_of(colors)\n\n    # Feasible neighbourhoods\n    if total_conf == 0:\n        # Prefer color elimination\n        if k > 1 and random.random() < 0.8:\n            colors_copy = list(colors)\n            if try_eliminate_top_color(colors_copy):\n                return encode(colors_copy), \"Eliminate-top-color\"\n        # Feasible recolor within existing palette\n        trials = 0\n        max_trials = 24\n        while trials < max_trials:\n            trials += 1\n            u = random.randrange(1, n+1)\n            cur = colors[u-1]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                continue\n            cnew = random.choice(cand)\n            if legal_for(u, cnew, colors):\n                colors2 = list(colors)\n                colors2[u-1] = cnew\n                return encode(colors2), \"Feasible-recolor\"\n        # Kempe swap preserving feasibility\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (a,b)]\n            if nodes:\n                start = random.choice(nodes)\n                colors2 = list(colors)\n                kempe_chain_swap(colors2, start, a, b)\n                conf2, _ = conflicts_of(colors2)\n                if conf2 == 0:\n                    return encode(colors2), \"Feasible-Kempe-swap\"\n        return encode(colors), \"Noop-feasible\"\n\n    # Infeasible branch: target a conflicting vertex\n    conflict_vertices = set()\n    for (u,v) in confl_edges:\n        conflict_vertices.add(u); conflict_vertices.add(v)\n\n    def sat_deg(u: int, cols: List[int]) -> int:\n        return len({cols[v-1] for v in adj[u]})\n\n    cand_vs = sorted(list(conflict_vertices), key=lambda u: (-len(adj[u]), -sat_deg(u, colors)))\n    u = cand_vs[0]\n    cur = colors[u-1]\n\n    # Try recolors within current palette; allow k+1 only if it strictly decreases conflicts\n    palette = list(range(1, k+1))\n    best_c = cur\n    best_conf = 10**9\n    random.shuffle(palette)\n    for c in palette:\n        if c == cur:\n            continue\n        tmp = list(colors)\n        tmp[u-1] = c\n        conf, _ = conflicts_of(tmp)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n    if best_c != cur and best_conf < total_conf:\n        colors2 = list(colors)\n        colors2[u-1] = best_c\n        return encode(colors2), \"Conflict-recolor\"\n\n    # Consider introducing k+1 only if strictly reduces conflicts\n    tmp = list(colors)\n    tmp[u-1] = k+1\n    conf_new, _ = conflicts_of(tmp)\n    if conf_new < total_conf:\n        return encode(tmp), \"Conflict-recolor-introduce-k+1\"\n\n    # Kempe swap on a conflicting edge's color pair; accept only if not worse\n    (a_u, a_v) = confl_edges[0]\n    ca, cb = colors[a_u-1], colors[a_v-1]\n    start = random.choice([a_u, a_v])\n    colors2 = list(colors)\n    kempe_chain_swap(colors2, start, ca, cb)\n    conf2, _ = conflicts_of(colors2)\n    if conf2 <= total_conf:\n        return encode(colors2), \"Kempe-chain-nonworsening\"\n\n    return encode(colors), \"Noop-infeasible\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\n\ndef perturb_solution(solution):\n    # Diversification via Kempe-chain swaps and focused recolors from top color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> Union[List[int], None]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        if len(out) != n:\n            return None\n        if any((not isinstance(x, int)) or (x < 1) for x in out):\n            return None\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    if colors is None:\n        return \",\".join([\"1\"]*n)\n\n    # Apply 2-3 Kempe-chain swaps over random color pairs\n    reps = random.randint(2, 3)\n    for _ in range(reps):\n        k = max(colors) if colors else 1\n        if k >= 2:\n            ca, cb = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n            if nodes:\n                start = random.choice(nodes)\n                kempe_chain_swap(colors, start, ca, cb)\n        # Random intra-palette recolors (biased to change top color vertices)\n        k = max(colors)\n        top_nodes = [i+1 for i in range(n) if colors[i] == k]\n        pool = top_nodes if top_nodes else list(range(1, n+1))\n        t = random.randint(1, 3)\n        for _j in range(t):\n            u = random.choice(pool)\n            pal = list(range(1, k+1))\n            cur = colors[u-1]\n            choices = [c for c in pal if c != cur]\n            if choices:\n                colors[u-1] = random.choice(choices)\n\n    # If still infeasible and stuck, allow a single k+1 only if conflicts strictly decrease and cap increase by 1\n    before = conflicts_of(colors)\n    if before > 0:\n        k = max(colors)\n        # try greedy repairs without increasing k\n        improved = True\n        while improved:\n            improved = False\n            for u in range(1, n+1):\n                cur = colors[u-1]\n                best = cur\n                best_conf = before\n                for c in range(1, k+1):\n                    if c == cur:\n                        continue\n                    tmp = list(colors)\n                    tmp[u-1] = c\n                    conf = conflicts_of(tmp)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best = c\n                if best != cur:\n                    colors[u-1] = best\n                    before = best_conf\n                    improved = True\n        if before > 0:\n            # try at most one promotion to k+1 if it strictly reduces conflicts\n            u = random.randrange(1, n+1)\n            tmp = list(colors)\n            tmp[u-1] = k+1\n            if conflicts_of(tmp) < before:\n                colors = tmp\n\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001616032}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns float cost.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Precomputed clique lower bound for this graph (omega=4) to avoid exponential recomputation\n    omega_const = 4\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        return out\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + float(abs(len(colors)-n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n\n    # feasible objective: minimize k\n    k_hat = max(colors) if colors else 0\n\n    lb_penalty = 0.0 if k_hat >= omega_const else (omega_const - k_hat) * 1000.0\n\n    # No stochastic tie-breaker to keep acceptance neutral for equal-k\n    return float(k_hat) + lb_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution_str, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> Union[List[int], None]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        if len(out) != n:\n            return None\n        if any((not isinstance(x, int)) or (x < 1) for x in out):\n            return None\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> Tuple[int, List[Tuple[int,int]]]:\n        confl = []\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                confl.append((u,v))\n                cnt += 1\n        return cnt, confl\n\n    def legal_for(u: int, c: int, colors: List[int]) -> bool:\n        for v in adj[u]:\n            if colors[v-1] == c:\n                return False\n        return True\n\n    def try_eliminate_top_color(colors: List[int]) -> bool:\n        # Transactional recoloring of vertices with color k into lower colors (DSATUR-guided)\n        k = max(colors)\n        target = k\n        verts = [i+1 for i in range(n) if colors[i] == target]\n        if not verts:\n            return False\n        # Order verts by descending saturation degree and degree\n        def sat_deg(u: int, cols: List[int]) -> int:\n            return len({cols[v-1] for v in adj[u]})\n        order = sorted(verts, key=lambda u: (-sat_deg(u, colors), -len(adj[u])))\n        new_colors = list(colors)\n        for u in order:\n            moved = False\n            for c in range(1, target):\n                if legal_for(u, c, new_colors):\n                    new_colors[u-1] = c\n                    moved = True\n                    break\n            if not moved:\n                return False  # Abort fully; no partial mutation\n        # Commit\n        for idx in range(n):\n            colors[idx] = new_colors[idx]\n        return True\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    if colors is None:\n        # Return a safe default and label as invalid-input repair\n        return \",\".join([\"1\"]*n), \"Invalid-input-repair\"\n\n    k = max(colors) if colors else 1\n    total_conf, confl_edges = conflicts_of(colors)\n\n    # Feasible neighbourhoods\n    if total_conf == 0:\n        # Prefer color elimination\n        if k > 1 and random.random() < 0.8:\n            colors_copy = list(colors)\n            if try_eliminate_top_color(colors_copy):\n                return encode(colors_copy), \"Eliminate-top-color\"\n        # Feasible recolor within existing palette\n        trials = 0\n        max_trials = 24\n        while trials < max_trials:\n            trials += 1\n            u = random.randrange(1, n+1)\n            cur = colors[u-1]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                continue\n            cnew = random.choice(cand)\n            if legal_for(u, cnew, colors):\n                colors2 = list(colors)\n                colors2[u-1] = cnew\n                return encode(colors2), \"Feasible-recolor\"\n        # Kempe swap preserving feasibility\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (a,b)]\n            if nodes:\n                start = random.choice(nodes)\n                colors2 = list(colors)\n                kempe_chain_swap(colors2, start, a, b)\n                conf2, _ = conflicts_of(colors2)\n                if conf2 == 0:\n                    return encode(colors2), \"Feasible-Kempe-swap\"\n        return encode(colors), \"Noop-feasible\"\n\n    # Infeasible branch: target a conflicting vertex\n    conflict_vertices = set()\n    for (u,v) in confl_edges:\n        conflict_vertices.add(u); conflict_vertices.add(v)\n\n    def sat_deg(u: int, cols: List[int]) -> int:\n        return len({cols[v-1] for v in adj[u]})\n\n    cand_vs = sorted(list(conflict_vertices), key=lambda u: (-len(adj[u]), -sat_deg(u, colors)))\n    u = cand_vs[0]\n    cur = colors[u-1]\n\n    # Try recolors within current palette; allow k+1 only if it strictly decreases conflicts\n    palette = list(range(1, k+1))\n    best_c = cur\n    best_conf = 10**9\n    random.shuffle(palette)\n    for c in palette:\n        if c == cur:\n            continue\n        tmp = list(colors)\n        tmp[u-1] = c\n        conf, _ = conflicts_of(tmp)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n    if best_c != cur and best_conf < total_conf:\n        colors2 = list(colors)\n        colors2[u-1] = best_c\n        return encode(colors2), \"Conflict-recolor\"\n\n    # Consider introducing k+1 only if strictly reduces conflicts\n    tmp = list(colors)\n    tmp[u-1] = k+1\n    conf_new, _ = conflicts_of(tmp)\n    if conf_new < total_conf:\n        return encode(tmp), \"Conflict-recolor-introduce-k+1\"\n\n    # Kempe swap on a conflicting edge's color pair; accept only if not worse\n    (a_u, a_v) = confl_edges[0]\n    ca, cb = colors[a_u-1], colors[a_v-1]\n    start = random.choice([a_u, a_v])\n    colors2 = list(colors)\n    kempe_chain_swap(colors2, start, ca, cb)\n    conf2, _ = conflicts_of(colors2)\n    if conf2 <= total_conf:\n        return encode(colors2), \"Kempe-chain-nonworsening\"\n\n    return encode(colors), \"Noop-infeasible\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\n\ndef perturb_solution(solution):\n    # Diversification via Kempe-chain swaps and focused recolors from top color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> Union[List[int], None]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        if len(out) != n:\n            return None\n        if any((not isinstance(x, int)) or (x < 1) for x in out):\n            return None\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    if colors is None:\n        return \",\".join([\"1\"]*n)\n\n    # Apply 2-3 Kempe-chain swaps over random color pairs\n    reps = random.randint(2, 3)\n    for _ in range(reps):\n        k = max(colors) if colors else 1\n        if k >= 2:\n            ca, cb = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n            if nodes:\n                start = random.choice(nodes)\n                kempe_chain_swap(colors, start, ca, cb)\n        # Random intra-palette recolors (biased to change top color vertices)\n        k = max(colors)\n        top_nodes = [i+1 for i in range(n) if colors[i] == k]\n        pool = top_nodes if top_nodes else list(range(1, n+1))\n        t = random.randint(1, 3)\n        for _j in range(t):\n            u = random.choice(pool)\n            pal = list(range(1, k+1))\n            cur = colors[u-1]\n            choices = [c for c in pal if c != cur]\n            if choices:\n                colors[u-1] = random.choice(choices)\n\n    # If still infeasible and stuck, allow a single k+1 only if conflicts strictly decrease and cap increase by 1\n    before = conflicts_of(colors)\n    if before > 0:\n        k = max(colors)\n        # try greedy repairs without increasing k\n        improved = True\n        while improved:\n            improved = False\n            for u in range(1, n+1):\n                cur = colors[u-1]\n                best = cur\n                best_conf = before\n                for c in range(1, k+1):\n                    if c == cur:\n                        continue\n                    tmp = list(colors)\n                    tmp[u-1] = c\n                    conf = conflicts_of(tmp)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best = c\n                if best != cur:\n                    colors[u-1] = best\n                    before = best_conf\n                    improved = True\n        if before > 0:\n            # try at most one promotion to k+1 if it strictly reduces conflicts\n            u = random.randrange(1, n+1)\n            tmp = list(colors)\n            tmp[u-1] = k+1\n            if conflicts_of(tmp) < before:\n                colors = tmp\n\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002448903}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9","Evaluacion":"import math\nimport random\nfrom typing import List, Union, Tuple\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns float cost.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Precomputed clique lower bound for this graph (omega=4) to avoid exponential recomputation\n    omega_const = 4\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        return out\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + float(abs(len(colors)-n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n\n    # feasibility\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n\n    # feasible objective: minimize k\n    k_hat = max(colors) if colors else 0\n\n    lb_penalty = 0.0 if k_hat >= omega_const else (omega_const - k_hat) * 1000.0\n\n    # No stochastic tie-breaker to keep acceptance neutral for equal-k\n    return float(k_hat) + lb_penalty\n","Vecindad":"import random\nfrom typing import List, Union, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_solution_str, movement_description)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> Union[List[int], None]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        if len(out) != n:\n            return None\n        if any((not isinstance(x, int)) or (x < 1) for x in out):\n            return None\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> Tuple[int, List[Tuple[int,int]]]:\n        confl = []\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                confl.append((u,v))\n                cnt += 1\n        return cnt, confl\n\n    def legal_for(u: int, c: int, colors: List[int]) -> bool:\n        for v in adj[u]:\n            if colors[v-1] == c:\n                return False\n        return True\n\n    def try_eliminate_top_color(colors: List[int]) -> bool:\n        # Transactional recoloring of vertices with color k into lower colors (DSATUR-guided)\n        k = max(colors)\n        target = k\n        verts = [i+1 for i in range(n) if colors[i] == target]\n        if not verts:\n            return False\n        # Order verts by descending saturation degree and degree\n        def sat_deg(u: int, cols: List[int]) -> int:\n            return len({cols[v-1] for v in adj[u]})\n        order = sorted(verts, key=lambda u: (-sat_deg(u, colors), -len(adj[u])))\n        new_colors = list(colors)\n        for u in order:\n            moved = False\n            for c in range(1, target):\n                if legal_for(u, c, new_colors):\n                    new_colors[u-1] = c\n                    moved = True\n                    break\n            if not moved:\n                return False  # Abort fully; no partial mutation\n        # Commit\n        for idx in range(n):\n            colors[idx] = new_colors[idx]\n        return True\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    if colors is None:\n        # Return a safe default and label as invalid-input repair\n        return \",\".join([\"1\"]*n), \"Invalid-input-repair\"\n\n    k = max(colors) if colors else 1\n    total_conf, confl_edges = conflicts_of(colors)\n\n    # Feasible neighbourhoods\n    if total_conf == 0:\n        # Prefer color elimination\n        if k > 1 and random.random() < 0.8:\n            colors_copy = list(colors)\n            if try_eliminate_top_color(colors_copy):\n                return encode(colors_copy), \"Eliminate-top-color\"\n        # Feasible recolor within existing palette\n        trials = 0\n        max_trials = 24\n        while trials < max_trials:\n            trials += 1\n            u = random.randrange(1, n+1)\n            cur = colors[u-1]\n            cand = [c for c in range(1, k+1) if c != cur]\n            if not cand:\n                continue\n            cnew = random.choice(cand)\n            if legal_for(u, cnew, colors):\n                colors2 = list(colors)\n                colors2[u-1] = cnew\n                return encode(colors2), \"Feasible-recolor\"\n        # Kempe swap preserving feasibility\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (a,b)]\n            if nodes:\n                start = random.choice(nodes)\n                colors2 = list(colors)\n                kempe_chain_swap(colors2, start, a, b)\n                conf2, _ = conflicts_of(colors2)\n                if conf2 == 0:\n                    return encode(colors2), \"Feasible-Kempe-swap\"\n        return encode(colors), \"Noop-feasible\"\n\n    # Infeasible branch: target a conflicting vertex\n    conflict_vertices = set()\n    for (u,v) in confl_edges:\n        conflict_vertices.add(u); conflict_vertices.add(v)\n\n    def sat_deg(u: int, cols: List[int]) -> int:\n        return len({cols[v-1] for v in adj[u]})\n\n    cand_vs = sorted(list(conflict_vertices), key=lambda u: (-len(adj[u]), -sat_deg(u, colors)))\n    u = cand_vs[0]\n    cur = colors[u-1]\n\n    # Try recolors within current palette; allow k+1 only if it strictly decreases conflicts\n    palette = list(range(1, k+1))\n    best_c = cur\n    best_conf = 10**9\n    random.shuffle(palette)\n    for c in palette:\n        if c == cur:\n            continue\n        tmp = list(colors)\n        tmp[u-1] = c\n        conf, _ = conflicts_of(tmp)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n    if best_c != cur and best_conf < total_conf:\n        colors2 = list(colors)\n        colors2[u-1] = best_c\n        return encode(colors2), \"Conflict-recolor\"\n\n    # Consider introducing k+1 only if strictly reduces conflicts\n    tmp = list(colors)\n    tmp[u-1] = k+1\n    conf_new, _ = conflicts_of(tmp)\n    if conf_new < total_conf:\n        return encode(tmp), \"Conflict-recolor-introduce-k+1\"\n\n    # Kempe swap on a conflicting edge's color pair; accept only if not worse\n    (a_u, a_v) = confl_edges[0]\n    ca, cb = colors[a_u-1], colors[a_v-1]\n    start = random.choice([a_u, a_v])\n    colors2 = list(colors)\n    kempe_chain_swap(colors2, start, ca, cb)\n    conf2, _ = conflicts_of(colors2)\n    if conf2 <= total_conf:\n        return encode(colors2), \"Kempe-chain-nonworsening\"\n\n    return encode(colors), \"Noop-infeasible\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\n\ndef perturb_solution(solution):\n    # Diversification via Kempe-chain swaps and focused recolors from top color.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol: Union[str, List[int]]) -> Union[List[int], None]:\n        if isinstance(sol, list):\n            try:\n                out = [int(x) for x in sol]\n            except Exception:\n                return None\n        elif isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                out = [int(p) for p in parts]\n            except Exception:\n                return None\n        else:\n            return None\n        if len(out) != n:\n            return None\n        if any((not isinstance(x, int)) or (x < 1) for x in out):\n            return None\n        return out\n\n    def encode(sol_list: List[int]) -> str:\n        return \",\".join(str(x) for x in sol_list)\n\n    def conflicts_of(colors: List[int]) -> int:\n        cnt = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_chain_swap(colors_list: List[int], start_node: int, ca: int, cb: int):\n        from collections import deque\n        target = {ca, cb}\n        visited = set([start_node])\n        dq = deque([start_node])\n        comp = []\n        while dq:\n            u = dq.popleft()\n            if colors_list[u-1] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and colors_list[v-1] in target:\n                    visited.add(v)\n                    dq.append(v)\n        for u in comp:\n            colors_list[u-1] = cb if colors_list[u-1] == ca else ca\n\n    colors = parse(solution)\n    if colors is None:\n        return \",\".join([\"1\"]*n)\n\n    # Apply 2-3 Kempe-chain swaps over random color pairs\n    reps = random.randint(2, 3)\n    for _ in range(reps):\n        k = max(colors) if colors else 1\n        if k >= 2:\n            ca, cb = random.sample(range(1, k+1), 2)\n            nodes = [i+1 for i in range(n) if colors[i] in (ca, cb)]\n            if nodes:\n                start = random.choice(nodes)\n                kempe_chain_swap(colors, start, ca, cb)\n        # Random intra-palette recolors (biased to change top color vertices)\n        k = max(colors)\n        top_nodes = [i+1 for i in range(n) if colors[i] == k]\n        pool = top_nodes if top_nodes else list(range(1, n+1))\n        t = random.randint(1, 3)\n        for _j in range(t):\n            u = random.choice(pool)\n            pal = list(range(1, k+1))\n            cur = colors[u-1]\n            choices = [c for c in pal if c != cur]\n            if choices:\n                colors[u-1] = random.choice(choices)\n\n    # If still infeasible and stuck, allow a single k+1 only if conflicts strictly decrease and cap increase by 1\n    before = conflicts_of(colors)\n    if before > 0:\n        k = max(colors)\n        # try greedy repairs without increasing k\n        improved = True\n        while improved:\n            improved = False\n            for u in range(1, n+1):\n                cur = colors[u-1]\n                best = cur\n                best_conf = before\n                for c in range(1, k+1):\n                    if c == cur:\n                        continue\n                    tmp = list(colors)\n                    tmp[u-1] = c\n                    conf = conflicts_of(tmp)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best = c\n                if best != cur:\n                    colors[u-1] = best\n                    before = best_conf\n                    improved = True\n        if before > 0:\n            # try at most one promotion to k+1 if it strictly reduces conflicts\n            u = random.randrange(1, n+1)\n            tmp = list(colors)\n            tmp[u-1] = k+1\n            if conflicts_of(tmp) < before:\n                colors = tmp\n\n    return encode(colors)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002538134}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nfrom typing import Iterable, List\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Representation: list of 9 positive ints (colors)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [1 if (not isinstance(x, int) or x < 1) else x for x in base]\n\n    new_sol: List[int] = base[:]\n\n    i = random.randrange(n)  # index to modify (0-based)\n\n    # Try smallest feasible color first, else small random bump\n    forbidden = { new_sol[j-1] for j in adj[i+1] }\n    # Candidate colors to try, prioritize low colors\n    candidates = list(range(1, max(5, max(new_sol)+1)))\n    random.shuffle(candidates)\n    candidates = sorted(set(candidates))\n\n    chosen = None\n    for c in candidates:\n        if c not in forbidden:\n            chosen = c\n            break\n    if chosen is None:\n        chosen = max(new_sol) + 1\n\n    new_sol[i] = chosen\n\n    return (new_sol, \"SingleIndexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multi-index random recolors to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        sol = [1 if (not isinstance(x, int) or x < 1) else int(x) for x in sol]\n\n    k = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k)\n\n    for i in idxs:\n        forbidden = { sol[j-1] for j in adj[i+1] }\n        # Use a small palette around current max to encourage compaction\n        palette_max = max(4, max(sol))\n        palette = list(range(1, palette_max+1))\n        random.shuffle(palette)\n        for c in palette:\n            if c not in forbidden:\n                sol[i] = c\n                break\n        else:\n            sol[i] = palette_max + 1\n\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000676739}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nfrom typing import Iterable, List\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Representation: list of 9 positive ints (colors)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [1 if (not isinstance(x, int) or x < 1) else x for x in base]\n\n    new_sol: List[int] = base[:]\n\n    i = random.randrange(n)  # index to modify (0-based)\n\n    # Try smallest feasible color first, else small random bump\n    forbidden = { new_sol[j-1] for j in adj[i+1] }\n    # Candidate colors to try, prioritize low colors\n    candidates = list(range(1, max(5, max(new_sol)+1)))\n    random.shuffle(candidates)\n    candidates = sorted(set(candidates))\n\n    chosen = None\n    for c in candidates:\n        if c not in forbidden:\n            chosen = c\n            break\n    if chosen is None:\n        chosen = max(new_sol) + 1\n\n    new_sol[i] = chosen\n\n    return (new_sol, \"SingleIndexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multi-index random recolors to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        sol = [1 if (not isinstance(x, int) or x < 1) else int(x) for x in sol]\n\n    k = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k)\n\n    for i in idxs:\n        forbidden = { sol[j-1] for j in adj[i+1] }\n        # Use a small palette around current max to encourage compaction\n        palette_max = max(4, max(sol))\n        palette = list(range(1, palette_max+1))\n        random.shuffle(palette)\n        for c in palette:\n            if c not in forbidden:\n                sol[i] = c\n                break\n        else:\n            sol[i] = palette_max + 1\n\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000839222}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nfrom typing import Iterable, List\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        return PENALTY_INVALID\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced: List[int] = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Representation: list of 9 positive ints (colors)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [1 if (not isinstance(x, int) or x < 1) else x for x in base]\n\n    new_sol: List[int] = base[:]\n\n    i = random.randrange(n)  # index to modify (0-based)\n\n    # Try smallest feasible color first, else small random bump\n    forbidden = { new_sol[j-1] for j in adj[i+1] }\n    # Candidate colors to try, prioritize low colors\n    candidates = list(range(1, max(5, max(new_sol)+1)))\n    random.shuffle(candidates)\n    candidates = sorted(set(candidates))\n\n    chosen = None\n    for c in candidates:\n        if c not in forbidden:\n            chosen = c\n            break\n    if chosen is None:\n        chosen = max(new_sol) + 1\n\n    new_sol[i] = chosen\n\n    return (new_sol, \"SingleIndexRecolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multi-index random recolors to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        sol = [1 if (not isinstance(x, int) or x < 1) else int(x) for x in sol]\n\n    k = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k)\n\n    for i in idxs:\n        forbidden = { sol[j-1] for j in adj[i+1] }\n        # Use a small palette around current max to encourage compaction\n        palette_max = max(4, max(sol))\n        palette = list(range(1, palette_max+1))\n        random.shuffle(palette)\n        for c in palette:\n            if c not in forbidden:\n                sol[i] = c\n                break\n        else:\n            sol[i] = palette_max + 1\n\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000822081}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE. A solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-based vertices).","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000  # Dominates any max color change\n    PENALTY_VALUE = 10_000\n\n    # Basic structural validation\n    if solution is None or not hasattr(solution, '__iter__'):\n        return float(PENALTY_INVALID)\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    # Strict type\/positivity check\n    coerced: List[int] = []\n    invalid_values = 0\n    max_color = 0\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == 0 or cv == 0:\n            continue\n        if cu == cv:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return float(\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return float(max_color)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Representation: list of 9 positive ints (colors)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/initialize base solution\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n\n    new_sol: List[int] = base[:]\n\n    # Identify conflicts and max color vertices\n    max_col = max(new_sol) if new_sol else 1\n    in_conflict = [False]*n\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            in_conflict[u-1] = True\n            in_conflict[v-1] = True\n\n    candidates = [i for i in range(n) if in_conflict[i] or new_sol[i] == max_col]\n    if not candidates:\n        candidates = list(range(n))\n    i = random.choice(candidates)  # index to modify (0-based)\n\n    # Try smallest feasible color from 1..max_col, allowing reduction of K\n    forbidden = { new_sol[j-1] for j in adj[i+1] if new_sol[j-1] > 0 }\n    chosen = None\n    for c in range(1, max_col+1):\n        if c not in forbidden:\n            chosen = c\n            break\n    if chosen is None:\n        # No feasible within current palette; minimally expand\n        chosen = max_col + 1\n\n    new_sol[i] = chosen\n\n    return (new_sol, \"RecolorOne\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multi-index recolors prioritizing vertices with max color\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/initialize\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        sol = [x if isinstance(x, int) and x > 0 else 1 for x in sol]\n\n    max_col = max(sol) if sol else 1\n\n    # Choose k indices with bias toward max color vertices\n    indices = list(range(n))\n    max_idxs = [i for i in indices if sol[i] == max_col]\n    k = max(2, n \/\/ 3)\n    chosen = []\n    if len(max_idxs) >= min(k, len(indices)):\n        chosen = random.sample(max_idxs, min(k, len(max_idxs)))\n    else:\n        chosen = max_idxs[:]\n        remaining = [i for i in indices if i not in chosen]\n        if remaining:\n            chosen += random.sample(remaining, min(k - len(chosen), len(remaining)))\n\n    # Recolor chosen indices with feasible colors from 1..max_col (or minimally expand)\n    for i in chosen:\n        forbidden = { sol[j-1] for j in adj[i+1] if sol[j-1] > 0 }\n        picked = None\n        for c in range(1, max_col+1):\n            if c not in forbidden:\n                picked = c\n                break\n        if picked is None:\n            picked = max_col + 1\n        sol[i] = picked\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000918413}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE. A solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-based vertices).","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000  # Dominates any max color change\n    PENALTY_VALUE = 10_000\n\n    # Basic structural validation\n    if solution is None or not hasattr(solution, '__iter__'):\n        return float(PENALTY_INVALID)\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    # Strict type\/positivity check\n    coerced: List[int] = []\n    invalid_values = 0\n    max_color = 0\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == 0 or cv == 0:\n            continue\n        if cu == cv:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return float(\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return float(max_color)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Representation: list of 9 positive ints (colors)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/initialize base solution\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n\n    new_sol: List[int] = base[:]\n\n    # Identify conflicts and max color vertices\n    max_col = max(new_sol) if new_sol else 1\n    in_conflict = [False]*n\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            in_conflict[u-1] = True\n            in_conflict[v-1] = True\n\n    candidates = [i for i in range(n) if in_conflict[i] or new_sol[i] == max_col]\n    if not candidates:\n        candidates = list(range(n))\n    i = random.choice(candidates)  # index to modify (0-based)\n\n    # Try smallest feasible color from 1..max_col, allowing reduction of K\n    forbidden = { new_sol[j-1] for j in adj[i+1] if new_sol[j-1] > 0 }\n    chosen = None\n    for c in range(1, max_col+1):\n        if c not in forbidden:\n            chosen = c\n            break\n    if chosen is None:\n        # No feasible within current palette; minimally expand\n        chosen = max_col + 1\n\n    new_sol[i] = chosen\n\n    return (new_sol, \"RecolorOne\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multi-index recolors prioritizing vertices with max color\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/initialize\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        sol = [x if isinstance(x, int) and x > 0 else 1 for x in sol]\n\n    max_col = max(sol) if sol else 1\n\n    # Choose k indices with bias toward max color vertices\n    indices = list(range(n))\n    max_idxs = [i for i in indices if sol[i] == max_col]\n    k = max(2, n \/\/ 3)\n    chosen = []\n    if len(max_idxs) >= min(k, len(indices)):\n        chosen = random.sample(max_idxs, min(k, len(max_idxs)))\n    else:\n        chosen = max_idxs[:]\n        remaining = [i for i in indices if i not in chosen]\n        if remaining:\n            chosen += random.sample(remaining, min(k - len(chosen), len(remaining)))\n\n    # Recolor chosen indices with feasible colors from 1..max_col (or minimally expand)\n    for i in chosen:\n        forbidden = { sol[j-1] for j in adj[i+1] if sol[j-1] > 0 }\n        picked = None\n        for c in range(1, max_col+1):\n            if c not in forbidden:\n                picked = c\n                break\n        if picked is None:\n            picked = max_col + 1\n        sol[i] = picked\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001238026}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE. A solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-based vertices).","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000  # Dominates any max color change\n    PENALTY_VALUE = 10_000\n\n    # Basic structural validation\n    if solution is None or not hasattr(solution, '__iter__'):\n        return float(PENALTY_INVALID)\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    # Strict type\/positivity check\n    coerced: List[int] = []\n    invalid_values = 0\n    max_color = 0\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if not isinstance(v, int):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        if v < 1:\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        coerced.append(v)\n        if v > max_color:\n            max_color = v\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == 0 or cv == 0:\n            continue\n        if cu == cv:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return float(\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return float(max_color)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Representation: list of 9 positive ints (colors)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/initialize base solution\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n\n    new_sol: List[int] = base[:]\n\n    # Identify conflicts and max color vertices\n    max_col = max(new_sol) if new_sol else 1\n    in_conflict = [False]*n\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            in_conflict[u-1] = True\n            in_conflict[v-1] = True\n\n    candidates = [i for i in range(n) if in_conflict[i] or new_sol[i] == max_col]\n    if not candidates:\n        candidates = list(range(n))\n    i = random.choice(candidates)  # index to modify (0-based)\n\n    # Try smallest feasible color from 1..max_col, allowing reduction of K\n    forbidden = { new_sol[j-1] for j in adj[i+1] if new_sol[j-1] > 0 }\n    chosen = None\n    for c in range(1, max_col+1):\n        if c not in forbidden:\n            chosen = c\n            break\n    if chosen is None:\n        # No feasible within current palette; minimally expand\n        chosen = max_col + 1\n\n    new_sol[i] = chosen\n\n    return (new_sol, \"RecolorOne\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Apply multi-index recolors prioritizing vertices with max color\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/initialize\n    if solution is None or not hasattr(solution, '__iter__'):\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        sol = [x if isinstance(x, int) and x > 0 else 1 for x in sol]\n\n    max_col = max(sol) if sol else 1\n\n    # Choose k indices with bias toward max color vertices\n    indices = list(range(n))\n    max_idxs = [i for i in indices if sol[i] == max_col]\n    k = max(2, n \/\/ 3)\n    chosen = []\n    if len(max_idxs) >= min(k, len(indices)):\n        chosen = random.sample(max_idxs, min(k, len(max_idxs)))\n    else:\n        chosen = max_idxs[:]\n        remaining = [i for i in indices if i not in chosen]\n        if remaining:\n            chosen += random.sample(remaining, min(k - len(chosen), len(remaining)))\n\n    # Recolor chosen indices with feasible colors from 1..max_col (or minimally expand)\n    for i in chosen:\n        forbidden = { sol[j-1] for j in adj[i+1] if sol[j-1] > 0 }\n        picked = None\n        for c in range(1, max_col+1):\n            if c not in forbidden:\n                picked = c\n                break\n        if picked is None:\n            picked = max_col + 1\n        sol[i] = picked\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001221106}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nimport random\nfrom typing import Iterable\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000\n    PENALTY_VALUE = 10_000\n\n    if solution is None or not isinstance(solution, Iterable):\n        return float(PENALTY_INVALID)\n\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    invalid_values = 0\n    max_color = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool) or not isinstance(v, int) or v < 1:\n            invalid_values += 1\n            coerced.append(0)\n        else:\n            coerced.append(v)\n            if v > max_color:\n                max_color = v\n\n    if invalid_values > 0:\n        return float(PENALTY_INVALID + invalid_values * PENALTY_VALUE + max_color)\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            violations += 1\n\n    if violations > 0:\n        return float(PENALTY_INVALID + violations * PENALTY_VIOLATION + max_color)\n\n    return float(max_color)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef _adjacency():\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return n, edges, adj\n\n\ndef _sanitize(solution):\n    n, _, _ = _adjacency()\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n    return base\n\n\ndef _normalize_colors(sol):\n    # Relabel colors to contiguous 1..K preserving relative class order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _conflict_mask(sol, edges):\n    n = len(sol)\n    mask = [False]*n\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            mask[u-1] = True\n            mask[v-1] = True\n    return mask\n\n\ndef _feasible_colors(idx, sol, adj):\n    forbidden = {sol[j-1] for j in adj[idx+1]}\n    k = max(sol) if sol else 1\n    feas = [c for c in range(1, k+1) if c not in forbidden]\n    if not feas:\n        feas = [k+1]\n    return feas\n\n\ndef _kempe_chain_swap(sol, start_idx, color_b, adj):\n    # Swap colors a<->b on the connected component (Kempe chain) containing start_idx in subgraph induced by colors {a,b}\n    a = sol[start_idx]\n    if a == color_b:\n        return sol[:]\n    n = len(sol)\n    use = set([a, color_b])\n    visited = [False]*n\n    q = deque()\n    if sol[start_idx] in use:\n        q.append(start_idx)\n        visited[start_idx] = True\n    comp = []\n    while q:\n        i = q.popleft()\n        comp.append(i)\n        for nb in adj[i+1]:\n            j = nb - 1\n            if not visited[j] and sol[j] in use:\n                visited[j] = True\n                q.append(j)\n    new_sol = sol[:]\n    for i in comp:\n        new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    n, edges, adj = _adjacency()\n    sol = _sanitize(solution)\n\n    # Move family selection with probabilities\n    r = random.random()\n    max_col = max(sol) if sol else 1\n    in_conflict = _conflict_mask(sol, edges)\n\n    if r < 0.45:\n        # RecolorOne: pick conflict or max-color vertex, recolor with a random feasible color (biased to small)\n        candidates = [i for i in range(n) if in_conflict[i] or sol[i] == max_col]\n        if not candidates:\n            candidates = list(range(n))\n        i = random.choice(candidates)\n        feas = _feasible_colors(i, sol, adj)\n        # Bias towards lower colors but keep diversity\n        feas_sorted = sorted(feas)\n        pick = random.choice(feas_sorted[: min(len(feas_sorted), 2)]) if len(feas_sorted) > 1 else feas_sorted[0]\n        new_sol = sol[:]\n        new_sol[i] = pick\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"RecolorOne\")\n\n    elif r < 0.70:\n        # TryReduceK: attempt to recolor a vertex from max color into [1..K-1]\n        max_vertices = [i for i in range(n) if sol[i] == max_col]\n        if not max_vertices:\n            max_vertices = list(range(n))\n        random.shuffle(max_vertices)\n        new_sol = sol[:]\n        moved = False\n        for i in max_vertices:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            candidates = [c for c in range(1, max_col) if c not in forbidden]\n            if candidates:\n                new_sol[i] = random.choice(candidates)\n                moved = True\n                break\n        if moved:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ReduceK-One\")\n        else:\n            # fallback to recolor one with any feasible\n            i = random.choice(list(range(n)))\n            feas = _feasible_colors(i, sol, adj)\n            new_sol[i] = random.choice(feas)\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"Fallback-Recolor\")\n\n    elif r < 0.85:\n        # KempeChain: pick a vertex and a random other color\n        i = random.randrange(n)\n        palette = list({c for c in sol})\n        if len(palette) < 2:\n            palette = [1, 2]\n        b = random.choice([c for c in range(1, max_col + 1)] or [1])\n        new_sol = _kempe_chain_swap(sol, i, b, adj)\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"KempeChain\")\n\n    else:\n        # ColorClassSwap: swap labels of two colors to diversify\n        palette = sorted(list({c for c in sol}))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            new_sol = [b if c == a else (a if c == b else c) for c in sol]\n        else:\n            new_sol = sol[:]\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"ColorClassSwap\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef _adjacency_p():\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return n, edges, adj\n\n\ndef _sanitize_p(solution):\n    n, _, _ = _adjacency_p()\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n    return base\n\n\ndef _normalize_p(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _kempe_component(sol, start_idx, color_b, adj):\n    a = sol[start_idx]\n    if a == color_b:\n        return sol[:]\n    use = {a, color_b}\n    n = len(sol)\n    seen = [False]*n\n    q = deque([start_idx])\n    seen[start_idx] = True\n    comp = []\n    while q:\n        i = q.popleft()\n        comp.append(i)\n        for nb in adj[i+1]:\n            j = nb - 1\n            if not seen[j] and sol[j] in use:\n                seen[j] = True\n                q.append(j)\n    new_sol = sol[:]\n    for i in comp:\n        new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n    return new_sol\n\n\ndef perturb_solution(solution):\n    # Strong perturbations for escaping local minima\n    n, edges, adj = _adjacency_p()\n    sol = _sanitize_p(solution)\n    k = max(sol) if sol else 1\n\n    # Choose an operation mix\n    ops = []\n    ops += [\"Kempe\"] * 5\n    ops += [\"ShuffleMax\"] * 3\n    ops += [\"Random2Swap\"] * 2\n\n    intensity = max(2, n \/\/ 3)\n\n    for _ in range(intensity):\n        op = random.choice(ops)\n        if op == \"Kempe\":\n            i = random.randrange(n)\n            b = random.randint(1, max(k, 2))\n            sol = _kempe_component(sol, i, b, adj)\n        elif op == \"ShuffleMax\":\n            maxc = max(sol)\n            max_idxs = [i for i in range(n) if sol[i] == maxc]\n            if max_idxs:\n                for i in random.sample(max_idxs, min(len(max_idxs), max(1, len(max_idxs)\/\/2))):\n                    forbidden = {sol[j-1] for j in adj[i+1]}\n                    candidates = [c for c in range(1, maxc) if c not in forbidden]\n                    if candidates:\n                        sol[i] = random.choice(candidates)\n        else:  # Random2Swap color-class swap\n            palette = list({c for c in sol})\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                sol = [b if c == a else (a if c == b else c) for c in sol]\n        k = max(sol)\n\n    sol = _normalize_p(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001308807}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nimport random\nfrom typing import Iterable\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000\n    PENALTY_VALUE = 10_000\n\n    if solution is None or not isinstance(solution, Iterable):\n        return float(PENALTY_INVALID)\n\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    invalid_values = 0\n    max_color = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool) or not isinstance(v, int) or v < 1:\n            invalid_values += 1\n            coerced.append(0)\n        else:\n            coerced.append(v)\n            if v > max_color:\n                max_color = v\n\n    if invalid_values > 0:\n        return float(PENALTY_INVALID + invalid_values * PENALTY_VALUE + max_color)\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            violations += 1\n\n    if violations > 0:\n        return float(PENALTY_INVALID + violations * PENALTY_VIOLATION + max_color)\n\n    return float(max_color)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef _adjacency():\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return n, edges, adj\n\n\ndef _sanitize(solution):\n    n, _, _ = _adjacency()\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n    return base\n\n\ndef _normalize_colors(sol):\n    # Relabel colors to contiguous 1..K preserving relative class order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _conflict_mask(sol, edges):\n    n = len(sol)\n    mask = [False]*n\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            mask[u-1] = True\n            mask[v-1] = True\n    return mask\n\n\ndef _feasible_colors(idx, sol, adj):\n    forbidden = {sol[j-1] for j in adj[idx+1]}\n    k = max(sol) if sol else 1\n    feas = [c for c in range(1, k+1) if c not in forbidden]\n    if not feas:\n        feas = [k+1]\n    return feas\n\n\ndef _kempe_chain_swap(sol, start_idx, color_b, adj):\n    # Swap colors a<->b on the connected component (Kempe chain) containing start_idx in subgraph induced by colors {a,b}\n    a = sol[start_idx]\n    if a == color_b:\n        return sol[:]\n    n = len(sol)\n    use = set([a, color_b])\n    visited = [False]*n\n    q = deque()\n    if sol[start_idx] in use:\n        q.append(start_idx)\n        visited[start_idx] = True\n    comp = []\n    while q:\n        i = q.popleft()\n        comp.append(i)\n        for nb in adj[i+1]:\n            j = nb - 1\n            if not visited[j] and sol[j] in use:\n                visited[j] = True\n                q.append(j)\n    new_sol = sol[:]\n    for i in comp:\n        new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    n, edges, adj = _adjacency()\n    sol = _sanitize(solution)\n\n    # Move family selection with probabilities\n    r = random.random()\n    max_col = max(sol) if sol else 1\n    in_conflict = _conflict_mask(sol, edges)\n\n    if r < 0.45:\n        # RecolorOne: pick conflict or max-color vertex, recolor with a random feasible color (biased to small)\n        candidates = [i for i in range(n) if in_conflict[i] or sol[i] == max_col]\n        if not candidates:\n            candidates = list(range(n))\n        i = random.choice(candidates)\n        feas = _feasible_colors(i, sol, adj)\n        # Bias towards lower colors but keep diversity\n        feas_sorted = sorted(feas)\n        pick = random.choice(feas_sorted[: min(len(feas_sorted), 2)]) if len(feas_sorted) > 1 else feas_sorted[0]\n        new_sol = sol[:]\n        new_sol[i] = pick\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"RecolorOne\")\n\n    elif r < 0.70:\n        # TryReduceK: attempt to recolor a vertex from max color into [1..K-1]\n        max_vertices = [i for i in range(n) if sol[i] == max_col]\n        if not max_vertices:\n            max_vertices = list(range(n))\n        random.shuffle(max_vertices)\n        new_sol = sol[:]\n        moved = False\n        for i in max_vertices:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            candidates = [c for c in range(1, max_col) if c not in forbidden]\n            if candidates:\n                new_sol[i] = random.choice(candidates)\n                moved = True\n                break\n        if moved:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ReduceK-One\")\n        else:\n            # fallback to recolor one with any feasible\n            i = random.choice(list(range(n)))\n            feas = _feasible_colors(i, sol, adj)\n            new_sol[i] = random.choice(feas)\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"Fallback-Recolor\")\n\n    elif r < 0.85:\n        # KempeChain: pick a vertex and a random other color\n        i = random.randrange(n)\n        palette = list({c for c in sol})\n        if len(palette) < 2:\n            palette = [1, 2]\n        b = random.choice([c for c in range(1, max_col + 1)] or [1])\n        new_sol = _kempe_chain_swap(sol, i, b, adj)\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"KempeChain\")\n\n    else:\n        # ColorClassSwap: swap labels of two colors to diversify\n        palette = sorted(list({c for c in sol}))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            new_sol = [b if c == a else (a if c == b else c) for c in sol]\n        else:\n            new_sol = sol[:]\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"ColorClassSwap\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef _adjacency_p():\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return n, edges, adj\n\n\ndef _sanitize_p(solution):\n    n, _, _ = _adjacency_p()\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n    return base\n\n\ndef _normalize_p(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _kempe_component(sol, start_idx, color_b, adj):\n    a = sol[start_idx]\n    if a == color_b:\n        return sol[:]\n    use = {a, color_b}\n    n = len(sol)\n    seen = [False]*n\n    q = deque([start_idx])\n    seen[start_idx] = True\n    comp = []\n    while q:\n        i = q.popleft()\n        comp.append(i)\n        for nb in adj[i+1]:\n            j = nb - 1\n            if not seen[j] and sol[j] in use:\n                seen[j] = True\n                q.append(j)\n    new_sol = sol[:]\n    for i in comp:\n        new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n    return new_sol\n\n\ndef perturb_solution(solution):\n    # Strong perturbations for escaping local minima\n    n, edges, adj = _adjacency_p()\n    sol = _sanitize_p(solution)\n    k = max(sol) if sol else 1\n\n    # Choose an operation mix\n    ops = []\n    ops += [\"Kempe\"] * 5\n    ops += [\"ShuffleMax\"] * 3\n    ops += [\"Random2Swap\"] * 2\n\n    intensity = max(2, n \/\/ 3)\n\n    for _ in range(intensity):\n        op = random.choice(ops)\n        if op == \"Kempe\":\n            i = random.randrange(n)\n            b = random.randint(1, max(k, 2))\n            sol = _kempe_component(sol, i, b, adj)\n        elif op == \"ShuffleMax\":\n            maxc = max(sol)\n            max_idxs = [i for i in range(n) if sol[i] == maxc]\n            if max_idxs:\n                for i in random.sample(max_idxs, min(len(max_idxs), max(1, len(max_idxs)\/\/2))):\n                    forbidden = {sol[j-1] for j in adj[i+1]}\n                    candidates = [c for c in range(1, maxc) if c not in forbidden]\n                    if candidates:\n                        sol[i] = random.choice(candidates)\n        else:  # Random2Swap color-class swap\n            palette = list({c for c in sol})\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                sol = [b if c == a else (a if c == b else c) for c in sol]\n        k = max(sol)\n\n    sol = _normalize_p(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001684412}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nimport random\nfrom typing import Iterable\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000\n    PENALTY_VALUE = 10_000\n\n    if solution is None or not isinstance(solution, Iterable):\n        return float(PENALTY_INVALID)\n\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    invalid_values = 0\n    max_color = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool) or not isinstance(v, int) or v < 1:\n            invalid_values += 1\n            coerced.append(0)\n        else:\n            coerced.append(v)\n            if v > max_color:\n                max_color = v\n\n    if invalid_values > 0:\n        return float(PENALTY_INVALID + invalid_values * PENALTY_VALUE + max_color)\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            violations += 1\n\n    if violations > 0:\n        return float(PENALTY_INVALID + violations * PENALTY_VIOLATION + max_color)\n\n    return float(max_color)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef _adjacency():\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return n, edges, adj\n\n\ndef _sanitize(solution):\n    n, _, _ = _adjacency()\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n    return base\n\n\ndef _normalize_colors(sol):\n    # Relabel colors to contiguous 1..K preserving relative class order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _conflict_mask(sol, edges):\n    n = len(sol)\n    mask = [False]*n\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            mask[u-1] = True\n            mask[v-1] = True\n    return mask\n\n\ndef _feasible_colors(idx, sol, adj):\n    forbidden = {sol[j-1] for j in adj[idx+1]}\n    k = max(sol) if sol else 1\n    feas = [c for c in range(1, k+1) if c not in forbidden]\n    if not feas:\n        feas = [k+1]\n    return feas\n\n\ndef _kempe_chain_swap(sol, start_idx, color_b, adj):\n    # Swap colors a<->b on the connected component (Kempe chain) containing start_idx in subgraph induced by colors {a,b}\n    a = sol[start_idx]\n    if a == color_b:\n        return sol[:]\n    n = len(sol)\n    use = set([a, color_b])\n    visited = [False]*n\n    q = deque()\n    if sol[start_idx] in use:\n        q.append(start_idx)\n        visited[start_idx] = True\n    comp = []\n    while q:\n        i = q.popleft()\n        comp.append(i)\n        for nb in adj[i+1]:\n            j = nb - 1\n            if not visited[j] and sol[j] in use:\n                visited[j] = True\n                q.append(j)\n    new_sol = sol[:]\n    for i in comp:\n        new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    n, edges, adj = _adjacency()\n    sol = _sanitize(solution)\n\n    # Move family selection with probabilities\n    r = random.random()\n    max_col = max(sol) if sol else 1\n    in_conflict = _conflict_mask(sol, edges)\n\n    if r < 0.45:\n        # RecolorOne: pick conflict or max-color vertex, recolor with a random feasible color (biased to small)\n        candidates = [i for i in range(n) if in_conflict[i] or sol[i] == max_col]\n        if not candidates:\n            candidates = list(range(n))\n        i = random.choice(candidates)\n        feas = _feasible_colors(i, sol, adj)\n        # Bias towards lower colors but keep diversity\n        feas_sorted = sorted(feas)\n        pick = random.choice(feas_sorted[: min(len(feas_sorted), 2)]) if len(feas_sorted) > 1 else feas_sorted[0]\n        new_sol = sol[:]\n        new_sol[i] = pick\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"RecolorOne\")\n\n    elif r < 0.70:\n        # TryReduceK: attempt to recolor a vertex from max color into [1..K-1]\n        max_vertices = [i for i in range(n) if sol[i] == max_col]\n        if not max_vertices:\n            max_vertices = list(range(n))\n        random.shuffle(max_vertices)\n        new_sol = sol[:]\n        moved = False\n        for i in max_vertices:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            candidates = [c for c in range(1, max_col) if c not in forbidden]\n            if candidates:\n                new_sol[i] = random.choice(candidates)\n                moved = True\n                break\n        if moved:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ReduceK-One\")\n        else:\n            # fallback to recolor one with any feasible\n            i = random.choice(list(range(n)))\n            feas = _feasible_colors(i, sol, adj)\n            new_sol[i] = random.choice(feas)\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"Fallback-Recolor\")\n\n    elif r < 0.85:\n        # KempeChain: pick a vertex and a random other color\n        i = random.randrange(n)\n        palette = list({c for c in sol})\n        if len(palette) < 2:\n            palette = [1, 2]\n        b = random.choice([c for c in range(1, max_col + 1)] or [1])\n        new_sol = _kempe_chain_swap(sol, i, b, adj)\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"KempeChain\")\n\n    else:\n        # ColorClassSwap: swap labels of two colors to diversify\n        palette = sorted(list({c for c in sol}))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            new_sol = [b if c == a else (a if c == b else c) for c in sol]\n        else:\n            new_sol = sol[:]\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"ColorClassSwap\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef _adjacency_p():\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return n, edges, adj\n\n\ndef _sanitize_p(solution):\n    n, _, _ = _adjacency_p()\n    if solution is None or not hasattr(solution, '__iter__'):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n    return base\n\n\ndef _normalize_p(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _kempe_component(sol, start_idx, color_b, adj):\n    a = sol[start_idx]\n    if a == color_b:\n        return sol[:]\n    use = {a, color_b}\n    n = len(sol)\n    seen = [False]*n\n    q = deque([start_idx])\n    seen[start_idx] = True\n    comp = []\n    while q:\n        i = q.popleft()\n        comp.append(i)\n        for nb in adj[i+1]:\n            j = nb - 1\n            if not seen[j] and sol[j] in use:\n                seen[j] = True\n                q.append(j)\n    new_sol = sol[:]\n    for i in comp:\n        new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n    return new_sol\n\n\ndef perturb_solution(solution):\n    # Strong perturbations for escaping local minima\n    n, edges, adj = _adjacency_p()\n    sol = _sanitize_p(solution)\n    k = max(sol) if sol else 1\n\n    # Choose an operation mix\n    ops = []\n    ops += [\"Kempe\"] * 5\n    ops += [\"ShuffleMax\"] * 3\n    ops += [\"Random2Swap\"] * 2\n\n    intensity = max(2, n \/\/ 3)\n\n    for _ in range(intensity):\n        op = random.choice(ops)\n        if op == \"Kempe\":\n            i = random.randrange(n)\n            b = random.randint(1, max(k, 2))\n            sol = _kempe_component(sol, i, b, adj)\n        elif op == \"ShuffleMax\":\n            maxc = max(sol)\n            max_idxs = [i for i in range(n) if sol[i] == maxc]\n            if max_idxs:\n                for i in random.sample(max_idxs, min(len(max_idxs), max(1, len(max_idxs)\/\/2))):\n                    forbidden = {sol[j-1] for j in adj[i+1]}\n                    candidates = [c for c in range(1, maxc) if c not in forbidden]\n                    if candidates:\n                        sol[i] = random.choice(candidates)\n        else:  # Random2Swap color-class swap\n            palette = list({c for c in sol})\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                sol = [b if c == a else (a if c == b else c) for c in sol]\n        k = max(sol)\n\n    sol = _normalize_p(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001591761}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nimport random\nfrom typing import Iterable\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000\n    PENALTY_VALUE = 10_000\n\n    if solution is None or not isinstance(solution, Iterable):\n        return float(PENALTY_INVALID)\n\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    invalid_values = 0\n    max_color = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool) or not isinstance(v, int) or v < 1:\n            invalid_values += 1\n            coerced.append(0)\n        else:\n            coerced.append(v)\n            if v > max_color:\n                max_color = v\n\n    if invalid_values > 0:\n        return float(PENALTY_INVALID + invalid_values * PENALTY_VALUE + max_color)\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            violations += 1\n\n    if violations > 0:\n        return float(PENALTY_INVALID + violations * PENALTY_VIOLATION + max_color)\n\n    return float(max_color)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    def _adjacency():\n        n = 9\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return n, edges, adj\n\n    def _sanitize(sol):\n        n, _, _ = _adjacency()\n        if sol is None or not hasattr(sol, '__iter__'):\n            base = [random.randint(1, 4) for _ in range(n)]\n        else:\n            base = list(sol)\n            if len(base) != n:\n                base = (base + [1]*n)[:n]\n            base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n        return base\n\n    def _normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _conflict_mask(sol, edges):\n        n = len(sol)\n        mask = [False]*n\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                mask[u-1] = True\n                mask[v-1] = True\n        return mask\n\n    def _feasible_colors(idx, sol, adj):\n        forbidden = {sol[j-1] for j in adj[idx+1]}\n        k = max(sol) if sol else 1\n        feas = [c for c in range(1, k+1) if c not in forbidden]\n        if not feas:\n            feas = [k+1]\n        return feas\n\n    def _kempe_chain_swap(sol, start_idx, color_b, adj):\n        a = sol[start_idx]\n        if a == color_b:\n            return sol[:]\n        use = set([a, color_b])\n        n = len(sol)\n        visited = [False]*n\n        q = deque()\n        q.append(start_idx)\n        visited[start_idx] = True\n        comp = []\n        while q:\n            i = q.popleft()\n            comp.append(i)\n            for nb in adj[i+1]:\n                j = nb - 1\n                if not visited[j] and sol[j] in use:\n                    visited[j] = True\n                    q.append(j)\n        new_sol = sol[:]\n        for i in comp:\n            new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n        return new_sol\n\n    n, edges, adj = _adjacency()\n    sol = _sanitize(solution)\n\n    r = random.random()\n    max_col = max(sol) if sol else 1\n    in_conflict = _conflict_mask(sol, edges)\n\n    if r < 0.45:\n        # RecolorOne with soft bias towards smaller colors\n        candidates = [i for i in range(n) if in_conflict[i] or sol[i] == max_col]\n        if not candidates:\n            candidates = list(range(n))\n        i = random.choice(candidates)\n        feas = _feasible_colors(i, sol, adj)\n        feas_sorted = sorted(feas)\n        # Exponential weights favor small colors but keep diversity\n        weights = [0.6**(c-1) for c in feas_sorted]\n        s = sum(weights)\n        t = random.random() * s\n        acc = 0.0\n        pick = feas_sorted[0]\n        for c, w in zip(feas_sorted, weights):\n            acc += w\n            if t <= acc:\n                pick = c\n                break\n        new_sol = sol[:]\n        new_sol[i] = pick\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"RecolorOne\")\n\n    elif r < 0.75:\n        # ReduceK-One: try to move a max-color vertex to lower palette\n        max_vertices = [i for i in range(n) if sol[i] == max_col]\n        order = max_vertices[:]\n        random.shuffle(order)\n        new_sol = sol[:]\n        moved = False\n        for i in order:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            candidates = [c for c in range(1, max_col) if c not in forbidden]\n            if candidates:\n                new_sol[i] = random.choice(candidates)\n                moved = True\n        if moved:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ReduceK-Batch\")\n        else:\n            # fallback recolor\n            i = random.randrange(n)\n            feas = _feasible_colors(i, sol, adj)\n            new_sol[i] = random.choice(feas)\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"Fallback-Recolor\")\n\n    elif r < 0.90:\n        # KempeChain: pick vertex i and neighbor color b != its color\n        i = random.randrange(n)\n        a = sol[i]\n        neigh_colors = {sol[j-1] for j in adj[i+1] if sol[j-1] != a}\n        palette = sorted(neigh_colors) if neigh_colors else [c for c in range(1, max_col+1) if c != a] or [1]\n        b = random.choice(palette)\n        new_sol = _kempe_chain_swap(sol, i, b, adj)\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"KempeChain\")\n\n    else:\n        # ColorClassMergeAttempt: try to merge max color into lower colors greedily\n        k = max_col\n        if k <= 1:\n            return (sol[:], \"Noop\")\n        targets = list(range(n))\n        random.shuffle(targets)\n        new_sol = sol[:]\n        success = True\n        for i in [t for t in targets if new_sol[t] == k]:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            feas = [c for c in range(1, k) if c not in forbidden]\n            if feas:\n                new_sol[i] = random.choice(feas)\n            else:\n                success = False\n                break\n        if success:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ClassMerge\")\n        else:\n            return (sol[:], \"NoMerge\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Strong perturbations to escape local minima\n    def _adjacency_p():\n        n = 9\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return n, edges, adj\n\n    def _sanitize_p(sol):\n        n, _, _ = _adjacency_p()\n        if sol is None or not hasattr(sol, '__iter__'):\n            base = [random.randint(1, 4) for _ in range(n)]\n        else:\n            base = list(sol)\n            if len(base) != n:\n                base = (base + [1]*n)[:n]\n            base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n        return base\n\n    def _normalize_p(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _kempe_component(sol, start_idx, color_b, adj):\n        a = sol[start_idx]\n        if a == color_b:\n            return sol[:]\n        use = {a, color_b}\n        n = len(sol)\n        seen = [False]*n\n        q = deque([start_idx])\n        seen[start_idx] = True\n        comp = []\n        while q:\n            i = q.popleft()\n            comp.append(i)\n            for nb in adj[i+1]:\n                j = nb - 1\n                if not seen[j] and sol[j] in use:\n                    seen[j] = True\n                    q.append(j)\n        new_sol = sol[:]\n        for i in comp:\n            new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n        return new_sol\n\n    n, edges, adj = _adjacency_p()\n    sol = _sanitize_p(solution)\n    k = max(sol) if sol else 1\n\n    # Operation pool\n    ops = []\n    ops += [\"Kempe\"] * 5\n    ops += [\"ShuffleMax\"] * 3\n    ops += [\"RandomClassSwap\"] * 2\n\n    intensity = max(3, n \/\/ 3 + 1)\n\n    for _ in range(intensity):\n        op = random.choice(ops)\n        if op == \"Kempe\":\n            i = random.randrange(n)\n            b = random.randint(1, max(k, 2))\n            sol = _kempe_component(sol, i, b, adj)\n        elif op == \"ShuffleMax\":\n            maxc = max(sol)\n            max_idxs = [i for i in range(n) if sol[i] == maxc]\n            if max_idxs:\n                pick = random.sample(max_idxs, min(len(max_idxs), max(1, len(max_idxs)\/\/2)))\n                for i in pick:\n                    forbidden = {sol[j-1] for j in adj[i+1]}\n                    candidates = [c for c in range(1, maxc) if c not in forbidden]\n                    if candidates:\n                        sol[i] = random.choice(candidates)\n        else:  # RandomClassSwap\n            palette = list({c for c in sol})\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                sol = [b if c == a else (a if c == b else c) for c in sol]\n        k = max(sol)\n\n    sol = _normalize_p(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001432889}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nimport random\nfrom typing import Iterable\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000\n    PENALTY_VALUE = 10_000\n\n    if solution is None or not isinstance(solution, Iterable):\n        return float(PENALTY_INVALID)\n\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    invalid_values = 0\n    max_color = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool) or not isinstance(v, int) or v < 1:\n            invalid_values += 1\n            coerced.append(0)\n        else:\n            coerced.append(v)\n            if v > max_color:\n                max_color = v\n\n    if invalid_values > 0:\n        return float(PENALTY_INVALID + invalid_values * PENALTY_VALUE + max_color)\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            violations += 1\n\n    if violations > 0:\n        return float(PENALTY_INVALID + violations * PENALTY_VIOLATION + max_color)\n\n    return float(max_color)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    def _adjacency():\n        n = 9\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return n, edges, adj\n\n    def _sanitize(sol):\n        n, _, _ = _adjacency()\n        if sol is None or not hasattr(sol, '__iter__'):\n            base = [random.randint(1, 4) for _ in range(n)]\n        else:\n            base = list(sol)\n            if len(base) != n:\n                base = (base + [1]*n)[:n]\n            base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n        return base\n\n    def _normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _conflict_mask(sol, edges):\n        n = len(sol)\n        mask = [False]*n\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                mask[u-1] = True\n                mask[v-1] = True\n        return mask\n\n    def _feasible_colors(idx, sol, adj):\n        forbidden = {sol[j-1] for j in adj[idx+1]}\n        k = max(sol) if sol else 1\n        feas = [c for c in range(1, k+1) if c not in forbidden]\n        if not feas:\n            feas = [k+1]\n        return feas\n\n    def _kempe_chain_swap(sol, start_idx, color_b, adj):\n        a = sol[start_idx]\n        if a == color_b:\n            return sol[:]\n        use = set([a, color_b])\n        n = len(sol)\n        visited = [False]*n\n        q = deque()\n        q.append(start_idx)\n        visited[start_idx] = True\n        comp = []\n        while q:\n            i = q.popleft()\n            comp.append(i)\n            for nb in adj[i+1]:\n                j = nb - 1\n                if not visited[j] and sol[j] in use:\n                    visited[j] = True\n                    q.append(j)\n        new_sol = sol[:]\n        for i in comp:\n            new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n        return new_sol\n\n    n, edges, adj = _adjacency()\n    sol = _sanitize(solution)\n\n    r = random.random()\n    max_col = max(sol) if sol else 1\n    in_conflict = _conflict_mask(sol, edges)\n\n    if r < 0.45:\n        # RecolorOne with soft bias towards smaller colors\n        candidates = [i for i in range(n) if in_conflict[i] or sol[i] == max_col]\n        if not candidates:\n            candidates = list(range(n))\n        i = random.choice(candidates)\n        feas = _feasible_colors(i, sol, adj)\n        feas_sorted = sorted(feas)\n        # Exponential weights favor small colors but keep diversity\n        weights = [0.6**(c-1) for c in feas_sorted]\n        s = sum(weights)\n        t = random.random() * s\n        acc = 0.0\n        pick = feas_sorted[0]\n        for c, w in zip(feas_sorted, weights):\n            acc += w\n            if t <= acc:\n                pick = c\n                break\n        new_sol = sol[:]\n        new_sol[i] = pick\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"RecolorOne\")\n\n    elif r < 0.75:\n        # ReduceK-One: try to move a max-color vertex to lower palette\n        max_vertices = [i for i in range(n) if sol[i] == max_col]\n        order = max_vertices[:]\n        random.shuffle(order)\n        new_sol = sol[:]\n        moved = False\n        for i in order:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            candidates = [c for c in range(1, max_col) if c not in forbidden]\n            if candidates:\n                new_sol[i] = random.choice(candidates)\n                moved = True\n        if moved:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ReduceK-Batch\")\n        else:\n            # fallback recolor\n            i = random.randrange(n)\n            feas = _feasible_colors(i, sol, adj)\n            new_sol[i] = random.choice(feas)\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"Fallback-Recolor\")\n\n    elif r < 0.90:\n        # KempeChain: pick vertex i and neighbor color b != its color\n        i = random.randrange(n)\n        a = sol[i]\n        neigh_colors = {sol[j-1] for j in adj[i+1] if sol[j-1] != a}\n        palette = sorted(neigh_colors) if neigh_colors else [c for c in range(1, max_col+1) if c != a] or [1]\n        b = random.choice(palette)\n        new_sol = _kempe_chain_swap(sol, i, b, adj)\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"KempeChain\")\n\n    else:\n        # ColorClassMergeAttempt: try to merge max color into lower colors greedily\n        k = max_col\n        if k <= 1:\n            return (sol[:], \"Noop\")\n        targets = list(range(n))\n        random.shuffle(targets)\n        new_sol = sol[:]\n        success = True\n        for i in [t for t in targets if new_sol[t] == k]:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            feas = [c for c in range(1, k) if c not in forbidden]\n            if feas:\n                new_sol[i] = random.choice(feas)\n            else:\n                success = False\n                break\n        if success:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ClassMerge\")\n        else:\n            return (sol[:], \"NoMerge\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Strong perturbations to escape local minima\n    def _adjacency_p():\n        n = 9\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return n, edges, adj\n\n    def _sanitize_p(sol):\n        n, _, _ = _adjacency_p()\n        if sol is None or not hasattr(sol, '__iter__'):\n            base = [random.randint(1, 4) for _ in range(n)]\n        else:\n            base = list(sol)\n            if len(base) != n:\n                base = (base + [1]*n)[:n]\n            base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n        return base\n\n    def _normalize_p(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _kempe_component(sol, start_idx, color_b, adj):\n        a = sol[start_idx]\n        if a == color_b:\n            return sol[:]\n        use = {a, color_b}\n        n = len(sol)\n        seen = [False]*n\n        q = deque([start_idx])\n        seen[start_idx] = True\n        comp = []\n        while q:\n            i = q.popleft()\n            comp.append(i)\n            for nb in adj[i+1]:\n                j = nb - 1\n                if not seen[j] and sol[j] in use:\n                    seen[j] = True\n                    q.append(j)\n        new_sol = sol[:]\n        for i in comp:\n            new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n        return new_sol\n\n    n, edges, adj = _adjacency_p()\n    sol = _sanitize_p(solution)\n    k = max(sol) if sol else 1\n\n    # Operation pool\n    ops = []\n    ops += [\"Kempe\"] * 5\n    ops += [\"ShuffleMax\"] * 3\n    ops += [\"RandomClassSwap\"] * 2\n\n    intensity = max(3, n \/\/ 3 + 1)\n\n    for _ in range(intensity):\n        op = random.choice(ops)\n        if op == \"Kempe\":\n            i = random.randrange(n)\n            b = random.randint(1, max(k, 2))\n            sol = _kempe_component(sol, i, b, adj)\n        elif op == \"ShuffleMax\":\n            maxc = max(sol)\n            max_idxs = [i for i in range(n) if sol[i] == maxc]\n            if max_idxs:\n                pick = random.sample(max_idxs, min(len(max_idxs), max(1, len(max_idxs)\/\/2)))\n                for i in pick:\n                    forbidden = {sol[j-1] for j in adj[i+1]}\n                    candidates = [c for c in range(1, maxc) if c not in forbidden]\n                    if candidates:\n                        sol[i] = random.choice(candidates)\n        else:  # RandomClassSwap\n            palette = list({c for c in sol})\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                sol = [b if c == a else (a if c == b else c) for c in sol]\n        k = max(sol)\n\n    sol = _normalize_p(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001976706}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\nimport random\nfrom typing import Iterable\n\ndef evaluate_solution(solution) -> float:\n    # Returns scalar fitness; lower is better. Feasible solutions return max color used.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 100_000\n    PENALTY_VALUE = 10_000\n\n    if solution is None or not isinstance(solution, Iterable):\n        return float(PENALTY_INVALID)\n\n    sol_list = list(solution)\n    if len(sol_list) != n:\n        return float(PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE)\n\n    invalid_values = 0\n    max_color = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool) or not isinstance(v, int) or v < 1:\n            invalid_values += 1\n            coerced.append(0)\n        else:\n            coerced.append(v)\n            if v > max_color:\n                max_color = v\n\n    if invalid_values > 0:\n        return float(PENALTY_INVALID + invalid_values * PENALTY_VALUE + max_color)\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            violations += 1\n\n    if violations > 0:\n        return float(PENALTY_INVALID + violations * PENALTY_VIOLATION + max_color)\n\n    return float(max_color)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    def _adjacency():\n        n = 9\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return n, edges, adj\n\n    def _sanitize(sol):\n        n, _, _ = _adjacency()\n        if sol is None or not hasattr(sol, '__iter__'):\n            base = [random.randint(1, 4) for _ in range(n)]\n        else:\n            base = list(sol)\n            if len(base) != n:\n                base = (base + [1]*n)[:n]\n            base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n        return base\n\n    def _normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _conflict_mask(sol, edges):\n        n = len(sol)\n        mask = [False]*n\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                mask[u-1] = True\n                mask[v-1] = True\n        return mask\n\n    def _feasible_colors(idx, sol, adj):\n        forbidden = {sol[j-1] for j in adj[idx+1]}\n        k = max(sol) if sol else 1\n        feas = [c for c in range(1, k+1) if c not in forbidden]\n        if not feas:\n            feas = [k+1]\n        return feas\n\n    def _kempe_chain_swap(sol, start_idx, color_b, adj):\n        a = sol[start_idx]\n        if a == color_b:\n            return sol[:]\n        use = set([a, color_b])\n        n = len(sol)\n        visited = [False]*n\n        q = deque()\n        q.append(start_idx)\n        visited[start_idx] = True\n        comp = []\n        while q:\n            i = q.popleft()\n            comp.append(i)\n            for nb in adj[i+1]:\n                j = nb - 1\n                if not visited[j] and sol[j] in use:\n                    visited[j] = True\n                    q.append(j)\n        new_sol = sol[:]\n        for i in comp:\n            new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n        return new_sol\n\n    n, edges, adj = _adjacency()\n    sol = _sanitize(solution)\n\n    r = random.random()\n    max_col = max(sol) if sol else 1\n    in_conflict = _conflict_mask(sol, edges)\n\n    if r < 0.45:\n        # RecolorOne with soft bias towards smaller colors\n        candidates = [i for i in range(n) if in_conflict[i] or sol[i] == max_col]\n        if not candidates:\n            candidates = list(range(n))\n        i = random.choice(candidates)\n        feas = _feasible_colors(i, sol, adj)\n        feas_sorted = sorted(feas)\n        # Exponential weights favor small colors but keep diversity\n        weights = [0.6**(c-1) for c in feas_sorted]\n        s = sum(weights)\n        t = random.random() * s\n        acc = 0.0\n        pick = feas_sorted[0]\n        for c, w in zip(feas_sorted, weights):\n            acc += w\n            if t <= acc:\n                pick = c\n                break\n        new_sol = sol[:]\n        new_sol[i] = pick\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"RecolorOne\")\n\n    elif r < 0.75:\n        # ReduceK-One: try to move a max-color vertex to lower palette\n        max_vertices = [i for i in range(n) if sol[i] == max_col]\n        order = max_vertices[:]\n        random.shuffle(order)\n        new_sol = sol[:]\n        moved = False\n        for i in order:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            candidates = [c for c in range(1, max_col) if c not in forbidden]\n            if candidates:\n                new_sol[i] = random.choice(candidates)\n                moved = True\n        if moved:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ReduceK-Batch\")\n        else:\n            # fallback recolor\n            i = random.randrange(n)\n            feas = _feasible_colors(i, sol, adj)\n            new_sol[i] = random.choice(feas)\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"Fallback-Recolor\")\n\n    elif r < 0.90:\n        # KempeChain: pick vertex i and neighbor color b != its color\n        i = random.randrange(n)\n        a = sol[i]\n        neigh_colors = {sol[j-1] for j in adj[i+1] if sol[j-1] != a}\n        palette = sorted(neigh_colors) if neigh_colors else [c for c in range(1, max_col+1) if c != a] or [1]\n        b = random.choice(palette)\n        new_sol = _kempe_chain_swap(sol, i, b, adj)\n        new_sol = _normalize_colors(new_sol)\n        return (new_sol, \"KempeChain\")\n\n    else:\n        # ColorClassMergeAttempt: try to merge max color into lower colors greedily\n        k = max_col\n        if k <= 1:\n            return (sol[:], \"Noop\")\n        targets = list(range(n))\n        random.shuffle(targets)\n        new_sol = sol[:]\n        success = True\n        for i in [t for t in targets if new_sol[t] == k]:\n            forbidden = {new_sol[j-1] for j in adj[i+1]}\n            feas = [c for c in range(1, k) if c not in forbidden]\n            if feas:\n                new_sol[i] = random.choice(feas)\n            else:\n                success = False\n                break\n        if success:\n            new_sol = _normalize_colors(new_sol)\n            return (new_sol, \"ClassMerge\")\n        else:\n            return (sol[:], \"NoMerge\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Strong perturbations to escape local minima\n    def _adjacency_p():\n        n = 9\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return n, edges, adj\n\n    def _sanitize_p(sol):\n        n, _, _ = _adjacency_p()\n        if sol is None or not hasattr(sol, '__iter__'):\n            base = [random.randint(1, 4) for _ in range(n)]\n        else:\n            base = list(sol)\n            if len(base) != n:\n                base = (base + [1]*n)[:n]\n            base = [x if isinstance(x, int) and x > 0 else 1 for x in base]\n        return base\n\n    def _normalize_p(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _kempe_component(sol, start_idx, color_b, adj):\n        a = sol[start_idx]\n        if a == color_b:\n            return sol[:]\n        use = {a, color_b}\n        n = len(sol)\n        seen = [False]*n\n        q = deque([start_idx])\n        seen[start_idx] = True\n        comp = []\n        while q:\n            i = q.popleft()\n            comp.append(i)\n            for nb in adj[i+1]:\n                j = nb - 1\n                if not seen[j] and sol[j] in use:\n                    seen[j] = True\n                    q.append(j)\n        new_sol = sol[:]\n        for i in comp:\n            new_sol[i] = a if sol[i] == color_b else (color_b if sol[i] == a else sol[i])\n        return new_sol\n\n    n, edges, adj = _adjacency_p()\n    sol = _sanitize_p(solution)\n    k = max(sol) if sol else 1\n\n    # Operation pool\n    ops = []\n    ops += [\"Kempe\"] * 5\n    ops += [\"ShuffleMax\"] * 3\n    ops += [\"RandomClassSwap\"] * 2\n\n    intensity = max(3, n \/\/ 3 + 1)\n\n    for _ in range(intensity):\n        op = random.choice(ops)\n        if op == \"Kempe\":\n            i = random.randrange(n)\n            b = random.randint(1, max(k, 2))\n            sol = _kempe_component(sol, i, b, adj)\n        elif op == \"ShuffleMax\":\n            maxc = max(sol)\n            max_idxs = [i for i in range(n) if sol[i] == maxc]\n            if max_idxs:\n                pick = random.sample(max_idxs, min(len(max_idxs), max(1, len(max_idxs)\/\/2)))\n                for i in pick:\n                    forbidden = {sol[j-1] for j in adj[i+1]}\n                    candidates = [c for c in range(1, maxc) if c not in forbidden]\n                    if candidates:\n                        sol[i] = random.choice(candidates)\n        else:  # RandomClassSwap\n            palette = list({c for c in sol})\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                sol = [b if c == a else (a if c == b else c) for c in sol]\n        k = max(sol)\n\n    sol = _normalize_p(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Iterable() takes no arguments.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001693931}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT: solution is a Python list of length 9 with positive integers [c1,...,c9], where ci is the color of vertex i. Proper colorings minimize the number of distinct labels; labels should be normalized to {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better. Feasible solutions get the number of colors used.\n    # Infeasible or invalid inputs receive large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000  # label-normalization penalty\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Constraint check: count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _encode_solution_list_to_str(sol: List[int]) -> str:\n    # Encode list of ints to comma-separated string (no spaces)\n    return \",\".join(str(int(x)) for x in sol)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_neighbour_solution_str, movement_description_str)\n    # Input is LIST9_POSINT; if invalid, echo input encoding and mark invalid.\n    try:\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (_encode_solution_list_to_str(solution if isinstance(solution, list) else []), \"INVALID_INPUT\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (_encode_solution_list_to_str(solution), \"INVALID_INPUT\")\n        n = 9\n        current = solution[:]\n        k = max(current)\n        i = random.randrange(n)\n        # Candidate colors allow introducing at most one new color (k+1)\n        candidates = list(range(1, k + 2))\n        # Ensure a change\n        if len(candidates) > 1:\n            candidates.remove(current[i])\n        new_color = random.choice(candidates)\n        neighbour = current[:]\n        neighbour[i] = new_color\n        move_desc = f\"Recolor(v={i+1},to={new_color})\"\n        return (_encode_solution_list_to_str(neighbour), move_desc)\n    except Exception:\n        return (_encode_solution_list_to_str(solution if isinstance(solution, list) else []), \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-recolor perturbation: randomly recolor about 30% of vertices, allowing up to one new color.\n    # Returns a LIST9_POSINT like the input (or echoes input on invalid).\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    n = 9\n    k = max(solution)\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    out = solution[:]\n    palette = list(range(1, k + 2))\n    for i in idxs:\n        choices = palette[:]\n        if out[i] in choices and len(choices) > 1:\n            choices.remove(out[i])\n        out[i] = random.choice(choices)\n    return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000553727}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT: solution is a Python list of length 9 with positive integers [c1,...,c9], where ci is the color of vertex i. Proper colorings minimize the number of distinct labels; labels should be normalized to {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better. Feasible solutions get the number of colors used.\n    # Infeasible or invalid inputs receive large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000  # label-normalization penalty\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Constraint check: count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _encode_solution_list_to_str(sol: List[int]) -> str:\n    # Encode list of ints to comma-separated string (no spaces)\n    return \",\".join(str(int(x)) for x in sol)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_neighbour_solution_str, movement_description_str)\n    # Input is LIST9_POSINT; if invalid, echo input encoding and mark invalid.\n    try:\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (_encode_solution_list_to_str(solution if isinstance(solution, list) else []), \"INVALID_INPUT\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (_encode_solution_list_to_str(solution), \"INVALID_INPUT\")\n        n = 9\n        current = solution[:]\n        k = max(current)\n        i = random.randrange(n)\n        # Candidate colors allow introducing at most one new color (k+1)\n        candidates = list(range(1, k + 2))\n        # Ensure a change\n        if len(candidates) > 1:\n            candidates.remove(current[i])\n        new_color = random.choice(candidates)\n        neighbour = current[:]\n        neighbour[i] = new_color\n        move_desc = f\"Recolor(v={i+1},to={new_color})\"\n        return (_encode_solution_list_to_str(neighbour), move_desc)\n    except Exception:\n        return (_encode_solution_list_to_str(solution if isinstance(solution, list) else []), \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-recolor perturbation: randomly recolor about 30% of vertices, allowing up to one new color.\n    # Returns a LIST9_POSINT like the input (or echoes input on invalid).\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    n = 9\n    k = max(solution)\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    out = solution[:]\n    palette = list(range(1, k + 2))\n    for i in idxs:\n        choices = palette[:]\n        if out[i] in choices and len(choices) > 1:\n            choices.remove(out[i])\n        out[i] = random.choice(choices)\n    return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000569118}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT: solution is a Python list of length 9 with positive integers [c1,...,c9], where ci is the color of vertex i. Proper colorings minimize the number of distinct labels; labels should be normalized to {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness: lower is better. Feasible solutions get the number of colors used.\n    # Infeasible or invalid inputs receive large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000  # label-normalization penalty\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Constraint check: count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _encode_solution_list_to_str(sol: List[int]) -> str:\n    # Encode list of ints to comma-separated string (no spaces)\n    return \",\".join(str(int(x)) for x in sol)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (encoded_neighbour_solution_str, movement_description_str)\n    # Input is LIST9_POSINT; if invalid, echo input encoding and mark invalid.\n    try:\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (_encode_solution_list_to_str(solution if isinstance(solution, list) else []), \"INVALID_INPUT\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (_encode_solution_list_to_str(solution), \"INVALID_INPUT\")\n        n = 9\n        current = solution[:]\n        k = max(current)\n        i = random.randrange(n)\n        # Candidate colors allow introducing at most one new color (k+1)\n        candidates = list(range(1, k + 2))\n        # Ensure a change\n        if len(candidates) > 1:\n            candidates.remove(current[i])\n        new_color = random.choice(candidates)\n        neighbour = current[:]\n        neighbour[i] = new_color\n        move_desc = f\"Recolor(v={i+1},to={new_color})\"\n        return (_encode_solution_list_to_str(neighbour), move_desc)\n    except Exception:\n        return (_encode_solution_list_to_str(solution if isinstance(solution, list) else []), \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-recolor perturbation: randomly recolor about 30% of vertices, allowing up to one new color.\n    # Returns a LIST9_POSINT like the input (or echoes input on invalid).\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    n = 9\n    k = max(solution)\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    out = solution[:]\n    palette = list(range(1, k + 2))\n    for i in idxs:\n        choices = palette[:]\n        if out[i] in choices and len(choices) > 1:\n            choices.remove(out[i])\n        out[i] = random.choice(choices)\n    return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000558487}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 100  # normalization penalty kept small to avoid dominating\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..k preserving partition\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Identify conflict vertices\n        in_conflict = [False]*n\n        for (u,v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        # Vertex selection: prefer conflicts; if none, attempt improvement anyway\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Build candidate palette: 1..k, optionally k+1 only if all colors tie\n        k = max(cur)\n        palette = list(range(1, k+1))\n        # Evaluate conflicts per color for v\n        adj = [[] for _ in range(n)]\n        for (u,vv) in edges:\n            adj[u-1].append(vv-1)\n            adj[vv-1].append(u-1)\n        def conflicts_if_color(vtx: int, color: int) -> int:\n            cnt = 0\n            for nb in adj[vtx]:\n                if cur_nb_colors[nb] == color:\n                    cnt += 1\n            return cnt\n        # Prepare neighbor colors snapshot\n        cur_nb_colors = cur[:]  # alias for clarity\n        best_colors = []\n        best_conf = None\n        for col in palette:\n            cval = conflicts_if_color(v, col)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [col]\n            elif cval == best_conf:\n                best_colors.append(col)\n        # If all palette yields conflicts and we are stuck, allow k+1\n        if best_conf is not None and best_conf > 0:\n            # Consider introducing a new color as a last resort\n            cval = conflicts_if_color(v, k+1)\n            if cval < best_conf:\n                best_colors = [k+1]\n                best_conf = cval\n            elif cval == best_conf:\n                best_colors.append(k+1)\n        # Tie-break: prefer existing colors (<=k) to avoid color bloat, then lowest label\n        best_colors_sorted = sorted(best_colors, key=lambda x: (x>k, x))\n        new_color = random.choice([c for c in best_colors_sorted if c<=k]) if any(c<=k for c in best_colors_sorted) else best_colors_sorted[0]\n        neighbour = cur[:]\n        neighbour[v] = new_color\n        neighbour = _normalize_colors(neighbour)\n        move_desc = f\"Recolor(v={v+1},to={new_color})\"\n        return (neighbour, move_desc)\n    except Exception as e:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; multi-vertex recoloring focusing on conflicts.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Mark conflicts\n    conflict_count = [0]*n\n    for (u,v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    vertices = list(range(n))\n    # Prefer vertices with conflicts; if none, random subset\n    conflicted = [i for i,c in enumerate(conflict_count) if c>0]\n    m = max(1, n\/\/3)\n    if conflicted:\n        # take up to m highest-conflict vertices\n        conflicted.sort(key=lambda i: (-conflict_count[i], i))\n        idxs = conflicted[:m]\n    else:\n        idxs = random.sample(vertices, m)\n    k = max(cur)\n    palette = list(range(1, k+1))\n    # Allow at most one k+1 introduction\n    allow_new = True\n    for i in idxs:\n        # compute min-conflict colors\n        best_col = None\n        best_conf = None\n        for col in palette + ([k+1] if allow_new else []):\n            cnt = 0\n            for nb in adj[i]:\n                if cur[nb] == col:\n                    cnt += 1\n            if best_conf is None or cnt < best_conf or (cnt == best_conf and (best_col is None or col < best_col)):\n                best_conf = cnt\n                best_col = col\n        if best_col == k+1:\n            allow_new = False\n        cur[i] = best_col\n    return _normalize_colors(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000925862}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 100  # normalization penalty kept small to avoid dominating\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..k preserving partition\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Identify conflict vertices\n        in_conflict = [False]*n\n        for (u,v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        # Vertex selection: prefer conflicts; if none, attempt improvement anyway\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Build candidate palette: 1..k, optionally k+1 only if all colors tie\n        k = max(cur)\n        palette = list(range(1, k+1))\n        # Evaluate conflicts per color for v\n        adj = [[] for _ in range(n)]\n        for (u,vv) in edges:\n            adj[u-1].append(vv-1)\n            adj[vv-1].append(u-1)\n        def conflicts_if_color(vtx: int, color: int) -> int:\n            cnt = 0\n            for nb in adj[vtx]:\n                if cur_nb_colors[nb] == color:\n                    cnt += 1\n            return cnt\n        # Prepare neighbor colors snapshot\n        cur_nb_colors = cur[:]  # alias for clarity\n        best_colors = []\n        best_conf = None\n        for col in palette:\n            cval = conflicts_if_color(v, col)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [col]\n            elif cval == best_conf:\n                best_colors.append(col)\n        # If all palette yields conflicts and we are stuck, allow k+1\n        if best_conf is not None and best_conf > 0:\n            # Consider introducing a new color as a last resort\n            cval = conflicts_if_color(v, k+1)\n            if cval < best_conf:\n                best_colors = [k+1]\n                best_conf = cval\n            elif cval == best_conf:\n                best_colors.append(k+1)\n        # Tie-break: prefer existing colors (<=k) to avoid color bloat, then lowest label\n        best_colors_sorted = sorted(best_colors, key=lambda x: (x>k, x))\n        new_color = random.choice([c for c in best_colors_sorted if c<=k]) if any(c<=k for c in best_colors_sorted) else best_colors_sorted[0]\n        neighbour = cur[:]\n        neighbour[v] = new_color\n        neighbour = _normalize_colors(neighbour)\n        move_desc = f\"Recolor(v={v+1},to={new_color})\"\n        return (neighbour, move_desc)\n    except Exception as e:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; multi-vertex recoloring focusing on conflicts.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Mark conflicts\n    conflict_count = [0]*n\n    for (u,v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    vertices = list(range(n))\n    # Prefer vertices with conflicts; if none, random subset\n    conflicted = [i for i,c in enumerate(conflict_count) if c>0]\n    m = max(1, n\/\/3)\n    if conflicted:\n        # take up to m highest-conflict vertices\n        conflicted.sort(key=lambda i: (-conflict_count[i], i))\n        idxs = conflicted[:m]\n    else:\n        idxs = random.sample(vertices, m)\n    k = max(cur)\n    palette = list(range(1, k+1))\n    # Allow at most one k+1 introduction\n    allow_new = True\n    for i in idxs:\n        # compute min-conflict colors\n        best_col = None\n        best_conf = None\n        for col in palette + ([k+1] if allow_new else []):\n            cnt = 0\n            for nb in adj[i]:\n                if cur[nb] == col:\n                    cnt += 1\n            if best_conf is None or cnt < best_conf or (cnt == best_conf and (best_col is None or col < best_col)):\n                best_conf = cnt\n                best_col = col\n        if best_col == k+1:\n            allow_new = False\n        cur[i] = best_col\n    return _normalize_colors(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001170065}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 100  # normalization penalty kept small to avoid dominating\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..k preserving partition\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Identify conflict vertices\n        in_conflict = [False]*n\n        for (u,v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        # Vertex selection: prefer conflicts; if none, attempt improvement anyway\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Build candidate palette: 1..k, optionally k+1 only if all colors tie\n        k = max(cur)\n        palette = list(range(1, k+1))\n        # Evaluate conflicts per color for v\n        adj = [[] for _ in range(n)]\n        for (u,vv) in edges:\n            adj[u-1].append(vv-1)\n            adj[vv-1].append(u-1)\n        def conflicts_if_color(vtx: int, color: int) -> int:\n            cnt = 0\n            for nb in adj[vtx]:\n                if cur_nb_colors[nb] == color:\n                    cnt += 1\n            return cnt\n        # Prepare neighbor colors snapshot\n        cur_nb_colors = cur[:]  # alias for clarity\n        best_colors = []\n        best_conf = None\n        for col in palette:\n            cval = conflicts_if_color(v, col)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [col]\n            elif cval == best_conf:\n                best_colors.append(col)\n        # If all palette yields conflicts and we are stuck, allow k+1\n        if best_conf is not None and best_conf > 0:\n            # Consider introducing a new color as a last resort\n            cval = conflicts_if_color(v, k+1)\n            if cval < best_conf:\n                best_colors = [k+1]\n                best_conf = cval\n            elif cval == best_conf:\n                best_colors.append(k+1)\n        # Tie-break: prefer existing colors (<=k) to avoid color bloat, then lowest label\n        best_colors_sorted = sorted(best_colors, key=lambda x: (x>k, x))\n        new_color = random.choice([c for c in best_colors_sorted if c<=k]) if any(c<=k for c in best_colors_sorted) else best_colors_sorted[0]\n        neighbour = cur[:]\n        neighbour[v] = new_color\n        neighbour = _normalize_colors(neighbour)\n        move_desc = f\"Recolor(v={v+1},to={new_color})\"\n        return (neighbour, move_desc)\n    except Exception as e:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; multi-vertex recoloring focusing on conflicts.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Mark conflicts\n    conflict_count = [0]*n\n    for (u,v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    vertices = list(range(n))\n    # Prefer vertices with conflicts; if none, random subset\n    conflicted = [i for i,c in enumerate(conflict_count) if c>0]\n    m = max(1, n\/\/3)\n    if conflicted:\n        # take up to m highest-conflict vertices\n        conflicted.sort(key=lambda i: (-conflict_count[i], i))\n        idxs = conflicted[:m]\n    else:\n        idxs = random.sample(vertices, m)\n    k = max(cur)\n    palette = list(range(1, k+1))\n    # Allow at most one k+1 introduction\n    allow_new = True\n    for i in idxs:\n        # compute min-conflict colors\n        best_col = None\n        best_conf = None\n        for col in palette + ([k+1] if allow_new else []):\n            cnt = 0\n            for nb in adj[i]:\n                if cur[nb] == col:\n                    cnt += 1\n            if best_conf is None or cnt < best_conf or (cnt == best_conf and (best_col is None or col < best_col)):\n                best_conf = cnt\n                best_col = col\n        if best_col == k+1:\n            allow_new = False\n        cur[i] = best_col\n    return _normalize_colors(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001138695}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 100  # normalization penalty kept small to avoid dominating\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_tail_compact(sol: List[int]) -> List[int]:\n    # Only compacts if the highest color class is empty\n    if not sol:\n        return sol\n    k = max(sol)\n    present = set(sol)\n    # While the max label is not present, shift down labels above it by 1\n    while k > 0 and k not in present:\n        # Shift any label > k down by 1 (effectively nothing); break\n        k -= 1\n        present = set(sol)\n    # If top labels exist, do nothing; if there are gaps below k, leave them to avoid masking moves\n    return sol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Build adjacency\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        # Identify conflict vertices\n        in_conflict = [False]*n\n        for (u, v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        k = max(cur)\n        neighbour = cur[:]\n        move_desc = \"NO_MOVE\"\n        # Helper: best color for vertex by minimizing immediate conflicts; prefer <= current k\n        def best_colors_for(vtx: int):\n            palette = list(range(1, k+1))\n            # Evaluate conflicts per color for vtx\n            best_conf = None\n            best_cols = []\n            for col in palette + [k+1]:\n                cnt = 0\n                for nb in adj[vtx]:\n                    if neighbour[nb] == col:\n                        cnt += 1\n                if best_conf is None or cnt < best_conf:\n                    best_conf = cnt\n                    best_cols = [col]\n                elif cnt == best_conf:\n                    best_cols.append(col)\n            # Prefer existing colors, then lowest label\n            best_cols.sort(key=lambda x: (x > k, x))\n            return best_cols, best_conf\n        if conflict_vertices:\n            # Resolve a conflict: pick a conflicted vertex with highest degree among conflicted\n            conflict_vertices.sort(key=lambda v: (-len(adj[v]), v))\n            v = random.choice(conflict_vertices[:max(1, len(conflict_vertices)\/\/2)])\n            best_cols, best_conf = best_colors_for(v)\n            # Choose among best with preference to existing colors\n            new_color = next((c for c in best_cols if c <= k), best_cols[0])\n            neighbour[v] = new_color\n            move_desc = f\"RecolorConflict(v={v+1},to={new_color})\"\n        else:\n            # Feasible: try reduce colors. Target a vertex with the highest color label and try to push it down.\n            max_color = max(neighbour)\n            candidates = [i for i,c in enumerate(neighbour) if c == max_color]\n            if candidates:\n                v = random.choice(candidates)\n                # Try colors < max_color that create no conflicts first, then minimal conflicts\n                best_c = None\n                best_cnt = None\n                for col in range(1, max_color):\n                    cnt = 0\n                    for nb in adj[v]:\n                        if neighbour[nb] == col:\n                            cnt += 1\n                    if best_cnt is None or cnt < best_cnt or (cnt == best_cnt and (best_c is None or col < best_c)):\n                        best_cnt = cnt\n                        best_c = col\n                if best_c is not None and best_cnt == 0:\n                    neighbour[v] = best_c\n                    move_desc = f\"ReduceColor(v={v+1},to={best_c})\"\n                else:\n                    # DSATUR-like choice: pick vertex with max saturation then degree, recolor greedily\n                    def saturation(u):\n                        return len(set(neighbour[w] for w in adj[u]))\n                    v = max(range(n), key=lambda u: (saturation(u), len(adj[u]), -neighbour[u], -u))\n                    # Greedy recolor to the lowest feasible color; if none, keep current\n                    used = set(neighbour[w] for w in adj[v])\n                    for col in range(1, max_color):\n                        if col not in used:\n                            neighbour[v] = col\n                            move_desc = f\"DSATURRecolor(v={v+1},to={col})\"\n                            break\n                    if move_desc == \"NO_MOVE\":\n                        # As a last resort, recolor to a color causing minimal conflicts (still feasible state expected to remain feasible)\n                        best_cols, best_conf = best_colors_for(v)\n                        pick = next((c for c in best_cols if c < max_color), best_cols[0])\n                        neighbour[v] = pick\n                        move_desc = f\"GreedyRecolor(v={v+1},to={pick})\"\n            # If we emptied the highest color class, compact labels\n            if max(neighbour) < k:\n                neighbour = _normalize_tail_compact(neighbour)\n        return (neighbour, move_desc)\n    except Exception:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors_full(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..k preserving partition order of appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; applies multi-vertex recoloring and optional Kempe-chain swap.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict-focused recolor of a small subset\n    # Compute conflict counts\n    conflict_count = [0]*n\n    for (u,v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    conflicted = [i for i,c in enumerate(conflict_count) if c>0]\n    vertices = list(range(n))\n    m = max(1, n\/\/3)\n    if conflicted:\n        conflicted.sort(key=lambda i: (-conflict_count[i], i))\n        idxs = conflicted[:m]\n    else:\n        idxs = random.sample(vertices, m)\n    k = max(cur)\n    for i in idxs:\n        # Choose a color minimizing immediate conflicts; prefer <= k\n        best_col = None\n        best_cnt = None\n        for col in list(range(1, k+1)) + [k+1]:\n            cnt = 0\n            for nb in adj[i]:\n                if cur[nb] == col:\n                    cnt += 1\n            if best_cnt is None or cnt < best_cnt or (cnt == best_cnt and (best_col is None or (col <= k and best_col > k) or (col < best_col))):\n                best_cnt = cnt\n                best_col = col\n        cur[i] = best_col\n        if max(cur) > k:\n            k = max(cur)\n    # Optional Kempe-chain swap between two colors to diversify\n    def kempe_chain_swap(state: List[int]):\n        if not state:\n            return state\n        kmax = max(state)\n        if kmax < 2:\n            return state\n        v0 = random.randrange(n)\n        # pick a neighbor color different from state[v0]; if none, pick random different color\n        neigh_colors = [state[w] for w in adj[v0]]\n        if neigh_colors:\n            c2 = random.choice([c for c in set(neigh_colors) if c != state[v0]] or [((state[v0]) % kmax) + 1])\n        else:\n            c2 = ((state[v0]) % kmax) + 1\n        c1 = state[v0]\n        # BFS to find the (c1,c2)-component containing v0\n        seen = [False]*n\n        stack = [v0]\n        seen[v0] = True\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if not seen[w] and state[w] in (c1, c2):\n                    seen[w] = True\n                    stack.append(w)\n        # Swap colors on the component\n        for i in range(n):\n            if seen[i]:\n                if state[i] == c1:\n                    state[i] = c2\n                elif state[i] == c2:\n                    state[i] = c1\n        return state\n    if random.random() < 0.8:\n        cur = kempe_chain_swap(cur)\n    # Normalize labeling for cleanliness\n    cur = _normalize_colors_full(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001158495}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 100  # normalization penalty kept small to avoid dominating\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_tail_compact(sol: List[int]) -> List[int]:\n    # Only compacts if the highest color class is empty\n    if not sol:\n        return sol\n    k = max(sol)\n    present = set(sol)\n    # While the max label is not present, shift down labels above it by 1\n    while k > 0 and k not in present:\n        # Shift any label > k down by 1 (effectively nothing); break\n        k -= 1\n        present = set(sol)\n    # If top labels exist, do nothing; if there are gaps below k, leave them to avoid masking moves\n    return sol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Build adjacency\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        # Identify conflict vertices\n        in_conflict = [False]*n\n        for (u, v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        k = max(cur)\n        neighbour = cur[:]\n        move_desc = \"NO_MOVE\"\n        # Helper: best color for vertex by minimizing immediate conflicts; prefer <= current k\n        def best_colors_for(vtx: int):\n            palette = list(range(1, k+1))\n            # Evaluate conflicts per color for vtx\n            best_conf = None\n            best_cols = []\n            for col in palette + [k+1]:\n                cnt = 0\n                for nb in adj[vtx]:\n                    if neighbour[nb] == col:\n                        cnt += 1\n                if best_conf is None or cnt < best_conf:\n                    best_conf = cnt\n                    best_cols = [col]\n                elif cnt == best_conf:\n                    best_cols.append(col)\n            # Prefer existing colors, then lowest label\n            best_cols.sort(key=lambda x: (x > k, x))\n            return best_cols, best_conf\n        if conflict_vertices:\n            # Resolve a conflict: pick a conflicted vertex with highest degree among conflicted\n            conflict_vertices.sort(key=lambda v: (-len(adj[v]), v))\n            v = random.choice(conflict_vertices[:max(1, len(conflict_vertices)\/\/2)])\n            best_cols, best_conf = best_colors_for(v)\n            # Choose among best with preference to existing colors\n            new_color = next((c for c in best_cols if c <= k), best_cols[0])\n            neighbour[v] = new_color\n            move_desc = f\"RecolorConflict(v={v+1},to={new_color})\"\n        else:\n            # Feasible: try reduce colors. Target a vertex with the highest color label and try to push it down.\n            max_color = max(neighbour)\n            candidates = [i for i,c in enumerate(neighbour) if c == max_color]\n            if candidates:\n                v = random.choice(candidates)\n                # Try colors < max_color that create no conflicts first, then minimal conflicts\n                best_c = None\n                best_cnt = None\n                for col in range(1, max_color):\n                    cnt = 0\n                    for nb in adj[v]:\n                        if neighbour[nb] == col:\n                            cnt += 1\n                    if best_cnt is None or cnt < best_cnt or (cnt == best_cnt and (best_c is None or col < best_c)):\n                        best_cnt = cnt\n                        best_c = col\n                if best_c is not None and best_cnt == 0:\n                    neighbour[v] = best_c\n                    move_desc = f\"ReduceColor(v={v+1},to={best_c})\"\n                else:\n                    # DSATUR-like choice: pick vertex with max saturation then degree, recolor greedily\n                    def saturation(u):\n                        return len(set(neighbour[w] for w in adj[u]))\n                    v = max(range(n), key=lambda u: (saturation(u), len(adj[u]), -neighbour[u], -u))\n                    # Greedy recolor to the lowest feasible color; if none, keep current\n                    used = set(neighbour[w] for w in adj[v])\n                    for col in range(1, max_color):\n                        if col not in used:\n                            neighbour[v] = col\n                            move_desc = f\"DSATURRecolor(v={v+1},to={col})\"\n                            break\n                    if move_desc == \"NO_MOVE\":\n                        # As a last resort, recolor to a color causing minimal conflicts (still feasible state expected to remain feasible)\n                        best_cols, best_conf = best_colors_for(v)\n                        pick = next((c for c in best_cols if c < max_color), best_cols[0])\n                        neighbour[v] = pick\n                        move_desc = f\"GreedyRecolor(v={v+1},to={pick})\"\n            # If we emptied the highest color class, compact labels\n            if max(neighbour) < k:\n                neighbour = _normalize_tail_compact(neighbour)\n        return (neighbour, move_desc)\n    except Exception:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors_full(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..k preserving partition order of appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; applies multi-vertex recoloring and optional Kempe-chain swap.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict-focused recolor of a small subset\n    # Compute conflict counts\n    conflict_count = [0]*n\n    for (u,v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    conflicted = [i for i,c in enumerate(conflict_count) if c>0]\n    vertices = list(range(n))\n    m = max(1, n\/\/3)\n    if conflicted:\n        conflicted.sort(key=lambda i: (-conflict_count[i], i))\n        idxs = conflicted[:m]\n    else:\n        idxs = random.sample(vertices, m)\n    k = max(cur)\n    for i in idxs:\n        # Choose a color minimizing immediate conflicts; prefer <= k\n        best_col = None\n        best_cnt = None\n        for col in list(range(1, k+1)) + [k+1]:\n            cnt = 0\n            for nb in adj[i]:\n                if cur[nb] == col:\n                    cnt += 1\n            if best_cnt is None or cnt < best_cnt or (cnt == best_cnt and (best_col is None or (col <= k and best_col > k) or (col < best_col))):\n                best_cnt = cnt\n                best_col = col\n        cur[i] = best_col\n        if max(cur) > k:\n            k = max(cur)\n    # Optional Kempe-chain swap between two colors to diversify\n    def kempe_chain_swap(state: List[int]):\n        if not state:\n            return state\n        kmax = max(state)\n        if kmax < 2:\n            return state\n        v0 = random.randrange(n)\n        # pick a neighbor color different from state[v0]; if none, pick random different color\n        neigh_colors = [state[w] for w in adj[v0]]\n        if neigh_colors:\n            c2 = random.choice([c for c in set(neigh_colors) if c != state[v0]] or [((state[v0]) % kmax) + 1])\n        else:\n            c2 = ((state[v0]) % kmax) + 1\n        c1 = state[v0]\n        # BFS to find the (c1,c2)-component containing v0\n        seen = [False]*n\n        stack = [v0]\n        seen[v0] = True\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if not seen[w] and state[w] in (c1, c2):\n                    seen[w] = True\n                    stack.append(w)\n        # Swap colors on the component\n        for i in range(n):\n            if seen[i]:\n                if state[i] == c1:\n                    state[i] = c2\n                elif state[i] == c2:\n                    state[i] = c1\n        return state\n    if random.random() < 0.8:\n        cur = kempe_chain_swap(cur)\n    # Normalize labeling for cleanliness\n    cur = _normalize_colors_full(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001583621}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 100  # normalization penalty kept small to avoid dominating\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_tail_compact(sol: List[int]) -> List[int]:\n    # Only compacts if the highest color class is empty\n    if not sol:\n        return sol\n    k = max(sol)\n    present = set(sol)\n    # While the max label is not present, shift down labels above it by 1\n    while k > 0 and k not in present:\n        # Shift any label > k down by 1 (effectively nothing); break\n        k -= 1\n        present = set(sol)\n    # If top labels exist, do nothing; if there are gaps below k, leave them to avoid masking moves\n    return sol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Build adjacency\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        # Identify conflict vertices\n        in_conflict = [False]*n\n        for (u, v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        k = max(cur)\n        neighbour = cur[:]\n        move_desc = \"NO_MOVE\"\n        # Helper: best color for vertex by minimizing immediate conflicts; prefer <= current k\n        def best_colors_for(vtx: int):\n            palette = list(range(1, k+1))\n            # Evaluate conflicts per color for vtx\n            best_conf = None\n            best_cols = []\n            for col in palette + [k+1]:\n                cnt = 0\n                for nb in adj[vtx]:\n                    if neighbour[nb] == col:\n                        cnt += 1\n                if best_conf is None or cnt < best_conf:\n                    best_conf = cnt\n                    best_cols = [col]\n                elif cnt == best_conf:\n                    best_cols.append(col)\n            # Prefer existing colors, then lowest label\n            best_cols.sort(key=lambda x: (x > k, x))\n            return best_cols, best_conf\n        if conflict_vertices:\n            # Resolve a conflict: pick a conflicted vertex with highest degree among conflicted\n            conflict_vertices.sort(key=lambda v: (-len(adj[v]), v))\n            v = random.choice(conflict_vertices[:max(1, len(conflict_vertices)\/\/2)])\n            best_cols, best_conf = best_colors_for(v)\n            # Choose among best with preference to existing colors\n            new_color = next((c for c in best_cols if c <= k), best_cols[0])\n            neighbour[v] = new_color\n            move_desc = f\"RecolorConflict(v={v+1},to={new_color})\"\n        else:\n            # Feasible: try reduce colors. Target a vertex with the highest color label and try to push it down.\n            max_color = max(neighbour)\n            candidates = [i for i,c in enumerate(neighbour) if c == max_color]\n            if candidates:\n                v = random.choice(candidates)\n                # Try colors < max_color that create no conflicts first, then minimal conflicts\n                best_c = None\n                best_cnt = None\n                for col in range(1, max_color):\n                    cnt = 0\n                    for nb in adj[v]:\n                        if neighbour[nb] == col:\n                            cnt += 1\n                    if best_cnt is None or cnt < best_cnt or (cnt == best_cnt and (best_c is None or col < best_c)):\n                        best_cnt = cnt\n                        best_c = col\n                if best_c is not None and best_cnt == 0:\n                    neighbour[v] = best_c\n                    move_desc = f\"ReduceColor(v={v+1},to={best_c})\"\n                else:\n                    # DSATUR-like choice: pick vertex with max saturation then degree, recolor greedily\n                    def saturation(u):\n                        return len(set(neighbour[w] for w in adj[u]))\n                    v = max(range(n), key=lambda u: (saturation(u), len(adj[u]), -neighbour[u], -u))\n                    # Greedy recolor to the lowest feasible color; if none, keep current\n                    used = set(neighbour[w] for w in adj[v])\n                    for col in range(1, max_color):\n                        if col not in used:\n                            neighbour[v] = col\n                            move_desc = f\"DSATURRecolor(v={v+1},to={col})\"\n                            break\n                    if move_desc == \"NO_MOVE\":\n                        # As a last resort, recolor to a color causing minimal conflicts (still feasible state expected to remain feasible)\n                        best_cols, best_conf = best_colors_for(v)\n                        pick = next((c for c in best_cols if c < max_color), best_cols[0])\n                        neighbour[v] = pick\n                        move_desc = f\"GreedyRecolor(v={v+1},to={pick})\"\n            # If we emptied the highest color class, compact labels\n            if max(neighbour) < k:\n                neighbour = _normalize_tail_compact(neighbour)\n        return (neighbour, move_desc)\n    except Exception:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors_full(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..k preserving partition order of appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; applies multi-vertex recoloring and optional Kempe-chain swap.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict-focused recolor of a small subset\n    # Compute conflict counts\n    conflict_count = [0]*n\n    for (u,v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    conflicted = [i for i,c in enumerate(conflict_count) if c>0]\n    vertices = list(range(n))\n    m = max(1, n\/\/3)\n    if conflicted:\n        conflicted.sort(key=lambda i: (-conflict_count[i], i))\n        idxs = conflicted[:m]\n    else:\n        idxs = random.sample(vertices, m)\n    k = max(cur)\n    for i in idxs:\n        # Choose a color minimizing immediate conflicts; prefer <= k\n        best_col = None\n        best_cnt = None\n        for col in list(range(1, k+1)) + [k+1]:\n            cnt = 0\n            for nb in adj[i]:\n                if cur[nb] == col:\n                    cnt += 1\n            if best_cnt is None or cnt < best_cnt or (cnt == best_cnt and (best_col is None or (col <= k and best_col > k) or (col < best_col))):\n                best_cnt = cnt\n                best_col = col\n        cur[i] = best_col\n        if max(cur) > k:\n            k = max(cur)\n    # Optional Kempe-chain swap between two colors to diversify\n    def kempe_chain_swap(state: List[int]):\n        if not state:\n            return state\n        kmax = max(state)\n        if kmax < 2:\n            return state\n        v0 = random.randrange(n)\n        # pick a neighbor color different from state[v0]; if none, pick random different color\n        neigh_colors = [state[w] for w in adj[v0]]\n        if neigh_colors:\n            c2 = random.choice([c for c in set(neigh_colors) if c != state[v0]] or [((state[v0]) % kmax) + 1])\n        else:\n            c2 = ((state[v0]) % kmax) + 1\n        c1 = state[v0]\n        # BFS to find the (c1,c2)-component containing v0\n        seen = [False]*n\n        stack = [v0]\n        seen[v0] = True\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if not seen[w] and state[w] in (c1, c2):\n                    seen[w] = True\n                    stack.append(w)\n        # Swap colors on the component\n        for i in range(n):\n            if seen[i]:\n                if state[i] == c1:\n                    state[i] = c2\n                elif state[i] == c2:\n                    state[i] = c1\n        return state\n    if random.random() < 0.8:\n        cur = kempe_chain_swap(cur)\n    # Normalize labeling for cleanliness\n    cur = _normalize_colors_full(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001452389}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 1  # tiny normalization preference within same k\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Build adjacency\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        # Helper: full normalization mapping sorted unique colors to 1..k\n        def normalize_full(sol: List[int]) -> List[int]:\n            uniq = sorted(set(sol))\n            mapping = {c:i+1 for i,c in enumerate(uniq)}\n            return [mapping[c] for c in sol]\n        # Identify conflicts\n        in_conflict = [False]*n\n        conflict_edges = []\n        for (u, v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n                conflict_edges.append((u-1,v-1))\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        k = max(cur)\n        neighbour = cur[:]\n        move_desc = \"NO_MOVE\"\n        # Utility: check conflicts for assigning color to vertex\n        def conflicts_for(vtx: int, color: int, state: List[int]) -> int:\n            cnt = 0\n            for nb in adj[vtx]:\n                if state[nb] == color:\n                    cnt += 1\n            return cnt\n        if conflict_vertices:\n            # Prefer operating on a specific conflicted edge to allow quick fixes\/swaps\n            # Choose the edge with highest combined degree; deterministic tie-break by index\n            conflict_edges.sort(key=lambda e: (-(len(adj[e[0]])+len(adj[e[1]])), e[0], e[1]))\n            u, v = conflict_edges[0]\n            cu, cv = neighbour[u], neighbour[v]  # equal here\n            # Try direct swap with a third color or recolor one endpoint to a feasible existing color\n            # Attempt recoloring u to the lowest conflict-free color among 1..k\n            for col in range(1, k+1):\n                if col != cv and conflicts_for(u, col, neighbour) == 0:\n                    neighbour[u] = col\n                    move_desc = f\"ResolveEdgeRecolor(u={u+1},to={col})\"\n                    break\n            if move_desc == \"NO_MOVE\":\n                # Attempt recolor v\n                for col in range(1, k+1):\n                    if col != cu and conflicts_for(v, col, neighbour) == 0:\n                        neighbour[v] = col\n                        move_desc = f\"ResolveEdgeRecolor(v={v+1},to={col})\"\n                        break\n            if move_desc == \"NO_MOVE\":\n                # As a bounded expansion fallback, allow k+1 only if it strictly reduces immediate conflicts vs best in 1..k\n                best_existing = min(conflicts_for(u, col, neighbour) for col in range(1, k+1))\n                if conflicts_for(u, k+1, neighbour) < best_existing:\n                    neighbour[u] = k+1\n                    move_desc = f\"BoundedExpand(u={u+1},to={k+1})\"\n                else:\n                    best_existing_v = min(conflicts_for(v, col, neighbour) for col in range(1, k+1))\n                    if conflicts_for(v, k+1, neighbour) < best_existing_v:\n                        neighbour[v] = k+1\n                        move_desc = f\"BoundedExpand(v={v+1},to={k+1})\"\n            # Done conflict phase\n        else:\n            # Feasible: attempt to reduce k by emptying the highest color class without introducing conflicts\n            max_color = max(neighbour)\n            class_vertices = [i for i,c in enumerate(neighbour) if c == max_color]\n            # Try to reassign each vertex in the max color class to the smallest available color < max_color\n            moved_any = False\n            for vtx in class_vertices:\n                used = set(neighbour[w] for w in adj[vtx])\n                for col in range(1, max_color):\n                    if col not in used:\n                        neighbour[vtx] = col\n                        moved_any = True\n                        move_desc = f\"ReduceColor(v={vtx+1},to={col})\"\n                        break\n            # If we emptied the class, normalize labels\n            if moved_any and all(c != max_color for c in neighbour):\n                neighbour = normalize_full(neighbour)\n                move_desc = move_desc + \"|Compact\"\n            if move_desc == \"NO_MOVE\":\n                # Plateau shake within feasible set: pick a vertex and recolor to another non-conflicting existing color if possible\n                vtx = max(range(n), key=lambda u: (len(set(neighbour[w] for w in adj[u])), len(adj[u]), -u))\n                used = set(neighbour[w] for w in adj[vtx])\n                for col in range(1, max_color+1):\n                    if col != neighbour[vtx] and col not in used:\n                        neighbour[vtx] = col\n                        move_desc = f\"FeasibleRecolor(v={vtx+1},to={col})\"\n                        break\n        return (neighbour, move_desc)\n    except Exception:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; applies Kempe-chain swap or multi-vertex recolor; keeps domain valid.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Normalize colors to 1..k preserving order of appearance\n    def normalize_colors_full(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Kempe-chain swap\n    def kempe_chain_swap(state: List[int]) -> List[int]:\n        kmax = max(state)\n        if kmax < 2:\n            return state\n        v0 = random.randrange(n)\n        c1 = state[v0]\n        neigh_colors = [state[w] for w in adj[v0]]\n        pool = [c for c in set(neigh_colors) if c != c1]\n        if not pool:\n            c2 = (c1 % kmax) + 1\n        else:\n            c2 = random.choice(pool)\n        # BFS\/DFS on (c1,c2)-component containing v0\n        seen = [False]*n\n        stack = [v0]\n        seen[v0] = True\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if not seen[w] and state[w] in (c1, c2):\n                    seen[w] = True\n                    stack.append(w)\n        for i in range(n):\n            if seen[i]:\n                state[i] = c1 if state[i] == c2 else (c2 if state[i] == c1 else state[i])\n        return state\n    # Apply 1-2 Kempe swaps and a small random recolor with bounded expansion\n    if random.random() < 0.9:\n        cur = kempe_chain_swap(cur)\n    if random.random() < 0.5:\n        cur = kempe_chain_swap(cur)\n    # Small subset targeted recolor\n    k = max(cur)\n    m = 3\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    picked = vertices[:m]\n    for i in picked:\n        # choose among 1..k and optionally k+1 if it strictly decreases immediate conflicts vs best existing\n        def conf_for(col: int) -> int:\n            return sum(1 for nb in adj[i] if cur[nb] == col)\n        best_exist = None\n        best_col = None\n        for col in range(1, k+1):\n            cval = conf_for(col)\n            if best_exist is None or cval < best_exist or (cval == best_exist and (best_col is None or col < best_col)):\n                best_exist = cval\n                best_col = col\n        # consider k+1\n        if conf_for(k+1) < (best_exist if best_exist is not None else 10**9):\n            cur[i] = k+1\n            k = max(k, k+1)\n        else:\n            cur[i] = best_col if best_col is not None else cur[i]\n    cur = normalize_colors_full(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001193793}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 1  # tiny normalization preference within same k\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Build adjacency\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        # Helper: full normalization mapping sorted unique colors to 1..k\n        def normalize_full(sol: List[int]) -> List[int]:\n            uniq = sorted(set(sol))\n            mapping = {c:i+1 for i,c in enumerate(uniq)}\n            return [mapping[c] for c in sol]\n        # Identify conflicts\n        in_conflict = [False]*n\n        conflict_edges = []\n        for (u, v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n                conflict_edges.append((u-1,v-1))\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        k = max(cur)\n        neighbour = cur[:]\n        move_desc = \"NO_MOVE\"\n        # Utility: check conflicts for assigning color to vertex\n        def conflicts_for(vtx: int, color: int, state: List[int]) -> int:\n            cnt = 0\n            for nb in adj[vtx]:\n                if state[nb] == color:\n                    cnt += 1\n            return cnt\n        if conflict_vertices:\n            # Prefer operating on a specific conflicted edge to allow quick fixes\/swaps\n            # Choose the edge with highest combined degree; deterministic tie-break by index\n            conflict_edges.sort(key=lambda e: (-(len(adj[e[0]])+len(adj[e[1]])), e[0], e[1]))\n            u, v = conflict_edges[0]\n            cu, cv = neighbour[u], neighbour[v]  # equal here\n            # Try direct swap with a third color or recolor one endpoint to a feasible existing color\n            # Attempt recoloring u to the lowest conflict-free color among 1..k\n            for col in range(1, k+1):\n                if col != cv and conflicts_for(u, col, neighbour) == 0:\n                    neighbour[u] = col\n                    move_desc = f\"ResolveEdgeRecolor(u={u+1},to={col})\"\n                    break\n            if move_desc == \"NO_MOVE\":\n                # Attempt recolor v\n                for col in range(1, k+1):\n                    if col != cu and conflicts_for(v, col, neighbour) == 0:\n                        neighbour[v] = col\n                        move_desc = f\"ResolveEdgeRecolor(v={v+1},to={col})\"\n                        break\n            if move_desc == \"NO_MOVE\":\n                # As a bounded expansion fallback, allow k+1 only if it strictly reduces immediate conflicts vs best in 1..k\n                best_existing = min(conflicts_for(u, col, neighbour) for col in range(1, k+1))\n                if conflicts_for(u, k+1, neighbour) < best_existing:\n                    neighbour[u] = k+1\n                    move_desc = f\"BoundedExpand(u={u+1},to={k+1})\"\n                else:\n                    best_existing_v = min(conflicts_for(v, col, neighbour) for col in range(1, k+1))\n                    if conflicts_for(v, k+1, neighbour) < best_existing_v:\n                        neighbour[v] = k+1\n                        move_desc = f\"BoundedExpand(v={v+1},to={k+1})\"\n            # Done conflict phase\n        else:\n            # Feasible: attempt to reduce k by emptying the highest color class without introducing conflicts\n            max_color = max(neighbour)\n            class_vertices = [i for i,c in enumerate(neighbour) if c == max_color]\n            # Try to reassign each vertex in the max color class to the smallest available color < max_color\n            moved_any = False\n            for vtx in class_vertices:\n                used = set(neighbour[w] for w in adj[vtx])\n                for col in range(1, max_color):\n                    if col not in used:\n                        neighbour[vtx] = col\n                        moved_any = True\n                        move_desc = f\"ReduceColor(v={vtx+1},to={col})\"\n                        break\n            # If we emptied the class, normalize labels\n            if moved_any and all(c != max_color for c in neighbour):\n                neighbour = normalize_full(neighbour)\n                move_desc = move_desc + \"|Compact\"\n            if move_desc == \"NO_MOVE\":\n                # Plateau shake within feasible set: pick a vertex and recolor to another non-conflicting existing color if possible\n                vtx = max(range(n), key=lambda u: (len(set(neighbour[w] for w in adj[u])), len(adj[u]), -u))\n                used = set(neighbour[w] for w in adj[vtx])\n                for col in range(1, max_color+1):\n                    if col != neighbour[vtx] and col not in used:\n                        neighbour[vtx] = col\n                        move_desc = f\"FeasibleRecolor(v={vtx+1},to={col})\"\n                        break\n        return (neighbour, move_desc)\n    except Exception:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; applies Kempe-chain swap or multi-vertex recolor; keeps domain valid.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Normalize colors to 1..k preserving order of appearance\n    def normalize_colors_full(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Kempe-chain swap\n    def kempe_chain_swap(state: List[int]) -> List[int]:\n        kmax = max(state)\n        if kmax < 2:\n            return state\n        v0 = random.randrange(n)\n        c1 = state[v0]\n        neigh_colors = [state[w] for w in adj[v0]]\n        pool = [c for c in set(neigh_colors) if c != c1]\n        if not pool:\n            c2 = (c1 % kmax) + 1\n        else:\n            c2 = random.choice(pool)\n        # BFS\/DFS on (c1,c2)-component containing v0\n        seen = [False]*n\n        stack = [v0]\n        seen[v0] = True\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if not seen[w] and state[w] in (c1, c2):\n                    seen[w] = True\n                    stack.append(w)\n        for i in range(n):\n            if seen[i]:\n                state[i] = c1 if state[i] == c2 else (c2 if state[i] == c1 else state[i])\n        return state\n    # Apply 1-2 Kempe swaps and a small random recolor with bounded expansion\n    if random.random() < 0.9:\n        cur = kempe_chain_swap(cur)\n    if random.random() < 0.5:\n        cur = kempe_chain_swap(cur)\n    # Small subset targeted recolor\n    k = max(cur)\n    m = 3\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    picked = vertices[:m]\n    for i in picked:\n        # choose among 1..k and optionally k+1 if it strictly decreases immediate conflicts vs best existing\n        def conf_for(col: int) -> int:\n            return sum(1 for nb in adj[i] if cur[nb] == col)\n        best_exist = None\n        best_col = None\n        for col in range(1, k+1):\n            cval = conf_for(col)\n            if best_exist is None or cval < best_exist or (cval == best_exist and (best_col is None or col < best_col)):\n                best_exist = cval\n                best_col = col\n        # consider k+1\n        if conf_for(k+1) < (best_exist if best_exist is not None else 10**9):\n            cur[i] = k+1\n            k = max(k, k+1)\n        else:\n            cur[i] = best_col if best_col is not None else cur[i]\n    cur = normalize_colors_full(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001494706}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST9_POSINT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Lower is better. Feasible solutions return number of colors used (k),\n    # infeasible\/invalid return large penalties with conflicts added.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 1  # tiny normalization preference within same k\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible objective: distinct color count with normalization preference\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_list9_posint, movement_description_str)\n    try:\n        # Basic validation\n        if not isinstance(solution, list) or len(solution) != 9:\n            return (solution, \"INVALID_INPUT_SHAPE\")\n        for c in solution:\n            if not isinstance(c, int) or c < 1:\n                return (solution, \"INVALID_INPUT_DOMAIN\")\n        # Problem data local\n        edges = [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n        n = 9\n        cur = solution[:]\n        # Build adjacency\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        # Helper: full normalization mapping sorted unique colors to 1..k\n        def normalize_full(sol: List[int]) -> List[int]:\n            uniq = sorted(set(sol))\n            mapping = {c:i+1 for i,c in enumerate(uniq)}\n            return [mapping[c] for c in sol]\n        # Identify conflicts\n        in_conflict = [False]*n\n        conflict_edges = []\n        for (u, v) in edges:\n            if cur[u-1] == cur[v-1]:\n                in_conflict[u-1] = True\n                in_conflict[v-1] = True\n                conflict_edges.append((u-1,v-1))\n        conflict_vertices = [i for i,b in enumerate(in_conflict) if b]\n        k = max(cur)\n        neighbour = cur[:]\n        move_desc = \"NO_MOVE\"\n        # Utility: check conflicts for assigning color to vertex\n        def conflicts_for(vtx: int, color: int, state: List[int]) -> int:\n            cnt = 0\n            for nb in adj[vtx]:\n                if state[nb] == color:\n                    cnt += 1\n            return cnt\n        if conflict_vertices:\n            # Prefer operating on a specific conflicted edge to allow quick fixes\/swaps\n            # Choose the edge with highest combined degree; deterministic tie-break by index\n            conflict_edges.sort(key=lambda e: (-(len(adj[e[0]])+len(adj[e[1]])), e[0], e[1]))\n            u, v = conflict_edges[0]\n            cu, cv = neighbour[u], neighbour[v]  # equal here\n            # Try direct swap with a third color or recolor one endpoint to a feasible existing color\n            # Attempt recoloring u to the lowest conflict-free color among 1..k\n            for col in range(1, k+1):\n                if col != cv and conflicts_for(u, col, neighbour) == 0:\n                    neighbour[u] = col\n                    move_desc = f\"ResolveEdgeRecolor(u={u+1},to={col})\"\n                    break\n            if move_desc == \"NO_MOVE\":\n                # Attempt recolor v\n                for col in range(1, k+1):\n                    if col != cu and conflicts_for(v, col, neighbour) == 0:\n                        neighbour[v] = col\n                        move_desc = f\"ResolveEdgeRecolor(v={v+1},to={col})\"\n                        break\n            if move_desc == \"NO_MOVE\":\n                # As a bounded expansion fallback, allow k+1 only if it strictly reduces immediate conflicts vs best in 1..k\n                best_existing = min(conflicts_for(u, col, neighbour) for col in range(1, k+1))\n                if conflicts_for(u, k+1, neighbour) < best_existing:\n                    neighbour[u] = k+1\n                    move_desc = f\"BoundedExpand(u={u+1},to={k+1})\"\n                else:\n                    best_existing_v = min(conflicts_for(v, col, neighbour) for col in range(1, k+1))\n                    if conflicts_for(v, k+1, neighbour) < best_existing_v:\n                        neighbour[v] = k+1\n                        move_desc = f\"BoundedExpand(v={v+1},to={k+1})\"\n            # Done conflict phase\n        else:\n            # Feasible: attempt to reduce k by emptying the highest color class without introducing conflicts\n            max_color = max(neighbour)\n            class_vertices = [i for i,c in enumerate(neighbour) if c == max_color]\n            # Try to reassign each vertex in the max color class to the smallest available color < max_color\n            moved_any = False\n            for vtx in class_vertices:\n                used = set(neighbour[w] for w in adj[vtx])\n                for col in range(1, max_color):\n                    if col not in used:\n                        neighbour[vtx] = col\n                        moved_any = True\n                        move_desc = f\"ReduceColor(v={vtx+1},to={col})\"\n                        break\n            # If we emptied the class, normalize labels\n            if moved_any and all(c != max_color for c in neighbour):\n                neighbour = normalize_full(neighbour)\n                move_desc = move_desc + \"|Compact\"\n            if move_desc == \"NO_MOVE\":\n                # Plateau shake within feasible set: pick a vertex and recolor to another non-conflicting existing color if possible\n                vtx = max(range(n), key=lambda u: (len(set(neighbour[w] for w in adj[u])), len(adj[u]), -u))\n                used = set(neighbour[w] for w in adj[vtx])\n                for col in range(1, max_color+1):\n                    if col != neighbour[vtx] and col not in used:\n                        neighbour[vtx] = col\n                        move_desc = f\"FeasibleRecolor(v={vtx+1},to={col})\"\n                        break\n        return (neighbour, move_desc)\n    except Exception:\n        return (solution, \"ERROR\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a valid LIST9_POSINT; applies Kempe-chain swap or multi-vertex recolor; keeps domain valid.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    cur = solution[:]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Normalize colors to 1..k preserving order of appearance\n    def normalize_colors_full(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Kempe-chain swap\n    def kempe_chain_swap(state: List[int]) -> List[int]:\n        kmax = max(state)\n        if kmax < 2:\n            return state\n        v0 = random.randrange(n)\n        c1 = state[v0]\n        neigh_colors = [state[w] for w in adj[v0]]\n        pool = [c for c in set(neigh_colors) if c != c1]\n        if not pool:\n            c2 = (c1 % kmax) + 1\n        else:\n            c2 = random.choice(pool)\n        # BFS\/DFS on (c1,c2)-component containing v0\n        seen = [False]*n\n        stack = [v0]\n        seen[v0] = True\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if not seen[w] and state[w] in (c1, c2):\n                    seen[w] = True\n                    stack.append(w)\n        for i in range(n):\n            if seen[i]:\n                state[i] = c1 if state[i] == c2 else (c2 if state[i] == c1 else state[i])\n        return state\n    # Apply 1-2 Kempe swaps and a small random recolor with bounded expansion\n    if random.random() < 0.9:\n        cur = kempe_chain_swap(cur)\n    if random.random() < 0.5:\n        cur = kempe_chain_swap(cur)\n    # Small subset targeted recolor\n    k = max(cur)\n    m = 3\n    vertices = list(range(n))\n    random.shuffle(vertices)\n    picked = vertices[:m]\n    for i in picked:\n        # choose among 1..k and optionally k+1 if it strictly decreases immediate conflicts vs best existing\n        def conf_for(col: int) -> int:\n            return sum(1 for nb in adj[i] if cur[nb] == col)\n        best_exist = None\n        best_col = None\n        for col in range(1, k+1):\n            cval = conf_for(col)\n            if best_exist is None or cval < best_exist or (cval == best_exist and (best_col is None or col < best_col)):\n                best_exist = cval\n                best_col = col\n        # consider k+1\n        if conf_for(k+1) < (best_exist if best_exist is not None else 10**9):\n            cur[i] = k+1\n            k = max(k, k+1)\n        else:\n            cur[i] = best_col if best_col is not None else cur[i]\n    cur = normalize_colors_full(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001411545}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Evaluate feasibility and color-count objective; smaller is better.\n    # Returns a numeric fitness: infeasible -> large penalty; feasible -> number of distinct colors\n    # Instance definition\n    n = 9\n    raw_edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # normalize edges: remove self-loops, duplicates, sort endpoints\n    E: List[Tuple[int,int]] = []\n    seen = set()\n    for (u,v) in raw_edges:\n        if not (isinstance(u,int) and isinstance(v,int)):\n            continue\n        if u == v:\n            continue\n        if u < 1 or u > n or v < 1 or v > n:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    # adjacency\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # validators\n    def domain_ok(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n    def is_feasible(sol: List[int]) -> bool:\n        # assumes domain_ok\n        for u,v in E:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n    # compute objective value (colors used)\n    def colors_used(sol: List[int]) -> int:\n        return len(set(sol))\n    # quick lower bound via greedy clique heuristic\n    def clique_lb() -> int:\n        # simple greedy: order by degree desc, iteratively build a clique\n        order = sorted(range(1,n+1), key=lambda i: len(adj[i]), reverse=True)\n        best = 1\n        for start in order:\n            clique = [start]\n            cand = [v for v in order if v != start and v in adj[start]]\n            while cand:\n                picked = None\n                for v in cand:\n                    ok = True\n                    for u in clique:\n                        if v not in adj[u]:\n                            ok = False\n                            break\n                    if ok:\n                        picked = v\n                        break\n                if picked is None:\n                    break\n                clique.append(picked)\n                cand = [v for v in cand if v != picked and all(v in adj[u] for u in clique)]\n            if len(clique) > best:\n                best = len(clique)\n        return best\n    # exact feasibility test for a given k using DSATUR backtracking\n    def can_color_with_k(k: int) -> bool:\n        if k < 1:\n            return False\n        # lower bound pruning\n        if clique_lb() > k:\n            return False\n        color = [0]*(n+1)  # 1-based nodes\n        uncolored = set(range(1,n+1))\n        degrees = {i: len(adj[i]) for i in range(1,n+1)}\n        def sat_deg(i: int) -> int:\n            return len({color[v] for v in adj[i] if color[v] != 0})\n        def select_node() -> int:\n            # DSATUR: highest saturation degree, tie-break by degree\n            return max(uncolored, key=lambda i: (sat_deg(i), degrees[i]))\n        def dfs() -> bool:\n            if not uncolored:\n                return True\n            node = select_node()\n            neighbor_colors = {color[v] for v in adj[node] if color[v] != 0}\n            for c in range(1, k+1):\n                if c in neighbor_colors:\n                    continue\n                color[node] = c\n                uncolored.remove(node)\n                # forward-checking\n                fc_ok = True\n                for w in adj[node]:\n                    if w in uncolored:\n                        used_w = {color[v] for v in adj[w] if color[v] != 0}\n                        if len(used_w) == k:\n                            fc_ok = False\n                            break\n                if fc_ok and dfs():\n                    return True\n                color[node] = 0\n                uncolored.add(node)\n            return False\n        return dfs()\n    # Main evaluation logic\n    if not domain_ok(solution):\n        return 1_000_000.0\n    if not is_feasible(solution):\n        # penalize by number of conflicts to give gradient\n        conflicts = 0\n        seen_pairs = set()\n        for u,v in E:\n            if solution[u-1] == solution[v-1]:\n                if (u,v) not in seen_pairs:\n                    conflicts += 1\n                    seen_pairs.add((u,v))\n        return 1_000_000.0 + conflicts\n    k = colors_used(solution)\n    # Minimality probe: if (k-1)-coloring exists, add tiny penalty to indicate non-minimality\n    if k > 1 and can_color_with_k(k-1):\n        return float(k) + 1e-3\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place single-vertex recolor; returns metadata only as required.\n    # Representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"invalid\", \"no-op\")\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in edges:\n        a,b = (u,v) if u < v else (v,u)\n        adj[a].add(b)\n        adj[b].add(a)\n    idx = random.randrange(n)\n    current_color = solution[idx]\n    # allowed colors: 1..max_color+1\n    maxc = max(1, max(solution))\n    candidate_colors = list(range(1, maxc+2))\n    # compute forbidden colors from neighbors\n    neighbor_colors = {solution[v-1] for v in adj[idx+1]}\n    feasible = [c for c in candidate_colors if c != current_color and c not in neighbor_colors]\n    if feasible:\n        # bias toward smaller colors to encourage compression\n        feasible.sort()\n        pick = random.choice(feasible[:min(3, len(feasible))])\n        solution[idx] = pick\n        return (\"recolor\", \"single-vertex\")\n    else:\n        # if no feasible different color, try color-swap with a random other vertex\n        j = (idx + 1 + random.randrange(n-1)) % n\n        if j == idx:\n            return (\"no-change\", \"stuck\")\n        solution[idx], solution[j] = solution[j], solution[idx]\n        return (\"swap\", \"pair-swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Return a new perturbed solution (does not modify input)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in edges:\n        a,b = (u,v) if u < v else (v,u)\n        adj[a].add(b)\n        adj[b].add(a)\n    new_sol = list(solution)\n    maxc = max(1, max(new_sol))\n    # random multi-vertex recolor\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        choices = [c for c in palette if c not in neighbor_colors]\n        if not choices:\n            choices = palette\n        new_sol[idx] = random.choice(choices)\n    # Kempe chain-like two-color swap to escape local minima\n    if random.random() < 0.7:\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick a random start vertex with color c1 or c2\n            verts = [i+1 for i,c in enumerate(new_sol) if c in (c1,c2)]\n            if verts:\n                start = random.choice(verts)\n                # BFS on subgraph induced by colors c1 and c2\n                queue = [start]\n                visited = set([start])\n                while queue:\n                    u = queue.pop(0)\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (c1,c2):\n                            visited.add(v)\n                            queue.append(v)\n                # swap colors on visited\n                for v in visited:\n                    new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # color compaction: relabel to 1..m to keep palette tight\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001430685}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Evaluate feasibility and color-count objective; smaller is better.\n    # Returns a numeric fitness: infeasible -> large penalty; feasible -> number of distinct colors\n    # Instance definition\n    n = 9\n    raw_edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # normalize edges: remove self-loops, duplicates, sort endpoints\n    E: List[Tuple[int,int]] = []\n    seen = set()\n    for (u,v) in raw_edges:\n        if not (isinstance(u,int) and isinstance(v,int)):\n            continue\n        if u == v:\n            continue\n        if u < 1 or u > n or v < 1 or v > n:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    # adjacency\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # validators\n    def domain_ok(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n    def is_feasible(sol: List[int]) -> bool:\n        # assumes domain_ok\n        for u,v in E:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n    # compute objective value (colors used)\n    def colors_used(sol: List[int]) -> int:\n        return len(set(sol))\n    # quick lower bound via greedy clique heuristic\n    def clique_lb() -> int:\n        # simple greedy: order by degree desc, iteratively build a clique\n        order = sorted(range(1,n+1), key=lambda i: len(adj[i]), reverse=True)\n        best = 1\n        for start in order:\n            clique = [start]\n            cand = [v for v in order if v != start and v in adj[start]]\n            while cand:\n                picked = None\n                for v in cand:\n                    ok = True\n                    for u in clique:\n                        if v not in adj[u]:\n                            ok = False\n                            break\n                    if ok:\n                        picked = v\n                        break\n                if picked is None:\n                    break\n                clique.append(picked)\n                cand = [v for v in cand if v != picked and all(v in adj[u] for u in clique)]\n            if len(clique) > best:\n                best = len(clique)\n        return best\n    # exact feasibility test for a given k using DSATUR backtracking\n    def can_color_with_k(k: int) -> bool:\n        if k < 1:\n            return False\n        # lower bound pruning\n        if clique_lb() > k:\n            return False\n        color = [0]*(n+1)  # 1-based nodes\n        uncolored = set(range(1,n+1))\n        degrees = {i: len(adj[i]) for i in range(1,n+1)}\n        def sat_deg(i: int) -> int:\n            return len({color[v] for v in adj[i] if color[v] != 0})\n        def select_node() -> int:\n            # DSATUR: highest saturation degree, tie-break by degree\n            return max(uncolored, key=lambda i: (sat_deg(i), degrees[i]))\n        def dfs() -> bool:\n            if not uncolored:\n                return True\n            node = select_node()\n            neighbor_colors = {color[v] for v in adj[node] if color[v] != 0}\n            for c in range(1, k+1):\n                if c in neighbor_colors:\n                    continue\n                color[node] = c\n                uncolored.remove(node)\n                # forward-checking\n                fc_ok = True\n                for w in adj[node]:\n                    if w in uncolored:\n                        used_w = {color[v] for v in adj[w] if color[v] != 0}\n                        if len(used_w) == k:\n                            fc_ok = False\n                            break\n                if fc_ok and dfs():\n                    return True\n                color[node] = 0\n                uncolored.add(node)\n            return False\n        return dfs()\n    # Main evaluation logic\n    if not domain_ok(solution):\n        return 1_000_000.0\n    if not is_feasible(solution):\n        # penalize by number of conflicts to give gradient\n        conflicts = 0\n        seen_pairs = set()\n        for u,v in E:\n            if solution[u-1] == solution[v-1]:\n                if (u,v) not in seen_pairs:\n                    conflicts += 1\n                    seen_pairs.add((u,v))\n        return 1_000_000.0 + conflicts\n    k = colors_used(solution)\n    # Minimality probe: if (k-1)-coloring exists, add tiny penalty to indicate non-minimality\n    if k > 1 and can_color_with_k(k-1):\n        return float(k) + 1e-3\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place single-vertex recolor; returns metadata only as required.\n    # Representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"invalid\", \"no-op\")\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in edges:\n        a,b = (u,v) if u < v else (v,u)\n        adj[a].add(b)\n        adj[b].add(a)\n    idx = random.randrange(n)\n    current_color = solution[idx]\n    # allowed colors: 1..max_color+1\n    maxc = max(1, max(solution))\n    candidate_colors = list(range(1, maxc+2))\n    # compute forbidden colors from neighbors\n    neighbor_colors = {solution[v-1] for v in adj[idx+1]}\n    feasible = [c for c in candidate_colors if c != current_color and c not in neighbor_colors]\n    if feasible:\n        # bias toward smaller colors to encourage compression\n        feasible.sort()\n        pick = random.choice(feasible[:min(3, len(feasible))])\n        solution[idx] = pick\n        return (\"recolor\", \"single-vertex\")\n    else:\n        # if no feasible different color, try color-swap with a random other vertex\n        j = (idx + 1 + random.randrange(n-1)) % n\n        if j == idx:\n            return (\"no-change\", \"stuck\")\n        solution[idx], solution[j] = solution[j], solution[idx]\n        return (\"swap\", \"pair-swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Return a new perturbed solution (does not modify input)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in edges:\n        a,b = (u,v) if u < v else (v,u)\n        adj[a].add(b)\n        adj[b].add(a)\n    new_sol = list(solution)\n    maxc = max(1, max(new_sol))\n    # random multi-vertex recolor\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        choices = [c for c in palette if c not in neighbor_colors]\n        if not choices:\n            choices = palette\n        new_sol[idx] = random.choice(choices)\n    # Kempe chain-like two-color swap to escape local minima\n    if random.random() < 0.7:\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick a random start vertex with color c1 or c2\n            verts = [i+1 for i,c in enumerate(new_sol) if c in (c1,c2)]\n            if verts:\n                start = random.choice(verts)\n                # BFS on subgraph induced by colors c1 and c2\n                queue = [start]\n                visited = set([start])\n                while queue:\n                    u = queue.pop(0)\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (c1,c2):\n                            visited.add(v)\n                            queue.append(v)\n                # swap colors on visited\n                for v in visited:\n                    new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # color compaction: relabel to 1..m to keep palette tight\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001609167}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Evaluate feasibility and color-count objective; smaller is better.\n    # Returns a numeric fitness: infeasible -> large penalty; feasible -> number of distinct colors\n    # Instance definition\n    n = 9\n    raw_edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # normalize edges: remove self-loops, duplicates, sort endpoints\n    E: List[Tuple[int,int]] = []\n    seen = set()\n    for (u,v) in raw_edges:\n        if not (isinstance(u,int) and isinstance(v,int)):\n            continue\n        if u == v:\n            continue\n        if u < 1 or u > n or v < 1 or v > n:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    # adjacency\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # validators\n    def domain_ok(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n    def is_feasible(sol: List[int]) -> bool:\n        # assumes domain_ok\n        for u,v in E:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n    # compute objective value (colors used)\n    def colors_used(sol: List[int]) -> int:\n        return len(set(sol))\n    # quick lower bound via greedy clique heuristic\n    def clique_lb() -> int:\n        # simple greedy: order by degree desc, iteratively build a clique\n        order = sorted(range(1,n+1), key=lambda i: len(adj[i]), reverse=True)\n        best = 1\n        for start in order:\n            clique = [start]\n            cand = [v for v in order if v != start and v in adj[start]]\n            while cand:\n                picked = None\n                for v in cand:\n                    ok = True\n                    for u in clique:\n                        if v not in adj[u]:\n                            ok = False\n                            break\n                    if ok:\n                        picked = v\n                        break\n                if picked is None:\n                    break\n                clique.append(picked)\n                cand = [v for v in cand if v != picked and all(v in adj[u] for u in clique)]\n            if len(clique) > best:\n                best = len(clique)\n        return best\n    # exact feasibility test for a given k using DSATUR backtracking\n    def can_color_with_k(k: int) -> bool:\n        if k < 1:\n            return False\n        # lower bound pruning\n        if clique_lb() > k:\n            return False\n        color = [0]*(n+1)  # 1-based nodes\n        uncolored = set(range(1,n+1))\n        degrees = {i: len(adj[i]) for i in range(1,n+1)}\n        def sat_deg(i: int) -> int:\n            return len({color[v] for v in adj[i] if color[v] != 0})\n        def select_node() -> int:\n            # DSATUR: highest saturation degree, tie-break by degree\n            return max(uncolored, key=lambda i: (sat_deg(i), degrees[i]))\n        def dfs() -> bool:\n            if not uncolored:\n                return True\n            node = select_node()\n            neighbor_colors = {color[v] for v in adj[node] if color[v] != 0}\n            for c in range(1, k+1):\n                if c in neighbor_colors:\n                    continue\n                color[node] = c\n                uncolored.remove(node)\n                # forward-checking\n                fc_ok = True\n                for w in adj[node]:\n                    if w in uncolored:\n                        used_w = {color[v] for v in adj[w] if color[v] != 0}\n                        if len(used_w) == k:\n                            fc_ok = False\n                            break\n                if fc_ok and dfs():\n                    return True\n                color[node] = 0\n                uncolored.add(node)\n            return False\n        return dfs()\n    # Main evaluation logic\n    if not domain_ok(solution):\n        return 1_000_000.0\n    if not is_feasible(solution):\n        # penalize by number of conflicts to give gradient\n        conflicts = 0\n        seen_pairs = set()\n        for u,v in E:\n            if solution[u-1] == solution[v-1]:\n                if (u,v) not in seen_pairs:\n                    conflicts += 1\n                    seen_pairs.add((u,v))\n        return 1_000_000.0 + conflicts\n    k = colors_used(solution)\n    # Minimality probe: if (k-1)-coloring exists, add tiny penalty to indicate non-minimality\n    if k > 1 and can_color_with_k(k-1):\n        return float(k) + 1e-3\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place single-vertex recolor; returns metadata only as required.\n    # Representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (\"invalid\", \"no-op\")\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in edges:\n        a,b = (u,v) if u < v else (v,u)\n        adj[a].add(b)\n        adj[b].add(a)\n    idx = random.randrange(n)\n    current_color = solution[idx]\n    # allowed colors: 1..max_color+1\n    maxc = max(1, max(solution))\n    candidate_colors = list(range(1, maxc+2))\n    # compute forbidden colors from neighbors\n    neighbor_colors = {solution[v-1] for v in adj[idx+1]}\n    feasible = [c for c in candidate_colors if c != current_color and c not in neighbor_colors]\n    if feasible:\n        # bias toward smaller colors to encourage compression\n        feasible.sort()\n        pick = random.choice(feasible[:min(3, len(feasible))])\n        solution[idx] = pick\n        return (\"recolor\", \"single-vertex\")\n    else:\n        # if no feasible different color, try color-swap with a random other vertex\n        j = (idx + 1 + random.randrange(n-1)) % n\n        if j == idx:\n            return (\"no-change\", \"stuck\")\n        solution[idx], solution[j] = solution[j], solution[idx]\n        return (\"swap\", \"pair-swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Return a new perturbed solution (does not modify input)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i:set() for i in range(1,n+1)}\n    for u,v in edges:\n        a,b = (u,v) if u < v else (v,u)\n        adj[a].add(b)\n        adj[b].add(a)\n    new_sol = list(solution)\n    maxc = max(1, max(new_sol))\n    # random multi-vertex recolor\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        choices = [c for c in palette if c not in neighbor_colors]\n        if not choices:\n            choices = palette\n        new_sol[idx] = random.choice(choices)\n    # Kempe chain-like two-color swap to escape local minima\n    if random.random() < 0.7:\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick a random start vertex with color c1 or c2\n            verts = [i+1 for i,c in enumerate(new_sol) if c in (c1,c2)]\n            if verts:\n                start = random.choice(verts)\n                # BFS on subgraph induced by colors c1 and c2\n                queue = [start]\n                visited = set([start])\n                while queue:\n                    u = queue.pop(0)\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (c1,c2):\n                            visited.add(v)\n                            queue.append(v)\n                # swap colors on visited\n                for v in visited:\n                    new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # color compaction: relabel to 1..m to keep palette tight\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001556767}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Composite objective: f = 100*conflicts + num_colors (smaller is better)\n    # Domain and instance are embedded locally to satisfy isolation constraints\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain check\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of colors used\n    num_colors = len(set(solution))\n    # Composite score\n    return float(100 * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution (no in-place mutation).\n    # Strategy: conflict-directed recolor; if no conflicts, attempt color compaction; occasional Kempe-chain swap.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else [1]*n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(solution)\n    # Helper: conflicts of each vertex\n    conflict_vertices = []\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    conflict_vertices = list(set(conflict_vertices))\n    maxc = max(1, max(new_sol))\n    # With small probability, do a Kempe-chain swap for diversification\n    if random.random() < 0.15:\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick a random start vertex with color c1 or c2\n            verts = [i for i, c in enumerate(new_sol, start=1) if c in (c1, c2)]\n            if verts:\n                start = random.choice(verts)\n                # BFS over subgraph induced by colors c1 and c2\n                queue = [start]\n                visited = {start}\n                while queue:\n                    u = queue.pop(0)\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (c1, c2):\n                            visited.add(v)\n                            queue.append(v)\n                for v in visited:\n                    new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n                return new_sol\n    # If there are conflicts, pick a conflicted vertex to recolor\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))  # allow introducing at most one new color\n        # Prefer lowest feasible color not equal to current\n        candidates = [c for c in palette if c != new_sol[idx] and c not in neighbor_colors]\n        if not candidates:\n            # fallback: random color from palette to shake\n            new_sol[idx] = random.choice(palette)\n        else:\n            # epsilon-greedy: mostly smallest color, sometimes diversify\n            candidates.sort()\n            if random.random() < 0.85:\n                new_sol[idx] = candidates[0]\n            else:\n                new_sol[idx] = random.choice(candidates)\n        return new_sol\n    # No conflicts: try compaction by lowering colors when possible\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Try to assign the smallest feasible color <= current\n        for c in range(1, max(current, 2)):\n            if c not in neighbor_colors and c != current:\n                new_sol[idx] = c\n                return new_sol\n    # If compaction failed, do a harmless swap of two vertices with different colors\n    i, j = random.sample(range(n), 2)\n    if new_sol[i] != new_sol[j]:\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Returns a NEW perturbed solution. Multi-vertex recolors + 1-2 Kempe-chain shakes and color relabeling.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else [1]*n\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(solution)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices, preferring feasible small colors\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        choices = [c for c in palette if c not in neighbor_colors]\n        if not choices:\n            choices = palette\n        # slight bias to smaller\n        choices.sort()\n        pick = choices[0] if random.random() < 0.7 else random.choice(choices)\n        new_sol[idx] = pick\n    # Perform 1-2 Kempe-chain swaps to escape local minima\n    shakes = random.randint(1, 2)\n    for _ in range(shakes):\n        colors = list(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        verts = [i for i, c in enumerate(new_sol, start=1) if c in (c1, c2)]\n        if not verts:\n            continue\n        start = random.choice(verts)\n        queue = [start]\n        visited = {start}\n        while queue:\n            u = queue.pop(0)\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (c1, c2):\n                    visited.add(v)\n                    queue.append(v)\n        for v in visited:\n            new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Color compaction: relabel used colors to 1..m to keep palette tight\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00087867}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Composite objective: f = 100*conflicts + num_colors (smaller is better)\n    # Domain and instance are embedded locally to satisfy isolation constraints\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain check\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of colors used\n    num_colors = len(set(solution))\n    # Composite score\n    return float(100 * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution (no in-place mutation).\n    # Strategy: conflict-directed recolor; if no conflicts, attempt color compaction; occasional Kempe-chain swap.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else [1]*n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(solution)\n    # Helper: conflicts of each vertex\n    conflict_vertices = []\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    conflict_vertices = list(set(conflict_vertices))\n    maxc = max(1, max(new_sol))\n    # With small probability, do a Kempe-chain swap for diversification\n    if random.random() < 0.15:\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick a random start vertex with color c1 or c2\n            verts = [i for i, c in enumerate(new_sol, start=1) if c in (c1, c2)]\n            if verts:\n                start = random.choice(verts)\n                # BFS over subgraph induced by colors c1 and c2\n                queue = [start]\n                visited = {start}\n                while queue:\n                    u = queue.pop(0)\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (c1, c2):\n                            visited.add(v)\n                            queue.append(v)\n                for v in visited:\n                    new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n                return new_sol\n    # If there are conflicts, pick a conflicted vertex to recolor\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))  # allow introducing at most one new color\n        # Prefer lowest feasible color not equal to current\n        candidates = [c for c in palette if c != new_sol[idx] and c not in neighbor_colors]\n        if not candidates:\n            # fallback: random color from palette to shake\n            new_sol[idx] = random.choice(palette)\n        else:\n            # epsilon-greedy: mostly smallest color, sometimes diversify\n            candidates.sort()\n            if random.random() < 0.85:\n                new_sol[idx] = candidates[0]\n            else:\n                new_sol[idx] = random.choice(candidates)\n        return new_sol\n    # No conflicts: try compaction by lowering colors when possible\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Try to assign the smallest feasible color <= current\n        for c in range(1, max(current, 2)):\n            if c not in neighbor_colors and c != current:\n                new_sol[idx] = c\n                return new_sol\n    # If compaction failed, do a harmless swap of two vertices with different colors\n    i, j = random.sample(range(n), 2)\n    if new_sol[i] != new_sol[j]:\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Returns a NEW perturbed solution. Multi-vertex recolors + 1-2 Kempe-chain shakes and color relabeling.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else [1]*n\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(solution)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices, preferring feasible small colors\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        choices = [c for c in palette if c not in neighbor_colors]\n        if not choices:\n            choices = palette\n        # slight bias to smaller\n        choices.sort()\n        pick = choices[0] if random.random() < 0.7 else random.choice(choices)\n        new_sol[idx] = pick\n    # Perform 1-2 Kempe-chain swaps to escape local minima\n    shakes = random.randint(1, 2)\n    for _ in range(shakes):\n        colors = list(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        verts = [i for i, c in enumerate(new_sol, start=1) if c in (c1, c2)]\n        if not verts:\n            continue\n        start = random.choice(verts)\n        queue = [start]\n        visited = {start}\n        while queue:\n            u = queue.pop(0)\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (c1, c2):\n                    visited.add(v)\n                    queue.append(v)\n        for v in visited:\n            new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Color compaction: relabel used colors to 1..m to keep palette tight\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001141873}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Composite objective: f = 100*conflicts + num_colors (smaller is better)\n    # Domain and instance are embedded locally to satisfy isolation constraints\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain check\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of colors used\n    num_colors = len(set(solution))\n    # Composite score\n    return float(100 * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution (no in-place mutation).\n    # Strategy: conflict-directed recolor; if no conflicts, attempt color compaction; occasional Kempe-chain swap.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else [1]*n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(solution)\n    # Helper: conflicts of each vertex\n    conflict_vertices = []\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    conflict_vertices = list(set(conflict_vertices))\n    maxc = max(1, max(new_sol))\n    # With small probability, do a Kempe-chain swap for diversification\n    if random.random() < 0.15:\n        colors = list(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick a random start vertex with color c1 or c2\n            verts = [i for i, c in enumerate(new_sol, start=1) if c in (c1, c2)]\n            if verts:\n                start = random.choice(verts)\n                # BFS over subgraph induced by colors c1 and c2\n                queue = [start]\n                visited = {start}\n                while queue:\n                    u = queue.pop(0)\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (c1, c2):\n                            visited.add(v)\n                            queue.append(v)\n                for v in visited:\n                    new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n                return new_sol\n    # If there are conflicts, pick a conflicted vertex to recolor\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))  # allow introducing at most one new color\n        # Prefer lowest feasible color not equal to current\n        candidates = [c for c in palette if c != new_sol[idx] and c not in neighbor_colors]\n        if not candidates:\n            # fallback: random color from palette to shake\n            new_sol[idx] = random.choice(palette)\n        else:\n            # epsilon-greedy: mostly smallest color, sometimes diversify\n            candidates.sort()\n            if random.random() < 0.85:\n                new_sol[idx] = candidates[0]\n            else:\n                new_sol[idx] = random.choice(candidates)\n        return new_sol\n    # No conflicts: try compaction by lowering colors when possible\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Try to assign the smallest feasible color <= current\n        for c in range(1, max(current, 2)):\n            if c not in neighbor_colors and c != current:\n                new_sol[idx] = c\n                return new_sol\n    # If compaction failed, do a harmless swap of two vertices with different colors\n    i, j = random.sample(range(n), 2)\n    if new_sol[i] != new_sol[j]:\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Returns a NEW perturbed solution. Multi-vertex recolors + 1-2 Kempe-chain shakes and color relabeling.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else [1]*n\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(solution)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices, preferring feasible small colors\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        choices = [c for c in palette if c not in neighbor_colors]\n        if not choices:\n            choices = palette\n        # slight bias to smaller\n        choices.sort()\n        pick = choices[0] if random.random() < 0.7 else random.choice(choices)\n        new_sol[idx] = pick\n    # Perform 1-2 Kempe-chain swaps to escape local minima\n    shakes = random.randint(1, 2)\n    for _ in range(shakes):\n        colors = list(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        verts = [i for i, c in enumerate(new_sol, start=1) if c in (c1, c2)]\n        if not verts:\n            continue\n        start = random.choice(verts)\n        queue = [start]\n        visited = {start}\n        while queue:\n            u = queue.pop(0)\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (c1, c2):\n                    visited.add(v)\n                    queue.append(v)\n        for v in visited:\n            new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Color compaction: relabel used colors to 1..m to keep palette tight\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001093382}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1000000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1000000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    num_colors = len(set(solution))\n    # Composite objective (minimize)\n    return float(100 * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution as a length-9 positive-int list.\n    # Strategy order:\n    # 1) If conflicts exist: recolor a conflicted vertex using smallest feasible color from current palette (allow +1 new color only if necessary).\n    # 2) If no conflicts: attempt deterministic color-lowering (compaction) for a randomly chosen vertex.\n    # 3) If compaction not possible: perform a small Kempe-chain swap between two colors to diversify while preserving feasibility.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Detect conflicts\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    maxc = max(1, max(new_sol))\n    # 1) Conflict-directed recolor\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices)) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Prefer colors within current palette [1..maxc]\n        candidates = [c for c in range(1, maxc+1) if c != new_sol[idx] and c not in neighbor_colors]\n        if candidates:\n            new_sol[idx] = min(candidates)\n            return new_sol\n        # Allow at most one new color if no feasible within current palette\n        new_color = maxc + 1\n        new_sol[idx] = new_color\n        return new_sol\n    # 2) No conflicts: try color-lowering compaction on a random order\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Try smallest feasible color <= current\n        for c in range(1, current):\n            if c not in neighbor_colors:\n                new_sol[idx] = c\n                return new_sol\n    # 3) Kempe-chain swap between two existing colors to diversify while attempting to preserve feasibility\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # pick a random start vertex with color c1 or c2\n        candidates = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            # BFS on subgraph induced by colors {c1,c2}\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            # Swap colors on visited component\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n            return new_sol\n    # Fallback: relabel highest color to lowest unused color if possible (no-op safe)\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Returns a NEW perturbed solution for ILS\/restarts.\n    # Multi-vertex recoloring with bias to small feasible colors + 1 Kempe-chain shake + color normalization.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))  # allow at most one new color\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            feasible.sort()\n            # 70% pick smallest feasible, else random feasible\n            new_sol[idx] = feasible[0] if random.random() < 0.7 else random.choice(feasible)\n        else:\n            new_sol[idx] = random.choice(palette)\n    # One Kempe-chain shake\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        comp_nodes = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if comp_nodes:\n            start = random.choice(comp_nodes)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Normalize colors to contiguous range 1..m (stable order)\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00085225}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1000000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1000000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    num_colors = len(set(solution))\n    # Composite objective (minimize)\n    return float(100 * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution as a length-9 positive-int list.\n    # Strategy order:\n    # 1) If conflicts exist: recolor a conflicted vertex using smallest feasible color from current palette (allow +1 new color only if necessary).\n    # 2) If no conflicts: attempt deterministic color-lowering (compaction) for a randomly chosen vertex.\n    # 3) If compaction not possible: perform a small Kempe-chain swap between two colors to diversify while preserving feasibility.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Detect conflicts\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    maxc = max(1, max(new_sol))\n    # 1) Conflict-directed recolor\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices)) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Prefer colors within current palette [1..maxc]\n        candidates = [c for c in range(1, maxc+1) if c != new_sol[idx] and c not in neighbor_colors]\n        if candidates:\n            new_sol[idx] = min(candidates)\n            return new_sol\n        # Allow at most one new color if no feasible within current palette\n        new_color = maxc + 1\n        new_sol[idx] = new_color\n        return new_sol\n    # 2) No conflicts: try color-lowering compaction on a random order\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Try smallest feasible color <= current\n        for c in range(1, current):\n            if c not in neighbor_colors:\n                new_sol[idx] = c\n                return new_sol\n    # 3) Kempe-chain swap between two existing colors to diversify while attempting to preserve feasibility\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # pick a random start vertex with color c1 or c2\n        candidates = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            # BFS on subgraph induced by colors {c1,c2}\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            # Swap colors on visited component\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n            return new_sol\n    # Fallback: relabel highest color to lowest unused color if possible (no-op safe)\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Returns a NEW perturbed solution for ILS\/restarts.\n    # Multi-vertex recoloring with bias to small feasible colors + 1 Kempe-chain shake + color normalization.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))  # allow at most one new color\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            feasible.sort()\n            # 70% pick smallest feasible, else random feasible\n            new_sol[idx] = feasible[0] if random.random() < 0.7 else random.choice(feasible)\n        else:\n            new_sol[idx] = random.choice(palette)\n    # One Kempe-chain shake\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        comp_nodes = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if comp_nodes:\n            start = random.choice(comp_nodes)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Normalize colors to contiguous range 1..m (stable order)\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001126853}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1000000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1000000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    num_colors = len(set(solution))\n    # Composite objective (minimize)\n    return float(100 * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution as a length-9 positive-int list.\n    # Strategy order:\n    # 1) If conflicts exist: recolor a conflicted vertex using smallest feasible color from current palette (allow +1 new color only if necessary).\n    # 2) If no conflicts: attempt deterministic color-lowering (compaction) for a randomly chosen vertex.\n    # 3) If compaction not possible: perform a small Kempe-chain swap between two colors to diversify while preserving feasibility.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Detect conflicts\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    maxc = max(1, max(new_sol))\n    # 1) Conflict-directed recolor\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices)) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Prefer colors within current palette [1..maxc]\n        candidates = [c for c in range(1, maxc+1) if c != new_sol[idx] and c not in neighbor_colors]\n        if candidates:\n            new_sol[idx] = min(candidates)\n            return new_sol\n        # Allow at most one new color if no feasible within current palette\n        new_color = maxc + 1\n        new_sol[idx] = new_color\n        return new_sol\n    # 2) No conflicts: try color-lowering compaction on a random order\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        # Try smallest feasible color <= current\n        for c in range(1, current):\n            if c not in neighbor_colors:\n                new_sol[idx] = c\n                return new_sol\n    # 3) Kempe-chain swap between two existing colors to diversify while attempting to preserve feasibility\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # pick a random start vertex with color c1 or c2\n        candidates = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            # BFS on subgraph induced by colors {c1,c2}\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            # Swap colors on visited component\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n            return new_sol\n    # Fallback: relabel highest color to lowest unused color if possible (no-op safe)\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Returns a NEW perturbed solution for ILS\/restarts.\n    # Multi-vertex recoloring with bias to small feasible colors + 1 Kempe-chain shake + color normalization.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))  # allow at most one new color\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            feasible.sort()\n            # 70% pick smallest feasible, else random feasible\n            new_sol[idx] = feasible[0] if random.random() < 0.7 else random.choice(feasible)\n        else:\n            new_sol[idx] = random.choice(palette)\n    # One Kempe-chain shake\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        comp_nodes = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if comp_nodes:\n            start = random.choice(comp_nodes)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Normalize colors to contiguous range 1..m (stable order)\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001051352}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1_000_000.0\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    num_colors = len(set(solution))\n    # Penalty big-M strictly larger than max feasible color count; use |E|+1\n    M = len(edges) + 1\n    return float(M * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution as a length-9 positive-int list.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Detect conflicts\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    maxc = max(1, max(new_sol))\n    # 1) Conflict-directed recolor using smallest feasible color; allow +1 color only if necessary\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices)) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        candidates = [c for c in range(1, maxc+1) if c != new_sol[idx] and c not in neighbor_colors]\n        if candidates:\n            new_sol[idx] = min(candidates)\n            return new_sol\n        new_sol[idx] = maxc + 1\n        return new_sol\n    # 2) No conflicts: attempt color-lowering compaction on a random order\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        for c in range(1, current):\n            if c not in neighbor_colors:\n                new_sol[idx] = c\n                return new_sol\n    # 3) Kempe-chain swap between two existing colors to diversify\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n            return new_sol\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Returns a NEW perturbed solution for diversification.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices (allow at most one new color)\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            feasible.sort()\n            new_sol[idx] = feasible[0] if random.random() < 0.7 else random.choice(feasible)\n        else:\n            new_sol[idx] = random.choice(palette)\n    # One Kempe-chain shake\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        comp_nodes = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if comp_nodes:\n            start = random.choice(comp_nodes)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Normalize colors to contiguous 1..m\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000890691}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1_000_000.0\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    num_colors = len(set(solution))\n    # Penalty big-M strictly larger than max feasible color count; use |E|+1\n    M = len(edges) + 1\n    return float(M * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution as a length-9 positive-int list.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Detect conflicts\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    maxc = max(1, max(new_sol))\n    # 1) Conflict-directed recolor using smallest feasible color; allow +1 color only if necessary\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices)) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        candidates = [c for c in range(1, maxc+1) if c != new_sol[idx] and c not in neighbor_colors]\n        if candidates:\n            new_sol[idx] = min(candidates)\n            return new_sol\n        new_sol[idx] = maxc + 1\n        return new_sol\n    # 2) No conflicts: attempt color-lowering compaction on a random order\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        for c in range(1, current):\n            if c not in neighbor_colors:\n                new_sol[idx] = c\n                return new_sol\n    # 3) Kempe-chain swap between two existing colors to diversify\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n            return new_sol\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Returns a NEW perturbed solution for diversification.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices (allow at most one new color)\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            feasible.sort()\n            new_sol[idx] = feasible[0] if random.random() < 0.7 else random.choice(feasible)\n        else:\n            new_sol[idx] = random.choice(palette)\n    # One Kempe-chain shake\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        comp_nodes = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if comp_nodes:\n            start = random.choice(comp_nodes)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Normalize colors to contiguous 1..m\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001097503}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_parties_with_exes_standard","Representacion":"INDEX_LIST_INT_POSITIVE_LEN_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000.0\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 1_000_000.0\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    num_colors = len(set(solution))\n    # Penalty big-M strictly larger than max feasible color count; use |E|+1\n    M = len(edges) + 1\n    return float(M * conflicts + num_colors)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a NEW neighbor solution as a length-9 positive-int list.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Detect conflicts\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    maxc = max(1, max(new_sol))\n    # 1) Conflict-directed recolor using smallest feasible color; allow +1 color only if necessary\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices)) - 1\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        candidates = [c for c in range(1, maxc+1) if c != new_sol[idx] and c not in neighbor_colors]\n        if candidates:\n            new_sol[idx] = min(candidates)\n            return new_sol\n        new_sol[idx] = maxc + 1\n        return new_sol\n    # 2) No conflicts: attempt color-lowering compaction on a random order\n    order = list(range(n))\n    random.shuffle(order)\n    for idx in order:\n        current = new_sol[idx]\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        for c in range(1, current):\n            if c not in neighbor_colors:\n                new_sol[idx] = c\n                return new_sol\n    # 3) Kempe-chain swap between two existing colors to diversify\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        candidates = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if candidates:\n            start = random.choice(candidates)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n            return new_sol\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Returns a NEW perturbed solution for diversification.\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    new_sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    maxc = max(1, max(new_sol))\n    # Recolor k random vertices (allow at most one new color)\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        neighbor_colors = {new_sol[v-1] for v in adj[idx+1]}\n        palette = list(range(1, maxc+2))\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            feasible.sort()\n            new_sol[idx] = feasible[0] if random.random() < 0.7 else random.choice(feasible)\n        else:\n            new_sol[idx] = random.choice(palette)\n    # One Kempe-chain shake\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        comp_nodes = [i for i, col in enumerate(new_sol, start=1) if col in (c1, c2)]\n        if comp_nodes:\n            start = random.choice(comp_nodes)\n            queue = [start]\n            visited = {start}\n            while queue and len(visited) <= n:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (c1, c2):\n                        visited.add(v)\n                        queue.append(v)\n            for v in visited:\n                new_sol[v-1] = c2 if new_sol[v-1] == c1 else c1\n    # Normalize colors to contiguous 1..m\n    mapping = {}\n    nextc = 1\n    for c in sorted(set(new_sol)):\n        mapping[c] = nextc\n        nextc += 1\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001011621}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Canonicalize labels to 1..k (no gaps)\n    remap = {}\n    next_label = 1\n    colors = [0]*n\n    for i, x in enumerate(solution):\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n        colors[i] = remap[x]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**10 + conflicts  # infeasible penalty\n    k_used = len(set(colors))\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].add(v)\n        adj[v].add(u)\n    # Order vertices by degree desc (for pruning)\n    order = sorted(range(n), key=lambda i: -len(adj[i]))\n    # Backtracking check if colorable with k\n    def can_color_with(k):\n        assigned = [0]*n\n        def bt(idx):\n            if idx == n:\n                return True\n            v = order[idx]\n            used = set()\n            for u in adj[v]:\n                c = assigned[u]\n                if c:\n                    used.add(c)\n            for c in range(1, k+1):\n                if c not in used:\n                    assigned[v] = c\n                    if bt(idx+1):\n                        return True\n                    assigned[v] = 0\n            return False\n        return bt(0)\n    k_opt = None\n    for k in range(1, n+1):\n        if can_color_with(k):\n            k_opt = k\n            break\n    if k_opt is None:\n        return 10**12\n    if k_used == k_opt:\n        return k_opt\n    else:\n        return k_used + 1000\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    import copy\n    # Fallback random initialization if input invalid\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # random 4-color assignment\n        return ([random.randint(1, 4) for _ in range(9)], \"random_init\")\n    def canonicalize(sol):\n        remap = {}\n        next_label = 1\n        out = []\n        for x in sol:\n            if x not in remap:\n                remap[x] = next_label\n                next_label += 1\n            out.append(remap[x])\n        return out\n    curr = canonicalize(solution)\n    k = len(set(curr))\n    move = random.random()\n    if move < 0.7:\n        # Recolor one vertex to a different color in [1..k+1]\n        i = random.randrange(9)\n        new = curr[:]\n        # choose a color different from current\n        choices = list(range(1, k+2))\n        choices.remove(curr[i])\n        new[i] = random.choice(choices)\n        new = canonicalize(new)\n        return (new, \"recolor_one\")\n    else:\n        # Swap two existing color labels globally (diversification)\n        if k < 2:\n            # If only one color present, recolor one instead\n            i = random.randrange(9)\n            new = curr[:]\n            choices = [2]\n            new[i] = 2\n            new = canonicalize(new)\n            return (new, \"recolor_one_bootstrap\")\n        a, b = random.sample(list(range(1, k+1)), 2)\n        new = [b if x == a else a if x == b else x for x in curr]\n        new = canonicalize(new)\n        return (new, \"swap_colors\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Multi-move perturbation for escaping local minima\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [random.randint(1, 4) for _ in range(9)]\n    def canonicalize(sol):\n        remap = {}\n        next_label = 1\n        out = []\n        for x in sol:\n            if x not in remap:\n                remap[x] = next_label\n                next_label += 1\n            out.append(remap[x])\n        return out\n    curr = canonicalize(solution)\n    k = len(set(curr))\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        # choose between recolor or color-swap\n        if random.random() < 0.6:\n            i = random.randrange(9)\n            choices = list(range(1, k+2))\n            if curr[i] in choices:\n                choices.remove(curr[i])\n            curr[i] = random.choice(choices)\n        else:\n            if k >= 2:\n                a, b = random.sample(list(range(1, k+1)), 2)\n                curr = [b if x == a else a if x == b else x for x in curr]\n        curr = canonicalize(curr)\n        k = len(set(curr))\n    return curr\n","Resultados":[[1,2,3,1,4,4,1,4,3],10000000004,[1,2,3,4,1,1,2,5,3],10000000002],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001284886}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Canonicalize labels to 1..k (no gaps)\n    remap = {}\n    next_label = 1\n    colors = [0]*n\n    for i, x in enumerate(solution):\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n        colors[i] = remap[x]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**10 + conflicts  # infeasible penalty\n    k_used = len(set(colors))\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].add(v)\n        adj[v].add(u)\n    # Order vertices by degree desc (for pruning)\n    order = sorted(range(n), key=lambda i: -len(adj[i]))\n    # Backtracking check if colorable with k\n    def can_color_with(k):\n        assigned = [0]*n\n        def bt(idx):\n            if idx == n:\n                return True\n            v = order[idx]\n            used = set()\n            for u in adj[v]:\n                c = assigned[u]\n                if c:\n                    used.add(c)\n            for c in range(1, k+1):\n                if c not in used:\n                    assigned[v] = c\n                    if bt(idx+1):\n                        return True\n                    assigned[v] = 0\n            return False\n        return bt(0)\n    k_opt = None\n    for k in range(1, n+1):\n        if can_color_with(k):\n            k_opt = k\n            break\n    if k_opt is None:\n        return 10**12\n    if k_used == k_opt:\n        return k_opt\n    else:\n        return k_used + 1000\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    import copy\n    # Fallback random initialization if input invalid\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # random 4-color assignment\n        return ([random.randint(1, 4) for _ in range(9)], \"random_init\")\n    def canonicalize(sol):\n        remap = {}\n        next_label = 1\n        out = []\n        for x in sol:\n            if x not in remap:\n                remap[x] = next_label\n                next_label += 1\n            out.append(remap[x])\n        return out\n    curr = canonicalize(solution)\n    k = len(set(curr))\n    move = random.random()\n    if move < 0.7:\n        # Recolor one vertex to a different color in [1..k+1]\n        i = random.randrange(9)\n        new = curr[:]\n        # choose a color different from current\n        choices = list(range(1, k+2))\n        choices.remove(curr[i])\n        new[i] = random.choice(choices)\n        new = canonicalize(new)\n        return (new, \"recolor_one\")\n    else:\n        # Swap two existing color labels globally (diversification)\n        if k < 2:\n            # If only one color present, recolor one instead\n            i = random.randrange(9)\n            new = curr[:]\n            choices = [2]\n            new[i] = 2\n            new = canonicalize(new)\n            return (new, \"recolor_one_bootstrap\")\n        a, b = random.sample(list(range(1, k+1)), 2)\n        new = [b if x == a else a if x == b else x for x in curr]\n        new = canonicalize(new)\n        return (new, \"swap_colors\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Multi-move perturbation for escaping local minima\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [random.randint(1, 4) for _ in range(9)]\n    def canonicalize(sol):\n        remap = {}\n        next_label = 1\n        out = []\n        for x in sol:\n            if x not in remap:\n                remap[x] = next_label\n                next_label += 1\n            out.append(remap[x])\n        return out\n    curr = canonicalize(solution)\n    k = len(set(curr))\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        # choose between recolor or color-swap\n        if random.random() < 0.6:\n            i = random.randrange(9)\n            choices = list(range(1, k+2))\n            if curr[i] in choices:\n                choices.remove(curr[i])\n            curr[i] = random.choice(choices)\n        else:\n            if k >= 2:\n                a, b = random.sample(list(range(1, k+1)), 2)\n                curr = [b if x == a else a if x == b else x for x in curr]\n        curr = canonicalize(curr)\n        k = len(set(curr))\n    return curr\n","Resultados":[[1,2,3,2,2,2,3,1,3],10000000011,[1,2,2,3,4,5,4,6,3],10000000002],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00169479}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Canonicalize labels to 1..k (no gaps)\n    remap = {}\n    next_label = 1\n    colors = [0]*n\n    for i, x in enumerate(solution):\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n        colors[i] = remap[x]\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**10 + conflicts  # infeasible penalty\n    k_used = len(set(colors))\n    # Build adjacency\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].add(v)\n        adj[v].add(u)\n    # Order vertices by degree desc (for pruning)\n    order = sorted(range(n), key=lambda i: -len(adj[i]))\n    # Backtracking check if colorable with k\n    def can_color_with(k):\n        assigned = [0]*n\n        def bt(idx):\n            if idx == n:\n                return True\n            v = order[idx]\n            used = set()\n            for u in adj[v]:\n                c = assigned[u]\n                if c:\n                    used.add(c)\n            for c in range(1, k+1):\n                if c not in used:\n                    assigned[v] = c\n                    if bt(idx+1):\n                        return True\n                    assigned[v] = 0\n            return False\n        return bt(0)\n    k_opt = None\n    for k in range(1, n+1):\n        if can_color_with(k):\n            k_opt = k\n            break\n    if k_opt is None:\n        return 10**12\n    if k_used == k_opt:\n        return k_opt\n    else:\n        return k_used + 1000\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    import copy\n    # Fallback random initialization if input invalid\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # random 4-color assignment\n        return ([random.randint(1, 4) for _ in range(9)], \"random_init\")\n    def canonicalize(sol):\n        remap = {}\n        next_label = 1\n        out = []\n        for x in sol:\n            if x not in remap:\n                remap[x] = next_label\n                next_label += 1\n            out.append(remap[x])\n        return out\n    curr = canonicalize(solution)\n    k = len(set(curr))\n    move = random.random()\n    if move < 0.7:\n        # Recolor one vertex to a different color in [1..k+1]\n        i = random.randrange(9)\n        new = curr[:]\n        # choose a color different from current\n        choices = list(range(1, k+2))\n        choices.remove(curr[i])\n        new[i] = random.choice(choices)\n        new = canonicalize(new)\n        return (new, \"recolor_one\")\n    else:\n        # Swap two existing color labels globally (diversification)\n        if k < 2:\n            # If only one color present, recolor one instead\n            i = random.randrange(9)\n            new = curr[:]\n            choices = [2]\n            new[i] = 2\n            new = canonicalize(new)\n            return (new, \"recolor_one_bootstrap\")\n        a, b = random.sample(list(range(1, k+1)), 2)\n        new = [b if x == a else a if x == b else x for x in curr]\n        new = canonicalize(new)\n        return (new, \"swap_colors\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Multi-move perturbation for escaping local minima\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [random.randint(1, 4) for _ in range(9)]\n    def canonicalize(sol):\n        remap = {}\n        next_label = 1\n        out = []\n        for x in sol:\n            if x not in remap:\n                remap[x] = next_label\n                next_label += 1\n            out.append(remap[x])\n        return out\n    curr = canonicalize(solution)\n    k = len(set(curr))\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        # choose between recolor or color-swap\n        if random.random() < 0.6:\n            i = random.randrange(9)\n            choices = list(range(1, k+2))\n            if curr[i] in choices:\n                choices.remove(curr[i])\n            curr[i] = random.choice(choices)\n        else:\n            if k >= 2:\n                a, b = random.sample(list(range(1, k+1)), 2)\n                curr = [b if x == a else a if x == b else x for x in curr]\n        curr = canonicalize(curr)\n        k = len(set(curr))\n    return curr\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00086162}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed in description; convert to 0-index here)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Colors used (labels may have gaps; we simply count distincts)\n    k_used = len(set(solution))\n    # Scalarized objective: fewer conflicts first, then fewer colors. Lower is better.\n    score = conflicts * 1_000_000 + k_used\n    return score","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Internal graph and helpers\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def dsatur_init():\n        # Simple DSATUR constructive initialization\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (-degrees[i], i))\n        colors = [0]*n\n        used_colors = 0\n        for v in order:\n            forbidden = set(colors[u] for u in adj[v] if colors[u] != 0)\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v] = c\n            if c > used_colors:\n                used_colors = c\n        return colors\n    # Fallback init if input invalid\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = solution[:]\n    k = len(set(sol))\n    # Identify conflicting vertices\n    conflicting = set()\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicting.add(u)\n            conflicting.add(v)\n    if conflicting:\n        # Conflict-driven recolor: choose conflicting vertex and assign color minimizing conflicts\n        v = random.choice(list(conflicting))\n        current_color = sol[v]\n        best_colors = []\n        best_conf = None\n        # allow trying existing colors plus one new color (k+1)\n        for c in range(1, k+2):\n            if c == current_color:\n                continue\n            conf = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (new_sol, \"conflict_recolor\")\n    # No conflicts: attempt color reduction by moving a vertex from the highest label to an existing color if feasible\n    color_classes = {}\n    for i,c in enumerate(sol):\n        color_classes.setdefault(c, []).append(i)\n    max_label = max(color_classes)\n    # Try vertices with max label first\n    candidates = color_classes[max_label][:]\n    random.shuffle(candidates)\n    for v in candidates:\n        # try assign to any color in [1..max_label-1] that creates no conflicts\n        targets = list(range(1, max_label))\n        random.shuffle(targets)\n        for c in targets:\n            ok = True\n            for u in adj[v]:\n                if sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[v] = c\n                return (new_sol, \"reduce_k_move\")\n    # Diversification: swap two color labels if at least 2 colors exist\n    if k >= 2:\n        a,b = random.sample(sorted(set(sol)), 2)\n        new_sol = [b if x == a else a if x == b else x for x in sol]\n        return (new_sol, \"swap_colors\")\n    # Fallback: recolor a random vertex to color 2\n    i = random.randrange(n)\n    new_sol = sol[:]\n    new_sol[i] = 2 if sol[i] != 2 else 1\n    return (new_sol, \"bootstrap_recolor\")","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Internal graph\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def random_init():\n        return [random.randint(1, 4) for _ in range(n)]\n    if not is_valid(solution):\n        return random_init()\n    sol = solution[:]\n    k = len(set(sol))\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # Choose between multi-vertex recolor and label swap\n        if random.random() < 0.7:\n            # pick a vertex, prefer conflicting if any\n            conflicting = set()\n            for u,v in edges:\n                if sol[u] == sol[v]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randrange(n)\n            choices = list(sorted(set(sol))) + [k+1]\n            if sol[v] in choices:\n                choices.remove(sol[v])\n            sol[v] = random.choice(choices)\n            k = len(set(sol))\n        else:\n            if k >= 2:\n                a,b = random.sample(sorted(set(sol)), 2)\n                sol = [b if x == a else a if x == b else x for x in sol]\n    return sol","Resultados":[[4,3,2,4,2,2,1,1,3],4,[2,3,1,2,4,1,4,4,3],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001525509}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed in description; convert to 0-index here)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Colors used (labels may have gaps; we simply count distincts)\n    k_used = len(set(solution))\n    # Scalarized objective: fewer conflicts first, then fewer colors. Lower is better.\n    score = conflicts * 1_000_000 + k_used\n    return score","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Internal graph and helpers\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def dsatur_init():\n        # Simple DSATUR constructive initialization\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (-degrees[i], i))\n        colors = [0]*n\n        used_colors = 0\n        for v in order:\n            forbidden = set(colors[u] for u in adj[v] if colors[u] != 0)\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v] = c\n            if c > used_colors:\n                used_colors = c\n        return colors\n    # Fallback init if input invalid\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = solution[:]\n    k = len(set(sol))\n    # Identify conflicting vertices\n    conflicting = set()\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicting.add(u)\n            conflicting.add(v)\n    if conflicting:\n        # Conflict-driven recolor: choose conflicting vertex and assign color minimizing conflicts\n        v = random.choice(list(conflicting))\n        current_color = sol[v]\n        best_colors = []\n        best_conf = None\n        # allow trying existing colors plus one new color (k+1)\n        for c in range(1, k+2):\n            if c == current_color:\n                continue\n            conf = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (new_sol, \"conflict_recolor\")\n    # No conflicts: attempt color reduction by moving a vertex from the highest label to an existing color if feasible\n    color_classes = {}\n    for i,c in enumerate(sol):\n        color_classes.setdefault(c, []).append(i)\n    max_label = max(color_classes)\n    # Try vertices with max label first\n    candidates = color_classes[max_label][:]\n    random.shuffle(candidates)\n    for v in candidates:\n        # try assign to any color in [1..max_label-1] that creates no conflicts\n        targets = list(range(1, max_label))\n        random.shuffle(targets)\n        for c in targets:\n            ok = True\n            for u in adj[v]:\n                if sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[v] = c\n                return (new_sol, \"reduce_k_move\")\n    # Diversification: swap two color labels if at least 2 colors exist\n    if k >= 2:\n        a,b = random.sample(sorted(set(sol)), 2)\n        new_sol = [b if x == a else a if x == b else x for x in sol]\n        return (new_sol, \"swap_colors\")\n    # Fallback: recolor a random vertex to color 2\n    i = random.randrange(n)\n    new_sol = sol[:]\n    new_sol[i] = 2 if sol[i] != 2 else 1\n    return (new_sol, \"bootstrap_recolor\")","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Internal graph\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def random_init():\n        return [random.randint(1, 4) for _ in range(n)]\n    if not is_valid(solution):\n        return random_init()\n    sol = solution[:]\n    k = len(set(sol))\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # Choose between multi-vertex recolor and label swap\n        if random.random() < 0.7:\n            # pick a vertex, prefer conflicting if any\n            conflicting = set()\n            for u,v in edges:\n                if sol[u] == sol[v]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randrange(n)\n            choices = list(sorted(set(sol))) + [k+1]\n            if sol[v] in choices:\n                choices.remove(sol[v])\n            sol[v] = random.choice(choices)\n            k = len(set(sol))\n        else:\n            if k >= 2:\n                a,b = random.sample(sorted(set(sol)), 2)\n                sol = [b if x == a else a if x == b else x for x in sol]\n    return sol","Resultados":[[7,8,8,4,6,1,5,2,3],5,"[1, 2, 3, 1, 3, 3, 4, 4, 2]",5],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002040944}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed in description; convert to 0-index here)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Colors used (labels may have gaps; we simply count distincts)\n    k_used = len(set(solution))\n    # Scalarized objective: fewer conflicts first, then fewer colors. Lower is better.\n    score = conflicts * 1_000_000 + k_used\n    return score","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Internal graph and helpers\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def dsatur_init():\n        # Simple DSATUR constructive initialization\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (-degrees[i], i))\n        colors = [0]*n\n        used_colors = 0\n        for v in order:\n            forbidden = set(colors[u] for u in adj[v] if colors[u] != 0)\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v] = c\n            if c > used_colors:\n                used_colors = c\n        return colors\n    # Fallback init if input invalid\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = solution[:]\n    k = len(set(sol))\n    # Identify conflicting vertices\n    conflicting = set()\n    for u,v in edges:\n        if sol[u] == sol[v]:\n            conflicting.add(u)\n            conflicting.add(v)\n    if conflicting:\n        # Conflict-driven recolor: choose conflicting vertex and assign color minimizing conflicts\n        v = random.choice(list(conflicting))\n        current_color = sol[v]\n        best_colors = []\n        best_conf = None\n        # allow trying existing colors plus one new color (k+1)\n        for c in range(1, k+2):\n            if c == current_color:\n                continue\n            conf = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (new_sol, \"conflict_recolor\")\n    # No conflicts: attempt color reduction by moving a vertex from the highest label to an existing color if feasible\n    color_classes = {}\n    for i,c in enumerate(sol):\n        color_classes.setdefault(c, []).append(i)\n    max_label = max(color_classes)\n    # Try vertices with max label first\n    candidates = color_classes[max_label][:]\n    random.shuffle(candidates)\n    for v in candidates:\n        # try assign to any color in [1..max_label-1] that creates no conflicts\n        targets = list(range(1, max_label))\n        random.shuffle(targets)\n        for c in targets:\n            ok = True\n            for u in adj[v]:\n                if sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[v] = c\n                return (new_sol, \"reduce_k_move\")\n    # Diversification: swap two color labels if at least 2 colors exist\n    if k >= 2:\n        a,b = random.sample(sorted(set(sol)), 2)\n        new_sol = [b if x == a else a if x == b else x for x in sol]\n        return (new_sol, \"swap_colors\")\n    # Fallback: recolor a random vertex to color 2\n    i = random.randrange(n)\n    new_sol = sol[:]\n    new_sol[i] = 2 if sol[i] != 2 else 1\n    return (new_sol, \"bootstrap_recolor\")","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Internal graph\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def random_init():\n        return [random.randint(1, 4) for _ in range(n)]\n    if not is_valid(solution):\n        return random_init()\n    sol = solution[:]\n    k = len(set(sol))\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # Choose between multi-vertex recolor and label swap\n        if random.random() < 0.7:\n            # pick a vertex, prefer conflicting if any\n            conflicting = set()\n            for u,v in edges:\n                if sol[u] == sol[v]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randrange(n)\n            choices = list(sorted(set(sol))) + [k+1]\n            if sol[v] in choices:\n                choices.remove(sol[v])\n            sol[v] = random.choice(choices)\n            k = len(set(sol))\n        else:\n            if k >= 2:\n                a,b = random.sample(sorted(set(sol)), 2)\n                sol = [b if x == a else a if x == b else x for x in sol]\n    return sol","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001013542}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    m = len(edges)\n    weight = m + 1  # ensures conflicts dominate k\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Normalize labels to 1..k (for stable accounting)\n    mapping = {}\n    next_label = 1\n    norm = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        norm.append(mapping[x])\n    k_used = len(mapping)\n    score = conflicts * weight + k_used\n    return score\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def count_vertex_conflicts(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def dsatur_init():\n        # Full DSATUR with dynamic saturation\n        colors = [0]*n\n        sat_deg = [0]*n\n        used = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        # pick start: highest degree\n        v = max(range(n), key=lambda i: degrees[i])\n        colors[v] = 1\n        for u in adj[v]:\n            used[u].add(1)\n            sat_deg[u] = len(used[u])\n        colored = 1\n        while colored < n:\n            candidates = [i for i in range(n) if colors[i] == 0]\n            v = max(candidates, key=lambda i: (sat_deg[i], degrees[i], -i))\n            c = 1\n            while c in used[v]:\n                c += 1\n            colors[v] = c\n            for u in adj[v]:\n                if c not in used[u]:\n                    used[u].add(c)\n                    sat_deg[u] = len(used[u])\n            colored += 1\n        return normalize(colors)\n    # Fallback init if invalid\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = normalize(solution[:])\n    # Identify conflicts\n    conflicting_vertices = set()\n    for (u,v) in edges:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        # Conflict-driven recolor without introducing new colors\n        k = len(set(sol))\n        # choose vertex with highest local conflict, tie-break by degree\n        v = max(conflicting_vertices, key=lambda x: (count_vertex_conflicts(sol, x), len(adj[x]), -x))\n        current_color = sol[v]\n        best_colors = []\n        best_conf = None\n        for c in range(1, k+1):\n            if c == current_color:\n                continue\n            conf = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        if not best_colors:\n            return (sol, \"no_move\")\n        new_c = random.choice(best_colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (normalize(new_sol), \"conflict_recolor\")\n    # No conflicts: attempt color reduction\n    k = len(set(sol))\n    color_classes = {}\n    for i,c in enumerate(sol):\n        color_classes.setdefault(c, []).append(i)\n    # Target smallest non-empty class for elimination attempts\n    smallest_color = min(color_classes.keys(), key=lambda c: (len(color_classes[c]), c))\n    vertices = color_classes[smallest_color][:]\n    random.shuffle(vertices)\n    # Try to move its vertices to other colors\n    for v in vertices:\n        targets = [c for c in range(1, k+1) if c != smallest_color]\n        random.shuffle(targets)\n        for c in targets:\n            ok = True\n            for u in adj[v]:\n                if sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[v] = c\n                # If smallest color becomes empty, relabel to compact\n                if all(x != smallest_color for x in new_sol):\n                    return (normalize(new_sol), \"reduce_k_eliminate\")\n                else:\n                    return (normalize(new_sol), \"reduce_k_progress\")\n    # If reduction failed, use Kempe-chain interchange for diversification\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i,x in enumerate(sol) if x == c1 or x == c2]\n        if candidates:\n            seed = random.choice(candidates)\n            # BFS on subgraph induced by colors c1 and c2\n            target_set = set([seed])\n            queue = [seed]\n            allowed = {c1, c2}\n            while queue:\n                x = queue.pop()\n                for y in adj[x]:\n                    if sol[y] in allowed and y not in target_set:\n                        target_set.add(y)\n                        queue.append(y)\n            new_sol = sol[:]\n            # swap c1<->c2 on the component\n            for x in target_set:\n                new_sol[x] = c2 if sol[x] == c1 else c1\n            # remains conflict-free by Kempe property\n            return (normalize(new_sol), \"kempe_chain_swap\")\n    # Fallback: relabel-only (no-op but keeps canonical form)\n    return (normalize(sol), \"relabel_canonical\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    if not is_valid(solution):\n        # simple randomized init within a small palette\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = normalize(solution[:])\n    # Structured perturbation: bounded steps, avoid increasing k if possible\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # With probability 0.6: act on conflicts; else diversify via Kempe\n        conflicting = set()\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                conflicting.add(u)\n                conflicting.add(v)\n        if conflicting and random.random() < 0.6:\n            v = random.choice(list(conflicting))\n            k = len(set(sol))\n            # try recolor within existing palette to minimize local conflicts\n            best = None\n            best_colors = []\n            for c in range(1, k+1):\n                if c == sol[v]:\n                    continue\n                conf = 0\n                for u in adj[v]:\n                    if sol[u] == c:\n                        conf += 1\n                if best is None or conf < best:\n                    best = conf\n                    best_colors = [c]\n                elif conf == best:\n                    best_colors.append(c)\n            if best_colors:\n                sol[v] = random.choice(best_colors)\n        else:\n            # Kempe-chain shuffle between two colors for diversification\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                c1, c2 = random.sample(colors, 2)\n                seeds = [i for i,x in enumerate(sol) if x in (c1,c2)]\n                if seeds:\n                    seed = random.choice(seeds)\n                    comp = set([seed])\n                    queue = [seed]\n                    allowed = {c1,c2}\n                    while queue:\n                        x = queue.pop()\n                        for y in adj[x]:\n                            if sol[y] in allowed and y not in comp:\n                                comp.add(y)\n                                queue.append(y)\n                    for x in comp:\n                        sol[x] = c2 if sol[x] == c1 else c1\n        # occasional attempt to compact labels by eliminating an empty class\n        sol = normalize(sol)\n    return sol\n","Resultados":[[1,2,3,1,3,3,4,4,2],4,[1,2,3,1,4,3,4,4,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002327448}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    m = len(edges)\n    weight = m + 1  # ensures conflicts dominate k\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Normalize labels to 1..k (for stable accounting)\n    mapping = {}\n    next_label = 1\n    norm = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        norm.append(mapping[x])\n    k_used = len(mapping)\n    score = conflicts * weight + k_used\n    return score\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def count_vertex_conflicts(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def dsatur_init():\n        # Full DSATUR with dynamic saturation\n        colors = [0]*n\n        sat_deg = [0]*n\n        used = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        # pick start: highest degree\n        v = max(range(n), key=lambda i: degrees[i])\n        colors[v] = 1\n        for u in adj[v]:\n            used[u].add(1)\n            sat_deg[u] = len(used[u])\n        colored = 1\n        while colored < n:\n            candidates = [i for i in range(n) if colors[i] == 0]\n            v = max(candidates, key=lambda i: (sat_deg[i], degrees[i], -i))\n            c = 1\n            while c in used[v]:\n                c += 1\n            colors[v] = c\n            for u in adj[v]:\n                if c not in used[u]:\n                    used[u].add(c)\n                    sat_deg[u] = len(used[u])\n            colored += 1\n        return normalize(colors)\n    # Fallback init if invalid\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = normalize(solution[:])\n    # Identify conflicts\n    conflicting_vertices = set()\n    for (u,v) in edges:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        # Conflict-driven recolor without introducing new colors\n        k = len(set(sol))\n        # choose vertex with highest local conflict, tie-break by degree\n        v = max(conflicting_vertices, key=lambda x: (count_vertex_conflicts(sol, x), len(adj[x]), -x))\n        current_color = sol[v]\n        best_colors = []\n        best_conf = None\n        for c in range(1, k+1):\n            if c == current_color:\n                continue\n            conf = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        if not best_colors:\n            return (sol, \"no_move\")\n        new_c = random.choice(best_colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (normalize(new_sol), \"conflict_recolor\")\n    # No conflicts: attempt color reduction\n    k = len(set(sol))\n    color_classes = {}\n    for i,c in enumerate(sol):\n        color_classes.setdefault(c, []).append(i)\n    # Target smallest non-empty class for elimination attempts\n    smallest_color = min(color_classes.keys(), key=lambda c: (len(color_classes[c]), c))\n    vertices = color_classes[smallest_color][:]\n    random.shuffle(vertices)\n    # Try to move its vertices to other colors\n    for v in vertices:\n        targets = [c for c in range(1, k+1) if c != smallest_color]\n        random.shuffle(targets)\n        for c in targets:\n            ok = True\n            for u in adj[v]:\n                if sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[v] = c\n                # If smallest color becomes empty, relabel to compact\n                if all(x != smallest_color for x in new_sol):\n                    return (normalize(new_sol), \"reduce_k_eliminate\")\n                else:\n                    return (normalize(new_sol), \"reduce_k_progress\")\n    # If reduction failed, use Kempe-chain interchange for diversification\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i,x in enumerate(sol) if x == c1 or x == c2]\n        if candidates:\n            seed = random.choice(candidates)\n            # BFS on subgraph induced by colors c1 and c2\n            target_set = set([seed])\n            queue = [seed]\n            allowed = {c1, c2}\n            while queue:\n                x = queue.pop()\n                for y in adj[x]:\n                    if sol[y] in allowed and y not in target_set:\n                        target_set.add(y)\n                        queue.append(y)\n            new_sol = sol[:]\n            # swap c1<->c2 on the component\n            for x in target_set:\n                new_sol[x] = c2 if sol[x] == c1 else c1\n            # remains conflict-free by Kempe property\n            return (normalize(new_sol), \"kempe_chain_swap\")\n    # Fallback: relabel-only (no-op but keeps canonical form)\n    return (normalize(sol), \"relabel_canonical\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    if not is_valid(solution):\n        # simple randomized init within a small palette\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = normalize(solution[:])\n    # Structured perturbation: bounded steps, avoid increasing k if possible\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # With probability 0.6: act on conflicts; else diversify via Kempe\n        conflicting = set()\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                conflicting.add(u)\n                conflicting.add(v)\n        if conflicting and random.random() < 0.6:\n            v = random.choice(list(conflicting))\n            k = len(set(sol))\n            # try recolor within existing palette to minimize local conflicts\n            best = None\n            best_colors = []\n            for c in range(1, k+1):\n                if c == sol[v]:\n                    continue\n                conf = 0\n                for u in adj[v]:\n                    if sol[u] == c:\n                        conf += 1\n                if best is None or conf < best:\n                    best = conf\n                    best_colors = [c]\n                elif conf == best:\n                    best_colors.append(c)\n            if best_colors:\n                sol[v] = random.choice(best_colors)\n        else:\n            # Kempe-chain shuffle between two colors for diversification\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                c1, c2 = random.sample(colors, 2)\n                seeds = [i for i,x in enumerate(sol) if x in (c1,c2)]\n                if seeds:\n                    seed = random.choice(seeds)\n                    comp = set([seed])\n                    queue = [seed]\n                    allowed = {c1,c2}\n                    while queue:\n                        x = queue.pop()\n                        for y in adj[x]:\n                            if sol[y] in allowed and y not in comp:\n                                comp.add(y)\n                                queue.append(y)\n                    for x in comp:\n                        sol[x] = c2 if sol[x] == c1 else c1\n        # occasional attempt to compact labels by eliminating an empty class\n        sol = normalize(sol)\n    return sol\n","Resultados":[[1,2,3,1,3,3,4,4,2],4,"[1,2,3,1,3,3,4,4,2]",4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003512782}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    m = len(edges)\n    weight = m + 1  # ensures conflicts dominate k\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Normalize labels to 1..k (for stable accounting)\n    mapping = {}\n    next_label = 1\n    norm = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        norm.append(mapping[x])\n    k_used = len(mapping)\n    score = conflicts * weight + k_used\n    return score\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def count_vertex_conflicts(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def dsatur_init():\n        # Full DSATUR with dynamic saturation\n        colors = [0]*n\n        sat_deg = [0]*n\n        used = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        # pick start: highest degree\n        v = max(range(n), key=lambda i: degrees[i])\n        colors[v] = 1\n        for u in adj[v]:\n            used[u].add(1)\n            sat_deg[u] = len(used[u])\n        colored = 1\n        while colored < n:\n            candidates = [i for i in range(n) if colors[i] == 0]\n            v = max(candidates, key=lambda i: (sat_deg[i], degrees[i], -i))\n            c = 1\n            while c in used[v]:\n                c += 1\n            colors[v] = c\n            for u in adj[v]:\n                if c not in used[u]:\n                    used[u].add(c)\n                    sat_deg[u] = len(used[u])\n            colored += 1\n        return normalize(colors)\n    # Fallback init if invalid\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = normalize(solution[:])\n    # Identify conflicts\n    conflicting_vertices = set()\n    for (u,v) in edges:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        # Conflict-driven recolor without introducing new colors\n        k = len(set(sol))\n        # choose vertex with highest local conflict, tie-break by degree\n        v = max(conflicting_vertices, key=lambda x: (count_vertex_conflicts(sol, x), len(adj[x]), -x))\n        current_color = sol[v]\n        best_colors = []\n        best_conf = None\n        for c in range(1, k+1):\n            if c == current_color:\n                continue\n            conf = 0\n            for u in adj[v]:\n                if sol[u] == c:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        if not best_colors:\n            return (sol, \"no_move\")\n        new_c = random.choice(best_colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (normalize(new_sol), \"conflict_recolor\")\n    # No conflicts: attempt color reduction\n    k = len(set(sol))\n    color_classes = {}\n    for i,c in enumerate(sol):\n        color_classes.setdefault(c, []).append(i)\n    # Target smallest non-empty class for elimination attempts\n    smallest_color = min(color_classes.keys(), key=lambda c: (len(color_classes[c]), c))\n    vertices = color_classes[smallest_color][:]\n    random.shuffle(vertices)\n    # Try to move its vertices to other colors\n    for v in vertices:\n        targets = [c for c in range(1, k+1) if c != smallest_color]\n        random.shuffle(targets)\n        for c in targets:\n            ok = True\n            for u in adj[v]:\n                if sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[v] = c\n                # If smallest color becomes empty, relabel to compact\n                if all(x != smallest_color for x in new_sol):\n                    return (normalize(new_sol), \"reduce_k_eliminate\")\n                else:\n                    return (normalize(new_sol), \"reduce_k_progress\")\n    # If reduction failed, use Kempe-chain interchange for diversification\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i,x in enumerate(sol) if x == c1 or x == c2]\n        if candidates:\n            seed = random.choice(candidates)\n            # BFS on subgraph induced by colors c1 and c2\n            target_set = set([seed])\n            queue = [seed]\n            allowed = {c1, c2}\n            while queue:\n                x = queue.pop()\n                for y in adj[x]:\n                    if sol[y] in allowed and y not in target_set:\n                        target_set.add(y)\n                        queue.append(y)\n            new_sol = sol[:]\n            # swap c1<->c2 on the component\n            for x in target_set:\n                new_sol[x] = c2 if sol[x] == c1 else c1\n            # remains conflict-free by Kempe property\n            return (normalize(new_sol), \"kempe_chain_swap\")\n    # Fallback: relabel-only (no-op but keeps canonical form)\n    return (normalize(sol), \"relabel_canonical\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    if not is_valid(solution):\n        # simple randomized init within a small palette\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = normalize(solution[:])\n    # Structured perturbation: bounded steps, avoid increasing k if possible\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # With probability 0.6: act on conflicts; else diversify via Kempe\n        conflicting = set()\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                conflicting.add(u)\n                conflicting.add(v)\n        if conflicting and random.random() < 0.6:\n            v = random.choice(list(conflicting))\n            k = len(set(sol))\n            # try recolor within existing palette to minimize local conflicts\n            best = None\n            best_colors = []\n            for c in range(1, k+1):\n                if c == sol[v]:\n                    continue\n                conf = 0\n                for u in adj[v]:\n                    if sol[u] == c:\n                        conf += 1\n                if best is None or conf < best:\n                    best = conf\n                    best_colors = [c]\n                elif conf == best:\n                    best_colors.append(c)\n            if best_colors:\n                sol[v] = random.choice(best_colors)\n        else:\n            # Kempe-chain shuffle between two colors for diversification\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                c1, c2 = random.sample(colors, 2)\n                seeds = [i for i,x in enumerate(sol) if x in (c1,c2)]\n                if seeds:\n                    seed = random.choice(seeds)\n                    comp = set([seed])\n                    queue = [seed]\n                    allowed = {c1,c2}\n                    while queue:\n                        x = queue.pop()\n                        for y in adj[x]:\n                            if sol[y] in allowed and y not in comp:\n                                comp.add(y)\n                                queue.append(y)\n                    for x in comp:\n                        sol[x] = c2 if sol[x] == c1 else c1\n        # occasional attempt to compact labels by eliminating an empty class\n        sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001465418}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    m = len(edges)\n    weight = m + 1  # strict dominance of conflicts over k\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Distinct colors used (labels may be non-compact; that's acceptable)\n    k_used = len(set(solution))\n    return conflicts * weight + k_used\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helpers\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        # Relabel to 1..k (dense) preserving classes\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def conflicts_of_vertex(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def score_delta_if_recolor(sol, v, new_c):\n        # Returns (delta_conflicts, will_increase_k)\n        old_c = sol[v]\n        if new_c == old_c:\n            return (0, False)\n        delta = 0\n        for u in adj[v]:\n            if sol[u] == old_c:\n                delta -= 1\n            if sol[u] == new_c:\n                delta += 1\n        inc_k = False\n        if new_c not in set(sol):\n            inc_k = True\n        # If moving last vertex of its color, k may decrease; handle by checking remaining\n        if sum(1 for x in sol if x == old_c) == 1 and not inc_k:\n            # color class old_c will vanish -> decreases k by 1\n            pass\n        return (delta, inc_k)\n    def dsatur_init():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        used = [set() for _ in range(n)]\n        sat = [0]*n\n        v = max(range(n), key=lambda i: degrees[i])\n        colors[v] = 1\n        for u in adj[v]:\n            used[u].add(1)\n            sat[u] = len(used[u])\n        colored = 1\n        while colored < n:\n            cand = [i for i in range(n) if colors[i] == 0]\n            v = max(cand, key=lambda i: (sat[i], degrees[i], -i))\n            c = 1\n            while c in used[v]:\n                c += 1\n            colors[v] = c\n            for u in adj[v]:\n                if c not in used[u]:\n                    used[u].add(c)\n                    sat[u] = len(used[u])\n            colored += 1\n        return normalize(colors)\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = solution[:]  # work on a copy\n    # Compute conflicts set\n    conflicting_vertices = set()\n    for (u,v) in edges:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        # Steepest local recolor among top conflicted vertices\n        k = len(set(sol))\n        # Rank vertices by local conflicts then degree\n        ranked = sorted(conflicting_vertices, key=lambda v: (conflicts_of_vertex(sol, v), len(adj[v]), -v), reverse=True)\n        top = ranked[:min(3, len(ranked))]\n        best_move = None  # (improvement, v, new_c)\n        best_new_sol = None\n        for v in top:\n            current_c = sol[v]\n            # Try all existing colors first (avoid new colors)\n            for c in range(1, k+1):\n                if c == current_c:\n                    continue\n                # compute conflict change\n                delta = 0\n                for u in adj[v]:\n                    if sol[u] == current_c:\n                        delta -= 1\n                    if sol[u] == c:\n                        delta += 1\n                if best_move is None or delta < best_move[0]:\n                    tmp = sol[:]\n                    tmp[v] = c\n                    best_move = (delta, v, c)\n                    best_new_sol = tmp\n        if best_new_sol is not None:\n            # Apply best steepest-improvement move (may be neutral or worsening if none improves)\n            return (best_new_sol, \"conflict_steepest_recolor\")\n        # Fallback random conflict recolor\n        v = random.choice(list(conflicting_vertices))\n        colors = list(set(sol))\n        if sol[v] in colors:\n            colors.remove(sol[v])\n        if not colors:\n            colors = list(set(sol))\n        new_c = random.choice(colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (new_sol, \"conflict_random_recolor\")\n    # No conflicts: attempt color reduction by eliminating smallest class fully\n    # Identify smallest color class\n    classes = {}\n    for i,c in enumerate(sol):\n        classes.setdefault(c, []).append(i)\n    smallest_c = min(classes.keys(), key=lambda c: (len(classes[c]), c))\n    k = len(classes)\n    vertices = classes[smallest_c][:]\n    random.shuffle(vertices)\n    moved_any = False\n    new_sol = sol[:]\n    for v in vertices:\n        # Try target colors biased toward those not used by neighbors\n        target_colors = [c for c in classes.keys() if c != smallest_c]\n        random.shuffle(target_colors)\n        placed = False\n        for c in target_colors:\n            ok = True\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol[v] = c\n                moved_any = True\n                placed = True\n                break\n        if not placed:\n            # Could not move this vertex; abandon elimination\n            break\n    if moved_any:\n        if all(x != smallest_c for x in new_sol):\n            # Successful elimination\n            # Relabel to compact representation\n            return (normalize(new_sol), \"reduce_k_eliminate\")\n        else:\n            return (new_sol, \"reduce_k_progress\")\n    # Kempe-chain diversification biased toward smallest class and its blockers\n    colors = sorted(classes.keys())\n    if len(colors) >= 2:\n        # Choose c1 as smallest class color, c2 as a frequent neighbor color\n        c1 = smallest_c\n        # Estimate blockers: colors appearing on neighbors of vertices in c1\n        neighbor_colors = {}\n        for v in classes[c1]:\n            for u in adj[v]:\n                neighbor_colors[new_sol[u]] = neighbor_colors.get(new_sol[u], 0) + 1\n        # Select c2 among top blocker colors; fallback random\n        candidates_c2 = [c for c,_ in sorted(neighbor_colors.items(), key=lambda kv: (-kv[1], kv[0])) if c != c1]\n        if not candidates_c2:\n            candidates_c2 = [c for c in colors if c != c1]\n        c2 = random.choice(candidates_c2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i,x in enumerate(sol) if x == c1 or x == c2]\n        if candidates:\n            seed = random.choice(candidates)\n            comp = set([seed])\n            queue = [seed]\n            allowed = {c1, c2}\n            while queue:\n                x = queue.pop()\n                for y in adj[x]:\n                    if new_sol[y] in allowed and y not in comp:\n                        comp.add(y)\n                        queue.append(y)\n            kempe_sol = new_sol[:]\n            for x in comp:\n                kempe_sol[x] = c2 if new_sol[x] == c1 else c1\n            return (kempe_sol, \"kempe_chain_swap\")\n    # No-op fallback with canonical relabel\n    return (normalize(sol), \"relabel_canonical\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    # Initialize base\n    if not is_valid(solution):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = solution[:]\n    sol = base\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        # 60% conflict-driven, 40% diversification\n        conflicting = set()\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                conflicting.add(u)\n                conflicting.add(v)\n        if conflicting and random.random() < 0.6:\n            v = random.choice(list(conflicting))\n            k = len(set(sol))\n            # try recolor within existing palette minimizing local conflicts\n            best = None\n            best_colors = []\n            for c in range(1, k+1):\n                if c == sol[v]:\n                    continue\n                conf = 0\n                for u in adj[v]:\n                    if sol[u] == c:\n                        conf += 1\n                if best is None or conf < best:\n                    best = conf\n                    best_colors = [c]\n                elif conf == best:\n                    best_colors.append(c)\n            if best_colors:\n                sol[v] = random.choice(best_colors)\n        else:\n            # Kempe-chain shuffle between two colors\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                c1, c2 = random.sample(colors, 2)\n                seeds = [i for i,x in enumerate(sol) if x in (c1,c2)]\n                if seeds:\n                    seed = random.choice(seeds)\n                    comp = set([seed])\n                    queue = [seed]\n                    allowed = {c1,c2}\n                    while queue:\n                        x = queue.pop()\n                        for y in adj[x]:\n                            if sol[y] in allowed and y not in comp:\n                                comp.add(y)\n                                queue.append(y)\n                    for x in comp:\n                        sol[x] = c2 if sol[x] == c1 else c1\n        # occasional relabel to keep labels compact\n        if random.random() < 0.5:\n            sol = normalize(sol)\n    return sol\n","Resultados":[[4,3,1,1,2,4,2,2,3],4,[1,2,3,1,4,3,4,4,2],4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002238018}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    m = len(edges)\n    weight = m + 1  # strict dominance of conflicts over k\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Distinct colors used (labels may be non-compact; that's acceptable)\n    k_used = len(set(solution))\n    return conflicts * weight + k_used\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helpers\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        # Relabel to 1..k (dense) preserving classes\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def conflicts_of_vertex(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def score_delta_if_recolor(sol, v, new_c):\n        # Returns (delta_conflicts, will_increase_k)\n        old_c = sol[v]\n        if new_c == old_c:\n            return (0, False)\n        delta = 0\n        for u in adj[v]:\n            if sol[u] == old_c:\n                delta -= 1\n            if sol[u] == new_c:\n                delta += 1\n        inc_k = False\n        if new_c not in set(sol):\n            inc_k = True\n        # If moving last vertex of its color, k may decrease; handle by checking remaining\n        if sum(1 for x in sol if x == old_c) == 1 and not inc_k:\n            # color class old_c will vanish -> decreases k by 1\n            pass\n        return (delta, inc_k)\n    def dsatur_init():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        used = [set() for _ in range(n)]\n        sat = [0]*n\n        v = max(range(n), key=lambda i: degrees[i])\n        colors[v] = 1\n        for u in adj[v]:\n            used[u].add(1)\n            sat[u] = len(used[u])\n        colored = 1\n        while colored < n:\n            cand = [i for i in range(n) if colors[i] == 0]\n            v = max(cand, key=lambda i: (sat[i], degrees[i], -i))\n            c = 1\n            while c in used[v]:\n                c += 1\n            colors[v] = c\n            for u in adj[v]:\n                if c not in used[u]:\n                    used[u].add(c)\n                    sat[u] = len(used[u])\n            colored += 1\n        return normalize(colors)\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = solution[:]  # work on a copy\n    # Compute conflicts set\n    conflicting_vertices = set()\n    for (u,v) in edges:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        # Steepest local recolor among top conflicted vertices\n        k = len(set(sol))\n        # Rank vertices by local conflicts then degree\n        ranked = sorted(conflicting_vertices, key=lambda v: (conflicts_of_vertex(sol, v), len(adj[v]), -v), reverse=True)\n        top = ranked[:min(3, len(ranked))]\n        best_move = None  # (improvement, v, new_c)\n        best_new_sol = None\n        for v in top:\n            current_c = sol[v]\n            # Try all existing colors first (avoid new colors)\n            for c in range(1, k+1):\n                if c == current_c:\n                    continue\n                # compute conflict change\n                delta = 0\n                for u in adj[v]:\n                    if sol[u] == current_c:\n                        delta -= 1\n                    if sol[u] == c:\n                        delta += 1\n                if best_move is None or delta < best_move[0]:\n                    tmp = sol[:]\n                    tmp[v] = c\n                    best_move = (delta, v, c)\n                    best_new_sol = tmp\n        if best_new_sol is not None:\n            # Apply best steepest-improvement move (may be neutral or worsening if none improves)\n            return (best_new_sol, \"conflict_steepest_recolor\")\n        # Fallback random conflict recolor\n        v = random.choice(list(conflicting_vertices))\n        colors = list(set(sol))\n        if sol[v] in colors:\n            colors.remove(sol[v])\n        if not colors:\n            colors = list(set(sol))\n        new_c = random.choice(colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (new_sol, \"conflict_random_recolor\")\n    # No conflicts: attempt color reduction by eliminating smallest class fully\n    # Identify smallest color class\n    classes = {}\n    for i,c in enumerate(sol):\n        classes.setdefault(c, []).append(i)\n    smallest_c = min(classes.keys(), key=lambda c: (len(classes[c]), c))\n    k = len(classes)\n    vertices = classes[smallest_c][:]\n    random.shuffle(vertices)\n    moved_any = False\n    new_sol = sol[:]\n    for v in vertices:\n        # Try target colors biased toward those not used by neighbors\n        target_colors = [c for c in classes.keys() if c != smallest_c]\n        random.shuffle(target_colors)\n        placed = False\n        for c in target_colors:\n            ok = True\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol[v] = c\n                moved_any = True\n                placed = True\n                break\n        if not placed:\n            # Could not move this vertex; abandon elimination\n            break\n    if moved_any:\n        if all(x != smallest_c for x in new_sol):\n            # Successful elimination\n            # Relabel to compact representation\n            return (normalize(new_sol), \"reduce_k_eliminate\")\n        else:\n            return (new_sol, \"reduce_k_progress\")\n    # Kempe-chain diversification biased toward smallest class and its blockers\n    colors = sorted(classes.keys())\n    if len(colors) >= 2:\n        # Choose c1 as smallest class color, c2 as a frequent neighbor color\n        c1 = smallest_c\n        # Estimate blockers: colors appearing on neighbors of vertices in c1\n        neighbor_colors = {}\n        for v in classes[c1]:\n            for u in adj[v]:\n                neighbor_colors[new_sol[u]] = neighbor_colors.get(new_sol[u], 0) + 1\n        # Select c2 among top blocker colors; fallback random\n        candidates_c2 = [c for c,_ in sorted(neighbor_colors.items(), key=lambda kv: (-kv[1], kv[0])) if c != c1]\n        if not candidates_c2:\n            candidates_c2 = [c for c in colors if c != c1]\n        c2 = random.choice(candidates_c2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i,x in enumerate(sol) if x == c1 or x == c2]\n        if candidates:\n            seed = random.choice(candidates)\n            comp = set([seed])\n            queue = [seed]\n            allowed = {c1, c2}\n            while queue:\n                x = queue.pop()\n                for y in adj[x]:\n                    if new_sol[y] in allowed and y not in comp:\n                        comp.add(y)\n                        queue.append(y)\n            kempe_sol = new_sol[:]\n            for x in comp:\n                kempe_sol[x] = c2 if new_sol[x] == c1 else c1\n            return (kempe_sol, \"kempe_chain_swap\")\n    # No-op fallback with canonical relabel\n    return (normalize(sol), \"relabel_canonical\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    # Initialize base\n    if not is_valid(solution):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = solution[:]\n    sol = base\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        # 60% conflict-driven, 40% diversification\n        conflicting = set()\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                conflicting.add(u)\n                conflicting.add(v)\n        if conflicting and random.random() < 0.6:\n            v = random.choice(list(conflicting))\n            k = len(set(sol))\n            # try recolor within existing palette minimizing local conflicts\n            best = None\n            best_colors = []\n            for c in range(1, k+1):\n                if c == sol[v]:\n                    continue\n                conf = 0\n                for u in adj[v]:\n                    if sol[u] == c:\n                        conf += 1\n                if best is None or conf < best:\n                    best = conf\n                    best_colors = [c]\n                elif conf == best:\n                    best_colors.append(c)\n            if best_colors:\n                sol[v] = random.choice(best_colors)\n        else:\n            # Kempe-chain shuffle between two colors\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                c1, c2 = random.sample(colors, 2)\n                seeds = [i for i,x in enumerate(sol) if x in (c1,c2)]\n                if seeds:\n                    seed = random.choice(seeds)\n                    comp = set([seed])\n                    queue = [seed]\n                    allowed = {c1,c2}\n                    while queue:\n                        x = queue.pop()\n                        for y in adj[x]:\n                            if sol[y] in allowed and y not in comp:\n                                comp.add(y)\n                                queue.append(y)\n                    for x in comp:\n                        sol[x] = c2 if sol[x] == c1 else c1\n        # occasional relabel to keep labels compact\n        if random.random() < 0.5:\n            sol = normalize(sol)\n    return sol\n","Resultados":[[2,1,3,3,4,2,4,4,1],4,"[1,2,3,1,3,3,4,4,2]",4],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003689445}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    m = len(edges)\n    weight = m + 1  # strict dominance of conflicts over k\n    # Validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Distinct colors used (labels may be non-compact; that's acceptable)\n    k_used = len(set(solution))\n    return conflicts * weight + k_used\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helpers\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        # Relabel to 1..k (dense) preserving classes\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def conflicts_of_vertex(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def score_delta_if_recolor(sol, v, new_c):\n        # Returns (delta_conflicts, will_increase_k)\n        old_c = sol[v]\n        if new_c == old_c:\n            return (0, False)\n        delta = 0\n        for u in adj[v]:\n            if sol[u] == old_c:\n                delta -= 1\n            if sol[u] == new_c:\n                delta += 1\n        inc_k = False\n        if new_c not in set(sol):\n            inc_k = True\n        # If moving last vertex of its color, k may decrease; handle by checking remaining\n        if sum(1 for x in sol if x == old_c) == 1 and not inc_k:\n            # color class old_c will vanish -> decreases k by 1\n            pass\n        return (delta, inc_k)\n    def dsatur_init():\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        used = [set() for _ in range(n)]\n        sat = [0]*n\n        v = max(range(n), key=lambda i: degrees[i])\n        colors[v] = 1\n        for u in adj[v]:\n            used[u].add(1)\n            sat[u] = len(used[u])\n        colored = 1\n        while colored < n:\n            cand = [i for i in range(n) if colors[i] == 0]\n            v = max(cand, key=lambda i: (sat[i], degrees[i], -i))\n            c = 1\n            while c in used[v]:\n                c += 1\n            colors[v] = c\n            for u in adj[v]:\n                if c not in used[u]:\n                    used[u].add(c)\n                    sat[u] = len(used[u])\n            colored += 1\n        return normalize(colors)\n    if not is_valid(solution):\n        return (dsatur_init(), \"init_dsatur\")\n    sol = solution[:]  # work on a copy\n    # Compute conflicts set\n    conflicting_vertices = set()\n    for (u,v) in edges:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        # Steepest local recolor among top conflicted vertices\n        k = len(set(sol))\n        # Rank vertices by local conflicts then degree\n        ranked = sorted(conflicting_vertices, key=lambda v: (conflicts_of_vertex(sol, v), len(adj[v]), -v), reverse=True)\n        top = ranked[:min(3, len(ranked))]\n        best_move = None  # (improvement, v, new_c)\n        best_new_sol = None\n        for v in top:\n            current_c = sol[v]\n            # Try all existing colors first (avoid new colors)\n            for c in range(1, k+1):\n                if c == current_c:\n                    continue\n                # compute conflict change\n                delta = 0\n                for u in adj[v]:\n                    if sol[u] == current_c:\n                        delta -= 1\n                    if sol[u] == c:\n                        delta += 1\n                if best_move is None or delta < best_move[0]:\n                    tmp = sol[:]\n                    tmp[v] = c\n                    best_move = (delta, v, c)\n                    best_new_sol = tmp\n        if best_new_sol is not None:\n            # Apply best steepest-improvement move (may be neutral or worsening if none improves)\n            return (best_new_sol, \"conflict_steepest_recolor\")\n        # Fallback random conflict recolor\n        v = random.choice(list(conflicting_vertices))\n        colors = list(set(sol))\n        if sol[v] in colors:\n            colors.remove(sol[v])\n        if not colors:\n            colors = list(set(sol))\n        new_c = random.choice(colors)\n        new_sol = sol[:]\n        new_sol[v] = new_c\n        return (new_sol, \"conflict_random_recolor\")\n    # No conflicts: attempt color reduction by eliminating smallest class fully\n    # Identify smallest color class\n    classes = {}\n    for i,c in enumerate(sol):\n        classes.setdefault(c, []).append(i)\n    smallest_c = min(classes.keys(), key=lambda c: (len(classes[c]), c))\n    k = len(classes)\n    vertices = classes[smallest_c][:]\n    random.shuffle(vertices)\n    moved_any = False\n    new_sol = sol[:]\n    for v in vertices:\n        # Try target colors biased toward those not used by neighbors\n        target_colors = [c for c in classes.keys() if c != smallest_c]\n        random.shuffle(target_colors)\n        placed = False\n        for c in target_colors:\n            ok = True\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol[v] = c\n                moved_any = True\n                placed = True\n                break\n        if not placed:\n            # Could not move this vertex; abandon elimination\n            break\n    if moved_any:\n        if all(x != smallest_c for x in new_sol):\n            # Successful elimination\n            # Relabel to compact representation\n            return (normalize(new_sol), \"reduce_k_eliminate\")\n        else:\n            return (new_sol, \"reduce_k_progress\")\n    # Kempe-chain diversification biased toward smallest class and its blockers\n    colors = sorted(classes.keys())\n    if len(colors) >= 2:\n        # Choose c1 as smallest class color, c2 as a frequent neighbor color\n        c1 = smallest_c\n        # Estimate blockers: colors appearing on neighbors of vertices in c1\n        neighbor_colors = {}\n        for v in classes[c1]:\n            for u in adj[v]:\n                neighbor_colors[new_sol[u]] = neighbor_colors.get(new_sol[u], 0) + 1\n        # Select c2 among top blocker colors; fallback random\n        candidates_c2 = [c for c,_ in sorted(neighbor_colors.items(), key=lambda kv: (-kv[1], kv[0])) if c != c1]\n        if not candidates_c2:\n            candidates_c2 = [c for c in colors if c != c1]\n        c2 = random.choice(candidates_c2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i,x in enumerate(sol) if x == c1 or x == c2]\n        if candidates:\n            seed = random.choice(candidates)\n            comp = set([seed])\n            queue = [seed]\n            allowed = {c1, c2}\n            while queue:\n                x = queue.pop()\n                for y in adj[x]:\n                    if new_sol[y] in allowed and y not in comp:\n                        comp.add(y)\n                        queue.append(y)\n            kempe_sol = new_sol[:]\n            for x in comp:\n                kempe_sol[x] = c2 if new_sol[x] == c1 else c1\n            return (kempe_sol, \"kempe_chain_swap\")\n    # No-op fallback with canonical relabel\n    return (normalize(sol), \"relabel_canonical\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Embedded problem data (0-indexed)\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def is_valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    # Initialize base\n    if not is_valid(solution):\n        base = [random.randint(1, 4) for _ in range(n)]\n    else:\n        base = solution[:]\n    sol = base\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        # 60% conflict-driven, 40% diversification\n        conflicting = set()\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                conflicting.add(u)\n                conflicting.add(v)\n        if conflicting and random.random() < 0.6:\n            v = random.choice(list(conflicting))\n            k = len(set(sol))\n            # try recolor within existing palette minimizing local conflicts\n            best = None\n            best_colors = []\n            for c in range(1, k+1):\n                if c == sol[v]:\n                    continue\n                conf = 0\n                for u in adj[v]:\n                    if sol[u] == c:\n                        conf += 1\n                if best is None or conf < best:\n                    best = conf\n                    best_colors = [c]\n                elif conf == best:\n                    best_colors.append(c)\n            if best_colors:\n                sol[v] = random.choice(best_colors)\n        else:\n            # Kempe-chain shuffle between two colors\n            colors = sorted(set(sol))\n            if len(colors) >= 2:\n                c1, c2 = random.sample(colors, 2)\n                seeds = [i for i,x in enumerate(sol) if x in (c1,c2)]\n                if seeds:\n                    seed = random.choice(seeds)\n                    comp = set([seed])\n                    queue = [seed]\n                    allowed = {c1,c2}\n                    while queue:\n                        x = queue.pop()\n                        for y in adj[x]:\n                            if sol[y] in allowed and y not in comp:\n                                comp.add(y)\n                                queue.append(y)\n                    for x in comp:\n                        sol[x] = c2 if sol[x] == c1 else c1\n        # occasional relabel to keep labels compact\n        if random.random() < 0.5:\n            sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.0016531399}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_1_TO_9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1 or x > n_expected:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return BIG \/\/ 4 + conflicts\n    # Feasible: number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbour_solution, NB_Type, Movement_Type)\n    n_expected = 9\n    # Defensive copy and validation of input format\n    if not isinstance(solution, list) or len(solution) != n_expected:\n        # Initialize a random valid-format solution if input invalid\n        sol = [random.randint(1, n_expected) for _ in range(n_expected)]\n    else:\n        sol = list(solution)\n\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n_expected + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Compute conflicts list (edges with equal colors)\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n\n    # Movement strategies\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting edge and recolor one endpoint greedily\n        u, v = random.choice(conflicts)\n        pick = random.choice([u, v])\n        current_color = sol[pick - 1]\n        # Candidate colors from 1..n_expected (cap to representation domain)\n        best_color = current_color\n        best_conf = None\n        for c in range(1, n_expected + 1):\n            if c == current_color:\n                continue\n            # Tentative recolor\n            old = sol[pick - 1]\n            sol[pick - 1] = c\n            # Count local conflicts for pick\n            c_conf = 0\n            for nb in adj[pick]:\n                if sol[nb - 1] == c:\n                    c_conf += 1\n            # Track best\n            if best_conf is None or c_conf < best_conf:\n                best_conf = c_conf\n                best_color = c\n            sol[pick - 1] = old\n        sol[pick - 1] = best_color\n        return sol, \"NB_Local\", \"conflict_directed_recolor\"\n    else:\n        # Feasible: diversify\/exploit\n        move_choice = random.random()\n        if move_choice < 0.6:\n            # Recolor a random vertex to an existing color (or another within domain) to explore color merges\n            i = random.randint(1, n_expected)\n            existing_colors = list(set(sol))\n            # Ensure at least 2 options in candidate set within domain 1..n_expected\n            candidates = list(set(existing_colors + [random.randint(1, n_expected)]))\n            new_color = random.choice(candidates)\n            while new_color == sol[i - 1] and len(candidates) > 1:\n                new_color = random.choice(candidates)\n            sol[i - 1] = new_color\n            return sol, \"NB_Local\", \"feasible_diversify_recolor\"\n        else:\n            # Color-swap on two colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a, b = random.sample(colors_present, 2)\n                # Swap colors a and b on a random subset (Kempe-like partial swap)\n                idxs = [i for i, x in enumerate(sol) if x in (a, b)]\n                k = max(1, len(idxs) \/\/ 2)\n                chosen = set(random.sample(idxs, k))\n                for i in chosen:\n                    sol[i] = a if sol[i] == b else (b if sol[i] == a else sol[i])\n                return sol, \"NB_Local\", \"partial_color_swap\"\n            else:\n                # Fallback to recolor if only one color present\n                i = random.randint(1, n_expected)\n                new_color = random.randint(1, n_expected)\n                while new_color == sol[i - 1]:\n                    new_color = random.randint(1, n_expected)\n                sol[i - 1] = new_color\n                return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n_expected = 9\n    # Start from a copy or random valid-format solution if invalid\n    if not isinstance(solution, list) or len(solution) != n_expected:\n        sol = [random.randint(1, n_expected) for _ in range(n_expected)]\n    else:\n        sol = list(solution)\n\n    # Strong perturbation: multiple random recolors within domain 1..9\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        i = random.randint(0, n_expected - 1)\n        new_color = random.randint(1, n_expected)\n        # Avoid null move if possible\n        tries = 0\n        while new_color == sol[i] and tries < 5:\n            new_color = random.randint(1, n_expected)\n            tries += 1\n        sol[i] = new_color\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00083607}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_1_TO_9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1 or x > n_expected:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return BIG \/\/ 4 + conflicts\n    # Feasible: number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbour_solution, NB_Type, Movement_Type)\n    n_expected = 9\n    # Defensive copy and validation of input format\n    if not isinstance(solution, list) or len(solution) != n_expected:\n        # Initialize a random valid-format solution if input invalid\n        sol = [random.randint(1, n_expected) for _ in range(n_expected)]\n    else:\n        sol = list(solution)\n\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n_expected + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Compute conflicts list (edges with equal colors)\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n\n    # Movement strategies\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting edge and recolor one endpoint greedily\n        u, v = random.choice(conflicts)\n        pick = random.choice([u, v])\n        current_color = sol[pick - 1]\n        # Candidate colors from 1..n_expected (cap to representation domain)\n        best_color = current_color\n        best_conf = None\n        for c in range(1, n_expected + 1):\n            if c == current_color:\n                continue\n            # Tentative recolor\n            old = sol[pick - 1]\n            sol[pick - 1] = c\n            # Count local conflicts for pick\n            c_conf = 0\n            for nb in adj[pick]:\n                if sol[nb - 1] == c:\n                    c_conf += 1\n            # Track best\n            if best_conf is None or c_conf < best_conf:\n                best_conf = c_conf\n                best_color = c\n            sol[pick - 1] = old\n        sol[pick - 1] = best_color\n        return sol, \"NB_Local\", \"conflict_directed_recolor\"\n    else:\n        # Feasible: diversify\/exploit\n        move_choice = random.random()\n        if move_choice < 0.6:\n            # Recolor a random vertex to an existing color (or another within domain) to explore color merges\n            i = random.randint(1, n_expected)\n            existing_colors = list(set(sol))\n            # Ensure at least 2 options in candidate set within domain 1..n_expected\n            candidates = list(set(existing_colors + [random.randint(1, n_expected)]))\n            new_color = random.choice(candidates)\n            while new_color == sol[i - 1] and len(candidates) > 1:\n                new_color = random.choice(candidates)\n            sol[i - 1] = new_color\n            return sol, \"NB_Local\", \"feasible_diversify_recolor\"\n        else:\n            # Color-swap on two colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a, b = random.sample(colors_present, 2)\n                # Swap colors a and b on a random subset (Kempe-like partial swap)\n                idxs = [i for i, x in enumerate(sol) if x in (a, b)]\n                k = max(1, len(idxs) \/\/ 2)\n                chosen = set(random.sample(idxs, k))\n                for i in chosen:\n                    sol[i] = a if sol[i] == b else (b if sol[i] == a else sol[i])\n                return sol, \"NB_Local\", \"partial_color_swap\"\n            else:\n                # Fallback to recolor if only one color present\n                i = random.randint(1, n_expected)\n                new_color = random.randint(1, n_expected)\n                while new_color == sol[i - 1]:\n                    new_color = random.randint(1, n_expected)\n                sol[i - 1] = new_color\n                return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n_expected = 9\n    # Start from a copy or random valid-format solution if invalid\n    if not isinstance(solution, list) or len(solution) != n_expected:\n        sol = [random.randint(1, n_expected) for _ in range(n_expected)]\n    else:\n        sol = list(solution)\n\n    # Strong perturbation: multiple random recolors within domain 1..9\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        i = random.randint(0, n_expected - 1)\n        new_color = random.randint(1, n_expected)\n        # Avoid null move if possible\n        tries = 0\n        while new_color == sol[i] and tries < 5:\n            new_color = random.randint(1, n_expected)\n            tries += 1\n        sol[i] = new_color\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000953582}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_1_TO_9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1 or x > n_expected:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return BIG \/\/ 4 + conflicts\n    # Feasible: number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbour_solution, NB_Type, Movement_Type)\n    n_expected = 9\n    # Defensive copy and validation of input format\n    if not isinstance(solution, list) or len(solution) != n_expected:\n        # Initialize a random valid-format solution if input invalid\n        sol = [random.randint(1, n_expected) for _ in range(n_expected)]\n    else:\n        sol = list(solution)\n\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n_expected + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Compute conflicts list (edges with equal colors)\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n\n    # Movement strategies\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting edge and recolor one endpoint greedily\n        u, v = random.choice(conflicts)\n        pick = random.choice([u, v])\n        current_color = sol[pick - 1]\n        # Candidate colors from 1..n_expected (cap to representation domain)\n        best_color = current_color\n        best_conf = None\n        for c in range(1, n_expected + 1):\n            if c == current_color:\n                continue\n            # Tentative recolor\n            old = sol[pick - 1]\n            sol[pick - 1] = c\n            # Count local conflicts for pick\n            c_conf = 0\n            for nb in adj[pick]:\n                if sol[nb - 1] == c:\n                    c_conf += 1\n            # Track best\n            if best_conf is None or c_conf < best_conf:\n                best_conf = c_conf\n                best_color = c\n            sol[pick - 1] = old\n        sol[pick - 1] = best_color\n        return sol, \"NB_Local\", \"conflict_directed_recolor\"\n    else:\n        # Feasible: diversify\/exploit\n        move_choice = random.random()\n        if move_choice < 0.6:\n            # Recolor a random vertex to an existing color (or another within domain) to explore color merges\n            i = random.randint(1, n_expected)\n            existing_colors = list(set(sol))\n            # Ensure at least 2 options in candidate set within domain 1..n_expected\n            candidates = list(set(existing_colors + [random.randint(1, n_expected)]))\n            new_color = random.choice(candidates)\n            while new_color == sol[i - 1] and len(candidates) > 1:\n                new_color = random.choice(candidates)\n            sol[i - 1] = new_color\n            return sol, \"NB_Local\", \"feasible_diversify_recolor\"\n        else:\n            # Color-swap on two colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                a, b = random.sample(colors_present, 2)\n                # Swap colors a and b on a random subset (Kempe-like partial swap)\n                idxs = [i for i, x in enumerate(sol) if x in (a, b)]\n                k = max(1, len(idxs) \/\/ 2)\n                chosen = set(random.sample(idxs, k))\n                for i in chosen:\n                    sol[i] = a if sol[i] == b else (b if sol[i] == a else sol[i])\n                return sol, \"NB_Local\", \"partial_color_swap\"\n            else:\n                # Fallback to recolor if only one color present\n                i = random.randint(1, n_expected)\n                new_color = random.randint(1, n_expected)\n                while new_color == sol[i - 1]:\n                    new_color = random.randint(1, n_expected)\n                sol[i - 1] = new_color\n                return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n_expected = 9\n    # Start from a copy or random valid-format solution if invalid\n    if not isinstance(solution, list) or len(solution) != n_expected:\n        sol = [random.randint(1, n_expected) for _ in range(n_expected)]\n    else:\n        sol = list(solution)\n\n    # Strong perturbation: multiple random recolors within domain 1..9\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        i = random.randint(0, n_expected - 1)\n        new_color = random.randint(1, n_expected)\n        # Avoid null move if possible\n        tries = 0\n        while new_color == sol[i] and tries < 5:\n            new_color = random.randint(1, n_expected)\n            tries += 1\n        sol[i] = new_color\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000920751}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation: positive integers\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Improved gradient: prioritize fewer conflicts, then fewer colors\n        # Weight >= n ensures conflicts dominate distinct color count\n        W = n_expected + 1\n        return BIG \/\/ 4 + conflicts * W + distinct_colors\n    # Feasible: number of distinct colors\n    return distinct_colors\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid_list(solution):\n        # Simple greedy constructive (Largest Degree First)\n        edges = [\n            (1,2),(1,3),(1,7),(1,8),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,7),(3,8),(3,9),\n            (4,5),(4,6),(4,7),(4,8),(4,9),\n            (6,7),(6,8),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n + 1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        sol = [0] * n\n        for u in order:\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n    else:\n        sol = list(solution)\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Compute conflicting edges and vertices\n    conflicts = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    colors_present = list(set(sol))\n    max_color = max(colors_present) if colors_present else 1\n    # Helper: DSATUR-like recolor of one vertex using local info\n    def recolor_vertex(u):\n        nonlocal sol\n        palette = set(colors_present)\n        # Allow expansion with small probability\n        if random.random() < 0.1:\n            palette.add(max_color + 1)\n        current = sol[u - 1]\n        best_c = current\n        best_score = (10**9, 10**9)  # (local_conflicts_after, palette_increase)\n        for c in palette:\n            if c == current:\n                continue\n            # local conflicts if u colored c\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_inc = 1 if (c not in set(sol)) else 0\n            cand = (loc_conf, pal_inc)\n            if cand < best_score:\n                best_score = cand\n                best_c = c\n        if best_c != current:\n            sol[u - 1] = best_c\n            return True\n        # fallback random change within palette\n        candidates = list(palette - {current})\n        if candidates:\n            sol[u - 1] = random.choice(candidates)\n            return True\n        return False\n    # Helper: Kempe chain swap between colors a and b on a random component\n    def kempe_swap(a, b):\n        nonlocal sol\n        vertices_ab = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not vertices_ab:\n            return False\n        start_candidates = [i for i in vertices_ab]\n        random.shuffle(start_candidates)\n        visited = set()\n        for start in start_candidates:\n            if start in visited:\n                continue\n            # BFS to get component in (a,b)-induced subgraph\n            comp = []\n            q = deque([start])\n            visited.add(start)\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in visited and sol[v - 1] in (a, b):\n                        visited.add(v)\n                        q.append(v)\n            # Perform swap on this component\n            changed = False\n            for u in comp:\n                c = sol[u - 1]\n                if c == a:\n                    sol[u - 1] = b\n                    changed = True\n                elif c == b:\n                    sol[u - 1] = a\n                    changed = True\n            if changed:\n                return True\n        return False\n    if conflicts:\n        # Conflict-directed move: pick a conflicting vertex with highest degree saturation\n        cand_vertices = list(conflict_vertices)\n        # DSATUR criterion: distinct neighbor colors count, break ties by degree\n        def dsat(u):\n            neigh_cols = {sol[v - 1] for v in adj[u]}\n            return (len(neigh_cols), len(adj[u]))\n        u = max(cand_vertices, key=dsat)\n        recolor_vertex(u)\n        return sol, \"NB_Local\", \"conflict_DSATUR_recolor\"\n    else:\n        # Feasible: try Kempe chain to reduce palette or diversify safely\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        if len(colors_present) >= 2:\n            # Target a rare color and another random color\n            rare = min(colors_present, key=lambda c: counts[c])\n            other_choices = [c for c in colors_present if c != rare]\n            a = random.choice(other_choices)\n            b = rare\n            # Randomize order\n            if random.random() < 0.5:\n                a, b = b, a\n            if kempe_swap(a, b):\n                return sol, \"NB_Local\", \"kempe_component_swap\"\n        # Fallback: recolor a random vertex to an existing color\n        u = random.randint(1, n)\n        palette = list(set(sol))\n        if len(palette) == 1:\n            palette.append(max(palette) + 1)\n        new_c = random.choice([c for c in palette if c != sol[u - 1]])\n        sol[u - 1] = new_c\n        return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    colors_present = list(set(sol))\n    max_color = max(colors_present) if colors_present else 1\n    # Kempe chain helper\n    def kempe_swap(a, b):\n        nonlocal sol\n        vertices_ab = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not vertices_ab:\n            return False\n        start = random.choice(vertices_ab)\n        visited = set([start])\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            c = sol[u - 1]\n            sol[u - 1] = a if c == b else (b if c == a else c)\n        return True\n    # Strong but structured perturbation: k steps\n    k = random.randint(2, 3)\n    for _ in range(k):\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            # Recolor a conflict-prone vertex or random one\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            if random.random() < 0.2:\n                palette.add(max_color + 1)\n                max_color += 1\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        colors_present = list(set(sol))\n        max_color = max(colors_present)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001316957}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation: positive integers\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Improved gradient: prioritize fewer conflicts, then fewer colors\n        # Weight >= n ensures conflicts dominate distinct color count\n        W = n_expected + 1\n        return BIG \/\/ 4 + conflicts * W + distinct_colors\n    # Feasible: number of distinct colors\n    return distinct_colors\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid_list(solution):\n        # Simple greedy constructive (Largest Degree First)\n        edges = [\n            (1,2),(1,3),(1,7),(1,8),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,7),(3,8),(3,9),\n            (4,5),(4,6),(4,7),(4,8),(4,9),\n            (6,7),(6,8),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n + 1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        sol = [0] * n\n        for u in order:\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n    else:\n        sol = list(solution)\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Compute conflicting edges and vertices\n    conflicts = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    colors_present = list(set(sol))\n    max_color = max(colors_present) if colors_present else 1\n    # Helper: DSATUR-like recolor of one vertex using local info\n    def recolor_vertex(u):\n        nonlocal sol\n        palette = set(colors_present)\n        # Allow expansion with small probability\n        if random.random() < 0.1:\n            palette.add(max_color + 1)\n        current = sol[u - 1]\n        best_c = current\n        best_score = (10**9, 10**9)  # (local_conflicts_after, palette_increase)\n        for c in palette:\n            if c == current:\n                continue\n            # local conflicts if u colored c\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_inc = 1 if (c not in set(sol)) else 0\n            cand = (loc_conf, pal_inc)\n            if cand < best_score:\n                best_score = cand\n                best_c = c\n        if best_c != current:\n            sol[u - 1] = best_c\n            return True\n        # fallback random change within palette\n        candidates = list(palette - {current})\n        if candidates:\n            sol[u - 1] = random.choice(candidates)\n            return True\n        return False\n    # Helper: Kempe chain swap between colors a and b on a random component\n    def kempe_swap(a, b):\n        nonlocal sol\n        vertices_ab = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not vertices_ab:\n            return False\n        start_candidates = [i for i in vertices_ab]\n        random.shuffle(start_candidates)\n        visited = set()\n        for start in start_candidates:\n            if start in visited:\n                continue\n            # BFS to get component in (a,b)-induced subgraph\n            comp = []\n            q = deque([start])\n            visited.add(start)\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in visited and sol[v - 1] in (a, b):\n                        visited.add(v)\n                        q.append(v)\n            # Perform swap on this component\n            changed = False\n            for u in comp:\n                c = sol[u - 1]\n                if c == a:\n                    sol[u - 1] = b\n                    changed = True\n                elif c == b:\n                    sol[u - 1] = a\n                    changed = True\n            if changed:\n                return True\n        return False\n    if conflicts:\n        # Conflict-directed move: pick a conflicting vertex with highest degree saturation\n        cand_vertices = list(conflict_vertices)\n        # DSATUR criterion: distinct neighbor colors count, break ties by degree\n        def dsat(u):\n            neigh_cols = {sol[v - 1] for v in adj[u]}\n            return (len(neigh_cols), len(adj[u]))\n        u = max(cand_vertices, key=dsat)\n        recolor_vertex(u)\n        return sol, \"NB_Local\", \"conflict_DSATUR_recolor\"\n    else:\n        # Feasible: try Kempe chain to reduce palette or diversify safely\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        if len(colors_present) >= 2:\n            # Target a rare color and another random color\n            rare = min(colors_present, key=lambda c: counts[c])\n            other_choices = [c for c in colors_present if c != rare]\n            a = random.choice(other_choices)\n            b = rare\n            # Randomize order\n            if random.random() < 0.5:\n                a, b = b, a\n            if kempe_swap(a, b):\n                return sol, \"NB_Local\", \"kempe_component_swap\"\n        # Fallback: recolor a random vertex to an existing color\n        u = random.randint(1, n)\n        palette = list(set(sol))\n        if len(palette) == 1:\n            palette.append(max(palette) + 1)\n        new_c = random.choice([c for c in palette if c != sol[u - 1]])\n        sol[u - 1] = new_c\n        return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    colors_present = list(set(sol))\n    max_color = max(colors_present) if colors_present else 1\n    # Kempe chain helper\n    def kempe_swap(a, b):\n        nonlocal sol\n        vertices_ab = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not vertices_ab:\n            return False\n        start = random.choice(vertices_ab)\n        visited = set([start])\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            c = sol[u - 1]\n            sol[u - 1] = a if c == b else (b if c == a else c)\n        return True\n    # Strong but structured perturbation: k steps\n    k = random.randint(2, 3)\n    for _ in range(k):\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            # Recolor a conflict-prone vertex or random one\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            if random.random() < 0.2:\n                palette.add(max_color + 1)\n                max_color += 1\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        colors_present = list(set(sol))\n        max_color = max(colors_present)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001524138}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation: positive integers\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Improved gradient: prioritize fewer conflicts, then fewer colors\n        # Weight >= n ensures conflicts dominate distinct color count\n        W = n_expected + 1\n        return BIG \/\/ 4 + conflicts * W + distinct_colors\n    # Feasible: number of distinct colors\n    return distinct_colors\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid_list(solution):\n        # Simple greedy constructive (Largest Degree First)\n        edges = [\n            (1,2),(1,3),(1,7),(1,8),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,7),(3,8),(3,9),\n            (4,5),(4,6),(4,7),(4,8),(4,9),\n            (6,7),(6,8),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n + 1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        sol = [0] * n\n        for u in order:\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n    else:\n        sol = list(solution)\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Compute conflicting edges and vertices\n    conflicts = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    colors_present = list(set(sol))\n    max_color = max(colors_present) if colors_present else 1\n    # Helper: DSATUR-like recolor of one vertex using local info\n    def recolor_vertex(u):\n        nonlocal sol\n        palette = set(colors_present)\n        # Allow expansion with small probability\n        if random.random() < 0.1:\n            palette.add(max_color + 1)\n        current = sol[u - 1]\n        best_c = current\n        best_score = (10**9, 10**9)  # (local_conflicts_after, palette_increase)\n        for c in palette:\n            if c == current:\n                continue\n            # local conflicts if u colored c\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_inc = 1 if (c not in set(sol)) else 0\n            cand = (loc_conf, pal_inc)\n            if cand < best_score:\n                best_score = cand\n                best_c = c\n        if best_c != current:\n            sol[u - 1] = best_c\n            return True\n        # fallback random change within palette\n        candidates = list(palette - {current})\n        if candidates:\n            sol[u - 1] = random.choice(candidates)\n            return True\n        return False\n    # Helper: Kempe chain swap between colors a and b on a random component\n    def kempe_swap(a, b):\n        nonlocal sol\n        vertices_ab = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not vertices_ab:\n            return False\n        start_candidates = [i for i in vertices_ab]\n        random.shuffle(start_candidates)\n        visited = set()\n        for start in start_candidates:\n            if start in visited:\n                continue\n            # BFS to get component in (a,b)-induced subgraph\n            comp = []\n            q = deque([start])\n            visited.add(start)\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in visited and sol[v - 1] in (a, b):\n                        visited.add(v)\n                        q.append(v)\n            # Perform swap on this component\n            changed = False\n            for u in comp:\n                c = sol[u - 1]\n                if c == a:\n                    sol[u - 1] = b\n                    changed = True\n                elif c == b:\n                    sol[u - 1] = a\n                    changed = True\n            if changed:\n                return True\n        return False\n    if conflicts:\n        # Conflict-directed move: pick a conflicting vertex with highest degree saturation\n        cand_vertices = list(conflict_vertices)\n        # DSATUR criterion: distinct neighbor colors count, break ties by degree\n        def dsat(u):\n            neigh_cols = {sol[v - 1] for v in adj[u]}\n            return (len(neigh_cols), len(adj[u]))\n        u = max(cand_vertices, key=dsat)\n        recolor_vertex(u)\n        return sol, \"NB_Local\", \"conflict_DSATUR_recolor\"\n    else:\n        # Feasible: try Kempe chain to reduce palette or diversify safely\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        if len(colors_present) >= 2:\n            # Target a rare color and another random color\n            rare = min(colors_present, key=lambda c: counts[c])\n            other_choices = [c for c in colors_present if c != rare]\n            a = random.choice(other_choices)\n            b = rare\n            # Randomize order\n            if random.random() < 0.5:\n                a, b = b, a\n            if kempe_swap(a, b):\n                return sol, \"NB_Local\", \"kempe_component_swap\"\n        # Fallback: recolor a random vertex to an existing color\n        u = random.randint(1, n)\n        palette = list(set(sol))\n        if len(palette) == 1:\n            palette.append(max(palette) + 1)\n        new_c = random.choice([c for c in palette if c != sol[u - 1]])\n        sol[u - 1] = new_c\n        return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    colors_present = list(set(sol))\n    max_color = max(colors_present) if colors_present else 1\n    # Kempe chain helper\n    def kempe_swap(a, b):\n        nonlocal sol\n        vertices_ab = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not vertices_ab:\n            return False\n        start = random.choice(vertices_ab)\n        visited = set([start])\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            c = sol[u - 1]\n            sol[u - 1] = a if c == b else (b if c == a else c)\n        return True\n    # Strong but structured perturbation: k steps\n    k = random.randint(2, 3)\n    for _ in range(k):\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            # Recolor a conflict-prone vertex or random one\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            if random.random() < 0.2:\n                palette.add(max_color + 1)\n                max_color += 1\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        colors_present = list(set(sol))\n        max_color = max(colors_present)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001452708}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation: positive integers\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Conflicts dominate palette size\n        W = n_expected + 1\n        return BIG \/\/ 4 + conflicts * W + distinct_colors\n    # Feasible: number of distinct colors\n    return distinct_colors\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbour generator with repair, DSATUR-guided recolor, Kempe swaps, and color normalization\ndef generate_neighbour(solution):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    # Normalize colors to [1..k] in order of first appearance to reduce symmetry\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        norm = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            norm.append(mapping[x])\n        return norm\n\n    if not valid_list(solution):\n        # DSATUR constructive\n        edges = [\n            (1,2),(1,3),(1,7),(1,8),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,7),(3,8),(3,9),\n            (4,5),(4,6),(4,7),(4,8),(4,9),\n            (6,7),(6,8),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n + 1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0] * n\n        uncolored = set(range(1, n + 1))\n        while uncolored:\n            def satdeg(u):\n                return (len({sol[v - 1] for v in adj[u] if sol[v - 1] > 0}), len(adj[u]))\n            u = max(uncolored, key=satdeg)\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n            uncolored.remove(u)\n        sol = normalize(sol)\n    else:\n        sol = normalize(list(solution))\n\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Compute conflicts and color stats\n    conflicts = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    colors_present = list(sorted(set(sol)))\n\n    def recolor_vertex_min_conf(u):\n        nonlocal sol\n        current = sol[u - 1]\n        palette = set(colors_present)\n        best = current\n        best_tuple = (10**9, 10**9)\n        for c in palette:\n            if c == current:\n                continue\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_inc = 0  # using existing palette only\n            cand = (loc_conf, pal_inc)\n            if cand < best_tuple:\n                best_tuple = cand\n                best = c\n        if best != current:\n            sol[u - 1] = best\n            return True\n        # fallback: try introducing one higher color with small prob for escape\n        if random.random() < 0.05:\n            sol[u - 1] = max(colors_present) + 1\n            return True\n        return False\n\n    def kempe_swap(a, b):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = random.choice(verts)\n        visited = set([start])\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        changed = False\n        for u in comp:\n            c = sol[u - 1]\n            if c == a:\n                sol[u - 1] = b\n                changed = True\n            elif c == b:\n                sol[u - 1] = a\n                changed = True\n        return changed\n\n    move_type = \"\"\n    if conflicts:\n        # Conflict-directed: DSATUR-like choice\n        def dsat(u):\n            neigh_cols = {sol[v - 1] for v in adj[u]}\n            return (len(neigh_cols), len(adj[u]))\n        u = max(list(conflict_vertices), key=dsat)\n        recolor_vertex_min_conf(u)\n        sol = normalize(sol)\n        move_type = \"conflict_DSATUR_recolor\"\n        return sol, \"NB_Local\", move_type\n    else:\n        # Feasible: try reduce palette using color-class elimination then Kempe\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        # Try recolor vertices of the rarest color\n        rare = min(colors_present, key=lambda c: counts[c])\n        rare_vertices = [i for i in range(1, n + 1) if sol[i - 1] == rare]\n        success_all = True\n        for u in rare_vertices:\n            # try recolor u to existing colors excluding 'rare'\n            target_palette = [c for c in colors_present if c != rare]\n            random.shuffle(target_palette)\n            moved = False\n            for c in target_palette:\n                if all(sol[v - 1] != c for v in adj[u]):\n                    sol[u - 1] = c\n                    moved = True\n                    break\n            if not moved:\n                success_all = False\n                break\n        if success_all:\n            # drop rare color\n            sol = normalize(sol)\n            move_type = \"feasible_color_elimination\"\n            return sol, \"NB_Local\", move_type\n        # Else attempt Kempe swap between rare and a random other color\n        other = random.choice([c for c in colors_present if c != rare]) if len(colors_present) > 1 else rare\n        if kempe_swap(rare, other):\n            sol = normalize(sol)\n            move_type = \"kempe_component_swap\"\n            return sol, \"NB_Local\", move_type\n        # Fallback: recolor a random vertex to any existing different color\n        u = random.randint(1, n)\n        palette = [c for c in colors_present if c != sol[u - 1]]\n        if not palette:\n            palette = [max(colors_present) + 1]\n        sol[u - 1] = random.choice(palette)\n        sol = normalize(sol)\n        move_type = \"fallback_recolor\"\n        return sol, \"NB_Local\", move_type\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    # Validate\/repair input\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = normalize(list(solution))\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap(a, b):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            c = sol[u - 1]\n            sol[u - 1] = a if c == b else (b if c == a else c)\n        return True\n\n    # Strong but structured perturbation: multiple steps mixing Kempe and recolors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        colors_present = list(sorted(set(sol)))\n        max_color = max(colors_present) if colors_present else 1\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            if random.random() < 0.2:\n                palette.add(max_color + 1)\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001507688}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation: positive integers\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Conflicts dominate palette size\n        W = n_expected + 1\n        return BIG \/\/ 4 + conflicts * W + distinct_colors\n    # Feasible: number of distinct colors\n    return distinct_colors\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbour generator with repair, DSATUR-guided recolor, Kempe swaps, and color normalization\ndef generate_neighbour(solution):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    # Normalize colors to [1..k] in order of first appearance to reduce symmetry\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        norm = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            norm.append(mapping[x])\n        return norm\n\n    if not valid_list(solution):\n        # DSATUR constructive\n        edges = [\n            (1,2),(1,3),(1,7),(1,8),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,7),(3,8),(3,9),\n            (4,5),(4,6),(4,7),(4,8),(4,9),\n            (6,7),(6,8),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n + 1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0] * n\n        uncolored = set(range(1, n + 1))\n        while uncolored:\n            def satdeg(u):\n                return (len({sol[v - 1] for v in adj[u] if sol[v - 1] > 0}), len(adj[u]))\n            u = max(uncolored, key=satdeg)\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n            uncolored.remove(u)\n        sol = normalize(sol)\n    else:\n        sol = normalize(list(solution))\n\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Compute conflicts and color stats\n    conflicts = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    colors_present = list(sorted(set(sol)))\n\n    def recolor_vertex_min_conf(u):\n        nonlocal sol\n        current = sol[u - 1]\n        palette = set(colors_present)\n        best = current\n        best_tuple = (10**9, 10**9)\n        for c in palette:\n            if c == current:\n                continue\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_inc = 0  # using existing palette only\n            cand = (loc_conf, pal_inc)\n            if cand < best_tuple:\n                best_tuple = cand\n                best = c\n        if best != current:\n            sol[u - 1] = best\n            return True\n        # fallback: try introducing one higher color with small prob for escape\n        if random.random() < 0.05:\n            sol[u - 1] = max(colors_present) + 1\n            return True\n        return False\n\n    def kempe_swap(a, b):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = random.choice(verts)\n        visited = set([start])\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        changed = False\n        for u in comp:\n            c = sol[u - 1]\n            if c == a:\n                sol[u - 1] = b\n                changed = True\n            elif c == b:\n                sol[u - 1] = a\n                changed = True\n        return changed\n\n    move_type = \"\"\n    if conflicts:\n        # Conflict-directed: DSATUR-like choice\n        def dsat(u):\n            neigh_cols = {sol[v - 1] for v in adj[u]}\n            return (len(neigh_cols), len(adj[u]))\n        u = max(list(conflict_vertices), key=dsat)\n        recolor_vertex_min_conf(u)\n        sol = normalize(sol)\n        move_type = \"conflict_DSATUR_recolor\"\n        return sol, \"NB_Local\", move_type\n    else:\n        # Feasible: try reduce palette using color-class elimination then Kempe\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        # Try recolor vertices of the rarest color\n        rare = min(colors_present, key=lambda c: counts[c])\n        rare_vertices = [i for i in range(1, n + 1) if sol[i - 1] == rare]\n        success_all = True\n        for u in rare_vertices:\n            # try recolor u to existing colors excluding 'rare'\n            target_palette = [c for c in colors_present if c != rare]\n            random.shuffle(target_palette)\n            moved = False\n            for c in target_palette:\n                if all(sol[v - 1] != c for v in adj[u]):\n                    sol[u - 1] = c\n                    moved = True\n                    break\n            if not moved:\n                success_all = False\n                break\n        if success_all:\n            # drop rare color\n            sol = normalize(sol)\n            move_type = \"feasible_color_elimination\"\n            return sol, \"NB_Local\", move_type\n        # Else attempt Kempe swap between rare and a random other color\n        other = random.choice([c for c in colors_present if c != rare]) if len(colors_present) > 1 else rare\n        if kempe_swap(rare, other):\n            sol = normalize(sol)\n            move_type = \"kempe_component_swap\"\n            return sol, \"NB_Local\", move_type\n        # Fallback: recolor a random vertex to any existing different color\n        u = random.randint(1, n)\n        palette = [c for c in colors_present if c != sol[u - 1]]\n        if not palette:\n            palette = [max(colors_present) + 1]\n        sol[u - 1] = random.choice(palette)\n        sol = normalize(sol)\n        move_type = \"fallback_recolor\"\n        return sol, \"NB_Local\", move_type\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    # Validate\/repair input\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = normalize(list(solution))\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap(a, b):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            c = sol[u - 1]\n            sol[u - 1] = a if c == b else (b if c == a else c)\n        return True\n\n    # Strong but structured perturbation: multiple steps mixing Kempe and recolors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        colors_present = list(sorted(set(sol)))\n        max_color = max(colors_present) if colors_present else 1\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            if random.random() < 0.2:\n                palette.add(max_color + 1)\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001747022}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    n_expected = 9\n    # Type and length checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n_expected:\n        return BIG + abs(len(solution) - n_expected)\n    # Label validation: positive integers\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Conflict count\n    conflicts = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Conflicts dominate palette size\n        W = n_expected + 1\n        return BIG \/\/ 4 + conflicts * W + distinct_colors\n    # Feasible: number of distinct colors\n    return distinct_colors\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbour generator with repair, DSATUR-guided recolor, Kempe swaps, and color normalization\ndef generate_neighbour(solution):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    # Normalize colors to [1..k] in order of first appearance to reduce symmetry\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        norm = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            norm.append(mapping[x])\n        return norm\n\n    if not valid_list(solution):\n        # DSATUR constructive\n        edges = [\n            (1,2),(1,3),(1,7),(1,8),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,7),(3,8),(3,9),\n            (4,5),(4,6),(4,7),(4,8),(4,9),\n            (6,7),(6,8),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n + 1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0] * n\n        uncolored = set(range(1, n + 1))\n        while uncolored:\n            def satdeg(u):\n                return (len({sol[v - 1] for v in adj[u] if sol[v - 1] > 0}), len(adj[u]))\n            u = max(uncolored, key=satdeg)\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n            uncolored.remove(u)\n        sol = normalize(sol)\n    else:\n        sol = normalize(list(solution))\n\n    # Internal graph and helpers\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Compute conflicts and color stats\n    conflicts = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    colors_present = list(sorted(set(sol)))\n\n    def recolor_vertex_min_conf(u):\n        nonlocal sol\n        current = sol[u - 1]\n        palette = set(colors_present)\n        best = current\n        best_tuple = (10**9, 10**9)\n        for c in palette:\n            if c == current:\n                continue\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_inc = 0  # using existing palette only\n            cand = (loc_conf, pal_inc)\n            if cand < best_tuple:\n                best_tuple = cand\n                best = c\n        if best != current:\n            sol[u - 1] = best\n            return True\n        # fallback: try introducing one higher color with small prob for escape\n        if random.random() < 0.05:\n            sol[u - 1] = max(colors_present) + 1\n            return True\n        return False\n\n    def kempe_swap(a, b):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = random.choice(verts)\n        visited = set([start])\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        changed = False\n        for u in comp:\n            c = sol[u - 1]\n            if c == a:\n                sol[u - 1] = b\n                changed = True\n            elif c == b:\n                sol[u - 1] = a\n                changed = True\n        return changed\n\n    move_type = \"\"\n    if conflicts:\n        # Conflict-directed: DSATUR-like choice\n        def dsat(u):\n            neigh_cols = {sol[v - 1] for v in adj[u]}\n            return (len(neigh_cols), len(adj[u]))\n        u = max(list(conflict_vertices), key=dsat)\n        recolor_vertex_min_conf(u)\n        sol = normalize(sol)\n        move_type = \"conflict_DSATUR_recolor\"\n        return sol, \"NB_Local\", move_type\n    else:\n        # Feasible: try reduce palette using color-class elimination then Kempe\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        # Try recolor vertices of the rarest color\n        rare = min(colors_present, key=lambda c: counts[c])\n        rare_vertices = [i for i in range(1, n + 1) if sol[i - 1] == rare]\n        success_all = True\n        for u in rare_vertices:\n            # try recolor u to existing colors excluding 'rare'\n            target_palette = [c for c in colors_present if c != rare]\n            random.shuffle(target_palette)\n            moved = False\n            for c in target_palette:\n                if all(sol[v - 1] != c for v in adj[u]):\n                    sol[u - 1] = c\n                    moved = True\n                    break\n            if not moved:\n                success_all = False\n                break\n        if success_all:\n            # drop rare color\n            sol = normalize(sol)\n            move_type = \"feasible_color_elimination\"\n            return sol, \"NB_Local\", move_type\n        # Else attempt Kempe swap between rare and a random other color\n        other = random.choice([c for c in colors_present if c != rare]) if len(colors_present) > 1 else rare\n        if kempe_swap(rare, other):\n            sol = normalize(sol)\n            move_type = \"kempe_component_swap\"\n            return sol, \"NB_Local\", move_type\n        # Fallback: recolor a random vertex to any existing different color\n        u = random.randint(1, n)\n        palette = [c for c in colors_present if c != sol[u - 1]]\n        if not palette:\n            palette = [max(colors_present) + 1]\n        sol[u - 1] = random.choice(palette)\n        sol = normalize(sol)\n        move_type = \"fallback_recolor\"\n        return sol, \"NB_Local\", move_type\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    # Validate\/repair input\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = normalize(list(solution))\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap(a, b):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            c = sol[u - 1]\n            sol[u - 1] = a if c == b else (b if c == a else c)\n        return True\n\n    # Strong but structured perturbation: multiple steps mixing Kempe and recolors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        colors_present = list(sorted(set(sol)))\n        max_color = max(colors_present) if colors_present else 1\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            if random.random() < 0.2:\n                palette.add(max_color + 1)\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001574909}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation checks\n    n_expected = 9\n    BIG_INVALID = 10**9\n    BIG_CONFLICT = 10**6\n    if not isinstance(solution, list):\n        return BIG_INVALID\n    if len(solution) != n_expected:\n        return BIG_INVALID + abs(len(solution) - n_expected)\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG_INVALID \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Lexicographic: conflicts first, then palette size\n        # Encoded into numeric scale so fewer conflicts always better\n        return BIG_CONFLICT + conflicts * 1000 + distinct_colors\n    # Feasible: minimize number of distinct colors\n    # Add small tie-breakers (sum of colors) to stabilize ordering\n    tie = sum(solution)\n    return distinct_colors * 1000 + (tie % 997)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        norm = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            norm.append(mapping[x])\n        return norm\n\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # If invalid, construct DSATUR coloring as a start\n    if not valid_list(solution):\n        sol = [0] * n\n        uncolored = set(range(1, n + 1))\n        while uncolored:\n            def satdeg(u):\n                return (len({sol[v - 1] for v in adj[u] if sol[v - 1] > 0}), len(adj[u]))\n            u = max(uncolored, key=satdeg)\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n            uncolored.remove(u)\n        sol = normalize(sol)\n    else:\n        sol = normalize(list(solution))\n\n    # Conflict detection\n    conflict_edges = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n\n    colors_present = sorted(set(sol))\n\n    def conflicts_incident(u, col=None):\n        c = sol[u - 1] if col is None else col\n        inc = 0\n        for v in adj[u]:\n            if sol[v - 1] == c:\n                inc += 1\n        return inc\n\n    def recolor_vertex_targeted(u):\n        nonlocal sol\n        current = sol[u - 1]\n        palette = list(sorted(set(sol)))\n        best_c = current\n        best_tuple = (10**9, 10**9)\n        for c in palette:\n            if c == current:\n                continue\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_pen = 0\n            cand = (loc_conf, pal_pen)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_c = c\n        # With small adaptive probability, allow a new color to break ties when highly conflicted\n        if best_c == current:\n            if conflicts_incident(u) >= 2 and random.random() < 0.15:\n                best_c = max(colors_present) + 1\n        if best_c != current:\n            sol[u - 1] = best_c\n            return True\n        return False\n\n    def kempe_swap(a, b, anchor=None):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = anchor if (anchor is not None and sol[anchor - 1] in (a, b)) else random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        # Perform swap\n        for u in comp:\n            sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return True\n\n    if conflict_edges:\n        # Prioritize vertex by (conflicts_incident, dsat, degree)\n        def score(u):\n            return (\n                -conflicts_incident(u),\n                -len({sol[v - 1] for v in adj[u]}),\n                -len(adj[u])\n            )\n        u = min(list(conflict_vertices), key=score)\n        moved = recolor_vertex_targeted(u)\n        if not moved:\n            neigh_cols = list({sol[v - 1] for v in adj[u]})\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n                a = sol[u - 1]\n                kempe_swap(a, b, anchor=u)\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"conflict_targeted\"\n    else:\n        # Feasible: try to reduce number of colors by eliminating the smallest color class\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        rare = min(colors_present, key=lambda c: counts[c])\n        rare_vertices = [i for i in range(1, n + 1) if sol[i - 1] == rare]\n        success = True\n        for u in rare_vertices:\n            target_palette = [c for c in colors_present if c != rare]\n            random.shuffle(target_palette)\n            placed = False\n            for c in target_palette:\n                conflict = False\n                for v in adj[u]:\n                    if sol[v - 1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize(sol)\n            return sol, \"NB_Local\", \"color_class_elimination\"\n        # If failed, attempt Kempe swap between rare and a conflicting neighbor color\n        other_choices = [c for c in colors_present if c != rare]\n        if other_choices:\n            b = random.choice(other_choices)\n            kempe_swap(rare, b)\n            sol = normalize(sol)\n            return sol, \"NB_Local\", \"kempe_swap\"\n        # Fallback: degree-biased recolor of a random vertex to an existing different color\n        u = random.randint(1, n)\n        palette = [c for c in colors_present if c != sol[u - 1]]\n        if not palette:\n            palette = [max(colors_present) + 1]\n        sol[u - 1] = random.choice(palette)\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = normalize(list(solution))\n\n    def kempe_swap(a, b, anchor=None):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = anchor if (anchor is not None and sol[anchor - 1] in (a, b)) else random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return True\n\n    # Intensity based on current diversity: stronger if many colors\n    colors_present = sorted(set(sol))\n    steps = 3 if len(colors_present) >= 4 else 2\n    for _ in range(steps):\n        colors_present = sorted(set(sol))\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            # Occasionally allow introducing a new color to escape deep basins\n            if random.random() < 0.2:\n                palette.add(max(colors_present) + 1)\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001461318}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation checks\n    n_expected = 9\n    BIG_INVALID = 10**9\n    BIG_CONFLICT = 10**6\n    if not isinstance(solution, list):\n        return BIG_INVALID\n    if len(solution) != n_expected:\n        return BIG_INVALID + abs(len(solution) - n_expected)\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG_INVALID \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Lexicographic: conflicts first, then palette size\n        # Encoded into numeric scale so fewer conflicts always better\n        return BIG_CONFLICT + conflicts * 1000 + distinct_colors\n    # Feasible: minimize number of distinct colors\n    # Add small tie-breakers (sum of colors) to stabilize ordering\n    tie = sum(solution)\n    return distinct_colors * 1000 + (tie % 997)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        norm = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            norm.append(mapping[x])\n        return norm\n\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # If invalid, construct DSATUR coloring as a start\n    if not valid_list(solution):\n        sol = [0] * n\n        uncolored = set(range(1, n + 1))\n        while uncolored:\n            def satdeg(u):\n                return (len({sol[v - 1] for v in adj[u] if sol[v - 1] > 0}), len(adj[u]))\n            u = max(uncolored, key=satdeg)\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n            uncolored.remove(u)\n        sol = normalize(sol)\n    else:\n        sol = normalize(list(solution))\n\n    # Conflict detection\n    conflict_edges = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n\n    colors_present = sorted(set(sol))\n\n    def conflicts_incident(u, col=None):\n        c = sol[u - 1] if col is None else col\n        inc = 0\n        for v in adj[u]:\n            if sol[v - 1] == c:\n                inc += 1\n        return inc\n\n    def recolor_vertex_targeted(u):\n        nonlocal sol\n        current = sol[u - 1]\n        palette = list(sorted(set(sol)))\n        best_c = current\n        best_tuple = (10**9, 10**9)\n        for c in palette:\n            if c == current:\n                continue\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_pen = 0\n            cand = (loc_conf, pal_pen)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_c = c\n        # With small adaptive probability, allow a new color to break ties when highly conflicted\n        if best_c == current:\n            if conflicts_incident(u) >= 2 and random.random() < 0.15:\n                best_c = max(colors_present) + 1\n        if best_c != current:\n            sol[u - 1] = best_c\n            return True\n        return False\n\n    def kempe_swap(a, b, anchor=None):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = anchor if (anchor is not None and sol[anchor - 1] in (a, b)) else random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        # Perform swap\n        for u in comp:\n            sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return True\n\n    if conflict_edges:\n        # Prioritize vertex by (conflicts_incident, dsat, degree)\n        def score(u):\n            return (\n                -conflicts_incident(u),\n                -len({sol[v - 1] for v in adj[u]}),\n                -len(adj[u])\n            )\n        u = min(list(conflict_vertices), key=score)\n        moved = recolor_vertex_targeted(u)\n        if not moved:\n            neigh_cols = list({sol[v - 1] for v in adj[u]})\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n                a = sol[u - 1]\n                kempe_swap(a, b, anchor=u)\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"conflict_targeted\"\n    else:\n        # Feasible: try to reduce number of colors by eliminating the smallest color class\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        rare = min(colors_present, key=lambda c: counts[c])\n        rare_vertices = [i for i in range(1, n + 1) if sol[i - 1] == rare]\n        success = True\n        for u in rare_vertices:\n            target_palette = [c for c in colors_present if c != rare]\n            random.shuffle(target_palette)\n            placed = False\n            for c in target_palette:\n                conflict = False\n                for v in adj[u]:\n                    if sol[v - 1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize(sol)\n            return sol, \"NB_Local\", \"color_class_elimination\"\n        # If failed, attempt Kempe swap between rare and a conflicting neighbor color\n        other_choices = [c for c in colors_present if c != rare]\n        if other_choices:\n            b = random.choice(other_choices)\n            kempe_swap(rare, b)\n            sol = normalize(sol)\n            return sol, \"NB_Local\", \"kempe_swap\"\n        # Fallback: degree-biased recolor of a random vertex to an existing different color\n        u = random.randint(1, n)\n        palette = [c for c in colors_present if c != sol[u - 1]]\n        if not palette:\n            palette = [max(colors_present) + 1]\n        sol[u - 1] = random.choice(palette)\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = normalize(list(solution))\n\n    def kempe_swap(a, b, anchor=None):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = anchor if (anchor is not None and sol[anchor - 1] in (a, b)) else random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return True\n\n    # Intensity based on current diversity: stronger if many colors\n    colors_present = sorted(set(sol))\n    steps = 3 if len(colors_present) >= 4 else 2\n    for _ in range(steps):\n        colors_present = sorted(set(sol))\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            # Occasionally allow introducing a new color to escape deep basins\n            if random.random() < 0.2:\n                palette.add(max(colors_present) + 1)\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001578599}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSINTS_GE_1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Representation checks\n    n_expected = 9\n    BIG_INVALID = 10**9\n    BIG_CONFLICT = 10**6\n    if not isinstance(solution, list):\n        return BIG_INVALID\n    if len(solution) != n_expected:\n        return BIG_INVALID + abs(len(solution) - n_expected)\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid += 1\n    if invalid:\n        return BIG_INVALID \/\/ 2 + invalid\n    # Graph definition (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    distinct_colors = len(set(solution))\n    if conflicts > 0:\n        # Lexicographic: conflicts first, then palette size\n        # Encoded into numeric scale so fewer conflicts always better\n        return BIG_CONFLICT + conflicts * 1000 + distinct_colors\n    # Feasible: minimize number of distinct colors\n    # Add small tie-breakers (sum of colors) to stabilize ordering\n    tie = sum(solution)\n    return distinct_colors * 1000 + (tie % 997)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    # Validate\/repair input to maintain representation\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        norm = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            norm.append(mapping[x])\n        return norm\n\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # If invalid, construct DSATUR coloring as a start\n    if not valid_list(solution):\n        sol = [0] * n\n        uncolored = set(range(1, n + 1))\n        while uncolored:\n            def satdeg(u):\n                return (len({sol[v - 1] for v in adj[u] if sol[v - 1] > 0}), len(adj[u]))\n            u = max(uncolored, key=satdeg)\n            forbidden = {sol[v - 1] for v in adj[u] if sol[v - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[u - 1] = c\n            uncolored.remove(u)\n        sol = normalize(sol)\n    else:\n        sol = normalize(list(solution))\n\n    # Conflict detection\n    conflict_edges = []\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u, v))\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n\n    colors_present = sorted(set(sol))\n\n    def conflicts_incident(u, col=None):\n        c = sol[u - 1] if col is None else col\n        inc = 0\n        for v in adj[u]:\n            if sol[v - 1] == c:\n                inc += 1\n        return inc\n\n    def recolor_vertex_targeted(u):\n        nonlocal sol\n        current = sol[u - 1]\n        palette = list(sorted(set(sol)))\n        best_c = current\n        best_tuple = (10**9, 10**9)\n        for c in palette:\n            if c == current:\n                continue\n            loc_conf = 0\n            for v in adj[u]:\n                if sol[v - 1] == c:\n                    loc_conf += 1\n            pal_pen = 0\n            cand = (loc_conf, pal_pen)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_c = c\n        # With small adaptive probability, allow a new color to break ties when highly conflicted\n        if best_c == current:\n            if conflicts_incident(u) >= 2 and random.random() < 0.15:\n                best_c = max(colors_present) + 1\n        if best_c != current:\n            sol[u - 1] = best_c\n            return True\n        return False\n\n    def kempe_swap(a, b, anchor=None):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = anchor if (anchor is not None and sol[anchor - 1] in (a, b)) else random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        # Perform swap\n        for u in comp:\n            sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return True\n\n    if conflict_edges:\n        # Prioritize vertex by (conflicts_incident, dsat, degree)\n        def score(u):\n            return (\n                -conflicts_incident(u),\n                -len({sol[v - 1] for v in adj[u]}),\n                -len(adj[u])\n            )\n        u = min(list(conflict_vertices), key=score)\n        moved = recolor_vertex_targeted(u)\n        if not moved:\n            neigh_cols = list({sol[v - 1] for v in adj[u]})\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n                a = sol[u - 1]\n                kempe_swap(a, b, anchor=u)\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"conflict_targeted\"\n    else:\n        # Feasible: try to reduce number of colors by eliminating the smallest color class\n        counts = {c: 0 for c in colors_present}\n        for x in sol:\n            counts[x] += 1\n        rare = min(colors_present, key=lambda c: counts[c])\n        rare_vertices = [i for i in range(1, n + 1) if sol[i - 1] == rare]\n        success = True\n        for u in rare_vertices:\n            target_palette = [c for c in colors_present if c != rare]\n            random.shuffle(target_palette)\n            placed = False\n            for c in target_palette:\n                conflict = False\n                for v in adj[u]:\n                    if sol[v - 1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize(sol)\n            return sol, \"NB_Local\", \"color_class_elimination\"\n        # If failed, attempt Kempe swap between rare and a conflicting neighbor color\n        other_choices = [c for c in colors_present if c != rare]\n        if other_choices:\n            b = random.choice(other_choices)\n            kempe_swap(rare, b)\n            sol = normalize(sol)\n            return sol, \"NB_Local\", \"kempe_swap\"\n        # Fallback: degree-biased recolor of a random vertex to an existing different color\n        u = random.randint(1, n)\n        palette = [c for c in colors_present if c != sol[u - 1]]\n        if not palette:\n            palette = [max(colors_present) + 1]\n        sol[u - 1] = random.choice(palette)\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"fallback_recolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    def valid_list(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not valid_list(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = normalize(list(solution))\n\n    def kempe_swap(a, b, anchor=None):\n        nonlocal sol\n        verts = [i for i in range(1, n + 1) if sol[i - 1] in (a, b)]\n        if not verts:\n            return False\n        start = anchor if (anchor is not None and sol[anchor - 1] in (a, b)) else random.choice(verts)\n        visited = {start}\n        q = deque([start])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v - 1] in (a, b):\n                    visited.add(v)\n                    q.append(v)\n        for u in comp:\n            sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return True\n\n    # Intensity based on current diversity: stronger if many colors\n    colors_present = sorted(set(sol))\n    steps = 3 if len(colors_present) >= 4 else 2\n    for _ in range(steps):\n        colors_present = sorted(set(sol))\n        if len(colors_present) >= 2 and random.random() < 0.7:\n            a, b = random.sample(colors_present, 2)\n            kempe_swap(a, b)\n        else:\n            u = random.randint(1, n)\n            palette = set(colors_present)\n            # Occasionally allow introducing a new color to escape deep basins\n            if random.random() < 0.2:\n                palette.add(max(colors_present) + 1)\n            if sol[u - 1] in palette and len(palette) > 1:\n                palette.discard(sol[u - 1])\n            sol[u - 1] = random.choice(list(palette))\n        sol = normalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00156161}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9.COMPRESSED_COLORS. Each solution is a string of 9 comma-separated positive integers representing colors for nodes 1..9. Colors are normalized to have no gaps: used color set equals {1..k}. Example: '1,2,3,1,3,3,4,4,2'.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring returns 0.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    EXPECTED_K = 4\n\n    penalty = 0.0\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return 1e9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n    if n != 9:\n        penalty += 1e8 + abs(n - 9) * 1e6\n    # Coerce to ints\n    coerced = []\n    invalid_entries = 0\n    for p in parts[:9]:  # consider only first 9 if longer; length penalty already added\n        try:\n            coerced.append(int(p))\n        except Exception:\n            coerced.append(0)\n            invalid_entries += 1\n    # If shorter, pad zeros (will be penalized by range checks)\n    while len(coerced) < 9:\n        coerced.append(0)\n    penalty += invalid_entries * 1e7\n\n    # Determine k and basic range checks\n    k = max(coerced) if coerced else 0\n    if k <= 0:\n        penalty += 1e8\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in coerced if c < 1 or c > k)\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in coerced if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            conflicts += 1\n    penalty += conflicts * 1e6\n\n    # Objective alignment: prefer k=EXPECTED_K when feasible\n    penalty += abs(k - EXPECTED_K) * 1e4\n\n    # Perfect feasibility at EXPECTED_K yields 0\n    if penalty == 0:\n        return 0.0\n    return float(penalty)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef _parse_csv(solution_str):\n    parts = [p.strip() for p in solution_str.split(',') if p.strip() != '']\n    vals = []\n    for p in parts[:9]:\n        try:\n            vals.append(int(p))\n        except Exception:\n            vals.append(1)\n    while len(vals) < 9:\n        vals.append(1)\n    return vals[:9]\n\n\ndef _normalize_colors(vals):\n    # Compress used colors to 1..k by order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in vals:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _to_csv(vals):\n    return ','.join(str(x) for x in vals)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: CSV string neighbor; single-node recolor with color-compaction.\n    \"\"\"\n    vals = _parse_csv(solution)\n    n = 9\n    # Current k\n    k = max(1, max(vals))\n    # Candidate color palette allows exploring up to k+1 but capped at 4 (known feasible)\n    max_palette = max(4, k)\n    idx = random.randrange(n)\n    current = vals[idx]\n    # Ensure a different color is chosen\n    choices = [c for c in range(1, max_palette + 1) if c != current]\n    if not choices:\n        choices = [1 if current != 1 else 2]\n    vals[idx] = random.choice(choices)\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Perturbacion":"import random\n\n\ndef _parse_csv(solution_str):\n    parts = [p.strip() for p in solution_str.split(',') if p.strip() != '']\n    vals = []\n    for p in parts[:9]:\n        try:\n            vals.append(int(p))\n        except Exception:\n            vals.append(1)\n    while len(vals) < 9:\n        vals.append(1)\n    return vals[:9]\n\n\ndef _normalize_colors(vals):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in vals:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _to_csv(vals):\n    return ','.join(str(x) for x in vals)\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Input: solution (CSV string)\n    Output: CSV string after stronger perturbation: reassign t random positions.\n    \"\"\"\n    vals = _parse_csv(solution)\n    n = 9\n    # Reassign t positions with colors from 1..4, where t in [2,4]\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for i in idxs:\n        vals[i] = random.randint(1, 4)\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000749069}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9.COMPRESSED_COLORS. Each solution is a string of 9 comma-separated positive integers representing colors for nodes 1..9. Colors are normalized to have no gaps: used color set equals {1..k}. Example: '1,2,3,1,3,3,4,4,2'.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring returns 0.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    EXPECTED_K = 4\n\n    penalty = 0.0\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return 1e9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n    if n != 9:\n        penalty += 1e8 + abs(n - 9) * 1e6\n    # Coerce to ints\n    coerced = []\n    invalid_entries = 0\n    for p in parts[:9]:  # consider only first 9 if longer; length penalty already added\n        try:\n            coerced.append(int(p))\n        except Exception:\n            coerced.append(0)\n            invalid_entries += 1\n    # If shorter, pad zeros (will be penalized by range checks)\n    while len(coerced) < 9:\n        coerced.append(0)\n    penalty += invalid_entries * 1e7\n\n    # Determine k and basic range checks\n    k = max(coerced) if coerced else 0\n    if k <= 0:\n        penalty += 1e8\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in coerced if c < 1 or c > k)\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in coerced if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            conflicts += 1\n    penalty += conflicts * 1e6\n\n    # Objective alignment: prefer k=EXPECTED_K when feasible\n    penalty += abs(k - EXPECTED_K) * 1e4\n\n    # Perfect feasibility at EXPECTED_K yields 0\n    if penalty == 0:\n        return 0.0\n    return float(penalty)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef _parse_csv(solution_str):\n    parts = [p.strip() for p in solution_str.split(',') if p.strip() != '']\n    vals = []\n    for p in parts[:9]:\n        try:\n            vals.append(int(p))\n        except Exception:\n            vals.append(1)\n    while len(vals) < 9:\n        vals.append(1)\n    return vals[:9]\n\n\ndef _normalize_colors(vals):\n    # Compress used colors to 1..k by order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in vals:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _to_csv(vals):\n    return ','.join(str(x) for x in vals)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: CSV string neighbor; single-node recolor with color-compaction.\n    \"\"\"\n    vals = _parse_csv(solution)\n    n = 9\n    # Current k\n    k = max(1, max(vals))\n    # Candidate color palette allows exploring up to k+1 but capped at 4 (known feasible)\n    max_palette = max(4, k)\n    idx = random.randrange(n)\n    current = vals[idx]\n    # Ensure a different color is chosen\n    choices = [c for c in range(1, max_palette + 1) if c != current]\n    if not choices:\n        choices = [1 if current != 1 else 2]\n    vals[idx] = random.choice(choices)\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Perturbacion":"import random\n\n\ndef _parse_csv(solution_str):\n    parts = [p.strip() for p in solution_str.split(',') if p.strip() != '']\n    vals = []\n    for p in parts[:9]:\n        try:\n            vals.append(int(p))\n        except Exception:\n            vals.append(1)\n    while len(vals) < 9:\n        vals.append(1)\n    return vals[:9]\n\n\ndef _normalize_colors(vals):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in vals:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _to_csv(vals):\n    return ','.join(str(x) for x in vals)\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Input: solution (CSV string)\n    Output: CSV string after stronger perturbation: reassign t random positions.\n    \"\"\"\n    vals = _parse_csv(solution)\n    n = 9\n    # Reassign t positions with colors from 1..4, where t in [2,4]\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for i in idxs:\n        vals[i] = random.randint(1, 4)\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000834861}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9.COMPRESSED_COLORS. Each solution is a string of 9 comma-separated positive integers representing colors for nodes 1..9. Colors are normalized to have no gaps: used color set equals {1..k}. Example: '1,2,3,1,3,3,4,4,2'.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring returns 0.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    EXPECTED_K = 4\n\n    penalty = 0.0\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return 1e9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n    if n != 9:\n        penalty += 1e8 + abs(n - 9) * 1e6\n    # Coerce to ints\n    coerced = []\n    invalid_entries = 0\n    for p in parts[:9]:  # consider only first 9 if longer; length penalty already added\n        try:\n            coerced.append(int(p))\n        except Exception:\n            coerced.append(0)\n            invalid_entries += 1\n    # If shorter, pad zeros (will be penalized by range checks)\n    while len(coerced) < 9:\n        coerced.append(0)\n    penalty += invalid_entries * 1e7\n\n    # Determine k and basic range checks\n    k = max(coerced) if coerced else 0\n    if k <= 0:\n        penalty += 1e8\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in coerced if c < 1 or c > k)\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in coerced if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            conflicts += 1\n    penalty += conflicts * 1e6\n\n    # Objective alignment: prefer k=EXPECTED_K when feasible\n    penalty += abs(k - EXPECTED_K) * 1e4\n\n    # Perfect feasibility at EXPECTED_K yields 0\n    if penalty == 0:\n        return 0.0\n    return float(penalty)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef _parse_csv(solution_str):\n    parts = [p.strip() for p in solution_str.split(',') if p.strip() != '']\n    vals = []\n    for p in parts[:9]:\n        try:\n            vals.append(int(p))\n        except Exception:\n            vals.append(1)\n    while len(vals) < 9:\n        vals.append(1)\n    return vals[:9]\n\n\ndef _normalize_colors(vals):\n    # Compress used colors to 1..k by order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in vals:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _to_csv(vals):\n    return ','.join(str(x) for x in vals)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: CSV string neighbor; single-node recolor with color-compaction.\n    \"\"\"\n    vals = _parse_csv(solution)\n    n = 9\n    # Current k\n    k = max(1, max(vals))\n    # Candidate color palette allows exploring up to k+1 but capped at 4 (known feasible)\n    max_palette = max(4, k)\n    idx = random.randrange(n)\n    current = vals[idx]\n    # Ensure a different color is chosen\n    choices = [c for c in range(1, max_palette + 1) if c != current]\n    if not choices:\n        choices = [1 if current != 1 else 2]\n    vals[idx] = random.choice(choices)\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Perturbacion":"import random\n\n\ndef _parse_csv(solution_str):\n    parts = [p.strip() for p in solution_str.split(',') if p.strip() != '']\n    vals = []\n    for p in parts[:9]:\n        try:\n            vals.append(int(p))\n        except Exception:\n            vals.append(1)\n    while len(vals) < 9:\n        vals.append(1)\n    return vals[:9]\n\n\ndef _normalize_colors(vals):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in vals:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _to_csv(vals):\n    return ','.join(str(x) for x in vals)\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Input: solution (CSV string)\n    Output: CSV string after stronger perturbation: reassign t random positions.\n    \"\"\"\n    vals = _parse_csv(solution)\n    n = 9\n    # Reassign t positions with colors from 1..4, where t in [2,4]\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for i in idxs:\n        vals[i] = random.randint(1, 4)\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00082847}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring returns 0.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    EXPECTED_K = 4\n\n    penalty = 0.0\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return 1e9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n    if n != 9:\n        penalty += 1e8 + abs(n - 9) * 1e6\n    # Coerce to ints\n    coerced = []\n    invalid_entries = 0\n    for p in parts[:9]:  # consider only first 9 if longer; length penalty already added\n        try:\n            coerced.append(int(p))\n        except Exception:\n            coerced.append(0)\n            invalid_entries += 1\n    # If shorter, pad zeros (will be penalized by range checks)\n    while len(coerced) < 9:\n        coerced.append(0)\n    penalty += invalid_entries * 1e7\n\n    # Determine k and basic range checks\n    k = max(coerced) if coerced else 0\n    if k <= 0:\n        penalty += 1e8\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in coerced if c < 1 or c > k)\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in coerced if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            conflicts += 1\n    penalty += conflicts * 1e6\n\n    # Objective alignment: prefer k=EXPECTED_K when feasible\n    penalty += abs(k - EXPECTED_K) * 1e4\n\n    # Perfect feasibility at EXPECTED_K yields 0\n    if penalty == 0:\n        return 0.0\n    return float(penalty)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: CSV string neighbor; uses mixed moves with color-compaction.\n    \"\"\"\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize_colors(vals):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    move_type = random.random()\n    if move_type < 0.6:\n        # Single-node recolor within palette up to min(k+1,4)\n        palette_max = min(k + 1, 4)\n        idx = random.randrange(n)\n        current = vals[idx]\n        choices = [c for c in range(1, palette_max + 1) if c != current]\n        if not choices:\n            choices = [1 if current != 1 else min(2, palette_max)]\n        vals[idx] = random.choice(choices)\n    else:\n        # Two-node color swap\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via Kempe-chain swap between two colors.\n    Returns a normalized CSV string.\n    \"\"\"\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize_colors(vals):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    # Graph edges (0-based for internal use)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Select a start node and a second color\n    start = random.randrange(n)\n    color_a = vals[start]\n    color_b = random.choice([c for c in range(1, max(4, k) + 1) if c != color_a and c <= 4])\n    # BFS over the subgraph induced by colors a and b\n    visited = [False] * n\n    queue = [start]\n    visited[start] = True\n    component = []\n    while queue:\n        u = queue.pop(0)\n        if vals[u] == color_a or vals[u] == color_b:\n            component.append(u)\n            for w in adj[u]:\n                if not visited[w] and (vals[w] == color_a or vals[w] == color_b):\n                    visited[w] = True\n                    queue.append(w)\n    # Swap colors a <-> b on the component\n    for u in component:\n        if vals[u] == color_a:\n            vals[u] = color_b\n        elif vals[u] == color_b:\n            vals[u] = color_a\n\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000879551}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring returns 0.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    EXPECTED_K = 4\n\n    penalty = 0.0\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return 1e9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n    if n != 9:\n        penalty += 1e8 + abs(n - 9) * 1e6\n    # Coerce to ints\n    coerced = []\n    invalid_entries = 0\n    for p in parts[:9]:  # consider only first 9 if longer; length penalty already added\n        try:\n            coerced.append(int(p))\n        except Exception:\n            coerced.append(0)\n            invalid_entries += 1\n    # If shorter, pad zeros (will be penalized by range checks)\n    while len(coerced) < 9:\n        coerced.append(0)\n    penalty += invalid_entries * 1e7\n\n    # Determine k and basic range checks\n    k = max(coerced) if coerced else 0\n    if k <= 0:\n        penalty += 1e8\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in coerced if c < 1 or c > k)\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in coerced if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            conflicts += 1\n    penalty += conflicts * 1e6\n\n    # Objective alignment: prefer k=EXPECTED_K when feasible\n    penalty += abs(k - EXPECTED_K) * 1e4\n\n    # Perfect feasibility at EXPECTED_K yields 0\n    if penalty == 0:\n        return 0.0\n    return float(penalty)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: CSV string neighbor; uses mixed moves with color-compaction.\n    \"\"\"\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize_colors(vals):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    move_type = random.random()\n    if move_type < 0.6:\n        # Single-node recolor within palette up to min(k+1,4)\n        palette_max = min(k + 1, 4)\n        idx = random.randrange(n)\n        current = vals[idx]\n        choices = [c for c in range(1, palette_max + 1) if c != current]\n        if not choices:\n            choices = [1 if current != 1 else min(2, palette_max)]\n        vals[idx] = random.choice(choices)\n    else:\n        # Two-node color swap\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via Kempe-chain swap between two colors.\n    Returns a normalized CSV string.\n    \"\"\"\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize_colors(vals):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    # Graph edges (0-based for internal use)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Select a start node and a second color\n    start = random.randrange(n)\n    color_a = vals[start]\n    color_b = random.choice([c for c in range(1, max(4, k) + 1) if c != color_a and c <= 4])\n    # BFS over the subgraph induced by colors a and b\n    visited = [False] * n\n    queue = [start]\n    visited[start] = True\n    component = []\n    while queue:\n        u = queue.pop(0)\n        if vals[u] == color_a or vals[u] == color_b:\n            component.append(u)\n            for w in adj[u]:\n                if not visited[w] and (vals[w] == color_a or vals[w] == color_b):\n                    visited[w] = True\n                    queue.append(w)\n    # Swap colors a <-> b on the component\n    for u in component:\n        if vals[u] == color_a:\n            vals[u] = color_b\n        elif vals[u] == color_b:\n            vals[u] = color_a\n\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001206866}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring returns 0.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    EXPECTED_K = 4\n\n    penalty = 0.0\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return 1e9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n    if n != 9:\n        penalty += 1e8 + abs(n - 9) * 1e6\n    # Coerce to ints\n    coerced = []\n    invalid_entries = 0\n    for p in parts[:9]:  # consider only first 9 if longer; length penalty already added\n        try:\n            coerced.append(int(p))\n        except Exception:\n            coerced.append(0)\n            invalid_entries += 1\n    # If shorter, pad zeros (will be penalized by range checks)\n    while len(coerced) < 9:\n        coerced.append(0)\n    penalty += invalid_entries * 1e7\n\n    # Determine k and basic range checks\n    k = max(coerced) if coerced else 0\n    if k <= 0:\n        penalty += 1e8\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in coerced if c < 1 or c > k)\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in coerced if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv:\n            conflicts += 1\n    penalty += conflicts * 1e6\n\n    # Objective alignment: prefer k=EXPECTED_K when feasible\n    penalty += abs(k - EXPECTED_K) * 1e4\n\n    # Perfect feasibility at EXPECTED_K yields 0\n    if penalty == 0:\n        return 0.0\n    return float(penalty)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: CSV string neighbor; uses mixed moves with color-compaction.\n    \"\"\"\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize_colors(vals):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    move_type = random.random()\n    if move_type < 0.6:\n        # Single-node recolor within palette up to min(k+1,4)\n        palette_max = min(k + 1, 4)\n        idx = random.randrange(n)\n        current = vals[idx]\n        choices = [c for c in range(1, palette_max + 1) if c != current]\n        if not choices:\n            choices = [1 if current != 1 else min(2, palette_max)]\n        vals[idx] = random.choice(choices)\n    else:\n        # Two-node color swap\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via Kempe-chain swap between two colors.\n    Returns a normalized CSV string.\n    \"\"\"\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize_colors(vals):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    # Graph edges (0-based for internal use)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Select a start node and a second color\n    start = random.randrange(n)\n    color_a = vals[start]\n    color_b = random.choice([c for c in range(1, max(4, k) + 1) if c != color_a and c <= 4])\n    # BFS over the subgraph induced by colors a and b\n    visited = [False] * n\n    queue = [start]\n    visited[start] = True\n    component = []\n    while queue:\n        u = queue.pop(0)\n        if vals[u] == color_a or vals[u] == color_b:\n            component.append(u)\n            for w in adj[u]:\n                if not visited[w] and (vals[w] == color_a or vals[w] == color_b):\n                    visited[w] = True\n                    queue.append(w)\n    # Swap colors a <-> b on the component\n    for u in component:\n        if vals[u] == color_a:\n            vals[u] = color_b\n        elif vals[u] == color_b:\n            vals[u] = color_a\n\n    vals = _normalize_colors(vals)\n    return _to_csv(vals)\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001049612}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring with contiguous labels returns small k tie-break; 0 if k==4.\n    Lexicographic objective via large weight on conflicts\/penalties.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n\n    BIG = 1e9  # invalid type\/shape\n    W = 1e6    # conflicts dominate k\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return float(BIG)\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n\n    penalty = 0.0\n    if n != 9:\n        penalty += 5e8 + abs(n - 9) * 1e7\n\n    # Coerce to ints for first 9, pad if short\n    vals = []\n    invalid_entries = 0\n    for p in parts[:9]:\n        try:\n            v = int(p)\n            vals.append(v)\n        except Exception:\n            vals.append(0)\n            invalid_entries += 1\n    while len(vals) < 9:\n        vals.append(0)\n        invalid_entries += 1\n    penalty += invalid_entries * 1e7\n\n    # Determine k and range checks\n    k = max(vals) if vals else 0\n    if k <= 0:\n        penalty += 1e8\n        k = 0\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in vals if c < 1 or (k > 0 and c > k))\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in vals if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = vals[u - 1]\n        cv = vals[v - 1]\n        if cu == cv and cu != 0:\n            conflicts += 1\n    penalty += conflicts * W\n\n    # Final score: conflicts\/penalties dominate; then k as tie-breaker\n    score = penalty + (k if penalty < W else 0.0)\n\n    # Perfect feasibility with k==4 returns 0.0 for convenience\n    if conflicts == 0 and penalty == k and k == 4:\n        return 0.0\n\n    return float(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: (neighbor_csv, meta_dict) where meta_dict={'move': 'recolor'|'swap'|'greedy_recolor'}\n    Uses conflict-driven recolor and swap; maintains contiguous color labels.\n    \"\"\"\n    # Graph edges (0-based)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize(vals):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Identify conflicts\n    in_conflict = [False]*n\n    for u, v in edges:\n        if vals[u] == vals[v]:\n            in_conflict[u] = True\n            in_conflict[v] = True\n\n    r = random.random()\n    if any(in_conflict) and r < 0.6:\n        # Greedy recolor a conflicted node to least conflicting color\n        idxs = [i for i, f in enumerate(in_conflict) if f]\n        u = random.choice(idxs)\n        palette = list(range(1, k + 2))  # allow introducing a new color if needed\n        best_c = vals[u]\n        best_conf = 10**9\n        for c in palette:\n            if c == vals[u]:\n                # still evaluate; may tie\n                pass\n            conf = 0\n            for w in adj[u]:\n                if vals[w] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        vals[u] = best_c\n        move = 'greedy_recolor'\n    elif r < 0.85:\n        # Random recolor a random node within palette up to k+1\n        u = random.randrange(n)\n        palette = list(range(1, k + 2))\n        choices = [c for c in palette if c != vals[u]]\n        vals[u] = random.choice(choices) if choices else vals[u]\n        move = 'recolor'\n    else:\n        # Swap colors of two nodes\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n        move = 'swap'\n\n    # Normalize labels to be contiguous\n    vals = _normalize(vals)\n\n    return _to_csv(vals), {'move': move}\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via random two-color Kempe-chain swap in the color-induced subgraph.\n    Returns normalized CSV string.\n    \"\"\"\n    # Graph edges (0-based)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize(vals):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    # Build adjacency\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Pick a random start and a second color\n    start = random.randrange(n)\n    color_a = vals[start]\n    palette = list(range(1, max(k, 4) + 1))\n    if len(palette) == 1:\n        palette.append(color_a % 4 + 1)\n    color_b_choices = [c for c in palette if c != color_a]\n    color_b = random.choice(color_b_choices) if color_b_choices else (color_a % 4 + 1)\n\n    # BFS over subgraph induced by colors {a,b}\n    use = [False]*n\n    for i in range(n):\n        use[i] = (vals[i] == color_a or vals[i] == color_b)\n\n    visited = [False]*n\n    queue = [start]\n    visited[start] = True\n    component = []\n    while queue:\n        u = queue.pop(0)\n        if use[u]:\n            component.append(u)\n            for w in adj[u]:\n                if not visited[w] and use[w]:\n                    visited[w] = True\n                    queue.append(w)\n\n    # Swap colors on the component\n    for u in component:\n        if vals[u] == color_a:\n            vals[u] = color_b\n        elif vals[u] == color_b:\n            vals[u] = color_a\n\n    vals = _normalize(vals)\n    return _to_csv(vals)\n","Resultados":["1,2,3,4,5,5,6,7,8",7.0,"1,2,3,1,3,3,4,4,2",4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001969739}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring with contiguous labels returns small k tie-break; 0 if k==4.\n    Lexicographic objective via large weight on conflicts\/penalties.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n\n    BIG = 1e9  # invalid type\/shape\n    W = 1e6    # conflicts dominate k\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return float(BIG)\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n\n    penalty = 0.0\n    if n != 9:\n        penalty += 5e8 + abs(n - 9) * 1e7\n\n    # Coerce to ints for first 9, pad if short\n    vals = []\n    invalid_entries = 0\n    for p in parts[:9]:\n        try:\n            v = int(p)\n            vals.append(v)\n        except Exception:\n            vals.append(0)\n            invalid_entries += 1\n    while len(vals) < 9:\n        vals.append(0)\n        invalid_entries += 1\n    penalty += invalid_entries * 1e7\n\n    # Determine k and range checks\n    k = max(vals) if vals else 0\n    if k <= 0:\n        penalty += 1e8\n        k = 0\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in vals if c < 1 or (k > 0 and c > k))\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in vals if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = vals[u - 1]\n        cv = vals[v - 1]\n        if cu == cv and cu != 0:\n            conflicts += 1\n    penalty += conflicts * W\n\n    # Final score: conflicts\/penalties dominate; then k as tie-breaker\n    score = penalty + (k if penalty < W else 0.0)\n\n    # Perfect feasibility with k==4 returns 0.0 for convenience\n    if conflicts == 0 and penalty == k and k == 4:\n        return 0.0\n\n    return float(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: (neighbor_csv, meta_dict) where meta_dict={'move': 'recolor'|'swap'|'greedy_recolor'}\n    Uses conflict-driven recolor and swap; maintains contiguous color labels.\n    \"\"\"\n    # Graph edges (0-based)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize(vals):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Identify conflicts\n    in_conflict = [False]*n\n    for u, v in edges:\n        if vals[u] == vals[v]:\n            in_conflict[u] = True\n            in_conflict[v] = True\n\n    r = random.random()\n    if any(in_conflict) and r < 0.6:\n        # Greedy recolor a conflicted node to least conflicting color\n        idxs = [i for i, f in enumerate(in_conflict) if f]\n        u = random.choice(idxs)\n        palette = list(range(1, k + 2))  # allow introducing a new color if needed\n        best_c = vals[u]\n        best_conf = 10**9\n        for c in palette:\n            if c == vals[u]:\n                # still evaluate; may tie\n                pass\n            conf = 0\n            for w in adj[u]:\n                if vals[w] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        vals[u] = best_c\n        move = 'greedy_recolor'\n    elif r < 0.85:\n        # Random recolor a random node within palette up to k+1\n        u = random.randrange(n)\n        palette = list(range(1, k + 2))\n        choices = [c for c in palette if c != vals[u]]\n        vals[u] = random.choice(choices) if choices else vals[u]\n        move = 'recolor'\n    else:\n        # Swap colors of two nodes\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n        move = 'swap'\n\n    # Normalize labels to be contiguous\n    vals = _normalize(vals)\n\n    return _to_csv(vals), {'move': move}\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via random two-color Kempe-chain swap in the color-induced subgraph.\n    Returns normalized CSV string.\n    \"\"\"\n    # Graph edges (0-based)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize(vals):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    # Build adjacency\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Pick a random start and a second color\n    start = random.randrange(n)\n    color_a = vals[start]\n    palette = list(range(1, max(k, 4) + 1))\n    if len(palette) == 1:\n        palette.append(color_a % 4 + 1)\n    color_b_choices = [c for c in palette if c != color_a]\n    color_b = random.choice(color_b_choices) if color_b_choices else (color_a % 4 + 1)\n\n    # BFS over subgraph induced by colors {a,b}\n    use = [False]*n\n    for i in range(n):\n        use[i] = (vals[i] == color_a or vals[i] == color_b)\n\n    visited = [False]*n\n    queue = [start]\n    visited[start] = True\n    component = []\n    while queue:\n        u = queue.pop(0)\n        if use[u]:\n            component.append(u)\n            for w in adj[u]:\n                if not visited[w] and use[w]:\n                    visited[w] = True\n                    queue.append(w)\n\n    # Swap colors on the component\n    for u in component:\n        if vals[u] == color_a:\n            vals[u] = color_b\n        elif vals[u] == color_b:\n            vals[u] = color_a\n\n    vals = _normalize(vals)\n    return _to_csv(vals)\n","Resultados":["1,2,3,1,4,3,1,4,2",2000000.0,"1,2,3,1,3,3,4,4,2",4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002382925}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring with contiguous labels returns small k tie-break; 0 if k==4.\n    Lexicographic objective via large weight on conflicts\/penalties.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n\n    BIG = 1e9  # invalid type\/shape\n    W = 1e6    # conflicts dominate k\n\n    # Type and parse checks\n    if not isinstance(solution, str):\n        return float(BIG)\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n\n    penalty = 0.0\n    if n != 9:\n        penalty += 5e8 + abs(n - 9) * 1e7\n\n    # Coerce to ints for first 9, pad if short\n    vals = []\n    invalid_entries = 0\n    for p in parts[:9]:\n        try:\n            v = int(p)\n            vals.append(v)\n        except Exception:\n            vals.append(0)\n            invalid_entries += 1\n    while len(vals) < 9:\n        vals.append(0)\n        invalid_entries += 1\n    penalty += invalid_entries * 1e7\n\n    # Determine k and range checks\n    k = max(vals) if vals else 0\n    if k <= 0:\n        penalty += 1e8\n        k = 0\n\n    # Range: all colors in [1..k]\n    out_of_range = sum(1 for c in vals if c < 1 or (k > 0 and c > k))\n    penalty += out_of_range * 1e6\n\n    # No gaps in colors: set must equal {1,..,k}\n    used = set(c for c in vals if 1 <= c <= k)\n    if k > 0 and used != set(range(1, k + 1)):\n        penalty += 5e5\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = vals[u - 1]\n        cv = vals[v - 1]\n        if cu == cv and cu != 0:\n            conflicts += 1\n    penalty += conflicts * W\n\n    # Final score: conflicts\/penalties dominate; then k as tie-breaker\n    score = penalty + (k if penalty < W else 0.0)\n\n    # Perfect feasibility with k==4 returns 0.0 for convenience\n    if conflicts == 0 and penalty == k and k == 4:\n        return 0.0\n\n    return float(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: (neighbor_csv, meta_dict) where meta_dict={'move': 'recolor'|'swap'|'greedy_recolor'}\n    Uses conflict-driven recolor and swap; maintains contiguous color labels.\n    \"\"\"\n    # Graph edges (0-based)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize(vals):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Identify conflicts\n    in_conflict = [False]*n\n    for u, v in edges:\n        if vals[u] == vals[v]:\n            in_conflict[u] = True\n            in_conflict[v] = True\n\n    r = random.random()\n    if any(in_conflict) and r < 0.6:\n        # Greedy recolor a conflicted node to least conflicting color\n        idxs = [i for i, f in enumerate(in_conflict) if f]\n        u = random.choice(idxs)\n        palette = list(range(1, k + 2))  # allow introducing a new color if needed\n        best_c = vals[u]\n        best_conf = 10**9\n        for c in palette:\n            if c == vals[u]:\n                # still evaluate; may tie\n                pass\n            conf = 0\n            for w in adj[u]:\n                if vals[w] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        vals[u] = best_c\n        move = 'greedy_recolor'\n    elif r < 0.85:\n        # Random recolor a random node within palette up to k+1\n        u = random.randrange(n)\n        palette = list(range(1, k + 2))\n        choices = [c for c in palette if c != vals[u]]\n        vals[u] = random.choice(choices) if choices else vals[u]\n        move = 'recolor'\n    else:\n        # Swap colors of two nodes\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n        move = 'swap'\n\n    # Normalize labels to be contiguous\n    vals = _normalize(vals)\n\n    return _to_csv(vals), {'move': move}\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via random two-color Kempe-chain swap in the color-induced subgraph.\n    Returns normalized CSV string.\n    \"\"\"\n    # Graph edges (0-based)\n    edges = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def _parse_csv(solution_str):\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        return vals[:9]\n\n    def _normalize(vals):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in vals:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def _to_csv(vals):\n        return ','.join(str(x) for x in vals)\n\n    # Build adjacency\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = _parse_csv(solution)\n    n = 9\n    k = max(1, max(vals))\n\n    # Pick a random start and a second color\n    start = random.randrange(n)\n    color_a = vals[start]\n    palette = list(range(1, max(k, 4) + 1))\n    if len(palette) == 1:\n        palette.append(color_a % 4 + 1)\n    color_b_choices = [c for c in palette if c != color_a]\n    color_b = random.choice(color_b_choices) if color_b_choices else (color_a % 4 + 1)\n\n    # BFS over subgraph induced by colors {a,b}\n    use = [False]*n\n    for i in range(n):\n        use[i] = (vals[i] == color_a or vals[i] == color_b)\n\n    visited = [False]*n\n    queue = [start]\n    visited[start] = True\n    component = []\n    while queue:\n        u = queue.pop(0)\n        if use[u]:\n            component.append(u)\n            for w in adj[u]:\n                if not visited[w] and use[w]:\n                    visited[w] = True\n                    queue.append(w)\n\n    # Swap colors on the component\n    for u in component:\n        if vals[u] == color_a:\n            vals[u] = color_b\n        elif vals[u] == color_b:\n            vals[u] = color_a\n\n    vals = _normalize(vals)\n    return _to_csv(vals)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001277129}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9. Encoding: solution is a CSV string of 9 positive integers representing colors for nodes 1..9. Labels are maintained contiguous {1..k} via stable compaction by sorted unique colors.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring with contiguous labels returns 0.0.\n    Conflicts dominate via very large weight W.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n\n    BIG = 1e12  # invalid type\/shape\n    W = 1e9     # conflicts dominate all other penalties\n\n    # Type check\n    if not isinstance(solution, str):\n        return float(BIG)\n\n    # Parse\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n\n    penalty = 0.0\n    if n != 9:\n        # penalize wrong length heavily but continue parsing up to 9\n        penalty += 5e10 + abs(n - 9) * 1e9\n\n    # Coerce to ints for first 9, pad if short\n    vals: List[int] = []\n    invalid_entries = 0\n    for p in parts[:9]:\n        try:\n            v = int(p)\n            vals.append(v)\n        except Exception:\n            vals.append(1)\n            invalid_entries += 1\n    while len(vals) < 9:\n        vals.append(1)\n        invalid_entries += 1\n    penalty += invalid_entries * 1e7\n\n    # Enforce positivity\n    neg_or_zero = sum(1 for c in vals if c <= 0)\n    if neg_or_zero:\n        penalty += neg_or_zero * 1e8\n        # shift non-positive to 1 for evaluation continuity\n        vals = [c if c > 0 else 1 for c in vals]\n\n    # Stable compaction of labels to contiguous 1..k by sorted unique labels\n    uniq = sorted(set(vals))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    vals = [mapping[c] for c in vals]\n\n    # Determine k\n    k = max(vals) if vals else 0\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = vals[u - 1]\n        cv = vals[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Final score: conflicts dominate; then minor penalties; then k as tie-breaker\n    score = conflicts * W + penalty + (k if conflicts == 0 else 0.0)\n\n    # Perfect feasibility with k==4 returns 0.0\n    if conflicts == 0 and k == 4 and n == 9 and invalid_entries == 0 and neg_or_zero == 0:\n        return 0.0\n\n    return float(score)\n","Vecindad":"from __future__ import annotations\nimport random\nfrom typing import List, Tuple, Dict\n\nNB_Type = str\nMovement_Type = Dict[str, str]\n\ndef generate_neighbour(solution) -> (NB_Type, Movement_Type):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: (neighbor_csv, meta_dict) where meta_dict={'move': ..., 'k': int}\n    Operators: conflict-driven recolor (within 1..k), Kempe-chain swap on two colors,\n    occasional random swap. Labels are normalized via stable compaction (sorted colors).\n    \"\"\"\n    # Graph edges (0-based)\n    edges: List[Tuple[int, int]] = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def parse_csv(solution_str: str) -> List[int]:\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals: List[int] = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        # ensure positivity\n        vals = [c if c > 0 else 1 for c in vals[:9]]\n        return vals[:9]\n\n    def stable_compact(vals: List[int]) -> List[int]:\n        uniq = sorted(set(vals))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in vals]\n\n    def to_csv(vals: List[int]) -> str:\n        return ','.join(str(x) for x in vals)\n\n    vals = parse_csv(solution)\n    n = 9\n\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Normalize first to avoid artificial gaps\n    vals = stable_compact(vals)\n    k = max(1, max(vals))\n\n    # Identify conflicts and weights\n    in_conflict = [0]*n\n    for u, v in edges:\n        if vals[u] == vals[v]:\n            in_conflict[u] += 1\n            in_conflict[v] += 1\n\n    r = random.random()\n    move = 'recolor'\n\n    if any(c > 0 for c in in_conflict) and r < 0.6:\n        # Conflict-driven recolor: pick node with probability proportional to conflict degree\n        idxs = [i for i, c in enumerate(in_conflict) if c > 0]\n        weights = [in_conflict[i] for i in idxs]\n        total = sum(weights)\n        t = random.uniform(0, total)\n        acc = 0.0\n        u = idxs[0]\n        for i, w in zip(idxs, weights):\n            acc += w\n            if t <= acc:\n                u = i\n                break\n        # Try best color in 1..k (avoid k+1 to not inflate palette here)\n        best_c = vals[u]\n        best_conf = 10**9\n        for c in range(1, k+1):\n            conf = 0\n            for w in adj[u]:\n                if vals[w] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        vals[u] = best_c\n        move = 'greedy_recolor'\n    elif r < 0.85:\n        # Kempe-chain swap between two colors (random pair among used or up to k)\n        if k == 1:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(list(range(1, k+1)), 2)\n        # pick a start node of color a or b\n        candidates = [i for i, c in enumerate(vals) if c == a or c == b]\n        if not candidates:\n            candidates = [random.randrange(n)]\n        start = random.choice(candidates)\n        color_a = vals[start]\n        color_b = a if color_a != a else b\n        # BFS over subgraph induced by {color_a, color_b}\n        use = [False]*n\n        for i in range(n):\n            use[i] = (vals[i] == color_a or vals[i] == color_b)\n        visited = [False]*n\n        queue = [start]\n        visited[start] = True\n        component = []\n        while queue:\n            u = queue.pop(0)\n            if use[u]:\n                component.append(u)\n                for w in adj[u]:\n                    if not visited[w] and use[w]:\n                        visited[w] = True\n                        queue.append(w)\n        for u in component:\n            vals[u] = color_b if vals[u] == color_a else (color_a if vals[u] == color_b else vals[u])\n        move = 'kempe_swap'\n    else:\n        # Random swap of two nodes' colors\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n        move = 'swap'\n\n    # Stable normalization\n    vals = stable_compact(vals)\n    nb_csv = to_csv(vals)\n    return nb_csv, {'move': move, 'k': max(vals)}\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via multiple random Kempe-chain swaps on random color pairs.\n    Returns normalized CSV string with stable compaction.\n    \"\"\"\n    # Graph edges (0-based)\n    edges: List[Tuple[int, int]] = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def parse_csv(solution_str: str) -> List[int]:\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals: List[int] = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        vals = [c if c > 0 else 1 for c in vals[:9]]\n        return vals[:9]\n\n    def stable_compact(vals: List[int]) -> List[int]:\n        uniq = sorted(set(vals))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in vals]\n\n    vals = parse_csv(solution)\n    n = 9\n\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = stable_compact(vals)\n    k = max(1, max(vals))\n\n    # Apply a few Kempe-chain swaps (intensity between 2 and 4)\n    intensity = random.randint(2, 4)\n    for _ in range(intensity):\n        # choose two distinct colors; if only one, allow a temporary second\n        if k == 1:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(list(range(1, k+1)), 2)\n        # pick a start node with color a or b\n        candidates = [i for i, c in enumerate(vals) if c == a or c == b]\n        if not candidates:\n            candidates = [random.randrange(n)]\n        start = random.choice(candidates)\n        color_a = vals[start]\n        color_b = a if color_a != a else b\n        # BFS on induced subgraph {a,b}\n        use = [False]*n\n        for i in range(n):\n            use[i] = (vals[i] == color_a or vals[i] == color_b)\n        visited = [False]*n\n        queue = [start]\n        visited[start] = True\n        component = []\n        while queue:\n            u = queue.pop(0)\n            if use[u]:\n                component.append(u)\n                for w in adj[u]:\n                    if not visited[w] and use[w]:\n                        visited[w] = True\n                        queue.append(w)\n        for u in component:\n            vals[u] = color_b if vals[u] == color_a else (color_a if vals[u] == color_b else vals[u])\n        # refresh k after swap\n        vals = stable_compact(vals)\n        k = max(1, max(vals))\n\n    vals = stable_compact(vals)\n    return ','.join(str(x) for x in vals)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001398069}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9. Encoding: solution is a CSV string of 9 positive integers representing colors for nodes 1..9. Labels are maintained contiguous {1..k} via stable compaction by sorted unique colors.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring with contiguous labels returns 0.0.\n    Conflicts dominate via very large weight W.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n\n    BIG = 1e12  # invalid type\/shape\n    W = 1e9     # conflicts dominate all other penalties\n\n    # Type check\n    if not isinstance(solution, str):\n        return float(BIG)\n\n    # Parse\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n\n    penalty = 0.0\n    if n != 9:\n        # penalize wrong length heavily but continue parsing up to 9\n        penalty += 5e10 + abs(n - 9) * 1e9\n\n    # Coerce to ints for first 9, pad if short\n    vals: List[int] = []\n    invalid_entries = 0\n    for p in parts[:9]:\n        try:\n            v = int(p)\n            vals.append(v)\n        except Exception:\n            vals.append(1)\n            invalid_entries += 1\n    while len(vals) < 9:\n        vals.append(1)\n        invalid_entries += 1\n    penalty += invalid_entries * 1e7\n\n    # Enforce positivity\n    neg_or_zero = sum(1 for c in vals if c <= 0)\n    if neg_or_zero:\n        penalty += neg_or_zero * 1e8\n        # shift non-positive to 1 for evaluation continuity\n        vals = [c if c > 0 else 1 for c in vals]\n\n    # Stable compaction of labels to contiguous 1..k by sorted unique labels\n    uniq = sorted(set(vals))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    vals = [mapping[c] for c in vals]\n\n    # Determine k\n    k = max(vals) if vals else 0\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = vals[u - 1]\n        cv = vals[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Final score: conflicts dominate; then minor penalties; then k as tie-breaker\n    score = conflicts * W + penalty + (k if conflicts == 0 else 0.0)\n\n    # Perfect feasibility with k==4 returns 0.0\n    if conflicts == 0 and k == 4 and n == 9 and invalid_entries == 0 and neg_or_zero == 0:\n        return 0.0\n\n    return float(score)\n","Vecindad":"from __future__ import annotations\nimport random\nfrom typing import List, Tuple, Dict\n\nNB_Type = str\nMovement_Type = Dict[str, str]\n\ndef generate_neighbour(solution) -> (NB_Type, Movement_Type):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: (neighbor_csv, meta_dict) where meta_dict={'move': ..., 'k': int}\n    Operators: conflict-driven recolor (within 1..k), Kempe-chain swap on two colors,\n    occasional random swap. Labels are normalized via stable compaction (sorted colors).\n    \"\"\"\n    # Graph edges (0-based)\n    edges: List[Tuple[int, int]] = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def parse_csv(solution_str: str) -> List[int]:\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals: List[int] = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        # ensure positivity\n        vals = [c if c > 0 else 1 for c in vals[:9]]\n        return vals[:9]\n\n    def stable_compact(vals: List[int]) -> List[int]:\n        uniq = sorted(set(vals))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in vals]\n\n    def to_csv(vals: List[int]) -> str:\n        return ','.join(str(x) for x in vals)\n\n    vals = parse_csv(solution)\n    n = 9\n\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Normalize first to avoid artificial gaps\n    vals = stable_compact(vals)\n    k = max(1, max(vals))\n\n    # Identify conflicts and weights\n    in_conflict = [0]*n\n    for u, v in edges:\n        if vals[u] == vals[v]:\n            in_conflict[u] += 1\n            in_conflict[v] += 1\n\n    r = random.random()\n    move = 'recolor'\n\n    if any(c > 0 for c in in_conflict) and r < 0.6:\n        # Conflict-driven recolor: pick node with probability proportional to conflict degree\n        idxs = [i for i, c in enumerate(in_conflict) if c > 0]\n        weights = [in_conflict[i] for i in idxs]\n        total = sum(weights)\n        t = random.uniform(0, total)\n        acc = 0.0\n        u = idxs[0]\n        for i, w in zip(idxs, weights):\n            acc += w\n            if t <= acc:\n                u = i\n                break\n        # Try best color in 1..k (avoid k+1 to not inflate palette here)\n        best_c = vals[u]\n        best_conf = 10**9\n        for c in range(1, k+1):\n            conf = 0\n            for w in adj[u]:\n                if vals[w] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        vals[u] = best_c\n        move = 'greedy_recolor'\n    elif r < 0.85:\n        # Kempe-chain swap between two colors (random pair among used or up to k)\n        if k == 1:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(list(range(1, k+1)), 2)\n        # pick a start node of color a or b\n        candidates = [i for i, c in enumerate(vals) if c == a or c == b]\n        if not candidates:\n            candidates = [random.randrange(n)]\n        start = random.choice(candidates)\n        color_a = vals[start]\n        color_b = a if color_a != a else b\n        # BFS over subgraph induced by {color_a, color_b}\n        use = [False]*n\n        for i in range(n):\n            use[i] = (vals[i] == color_a or vals[i] == color_b)\n        visited = [False]*n\n        queue = [start]\n        visited[start] = True\n        component = []\n        while queue:\n            u = queue.pop(0)\n            if use[u]:\n                component.append(u)\n                for w in adj[u]:\n                    if not visited[w] and use[w]:\n                        visited[w] = True\n                        queue.append(w)\n        for u in component:\n            vals[u] = color_b if vals[u] == color_a else (color_a if vals[u] == color_b else vals[u])\n        move = 'kempe_swap'\n    else:\n        # Random swap of two nodes' colors\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n        move = 'swap'\n\n    # Stable normalization\n    vals = stable_compact(vals)\n    nb_csv = to_csv(vals)\n    return nb_csv, {'move': move, 'k': max(vals)}\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via multiple random Kempe-chain swaps on random color pairs.\n    Returns normalized CSV string with stable compaction.\n    \"\"\"\n    # Graph edges (0-based)\n    edges: List[Tuple[int, int]] = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def parse_csv(solution_str: str) -> List[int]:\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals: List[int] = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        vals = [c if c > 0 else 1 for c in vals[:9]]\n        return vals[:9]\n\n    def stable_compact(vals: List[int]) -> List[int]:\n        uniq = sorted(set(vals))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in vals]\n\n    vals = parse_csv(solution)\n    n = 9\n\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = stable_compact(vals)\n    k = max(1, max(vals))\n\n    # Apply a few Kempe-chain swaps (intensity between 2 and 4)\n    intensity = random.randint(2, 4)\n    for _ in range(intensity):\n        # choose two distinct colors; if only one, allow a temporary second\n        if k == 1:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(list(range(1, k+1)), 2)\n        # pick a start node with color a or b\n        candidates = [i for i, c in enumerate(vals) if c == a or c == b]\n        if not candidates:\n            candidates = [random.randrange(n)]\n        start = random.choice(candidates)\n        color_a = vals[start]\n        color_b = a if color_a != a else b\n        # BFS on induced subgraph {a,b}\n        use = [False]*n\n        for i in range(n):\n            use[i] = (vals[i] == color_a or vals[i] == color_b)\n        visited = [False]*n\n        queue = [start]\n        visited[start] = True\n        component = []\n        while queue:\n            u = queue.pop(0)\n            if use[u]:\n                component.append(u)\n                for w in adj[u]:\n                    if not visited[w] and use[w]:\n                        visited[w] = True\n                        queue.append(w)\n        for u in component:\n            vals[u] = color_b if vals[u] == color_a else (color_a if vals[u] == color_b else vals[u])\n        # refresh k after swap\n        vals = stable_compact(vals)\n        k = max(1, max(vals))\n\n    vals = stable_compact(vals)\n    return ','.join(str(x) for x in vals)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001653423}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"CSV_LIST_INT_LEN9. Encoding: solution is a CSV string of 9 positive integers representing colors for nodes 1..9. Labels are maintained contiguous {1..k} via stable compaction by sorted unique colors.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Input: solution (str) -> CSV of 9 integers representing colors for nodes 1..9.\n    Output: float fitness (lower is better). Feasible 4-coloring with contiguous labels returns 0.0.\n    Conflicts dominate via very large weight W.\n    \"\"\"\n    # Graph edges (1-based indices)\n    edges: List[Tuple[int, int]] = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n\n    BIG = 1e12  # invalid type\/shape\n    W = 1e9     # conflicts dominate all other penalties\n\n    # Type check\n    if not isinstance(solution, str):\n        return float(BIG)\n\n    # Parse\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    n = len(parts)\n\n    penalty = 0.0\n    if n != 9:\n        # penalize wrong length heavily but continue parsing up to 9\n        penalty += 5e10 + abs(n - 9) * 1e9\n\n    # Coerce to ints for first 9, pad if short\n    vals: List[int] = []\n    invalid_entries = 0\n    for p in parts[:9]:\n        try:\n            v = int(p)\n            vals.append(v)\n        except Exception:\n            vals.append(1)\n            invalid_entries += 1\n    while len(vals) < 9:\n        vals.append(1)\n        invalid_entries += 1\n    penalty += invalid_entries * 1e7\n\n    # Enforce positivity\n    neg_or_zero = sum(1 for c in vals if c <= 0)\n    if neg_or_zero:\n        penalty += neg_or_zero * 1e8\n        # shift non-positive to 1 for evaluation continuity\n        vals = [c if c > 0 else 1 for c in vals]\n\n    # Stable compaction of labels to contiguous 1..k by sorted unique labels\n    uniq = sorted(set(vals))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    vals = [mapping[c] for c in vals]\n\n    # Determine k\n    k = max(vals) if vals else 0\n\n    # Adjacency conflicts\n    conflicts = 0\n    for u, v in edges:\n        cu = vals[u - 1]\n        cv = vals[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Final score: conflicts dominate; then minor penalties; then k as tie-breaker\n    score = conflicts * W + penalty + (k if conflicts == 0 else 0.0)\n\n    # Perfect feasibility with k==4 returns 0.0\n    if conflicts == 0 and k == 4 and n == 9 and invalid_entries == 0 and neg_or_zero == 0:\n        return 0.0\n\n    return float(score)\n","Vecindad":"from __future__ import annotations\nimport random\nfrom typing import List, Tuple, Dict\n\nNB_Type = str\nMovement_Type = Dict[str, str]\n\ndef generate_neighbour(solution) -> (NB_Type, Movement_Type):\n    \"\"\"\n    Input: solution (CSV string of 9 ints)\n    Output: (neighbor_csv, meta_dict) where meta_dict={'move': ..., 'k': int}\n    Operators: conflict-driven recolor (within 1..k), Kempe-chain swap on two colors,\n    occasional random swap. Labels are normalized via stable compaction (sorted colors).\n    \"\"\"\n    # Graph edges (0-based)\n    edges: List[Tuple[int, int]] = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def parse_csv(solution_str: str) -> List[int]:\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals: List[int] = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        # ensure positivity\n        vals = [c if c > 0 else 1 for c in vals[:9]]\n        return vals[:9]\n\n    def stable_compact(vals: List[int]) -> List[int]:\n        uniq = sorted(set(vals))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in vals]\n\n    def to_csv(vals: List[int]) -> str:\n        return ','.join(str(x) for x in vals)\n\n    vals = parse_csv(solution)\n    n = 9\n\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Normalize first to avoid artificial gaps\n    vals = stable_compact(vals)\n    k = max(1, max(vals))\n\n    # Identify conflicts and weights\n    in_conflict = [0]*n\n    for u, v in edges:\n        if vals[u] == vals[v]:\n            in_conflict[u] += 1\n            in_conflict[v] += 1\n\n    r = random.random()\n    move = 'recolor'\n\n    if any(c > 0 for c in in_conflict) and r < 0.6:\n        # Conflict-driven recolor: pick node with probability proportional to conflict degree\n        idxs = [i for i, c in enumerate(in_conflict) if c > 0]\n        weights = [in_conflict[i] for i in idxs]\n        total = sum(weights)\n        t = random.uniform(0, total)\n        acc = 0.0\n        u = idxs[0]\n        for i, w in zip(idxs, weights):\n            acc += w\n            if t <= acc:\n                u = i\n                break\n        # Try best color in 1..k (avoid k+1 to not inflate palette here)\n        best_c = vals[u]\n        best_conf = 10**9\n        for c in range(1, k+1):\n            conf = 0\n            for w in adj[u]:\n                if vals[w] == c:\n                    conf += 1\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        vals[u] = best_c\n        move = 'greedy_recolor'\n    elif r < 0.85:\n        # Kempe-chain swap between two colors (random pair among used or up to k)\n        if k == 1:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(list(range(1, k+1)), 2)\n        # pick a start node of color a or b\n        candidates = [i for i, c in enumerate(vals) if c == a or c == b]\n        if not candidates:\n            candidates = [random.randrange(n)]\n        start = random.choice(candidates)\n        color_a = vals[start]\n        color_b = a if color_a != a else b\n        # BFS over subgraph induced by {color_a, color_b}\n        use = [False]*n\n        for i in range(n):\n            use[i] = (vals[i] == color_a or vals[i] == color_b)\n        visited = [False]*n\n        queue = [start]\n        visited[start] = True\n        component = []\n        while queue:\n            u = queue.pop(0)\n            if use[u]:\n                component.append(u)\n                for w in adj[u]:\n                    if not visited[w] and use[w]:\n                        visited[w] = True\n                        queue.append(w)\n        for u in component:\n            vals[u] = color_b if vals[u] == color_a else (color_a if vals[u] == color_b else vals[u])\n        move = 'kempe_swap'\n    else:\n        # Random swap of two nodes' colors\n        i, j = random.sample(range(n), 2)\n        vals[i], vals[j] = vals[j], vals[i]\n        move = 'swap'\n\n    # Stable normalization\n    vals = stable_compact(vals)\n    nb_csv = to_csv(vals)\n    return nb_csv, {'move': move, 'k': max(vals)}\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger perturbation via multiple random Kempe-chain swaps on random color pairs.\n    Returns normalized CSV string with stable compaction.\n    \"\"\"\n    # Graph edges (0-based)\n    edges: List[Tuple[int, int]] = [\n        (0,1),(0,2),(0,6),(0,7),(0,8),\n        (1,2),(1,4),(1,5),(1,6),(1,7),\n        (2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,8),\n        (5,6),(5,7),\n        (7,8)\n    ]\n\n    def parse_csv(solution_str: str) -> List[int]:\n        parts = [p.strip() for p in str(solution_str).split(',') if p.strip() != '']\n        vals: List[int] = []\n        for p in parts[:9]:\n            try:\n                vals.append(int(p))\n            except Exception:\n                vals.append(1)\n        while len(vals) < 9:\n            vals.append(1)\n        vals = [c if c > 0 else 1 for c in vals[:9]]\n        return vals[:9]\n\n    def stable_compact(vals: List[int]) -> List[int]:\n        uniq = sorted(set(vals))\n        mapping = {c: i+1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in vals]\n\n    vals = parse_csv(solution)\n    n = 9\n\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    vals = stable_compact(vals)\n    k = max(1, max(vals))\n\n    # Apply a few Kempe-chain swaps (intensity between 2 and 4)\n    intensity = random.randint(2, 4)\n    for _ in range(intensity):\n        # choose two distinct colors; if only one, allow a temporary second\n        if k == 1:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(list(range(1, k+1)), 2)\n        # pick a start node with color a or b\n        candidates = [i for i, c in enumerate(vals) if c == a or c == b]\n        if not candidates:\n            candidates = [random.randrange(n)]\n        start = random.choice(candidates)\n        color_a = vals[start]\n        color_b = a if color_a != a else b\n        # BFS on induced subgraph {a,b}\n        use = [False]*n\n        for i in range(n):\n            use[i] = (vals[i] == color_a or vals[i] == color_b)\n        visited = [False]*n\n        queue = [start]\n        visited[start] = True\n        component = []\n        while queue:\n            u = queue.pop(0)\n            if use[u]:\n                component.append(u)\n                for w in adj[u]:\n                    if not visited[w] and use[w]:\n                        visited[w] = True\n                        queue.append(w)\n        for u in component:\n            vals[u] = color_b if vals[u] == color_a else (color_a if vals[u] == color_b else vals[u])\n        # refresh k after swap\n        vals = stable_compact(vals)\n        k = max(1, max(vals))\n\n    vals = stable_compact(vals)\n    return ','.join(str(x) for x in vals)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001778956}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraint satisfaction and objective.\n    Lower is better; optimal expected value is 4 for this instance.\n    Valid encodings: list of 9 positive integers (colors) with contiguous labels 1..k.\n    \"\"\"\n    # Embedded problem instance\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    # Structural checks\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    colors = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n        else:\n            colors.append(x)\n    if len(colors) == 0:\n        return 15000.0 + 100.0 * invalid_entries\n    k = max(colors)\n    distinct = set(colors)\n    contiguous_ok = (len(distinct) == k) and all((c in distinct) for c in range(1, k+1))\n    gap_penalty = 0 if contiguous_ok else 1\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv and cu > 0:\n            conflicts += 1\n    # Fitness aggregation: smaller is better. Valid colorings score k.\n    fitness = (\n        (k if (invalid_entries == 0 and conflicts == 0 and gap_penalty == 0) else 0)\n        + 1000.0 * conflicts\n        + 100.0 * invalid_entries\n        + 50.0 * gap_penalty\n    )\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(seq: List[int]) -> List[int]:\n    # Relabel colors to 1..k in order of first appearance for contiguity\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in seq:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Creates a neighbor by either recoloring a single vertex or swapping colors of two vertices.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"LOCAL\"\n    Movement_Type: one of {\"RECOLOR\", \"SWAP\"}\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        # Fallback to a trivial valid-shaped candidate\n        base = [1] * 9\n        return (base, \"LOCAL\", \"RECOLOR\")\n    n = len(solution)\n    s = list(solution)\n    move = \"RECOLOR\" if random.random() < 0.6 else \"SWAP\"\n    if move == \"RECOLOR\":\n        idx = random.randrange(n)\n        current_k = max(1, max([c for c in s if isinstance(c, int) and c > 0] + [1]))\n        # Allow exploring up to k+1 but cap at 5 to avoid explosion; 4 is known optimum\n        cap = min(5, max(4, current_k + 1))\n        new_color = s[idx]\n        # Ensure a change\n        for _ in range(8):\n            cand = random.randint(1, cap)\n            if cand != s[idx]:\n                new_color = cand\n                break\n        s[idx] = int(new_color)\n        s = _normalize_colors(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n    else:\n        # SWAP colors of two distinct vertices\n        if n < 2:\n            return (s, \"LOCAL\", \"RECOLOR\")\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        s = _normalize_colors(s)\n        return (s, \"LOCAL\", \"SWAP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: perform multiple random recolors on distinct vertices,\n    then normalize labels to contiguous 1..k.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1] * 9\n    n = len(solution)\n    s = list(solution)\n    steps = max(3, n \/\/ 3)\n    current_k = max(1, max([c for c in s if isinstance(c, int) and c > 0] + [1]))\n    cap = min(5, max(4, current_k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(steps):\n        i = idxs[t % n]\n        old = s[i]\n        # force a change where possible\n        choices = [c for c in range(1, cap + 1) if c != old]\n        if not choices:\n            continue\n        s[i] = random.choice(choices)\n    # Normalize to contiguous labels\n    mapping = {}\n    next_label = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        s[i] = mapping[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00070868}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraint satisfaction and objective.\n    Lower is better; optimal expected value is 4 for this instance.\n    Valid encodings: list of 9 positive integers (colors) with contiguous labels 1..k.\n    \"\"\"\n    # Embedded problem instance\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    # Structural checks\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    colors = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n        else:\n            colors.append(x)\n    if len(colors) == 0:\n        return 15000.0 + 100.0 * invalid_entries\n    k = max(colors)\n    distinct = set(colors)\n    contiguous_ok = (len(distinct) == k) and all((c in distinct) for c in range(1, k+1))\n    gap_penalty = 0 if contiguous_ok else 1\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv and cu > 0:\n            conflicts += 1\n    # Fitness aggregation: smaller is better. Valid colorings score k.\n    fitness = (\n        (k if (invalid_entries == 0 and conflicts == 0 and gap_penalty == 0) else 0)\n        + 1000.0 * conflicts\n        + 100.0 * invalid_entries\n        + 50.0 * gap_penalty\n    )\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(seq: List[int]) -> List[int]:\n    # Relabel colors to 1..k in order of first appearance for contiguity\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in seq:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Creates a neighbor by either recoloring a single vertex or swapping colors of two vertices.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"LOCAL\"\n    Movement_Type: one of {\"RECOLOR\", \"SWAP\"}\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        # Fallback to a trivial valid-shaped candidate\n        base = [1] * 9\n        return (base, \"LOCAL\", \"RECOLOR\")\n    n = len(solution)\n    s = list(solution)\n    move = \"RECOLOR\" if random.random() < 0.6 else \"SWAP\"\n    if move == \"RECOLOR\":\n        idx = random.randrange(n)\n        current_k = max(1, max([c for c in s if isinstance(c, int) and c > 0] + [1]))\n        # Allow exploring up to k+1 but cap at 5 to avoid explosion; 4 is known optimum\n        cap = min(5, max(4, current_k + 1))\n        new_color = s[idx]\n        # Ensure a change\n        for _ in range(8):\n            cand = random.randint(1, cap)\n            if cand != s[idx]:\n                new_color = cand\n                break\n        s[idx] = int(new_color)\n        s = _normalize_colors(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n    else:\n        # SWAP colors of two distinct vertices\n        if n < 2:\n            return (s, \"LOCAL\", \"RECOLOR\")\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        s = _normalize_colors(s)\n        return (s, \"LOCAL\", \"SWAP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: perform multiple random recolors on distinct vertices,\n    then normalize labels to contiguous 1..k.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1] * 9\n    n = len(solution)\n    s = list(solution)\n    steps = max(3, n \/\/ 3)\n    current_k = max(1, max([c for c in s if isinstance(c, int) and c > 0] + [1]))\n    cap = min(5, max(4, current_k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(steps):\n        i = idxs[t % n]\n        old = s[i]\n        # force a change where possible\n        choices = [c for c in range(1, cap + 1) if c != old]\n        if not choices:\n            continue\n        s[i] = random.choice(choices)\n    # Normalize to contiguous labels\n    mapping = {}\n    next_label = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        s[i] = mapping[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00075847}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraint satisfaction and objective.\n    Lower is better; optimal expected value is 4 for this instance.\n    Valid encodings: list of 9 positive integers (colors) with contiguous labels 1..k.\n    \"\"\"\n    # Embedded problem instance\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    # Structural checks\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    colors = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n        else:\n            colors.append(x)\n    if len(colors) == 0:\n        return 15000.0 + 100.0 * invalid_entries\n    k = max(colors)\n    distinct = set(colors)\n    contiguous_ok = (len(distinct) == k) and all((c in distinct) for c in range(1, k+1))\n    gap_penalty = 0 if contiguous_ok else 1\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv and cu > 0:\n            conflicts += 1\n    # Fitness aggregation: smaller is better. Valid colorings score k.\n    fitness = (\n        (k if (invalid_entries == 0 and conflicts == 0 and gap_penalty == 0) else 0)\n        + 1000.0 * conflicts\n        + 100.0 * invalid_entries\n        + 50.0 * gap_penalty\n    )\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(seq: List[int]) -> List[int]:\n    # Relabel colors to 1..k in order of first appearance for contiguity\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in seq:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Creates a neighbor by either recoloring a single vertex or swapping colors of two vertices.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"LOCAL\"\n    Movement_Type: one of {\"RECOLOR\", \"SWAP\"}\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        # Fallback to a trivial valid-shaped candidate\n        base = [1] * 9\n        return (base, \"LOCAL\", \"RECOLOR\")\n    n = len(solution)\n    s = list(solution)\n    move = \"RECOLOR\" if random.random() < 0.6 else \"SWAP\"\n    if move == \"RECOLOR\":\n        idx = random.randrange(n)\n        current_k = max(1, max([c for c in s if isinstance(c, int) and c > 0] + [1]))\n        # Allow exploring up to k+1 but cap at 5 to avoid explosion; 4 is known optimum\n        cap = min(5, max(4, current_k + 1))\n        new_color = s[idx]\n        # Ensure a change\n        for _ in range(8):\n            cand = random.randint(1, cap)\n            if cand != s[idx]:\n                new_color = cand\n                break\n        s[idx] = int(new_color)\n        s = _normalize_colors(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n    else:\n        # SWAP colors of two distinct vertices\n        if n < 2:\n            return (s, \"LOCAL\", \"RECOLOR\")\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        s = _normalize_colors(s)\n        return (s, \"LOCAL\", \"SWAP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: perform multiple random recolors on distinct vertices,\n    then normalize labels to contiguous 1..k.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return [1] * 9\n    n = len(solution)\n    s = list(solution)\n    steps = max(3, n \/\/ 3)\n    current_k = max(1, max([c for c in s if isinstance(c, int) and c > 0] + [1]))\n    cap = min(5, max(4, current_k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(steps):\n        i = idxs[t % n]\n        old = s[i]\n        # force a change where possible\n        choices = [c for c in range(1, cap + 1) if c != old]\n        if not choices:\n            continue\n        s[i] = random.choice(choices)\n    # Normalize to contiguous labels\n    mapping = {}\n    next_label = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        s[i] = mapping[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000744771}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts, label contiguity) and objective (k).\n    Lower is better. Valid colorings score k (hence optimal expected 4 on this instance).\n    Representation: list of 9 positive integers (colors) with contiguous labels 1..k.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Structural checks\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    colors = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n        else:\n            colors.append(x)\n    if len(colors) == 0:\n        return 15000.0 + 100.0 * invalid_entries\n    k = max(colors)\n    distinct = set(colors)\n    contiguous_ok = (len(distinct) == k) and all((c in distinct) for c in range(1, k+1))\n    gap_penalty = 0 if contiguous_ok else 1\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu > 0 and cv > 0 and cu == cv:\n            conflicts += 1\n    # Fitness aggregation: lexicographic style; always include k to push minimizing colors\n    fitness = (k + 1000.0 * conflicts + 50.0 * gap_penalty + 100.0 * invalid_entries)\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u0 = u-1; v0 = v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    return adj\n\ndef _conflicted_vertices(sol: List[int], edges: List[Tuple[int,int]]) -> List[int]:\n    bad = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            bad.add(u-1); bad.add(v-1)\n    return list(bad)\n\ndef _canonical_normalize(seq: List[int]) -> List[int]:\n    \"\"\"Map sorted unique labels to 1..k to enforce contiguity deterministically.\"\"\"\n    uniq = sorted(set(int(c) if isinstance(c,int) and c>0 else 1 for c in seq))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping.get(int(c) if isinstance(c,int) and c>0 else 1, 1) for c in seq]\n\ndef _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n    nsol = list(sol)\n    target_set = {color_a, color_b}\n    seen = set([start])\n    stack = [start]\n    component = []\n    while stack:\n        u = stack.pop()\n        if nsol[u] not in target_set:\n            continue\n        component.append(u)\n        for v in adj[u]:\n            if v not in seen and nsol[v] in target_set:\n                seen.add(v)\n                stack.append(v)\n    # swap colors within component\n    for u in component:\n        if nsol[u] == color_a:\n            nsol[u] = color_b\n        elif nsol[u] == color_b:\n            nsol[u] = color_a\n    return nsol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (neighbor_solution, \"LOCAL\", move_type) where move_type in {\"RECOLOR\",\"SWAP\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = _adjacency_list(n, edges)\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        base = _canonical_normalize(base)\n        return (base, \"LOCAL\", \"RECOLOR\")\n    s = list(int(c) if isinstance(c,int) and c>0 else 1 for c in solution)\n    k = max(s) if len(s)>0 else 1\n    moves = [\"RECOLOR\",\"SWAP\",\"CLASS_SWAP\",\"KEMPE\"]\n    # Bias move selection: favor recolor\/kempe when conflicts exist\n    conflicted = _conflicted_vertices(s, edges)\n    if conflicted:\n        weights = [0.45, 0.10, 0.10, 0.35]\n    else:\n        weights = [0.40, 0.20, 0.25, 0.15]\n    r = random.random()\n    cum = 0.0\n    pick = moves[0]\n    for m,w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n    if pick == \"RECOLOR\":\n        if conflicted:\n            idx = random.choice(conflicted)\n        else:\n            idx = random.randrange(n)\n        # allow exploring up to k+1, capped by n\n        cap = min(n, max(3, k + (1 if random.random()<0.5 else 0)))\n        newc = s[idx]\n        for _ in range(8):\n            cand = random.randint(1, cap)\n            if cand != s[idx]:\n                newc = cand\n                break\n        s[idx] = int(newc)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n    elif pick == \"SWAP\":\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"SWAP\")\n    elif pick == \"CLASS_SWAP\":\n        if k < 2:\n            # fall back\n            i, j = random.sample(range(n), 2)\n            s[i], s[j] = s[j], s[i]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"SWAP\")\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c==a else (a if c==b else c) for c in s]\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"CLASS_SWAP\")\n    else:  # KEMPE\n        # choose a seed vertex (prefer conflicted) and two colors\n        if conflicted:\n            seed = random.choice(conflicted)\n        else:\n            seed = random.randrange(n)\n        # pick a partner color distinct from seed color\n        colors_present = sorted(set(s))\n        if len(colors_present) == 1:\n            b = min(n, colors_present[0] + 1)\n            colors_present.append(b)\n        a = s[seed]\n        other_choices = [c for c in colors_present if c != a]\n        if not other_choices:\n            other_choices = [min(n, a+1)]\n        b = random.choice(other_choices)\n        s2 = _kempe_interchange(s, seed, a, b, adj)\n        s2 = _canonical_normalize(s2)\n        return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef _canonical_normalize(seq: List[int]) -> List[int]:\n    uniq = sorted(set(int(c) if isinstance(c,int) and c>0 else 1 for c in seq))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping.get(int(c) if isinstance(c,int) and c>0 else 1, 1) for c in seq]\n\ndef _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u0 = u-1; v0 = v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    return adj\n\ndef _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n    seen = set([start])\n    stack = [start]\n    comp = []\n    target = {a,b}\n    while stack:\n        u = stack.pop()\n        if sol[u] not in target:\n            continue\n        comp.append(u)\n        for v in adj[u]:\n            if v not in seen and sol[v] in target:\n                seen.add(v)\n                stack.append(v)\n    return comp\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: multiple Kempe interchanges and a global class swap, plus random recolors.\n    Ensures labels are contiguous at the end.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n    s = list(int(c) if isinstance(c,int) and c>0 else 1 for c in solution)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        # Kempe step\n        seed = random.randrange(n)\n        a = s[seed]\n        b = random.randint(1, max(k, 3))\n        if b == a:\n            b = (a % max(k,3)) + 1\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u]==a else (a if s[u]==b else s[u])\n        k = max(s)\n    # Global class swap\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c==a else (a if c==b else c) for c in s]\n    # Sparse random recolors on ~30% of vertices\n    cap = min(n, max(3, k+1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap+1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001361748}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts, label contiguity) and objective (k).\n    Lower is better. Valid colorings score k (hence optimal expected 4 on this instance).\n    Representation: list of 9 positive integers (colors) with contiguous labels 1..k.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Structural checks\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    colors = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n        else:\n            colors.append(x)\n    if len(colors) == 0:\n        return 15000.0 + 100.0 * invalid_entries\n    k = max(colors)\n    distinct = set(colors)\n    contiguous_ok = (len(distinct) == k) and all((c in distinct) for c in range(1, k+1))\n    gap_penalty = 0 if contiguous_ok else 1\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu > 0 and cv > 0 and cu == cv:\n            conflicts += 1\n    # Fitness aggregation: lexicographic style; always include k to push minimizing colors\n    fitness = (k + 1000.0 * conflicts + 50.0 * gap_penalty + 100.0 * invalid_entries)\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u0 = u-1; v0 = v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    return adj\n\ndef _conflicted_vertices(sol: List[int], edges: List[Tuple[int,int]]) -> List[int]:\n    bad = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            bad.add(u-1); bad.add(v-1)\n    return list(bad)\n\ndef _canonical_normalize(seq: List[int]) -> List[int]:\n    \"\"\"Map sorted unique labels to 1..k to enforce contiguity deterministically.\"\"\"\n    uniq = sorted(set(int(c) if isinstance(c,int) and c>0 else 1 for c in seq))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping.get(int(c) if isinstance(c,int) and c>0 else 1, 1) for c in seq]\n\ndef _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n    nsol = list(sol)\n    target_set = {color_a, color_b}\n    seen = set([start])\n    stack = [start]\n    component = []\n    while stack:\n        u = stack.pop()\n        if nsol[u] not in target_set:\n            continue\n        component.append(u)\n        for v in adj[u]:\n            if v not in seen and nsol[v] in target_set:\n                seen.add(v)\n                stack.append(v)\n    # swap colors within component\n    for u in component:\n        if nsol[u] == color_a:\n            nsol[u] = color_b\n        elif nsol[u] == color_b:\n            nsol[u] = color_a\n    return nsol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (neighbor_solution, \"LOCAL\", move_type) where move_type in {\"RECOLOR\",\"SWAP\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = _adjacency_list(n, edges)\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        base = _canonical_normalize(base)\n        return (base, \"LOCAL\", \"RECOLOR\")\n    s = list(int(c) if isinstance(c,int) and c>0 else 1 for c in solution)\n    k = max(s) if len(s)>0 else 1\n    moves = [\"RECOLOR\",\"SWAP\",\"CLASS_SWAP\",\"KEMPE\"]\n    # Bias move selection: favor recolor\/kempe when conflicts exist\n    conflicted = _conflicted_vertices(s, edges)\n    if conflicted:\n        weights = [0.45, 0.10, 0.10, 0.35]\n    else:\n        weights = [0.40, 0.20, 0.25, 0.15]\n    r = random.random()\n    cum = 0.0\n    pick = moves[0]\n    for m,w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n    if pick == \"RECOLOR\":\n        if conflicted:\n            idx = random.choice(conflicted)\n        else:\n            idx = random.randrange(n)\n        # allow exploring up to k+1, capped by n\n        cap = min(n, max(3, k + (1 if random.random()<0.5 else 0)))\n        newc = s[idx]\n        for _ in range(8):\n            cand = random.randint(1, cap)\n            if cand != s[idx]:\n                newc = cand\n                break\n        s[idx] = int(newc)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n    elif pick == \"SWAP\":\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"SWAP\")\n    elif pick == \"CLASS_SWAP\":\n        if k < 2:\n            # fall back\n            i, j = random.sample(range(n), 2)\n            s[i], s[j] = s[j], s[i]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"SWAP\")\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c==a else (a if c==b else c) for c in s]\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"CLASS_SWAP\")\n    else:  # KEMPE\n        # choose a seed vertex (prefer conflicted) and two colors\n        if conflicted:\n            seed = random.choice(conflicted)\n        else:\n            seed = random.randrange(n)\n        # pick a partner color distinct from seed color\n        colors_present = sorted(set(s))\n        if len(colors_present) == 1:\n            b = min(n, colors_present[0] + 1)\n            colors_present.append(b)\n        a = s[seed]\n        other_choices = [c for c in colors_present if c != a]\n        if not other_choices:\n            other_choices = [min(n, a+1)]\n        b = random.choice(other_choices)\n        s2 = _kempe_interchange(s, seed, a, b, adj)\n        s2 = _canonical_normalize(s2)\n        return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef _canonical_normalize(seq: List[int]) -> List[int]:\n    uniq = sorted(set(int(c) if isinstance(c,int) and c>0 else 1 for c in seq))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping.get(int(c) if isinstance(c,int) and c>0 else 1, 1) for c in seq]\n\ndef _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u0 = u-1; v0 = v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    return adj\n\ndef _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n    seen = set([start])\n    stack = [start]\n    comp = []\n    target = {a,b}\n    while stack:\n        u = stack.pop()\n        if sol[u] not in target:\n            continue\n        comp.append(u)\n        for v in adj[u]:\n            if v not in seen and sol[v] in target:\n                seen.add(v)\n                stack.append(v)\n    return comp\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: multiple Kempe interchanges and a global class swap, plus random recolors.\n    Ensures labels are contiguous at the end.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n    s = list(int(c) if isinstance(c,int) and c>0 else 1 for c in solution)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        # Kempe step\n        seed = random.randrange(n)\n        a = s[seed]\n        b = random.randint(1, max(k, 3))\n        if b == a:\n            b = (a % max(k,3)) + 1\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u]==a else (a if s[u]==b else s[u])\n        k = max(s)\n    # Global class swap\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c==a else (a if c==b else c) for c in s]\n    # Sparse random recolors on ~30% of vertices\n    cap = min(n, max(3, k+1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap+1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001727954}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts, label contiguity) and objective (k).\n    Lower is better. Valid colorings score k (hence optimal expected 4 on this instance).\n    Representation: list of 9 positive integers (colors) with contiguous labels 1..k.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Structural checks\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    colors = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n        else:\n            colors.append(x)\n    if len(colors) == 0:\n        return 15000.0 + 100.0 * invalid_entries\n    k = max(colors)\n    distinct = set(colors)\n    contiguous_ok = (len(distinct) == k) and all((c in distinct) for c in range(1, k+1))\n    gap_penalty = 0 if contiguous_ok else 1\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu > 0 and cv > 0 and cu == cv:\n            conflicts += 1\n    # Fitness aggregation: lexicographic style; always include k to push minimizing colors\n    fitness = (k + 1000.0 * conflicts + 50.0 * gap_penalty + 100.0 * invalid_entries)\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u0 = u-1; v0 = v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    return adj\n\ndef _conflicted_vertices(sol: List[int], edges: List[Tuple[int,int]]) -> List[int]:\n    bad = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            bad.add(u-1); bad.add(v-1)\n    return list(bad)\n\ndef _canonical_normalize(seq: List[int]) -> List[int]:\n    \"\"\"Map sorted unique labels to 1..k to enforce contiguity deterministically.\"\"\"\n    uniq = sorted(set(int(c) if isinstance(c,int) and c>0 else 1 for c in seq))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping.get(int(c) if isinstance(c,int) and c>0 else 1, 1) for c in seq]\n\ndef _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n    nsol = list(sol)\n    target_set = {color_a, color_b}\n    seen = set([start])\n    stack = [start]\n    component = []\n    while stack:\n        u = stack.pop()\n        if nsol[u] not in target_set:\n            continue\n        component.append(u)\n        for v in adj[u]:\n            if v not in seen and nsol[v] in target_set:\n                seen.add(v)\n                stack.append(v)\n    # swap colors within component\n    for u in component:\n        if nsol[u] == color_a:\n            nsol[u] = color_b\n        elif nsol[u] == color_b:\n            nsol[u] = color_a\n    return nsol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (neighbor_solution, \"LOCAL\", move_type) where move_type in {\"RECOLOR\",\"SWAP\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = _adjacency_list(n, edges)\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        base = _canonical_normalize(base)\n        return (base, \"LOCAL\", \"RECOLOR\")\n    s = list(int(c) if isinstance(c,int) and c>0 else 1 for c in solution)\n    k = max(s) if len(s)>0 else 1\n    moves = [\"RECOLOR\",\"SWAP\",\"CLASS_SWAP\",\"KEMPE\"]\n    # Bias move selection: favor recolor\/kempe when conflicts exist\n    conflicted = _conflicted_vertices(s, edges)\n    if conflicted:\n        weights = [0.45, 0.10, 0.10, 0.35]\n    else:\n        weights = [0.40, 0.20, 0.25, 0.15]\n    r = random.random()\n    cum = 0.0\n    pick = moves[0]\n    for m,w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n    if pick == \"RECOLOR\":\n        if conflicted:\n            idx = random.choice(conflicted)\n        else:\n            idx = random.randrange(n)\n        # allow exploring up to k+1, capped by n\n        cap = min(n, max(3, k + (1 if random.random()<0.5 else 0)))\n        newc = s[idx]\n        for _ in range(8):\n            cand = random.randint(1, cap)\n            if cand != s[idx]:\n                newc = cand\n                break\n        s[idx] = int(newc)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n    elif pick == \"SWAP\":\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"SWAP\")\n    elif pick == \"CLASS_SWAP\":\n        if k < 2:\n            # fall back\n            i, j = random.sample(range(n), 2)\n            s[i], s[j] = s[j], s[i]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"SWAP\")\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c==a else (a if c==b else c) for c in s]\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"CLASS_SWAP\")\n    else:  # KEMPE\n        # choose a seed vertex (prefer conflicted) and two colors\n        if conflicted:\n            seed = random.choice(conflicted)\n        else:\n            seed = random.randrange(n)\n        # pick a partner color distinct from seed color\n        colors_present = sorted(set(s))\n        if len(colors_present) == 1:\n            b = min(n, colors_present[0] + 1)\n            colors_present.append(b)\n        a = s[seed]\n        other_choices = [c for c in colors_present if c != a]\n        if not other_choices:\n            other_choices = [min(n, a+1)]\n        b = random.choice(other_choices)\n        s2 = _kempe_interchange(s, seed, a, b, adj)\n        s2 = _canonical_normalize(s2)\n        return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef _canonical_normalize(seq: List[int]) -> List[int]:\n    uniq = sorted(set(int(c) if isinstance(c,int) and c>0 else 1 for c in seq))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping.get(int(c) if isinstance(c,int) and c>0 else 1, 1) for c in seq]\n\ndef _adjacency_list(n: int, edges: List[Tuple[int,int]]):\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u0 = u-1; v0 = v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    return adj\n\ndef _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n    seen = set([start])\n    stack = [start]\n    comp = []\n    target = {a,b}\n    while stack:\n        u = stack.pop()\n        if sol[u] not in target:\n            continue\n        comp.append(u)\n        for v in adj[u]:\n            if v not in seen and sol[v] in target:\n                seen.add(v)\n                stack.append(v)\n    return comp\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: multiple Kempe interchanges and a global class swap, plus random recolors.\n    Ensures labels are contiguous at the end.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n    s = list(int(c) if isinstance(c,int) and c>0 else 1 for c in solution)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        # Kempe step\n        seed = random.randrange(n)\n        a = s[seed]\n        b = random.randint(1, max(k, 3))\n        if b == a:\n            b = (a % max(k,3)) + 1\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u]==a else (a if s[u]==b else s[u])\n        k = max(s)\n    # Global class swap\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c==a else (a if c==b else c) for c in s]\n    # Sparse random recolors on ~30% of vertices\n    cap = min(n, max(3, k+1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap+1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001578631}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts) and objective (k).\n    Lower is better. Valid colorings score k.\n    Representation: list of 9 positive integers (colors) with contiguous labels 1..k.\n    This evaluator internally normalizes labels to 1..k to ensure fair comparison.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks and normalization (no side effects on caller data)\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    tmp = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n            tmp.append(1)\n        else:\n            tmp.append(int(x))\n    # Canonical relabel to 1..k (preserves equality relations)\n    uniq = sorted(set(tmp))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    s = [mapping[c] for c in tmp]\n    k = max(s) if s else 1\n\n    # Count edge conflicts on normalized labels\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Fitness aggregation: conflicts dominate; then minimize k; penalize invalid entries\n    fitness = (1000.0 * conflicts) + k + (100.0 * invalid_entries)\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, \"LOCAL\", move_type)\n    move_type in {\"RECOLOR\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _conflicted_vertices(sol: List[int], eds: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for (u, v) in eds:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n        nsol = list(sol)\n        target_set = {color_a, color_b}\n        seen = set([start])\n        stack = [start]\n        component = []\n        while stack:\n            u = stack.pop()\n            if nsol[u] not in target_set:\n                continue\n            component.append(u)\n            for v in adj[u]:\n                if v not in seen and nsol[v] in target_set:\n                    seen.add(v)\n                    stack.append(v)\n        for u in component:\n            if nsol[u] == color_a:\n                nsol[u] = color_b\n            elif nsol[u] == color_b:\n                nsol[u] = color_a\n        return nsol\n\n    adj = _adjacency_list(n, edges)\n\n    # Seed if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        base = _canonical_normalize(base)\n        return (base, \"LOCAL\", \"RECOLOR\")\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n\n    # Move selection with conflict-aware bias\n    conflicted = _conflicted_vertices(s, edges)\n    moves = [\"RECOLOR\", \"CLASS_SWAP\", \"KEMPE\"]\n    if conflicted:\n        weights = [0.5, 0.1, 0.4]\n    else:\n        weights = [0.4, 0.25, 0.35]\n    r = random.random(); cum = 0.0; pick = moves[0]\n    for m, w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n\n    if pick == \"RECOLOR\":\n        # Prefer recoloring conflicted vertex; restrict palette to <= k when conflicts exist\n        if conflicted:\n            idx = random.choice(conflicted)\n            cap = max(1, k)\n        else:\n            idx = random.randrange(n)\n            cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    if pick == \"CLASS_SWAP\":\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            s = [b if c == a else (a if c == b else c) for c in s]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"CLASS_SWAP\")\n        # Fallback to recolor\n        idx = random.randrange(n)\n        cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    # KEMPE move\n    seed = random.choice(conflicted) if conflicted else random.randrange(n)\n    colors_present = sorted(set(s))\n    a = s[seed]\n    other = [c for c in colors_present if c != a]\n    if not other:\n        other = [min(n, a + 1)]\n    b = random.choice(other)\n    s2 = _kempe_interchange(s, seed, a, b, adj)\n    s2 = _canonical_normalize(s2)\n    return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: chained Kempe interchanges, a global class swap, and sparse recolors.\n    Ensures labels are contiguous at the end.\n    \"\"\"\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n        seen = set([start])\n        stack = [start]\n        comp = []\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            if sol[u] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in seen and sol[v] in target:\n                    seen.add(v)\n                    stack.append(v)\n        return comp\n\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        seed = random.randrange(n)\n        a = s[seed]\n        b = random.randint(1, max(k, 3))\n        if b == a:\n            b = (a % max(k, 3)) + 1\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        k = max(s)\n\n    # Global class swap\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        s = [b if c == a else (a if c == b else c) for c in s]\n\n    # Sparse random recolors\n    cap = min(n, max(3, k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap + 1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001372678}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts) and objective (k).\n    Lower is better. Valid colorings score k.\n    Representation: list of 9 positive integers (colors) with contiguous labels 1..k.\n    This evaluator internally normalizes labels to 1..k to ensure fair comparison.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks and normalization (no side effects on caller data)\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    tmp = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n            tmp.append(1)\n        else:\n            tmp.append(int(x))\n    # Canonical relabel to 1..k (preserves equality relations)\n    uniq = sorted(set(tmp))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    s = [mapping[c] for c in tmp]\n    k = max(s) if s else 1\n\n    # Count edge conflicts on normalized labels\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Fitness aggregation: conflicts dominate; then minimize k; penalize invalid entries\n    fitness = (1000.0 * conflicts) + k + (100.0 * invalid_entries)\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, \"LOCAL\", move_type)\n    move_type in {\"RECOLOR\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _conflicted_vertices(sol: List[int], eds: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for (u, v) in eds:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n        nsol = list(sol)\n        target_set = {color_a, color_b}\n        seen = set([start])\n        stack = [start]\n        component = []\n        while stack:\n            u = stack.pop()\n            if nsol[u] not in target_set:\n                continue\n            component.append(u)\n            for v in adj[u]:\n                if v not in seen and nsol[v] in target_set:\n                    seen.add(v)\n                    stack.append(v)\n        for u in component:\n            if nsol[u] == color_a:\n                nsol[u] = color_b\n            elif nsol[u] == color_b:\n                nsol[u] = color_a\n        return nsol\n\n    adj = _adjacency_list(n, edges)\n\n    # Seed if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        base = _canonical_normalize(base)\n        return (base, \"LOCAL\", \"RECOLOR\")\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n\n    # Move selection with conflict-aware bias\n    conflicted = _conflicted_vertices(s, edges)\n    moves = [\"RECOLOR\", \"CLASS_SWAP\", \"KEMPE\"]\n    if conflicted:\n        weights = [0.5, 0.1, 0.4]\n    else:\n        weights = [0.4, 0.25, 0.35]\n    r = random.random(); cum = 0.0; pick = moves[0]\n    for m, w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n\n    if pick == \"RECOLOR\":\n        # Prefer recoloring conflicted vertex; restrict palette to <= k when conflicts exist\n        if conflicted:\n            idx = random.choice(conflicted)\n            cap = max(1, k)\n        else:\n            idx = random.randrange(n)\n            cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    if pick == \"CLASS_SWAP\":\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            s = [b if c == a else (a if c == b else c) for c in s]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"CLASS_SWAP\")\n        # Fallback to recolor\n        idx = random.randrange(n)\n        cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    # KEMPE move\n    seed = random.choice(conflicted) if conflicted else random.randrange(n)\n    colors_present = sorted(set(s))\n    a = s[seed]\n    other = [c for c in colors_present if c != a]\n    if not other:\n        other = [min(n, a + 1)]\n    b = random.choice(other)\n    s2 = _kempe_interchange(s, seed, a, b, adj)\n    s2 = _canonical_normalize(s2)\n    return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: chained Kempe interchanges, a global class swap, and sparse recolors.\n    Ensures labels are contiguous at the end.\n    \"\"\"\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n        seen = set([start])\n        stack = [start]\n        comp = []\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            if sol[u] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in seen and sol[v] in target:\n                    seen.add(v)\n                    stack.append(v)\n        return comp\n\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        seed = random.randrange(n)\n        a = s[seed]\n        b = random.randint(1, max(k, 3))\n        if b == a:\n            b = (a % max(k, 3)) + 1\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        k = max(s)\n\n    # Global class swap\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        s = [b if c == a else (a if c == b else c) for c in s]\n\n    # Sparse random recolors\n    cap = min(n, max(3, k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap + 1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001881795}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_SEQ_1_TO_K","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts) and objective (k).\n    Lower is better. Valid colorings score k.\n    Representation: list of 9 positive integers (colors) with contiguous labels 1..k.\n    This evaluator internally normalizes labels to 1..k to ensure fair comparison.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks and normalization (no side effects on caller data)\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    tmp = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n            tmp.append(1)\n        else:\n            tmp.append(int(x))\n    # Canonical relabel to 1..k (preserves equality relations)\n    uniq = sorted(set(tmp))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    s = [mapping[c] for c in tmp]\n    k = max(s) if s else 1\n\n    # Count edge conflicts on normalized labels\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Fitness aggregation: conflicts dominate; then minimize k; penalize invalid entries\n    fitness = (1000.0 * conflicts) + k + (100.0 * invalid_entries)\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, \"LOCAL\", move_type)\n    move_type in {\"RECOLOR\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _conflicted_vertices(sol: List[int], eds: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for (u, v) in eds:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n        nsol = list(sol)\n        target_set = {color_a, color_b}\n        seen = set([start])\n        stack = [start]\n        component = []\n        while stack:\n            u = stack.pop()\n            if nsol[u] not in target_set:\n                continue\n            component.append(u)\n            for v in adj[u]:\n                if v not in seen and nsol[v] in target_set:\n                    seen.add(v)\n                    stack.append(v)\n        for u in component:\n            if nsol[u] == color_a:\n                nsol[u] = color_b\n            elif nsol[u] == color_b:\n                nsol[u] = color_a\n        return nsol\n\n    adj = _adjacency_list(n, edges)\n\n    # Seed if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        base = _canonical_normalize(base)\n        return (base, \"LOCAL\", \"RECOLOR\")\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n\n    # Move selection with conflict-aware bias\n    conflicted = _conflicted_vertices(s, edges)\n    moves = [\"RECOLOR\", \"CLASS_SWAP\", \"KEMPE\"]\n    if conflicted:\n        weights = [0.5, 0.1, 0.4]\n    else:\n        weights = [0.4, 0.25, 0.35]\n    r = random.random(); cum = 0.0; pick = moves[0]\n    for m, w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n\n    if pick == \"RECOLOR\":\n        # Prefer recoloring conflicted vertex; restrict palette to <= k when conflicts exist\n        if conflicted:\n            idx = random.choice(conflicted)\n            cap = max(1, k)\n        else:\n            idx = random.randrange(n)\n            cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    if pick == \"CLASS_SWAP\":\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            s = [b if c == a else (a if c == b else c) for c in s]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"CLASS_SWAP\")\n        # Fallback to recolor\n        idx = random.randrange(n)\n        cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    # KEMPE move\n    seed = random.choice(conflicted) if conflicted else random.randrange(n)\n    colors_present = sorted(set(s))\n    a = s[seed]\n    other = [c for c in colors_present if c != a]\n    if not other:\n        other = [min(n, a + 1)]\n    b = random.choice(other)\n    s2 = _kempe_interchange(s, seed, a, b, adj)\n    s2 = _canonical_normalize(s2)\n    return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: chained Kempe interchanges, a global class swap, and sparse recolors.\n    Ensures labels are contiguous at the end.\n    \"\"\"\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n        seen = set([start])\n        stack = [start]\n        comp = []\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            if sol[u] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in seen and sol[v] in target:\n                    seen.add(v)\n                    stack.append(v)\n        return comp\n\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        seed = random.randrange(n)\n        a = s[seed]\n        b = random.randint(1, max(k, 3))\n        if b == a:\n            b = (a % max(k, 3)) + 1\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        k = max(s)\n\n    # Global class swap\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        s = [b if c == a else (a if c == b else c) for c in s]\n\n    # Sparse random recolors\n    cap = min(n, max(3, k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap + 1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002114458}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"List[int] of length 9. Colors are positive integers with contiguous labels 1..k. Example: [4,1,2,3,3,4,4,2,1]","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts) and objective (k).\n    Lower is better. Valid colorings score k. Representation: list of 9 positive\n    integers (colors) with contiguous labels 1..k. This evaluator internally normalizes\n    labels to 1..k to ensure fair comparison.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks and normalization (no side effects on caller data)\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    tmp: List[int] = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n            tmp.append(1)\n        else:\n            tmp.append(int(x))\n    # Canonical relabel to 1..k (preserves equality relations)\n    uniq = sorted(set(tmp))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    s = [mapping[c] for c in tmp]\n    k = max(s) if s else 1\n\n    # Count edge conflicts on normalized labels\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Optional mild tiebreaker on class balance once conflict-free\n    class_balance_penalty = 0.0\n    if conflicts == 0:\n        counts = [0]*(k)\n        for c in s:\n            counts[c-1] += 1\n        class_balance_penalty = 1e-3 * max(counts)  # tiny\n\n    # Fitness aggregation: conflicts dominate; then minimize k; penalize invalid entries\n    fitness = (1000.0 * conflicts) + k + (100.0 * invalid_entries) + class_balance_penalty\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, \"LOCAL\", move_type)\n    move_type in {\"RECOLOR\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _conflicted_vertices(sol: List[int], eds: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for (u, v) in eds:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n        nsol = list(sol)\n        target_set = {color_a, color_b}\n        seen = set([start])\n        stack = [start]\n        component = []\n        while stack:\n            u = stack.pop()\n            if nsol[u] not in target_set:\n                continue\n            component.append(u)\n            for v in adj[u]:\n                if v not in seen and nsol[v] in target_set:\n                    seen.add(v)\n                    stack.append(v)\n        for u in component:\n            if nsol[u] == color_a:\n                nsol[u] = color_b\n            elif nsol[u] == color_b:\n                nsol[u] = color_a\n        return nsol\n\n    adj = _adjacency_list(n, edges)\n\n    # Seed if invalid via simple greedy DSATUR-like heuristic\n    def _seed_dsatur():\n        colors = [0]*n\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        order = list(range(n))\n        # degrees for tie-break\n        deg = [0]*n\n        for (u,v) in edges:\n            deg[u-1]+=1; deg[v-1]+=1\n        for _ in range(n):\n            # pick uncolored with max (sat_deg, deg)\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat_deg[x], deg[x]))\n            used = neighbor_colors[i]\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n            for v in adj[i]:\n                neighbor_colors[v].add(c)\n                sat_deg[v] = len(neighbor_colors[v])\n        return _canonical_normalize(colors)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        base = _seed_dsatur()\n        return (base, \"LOCAL\", \"RECOLOR\")\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n\n    # Move selection with conflict-aware bias\n    conflicted = _conflicted_vertices(s, edges)\n    moves = [\"RECOLOR\", \"CLASS_SWAP\", \"KEMPE\"]\n    if conflicted:\n        weights = [0.55, 0.1, 0.35]\n    else:\n        weights = [0.35, 0.25, 0.40]\n    r = random.random(); cum = 0.0; pick = moves[0]\n    for m, w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n\n    if pick == \"RECOLOR\":\n        # Prefer recoloring conflicted vertex; restrict palette to <= k when conflicts exist\n        if conflicted:\n            idx = random.choice(conflicted)\n            cap = max(1, k)\n        else:\n            idx = random.randrange(n)\n            cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    if pick == \"CLASS_SWAP\":\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            s = [b if c == a else (a if c == b else c) for c in s]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"CLASS_SWAP\")\n        # Fallback to recolor\n        idx = random.randrange(n)\n        cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    # KEMPE move\n    # If conflicts exist, bias seed to conflicted vertex and choose partner color seen in its neighborhood\n    if conflicted:\n        seed = random.choice(conflicted)\n        a = s[seed]\n        neigh_colors = {s[v] for v in adj[seed]}\n        other = list(neigh_colors - {a})\n        if not other:\n            colors_present = sorted(set(s))\n            other = [c for c in colors_present if c != a]\n        b = random.choice(other) if other else (a % max(2, k)) + 1\n    else:\n        seed = random.randrange(n)\n        colors_present = sorted(set(s))\n        a = s[seed]\n        other = [c for c in colors_present if c != a]\n        b = random.choice(other) if other else (a % max(2, k)) + 1\n    s2 = _kempe_interchange(s, seed, a, b, adj)\n    s2 = _canonical_normalize(s2)\n    return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: chained Kempe interchanges, a global class swap, and sparse recolors.\n    Ensures labels are contiguous at the end. Increases move radius for ILS\/SA restarts.\n    \"\"\"\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n        seen = set([start])\n        stack = [start]\n        comp = []\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            if sol[u] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in seen and sol[v] in target:\n                    seen.add(v)\n                    stack.append(v)\n        return comp\n\n    # If invalid, seed using a small random palette, then normalize\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n\n    # Chain 3-5 Kempe interchanges\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        seed = random.randrange(n)\n        a = s[seed]\n        # choose b from neighbor colors if available, else from current palette\n        neigh_colors = {s[v] for v in adj[seed]}\n        if neigh_colors:\n            b_candidates = list(neigh_colors - {a}) or list(neigh_colors)\n        else:\n            b_candidates = list(set(s))\n        b = random.choice(b_candidates)\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        k = max(s)\n\n    # Global class swap to reshuffle palette\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        s = [b if c == a else (a if c == b else c) for c in s]\n\n    # Sparse random recolors with slight palette expansion\n    cap = min(n, max(3, k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap + 1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001581521}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"List[int] of length 9. Colors are positive integers with contiguous labels 1..k. Example: [4,1,2,3,3,4,4,2,1]","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts) and objective (k).\n    Lower is better. Valid colorings score k. Representation: list of 9 positive\n    integers (colors) with contiguous labels 1..k. This evaluator internally normalizes\n    labels to 1..k to ensure fair comparison.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks and normalization (no side effects on caller data)\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    tmp: List[int] = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n            tmp.append(1)\n        else:\n            tmp.append(int(x))\n    # Canonical relabel to 1..k (preserves equality relations)\n    uniq = sorted(set(tmp))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    s = [mapping[c] for c in tmp]\n    k = max(s) if s else 1\n\n    # Count edge conflicts on normalized labels\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Optional mild tiebreaker on class balance once conflict-free\n    class_balance_penalty = 0.0\n    if conflicts == 0:\n        counts = [0]*(k)\n        for c in s:\n            counts[c-1] += 1\n        class_balance_penalty = 1e-3 * max(counts)  # tiny\n\n    # Fitness aggregation: conflicts dominate; then minimize k; penalize invalid entries\n    fitness = (1000.0 * conflicts) + k + (100.0 * invalid_entries) + class_balance_penalty\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, \"LOCAL\", move_type)\n    move_type in {\"RECOLOR\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _conflicted_vertices(sol: List[int], eds: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for (u, v) in eds:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n        nsol = list(sol)\n        target_set = {color_a, color_b}\n        seen = set([start])\n        stack = [start]\n        component = []\n        while stack:\n            u = stack.pop()\n            if nsol[u] not in target_set:\n                continue\n            component.append(u)\n            for v in adj[u]:\n                if v not in seen and nsol[v] in target_set:\n                    seen.add(v)\n                    stack.append(v)\n        for u in component:\n            if nsol[u] == color_a:\n                nsol[u] = color_b\n            elif nsol[u] == color_b:\n                nsol[u] = color_a\n        return nsol\n\n    adj = _adjacency_list(n, edges)\n\n    # Seed if invalid via simple greedy DSATUR-like heuristic\n    def _seed_dsatur():\n        colors = [0]*n\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        order = list(range(n))\n        # degrees for tie-break\n        deg = [0]*n\n        for (u,v) in edges:\n            deg[u-1]+=1; deg[v-1]+=1\n        for _ in range(n):\n            # pick uncolored with max (sat_deg, deg)\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat_deg[x], deg[x]))\n            used = neighbor_colors[i]\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n            for v in adj[i]:\n                neighbor_colors[v].add(c)\n                sat_deg[v] = len(neighbor_colors[v])\n        return _canonical_normalize(colors)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        base = _seed_dsatur()\n        return (base, \"LOCAL\", \"RECOLOR\")\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n\n    # Move selection with conflict-aware bias\n    conflicted = _conflicted_vertices(s, edges)\n    moves = [\"RECOLOR\", \"CLASS_SWAP\", \"KEMPE\"]\n    if conflicted:\n        weights = [0.55, 0.1, 0.35]\n    else:\n        weights = [0.35, 0.25, 0.40]\n    r = random.random(); cum = 0.0; pick = moves[0]\n    for m, w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n\n    if pick == \"RECOLOR\":\n        # Prefer recoloring conflicted vertex; restrict palette to <= k when conflicts exist\n        if conflicted:\n            idx = random.choice(conflicted)\n            cap = max(1, k)\n        else:\n            idx = random.randrange(n)\n            cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    if pick == \"CLASS_SWAP\":\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            s = [b if c == a else (a if c == b else c) for c in s]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"CLASS_SWAP\")\n        # Fallback to recolor\n        idx = random.randrange(n)\n        cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    # KEMPE move\n    # If conflicts exist, bias seed to conflicted vertex and choose partner color seen in its neighborhood\n    if conflicted:\n        seed = random.choice(conflicted)\n        a = s[seed]\n        neigh_colors = {s[v] for v in adj[seed]}\n        other = list(neigh_colors - {a})\n        if not other:\n            colors_present = sorted(set(s))\n            other = [c for c in colors_present if c != a]\n        b = random.choice(other) if other else (a % max(2, k)) + 1\n    else:\n        seed = random.randrange(n)\n        colors_present = sorted(set(s))\n        a = s[seed]\n        other = [c for c in colors_present if c != a]\n        b = random.choice(other) if other else (a % max(2, k)) + 1\n    s2 = _kempe_interchange(s, seed, a, b, adj)\n    s2 = _canonical_normalize(s2)\n    return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: chained Kempe interchanges, a global class swap, and sparse recolors.\n    Ensures labels are contiguous at the end. Increases move radius for ILS\/SA restarts.\n    \"\"\"\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n        seen = set([start])\n        stack = [start]\n        comp = []\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            if sol[u] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in seen and sol[v] in target:\n                    seen.add(v)\n                    stack.append(v)\n        return comp\n\n    # If invalid, seed using a small random palette, then normalize\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n\n    # Chain 3-5 Kempe interchanges\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        seed = random.randrange(n)\n        a = s[seed]\n        # choose b from neighbor colors if available, else from current palette\n        neigh_colors = {s[v] for v in adj[seed]}\n        if neigh_colors:\n            b_candidates = list(neigh_colors - {a}) or list(neigh_colors)\n        else:\n            b_candidates = list(set(s))\n        b = random.choice(b_candidates)\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        k = max(s)\n\n    # Global class swap to reshuffle palette\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        s = [b if c == a else (a if c == b else c) for c in s]\n\n    # Sparse random recolors with slight palette expansion\n    cap = min(n, max(3, k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap + 1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001808263}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"List[int] of length 9. Colors are positive integers with contiguous labels 1..k. Example: [4,1,2,3,3,4,4,2,1]","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness combining constraints (edge conflicts) and objective (k).\n    Lower is better. Valid colorings score k. Representation: list of 9 positive\n    integers (colors) with contiguous labels 1..k. This evaluator internally normalizes\n    labels to 1..k to ensure fair comparison.\n    \"\"\"\n    # Embedded problem instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks and normalization (no side effects on caller data)\n    if not isinstance(solution, list):\n        return 20000.0\n    if len(solution) != n:\n        return 10000.0 + abs(len(solution) - n)\n    invalid_entries = 0\n    tmp: List[int] = []\n    for x in solution:\n        if isinstance(x, bool) or not isinstance(x, int) or x <= 0:\n            invalid_entries += 1\n            tmp.append(1)\n        else:\n            tmp.append(int(x))\n    # Canonical relabel to 1..k (preserves equality relations)\n    uniq = sorted(set(tmp))\n    mapping = {c: i+1 for i, c in enumerate(uniq)}\n    s = [mapping[c] for c in tmp]\n    k = max(s) if s else 1\n\n    # Count edge conflicts on normalized labels\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Optional mild tiebreaker on class balance once conflict-free\n    class_balance_penalty = 0.0\n    if conflicts == 0:\n        counts = [0]*(k)\n        for c in s:\n            counts[c-1] += 1\n        class_balance_penalty = 1e-3 * max(counts)  # tiny\n\n    # Fitness aggregation: conflicts dominate; then minimize k; penalize invalid entries\n    fitness = (1000.0 * conflicts) + k + (100.0 * invalid_entries) + class_balance_penalty\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, \"LOCAL\", move_type)\n    move_type in {\"RECOLOR\",\"CLASS_SWAP\",\"KEMPE\"}\n    Representation invariant enforced via canonical normalization.\n    \"\"\"\n    # Embedded instance\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _conflicted_vertices(sol: List[int], eds: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for (u, v) in eds:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1); bad.add(v-1)\n        return list(bad)\n\n    def _kempe_interchange(sol: List[int], start: int, color_a: int, color_b: int, adj: List[List[int]]) -> List[int]:\n        nsol = list(sol)\n        target_set = {color_a, color_b}\n        seen = set([start])\n        stack = [start]\n        component = []\n        while stack:\n            u = stack.pop()\n            if nsol[u] not in target_set:\n                continue\n            component.append(u)\n            for v in adj[u]:\n                if v not in seen and nsol[v] in target_set:\n                    seen.add(v)\n                    stack.append(v)\n        for u in component:\n            if nsol[u] == color_a:\n                nsol[u] = color_b\n            elif nsol[u] == color_b:\n                nsol[u] = color_a\n        return nsol\n\n    adj = _adjacency_list(n, edges)\n\n    # Seed if invalid via simple greedy DSATUR-like heuristic\n    def _seed_dsatur():\n        colors = [0]*n\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        order = list(range(n))\n        # degrees for tie-break\n        deg = [0]*n\n        for (u,v) in edges:\n            deg[u-1]+=1; deg[v-1]+=1\n        for _ in range(n):\n            # pick uncolored with max (sat_deg, deg)\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat_deg[x], deg[x]))\n            used = neighbor_colors[i]\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n            for v in adj[i]:\n                neighbor_colors[v].add(c)\n                sat_deg[v] = len(neighbor_colors[v])\n        return _canonical_normalize(colors)\n\n    if not isinstance(solution, list) or len(solution) != n:\n        base = _seed_dsatur()\n        return (base, \"LOCAL\", \"RECOLOR\")\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n\n    # Move selection with conflict-aware bias\n    conflicted = _conflicted_vertices(s, edges)\n    moves = [\"RECOLOR\", \"CLASS_SWAP\", \"KEMPE\"]\n    if conflicted:\n        weights = [0.55, 0.1, 0.35]\n    else:\n        weights = [0.35, 0.25, 0.40]\n    r = random.random(); cum = 0.0; pick = moves[0]\n    for m, w in zip(moves, weights):\n        cum += w\n        if r <= cum:\n            pick = m\n            break\n\n    if pick == \"RECOLOR\":\n        # Prefer recoloring conflicted vertex; restrict palette to <= k when conflicts exist\n        if conflicted:\n            idx = random.choice(conflicted)\n            cap = max(1, k)\n        else:\n            idx = random.randrange(n)\n            cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    if pick == \"CLASS_SWAP\":\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            s = [b if c == a else (a if c == b else c) for c in s]\n            s = _canonical_normalize(s)\n            return (s, \"LOCAL\", \"CLASS_SWAP\")\n        # Fallback to recolor\n        idx = random.randrange(n)\n        cap = min(n, max(3, k + 1))\n        choices = [c for c in range(1, cap + 1) if c != s[idx]]\n        if choices:\n            s[idx] = random.choice(choices)\n        s = _canonical_normalize(s)\n        return (s, \"LOCAL\", \"RECOLOR\")\n\n    # KEMPE move\n    # If conflicts exist, bias seed to conflicted vertex and choose partner color seen in its neighborhood\n    if conflicted:\n        seed = random.choice(conflicted)\n        a = s[seed]\n        neigh_colors = {s[v] for v in adj[seed]}\n        other = list(neigh_colors - {a})\n        if not other:\n            colors_present = sorted(set(s))\n            other = [c for c in colors_present if c != a]\n        b = random.choice(other) if other else (a % max(2, k)) + 1\n    else:\n        seed = random.randrange(n)\n        colors_present = sorted(set(s))\n        a = s[seed]\n        other = [c for c in colors_present if c != a]\n        b = random.choice(other) if other else (a % max(2, k)) + 1\n    s2 = _kempe_interchange(s, seed, a, b, adj)\n    s2 = _canonical_normalize(s2)\n    return (s2, \"LOCAL\", \"KEMPE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation: chained Kempe interchanges, a global class swap, and sparse recolors.\n    Ensures labels are contiguous at the end. Increases move radius for ILS\/SA restarts.\n    \"\"\"\n    n = 9\n    edges: List[Tuple[int,int]] = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def _canonical_normalize(seq: List[int]) -> List[int]:\n        uniq = sorted(set(int(c) if isinstance(c, int) and c > 0 else 1 for c in seq))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping.get(int(c) if isinstance(c, int) and c > 0 else 1, 1) for c in seq]\n\n    def _adjacency_list(nn: int, eds: List[Tuple[int,int]]):\n        adj = [[] for _ in range(nn)]\n        for (u, v) in eds:\n            u0 = u - 1; v0 = v - 1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        return adj\n\n    def _kempe_component(sol: List[int], start: int, a: int, b: int, adj: List[List[int]]) -> List[int]:\n        seen = set([start])\n        stack = [start]\n        comp = []\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            if sol[u] not in target:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if v not in seen and sol[v] in target:\n                    seen.add(v)\n                    stack.append(v)\n        return comp\n\n    # If invalid, seed using a small random palette, then normalize\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 4) for _ in range(n)]\n        return _canonical_normalize(base)\n\n    s = [int(c) if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _canonical_normalize(s)\n    k = max(s) if s else 1\n    adj = _adjacency_list(n, edges)\n\n    # Chain 3-5 Kempe interchanges\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        seed = random.randrange(n)\n        a = s[seed]\n        # choose b from neighbor colors if available, else from current palette\n        neigh_colors = {s[v] for v in adj[seed]}\n        if neigh_colors:\n            b_candidates = list(neigh_colors - {a}) or list(neigh_colors)\n        else:\n            b_candidates = list(set(s))\n        b = random.choice(b_candidates)\n        comp = _kempe_component(s, seed, a, b, adj)\n        for u in comp:\n            s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        k = max(s)\n\n    # Global class swap to reshuffle palette\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        s = [b if c == a else (a if c == b else c) for c in s]\n\n    # Sparse random recolors with slight palette expansion\n    cap = min(n, max(3, k + 1))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    m = max(3, n \/\/ 3)\n    for i in idxs[:m]:\n        cur = s[i]\n        choices = [c for c in range(1, cap + 1) if c != cur]\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = _canonical_normalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.0016634529}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of groups used.\n    # Infeasible or invalid => large penalty + conflict count + k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**6 + conflicts * 1000 + k\n    return k\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor operator with labeled return. Returns (NB_Type, Movement_Type)\n    # If input invalid, attempt to repair by random initialization.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n        solution.clear(); solution.extend(sol)\n        return (\"NB_Init\", \"RandomSeed\")\n    # Ensure valid domain\n    for i in range(n):\n        if not isinstance(solution[i], int) or solution[i] < 1:\n            solution[i] = (i % 3) + 1\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts.append((u-1, v-1))\n    palette = set(solution)\n    max_color = max(palette) if palette else 1\n    # Try recolor a conflicted vertex greedily\n    if conflicts:\n        u,v = random.choice(conflicts)\n        x = random.choice([u,v])\n        # Evaluate conflict count per color\n        best_c = solution[x]\n        best_cost = 1e9\n        for c in range(1, max_color + 1):\n            cost = 0\n            for nbr in adj[x]:\n                if c == solution[nbr]:\n                    cost += 1\n            # prefer lowering color count if ties\n            k_after = len(palette | {c})\n            score = cost * 100 + k_after\n            if score < best_cost:\n                best_cost = score\n                best_c = c\n        # Also allow trying a new color if everything conflicts badly\n        if best_cost >= 100:\n            best_c = max_color + 1\n        solution[x] = best_c\n        return (\"NB_Local\", \"RecolorGreedy\")\n    # No conflicts: try reduce number of colors by reassigning a vertex from a rare color\n    color_counts = {}\n    for idx,c in enumerate(solution):\n        color_counts[c] = color_counts.get(c, 0) + 1\n    # Target a color class with smallest cardinality\n    target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n    candidates = [i for i,c in enumerate(solution) if c == target_color]\n    x = random.choice(candidates)\n    # Try assign x to a different existing color without introducing conflicts\n    available = [c for c in color_counts.keys() if c != target_color]\n    random.shuffle(available)\n    moved = False\n    for c in available:\n        ok = True\n        for nbr in adj[x]:\n            if solution[nbr] == c:\n                ok = False; break\n        if ok:\n            solution[x] = c\n            moved = True\n            break\n    if moved:\n        return (\"NB_Reduction\", \"ClassMergeMove\")\n    # As fallback, swap color labels of two random colors (label-swap can escape symmetry traps)\n    if len(color_counts) >= 2:\n        c1, c2 = random.sample(list(color_counts.keys()), 2)\n        for i in range(n):\n            if solution[i] == c1:\n                solution[i] = -1\n            elif solution[i] == c2:\n                solution[i] = c1\n        for i in range(n):\n            if solution[i] == -1:\n                solution[i] = c2\n        return (\"NB_Symmetry\", \"ColorLabelSwap\")\n    # If all else fails, random recolor a vertex within palette\n    i = random.randrange(n)\n    solution[i] = random.choice(list(palette))\n    return (\"NB_Local\", \"RandomRecolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    # Basic sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 4) + 1) for i in range(n)]\n        return sol\n    sol = [int(c) if isinstance(c,int) and c>0 else 1 for c in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Strong perturbation: shuffle color labels, then random-recolor a few vertices to feasible colors if possible\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    pert = [mapping[c] for c in sol]\n    # Random recolors on m vertices\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    # restrict candidate colors to current palette plus possibly one new color\n    cand_palette = sorted(set(pert))\n    for x in idxs:\n        # Try pick a color minimizing conflicts locally\n        best_c = random.choice(cand_palette)\n        best_conf = 1e9\n        for c in cand_palette + [max(cand_palette)+1]:\n            conf = 0\n            for nbr in adj[x]:\n                if pert[nbr] == c:\n                    conf += 1\n            score = conf * 100 + (len(set(pert)) + (1 if c == max(cand_palette)+1 else 0))\n            if score < best_conf:\n                best_conf = score\n                best_c = c\n        pert[x] = best_c\n    return pert\n","Resultados":"Failed to run target heuristic: 'str' object has no attribute 'clear'.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000988763}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of groups used.\n    # Infeasible or invalid => large penalty + conflict count + k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**6 + conflicts * 1000 + k\n    return k\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor operator with labeled return. Returns (NB_Type, Movement_Type)\n    # If input invalid, attempt to repair by random initialization.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n        solution.clear(); solution.extend(sol)\n        return (\"NB_Init\", \"RandomSeed\")\n    # Ensure valid domain\n    for i in range(n):\n        if not isinstance(solution[i], int) or solution[i] < 1:\n            solution[i] = (i % 3) + 1\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts.append((u-1, v-1))\n    palette = set(solution)\n    max_color = max(palette) if palette else 1\n    # Try recolor a conflicted vertex greedily\n    if conflicts:\n        u,v = random.choice(conflicts)\n        x = random.choice([u,v])\n        # Evaluate conflict count per color\n        best_c = solution[x]\n        best_cost = 1e9\n        for c in range(1, max_color + 1):\n            cost = 0\n            for nbr in adj[x]:\n                if c == solution[nbr]:\n                    cost += 1\n            # prefer lowering color count if ties\n            k_after = len(palette | {c})\n            score = cost * 100 + k_after\n            if score < best_cost:\n                best_cost = score\n                best_c = c\n        # Also allow trying a new color if everything conflicts badly\n        if best_cost >= 100:\n            best_c = max_color + 1\n        solution[x] = best_c\n        return (\"NB_Local\", \"RecolorGreedy\")\n    # No conflicts: try reduce number of colors by reassigning a vertex from a rare color\n    color_counts = {}\n    for idx,c in enumerate(solution):\n        color_counts[c] = color_counts.get(c, 0) + 1\n    # Target a color class with smallest cardinality\n    target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n    candidates = [i for i,c in enumerate(solution) if c == target_color]\n    x = random.choice(candidates)\n    # Try assign x to a different existing color without introducing conflicts\n    available = [c for c in color_counts.keys() if c != target_color]\n    random.shuffle(available)\n    moved = False\n    for c in available:\n        ok = True\n        for nbr in adj[x]:\n            if solution[nbr] == c:\n                ok = False; break\n        if ok:\n            solution[x] = c\n            moved = True\n            break\n    if moved:\n        return (\"NB_Reduction\", \"ClassMergeMove\")\n    # As fallback, swap color labels of two random colors (label-swap can escape symmetry traps)\n    if len(color_counts) >= 2:\n        c1, c2 = random.sample(list(color_counts.keys()), 2)\n        for i in range(n):\n            if solution[i] == c1:\n                solution[i] = -1\n            elif solution[i] == c2:\n                solution[i] = c1\n        for i in range(n):\n            if solution[i] == -1:\n                solution[i] = c2\n        return (\"NB_Symmetry\", \"ColorLabelSwap\")\n    # If all else fails, random recolor a vertex within palette\n    i = random.randrange(n)\n    solution[i] = random.choice(list(palette))\n    return (\"NB_Local\", \"RandomRecolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    # Basic sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 4) + 1) for i in range(n)]\n        return sol\n    sol = [int(c) if isinstance(c,int) and c>0 else 1 for c in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Strong perturbation: shuffle color labels, then random-recolor a few vertices to feasible colors if possible\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    pert = [mapping[c] for c in sol]\n    # Random recolors on m vertices\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    # restrict candidate colors to current palette plus possibly one new color\n    cand_palette = sorted(set(pert))\n    for x in idxs:\n        # Try pick a color minimizing conflicts locally\n        best_c = random.choice(cand_palette)\n        best_conf = 1e9\n        for c in cand_palette + [max(cand_palette)+1]:\n            conf = 0\n            for nbr in adj[x]:\n                if pert[nbr] == c:\n                    conf += 1\n            score = conf * 100 + (len(set(pert)) + (1 if c == max(cand_palette)+1 else 0))\n            if score < best_conf:\n                best_conf = score\n                best_c = c\n        pert[x] = best_c\n    return pert\n","Resultados":"Failed to run target heuristic: 'str' object has no attribute 'clear'.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001172676}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of groups used.\n    # Infeasible or invalid => large penalty + conflict count + k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**6 + conflicts * 1000 + k\n    return k\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor operator with labeled return. Returns (NB_Type, Movement_Type)\n    # If input invalid, attempt to repair by random initialization.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n        solution.clear(); solution.extend(sol)\n        return (\"NB_Init\", \"RandomSeed\")\n    # Ensure valid domain\n    for i in range(n):\n        if not isinstance(solution[i], int) or solution[i] < 1:\n            solution[i] = (i % 3) + 1\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts.append((u-1, v-1))\n    palette = set(solution)\n    max_color = max(palette) if palette else 1\n    # Try recolor a conflicted vertex greedily\n    if conflicts:\n        u,v = random.choice(conflicts)\n        x = random.choice([u,v])\n        # Evaluate conflict count per color\n        best_c = solution[x]\n        best_cost = 1e9\n        for c in range(1, max_color + 1):\n            cost = 0\n            for nbr in adj[x]:\n                if c == solution[nbr]:\n                    cost += 1\n            # prefer lowering color count if ties\n            k_after = len(palette | {c})\n            score = cost * 100 + k_after\n            if score < best_cost:\n                best_cost = score\n                best_c = c\n        # Also allow trying a new color if everything conflicts badly\n        if best_cost >= 100:\n            best_c = max_color + 1\n        solution[x] = best_c\n        return (\"NB_Local\", \"RecolorGreedy\")\n    # No conflicts: try reduce number of colors by reassigning a vertex from a rare color\n    color_counts = {}\n    for idx,c in enumerate(solution):\n        color_counts[c] = color_counts.get(c, 0) + 1\n    # Target a color class with smallest cardinality\n    target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n    candidates = [i for i,c in enumerate(solution) if c == target_color]\n    x = random.choice(candidates)\n    # Try assign x to a different existing color without introducing conflicts\n    available = [c for c in color_counts.keys() if c != target_color]\n    random.shuffle(available)\n    moved = False\n    for c in available:\n        ok = True\n        for nbr in adj[x]:\n            if solution[nbr] == c:\n                ok = False; break\n        if ok:\n            solution[x] = c\n            moved = True\n            break\n    if moved:\n        return (\"NB_Reduction\", \"ClassMergeMove\")\n    # As fallback, swap color labels of two random colors (label-swap can escape symmetry traps)\n    if len(color_counts) >= 2:\n        c1, c2 = random.sample(list(color_counts.keys()), 2)\n        for i in range(n):\n            if solution[i] == c1:\n                solution[i] = -1\n            elif solution[i] == c2:\n                solution[i] = c1\n        for i in range(n):\n            if solution[i] == -1:\n                solution[i] = c2\n        return (\"NB_Symmetry\", \"ColorLabelSwap\")\n    # If all else fails, random recolor a vertex within palette\n    i = random.randrange(n)\n    solution[i] = random.choice(list(palette))\n    return (\"NB_Local\", \"RandomRecolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    # Basic sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 4) + 1) for i in range(n)]\n        return sol\n    sol = [int(c) if isinstance(c,int) and c>0 else 1 for c in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Strong perturbation: shuffle color labels, then random-recolor a few vertices to feasible colors if possible\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    pert = [mapping[c] for c in sol]\n    # Random recolors on m vertices\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    # restrict candidate colors to current palette plus possibly one new color\n    cand_palette = sorted(set(pert))\n    for x in idxs:\n        # Try pick a color minimizing conflicts locally\n        best_c = random.choice(cand_palette)\n        best_conf = 1e9\n        for c in cand_palette + [max(cand_palette)+1]:\n            conf = 0\n            for nbr in adj[x]:\n                if pert[nbr] == c:\n                    conf += 1\n            score = conf * 100 + (len(set(pert)) + (1 if c == max(cand_palette)+1 else 0))\n            if score < best_conf:\n                best_conf = score\n                best_c = c\n        pert[x] = best_c\n    return pert\n","Resultados":"Failed to run target heuristic: 'str' object has no attribute 'clear'.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001118114}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible or invalid => very large penalty + strong weighting on conflicts + small k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**9 + conflicts * 10**6 + k\n    return k\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Always returns a fresh list (no in-place mutation of the input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to 1..k in order of first appearance to reduce symmetry\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol: List[int]):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        # Swap colors c1<->c2 in the connected component of v induced by colors {c1,c2}\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        target = sol[v]\n        other = c2 if target == c1 else c1\n        q = deque([v])\n        seen = set([v])\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c1 if sol[x] == c2 else (c2 if sol[x] == c1 else sol[x])\n        return new_sol\n\n    # Prepare a base solution (repair if invalid)\n    if not is_valid_input(solution):\n        base = [((i % 3) + 1) for i in range(n)]\n        base = normalize_colors(base)\n        return base, \"NB_Init\", \"RandomSeed\"\n\n    base = normalize_colors([int(c) for c in solution])\n    adj = build_adj()\n\n    conf = conflict_edges(base)\n    palette = sorted(set(base))\n\n    # Strategy selection probabilities\n    r = random.random()\n\n    # Case 1: If conflicts exist, try to fix locally (greedy recolor), else Kempe swap\n    if conf:\n        # Pick a conflicted vertex\n        u, v = random.choice(conf)\n        x = random.choice([u, v])\n        # Try recoloring x to an existing color minimizing new conflicts; avoid introducing new colors\n        best_c = base[x]\n        best_score = 10**9\n        colors = palette  # only existing colors\n        for c in colors:\n            if c == base[x]:\n                # evaluate staying as-is too (baseline)\n                pass\n            # count conflicts if x becomes color c\n            cost = 0\n            for nb in adj[x]:\n                if base[nb] == c:\n                    cost += 1\n            # secondary: prefer smaller palette after recolor (ties broken by label)\n            k_after = len(set(base))  # unchanged since c in palette\n            score = cost * 1000 + k_after * 10 + c\n            if score < best_score:\n                best_score = score\n                best_c = c\n        new_sol = base[:]\n        new_sol[x] = best_c\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"GreedyRecolor\"\n    else:\n        # No conflicts: attempt to reduce number of colors via merge or Kempe swap\n        color_counts = {}\n        for c in base:\n            color_counts[c] = color_counts.get(c, 0) + 1\n        if len(color_counts) >= 2 and r < 0.6:\n            # Choose a smallest color class and try to move a vertex into another color legally\n            target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            candidates = [i for i, c in enumerate(base) if c == target_color]\n            x = random.choice(candidates)\n            other_colors = [c for c in color_counts.keys() if c != target_color]\n            random.shuffle(other_colors)\n            for c in other_colors:\n                ok = True\n                for nb in adj[x]:\n                    if base[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = base[:]\n                    new_sol[x] = c\n                    new_sol = normalize_colors(new_sol)\n                    return new_sol, \"NB_Reduction\", \"ClassMergeMove\"\n            # If not successful, fall through to Kempe swap\n        # Kempe chain swap between two random colors\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # pick a random vertex with color c1 or c2\n            idxs = [i for i, col in enumerate(base) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                new_sol = kempe_swap(base, v, c1, c2, adj)\n                new_sol = normalize_colors(new_sol)\n                return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # As symmetry escape: swap two color labels globally\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            mapc = {c1: c2, c2: c1}\n            new_sol = [(mapc.get(col, col)) for col in base]\n            new_sol = normalize_colors(new_sol)\n            return new_sol, \"NB_Symmetry\", \"ColorLabelSwap\"\n        # Fallback: random recolor within palette\n        i = random.randrange(n)\n        new_sol = base[:]\n        new_sol[i] = random.choice(palette)\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"RandomRecolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = set([v])\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c1 if sol[x] == c2 else (c2 if sol[x] == c1 else sol[x])\n        return new_sol\n\n    if not is_valid_input(solution):\n        base = [((i % 4) + 1) for i in range(n)]\n        return normalize_colors(base)\n\n    base = normalize_colors([int(c) if isinstance(c, int) and c > 0 else 1 for c in solution])\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Global color relabel shuffle\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    sol = [mapping[c] for c in sol]\n\n    # 2) Apply a few Kempe swaps on random vertices and color pairs\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(sol) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Conflict-driven random recolors on a few vertices\n    # Build conflict list\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        conflicts = list(set(conflicts))\n        picks = random.sample(conflicts, min(len(conflicts), random.randint(2, 4)))\n        palette = sorted(set(sol))\n        for x in picks:\n            # Try a color minimizing local conflicts; allow adding one new color only if all existing colors clash\n            best_c = sol[x]\n            best_cost = 10**9\n            all_clash = True\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost == 0:\n                    all_clash = False\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if all_clash:\n                best_c = max(palette) + 1\n            sol[x] = best_c\n\n    return normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001339128}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible or invalid => very large penalty + strong weighting on conflicts + small k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**9 + conflicts * 10**6 + k\n    return k\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Always returns a fresh list (no in-place mutation of the input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to 1..k in order of first appearance to reduce symmetry\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol: List[int]):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        # Swap colors c1<->c2 in the connected component of v induced by colors {c1,c2}\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        target = sol[v]\n        other = c2 if target == c1 else c1\n        q = deque([v])\n        seen = set([v])\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c1 if sol[x] == c2 else (c2 if sol[x] == c1 else sol[x])\n        return new_sol\n\n    # Prepare a base solution (repair if invalid)\n    if not is_valid_input(solution):\n        base = [((i % 3) + 1) for i in range(n)]\n        base = normalize_colors(base)\n        return base, \"NB_Init\", \"RandomSeed\"\n\n    base = normalize_colors([int(c) for c in solution])\n    adj = build_adj()\n\n    conf = conflict_edges(base)\n    palette = sorted(set(base))\n\n    # Strategy selection probabilities\n    r = random.random()\n\n    # Case 1: If conflicts exist, try to fix locally (greedy recolor), else Kempe swap\n    if conf:\n        # Pick a conflicted vertex\n        u, v = random.choice(conf)\n        x = random.choice([u, v])\n        # Try recoloring x to an existing color minimizing new conflicts; avoid introducing new colors\n        best_c = base[x]\n        best_score = 10**9\n        colors = palette  # only existing colors\n        for c in colors:\n            if c == base[x]:\n                # evaluate staying as-is too (baseline)\n                pass\n            # count conflicts if x becomes color c\n            cost = 0\n            for nb in adj[x]:\n                if base[nb] == c:\n                    cost += 1\n            # secondary: prefer smaller palette after recolor (ties broken by label)\n            k_after = len(set(base))  # unchanged since c in palette\n            score = cost * 1000 + k_after * 10 + c\n            if score < best_score:\n                best_score = score\n                best_c = c\n        new_sol = base[:]\n        new_sol[x] = best_c\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"GreedyRecolor\"\n    else:\n        # No conflicts: attempt to reduce number of colors via merge or Kempe swap\n        color_counts = {}\n        for c in base:\n            color_counts[c] = color_counts.get(c, 0) + 1\n        if len(color_counts) >= 2 and r < 0.6:\n            # Choose a smallest color class and try to move a vertex into another color legally\n            target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            candidates = [i for i, c in enumerate(base) if c == target_color]\n            x = random.choice(candidates)\n            other_colors = [c for c in color_counts.keys() if c != target_color]\n            random.shuffle(other_colors)\n            for c in other_colors:\n                ok = True\n                for nb in adj[x]:\n                    if base[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = base[:]\n                    new_sol[x] = c\n                    new_sol = normalize_colors(new_sol)\n                    return new_sol, \"NB_Reduction\", \"ClassMergeMove\"\n            # If not successful, fall through to Kempe swap\n        # Kempe chain swap between two random colors\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # pick a random vertex with color c1 or c2\n            idxs = [i for i, col in enumerate(base) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                new_sol = kempe_swap(base, v, c1, c2, adj)\n                new_sol = normalize_colors(new_sol)\n                return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # As symmetry escape: swap two color labels globally\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            mapc = {c1: c2, c2: c1}\n            new_sol = [(mapc.get(col, col)) for col in base]\n            new_sol = normalize_colors(new_sol)\n            return new_sol, \"NB_Symmetry\", \"ColorLabelSwap\"\n        # Fallback: random recolor within palette\n        i = random.randrange(n)\n        new_sol = base[:]\n        new_sol[i] = random.choice(palette)\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"RandomRecolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = set([v])\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c1 if sol[x] == c2 else (c2 if sol[x] == c1 else sol[x])\n        return new_sol\n\n    if not is_valid_input(solution):\n        base = [((i % 4) + 1) for i in range(n)]\n        return normalize_colors(base)\n\n    base = normalize_colors([int(c) if isinstance(c, int) and c > 0 else 1 for c in solution])\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Global color relabel shuffle\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    sol = [mapping[c] for c in sol]\n\n    # 2) Apply a few Kempe swaps on random vertices and color pairs\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(sol) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Conflict-driven random recolors on a few vertices\n    # Build conflict list\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        conflicts = list(set(conflicts))\n        picks = random.sample(conflicts, min(len(conflicts), random.randint(2, 4)))\n        palette = sorted(set(sol))\n        for x in picks:\n            # Try a color minimizing local conflicts; allow adding one new color only if all existing colors clash\n            best_c = sol[x]\n            best_cost = 10**9\n            all_clash = True\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost == 0:\n                    all_clash = False\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if all_clash:\n                best_c = max(palette) + 1\n            sol[x] = best_c\n\n    return normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002406851}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible or invalid => very large penalty + strong weighting on conflicts + small k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**9 + conflicts * 10**6 + k\n    return k\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Always returns a fresh list (no in-place mutation of the input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to 1..k in order of first appearance to reduce symmetry\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol: List[int]):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        # Swap colors c1<->c2 in the connected component of v induced by colors {c1,c2}\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        target = sol[v]\n        other = c2 if target == c1 else c1\n        q = deque([v])\n        seen = set([v])\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c1 if sol[x] == c2 else (c2 if sol[x] == c1 else sol[x])\n        return new_sol\n\n    # Prepare a base solution (repair if invalid)\n    if not is_valid_input(solution):\n        base = [((i % 3) + 1) for i in range(n)]\n        base = normalize_colors(base)\n        return base, \"NB_Init\", \"RandomSeed\"\n\n    base = normalize_colors([int(c) for c in solution])\n    adj = build_adj()\n\n    conf = conflict_edges(base)\n    palette = sorted(set(base))\n\n    # Strategy selection probabilities\n    r = random.random()\n\n    # Case 1: If conflicts exist, try to fix locally (greedy recolor), else Kempe swap\n    if conf:\n        # Pick a conflicted vertex\n        u, v = random.choice(conf)\n        x = random.choice([u, v])\n        # Try recoloring x to an existing color minimizing new conflicts; avoid introducing new colors\n        best_c = base[x]\n        best_score = 10**9\n        colors = palette  # only existing colors\n        for c in colors:\n            if c == base[x]:\n                # evaluate staying as-is too (baseline)\n                pass\n            # count conflicts if x becomes color c\n            cost = 0\n            for nb in adj[x]:\n                if base[nb] == c:\n                    cost += 1\n            # secondary: prefer smaller palette after recolor (ties broken by label)\n            k_after = len(set(base))  # unchanged since c in palette\n            score = cost * 1000 + k_after * 10 + c\n            if score < best_score:\n                best_score = score\n                best_c = c\n        new_sol = base[:]\n        new_sol[x] = best_c\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"GreedyRecolor\"\n    else:\n        # No conflicts: attempt to reduce number of colors via merge or Kempe swap\n        color_counts = {}\n        for c in base:\n            color_counts[c] = color_counts.get(c, 0) + 1\n        if len(color_counts) >= 2 and r < 0.6:\n            # Choose a smallest color class and try to move a vertex into another color legally\n            target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            candidates = [i for i, c in enumerate(base) if c == target_color]\n            x = random.choice(candidates)\n            other_colors = [c for c in color_counts.keys() if c != target_color]\n            random.shuffle(other_colors)\n            for c in other_colors:\n                ok = True\n                for nb in adj[x]:\n                    if base[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = base[:]\n                    new_sol[x] = c\n                    new_sol = normalize_colors(new_sol)\n                    return new_sol, \"NB_Reduction\", \"ClassMergeMove\"\n            # If not successful, fall through to Kempe swap\n        # Kempe chain swap between two random colors\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # pick a random vertex with color c1 or c2\n            idxs = [i for i, col in enumerate(base) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                new_sol = kempe_swap(base, v, c1, c2, adj)\n                new_sol = normalize_colors(new_sol)\n                return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # As symmetry escape: swap two color labels globally\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            mapc = {c1: c2, c2: c1}\n            new_sol = [(mapc.get(col, col)) for col in base]\n            new_sol = normalize_colors(new_sol)\n            return new_sol, \"NB_Symmetry\", \"ColorLabelSwap\"\n        # Fallback: random recolor within palette\n        i = random.randrange(n)\n        new_sol = base[:]\n        new_sol[i] = random.choice(palette)\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"RandomRecolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = set([v])\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c1 if sol[x] == c2 else (c2 if sol[x] == c1 else sol[x])\n        return new_sol\n\n    if not is_valid_input(solution):\n        base = [((i % 4) + 1) for i in range(n)]\n        return normalize_colors(base)\n\n    base = normalize_colors([int(c) if isinstance(c, int) and c > 0 else 1 for c in solution])\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Global color relabel shuffle\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    sol = [mapping[c] for c in sol]\n\n    # 2) Apply a few Kempe swaps on random vertices and color pairs\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(sol) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Conflict-driven random recolors on a few vertices\n    # Build conflict list\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        conflicts = list(set(conflicts))\n        picks = random.sample(conflicts, min(len(conflicts), random.randint(2, 4)))\n        palette = sorted(set(sol))\n        for x in picks:\n            # Try a color minimizing local conflicts; allow adding one new color only if all existing colors clash\n            best_c = sol[x]\n            best_cost = 10**9\n            all_clash = True\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost == 0:\n                    all_clash = False\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if all_clash:\n                best_c = max(palette) + 1\n            sol[x] = best_c\n\n    return normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001798864}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Dict, Any\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible or invalid => very large penalty + strong weighting on conflicts + small k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**9 + conflicts * 10**6 + k\n    return k\n\n# Optional SA and wrapper (do not access FS\/OS\/Network)\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    rng = random.Random()\n    curr = list(currentSolution) if isinstance(currentSolution, list) else []\n    if not curr or len(curr) != 9:\n        curr = [((i % 4) + 1) for i in range(9)]\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best = curr[:]\n        best_score = curr_score\n    iters = 0\n    accepts = 0\n    last_improv = 0\n    while temp > minTemp and iters < 10000:\n        iters += 1\n        nb, nb_type, mv = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if nb_score <= curr_score or rng.random() < math.exp(-max(0, delta)\/max(1e-9, temp)):\n            curr = nb\n            curr_score = nb_score\n            accepts += 1\n        if curr_score < best_score:\n            best = curr[:]\n            best_score = curr_score\n            last_improv = iters\n        temp *= cooling_factor\n    return best, {\"best_score\": best_score, \"iters\": iters, \"accepts\": accepts, \"last_improvement_iter\": last_improv, \"method\": \"SA\"}\n\n\ndef Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params=None):\n    # Simple dispatcher calling SA with defaults\n    params = other_params or {}\n    temp = params.get(\"temp\", 1.0)\n    minTemp = params.get(\"minTemp\", 1e-3)\n    cooling = params.get(\"cooling_factor\", 0.995)\n    return SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling)\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol: List[int]):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            if sol[x] == c1:\n                new_sol[x] = c2\n            elif sol[x] == c2:\n                new_sol[x] = c1\n        return new_sol\n\n    if not is_valid_input(solution):\n        # Constructive seed: simple cyclic 4-coloring\n        base = [((i % 4) + 1) for i in range(n)]\n        base = normalize_colors(base)\n        return base, \"NB_Init\", \"Seed4Color\"\n\n    base = normalize_colors([int(c) for c in solution])\n    adj = build_adj()\n\n    conf = conflict_edges(base)\n    palette = sorted(set(base))\n\n    r = random.random()\n\n    if conf:\n        # Pick a conflicted vertex\n        u, v = random.choice(conf)\n        x = random.choice([u, v])\n        best_c = base[x]\n        best_cost = 10**9\n        colors = palette + [max(palette) + 1]  # allow new color if needed\n        for c in colors:\n            cost = 0\n            for nb in adj[x]:\n                if base[nb] == c:\n                    cost += 1\n            score = cost * 1000 + (len(palette) + (1 if c == max(palette) + 1 else 0))\n            if score < best_cost:\n                best_cost = score\n                best_c = c\n        new_sol = base[:]\n        new_sol[x] = best_c\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"GreedyRecolorExt\"\n    else:\n        color_counts = {}\n        for c in base:\n            color_counts[c] = color_counts.get(c, 0) + 1\n        if len(color_counts) >= 2 and r < 0.6:\n            # Attempt class reduction: try moving all vertices of smallest class\n            target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            candidates = [i for i, c in enumerate(base) if c == target_color]\n            order = sorted(candidates, key=lambda i: len(adj[i]), reverse=True)  # higher degree first\n            new_sol = base[:]\n            success_moves = 0\n            for x in order:\n                other_colors = [c for c in color_counts.keys() if c != target_color]\n                random.shuffle(other_colors)\n                moved = False\n                for c in other_colors:\n                    ok = True\n                    for nb in adj[x]:\n                        if new_sol[nb] == c:\n                            ok = False\n                            break\n                    if ok:\n                        new_sol[x] = c\n                        success_moves += 1\n                        moved = True\n                        break\n                if not moved:\n                    # leave as is; reduction may fail partially\n                    pass\n            new_sol = normalize_colors(new_sol)\n            if len(set(new_sol)) <= len(set(base)):\n                return new_sol, \"NB_Reduction\", \"ClassMergeAttempt\"\n        # Kempe swap\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(base) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                new_sol = kempe_swap(base, v, c1, c2, adj)\n                new_sol = normalize_colors(new_sol)\n                return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # Fallback recolor within palette\n        i = random.randrange(n)\n        new_sol = base[:]\n        new_sol[i] = random.choice(palette)\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"RandomRecolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            if sol[x] == c1:\n                new_sol[x] = c2\n            elif sol[x] == c2:\n                new_sol[x] = c1\n        return new_sol\n\n    if not is_valid_input(solution):\n        base = [((i % 4) + 1) for i in range(n)]\n        return normalize_colors(base)\n\n    base = normalize_colors([int(c) if isinstance(c, int) and c > 0 else 1 for c in solution])\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Global color relabel shuffle\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    sol = [mapping[c] for c in sol]\n\n    # 2) Apply a few Kempe swaps on random vertices and color pairs\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(sol) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Conflict-driven recolors on a few vertices\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        conflicts = list(set(conflicts))\n        picks = random.sample(conflicts, min(len(conflicts), random.randint(2, 4)))\n        palette = sorted(set(sol))\n        for x in picks:\n            best_c = sol[x]\n            best_cost = 10**9\n            all_clash = True\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost == 0:\n                    all_clash = False\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if all_clash:\n                best_c = max(palette) + 1\n            sol[x] = best_c\n\n    return normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00150093}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Dict, Any\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible or invalid => very large penalty + strong weighting on conflicts + small k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**9 + conflicts * 10**6 + k\n    return k\n\n# Optional SA and wrapper (do not access FS\/OS\/Network)\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    rng = random.Random()\n    curr = list(currentSolution) if isinstance(currentSolution, list) else []\n    if not curr or len(curr) != 9:\n        curr = [((i % 4) + 1) for i in range(9)]\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best = curr[:]\n        best_score = curr_score\n    iters = 0\n    accepts = 0\n    last_improv = 0\n    while temp > minTemp and iters < 10000:\n        iters += 1\n        nb, nb_type, mv = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if nb_score <= curr_score or rng.random() < math.exp(-max(0, delta)\/max(1e-9, temp)):\n            curr = nb\n            curr_score = nb_score\n            accepts += 1\n        if curr_score < best_score:\n            best = curr[:]\n            best_score = curr_score\n            last_improv = iters\n        temp *= cooling_factor\n    return best, {\"best_score\": best_score, \"iters\": iters, \"accepts\": accepts, \"last_improvement_iter\": last_improv, \"method\": \"SA\"}\n\n\ndef Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params=None):\n    # Simple dispatcher calling SA with defaults\n    params = other_params or {}\n    temp = params.get(\"temp\", 1.0)\n    minTemp = params.get(\"minTemp\", 1e-3)\n    cooling = params.get(\"cooling_factor\", 0.995)\n    return SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling)\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol: List[int]):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            if sol[x] == c1:\n                new_sol[x] = c2\n            elif sol[x] == c2:\n                new_sol[x] = c1\n        return new_sol\n\n    if not is_valid_input(solution):\n        # Constructive seed: simple cyclic 4-coloring\n        base = [((i % 4) + 1) for i in range(n)]\n        base = normalize_colors(base)\n        return base, \"NB_Init\", \"Seed4Color\"\n\n    base = normalize_colors([int(c) for c in solution])\n    adj = build_adj()\n\n    conf = conflict_edges(base)\n    palette = sorted(set(base))\n\n    r = random.random()\n\n    if conf:\n        # Pick a conflicted vertex\n        u, v = random.choice(conf)\n        x = random.choice([u, v])\n        best_c = base[x]\n        best_cost = 10**9\n        colors = palette + [max(palette) + 1]  # allow new color if needed\n        for c in colors:\n            cost = 0\n            for nb in adj[x]:\n                if base[nb] == c:\n                    cost += 1\n            score = cost * 1000 + (len(palette) + (1 if c == max(palette) + 1 else 0))\n            if score < best_cost:\n                best_cost = score\n                best_c = c\n        new_sol = base[:]\n        new_sol[x] = best_c\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"GreedyRecolorExt\"\n    else:\n        color_counts = {}\n        for c in base:\n            color_counts[c] = color_counts.get(c, 0) + 1\n        if len(color_counts) >= 2 and r < 0.6:\n            # Attempt class reduction: try moving all vertices of smallest class\n            target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            candidates = [i for i, c in enumerate(base) if c == target_color]\n            order = sorted(candidates, key=lambda i: len(adj[i]), reverse=True)  # higher degree first\n            new_sol = base[:]\n            success_moves = 0\n            for x in order:\n                other_colors = [c for c in color_counts.keys() if c != target_color]\n                random.shuffle(other_colors)\n                moved = False\n                for c in other_colors:\n                    ok = True\n                    for nb in adj[x]:\n                        if new_sol[nb] == c:\n                            ok = False\n                            break\n                    if ok:\n                        new_sol[x] = c\n                        success_moves += 1\n                        moved = True\n                        break\n                if not moved:\n                    # leave as is; reduction may fail partially\n                    pass\n            new_sol = normalize_colors(new_sol)\n            if len(set(new_sol)) <= len(set(base)):\n                return new_sol, \"NB_Reduction\", \"ClassMergeAttempt\"\n        # Kempe swap\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(base) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                new_sol = kempe_swap(base, v, c1, c2, adj)\n                new_sol = normalize_colors(new_sol)\n                return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # Fallback recolor within palette\n        i = random.randrange(n)\n        new_sol = base[:]\n        new_sol[i] = random.choice(palette)\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"RandomRecolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            if sol[x] == c1:\n                new_sol[x] = c2\n            elif sol[x] == c2:\n                new_sol[x] = c1\n        return new_sol\n\n    if not is_valid_input(solution):\n        base = [((i % 4) + 1) for i in range(n)]\n        return normalize_colors(base)\n\n    base = normalize_colors([int(c) if isinstance(c, int) and c > 0 else 1 for c in solution])\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Global color relabel shuffle\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    sol = [mapping[c] for c in sol]\n\n    # 2) Apply a few Kempe swaps on random vertices and color pairs\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(sol) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Conflict-driven recolors on a few vertices\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        conflicts = list(set(conflicts))\n        picks = random.sample(conflicts, min(len(conflicts), random.randint(2, 4)))\n        palette = sorted(set(sol))\n        for x in picks:\n            best_c = sol[x]\n            best_cost = 10**9\n            all_clash = True\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost == 0:\n                    all_clash = False\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if all_clash:\n                best_c = max(palette) + 1\n            sol[x] = best_c\n\n    return normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001864755}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Dict, Any\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible or invalid => very large penalty + strong weighting on conflicts + small k tie-breaker.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts > 0:\n        return 10**9 + conflicts * 10**6 + k\n    return k\n\n# Optional SA and wrapper (do not access FS\/OS\/Network)\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    rng = random.Random()\n    curr = list(currentSolution) if isinstance(currentSolution, list) else []\n    if not curr or len(curr) != 9:\n        curr = [((i % 4) + 1) for i in range(9)]\n    curr_score = evaluate_solution(curr)\n    if best is None:\n        best = curr[:]\n        best_score = curr_score\n    iters = 0\n    accepts = 0\n    last_improv = 0\n    while temp > minTemp and iters < 10000:\n        iters += 1\n        nb, nb_type, mv = generate_neighbour(curr)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - curr_score\n        if nb_score <= curr_score or rng.random() < math.exp(-max(0, delta)\/max(1e-9, temp)):\n            curr = nb\n            curr_score = nb_score\n            accepts += 1\n        if curr_score < best_score:\n            best = curr[:]\n            best_score = curr_score\n            last_improv = iters\n        temp *= cooling_factor\n    return best, {\"best_score\": best_score, \"iters\": iters, \"accepts\": accepts, \"last_improvement_iter\": last_improv, \"method\": \"SA\"}\n\n\ndef Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params=None):\n    # Simple dispatcher calling SA with defaults\n    params = other_params or {}\n    temp = params.get(\"temp\", 1.0)\n    minTemp = params.get(\"minTemp\", 1e-3)\n    cooling = params.get(\"cooling_factor\", 0.995)\n    return SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling)\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol: List[int]):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            if sol[x] == c1:\n                new_sol[x] = c2\n            elif sol[x] == c2:\n                new_sol[x] = c1\n        return new_sol\n\n    if not is_valid_input(solution):\n        # Constructive seed: simple cyclic 4-coloring\n        base = [((i % 4) + 1) for i in range(n)]\n        base = normalize_colors(base)\n        return base, \"NB_Init\", \"Seed4Color\"\n\n    base = normalize_colors([int(c) for c in solution])\n    adj = build_adj()\n\n    conf = conflict_edges(base)\n    palette = sorted(set(base))\n\n    r = random.random()\n\n    if conf:\n        # Pick a conflicted vertex\n        u, v = random.choice(conf)\n        x = random.choice([u, v])\n        best_c = base[x]\n        best_cost = 10**9\n        colors = palette + [max(palette) + 1]  # allow new color if needed\n        for c in colors:\n            cost = 0\n            for nb in adj[x]:\n                if base[nb] == c:\n                    cost += 1\n            score = cost * 1000 + (len(palette) + (1 if c == max(palette) + 1 else 0))\n            if score < best_cost:\n                best_cost = score\n                best_c = c\n        new_sol = base[:]\n        new_sol[x] = best_c\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"GreedyRecolorExt\"\n    else:\n        color_counts = {}\n        for c in base:\n            color_counts[c] = color_counts.get(c, 0) + 1\n        if len(color_counts) >= 2 and r < 0.6:\n            # Attempt class reduction: try moving all vertices of smallest class\n            target_color = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n            candidates = [i for i, c in enumerate(base) if c == target_color]\n            order = sorted(candidates, key=lambda i: len(adj[i]), reverse=True)  # higher degree first\n            new_sol = base[:]\n            success_moves = 0\n            for x in order:\n                other_colors = [c for c in color_counts.keys() if c != target_color]\n                random.shuffle(other_colors)\n                moved = False\n                for c in other_colors:\n                    ok = True\n                    for nb in adj[x]:\n                        if new_sol[nb] == c:\n                            ok = False\n                            break\n                    if ok:\n                        new_sol[x] = c\n                        success_moves += 1\n                        moved = True\n                        break\n                if not moved:\n                    # leave as is; reduction may fail partially\n                    pass\n            new_sol = normalize_colors(new_sol)\n            if len(set(new_sol)) <= len(set(base)):\n                return new_sol, \"NB_Reduction\", \"ClassMergeAttempt\"\n        # Kempe swap\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(base) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                new_sol = kempe_swap(base, v, c1, c2, adj)\n                new_sol = normalize_colors(new_sol)\n                return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # Fallback recolor within palette\n        i = random.randrange(n)\n        new_sol = base[:]\n        new_sol[i] = random.choice(palette)\n        new_sol = normalize_colors(new_sol)\n        return new_sol, \"NB_Local\", \"RandomRecolor\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol: List[int], v: int, c1: int, c2: int, adj) -> List[int]:\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            if sol[x] == c1:\n                new_sol[x] = c2\n            elif sol[x] == c2:\n                new_sol[x] = c1\n        return new_sol\n\n    if not is_valid_input(solution):\n        base = [((i % 4) + 1) for i in range(n)]\n        return normalize_colors(base)\n\n    base = normalize_colors([int(c) if isinstance(c, int) and c > 0 else 1 for c in solution])\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Global color relabel shuffle\n    palette = sorted(set(sol))\n    perm = palette[:]\n    random.shuffle(perm)\n    mapping = {palette[i]: perm[i] for i in range(len(palette))}\n    sol = [mapping[c] for c in sol]\n\n    # 2) Apply a few Kempe swaps on random vertices and color pairs\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            idxs = [i for i, col in enumerate(sol) if col in (c1, c2)]\n            if idxs:\n                v = random.choice(idxs)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Conflict-driven recolors on a few vertices\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append(u-1)\n            conflicts.append(v-1)\n    if conflicts:\n        conflicts = list(set(conflicts))\n        picks = random.sample(conflicts, min(len(conflicts), random.randint(2, 4)))\n        palette = sorted(set(sol))\n        for x in picks:\n            best_c = sol[x]\n            best_cost = 10**9\n            all_clash = True\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost == 0:\n                    all_clash = False\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if all_clash:\n                best_c = max(palette) + 1\n            sol[x] = best_c\n\n    return normalize_colors(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001695001}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom collections import defaultdict\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible => large penalty with informative tie-breakers.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # adjacency degrees\n    deg = [0]*n\n    for u,v in edges:\n        deg[u-1]+=1; deg[v-1]+=1\n    conflicts = 0\n    conflict_vertices = set()\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    k = len(set(solution))\n    if conflicts > 0:\n        # Strongly ordered penalties\n        sum_conflict_deg = sum(deg[i] for i in conflict_vertices)\n        # Penalty tiers ensure lexicographic ordering by (conflicts, |conflict_vertices|, sum_deg, k)\n        return 10**9 + conflicts*10**6 + len(conflict_vertices)*10**3 + sum_conflict_deg*10 + k\n    return k\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def dsatur_seed():\n        # DSATUR constructive heuristic\n        adj = [[] for _ in range(n)]\n        for u,v in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        used = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # pick vertex: max saturation degree, tie by degree\n            v = max(uncolored, key=lambda x: (sat_deg[x], degrees[x], x))\n            # choose smallest feasible color\n            c = 1\n            while any(colors[nb]==c for nb in adj[v]):\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for nb in adj[v]:\n                if colors[nb]==0 and c not in used[nb]:\n                    used[nb].add(c)\n                    sat_deg[nb] = len(used[nb])\n        return colors\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol, v, c1, c2, adj):\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c2 if sol[x]==c1 else (c1 if sol[x]==c2 else sol[x])\n        return new_sol\n\n    def try_recolor_vertex(sol, x, palette, adj):\n        # Try recolor within current palette; return best color and resulting conflicts count\n        best_c = sol[x]\n        best_cost = 10**9\n        deg_conf = 0\n        for c in palette:\n            if c == sol[x]:\n                # prefer staying only if no alternative\n                pass\n            clash = False\n            cost = 0\n            for nb in adj[x]:\n                if sol[nb] == c:\n                    clash = True\n                    cost += 1\n            if not clash:\n                # zero-conflict recolor preferred\n                return c, 0\n            if cost < best_cost:\n                best_cost = cost\n                best_c = c\n                deg_conf = cost\n        return best_c, deg_conf\n\n    # Initialize solution\n    if not is_valid_input(solution):\n        seed = dsatur_seed()\n        return seed, \"NB_Init\", \"DSATUR\"\n\n    base = [int(c) if isinstance(c, int) and c>0 else 1 for c in solution]\n    adj = build_adj()\n    palette = sorted(set(base))\n\n    conf = conflict_edges(base)\n    if conf:\n        # Pick conflicted vertex with higher degree first\n        # Build degree list\n        degrees = [len(adj[i]) for i in range(n)]\n        candidates = list({u for e in conf for u in e})\n        candidates.sort(key=lambda i: (-degrees[i], i))\n        x = random.choice(candidates[:max(1, min(3, len(candidates)))])\n        # Attempt recolor within palette; do not introduce new color unless no feasible recolor\n        new_sol = base[:]\n        new_c, cost = try_recolor_vertex(new_sol, x, palette, adj)\n        if cost == 0:\n            new_sol[x] = new_c\n            return new_sol, \"NB_Local\", \"ConflictGreedyRecolor\"\n        # No conflict-free recolor within palette; attempt targeted Kempe swap using most conflicting color pair\n        nb_colors = [new_sol[nb] for nb in adj[x]]\n        if nb_colors:\n            # pick the color causing most conflicts with x (same as current) and another candidate\n            freq = defaultdict(int)\n            for col in nb_colors:\n                freq[col]+=1\n            sorted_cols = sorted(freq.items(), key=lambda kv: -kv[1])\n            for c2,_ in sorted_cols:\n                if c2 != new_sol[x]:\n                    swapped = kempe_swap(new_sol, x, new_sol[x], c2, adj)\n                    if evaluate_solution(swapped) <= evaluate_solution(new_sol):\n                        return swapped, \"NB_Escape\", \"TargetedKempe\"\n        # As last resort, allow introducing new color\n        new_color = max(palette)+1\n        new_sol[x] = new_color\n        return new_sol, \"NB_Local\", \"IntroduceColor\"\n    else:\n        # Feasible: attempt k-reduction via color-class merge with limited backtracking\n        color_counts = {c: 0 for c in palette}\n        for c in base:\n            color_counts[c] += 1\n        # target smallest class to remove\n        target = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        verts = [i for i,c in enumerate(base) if c==target]\n        order = sorted(verts, key=lambda i: len(adj[i]), reverse=True)\n        new_sol = base[:]\n        avail_colors = [c for c in palette if c != target]\n\n        def backtrack(idx):\n            if idx == len(order):\n                return True\n            v = order[idx]\n            # try colors in order of least conflicts\n            tries = []\n            for c in avail_colors:\n                ok = True\n                for nb in adj[v]:\n                    if new_sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    tries.append(c)\n            # If none, try a Kempe swap assisted move\n            if not tries:\n                for c in avail_colors:\n                    tmp = kempe_swap(new_sol, v, new_sol[v], c, adj)\n                    if all(tmp[nb]!=c for nb in adj[v]):\n                        # if after swap, v can take c\n                        old = new_sol[:]\n                        new_sol[:] = tmp\n                        new_sol[v] = c\n                        if backtrack(idx+1):\n                            return True\n                        new_sol[:] = old\n                return False\n            # Try feasible colors\n            for c in tries:\n                old_c = new_sol[v]\n                new_sol[v] = c\n                if backtrack(idx+1):\n                    return True\n                new_sol[v] = old_c\n            return False\n\n        if len(avail_colors) >= 1 and order:\n            snapshot = new_sol[:]\n            if backtrack(0):\n                # removed a color class\n                # Relabel colors to compact labels while keeping stability otherwise\n                mapping = {}\n                next_label = 1\n                out = []\n                for c in new_sol:\n                    if c not in mapping:\n                        mapping[c] = next_label\n                        next_label += 1\n                    out.append(mapping[c])\n                return out, \"NB_Reduction\", \"ClassMergeBacktrack\"\n            else:\n                new_sol = snapshot\n        # If reduction fails, perform a diversification Kempe swap biased to high degree\n        degrees = [len(adj[i]) for i in range(n)]\n        pick = max(range(n), key=lambda i: (degrees[i], -color_counts.get(base[i],0), i))\n        if len(palette) >= 2:\n            # pick second color as the most frequent among neighbors\n            nb_cols = [base[nb] for nb in adj[pick]]\n            if nb_cols:\n                # choose different color with highest frequency\n                freq = defaultdict(int)\n                for col in nb_cols:\n                    if col != base[pick]:\n                        freq[col]+=1\n                if freq:\n                    c2 = max(freq.items(), key=lambda kv: kv[1])[0]\n                else:\n                    c2 = random.choice([c for c in palette if c != base[pick]])\n            else:\n                c2 = random.choice([c for c in palette if c != base[pick]])\n            new_sol = kempe_swap(base, pick, base[pick], c2, adj)\n            return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # fallback: random recolor within palette (keeps feasibility)\n        i = random.randrange(n)\n        cand = [c for c in palette if all(base[nb]!=c for nb in adj[i])]\n        if cand:\n            new_sol = base[:]\n            new_sol[i] = random.choice(cand)\n            return new_sol, \"NB_Local\", \"FeasibleRecolor\"\n        return base[:], \"NB_NoOp\", \"Stay\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, v, c1, c2, adj):\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c2 if sol[x]==c1 else (c1 if sol[x]==c2 else sol[x])\n        return new_sol\n\n    # If invalid, produce DSATUR seed\n    if not is_valid_input(solution):\n        # Simple greedy largest-degree-first as fallback seed\n        adj = build_adj()\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for v in order:\n            c = 1\n            while any(colors[nb]==c for nb in adj[v]):\n                c += 1\n            colors[v] = c\n        return colors\n\n    base = [int(c) if isinstance(c, int) and c>0 else 1 for c in solution]\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Light relabel shuffle to diversify but keep palette size\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        perm = palette[:]\n        random.shuffle(perm)\n        mapping = {palette[i]: perm[i] for i in range(len(palette))}\n        sol = [mapping[c] for c in sol]\n\n    # 2) Apply several Kempe swaps focused on high-degree vertices\n    degrees = [len(adj[i]) for i in range(n)]\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        v = max(range(n), key=lambda i: (degrees[i], random.random()))\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1 = sol[v]\n            others = [c for c in palette if c != c1]\n            if others:\n                c2 = random.choice(others)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Kick: recolor a few random vertices within palette if feasible, else with minimal conflicts\n    m_kick = random.randint(2, 4)\n    idxs = random.sample(range(n), m_kick)\n    for x in idxs:\n        palette = sorted(set(sol))\n        feas = [c for c in palette if all(sol[nb]!=c for nb in adj[x])]\n        if feas:\n            sol[x] = random.choice(feas)\n        else:\n            # choose color with least neighbor conflicts or introduce new color with small prob\n            best_c = sol[x]\n            best_cost = 10**9\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if random.random() < 0.2:\n                best_c = max(palette)+1\n            sol[x] = best_c\n\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001995336}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom collections import defaultdict\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible => large penalty with informative tie-breakers.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # adjacency degrees\n    deg = [0]*n\n    for u,v in edges:\n        deg[u-1]+=1; deg[v-1]+=1\n    conflicts = 0\n    conflict_vertices = set()\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    k = len(set(solution))\n    if conflicts > 0:\n        # Strongly ordered penalties\n        sum_conflict_deg = sum(deg[i] for i in conflict_vertices)\n        # Penalty tiers ensure lexicographic ordering by (conflicts, |conflict_vertices|, sum_deg, k)\n        return 10**9 + conflicts*10**6 + len(conflict_vertices)*10**3 + sum_conflict_deg*10 + k\n    return k\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def dsatur_seed():\n        # DSATUR constructive heuristic\n        adj = [[] for _ in range(n)]\n        for u,v in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        used = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # pick vertex: max saturation degree, tie by degree\n            v = max(uncolored, key=lambda x: (sat_deg[x], degrees[x], x))\n            # choose smallest feasible color\n            c = 1\n            while any(colors[nb]==c for nb in adj[v]):\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for nb in adj[v]:\n                if colors[nb]==0 and c not in used[nb]:\n                    used[nb].add(c)\n                    sat_deg[nb] = len(used[nb])\n        return colors\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol, v, c1, c2, adj):\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c2 if sol[x]==c1 else (c1 if sol[x]==c2 else sol[x])\n        return new_sol\n\n    def try_recolor_vertex(sol, x, palette, adj):\n        # Try recolor within current palette; return best color and resulting conflicts count\n        best_c = sol[x]\n        best_cost = 10**9\n        deg_conf = 0\n        for c in palette:\n            if c == sol[x]:\n                # prefer staying only if no alternative\n                pass\n            clash = False\n            cost = 0\n            for nb in adj[x]:\n                if sol[nb] == c:\n                    clash = True\n                    cost += 1\n            if not clash:\n                # zero-conflict recolor preferred\n                return c, 0\n            if cost < best_cost:\n                best_cost = cost\n                best_c = c\n                deg_conf = cost\n        return best_c, deg_conf\n\n    # Initialize solution\n    if not is_valid_input(solution):\n        seed = dsatur_seed()\n        return seed, \"NB_Init\", \"DSATUR\"\n\n    base = [int(c) if isinstance(c, int) and c>0 else 1 for c in solution]\n    adj = build_adj()\n    palette = sorted(set(base))\n\n    conf = conflict_edges(base)\n    if conf:\n        # Pick conflicted vertex with higher degree first\n        # Build degree list\n        degrees = [len(adj[i]) for i in range(n)]\n        candidates = list({u for e in conf for u in e})\n        candidates.sort(key=lambda i: (-degrees[i], i))\n        x = random.choice(candidates[:max(1, min(3, len(candidates)))])\n        # Attempt recolor within palette; do not introduce new color unless no feasible recolor\n        new_sol = base[:]\n        new_c, cost = try_recolor_vertex(new_sol, x, palette, adj)\n        if cost == 0:\n            new_sol[x] = new_c\n            return new_sol, \"NB_Local\", \"ConflictGreedyRecolor\"\n        # No conflict-free recolor within palette; attempt targeted Kempe swap using most conflicting color pair\n        nb_colors = [new_sol[nb] for nb in adj[x]]\n        if nb_colors:\n            # pick the color causing most conflicts with x (same as current) and another candidate\n            freq = defaultdict(int)\n            for col in nb_colors:\n                freq[col]+=1\n            sorted_cols = sorted(freq.items(), key=lambda kv: -kv[1])\n            for c2,_ in sorted_cols:\n                if c2 != new_sol[x]:\n                    swapped = kempe_swap(new_sol, x, new_sol[x], c2, adj)\n                    if evaluate_solution(swapped) <= evaluate_solution(new_sol):\n                        return swapped, \"NB_Escape\", \"TargetedKempe\"\n        # As last resort, allow introducing new color\n        new_color = max(palette)+1\n        new_sol[x] = new_color\n        return new_sol, \"NB_Local\", \"IntroduceColor\"\n    else:\n        # Feasible: attempt k-reduction via color-class merge with limited backtracking\n        color_counts = {c: 0 for c in palette}\n        for c in base:\n            color_counts[c] += 1\n        # target smallest class to remove\n        target = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        verts = [i for i,c in enumerate(base) if c==target]\n        order = sorted(verts, key=lambda i: len(adj[i]), reverse=True)\n        new_sol = base[:]\n        avail_colors = [c for c in palette if c != target]\n\n        def backtrack(idx):\n            if idx == len(order):\n                return True\n            v = order[idx]\n            # try colors in order of least conflicts\n            tries = []\n            for c in avail_colors:\n                ok = True\n                for nb in adj[v]:\n                    if new_sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    tries.append(c)\n            # If none, try a Kempe swap assisted move\n            if not tries:\n                for c in avail_colors:\n                    tmp = kempe_swap(new_sol, v, new_sol[v], c, adj)\n                    if all(tmp[nb]!=c for nb in adj[v]):\n                        # if after swap, v can take c\n                        old = new_sol[:]\n                        new_sol[:] = tmp\n                        new_sol[v] = c\n                        if backtrack(idx+1):\n                            return True\n                        new_sol[:] = old\n                return False\n            # Try feasible colors\n            for c in tries:\n                old_c = new_sol[v]\n                new_sol[v] = c\n                if backtrack(idx+1):\n                    return True\n                new_sol[v] = old_c\n            return False\n\n        if len(avail_colors) >= 1 and order:\n            snapshot = new_sol[:]\n            if backtrack(0):\n                # removed a color class\n                # Relabel colors to compact labels while keeping stability otherwise\n                mapping = {}\n                next_label = 1\n                out = []\n                for c in new_sol:\n                    if c not in mapping:\n                        mapping[c] = next_label\n                        next_label += 1\n                    out.append(mapping[c])\n                return out, \"NB_Reduction\", \"ClassMergeBacktrack\"\n            else:\n                new_sol = snapshot\n        # If reduction fails, perform a diversification Kempe swap biased to high degree\n        degrees = [len(adj[i]) for i in range(n)]\n        pick = max(range(n), key=lambda i: (degrees[i], -color_counts.get(base[i],0), i))\n        if len(palette) >= 2:\n            # pick second color as the most frequent among neighbors\n            nb_cols = [base[nb] for nb in adj[pick]]\n            if nb_cols:\n                # choose different color with highest frequency\n                freq = defaultdict(int)\n                for col in nb_cols:\n                    if col != base[pick]:\n                        freq[col]+=1\n                if freq:\n                    c2 = max(freq.items(), key=lambda kv: kv[1])[0]\n                else:\n                    c2 = random.choice([c for c in palette if c != base[pick]])\n            else:\n                c2 = random.choice([c for c in palette if c != base[pick]])\n            new_sol = kempe_swap(base, pick, base[pick], c2, adj)\n            return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # fallback: random recolor within palette (keeps feasibility)\n        i = random.randrange(n)\n        cand = [c for c in palette if all(base[nb]!=c for nb in adj[i])]\n        if cand:\n            new_sol = base[:]\n            new_sol[i] = random.choice(cand)\n            return new_sol, \"NB_Local\", \"FeasibleRecolor\"\n        return base[:], \"NB_NoOp\", \"Stay\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, v, c1, c2, adj):\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c2 if sol[x]==c1 else (c1 if sol[x]==c2 else sol[x])\n        return new_sol\n\n    # If invalid, produce DSATUR seed\n    if not is_valid_input(solution):\n        # Simple greedy largest-degree-first as fallback seed\n        adj = build_adj()\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for v in order:\n            c = 1\n            while any(colors[nb]==c for nb in adj[v]):\n                c += 1\n            colors[v] = c\n        return colors\n\n    base = [int(c) if isinstance(c, int) and c>0 else 1 for c in solution]\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Light relabel shuffle to diversify but keep palette size\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        perm = palette[:]\n        random.shuffle(perm)\n        mapping = {palette[i]: perm[i] for i in range(len(palette))}\n        sol = [mapping[c] for c in sol]\n\n    # 2) Apply several Kempe swaps focused on high-degree vertices\n    degrees = [len(adj[i]) for i in range(n)]\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        v = max(range(n), key=lambda i: (degrees[i], random.random()))\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1 = sol[v]\n            others = [c for c in palette if c != c1]\n            if others:\n                c2 = random.choice(others)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Kick: recolor a few random vertices within palette if feasible, else with minimal conflicts\n    m_kick = random.randint(2, 4)\n    idxs = random.sample(range(n), m_kick)\n    for x in idxs:\n        palette = sorted(set(sol))\n        feas = [c for c in palette if all(sol[nb]!=c for nb in adj[x])]\n        if feas:\n            sol[x] = random.choice(feas)\n        else:\n            # choose color with least neighbor conflicts or introduce new color with small prob\n            best_c = sol[x]\n            best_cost = 10**9\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if random.random() < 0.2:\n                best_c = max(palette)+1\n            sol[x] = best_c\n\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002116337}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"LIST_LEN_9_POSITIVE_INTS_COLORS","Evaluacion":"import math\nimport random\nfrom collections import defaultdict\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: lower is better.\n    # Feasible => fitness = number of colors used (k).\n    # Infeasible => large penalty with informative tie-breakers.\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # adjacency degrees\n    deg = [0]*n\n    for u,v in edges:\n        deg[u-1]+=1; deg[v-1]+=1\n    conflicts = 0\n    conflict_vertices = set()\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    k = len(set(solution))\n    if conflicts > 0:\n        # Strongly ordered penalties\n        sum_conflict_deg = sum(deg[i] for i in conflict_vertices)\n        # Penalty tiers ensure lexicographic ordering by (conflicts, |conflict_vertices|, sum_deg, k)\n        return 10**9 + conflicts*10**6 + len(conflict_vertices)*10**3 + sum_conflict_deg*10 + k\n    return k\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def dsatur_seed():\n        # DSATUR constructive heuristic\n        adj = [[] for _ in range(n)]\n        for u,v in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        used = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # pick vertex: max saturation degree, tie by degree\n            v = max(uncolored, key=lambda x: (sat_deg[x], degrees[x], x))\n            # choose smallest feasible color\n            c = 1\n            while any(colors[nb]==c for nb in adj[v]):\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for nb in adj[v]:\n                if colors[nb]==0 and c not in used[nb]:\n                    used[nb].add(c)\n                    sat_deg[nb] = len(used[nb])\n        return colors\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_edges(sol):\n        conf = []\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n\n    def kempe_swap(sol, v, c1, c2, adj):\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c2 if sol[x]==c1 else (c1 if sol[x]==c2 else sol[x])\n        return new_sol\n\n    def try_recolor_vertex(sol, x, palette, adj):\n        # Try recolor within current palette; return best color and resulting conflicts count\n        best_c = sol[x]\n        best_cost = 10**9\n        deg_conf = 0\n        for c in palette:\n            if c == sol[x]:\n                # prefer staying only if no alternative\n                pass\n            clash = False\n            cost = 0\n            for nb in adj[x]:\n                if sol[nb] == c:\n                    clash = True\n                    cost += 1\n            if not clash:\n                # zero-conflict recolor preferred\n                return c, 0\n            if cost < best_cost:\n                best_cost = cost\n                best_c = c\n                deg_conf = cost\n        return best_c, deg_conf\n\n    # Initialize solution\n    if not is_valid_input(solution):\n        seed = dsatur_seed()\n        return seed, \"NB_Init\", \"DSATUR\"\n\n    base = [int(c) if isinstance(c, int) and c>0 else 1 for c in solution]\n    adj = build_adj()\n    palette = sorted(set(base))\n\n    conf = conflict_edges(base)\n    if conf:\n        # Pick conflicted vertex with higher degree first\n        # Build degree list\n        degrees = [len(adj[i]) for i in range(n)]\n        candidates = list({u for e in conf for u in e})\n        candidates.sort(key=lambda i: (-degrees[i], i))\n        x = random.choice(candidates[:max(1, min(3, len(candidates)))])\n        # Attempt recolor within palette; do not introduce new color unless no feasible recolor\n        new_sol = base[:]\n        new_c, cost = try_recolor_vertex(new_sol, x, palette, adj)\n        if cost == 0:\n            new_sol[x] = new_c\n            return new_sol, \"NB_Local\", \"ConflictGreedyRecolor\"\n        # No conflict-free recolor within palette; attempt targeted Kempe swap using most conflicting color pair\n        nb_colors = [new_sol[nb] for nb in adj[x]]\n        if nb_colors:\n            # pick the color causing most conflicts with x (same as current) and another candidate\n            freq = defaultdict(int)\n            for col in nb_colors:\n                freq[col]+=1\n            sorted_cols = sorted(freq.items(), key=lambda kv: -kv[1])\n            for c2,_ in sorted_cols:\n                if c2 != new_sol[x]:\n                    swapped = kempe_swap(new_sol, x, new_sol[x], c2, adj)\n                    if evaluate_solution(swapped) <= evaluate_solution(new_sol):\n                        return swapped, \"NB_Escape\", \"TargetedKempe\"\n        # As last resort, allow introducing new color\n        new_color = max(palette)+1\n        new_sol[x] = new_color\n        return new_sol, \"NB_Local\", \"IntroduceColor\"\n    else:\n        # Feasible: attempt k-reduction via color-class merge with limited backtracking\n        color_counts = {c: 0 for c in palette}\n        for c in base:\n            color_counts[c] += 1\n        # target smallest class to remove\n        target = min(color_counts.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        verts = [i for i,c in enumerate(base) if c==target]\n        order = sorted(verts, key=lambda i: len(adj[i]), reverse=True)\n        new_sol = base[:]\n        avail_colors = [c for c in palette if c != target]\n\n        def backtrack(idx):\n            if idx == len(order):\n                return True\n            v = order[idx]\n            # try colors in order of least conflicts\n            tries = []\n            for c in avail_colors:\n                ok = True\n                for nb in adj[v]:\n                    if new_sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    tries.append(c)\n            # If none, try a Kempe swap assisted move\n            if not tries:\n                for c in avail_colors:\n                    tmp = kempe_swap(new_sol, v, new_sol[v], c, adj)\n                    if all(tmp[nb]!=c for nb in adj[v]):\n                        # if after swap, v can take c\n                        old = new_sol[:]\n                        new_sol[:] = tmp\n                        new_sol[v] = c\n                        if backtrack(idx+1):\n                            return True\n                        new_sol[:] = old\n                return False\n            # Try feasible colors\n            for c in tries:\n                old_c = new_sol[v]\n                new_sol[v] = c\n                if backtrack(idx+1):\n                    return True\n                new_sol[v] = old_c\n            return False\n\n        if len(avail_colors) >= 1 and order:\n            snapshot = new_sol[:]\n            if backtrack(0):\n                # removed a color class\n                # Relabel colors to compact labels while keeping stability otherwise\n                mapping = {}\n                next_label = 1\n                out = []\n                for c in new_sol:\n                    if c not in mapping:\n                        mapping[c] = next_label\n                        next_label += 1\n                    out.append(mapping[c])\n                return out, \"NB_Reduction\", \"ClassMergeBacktrack\"\n            else:\n                new_sol = snapshot\n        # If reduction fails, perform a diversification Kempe swap biased to high degree\n        degrees = [len(adj[i]) for i in range(n)]\n        pick = max(range(n), key=lambda i: (degrees[i], -color_counts.get(base[i],0), i))\n        if len(palette) >= 2:\n            # pick second color as the most frequent among neighbors\n            nb_cols = [base[nb] for nb in adj[pick]]\n            if nb_cols:\n                # choose different color with highest frequency\n                freq = defaultdict(int)\n                for col in nb_cols:\n                    if col != base[pick]:\n                        freq[col]+=1\n                if freq:\n                    c2 = max(freq.items(), key=lambda kv: kv[1])[0]\n                else:\n                    c2 = random.choice([c for c in palette if c != base[pick]])\n            else:\n                c2 = random.choice([c for c in palette if c != base[pick]])\n            new_sol = kempe_swap(base, pick, base[pick], c2, adj)\n            return new_sol, \"NB_Escape\", \"KempeSwap\"\n        # fallback: random recolor within palette (keeps feasibility)\n        i = random.randrange(n)\n        cand = [c for c in palette if all(base[nb]!=c for nb in adj[i])]\n        if cand:\n            new_sol = base[:]\n            new_sol[i] = random.choice(cand)\n            return new_sol, \"NB_Local\", \"FeasibleRecolor\"\n        return base[:], \"NB_NoOp\", \"Stay\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution (does not modify input).\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for c in sol:\n            if not isinstance(c, int) or c < 1:\n                return False\n        return True\n\n    def build_adj():\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, v, c1, c2, adj):\n        if sol[v] not in (c1, c2):\n            return sol[:]\n        q = deque([v])\n        seen = {v}\n        comp = []\n        while q:\n            x = q.popleft()\n            if sol[x] in (c1, c2):\n                comp.append(x)\n                for nb in adj[x]:\n                    if nb not in seen and sol[nb] in (c1, c2):\n                        seen.add(nb)\n                        q.append(nb)\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x] = c2 if sol[x]==c1 else (c1 if sol[x]==c2 else sol[x])\n        return new_sol\n\n    # If invalid, produce DSATUR seed\n    if not is_valid_input(solution):\n        # Simple greedy largest-degree-first as fallback seed\n        adj = build_adj()\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for v in order:\n            c = 1\n            while any(colors[nb]==c for nb in adj[v]):\n                c += 1\n            colors[v] = c\n        return colors\n\n    base = [int(c) if isinstance(c, int) and c>0 else 1 for c in solution]\n    adj = build_adj()\n\n    sol = base[:]\n\n    # 1) Light relabel shuffle to diversify but keep palette size\n    palette = sorted(set(sol))\n    if len(palette) >= 2:\n        perm = palette[:]\n        random.shuffle(perm)\n        mapping = {palette[i]: perm[i] for i in range(len(palette))}\n        sol = [mapping[c] for c in sol]\n\n    # 2) Apply several Kempe swaps focused on high-degree vertices\n    degrees = [len(adj[i]) for i in range(n)]\n    m_swaps = random.randint(1, 3)\n    for _ in range(m_swaps):\n        v = max(range(n), key=lambda i: (degrees[i], random.random()))\n        palette = sorted(set(sol))\n        if len(palette) >= 2:\n            c1 = sol[v]\n            others = [c for c in palette if c != c1]\n            if others:\n                c2 = random.choice(others)\n                sol = kempe_swap(sol, v, c1, c2, adj)\n\n    # 3) Kick: recolor a few random vertices within palette if feasible, else with minimal conflicts\n    m_kick = random.randint(2, 4)\n    idxs = random.sample(range(n), m_kick)\n    for x in idxs:\n        palette = sorted(set(sol))\n        feas = [c for c in palette if all(sol[nb]!=c for nb in adj[x])]\n        if feas:\n            sol[x] = random.choice(feas)\n        else:\n            # choose color with least neighbor conflicts or introduce new color with small prob\n            best_c = sol[x]\n            best_cost = 10**9\n            for c in palette:\n                cost = 0\n                for nb in adj[x]:\n                    if sol[nb] == c:\n                        cost += 1\n                if cost < best_cost:\n                    best_cost = cost\n                    best_c = c\n            if random.random() < 0.2:\n                best_c = max(palette)+1\n            sol[x] = best_c\n\n    return sol\n","Resultados":"Failed to run target heuristic: first argument must be callable or None.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002088917}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON. Each solution is a JSON list of 9 positive integers [r1,...,r9], ri in {1,...,K}, where K = max(ri). Vertices are indexed 1..9 mapped to positions 0..8.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Graph definition (embedded)\n    V = list(range(1, 10))\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return 10**9\n    K = max(solution)\n    # Build adjacency list\n    adj = {i: set() for i in V}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Lower bound via maximum clique search (branch and bound)\n    def max_clique_size():\n        order = sorted(V, key=lambda x: len(adj[x]), reverse=True)\n        best = 0\n        current = []\n        def backtrack(start_idx):\n            nonlocal best, current\n            if len(current) + (len(order) - start_idx) <= best:\n                return\n            if start_idx == len(order):\n                if len(current) > best:\n                    best = len(current)\n                return\n            for i in range(start_idx, len(order)):\n                v = order[i]\n                ok = True\n                for u in current:\n                    if v not in adj[u]:\n                        ok = False\n                        break\n                if ok:\n                    current.append(v)\n                    backtrack(i + 1)\n                    current.pop()\n                if len(current) + (len(order) - (i + 1)) <= best:\n                    break\n            if len(current) > best:\n                best = len(current)\n        backtrack(0)\n        return best\n    omega = max_clique_size()\n    if omega >= K:\n        return K\n    # Try to refute minimality by finding a (K-1)-coloring\n    target_k = K - 1\n    if target_k <= 0:\n        return 10**9\n    order = sorted(V, key=lambda x: len(adj[x]), reverse=True)\n    assignment = {v: 0 for v in V}\n    def can_color(v, c):\n        for nb in adj[v]:\n            if assignment[nb] == c:\n                return False\n        return True\n    found = False\n    def dfs(idx):\n        nonlocal found\n        if found:\n            return\n        if idx == len(order):\n            found = True\n            return\n        v = order[idx]\n        for c in range(1, target_k + 1):\n            if can_color(v, c):\n                assignment[v] = c\n                dfs(idx + 1)\n                if found:\n                    return\n                assignment[v] = 0\n    dfs(0)\n    if found:\n        return K + 100\n    return K\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a trivial feasible-looking neighbor attempt plus metadata\n        return [1,2,3,4,4,1,1,3,2], (\"VertexRecolor\", \"RepairFallback\")\n    colors = solution[:]\n    # Ensure positive integers; if not, repair\n    for i, c in enumerate(colors):\n        if not isinstance(c, int) or c <= 0:\n            colors[i] = 1\n    K = max(colors) if colors else 1\n    # Neighborhood: random vertex recolor to a color in {1..K+1} excluding current\n    v = random.randrange(9)\n    new_color_choices = [c for c in range(1, K + 2) if c != colors[v]]\n    if not new_color_choices:\n        new_color_choices = [1 if colors[v] != 1 else 2]\n    colors[v] = random.choice(new_color_choices)\n    # Optional small chance to swap two color labels to escape plateaus\n    if random.random() < 0.2:\n        a = random.randint(1, max(colors))\n        b = random.randint(1, max(colors))\n        if a != b:\n            colors = [b if x == a else (a if x == b else x) for x in colors]\n    return colors, (\"VertexRecolor\", \"RandomAssignOrSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,4,4,1,1,3,2]\n    s = solution[:]\n    # Normalize colors to a compact range 1..K\n    unique = {}\n    nextc = 1\n    for i, c in enumerate(s):\n        if c not in unique and isinstance(c, int) and c > 0:\n            unique[c] = nextc\n            nextc += 1\n        if not isinstance(c, int) or c <= 0:\n            unique[c] = 1\n        s[i] = unique[s[i]]\n    K = max(s) if s else 1\n    # Apply multiple random recolors and a color relabel shuffle\n    steps = 4\n    for _ in range(steps):\n        v = random.randrange(9)\n        newc = random.randint(1, K + 1)\n        if newc == s[v]:\n            newc = (newc % (K + 1)) + 1\n        s[v] = newc\n        K = max(K, newc)\n    # Randomly permute existing color labels to diversify basins\n    labels = list(range(1, K + 1))\n    random.shuffle(labels)\n    label_map = {i + 1: labels[i] for i in range(len(labels))}\n    s = [label_map.get(c, c) for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001049304}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON. Each solution is a JSON list of 9 positive integers [r1,...,r9], ri in {1,...,K}, where K = max(ri). Vertices are indexed 1..9 mapped to positions 0..8.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Graph definition (embedded)\n    V = list(range(1, 10))\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return 10**9\n    K = max(solution)\n    # Build adjacency list\n    adj = {i: set() for i in V}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Lower bound via maximum clique search (branch and bound)\n    def max_clique_size():\n        order = sorted(V, key=lambda x: len(adj[x]), reverse=True)\n        best = 0\n        current = []\n        def backtrack(start_idx):\n            nonlocal best, current\n            if len(current) + (len(order) - start_idx) <= best:\n                return\n            if start_idx == len(order):\n                if len(current) > best:\n                    best = len(current)\n                return\n            for i in range(start_idx, len(order)):\n                v = order[i]\n                ok = True\n                for u in current:\n                    if v not in adj[u]:\n                        ok = False\n                        break\n                if ok:\n                    current.append(v)\n                    backtrack(i + 1)\n                    current.pop()\n                if len(current) + (len(order) - (i + 1)) <= best:\n                    break\n            if len(current) > best:\n                best = len(current)\n        backtrack(0)\n        return best\n    omega = max_clique_size()\n    if omega >= K:\n        return K\n    # Try to refute minimality by finding a (K-1)-coloring\n    target_k = K - 1\n    if target_k <= 0:\n        return 10**9\n    order = sorted(V, key=lambda x: len(adj[x]), reverse=True)\n    assignment = {v: 0 for v in V}\n    def can_color(v, c):\n        for nb in adj[v]:\n            if assignment[nb] == c:\n                return False\n        return True\n    found = False\n    def dfs(idx):\n        nonlocal found\n        if found:\n            return\n        if idx == len(order):\n            found = True\n            return\n        v = order[idx]\n        for c in range(1, target_k + 1):\n            if can_color(v, c):\n                assignment[v] = c\n                dfs(idx + 1)\n                if found:\n                    return\n                assignment[v] = 0\n    dfs(0)\n    if found:\n        return K + 100\n    return K\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a trivial feasible-looking neighbor attempt plus metadata\n        return [1,2,3,4,4,1,1,3,2], (\"VertexRecolor\", \"RepairFallback\")\n    colors = solution[:]\n    # Ensure positive integers; if not, repair\n    for i, c in enumerate(colors):\n        if not isinstance(c, int) or c <= 0:\n            colors[i] = 1\n    K = max(colors) if colors else 1\n    # Neighborhood: random vertex recolor to a color in {1..K+1} excluding current\n    v = random.randrange(9)\n    new_color_choices = [c for c in range(1, K + 2) if c != colors[v]]\n    if not new_color_choices:\n        new_color_choices = [1 if colors[v] != 1 else 2]\n    colors[v] = random.choice(new_color_choices)\n    # Optional small chance to swap two color labels to escape plateaus\n    if random.random() < 0.2:\n        a = random.randint(1, max(colors))\n        b = random.randint(1, max(colors))\n        if a != b:\n            colors = [b if x == a else (a if x == b else x) for x in colors]\n    return colors, (\"VertexRecolor\", \"RandomAssignOrSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,4,4,1,1,3,2]\n    s = solution[:]\n    # Normalize colors to a compact range 1..K\n    unique = {}\n    nextc = 1\n    for i, c in enumerate(s):\n        if c not in unique and isinstance(c, int) and c > 0:\n            unique[c] = nextc\n            nextc += 1\n        if not isinstance(c, int) or c <= 0:\n            unique[c] = 1\n        s[i] = unique[s[i]]\n    K = max(s) if s else 1\n    # Apply multiple random recolors and a color relabel shuffle\n    steps = 4\n    for _ in range(steps):\n        v = random.randrange(9)\n        newc = random.randint(1, K + 1)\n        if newc == s[v]:\n            newc = (newc % (K + 1)) + 1\n        s[v] = newc\n        K = max(K, newc)\n    # Randomly permute existing color labels to diversify basins\n    labels = list(range(1, K + 1))\n    random.shuffle(labels)\n    label_map = {i + 1: labels[i] for i in range(len(labels))}\n    s = [label_map.get(c, c) for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001085604}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON. Each solution is a JSON list of 9 positive integers [r1,...,r9], ri in {1,...,K}, where K = max(ri). Vertices are indexed 1..9 mapped to positions 0..8.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Graph definition (embedded)\n    V = list(range(1, 10))\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return 10**9\n    K = max(solution)\n    # Build adjacency list\n    adj = {i: set() for i in V}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Lower bound via maximum clique search (branch and bound)\n    def max_clique_size():\n        order = sorted(V, key=lambda x: len(adj[x]), reverse=True)\n        best = 0\n        current = []\n        def backtrack(start_idx):\n            nonlocal best, current\n            if len(current) + (len(order) - start_idx) <= best:\n                return\n            if start_idx == len(order):\n                if len(current) > best:\n                    best = len(current)\n                return\n            for i in range(start_idx, len(order)):\n                v = order[i]\n                ok = True\n                for u in current:\n                    if v not in adj[u]:\n                        ok = False\n                        break\n                if ok:\n                    current.append(v)\n                    backtrack(i + 1)\n                    current.pop()\n                if len(current) + (len(order) - (i + 1)) <= best:\n                    break\n            if len(current) > best:\n                best = len(current)\n        backtrack(0)\n        return best\n    omega = max_clique_size()\n    if omega >= K:\n        return K\n    # Try to refute minimality by finding a (K-1)-coloring\n    target_k = K - 1\n    if target_k <= 0:\n        return 10**9\n    order = sorted(V, key=lambda x: len(adj[x]), reverse=True)\n    assignment = {v: 0 for v in V}\n    def can_color(v, c):\n        for nb in adj[v]:\n            if assignment[nb] == c:\n                return False\n        return True\n    found = False\n    def dfs(idx):\n        nonlocal found\n        if found:\n            return\n        if idx == len(order):\n            found = True\n            return\n        v = order[idx]\n        for c in range(1, target_k + 1):\n            if can_color(v, c):\n                assignment[v] = c\n                dfs(idx + 1)\n                if found:\n                    return\n                assignment[v] = 0\n    dfs(0)\n    if found:\n        return K + 100\n    return K\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return a trivial feasible-looking neighbor attempt plus metadata\n        return [1,2,3,4,4,1,1,3,2], (\"VertexRecolor\", \"RepairFallback\")\n    colors = solution[:]\n    # Ensure positive integers; if not, repair\n    for i, c in enumerate(colors):\n        if not isinstance(c, int) or c <= 0:\n            colors[i] = 1\n    K = max(colors) if colors else 1\n    # Neighborhood: random vertex recolor to a color in {1..K+1} excluding current\n    v = random.randrange(9)\n    new_color_choices = [c for c in range(1, K + 2) if c != colors[v]]\n    if not new_color_choices:\n        new_color_choices = [1 if colors[v] != 1 else 2]\n    colors[v] = random.choice(new_color_choices)\n    # Optional small chance to swap two color labels to escape plateaus\n    if random.random() < 0.2:\n        a = random.randint(1, max(colors))\n        b = random.randint(1, max(colors))\n        if a != b:\n            colors = [b if x == a else (a if x == b else x) for x in colors]\n    return colors, (\"VertexRecolor\", \"RandomAssignOrSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,4,4,1,1,3,2]\n    s = solution[:]\n    # Normalize colors to a compact range 1..K\n    unique = {}\n    nextc = 1\n    for i, c in enumerate(s):\n        if c not in unique and isinstance(c, int) and c > 0:\n            unique[c] = nextc\n            nextc += 1\n        if not isinstance(c, int) or c <= 0:\n            unique[c] = 1\n        s[i] = unique[s[i]]\n    K = max(s) if s else 1\n    # Apply multiple random recolors and a color relabel shuffle\n    steps = 4\n    for _ in range(steps):\n        v = random.randrange(9)\n        newc = random.randint(1, K + 1)\n        if newc == s[v]:\n            newc = (newc % (K + 1)) + 1\n        s[v] = newc\n        K = max(K, newc)\n    # Randomly permute existing color labels to diversify basins\n    labels = list(range(1, K + 1))\n    random.shuffle(labels)\n    label_map = {i + 1: labels[i] for i in range(len(labels))}\n    s = [label_map.get(c, c) for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000901982}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON. Each solution is a JSON list of 9 positive integers [r1,...,r9], ri in {1,...,K}, where K = max(ri). Vertices are 1..9 mapped to indices 0..8.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    V = list(range(1, 10))\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and basic repair\n    if not isinstance(solution, list) or len(solution) != 9:\n        cand = [1,2,3,4,4,1,1,3,2]\n        return cand, (\"VertexRecolor\", \"RepairFallback\")\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _normalize_colors(s)\n    K = max(s) if s else 1\n\n    # Bias: if feasible reduction seems possible, try to reduce usage of K\n    v_indices = list(range(9))\n    random.shuffle(v_indices)\n\n    # With some probability perform a color-class relabel that can drop an empty max color\n    move_type = (\"VertexRecolor\", \"RandomOrReduceK\")\n\n    # Choose a vertex\n    v = None\n    # Prefer vertices of max color to try to reduce K\n    max_color_vertices = [i for i, c in enumerate(s) if c == K]\n    if max_color_vertices and random.random() < 0.7:\n        v = random.choice(max_color_vertices)\n    else:\n        v = random.randrange(9)\n\n    # Choose a new color in 1..max(K-1,1) most of the time to avoid inflating K\n    allow_new_color = random.random() < 0.1  # small chance to open K+1\n    if K > 1 and not allow_new_color:\n        palette = [c for c in range(1, K) if c != s[v]]\n        if not palette:\n            palette = [s[v]]  # fallback no-op, will swap below\n    else:\n        palette = [c for c in range(1, K + 2) if c != s[v]]\n    new_color = random.choice(palette) if palette else s[v]\n\n    new_s = s[:]\n    new_s[v] = new_color\n\n    # Occasionally swap two color labels to escape plateaus\n    if random.random() < 0.2:\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a != b:\n            new_s = [b if x == a else (a if x == b else x) for x in new_s]\n        move_type = (\"ColorSwap\", \"LabelSwap\")\n\n    new_s = _normalize_colors(new_s)\n    return new_s, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,4,4,1,1,3,2]\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _normalize_colors(s)\n    K = max(s) if s else 1\n    # Apply multiple random recolors with conservative palette to avoid K blow-up\n    steps = 5\n    for _ in range(steps):\n        v = random.randrange(9)\n        if K > 1 and random.random() < 0.85:\n            palette = list(range(1, K))\n            if s[v] in palette:\n                palette.remove(s[v])\n            if not palette:\n                palette = [s[v]]\n        else:\n            palette = [c for c in range(1, K + 2) if c != s[v]]\n        s[v] = random.choice(palette)\n        K = max(K, s[v])\n    # Randomly permute labels\n    labels = list(range(1, K + 1))\n    random.shuffle(labels)\n    relabel = {i + 1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n    s = _normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000656119}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON. Each solution is a JSON list of 9 positive integers [r1,...,r9], ri in {1,...,K}, where K = max(ri). Vertices are 1..9 mapped to indices 0..8.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    V = list(range(1, 10))\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and basic repair\n    if not isinstance(solution, list) or len(solution) != 9:\n        cand = [1,2,3,4,4,1,1,3,2]\n        return cand, (\"VertexRecolor\", \"RepairFallback\")\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _normalize_colors(s)\n    K = max(s) if s else 1\n\n    # Bias: if feasible reduction seems possible, try to reduce usage of K\n    v_indices = list(range(9))\n    random.shuffle(v_indices)\n\n    # With some probability perform a color-class relabel that can drop an empty max color\n    move_type = (\"VertexRecolor\", \"RandomOrReduceK\")\n\n    # Choose a vertex\n    v = None\n    # Prefer vertices of max color to try to reduce K\n    max_color_vertices = [i for i, c in enumerate(s) if c == K]\n    if max_color_vertices and random.random() < 0.7:\n        v = random.choice(max_color_vertices)\n    else:\n        v = random.randrange(9)\n\n    # Choose a new color in 1..max(K-1,1) most of the time to avoid inflating K\n    allow_new_color = random.random() < 0.1  # small chance to open K+1\n    if K > 1 and not allow_new_color:\n        palette = [c for c in range(1, K) if c != s[v]]\n        if not palette:\n            palette = [s[v]]  # fallback no-op, will swap below\n    else:\n        palette = [c for c in range(1, K + 2) if c != s[v]]\n    new_color = random.choice(palette) if palette else s[v]\n\n    new_s = s[:]\n    new_s[v] = new_color\n\n    # Occasionally swap two color labels to escape plateaus\n    if random.random() < 0.2:\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a != b:\n            new_s = [b if x == a else (a if x == b else x) for x in new_s]\n        move_type = (\"ColorSwap\", \"LabelSwap\")\n\n    new_s = _normalize_colors(new_s)\n    return new_s, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,4,4,1,1,3,2]\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _normalize_colors(s)\n    K = max(s) if s else 1\n    # Apply multiple random recolors with conservative palette to avoid K blow-up\n    steps = 5\n    for _ in range(steps):\n        v = random.randrange(9)\n        if K > 1 and random.random() < 0.85:\n            palette = list(range(1, K))\n            if s[v] in palette:\n                palette.remove(s[v])\n            if not palette:\n                palette = [s[v]]\n        else:\n            palette = [c for c in range(1, K + 2) if c != s[v]]\n        s[v] = random.choice(palette)\n        K = max(K, s[v])\n    # Randomly permute labels\n    labels = list(range(1, K + 1))\n    random.shuffle(labels)\n    relabel = {i + 1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n    s = _normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000838921}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON. Each solution is a JSON list of 9 positive integers [r1,...,r9], ri in {1,...,K}, where K = max(ri). Vertices are 1..9 mapped to indices 0..8.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    V = list(range(1, 10))\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and basic repair\n    if not isinstance(solution, list) or len(solution) != 9:\n        cand = [1,2,3,4,4,1,1,3,2]\n        return cand, (\"VertexRecolor\", \"RepairFallback\")\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _normalize_colors(s)\n    K = max(s) if s else 1\n\n    # Bias: if feasible reduction seems possible, try to reduce usage of K\n    v_indices = list(range(9))\n    random.shuffle(v_indices)\n\n    # With some probability perform a color-class relabel that can drop an empty max color\n    move_type = (\"VertexRecolor\", \"RandomOrReduceK\")\n\n    # Choose a vertex\n    v = None\n    # Prefer vertices of max color to try to reduce K\n    max_color_vertices = [i for i, c in enumerate(s) if c == K]\n    if max_color_vertices and random.random() < 0.7:\n        v = random.choice(max_color_vertices)\n    else:\n        v = random.randrange(9)\n\n    # Choose a new color in 1..max(K-1,1) most of the time to avoid inflating K\n    allow_new_color = random.random() < 0.1  # small chance to open K+1\n    if K > 1 and not allow_new_color:\n        palette = [c for c in range(1, K) if c != s[v]]\n        if not palette:\n            palette = [s[v]]  # fallback no-op, will swap below\n    else:\n        palette = [c for c in range(1, K + 2) if c != s[v]]\n    new_color = random.choice(palette) if palette else s[v]\n\n    new_s = s[:]\n    new_s[v] = new_color\n\n    # Occasionally swap two color labels to escape plateaus\n    if random.random() < 0.2:\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a != b:\n            new_s = [b if x == a else (a if x == b else x) for x in new_s]\n        move_type = (\"ColorSwap\", \"LabelSwap\")\n\n    new_s = _normalize_colors(new_s)\n    return new_s, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,4,4,1,1,3,2]\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = _normalize_colors(s)\n    K = max(s) if s else 1\n    # Apply multiple random recolors with conservative palette to avoid K blow-up\n    steps = 5\n    for _ in range(steps):\n        v = random.randrange(9)\n        if K > 1 and random.random() < 0.85:\n            palette = list(range(1, K))\n            if s[v] in palette:\n                palette.remove(s[v])\n            if not palette:\n                palette = [s[v]]\n        else:\n            palette = [c for c in range(1, K + 2) if c != s[v]]\n        s[v] = random.choice(palette)\n        K = max(K, s[v])\n    # Randomly permute labels\n    labels = list(range(1, K + 1))\n    random.shuffle(labels)\n    relabel = {i + 1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n    s = _normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00079655}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON with entries in positive integers representing colors for vertices 1..9 mapped to indices 0..8. Example: [4,1,2,3,3,4,4,2,1].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _graph_edges():\n    return [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef _conflict_vertices(sol: List[int]) -> List[int]:\n    E = _graph_edges()\n    n = 9\n    conflict = [False]*n\n    for (u,v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict[u-1] = True\n            conflict[v-1] = True\n    return [i for i,flag in enumerate(conflict) if flag]\n\ndef _neighbor_colors(idx: int, sol: List[int]) -> set:\n    E = _graph_edges()\n    colors = set()\n    for (u,v) in E:\n        if u-1 == idx:\n            colors.add(sol[v-1])\n        elif v-1 == idx:\n            colors.add(sol[u-1])\n    return colors\n\ndef _kempe_chain_swap(sol: List[int], a: int, b: int, start_v: int) -> List[int]:\n    # BFS on subgraph induced by colors a and b, then swap colors on that component\n    E = _graph_edges()\n    n = 9\n    if sol[start_v] not in (a,b):\n        return sol[:]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    visited = [False]*n\n    comp = []\n    stack = [start_v]\n    visited[start_v] = True\n    while stack:\n        x = stack.pop()\n        comp.append(x)\n        for y in adj[x]:\n            if not visited[y] and sol[y] in (a,b):\n                visited[y] = True\n                stack.append(y)\n    new_sol = sol[:]\n    for v in comp:\n        new_sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n    return new_sol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        cand = [1,2,3,4,4,1,1,3,2]\n        return cand, (\"Repair\", \"FallbackInvalid\")\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    K = max(s) if s else 1\n\n    conf_vertices = _conflict_vertices(s)\n    move_meta = (\"VertexRecolor\", \"Greedy\")\n\n    if conf_vertices:\n        # Conflict-driven greedy recolor; allow K+1 rarely\n        v = random.choice(conf_vertices)\n        neighbor_cols = _neighbor_colors(v, s)\n        palette = list(range(1, K+1))\n        # Small chance to open a new color when stuck in conflicts\n        if random.random() < 0.05:\n            palette.append(K+1)\n        best_color = s[v]\n        best_conflicts = 10**9\n        for col in palette:\n            if col == s[v]:\n                # evaluate current color too for completeness\n                pass\n            new_c = col\n            tmp = s[:]\n            tmp[v] = new_c\n            cverts = _conflict_vertices(tmp)\n            score = len(cverts)\n            if score < best_conflicts or (score == best_conflicts and new_c < best_color):\n                best_conflicts = score\n                best_color = new_c\n        new_s = s[:]\n        new_s[v] = best_color\n        move_meta = (\"VertexRecolor\", \"ConflictGreedy\")\n        return new_s, move_meta\n    else:\n        # Feasible: try to reduce K without creating conflicts\n        max_vertices = [i for i,c in enumerate(s) if c == K]\n        random.shuffle(max_vertices)\n        for v in max_vertices:\n            neighbor_cols = _neighbor_colors(v, s)\n            feasible_colors = [c for c in range(1, K) if c not in neighbor_cols]\n            if feasible_colors:\n                new_color = random.choice(feasible_colors)\n                new_s = s[:]\n                new_s[v] = new_color\n                # If K is no longer used, normalize labels to drop it\n                if K not in new_s:\n                    new_s = _normalize_colors(new_s)\n                    return new_s, (\"VertexRecolor\", \"KDrop\")\n                return new_s, (\"VertexRecolor\", \"KConserve\")\n        # Kempe-chain move between K and a lower color to free K\n        if max_vertices:\n            v = random.choice(max_vertices)\n            if K > 1:\n                b = random.randint(1, K-1)\n                new_s = _kempe_chain_swap(s, K, b, v)\n                # accept kempe swap; if it drops K usage, normalize\n                if K not in new_s:\n                    new_s = _normalize_colors(new_s)\n                    return new_s, (\"Kempe\", \"KDrop\")\n                return new_s, (\"Kempe\", \"PlateauMove\")\n        # As a fallback, swap two color labels to diversify\n        labels = list(range(1, K+1))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            new_s = [b if x == a else (a if x == b else x) for x in s]\n            return new_s, (\"ColorSwap\", \"LabelDiversify\")\n        return s[:], (\"NoOp\", \"Stable\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef _graph_edges():\n    return [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\ndef _conflict_vertices(sol: List[int]) -> List[int]:\n    E = _graph_edges()\n    n = 9\n    conflict = [False]*n\n    for (u,v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict[u-1] = True\n            conflict[v-1] = True\n    return [i for i,flag in enumerate(conflict) if flag]\n\ndef perturb_solution(solution):\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    K = max(s) if s else 1\n\n    # Determine strength adaptively\n    confs = _conflict_vertices(s)\n    if confs:\n        steps = min(7, 3 + len(confs))\n        focus_vertices = confs\n    else:\n        steps = 4\n        focus_vertices = [i for i,c in enumerate(s) if c == K] or list(range(9))\n\n    for _ in range(steps):\n        v = random.choice(focus_vertices)\n        # Greedy least-conflict recolor, allow occasional K+1 if still conflicting\n        palette = list(range(1, K+1))\n        if confs and random.random() < 0.1:\n            palette.append(K+1)\n        best_color = s[v]\n        best_score = 10**9\n        for col in palette:\n            tmp = s[:]\n            tmp[v] = col\n            score = len(_conflict_vertices(tmp))\n            if score < best_score or (score == best_score and col < best_color):\n                best_score = score\n                best_color = col\n        s[v] = best_color\n        K = max(K, s[v])\n\n    # Random label permutation to escape symmetries\n    labels = list(range(1, K+1))\n    random.shuffle(labels)\n    relabel = {i+1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n\n    s = _normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001158805}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON with entries in positive integers representing colors for vertices 1..9 mapped to indices 0..8. Example: [4,1,2,3,3,4,4,2,1].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _graph_edges():\n    return [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef _conflict_vertices(sol: List[int]) -> List[int]:\n    E = _graph_edges()\n    n = 9\n    conflict = [False]*n\n    for (u,v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict[u-1] = True\n            conflict[v-1] = True\n    return [i for i,flag in enumerate(conflict) if flag]\n\ndef _neighbor_colors(idx: int, sol: List[int]) -> set:\n    E = _graph_edges()\n    colors = set()\n    for (u,v) in E:\n        if u-1 == idx:\n            colors.add(sol[v-1])\n        elif v-1 == idx:\n            colors.add(sol[u-1])\n    return colors\n\ndef _kempe_chain_swap(sol: List[int], a: int, b: int, start_v: int) -> List[int]:\n    # BFS on subgraph induced by colors a and b, then swap colors on that component\n    E = _graph_edges()\n    n = 9\n    if sol[start_v] not in (a,b):\n        return sol[:]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    visited = [False]*n\n    comp = []\n    stack = [start_v]\n    visited[start_v] = True\n    while stack:\n        x = stack.pop()\n        comp.append(x)\n        for y in adj[x]:\n            if not visited[y] and sol[y] in (a,b):\n                visited[y] = True\n                stack.append(y)\n    new_sol = sol[:]\n    for v in comp:\n        new_sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n    return new_sol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        cand = [1,2,3,4,4,1,1,3,2]\n        return cand, (\"Repair\", \"FallbackInvalid\")\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    K = max(s) if s else 1\n\n    conf_vertices = _conflict_vertices(s)\n    move_meta = (\"VertexRecolor\", \"Greedy\")\n\n    if conf_vertices:\n        # Conflict-driven greedy recolor; allow K+1 rarely\n        v = random.choice(conf_vertices)\n        neighbor_cols = _neighbor_colors(v, s)\n        palette = list(range(1, K+1))\n        # Small chance to open a new color when stuck in conflicts\n        if random.random() < 0.05:\n            palette.append(K+1)\n        best_color = s[v]\n        best_conflicts = 10**9\n        for col in palette:\n            if col == s[v]:\n                # evaluate current color too for completeness\n                pass\n            new_c = col\n            tmp = s[:]\n            tmp[v] = new_c\n            cverts = _conflict_vertices(tmp)\n            score = len(cverts)\n            if score < best_conflicts or (score == best_conflicts and new_c < best_color):\n                best_conflicts = score\n                best_color = new_c\n        new_s = s[:]\n        new_s[v] = best_color\n        move_meta = (\"VertexRecolor\", \"ConflictGreedy\")\n        return new_s, move_meta\n    else:\n        # Feasible: try to reduce K without creating conflicts\n        max_vertices = [i for i,c in enumerate(s) if c == K]\n        random.shuffle(max_vertices)\n        for v in max_vertices:\n            neighbor_cols = _neighbor_colors(v, s)\n            feasible_colors = [c for c in range(1, K) if c not in neighbor_cols]\n            if feasible_colors:\n                new_color = random.choice(feasible_colors)\n                new_s = s[:]\n                new_s[v] = new_color\n                # If K is no longer used, normalize labels to drop it\n                if K not in new_s:\n                    new_s = _normalize_colors(new_s)\n                    return new_s, (\"VertexRecolor\", \"KDrop\")\n                return new_s, (\"VertexRecolor\", \"KConserve\")\n        # Kempe-chain move between K and a lower color to free K\n        if max_vertices:\n            v = random.choice(max_vertices)\n            if K > 1:\n                b = random.randint(1, K-1)\n                new_s = _kempe_chain_swap(s, K, b, v)\n                # accept kempe swap; if it drops K usage, normalize\n                if K not in new_s:\n                    new_s = _normalize_colors(new_s)\n                    return new_s, (\"Kempe\", \"KDrop\")\n                return new_s, (\"Kempe\", \"PlateauMove\")\n        # As a fallback, swap two color labels to diversify\n        labels = list(range(1, K+1))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            new_s = [b if x == a else (a if x == b else x) for x in s]\n            return new_s, (\"ColorSwap\", \"LabelDiversify\")\n        return s[:], (\"NoOp\", \"Stable\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef _graph_edges():\n    return [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\ndef _conflict_vertices(sol: List[int]) -> List[int]:\n    E = _graph_edges()\n    n = 9\n    conflict = [False]*n\n    for (u,v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict[u-1] = True\n            conflict[v-1] = True\n    return [i for i,flag in enumerate(conflict) if flag]\n\ndef perturb_solution(solution):\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    K = max(s) if s else 1\n\n    # Determine strength adaptively\n    confs = _conflict_vertices(s)\n    if confs:\n        steps = min(7, 3 + len(confs))\n        focus_vertices = confs\n    else:\n        steps = 4\n        focus_vertices = [i for i,c in enumerate(s) if c == K] or list(range(9))\n\n    for _ in range(steps):\n        v = random.choice(focus_vertices)\n        # Greedy least-conflict recolor, allow occasional K+1 if still conflicting\n        palette = list(range(1, K+1))\n        if confs and random.random() < 0.1:\n            palette.append(K+1)\n        best_color = s[v]\n        best_score = 10**9\n        for col in palette:\n            tmp = s[:]\n            tmp[v] = col\n            score = len(_conflict_vertices(tmp))\n            if score < best_score or (score == best_score and col < best_color):\n                best_score = score\n                best_color = col\n        s[v] = best_color\n        K = max(K, s[v])\n\n    # Random label permutation to escape symmetries\n    labels = list(range(1, K+1))\n    random.shuffle(labels)\n    relabel = {i+1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n\n    s = _normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001426859}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON with entries in positive integers representing colors for vertices 1..9 mapped to indices 0..8. Example: [4,1,2,3,3,4,4,2,1].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _graph_edges():\n    return [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef _conflict_vertices(sol: List[int]) -> List[int]:\n    E = _graph_edges()\n    n = 9\n    conflict = [False]*n\n    for (u,v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict[u-1] = True\n            conflict[v-1] = True\n    return [i for i,flag in enumerate(conflict) if flag]\n\ndef _neighbor_colors(idx: int, sol: List[int]) -> set:\n    E = _graph_edges()\n    colors = set()\n    for (u,v) in E:\n        if u-1 == idx:\n            colors.add(sol[v-1])\n        elif v-1 == idx:\n            colors.add(sol[u-1])\n    return colors\n\ndef _kempe_chain_swap(sol: List[int], a: int, b: int, start_v: int) -> List[int]:\n    # BFS on subgraph induced by colors a and b, then swap colors on that component\n    E = _graph_edges()\n    n = 9\n    if sol[start_v] not in (a,b):\n        return sol[:]\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    visited = [False]*n\n    comp = []\n    stack = [start_v]\n    visited[start_v] = True\n    while stack:\n        x = stack.pop()\n        comp.append(x)\n        for y in adj[x]:\n            if not visited[y] and sol[y] in (a,b):\n                visited[y] = True\n                stack.append(y)\n    new_sol = sol[:]\n    for v in comp:\n        new_sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n    return new_sol\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        cand = [1,2,3,4,4,1,1,3,2]\n        return cand, (\"Repair\", \"FallbackInvalid\")\n    s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    K = max(s) if s else 1\n\n    conf_vertices = _conflict_vertices(s)\n    move_meta = (\"VertexRecolor\", \"Greedy\")\n\n    if conf_vertices:\n        # Conflict-driven greedy recolor; allow K+1 rarely\n        v = random.choice(conf_vertices)\n        neighbor_cols = _neighbor_colors(v, s)\n        palette = list(range(1, K+1))\n        # Small chance to open a new color when stuck in conflicts\n        if random.random() < 0.05:\n            palette.append(K+1)\n        best_color = s[v]\n        best_conflicts = 10**9\n        for col in palette:\n            if col == s[v]:\n                # evaluate current color too for completeness\n                pass\n            new_c = col\n            tmp = s[:]\n            tmp[v] = new_c\n            cverts = _conflict_vertices(tmp)\n            score = len(cverts)\n            if score < best_conflicts or (score == best_conflicts and new_c < best_color):\n                best_conflicts = score\n                best_color = new_c\n        new_s = s[:]\n        new_s[v] = best_color\n        move_meta = (\"VertexRecolor\", \"ConflictGreedy\")\n        return new_s, move_meta\n    else:\n        # Feasible: try to reduce K without creating conflicts\n        max_vertices = [i for i,c in enumerate(s) if c == K]\n        random.shuffle(max_vertices)\n        for v in max_vertices:\n            neighbor_cols = _neighbor_colors(v, s)\n            feasible_colors = [c for c in range(1, K) if c not in neighbor_cols]\n            if feasible_colors:\n                new_color = random.choice(feasible_colors)\n                new_s = s[:]\n                new_s[v] = new_color\n                # If K is no longer used, normalize labels to drop it\n                if K not in new_s:\n                    new_s = _normalize_colors(new_s)\n                    return new_s, (\"VertexRecolor\", \"KDrop\")\n                return new_s, (\"VertexRecolor\", \"KConserve\")\n        # Kempe-chain move between K and a lower color to free K\n        if max_vertices:\n            v = random.choice(max_vertices)\n            if K > 1:\n                b = random.randint(1, K-1)\n                new_s = _kempe_chain_swap(s, K, b, v)\n                # accept kempe swap; if it drops K usage, normalize\n                if K not in new_s:\n                    new_s = _normalize_colors(new_s)\n                    return new_s, (\"Kempe\", \"KDrop\")\n                return new_s, (\"Kempe\", \"PlateauMove\")\n        # As a fallback, swap two color labels to diversify\n        labels = list(range(1, K+1))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            new_s = [b if x == a else (a if x == b else x) for x in s]\n            return new_s, (\"ColorSwap\", \"LabelDiversify\")\n        return s[:], (\"NoOp\", \"Stable\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef _normalize_colors(sol: List[int]) -> List[int]:\n    remap = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nextc\n            nextc += 1\n        out.append(remap[c])\n    return out\n\ndef _graph_edges():\n    return [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\ndef _conflict_vertices(sol: List[int]) -> List[int]:\n    E = _graph_edges()\n    n = 9\n    conflict = [False]*n\n    for (u,v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict[u-1] = True\n            conflict[v-1] = True\n    return [i for i,flag in enumerate(conflict) if flag]\n\ndef perturb_solution(solution):\n    # Defensive copy and sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    K = max(s) if s else 1\n\n    # Determine strength adaptively\n    confs = _conflict_vertices(s)\n    if confs:\n        steps = min(7, 3 + len(confs))\n        focus_vertices = confs\n    else:\n        steps = 4\n        focus_vertices = [i for i,c in enumerate(s) if c == K] or list(range(9))\n\n    for _ in range(steps):\n        v = random.choice(focus_vertices)\n        # Greedy least-conflict recolor, allow occasional K+1 if still conflicting\n        palette = list(range(1, K+1))\n        if confs and random.random() < 0.1:\n            palette.append(K+1)\n        best_color = s[v]\n        best_score = 10**9\n        for col in palette:\n            tmp = s[:]\n            tmp[v] = col\n            score = len(_conflict_vertices(tmp))\n            if score < best_score or (score == best_score and col < best_color):\n                best_score = score\n                best_color = col\n        s[v] = best_color\n        K = max(K, s[v])\n\n    # Random label permutation to escape symmetries\n    labels = list(range(1, K+1))\n    random.shuffle(labels)\n    relabel = {i+1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n\n    s = _normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001322327}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON; entries are positive integers representing colors for vertices 1..9 (indices 0..8). Example: [1,2,3,4,4,1,1,3,2]","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers\n    def edges():\n        return [\n            (1,2),(1,3),(1,4),(1,8),(1,9),\n            (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,6),(3,7),(3,9),\n            (4,7),\n            (5,6),(5,7),(5,8),(5,9),\n            (7,8),(7,9),\n            (8,9)\n        ]\n    def build_adj(n: int = 9):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges():\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def normalize_colors(sol: List[int]) -> List[int]:\n        remap = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nextc\n                nextc += 1\n            out.append(remap[c])\n        return out\n    def conflict_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n        n = len(sol)\n        conflict = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    conflict[u] = True\n                    conflict[v] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def delta_conflicts_for_vertex(sol: List[int], adj: List[List[int]], v: int, new_color: int) -> int:\n        # Returns number of conflicting edges incident to v after recoloring v with new_color\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb] == new_color:\n                cnt += 1\n        return cnt\n    def kempe_chain_swap(sol: List[int], adj: List[List[int]], a: int, b: int, start_v: int) -> List[int]:\n        n = len(sol)\n        if sol[start_v] not in (a,b):\n            return sol[:]\n        stack = [start_v]\n        visited = [False]*n\n        visited[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and sol[y] in (a,b):\n                    visited[y] = True\n                    stack.append(y)\n        new_sol = sol[:]\n        for v in comp:\n            new_sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return new_sol\n\n    # Defensive sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = normalize_colors(s)\n\n    adj = build_adj(9)\n    K = max(s)\n\n    conf_vs = conflict_vertices(s, adj)\n\n    if conf_vs:\n        # Choose a conflicting vertex with highest degree in conflict neighborhood\n        v = max(conf_vs, key=lambda x: sum(1 for nb in adj[x] if s[nb] == s[x]))\n        palette = list(range(1, K+1))\n        if random.random() < 0.05:\n            palette.append(K+1)\n        best_col = s[v]\n        best_cnt = 10**9\n        for col in palette:\n            cnt = delta_conflicts_for_vertex(s, adj, v, col)\n            if cnt < best_cnt or (cnt == best_cnt and col < best_col):\n                best_cnt = cnt\n                best_col = col\n        new_s = s[:]\n        new_s[v] = best_col\n        new_s = normalize_colors(new_s)\n        return new_s, (\"VertexRecolor\", \"ConflictGreedyDelta\")\n    else:\n        # Feasible: deterministic K-drop attempt\n        max_vertices = [i for i,c in enumerate(s) if c == K]\n        # Try to push each K-vertex to lowest feasible color\n        changed = False\n        new_s = s[:]\n        for v in max_vertices:\n            neighbor_colors = {new_s[nb] for nb in adj[v]}\n            for col in range(1, K):\n                if col not in neighbor_colors:\n                    new_s[v] = col\n                    changed = True\n                    break\n        if changed:\n            new_s = normalize_colors(new_s)\n            move = (\"VertexRecolor\", \"KDropGreedy\") if K not in new_s else (\"VertexRecolor\", \"KConserveGreedy\")\n            return new_s, move\n        # Targeted Kempe-chain between K and best lower color to free K\n        if max_vertices and K > 1:\n            # Choose lower color that minimizes intersections\n            lower_colors = list(range(1, K))\n            best_c = min(lower_colors, key=lambda c: sum(1 for v in max_vertices for nb in adj[v] if s[nb]==c))\n            v = random.choice(max_vertices)\n            kc = kempe_chain_swap(s, adj, K, best_c, v)\n            kc = normalize_colors(kc)\n            if kc != s:\n                move = (\"Kempe\", \"KDrop\") if K not in kc else (\"Kempe\", \"PlateauMove\")\n                return kc, move\n        # Label swap diversify\n        labels = list(range(1, K+1))\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            swapped = [b if x == a else (a if x == b else x) for x in s]\n            swapped = normalize_colors(swapped)\n            return swapped, (\"ColorSwap\", \"LabelDiversify\")\n        return s[:], (\"NoOp\", \"Stable\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def edges():\n        return [\n            (1,2),(1,3),(1,4),(1,8),(1,9),\n            (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,6),(3,7),(3,9),\n            (4,7),\n            (5,6),(5,7),(5,8),(5,9),\n            (7,8),(7,9),\n            (8,9)\n        ]\n    def build_adj(n: int = 9):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges():\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def normalize_colors(sol: List[int]) -> List[int]:\n        remap = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nextc\n                nextc += 1\n            out.append(remap[c])\n        return out\n    def conflict_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n        n = len(sol)\n        conflict = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    conflict[u] = True\n                    conflict[v] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n\n    # Sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n\n    s = normalize_colors(s)\n    adj = build_adj(9)\n    K = max(s)\n\n    confs = conflict_vertices(s, adj)\n    steps = min(8, 4 + (len(confs) if confs else 0))\n\n    # Focus on hardest vertices: conflicts first, then max color class\n    focus = confs if confs else [i for i,c in enumerate(s) if c == K]\n    if not focus:\n        focus = list(range(9))\n\n    for _ in range(steps):\n        v = random.choice(focus)\n        neighbor_colors = {s[nb] for nb in adj[v]}\n        palette = list(range(1, max(K, max(s))+1))\n        if confs and random.random() < 0.15:\n            palette.append(max(K, max(s))+1)\n        # choose least-conflict color locally\n        best_col = s[v]\n        best_cnt = 10**9\n        for col in palette:\n            cnt = sum(1 for nb in adj[v] if s[nb] == col)\n            if cnt < best_cnt or (cnt == best_cnt and col < best_col):\n                best_cnt = cnt\n                best_col = col\n        s[v] = best_col\n        K = max(K, s[v])\n\n    # Random relabel to escape symmetry\n    labels = list(range(1, K+1))\n    random.shuffle(labels)\n    relabel = {i+1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001352968}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON; entries are positive integers representing colors for vertices 1..9 (indices 0..8). Example: [1,2,3,4,4,1,1,3,2]","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers\n    def edges():\n        return [\n            (1,2),(1,3),(1,4),(1,8),(1,9),\n            (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,6),(3,7),(3,9),\n            (4,7),\n            (5,6),(5,7),(5,8),(5,9),\n            (7,8),(7,9),\n            (8,9)\n        ]\n    def build_adj(n: int = 9):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges():\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def normalize_colors(sol: List[int]) -> List[int]:\n        remap = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nextc\n                nextc += 1\n            out.append(remap[c])\n        return out\n    def conflict_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n        n = len(sol)\n        conflict = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    conflict[u] = True\n                    conflict[v] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def delta_conflicts_for_vertex(sol: List[int], adj: List[List[int]], v: int, new_color: int) -> int:\n        # Returns number of conflicting edges incident to v after recoloring v with new_color\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb] == new_color:\n                cnt += 1\n        return cnt\n    def kempe_chain_swap(sol: List[int], adj: List[List[int]], a: int, b: int, start_v: int) -> List[int]:\n        n = len(sol)\n        if sol[start_v] not in (a,b):\n            return sol[:]\n        stack = [start_v]\n        visited = [False]*n\n        visited[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and sol[y] in (a,b):\n                    visited[y] = True\n                    stack.append(y)\n        new_sol = sol[:]\n        for v in comp:\n            new_sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return new_sol\n\n    # Defensive sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = normalize_colors(s)\n\n    adj = build_adj(9)\n    K = max(s)\n\n    conf_vs = conflict_vertices(s, adj)\n\n    if conf_vs:\n        # Choose a conflicting vertex with highest degree in conflict neighborhood\n        v = max(conf_vs, key=lambda x: sum(1 for nb in adj[x] if s[nb] == s[x]))\n        palette = list(range(1, K+1))\n        if random.random() < 0.05:\n            palette.append(K+1)\n        best_col = s[v]\n        best_cnt = 10**9\n        for col in palette:\n            cnt = delta_conflicts_for_vertex(s, adj, v, col)\n            if cnt < best_cnt or (cnt == best_cnt and col < best_col):\n                best_cnt = cnt\n                best_col = col\n        new_s = s[:]\n        new_s[v] = best_col\n        new_s = normalize_colors(new_s)\n        return new_s, (\"VertexRecolor\", \"ConflictGreedyDelta\")\n    else:\n        # Feasible: deterministic K-drop attempt\n        max_vertices = [i for i,c in enumerate(s) if c == K]\n        # Try to push each K-vertex to lowest feasible color\n        changed = False\n        new_s = s[:]\n        for v in max_vertices:\n            neighbor_colors = {new_s[nb] for nb in adj[v]}\n            for col in range(1, K):\n                if col not in neighbor_colors:\n                    new_s[v] = col\n                    changed = True\n                    break\n        if changed:\n            new_s = normalize_colors(new_s)\n            move = (\"VertexRecolor\", \"KDropGreedy\") if K not in new_s else (\"VertexRecolor\", \"KConserveGreedy\")\n            return new_s, move\n        # Targeted Kempe-chain between K and best lower color to free K\n        if max_vertices and K > 1:\n            # Choose lower color that minimizes intersections\n            lower_colors = list(range(1, K))\n            best_c = min(lower_colors, key=lambda c: sum(1 for v in max_vertices for nb in adj[v] if s[nb]==c))\n            v = random.choice(max_vertices)\n            kc = kempe_chain_swap(s, adj, K, best_c, v)\n            kc = normalize_colors(kc)\n            if kc != s:\n                move = (\"Kempe\", \"KDrop\") if K not in kc else (\"Kempe\", \"PlateauMove\")\n                return kc, move\n        # Label swap diversify\n        labels = list(range(1, K+1))\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            swapped = [b if x == a else (a if x == b else x) for x in s]\n            swapped = normalize_colors(swapped)\n            return swapped, (\"ColorSwap\", \"LabelDiversify\")\n        return s[:], (\"NoOp\", \"Stable\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def edges():\n        return [\n            (1,2),(1,3),(1,4),(1,8),(1,9),\n            (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,6),(3,7),(3,9),\n            (4,7),\n            (5,6),(5,7),(5,8),(5,9),\n            (7,8),(7,9),\n            (8,9)\n        ]\n    def build_adj(n: int = 9):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges():\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def normalize_colors(sol: List[int]) -> List[int]:\n        remap = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nextc\n                nextc += 1\n            out.append(remap[c])\n        return out\n    def conflict_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n        n = len(sol)\n        conflict = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    conflict[u] = True\n                    conflict[v] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n\n    # Sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n\n    s = normalize_colors(s)\n    adj = build_adj(9)\n    K = max(s)\n\n    confs = conflict_vertices(s, adj)\n    steps = min(8, 4 + (len(confs) if confs else 0))\n\n    # Focus on hardest vertices: conflicts first, then max color class\n    focus = confs if confs else [i for i,c in enumerate(s) if c == K]\n    if not focus:\n        focus = list(range(9))\n\n    for _ in range(steps):\n        v = random.choice(focus)\n        neighbor_colors = {s[nb] for nb in adj[v]}\n        palette = list(range(1, max(K, max(s))+1))\n        if confs and random.random() < 0.15:\n            palette.append(max(K, max(s))+1)\n        # choose least-conflict color locally\n        best_col = s[v]\n        best_cnt = 10**9\n        for col in palette:\n            cnt = sum(1 for nb in adj[v] if s[nb] == col)\n            if cnt < best_cnt or (cnt == best_cnt and col < best_col):\n                best_cnt = cnt\n                best_col = col\n        s[v] = best_col\n        K = max(K, s[v])\n\n    # Random relabel to escape symmetry\n    labels = list(range(1, K+1))\n    random.shuffle(labels)\n    relabel = {i+1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001780523}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_JSON; entries are positive integers representing colors for vertices 1..9 (indices 0..8). Example: [1,2,3,4,4,1,1,3,2]","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded graph definition\n    E = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: minimize K, with strong penalty for conflicts\n    K = max(solution)\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers\n    def edges():\n        return [\n            (1,2),(1,3),(1,4),(1,8),(1,9),\n            (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,6),(3,7),(3,9),\n            (4,7),\n            (5,6),(5,7),(5,8),(5,9),\n            (7,8),(7,9),\n            (8,9)\n        ]\n    def build_adj(n: int = 9):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges():\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def normalize_colors(sol: List[int]) -> List[int]:\n        remap = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nextc\n                nextc += 1\n            out.append(remap[c])\n        return out\n    def conflict_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n        n = len(sol)\n        conflict = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    conflict[u] = True\n                    conflict[v] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n    def delta_conflicts_for_vertex(sol: List[int], adj: List[List[int]], v: int, new_color: int) -> int:\n        # Returns number of conflicting edges incident to v after recoloring v with new_color\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb] == new_color:\n                cnt += 1\n        return cnt\n    def kempe_chain_swap(sol: List[int], adj: List[List[int]], a: int, b: int, start_v: int) -> List[int]:\n        n = len(sol)\n        if sol[start_v] not in (a,b):\n            return sol[:]\n        stack = [start_v]\n        visited = [False]*n\n        visited[start_v] = True\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and sol[y] in (a,b):\n                    visited[y] = True\n                    stack.append(y)\n        new_sol = sol[:]\n        for v in comp:\n            new_sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return new_sol\n\n    # Defensive sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n    s = normalize_colors(s)\n\n    adj = build_adj(9)\n    K = max(s)\n\n    conf_vs = conflict_vertices(s, adj)\n\n    if conf_vs:\n        # Choose a conflicting vertex with highest degree in conflict neighborhood\n        v = max(conf_vs, key=lambda x: sum(1 for nb in adj[x] if s[nb] == s[x]))\n        palette = list(range(1, K+1))\n        if random.random() < 0.05:\n            palette.append(K+1)\n        best_col = s[v]\n        best_cnt = 10**9\n        for col in palette:\n            cnt = delta_conflicts_for_vertex(s, adj, v, col)\n            if cnt < best_cnt or (cnt == best_cnt and col < best_col):\n                best_cnt = cnt\n                best_col = col\n        new_s = s[:]\n        new_s[v] = best_col\n        new_s = normalize_colors(new_s)\n        return new_s, (\"VertexRecolor\", \"ConflictGreedyDelta\")\n    else:\n        # Feasible: deterministic K-drop attempt\n        max_vertices = [i for i,c in enumerate(s) if c == K]\n        # Try to push each K-vertex to lowest feasible color\n        changed = False\n        new_s = s[:]\n        for v in max_vertices:\n            neighbor_colors = {new_s[nb] for nb in adj[v]}\n            for col in range(1, K):\n                if col not in neighbor_colors:\n                    new_s[v] = col\n                    changed = True\n                    break\n        if changed:\n            new_s = normalize_colors(new_s)\n            move = (\"VertexRecolor\", \"KDropGreedy\") if K not in new_s else (\"VertexRecolor\", \"KConserveGreedy\")\n            return new_s, move\n        # Targeted Kempe-chain between K and best lower color to free K\n        if max_vertices and K > 1:\n            # Choose lower color that minimizes intersections\n            lower_colors = list(range(1, K))\n            best_c = min(lower_colors, key=lambda c: sum(1 for v in max_vertices for nb in adj[v] if s[nb]==c))\n            v = random.choice(max_vertices)\n            kc = kempe_chain_swap(s, adj, K, best_c, v)\n            kc = normalize_colors(kc)\n            if kc != s:\n                move = (\"Kempe\", \"KDrop\") if K not in kc else (\"Kempe\", \"PlateauMove\")\n                return kc, move\n        # Label swap diversify\n        labels = list(range(1, K+1))\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            swapped = [b if x == a else (a if x == b else x) for x in s]\n            swapped = normalize_colors(swapped)\n            return swapped, (\"ColorSwap\", \"LabelDiversify\")\n        return s[:], (\"NoOp\", \"Stable\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def edges():\n        return [\n            (1,2),(1,3),(1,4),(1,8),(1,9),\n            (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,6),(3,7),(3,9),\n            (4,7),\n            (5,6),(5,7),(5,8),(5,9),\n            (7,8),(7,9),\n            (8,9)\n        ]\n    def build_adj(n: int = 9):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges():\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def normalize_colors(sol: List[int]) -> List[int]:\n        remap = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nextc\n                nextc += 1\n            out.append(remap[c])\n        return out\n    def conflict_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n        n = len(sol)\n        conflict = [False]*n\n        for u in range(n):\n            cu = sol[u]\n            for v in adj[u]:\n                if v > u and cu == sol[v]:\n                    conflict[u] = True\n                    conflict[v] = True\n        return [i for i,flag in enumerate(conflict) if flag]\n\n    # Sanitize\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1,2,3,4,4,1,1,3,2]\n    else:\n        s = [c if isinstance(c, int) and c > 0 else 1 for c in solution]\n\n    s = normalize_colors(s)\n    adj = build_adj(9)\n    K = max(s)\n\n    confs = conflict_vertices(s, adj)\n    steps = min(8, 4 + (len(confs) if confs else 0))\n\n    # Focus on hardest vertices: conflicts first, then max color class\n    focus = confs if confs else [i for i,c in enumerate(s) if c == K]\n    if not focus:\n        focus = list(range(9))\n\n    for _ in range(steps):\n        v = random.choice(focus)\n        neighbor_colors = {s[nb] for nb in adj[v]}\n        palette = list(range(1, max(K, max(s))+1))\n        if confs and random.random() < 0.15:\n            palette.append(max(K, max(s))+1)\n        # choose least-conflict color locally\n        best_col = s[v]\n        best_cnt = 10**9\n        for col in palette:\n            cnt = sum(1 for nb in adj[v] if s[nb] == col)\n            if cnt < best_cnt or (cnt == best_cnt and col < best_col):\n                best_cnt = cnt\n                best_col = col\n        s[v] = best_col\n        K = max(K, s[v])\n\n    # Random relabel to escape symmetry\n    labels = list(range(1, K+1))\n    random.shuffle(labels)\n    relabel = {i+1: labels[i] for i in range(len(labels))}\n    s = [relabel.get(c, c) for c in s]\n\n    s = normalize_colors(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002051436}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9  \/\/ Colors for vertices [1..9] in order; each int >=1; objective minimizes max color used subject to no-edge-conflicts.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    if not isinstance(solution, list):\n        return 10_000_000\n    if len(solution) != n:\n        return 10_000_000 + 1_000_000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int):\n            return 10_000_000\n        if c < 1:\n            return 10_000_000\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty to enforce feasibility first; smaller is better\n        return 1_000_000 + conflicts\n    # Proper coloring: fitness = number of colors used (minimize)\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by either fixing a conflict or attempting color reduction.\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Defensive copy\n    if not isinstance(solution, list):\n        # Return a default feasible-length list to allow recovery\n        sol = [1]*n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1]* (n-len(solution)))\n    # Ensure ints >=1\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting edge, recolor one endpoint\n        u, v = random.choice(conflicts)\n        target = u if random.random() < 0.5 else v\n        # Try smallest feasible color starting from 1\n        forbidden = {sol[w-1] for (a, b) in edges for w in ((a if b == target else None), (b if a == target else None)) if w is not None}\n        new_color = 1\n        while new_color in forbidden:\n            new_color += 1\n        sol[target-1] = new_color\n        return (sol, \"Recolor\", \"Conflict-Directed\")\n    else:\n        # No conflicts: try to reduce number of colors by recoloring a max-color vertex\n        current_max = max(sol) if sol else 1\n        max_vertices = [i+1 for i, c in enumerate(sol) if c == current_max]\n        if max_vertices:\n            target = random.choice(max_vertices)\n            # Determine feasible colors excluding neighbors\n            neighbor_colors = set()\n            for (u, v) in edges:\n                if u == target:\n                    neighbor_colors.add(sol[v-1])\n                elif v == target:\n                    neighbor_colors.add(sol[u-1])\n            # Try to assign the smallest color < current_max not in neighbor colors\n            candidate_colors = [c for c in range(1, current_max) if c not in neighbor_colors]\n            if candidate_colors:\n                sol[target-1] = random.choice(candidate_colors)\n                return (sol, \"Recolor\", \"MaxColor-Reduction\")\n        # Otherwise perform a mild perturbative swap of colors of two random vertices to explore\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return (sol, \"Swap\", \"Exploration\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: remap a random subset of vertices to feasible low colors; preserves feasibility when possible.\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    if not isinstance(solution, list):\n        sol = [1]*n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1]* (n-len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Select subset to perturb\n    m = max(2, n \/\/ 3)\n    indices = random.sample(range(n), m)\n\n    # For each selected vertex, try to assign a random feasible color from a small palette\n    base_palette = list(range(1, max(4, min(6, max(sol)))))\n    random.shuffle(base_palette)\n\n    for idx in indices:\n        # Collect neighbor colors\n        neighbor_colors = set()\n        v = idx + 1\n        for (u, w) in edges:\n            if u == v:\n                neighbor_colors.add(sol[w-1])\n            elif w == v:\n                neighbor_colors.add(sol[u-1])\n        feasible = [c for c in base_palette if c not in neighbor_colors]\n        if feasible:\n            sol[idx] = random.choice(feasible)\n        else:\n            # Fallback: increment color to escape local minima\n            sol[idx] = max(sol) + 1\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000745778}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9  \/\/ Colors for vertices [1..9] in order; each int >=1; objective minimizes max color used subject to no-edge-conflicts.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    if not isinstance(solution, list):\n        return 10_000_000\n    if len(solution) != n:\n        return 10_000_000 + 1_000_000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int):\n            return 10_000_000\n        if c < 1:\n            return 10_000_000\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty to enforce feasibility first; smaller is better\n        return 1_000_000 + conflicts\n    # Proper coloring: fitness = number of colors used (minimize)\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by either fixing a conflict or attempting color reduction.\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Defensive copy\n    if not isinstance(solution, list):\n        # Return a default feasible-length list to allow recovery\n        sol = [1]*n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1]* (n-len(solution)))\n    # Ensure ints >=1\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting edge, recolor one endpoint\n        u, v = random.choice(conflicts)\n        target = u if random.random() < 0.5 else v\n        # Try smallest feasible color starting from 1\n        forbidden = {sol[w-1] for (a, b) in edges for w in ((a if b == target else None), (b if a == target else None)) if w is not None}\n        new_color = 1\n        while new_color in forbidden:\n            new_color += 1\n        sol[target-1] = new_color\n        return (sol, \"Recolor\", \"Conflict-Directed\")\n    else:\n        # No conflicts: try to reduce number of colors by recoloring a max-color vertex\n        current_max = max(sol) if sol else 1\n        max_vertices = [i+1 for i, c in enumerate(sol) if c == current_max]\n        if max_vertices:\n            target = random.choice(max_vertices)\n            # Determine feasible colors excluding neighbors\n            neighbor_colors = set()\n            for (u, v) in edges:\n                if u == target:\n                    neighbor_colors.add(sol[v-1])\n                elif v == target:\n                    neighbor_colors.add(sol[u-1])\n            # Try to assign the smallest color < current_max not in neighbor colors\n            candidate_colors = [c for c in range(1, current_max) if c not in neighbor_colors]\n            if candidate_colors:\n                sol[target-1] = random.choice(candidate_colors)\n                return (sol, \"Recolor\", \"MaxColor-Reduction\")\n        # Otherwise perform a mild perturbative swap of colors of two random vertices to explore\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return (sol, \"Swap\", \"Exploration\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: remap a random subset of vertices to feasible low colors; preserves feasibility when possible.\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    if not isinstance(solution, list):\n        sol = [1]*n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1]* (n-len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Select subset to perturb\n    m = max(2, n \/\/ 3)\n    indices = random.sample(range(n), m)\n\n    # For each selected vertex, try to assign a random feasible color from a small palette\n    base_palette = list(range(1, max(4, min(6, max(sol)))))\n    random.shuffle(base_palette)\n\n    for idx in indices:\n        # Collect neighbor colors\n        neighbor_colors = set()\n        v = idx + 1\n        for (u, w) in edges:\n            if u == v:\n                neighbor_colors.add(sol[w-1])\n            elif w == v:\n                neighbor_colors.add(sol[u-1])\n        feasible = [c for c in base_palette if c not in neighbor_colors]\n        if feasible:\n            sol[idx] = random.choice(feasible)\n        else:\n            # Fallback: increment color to escape local minima\n            sol[idx] = max(sol) + 1\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001029722}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9  \/\/ Colors for vertices [1..9] in order; each int >=1; objective minimizes max color used subject to no-edge-conflicts.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    if not isinstance(solution, list):\n        return 10_000_000\n    if len(solution) != n:\n        return 10_000_000 + 1_000_000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int):\n            return 10_000_000\n        if c < 1:\n            return 10_000_000\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty to enforce feasibility first; smaller is better\n        return 1_000_000 + conflicts\n    # Proper coloring: fitness = number of colors used (minimize)\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by either fixing a conflict or attempting color reduction.\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Defensive copy\n    if not isinstance(solution, list):\n        # Return a default feasible-length list to allow recovery\n        sol = [1]*n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1]* (n-len(solution)))\n    # Ensure ints >=1\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting edge, recolor one endpoint\n        u, v = random.choice(conflicts)\n        target = u if random.random() < 0.5 else v\n        # Try smallest feasible color starting from 1\n        forbidden = {sol[w-1] for (a, b) in edges for w in ((a if b == target else None), (b if a == target else None)) if w is not None}\n        new_color = 1\n        while new_color in forbidden:\n            new_color += 1\n        sol[target-1] = new_color\n        return (sol, \"Recolor\", \"Conflict-Directed\")\n    else:\n        # No conflicts: try to reduce number of colors by recoloring a max-color vertex\n        current_max = max(sol) if sol else 1\n        max_vertices = [i+1 for i, c in enumerate(sol) if c == current_max]\n        if max_vertices:\n            target = random.choice(max_vertices)\n            # Determine feasible colors excluding neighbors\n            neighbor_colors = set()\n            for (u, v) in edges:\n                if u == target:\n                    neighbor_colors.add(sol[v-1])\n                elif v == target:\n                    neighbor_colors.add(sol[u-1])\n            # Try to assign the smallest color < current_max not in neighbor colors\n            candidate_colors = [c for c in range(1, current_max) if c not in neighbor_colors]\n            if candidate_colors:\n                sol[target-1] = random.choice(candidate_colors)\n                return (sol, \"Recolor\", \"MaxColor-Reduction\")\n        # Otherwise perform a mild perturbative swap of colors of two random vertices to explore\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return (sol, \"Swap\", \"Exploration\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: remap a random subset of vertices to feasible low colors; preserves feasibility when possible.\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    if not isinstance(solution, list):\n        sol = [1]*n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1]* (n-len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Select subset to perturb\n    m = max(2, n \/\/ 3)\n    indices = random.sample(range(n), m)\n\n    # For each selected vertex, try to assign a random feasible color from a small palette\n    base_palette = list(range(1, max(4, min(6, max(sol)))))\n    random.shuffle(base_palette)\n\n    for idx in indices:\n        # Collect neighbor colors\n        neighbor_colors = set()\n        v = idx + 1\n        for (u, w) in edges:\n            if u == v:\n                neighbor_colors.add(sol[w-1])\n            elif w == v:\n                neighbor_colors.add(sol[u-1])\n        feasible = [c for c in base_palette if c not in neighbor_colors]\n        if feasible:\n            sol[idx] = random.choice(feasible)\n        else:\n            # Fallback: increment color to escape local minima\n            sol[idx] = max(sol) + 1\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000862129}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9. List[int] of length 9 giving colors for vertices 1..9 respectively; each int >= 1. Objective: minimize max color used subject to no equal colors on endpoints of any edge.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Type and size guard\/repair\n    if not isinstance(solution, list):\n        return 10_000_000\n    if len(solution) != n:\n        return 10_000_000 + 1_000_000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10_000_000\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 1_000_000 + conflicts  # smaller is better; heavy penalty for infeasibility\n    # Proper coloring: minimize number of colors used\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    return k\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Repair\/normalize input to valid list[int] length n\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Build adjacency list\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Identify conflicts and per-vertex conflict counts\n    conflicts = []\n    conflict_count = [0] * (n + 1)\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n\n    def compress_colors(arr):\n        # Relabel colors to 1..m preserving equality\n        mapping = {}\n        next_c = 1\n        for c in sorted(set(arr)):\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in arr]\n\n    if conflicts:\n        # Conflict-directed recolor: pick vertex with max conflicts among a random conflicting edge\n        u, v = random.choice(conflicts)\n        target = u if conflict_count[u] >= conflict_count[v] else v\n        used = {sol[w-1] for w in adj[target]}\n        current_max = max(sol) if sol else 1\n        # Prefer colors within current palette to avoid growth\n        candidate = None\n        for c in range(1, current_max + 1):\n            if c not in used:\n                candidate = c\n                break\n        if candidate is None:\n            candidate = current_max + 1\n        sol[target-1] = candidate\n        sol = compress_colors(sol)\n        return sol\n    else:\n        # Feasible: attempt color reduction via recolor or Kempe-chain on max color class\n        M = max(sol) if sol else 1\n        max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n        if max_vertices:\n            v = random.choice(max_vertices)\n            neighbor_colors = {sol[w-1] for w in adj[v]}\n            # Try direct recolor to any color < M not in neighbor colors\n            candidates = [c for c in range(1, M) if c not in neighbor_colors]\n            if candidates:\n                sol[v-1] = random.choice(candidates)\n                sol = compress_colors(sol)\n                return sol\n            # Try Kempe-chain interchange between colors (M, c)\n            palette = list(range(1, M))\n            random.shuffle(palette)\n            for c in palette:\n                # Build subgraph induced by colors {M, c}\n                allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n                # BFS from v restricted to allowed set\n                stack = [v]\n                comp = set([v])\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y in allowed and y not in comp and ((sol[x-1] == M and sol[y-1] == c) or (sol[x-1] == c and sol[y-1] == M) or (sol[x-1] == sol[y-1])):\n                            comp.add(y)\n                            stack.append(y)\n                # Swap colors on this component\n                for w in comp:\n                    sol[w-1] = M if sol[w-1] == c else (c if sol[w-1] == M else sol[w-1])\n                # After swap, try recolor v away from M\n                neighbor_colors = {sol[w-1] for w in adj[v]}\n                candidates2 = [cc for cc in range(1, M) if cc not in neighbor_colors]\n                if candidates2:\n                    sol[v-1] = random.choice(candidates2)\n                    sol = compress_colors(sol)\n                    return sol\n                # Revert swap if unsuccessful effect\n                for w in comp:\n                    sol[w-1] = M if sol[w-1] == c else (c if sol[w-1] == M else sol[w-1])\n        # Mild exploration: recolor a random vertex with smallest feasible color\n        idx = random.randrange(n)\n        vertex = idx + 1\n        used = {sol[w-1] for w in adj[vertex]}\n        new_color = 1\n        while new_color in used:\n            new_color += 1\n        sol[vertex-1] = new_color\n        sol = compress_colors(sol)\n        return sol\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Repair\/normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(arr):\n        mapping = {}\n        next_c = 1\n        for c in sorted(set(arr)):\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in arr]\n\n    # Random subset recoloring\n    M = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    indices = random.sample(range(n), m)\n    base_palette = list(range(1, max(4, M)))\n    random.shuffle(base_palette)\n\n    for idx in indices:\n        v = idx + 1\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feas = [c for c in base_palette if c not in neighbor_colors]\n        if feas:\n            sol[idx] = random.choice(feas)\n        else:\n            sol[idx] = M + 1\n            M = max(M, sol[idx])\n\n    # Optional Kempe swap between two random colors to escape local minima\n    M = max(sol)\n    if M >= 2 and random.random() < 0.7:\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if allowed:\n            # pick random seed vertex from allowed and swap its component\n            seed = random.choice(list(allowed))\n            stack = [seed]\n            comp = set([seed])\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and ((sol[x-1] == c1 and sol[y-1] == c2) or (sol[x-1] == c2 and sol[y-1] == c1) or (sol[x-1] == sol[y-1])):\n                        comp.add(y)\n                        stack.append(y)\n            for w in comp:\n                sol[w-1] = c1 if sol[w-1] == c2 else (c2 if sol[w-1] == c1 else sol[w-1])\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001126033}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9. List[int] of length 9 giving colors for vertices 1..9 respectively; each int >= 1. Objective: minimize max color used subject to no equal colors on endpoints of any edge.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Type and size guard\/repair\n    if not isinstance(solution, list):\n        return 10_000_000\n    if len(solution) != n:\n        return 10_000_000 + 1_000_000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10_000_000\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 1_000_000 + conflicts  # smaller is better; heavy penalty for infeasibility\n    # Proper coloring: minimize number of colors used\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    return k\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Repair\/normalize input to valid list[int] length n\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Build adjacency list\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Identify conflicts and per-vertex conflict counts\n    conflicts = []\n    conflict_count = [0] * (n + 1)\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n\n    def compress_colors(arr):\n        # Relabel colors to 1..m preserving equality\n        mapping = {}\n        next_c = 1\n        for c in sorted(set(arr)):\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in arr]\n\n    if conflicts:\n        # Conflict-directed recolor: pick vertex with max conflicts among a random conflicting edge\n        u, v = random.choice(conflicts)\n        target = u if conflict_count[u] >= conflict_count[v] else v\n        used = {sol[w-1] for w in adj[target]}\n        current_max = max(sol) if sol else 1\n        # Prefer colors within current palette to avoid growth\n        candidate = None\n        for c in range(1, current_max + 1):\n            if c not in used:\n                candidate = c\n                break\n        if candidate is None:\n            candidate = current_max + 1\n        sol[target-1] = candidate\n        sol = compress_colors(sol)\n        return sol\n    else:\n        # Feasible: attempt color reduction via recolor or Kempe-chain on max color class\n        M = max(sol) if sol else 1\n        max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n        if max_vertices:\n            v = random.choice(max_vertices)\n            neighbor_colors = {sol[w-1] for w in adj[v]}\n            # Try direct recolor to any color < M not in neighbor colors\n            candidates = [c for c in range(1, M) if c not in neighbor_colors]\n            if candidates:\n                sol[v-1] = random.choice(candidates)\n                sol = compress_colors(sol)\n                return sol\n            # Try Kempe-chain interchange between colors (M, c)\n            palette = list(range(1, M))\n            random.shuffle(palette)\n            for c in palette:\n                # Build subgraph induced by colors {M, c}\n                allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n                # BFS from v restricted to allowed set\n                stack = [v]\n                comp = set([v])\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y in allowed and y not in comp and ((sol[x-1] == M and sol[y-1] == c) or (sol[x-1] == c and sol[y-1] == M) or (sol[x-1] == sol[y-1])):\n                            comp.add(y)\n                            stack.append(y)\n                # Swap colors on this component\n                for w in comp:\n                    sol[w-1] = M if sol[w-1] == c else (c if sol[w-1] == M else sol[w-1])\n                # After swap, try recolor v away from M\n                neighbor_colors = {sol[w-1] for w in adj[v]}\n                candidates2 = [cc for cc in range(1, M) if cc not in neighbor_colors]\n                if candidates2:\n                    sol[v-1] = random.choice(candidates2)\n                    sol = compress_colors(sol)\n                    return sol\n                # Revert swap if unsuccessful effect\n                for w in comp:\n                    sol[w-1] = M if sol[w-1] == c else (c if sol[w-1] == M else sol[w-1])\n        # Mild exploration: recolor a random vertex with smallest feasible color\n        idx = random.randrange(n)\n        vertex = idx + 1\n        used = {sol[w-1] for w in adj[vertex]}\n        new_color = 1\n        while new_color in used:\n            new_color += 1\n        sol[vertex-1] = new_color\n        sol = compress_colors(sol)\n        return sol\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Repair\/normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(arr):\n        mapping = {}\n        next_c = 1\n        for c in sorted(set(arr)):\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in arr]\n\n    # Random subset recoloring\n    M = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    indices = random.sample(range(n), m)\n    base_palette = list(range(1, max(4, M)))\n    random.shuffle(base_palette)\n\n    for idx in indices:\n        v = idx + 1\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feas = [c for c in base_palette if c not in neighbor_colors]\n        if feas:\n            sol[idx] = random.choice(feas)\n        else:\n            sol[idx] = M + 1\n            M = max(M, sol[idx])\n\n    # Optional Kempe swap between two random colors to escape local minima\n    M = max(sol)\n    if M >= 2 and random.random() < 0.7:\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if allowed:\n            # pick random seed vertex from allowed and swap its component\n            seed = random.choice(list(allowed))\n            stack = [seed]\n            comp = set([seed])\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and ((sol[x-1] == c1 and sol[y-1] == c2) or (sol[x-1] == c2 and sol[y-1] == c1) or (sol[x-1] == sol[y-1])):\n                        comp.add(y)\n                        stack.append(y)\n            for w in comp:\n                sol[w-1] = c1 if sol[w-1] == c2 else (c2 if sol[w-1] == c1 else sol[w-1])\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001357385}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9. List[int] of length 9 giving colors for vertices 1..9 respectively; each int >= 1. Objective: minimize max color used subject to no equal colors on endpoints of any edge.","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Type and size guard\/repair\n    if not isinstance(solution, list):\n        return 10_000_000\n    if len(solution) != n:\n        return 10_000_000 + 1_000_000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10_000_000\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 1_000_000 + conflicts  # smaller is better; heavy penalty for infeasibility\n    # Proper coloring: minimize number of colors used\n    k = 0\n    for c in solution:\n        if c > k:\n            k = c\n    return k\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Repair\/normalize input to valid list[int] length n\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Build adjacency list\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Identify conflicts and per-vertex conflict counts\n    conflicts = []\n    conflict_count = [0] * (n + 1)\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n\n    def compress_colors(arr):\n        # Relabel colors to 1..m preserving equality\n        mapping = {}\n        next_c = 1\n        for c in sorted(set(arr)):\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in arr]\n\n    if conflicts:\n        # Conflict-directed recolor: pick vertex with max conflicts among a random conflicting edge\n        u, v = random.choice(conflicts)\n        target = u if conflict_count[u] >= conflict_count[v] else v\n        used = {sol[w-1] for w in adj[target]}\n        current_max = max(sol) if sol else 1\n        # Prefer colors within current palette to avoid growth\n        candidate = None\n        for c in range(1, current_max + 1):\n            if c not in used:\n                candidate = c\n                break\n        if candidate is None:\n            candidate = current_max + 1\n        sol[target-1] = candidate\n        sol = compress_colors(sol)\n        return sol\n    else:\n        # Feasible: attempt color reduction via recolor or Kempe-chain on max color class\n        M = max(sol) if sol else 1\n        max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n        if max_vertices:\n            v = random.choice(max_vertices)\n            neighbor_colors = {sol[w-1] for w in adj[v]}\n            # Try direct recolor to any color < M not in neighbor colors\n            candidates = [c for c in range(1, M) if c not in neighbor_colors]\n            if candidates:\n                sol[v-1] = random.choice(candidates)\n                sol = compress_colors(sol)\n                return sol\n            # Try Kempe-chain interchange between colors (M, c)\n            palette = list(range(1, M))\n            random.shuffle(palette)\n            for c in palette:\n                # Build subgraph induced by colors {M, c}\n                allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n                # BFS from v restricted to allowed set\n                stack = [v]\n                comp = set([v])\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y in allowed and y not in comp and ((sol[x-1] == M and sol[y-1] == c) or (sol[x-1] == c and sol[y-1] == M) or (sol[x-1] == sol[y-1])):\n                            comp.add(y)\n                            stack.append(y)\n                # Swap colors on this component\n                for w in comp:\n                    sol[w-1] = M if sol[w-1] == c else (c if sol[w-1] == M else sol[w-1])\n                # After swap, try recolor v away from M\n                neighbor_colors = {sol[w-1] for w in adj[v]}\n                candidates2 = [cc for cc in range(1, M) if cc not in neighbor_colors]\n                if candidates2:\n                    sol[v-1] = random.choice(candidates2)\n                    sol = compress_colors(sol)\n                    return sol\n                # Revert swap if unsuccessful effect\n                for w in comp:\n                    sol[w-1] = M if sol[w-1] == c else (c if sol[w-1] == M else sol[w-1])\n        # Mild exploration: recolor a random vertex with smallest feasible color\n        idx = random.randrange(n)\n        vertex = idx + 1\n        used = {sol[w-1] for w in adj[vertex]}\n        new_color = 1\n        while new_color in used:\n            new_color += 1\n        sol[vertex-1] = new_color\n        sol = compress_colors(sol)\n        return sol\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Repair\/normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(arr):\n        mapping = {}\n        next_c = 1\n        for c in sorted(set(arr)):\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in arr]\n\n    # Random subset recoloring\n    M = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    indices = random.sample(range(n), m)\n    base_palette = list(range(1, max(4, M)))\n    random.shuffle(base_palette)\n\n    for idx in indices:\n        v = idx + 1\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feas = [c for c in base_palette if c not in neighbor_colors]\n        if feas:\n            sol[idx] = random.choice(feas)\n        else:\n            sol[idx] = M + 1\n            M = max(M, sol[idx])\n\n    # Optional Kempe swap between two random colors to escape local minima\n    M = max(sol)\n    if M >= 2 and random.random() < 0.7:\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if allowed:\n            # pick random seed vertex from allowed and swap its component\n            seed = random.choice(list(allowed))\n            stack = [seed]\n            comp = set([seed])\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and ((sol[x-1] == c1 and sol[y-1] == c2) or (sol[x-1] == c2 and sol[y-1] == c1) or (sol[x-1] == sol[y-1])):\n                        comp.add(y)\n                        stack.append(y)\n            for w in comp:\n                sol[w-1] = c1 if sol[w-1] == c2 else (c2 if sol[w-1] == c1 else sol[w-1])\n\n    sol = compress_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001333716}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9. List[int] of length 9 giving colors for vertices 1..9 respectively; each int >= 1. Objective: minimize max color used subject to no equal colors on endpoints of any edge.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Guards\n    if not isinstance(solution, list):\n        return 10000000\n    if len(solution) != n:\n        return 10000000 + 1000000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10000000\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: lexicographic via scalarization\n    max_color = 0\n    for c in solution:\n        if c > max_color:\n            max_color = c\n    if conflicts > 0:\n        return conflicts * 10000 + max_color\n    return max_color\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize input\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def stable_compress(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    M = max(sol) if sol else 1\n\n    # Identify conflicts and per-vertex conflict counts\n    conflict_edges = []\n    conflict_count = [0] * (n + 1)\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflict_edges.append((u, v))\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n\n    move_info = {\"type\": None}\n\n    if conflict_edges:\n        # Pick vertex with max conflicts overall\n        target = max(range(1, n+1), key=lambda x: conflict_count[x])\n        neighbor_colors = {sol[w-1] for w in adj[target]}\n        # Evaluate feasible colors up to M first, prefer min conflicts then smallest color\n        best_c = None\n        best_score = (10**9, 10**9)\n        for c in range(1, M+1):\n            tmp = sol[:]\n            tmp[target-1] = c\n            conf = count_conflicts(tmp)\n            score = (conf, c)\n            if score < best_score and c not in neighbor_colors:\n                best_score = score\n                best_c = c\n        if best_c is None:\n            # No feasible within 1..M; try min-conflict color within 1..M anyway\n            for c in range(1, M+1):\n                tmp = sol[:]\n                tmp[target-1] = c\n                conf = count_conflicts(tmp)\n                score = (conf, c)\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n        if best_c is None:\n            best_c = M + 1\n        old_c = sol[target-1]\n        sol[target-1] = best_c\n        sol = stable_compress(sol)\n        move_info = {\"type\": \"recolor_conflict\", \"vertex\": target, \"from\": old_c, \"to\": sol[target-1]}\n        return sol, move_info\n\n    # Feasible: try to reduce max color\n    M = max(sol) if sol else 1\n    max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        candidates = [c for c in range(1, M) if c not in neighbor_colors]\n        if candidates:\n            old = sol[v-1]\n            sol[v-1] = min(candidates)\n            sol = stable_compress(sol)\n            move_info = {\"type\": \"reduce_direct\", \"vertex\": v, \"from\": old, \"to\": sol[v-1]}\n            return sol, move_info\n        # Kempe chain swap between (M, c)\n        palette = list(range(1, M))\n        random.shuffle(palette)\n        for c in palette:\n            # Build alternating component containing v in subgraph induced by colors {M,c}\n            if sol[v-1] != M:\n                continue\n            allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n            if v not in allowed:\n                continue\n            stack = [v]\n            comp = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            # Swap colors on component\n            for w in comp:\n                if sol[w-1] == M:\n                    sol[w-1] = c\n                elif sol[w-1] == c:\n                    sol[w-1] = M\n            # Try recolor v now\n            neighbor_colors = {sol[w-1] for w in adj[v]}\n            candidates2 = [cc for cc in range(1, M) if cc not in neighbor_colors]\n            if candidates2:\n                old = M\n                sol[v-1] = min(candidates2)\n                sol = stable_compress(sol)\n                move_info = {\"type\": \"kempe_reduce\", \"vertex\": v, \"from\": old, \"to\": sol[v-1], \"pair\": (M, c)}\n                return sol, move_info\n            # Revert swap if ineffective\n            for w in comp:\n                if sol[w-1] == c:\n                    sol[w-1] = M\n                elif sol[w-1] == M:\n                    sol[w-1] = c\n    # Mild exploration without increasing palette when possible\n    idx = random.randrange(n)\n    vertex = idx + 1\n    used = {sol[w-1] for w in adj[vertex]}\n    new_color = None\n    for cc in range(1, max(sol)+1):\n        if cc not in used:\n            new_color = cc\n            break\n    if new_color is None:\n        new_color = max(sol)  # keep palette stable\n    old = sol[vertex-1]\n    sol[vertex-1] = new_color\n    sol = stable_compress(sol)\n    move_info = {\"type\": \"explore\", \"vertex\": vertex, \"from\": old, \"to\": sol[vertex-1]}\n    return sol, move_info\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def stable_compress(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_vertices(arr):\n        bad = set()\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u); bad.add(v)\n        return bad\n\n    M = max(sol) if sol else 1\n    bad = list(conflict_vertices(sol))\n\n    # Choose shake set: mix of max-color class and conflict vertices\n    max_class = [i+1 for i, c in enumerate(sol) if c == M]\n    pool = list(set(max_class + bad))\n    if not pool:\n        pool = list(range(1, n+1))\n    k = max(3, min(len(pool), 4))\n    chosen = random.sample(pool, k)\n\n    # Recolor chosen vertices with random feasible colors from a bounded palette\n    base_palette = list(range(1, max(4, M)))\n    random.shuffle(base_palette)\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feas = [c for c in base_palette if c not in neighbor_colors]\n        if feas:\n            sol[v-1] = random.choice(feas)\n        else:\n            # fallback within current palette to avoid growth\n            sol[v-1] = random.randint(1, max(1, M))\n\n    # One random Kempe swap to diversify\n    M = max(sol) if sol else 1\n    if M >= 2:\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if allowed:\n            seed = random.choice(list(allowed))\n            stack = [seed]\n            comp = {seed}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            for w in comp:\n                if sol[w-1] == c1:\n                    sol[w-1] = c2\n                elif sol[w-1] == c2:\n                    sol[w-1] = c1\n\n    sol = stable_compress(sol)\n    return sol\n","Resultados":[[1,1,1,1,1,1,1,1,1],240001,[1,1,1,1,1,1,1,1,1],240001],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002034654}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9. List[int] of length 9 giving colors for vertices 1..9 respectively; each int >= 1. Objective: minimize max color used subject to no equal colors on endpoints of any edge.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Guards\n    if not isinstance(solution, list):\n        return 10000000\n    if len(solution) != n:\n        return 10000000 + 1000000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10000000\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: lexicographic via scalarization\n    max_color = 0\n    for c in solution:\n        if c > max_color:\n            max_color = c\n    if conflicts > 0:\n        return conflicts * 10000 + max_color\n    return max_color\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize input\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def stable_compress(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    M = max(sol) if sol else 1\n\n    # Identify conflicts and per-vertex conflict counts\n    conflict_edges = []\n    conflict_count = [0] * (n + 1)\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflict_edges.append((u, v))\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n\n    move_info = {\"type\": None}\n\n    if conflict_edges:\n        # Pick vertex with max conflicts overall\n        target = max(range(1, n+1), key=lambda x: conflict_count[x])\n        neighbor_colors = {sol[w-1] for w in adj[target]}\n        # Evaluate feasible colors up to M first, prefer min conflicts then smallest color\n        best_c = None\n        best_score = (10**9, 10**9)\n        for c in range(1, M+1):\n            tmp = sol[:]\n            tmp[target-1] = c\n            conf = count_conflicts(tmp)\n            score = (conf, c)\n            if score < best_score and c not in neighbor_colors:\n                best_score = score\n                best_c = c\n        if best_c is None:\n            # No feasible within 1..M; try min-conflict color within 1..M anyway\n            for c in range(1, M+1):\n                tmp = sol[:]\n                tmp[target-1] = c\n                conf = count_conflicts(tmp)\n                score = (conf, c)\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n        if best_c is None:\n            best_c = M + 1\n        old_c = sol[target-1]\n        sol[target-1] = best_c\n        sol = stable_compress(sol)\n        move_info = {\"type\": \"recolor_conflict\", \"vertex\": target, \"from\": old_c, \"to\": sol[target-1]}\n        return sol, move_info\n\n    # Feasible: try to reduce max color\n    M = max(sol) if sol else 1\n    max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        candidates = [c for c in range(1, M) if c not in neighbor_colors]\n        if candidates:\n            old = sol[v-1]\n            sol[v-1] = min(candidates)\n            sol = stable_compress(sol)\n            move_info = {\"type\": \"reduce_direct\", \"vertex\": v, \"from\": old, \"to\": sol[v-1]}\n            return sol, move_info\n        # Kempe chain swap between (M, c)\n        palette = list(range(1, M))\n        random.shuffle(palette)\n        for c in palette:\n            # Build alternating component containing v in subgraph induced by colors {M,c}\n            if sol[v-1] != M:\n                continue\n            allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n            if v not in allowed:\n                continue\n            stack = [v]\n            comp = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            # Swap colors on component\n            for w in comp:\n                if sol[w-1] == M:\n                    sol[w-1] = c\n                elif sol[w-1] == c:\n                    sol[w-1] = M\n            # Try recolor v now\n            neighbor_colors = {sol[w-1] for w in adj[v]}\n            candidates2 = [cc for cc in range(1, M) if cc not in neighbor_colors]\n            if candidates2:\n                old = M\n                sol[v-1] = min(candidates2)\n                sol = stable_compress(sol)\n                move_info = {\"type\": \"kempe_reduce\", \"vertex\": v, \"from\": old, \"to\": sol[v-1], \"pair\": (M, c)}\n                return sol, move_info\n            # Revert swap if ineffective\n            for w in comp:\n                if sol[w-1] == c:\n                    sol[w-1] = M\n                elif sol[w-1] == M:\n                    sol[w-1] = c\n    # Mild exploration without increasing palette when possible\n    idx = random.randrange(n)\n    vertex = idx + 1\n    used = {sol[w-1] for w in adj[vertex]}\n    new_color = None\n    for cc in range(1, max(sol)+1):\n        if cc not in used:\n            new_color = cc\n            break\n    if new_color is None:\n        new_color = max(sol)  # keep palette stable\n    old = sol[vertex-1]\n    sol[vertex-1] = new_color\n    sol = stable_compress(sol)\n    move_info = {\"type\": \"explore\", \"vertex\": vertex, \"from\": old, \"to\": sol[vertex-1]}\n    return sol, move_info\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def stable_compress(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_vertices(arr):\n        bad = set()\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u); bad.add(v)\n        return bad\n\n    M = max(sol) if sol else 1\n    bad = list(conflict_vertices(sol))\n\n    # Choose shake set: mix of max-color class and conflict vertices\n    max_class = [i+1 for i, c in enumerate(sol) if c == M]\n    pool = list(set(max_class + bad))\n    if not pool:\n        pool = list(range(1, n+1))\n    k = max(3, min(len(pool), 4))\n    chosen = random.sample(pool, k)\n\n    # Recolor chosen vertices with random feasible colors from a bounded palette\n    base_palette = list(range(1, max(4, M)))\n    random.shuffle(base_palette)\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feas = [c for c in base_palette if c not in neighbor_colors]\n        if feas:\n            sol[v-1] = random.choice(feas)\n        else:\n            # fallback within current palette to avoid growth\n            sol[v-1] = random.randint(1, max(1, M))\n\n    # One random Kempe swap to diversify\n    M = max(sol) if sol else 1\n    if M >= 2:\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if allowed:\n            seed = random.choice(list(allowed))\n            stack = [seed]\n            comp = {seed}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            for w in comp:\n                if sol[w-1] == c1:\n                    sol[w-1] = c2\n                elif sol[w-1] == c2:\n                    sol[w-1] = c1\n\n    sol = stable_compress(sol)\n    return sol\n","Resultados":[[1,2,1,2,2,3,1,3,3],240001,[1,2,3,2,1,1,1,3,2],30003],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.003385609}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9. List[int] of length 9 giving colors for vertices 1..9 respectively; each int >= 1. Objective: minimize max color used subject to no equal colors on endpoints of any edge.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Guards\n    if not isinstance(solution, list):\n        return 10000000\n    if len(solution) != n:\n        return 10000000 + 1000000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10000000\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: lexicographic via scalarization\n    max_color = 0\n    for c in solution:\n        if c > max_color:\n            max_color = c\n    if conflicts > 0:\n        return conflicts * 10000 + max_color\n    return max_color\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize input\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def stable_compress(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(arr):\n        cnt = 0\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    M = max(sol) if sol else 1\n\n    # Identify conflicts and per-vertex conflict counts\n    conflict_edges = []\n    conflict_count = [0] * (n + 1)\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflict_edges.append((u, v))\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n\n    move_info = {\"type\": None}\n\n    if conflict_edges:\n        # Pick vertex with max conflicts overall\n        target = max(range(1, n+1), key=lambda x: conflict_count[x])\n        neighbor_colors = {sol[w-1] for w in adj[target]}\n        # Evaluate feasible colors up to M first, prefer min conflicts then smallest color\n        best_c = None\n        best_score = (10**9, 10**9)\n        for c in range(1, M+1):\n            tmp = sol[:]\n            tmp[target-1] = c\n            conf = count_conflicts(tmp)\n            score = (conf, c)\n            if score < best_score and c not in neighbor_colors:\n                best_score = score\n                best_c = c\n        if best_c is None:\n            # No feasible within 1..M; try min-conflict color within 1..M anyway\n            for c in range(1, M+1):\n                tmp = sol[:]\n                tmp[target-1] = c\n                conf = count_conflicts(tmp)\n                score = (conf, c)\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n        if best_c is None:\n            best_c = M + 1\n        old_c = sol[target-1]\n        sol[target-1] = best_c\n        sol = stable_compress(sol)\n        move_info = {\"type\": \"recolor_conflict\", \"vertex\": target, \"from\": old_c, \"to\": sol[target-1]}\n        return sol, move_info\n\n    # Feasible: try to reduce max color\n    M = max(sol) if sol else 1\n    max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        candidates = [c for c in range(1, M) if c not in neighbor_colors]\n        if candidates:\n            old = sol[v-1]\n            sol[v-1] = min(candidates)\n            sol = stable_compress(sol)\n            move_info = {\"type\": \"reduce_direct\", \"vertex\": v, \"from\": old, \"to\": sol[v-1]}\n            return sol, move_info\n        # Kempe chain swap between (M, c)\n        palette = list(range(1, M))\n        random.shuffle(palette)\n        for c in palette:\n            # Build alternating component containing v in subgraph induced by colors {M,c}\n            if sol[v-1] != M:\n                continue\n            allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n            if v not in allowed:\n                continue\n            stack = [v]\n            comp = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            # Swap colors on component\n            for w in comp:\n                if sol[w-1] == M:\n                    sol[w-1] = c\n                elif sol[w-1] == c:\n                    sol[w-1] = M\n            # Try recolor v now\n            neighbor_colors = {sol[w-1] for w in adj[v]}\n            candidates2 = [cc for cc in range(1, M) if cc not in neighbor_colors]\n            if candidates2:\n                old = M\n                sol[v-1] = min(candidates2)\n                sol = stable_compress(sol)\n                move_info = {\"type\": \"kempe_reduce\", \"vertex\": v, \"from\": old, \"to\": sol[v-1], \"pair\": (M, c)}\n                return sol, move_info\n            # Revert swap if ineffective\n            for w in comp:\n                if sol[w-1] == c:\n                    sol[w-1] = M\n                elif sol[w-1] == M:\n                    sol[w-1] = c\n    # Mild exploration without increasing palette when possible\n    idx = random.randrange(n)\n    vertex = idx + 1\n    used = {sol[w-1] for w in adj[vertex]}\n    new_color = None\n    for cc in range(1, max(sol)+1):\n        if cc not in used:\n            new_color = cc\n            break\n    if new_color is None:\n        new_color = max(sol)  # keep palette stable\n    old = sol[vertex-1]\n    sol[vertex-1] = new_color\n    sol = stable_compress(sol)\n    move_info = {\"type\": \"explore\", \"vertex\": vertex, \"from\": old, \"to\": sol[vertex-1]}\n    return sol, move_info\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def stable_compress(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_vertices(arr):\n        bad = set()\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u); bad.add(v)\n        return bad\n\n    M = max(sol) if sol else 1\n    bad = list(conflict_vertices(sol))\n\n    # Choose shake set: mix of max-color class and conflict vertices\n    max_class = [i+1 for i, c in enumerate(sol) if c == M]\n    pool = list(set(max_class + bad))\n    if not pool:\n        pool = list(range(1, n+1))\n    k = max(3, min(len(pool), 4))\n    chosen = random.sample(pool, k)\n\n    # Recolor chosen vertices with random feasible colors from a bounded palette\n    base_palette = list(range(1, max(4, M)))\n    random.shuffle(base_palette)\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feas = [c for c in base_palette if c not in neighbor_colors]\n        if feas:\n            sol[v-1] = random.choice(feas)\n        else:\n            # fallback within current palette to avoid growth\n            sol[v-1] = random.randint(1, max(1, M))\n\n    # One random Kempe swap to diversify\n    M = max(sol) if sol else 1\n    if M >= 2:\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if allowed:\n            seed = random.choice(list(allowed))\n            stack = [seed]\n            comp = {seed}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            for w in comp:\n                if sol[w-1] == c1:\n                    sol[w-1] = c2\n                elif sol[w-1] == c2:\n                    sol[w-1] = c1\n\n    sol = stable_compress(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001795531}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9; indices 1..9 map to vertices 1..9; integers >=1 denote colors; objective: minimize max color with hard edge constraints.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Guards\n    if not isinstance(solution, list):\n        return 10000000\n    if len(solution) != n:\n        return 10000000 + 1000000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10000000\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: lexicographic via scalarization (feasible prioritized, then palette size)\n    max_color = 0\n    for c in solution:\n        if c > max_color:\n            max_color = c\n    if conflicts > 0:\n        return conflicts * 10000 + max_color\n    return max_color\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize input\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def palette_size(arr):\n        m = 0\n        for c in arr:\n            if c > m:\n                m = c\n        return m\n\n    def count_conflicts_for_vertex(arr, v):\n        c = arr[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if arr[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def total_conflicts(arr):\n        cnt = 0\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    M = palette_size(sol)\n\n    # Identify conflicts and per-vertex conflict counts\n    conflict_count = [0] * (n + 1)\n    any_conflict = False\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            any_conflict = True\n\n    if any_conflict:\n        # Select target with max conflicts; break ties by degree and slight randomness\n        candidates = list(range(1, n+1))\n        target = max(candidates, key=lambda x: (conflict_count[x], len(adj[x]), random.random()))\n        # Try recoloring with minimal local conflicts; avoid increasing palette\n        neighbor_colors = {sol[u-1] for u in adj[target]}\n        best_c = None\n        best = (10**9, 10**9)\n        # Evaluate colors 1..M using O(deg(v)) delta\n        color_freq = {}\n        for u in adj[target]:\n            cu = sol[u-1]\n            color_freq[cu] = color_freq.get(cu, 0) + 1\n        for c in range(1, M+1):\n            local_conf = color_freq.get(c, 0)\n            score = (local_conf, c)\n            # Prefer zero-local-conflict colors not in neighbor set\n            if score < best and c not in neighbor_colors:\n                best = score\n                best_c = c\n        if best_c is None:\n            # Fall back to least-local-conflict color in 1..M\n            for c in range(1, M+1):\n                local_conf = color_freq.get(c, 0)\n                score = (local_conf, c)\n                if score < best:\n                    best = score\n                    best_c = c\n        # Apply move\n        old_c = sol[target-1]\n        sol[target-1] = best_c if best_c is not None else old_c\n        return sol, \"recolor_conflict\"\n\n    # Feasible phase: try to reduce palette without increasing it elsewhere\n    M = palette_size(sol)\n    max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        used = {sol[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, M) if c not in used]\n        if candidates:\n            old = sol[v-1]\n            sol[v-1] = min(candidates)\n            return sol, \"reduce_direct\"\n        # Kempe chain attempt to free a color < M for v\n        palette = list(range(1, M))\n        random.shuffle(palette)\n        for c in palette:\n            if sol[v-1] != M:\n                break\n            allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n            if v not in allowed:\n                continue\n            # Build alternating component containing v\n            stack = [v]\n            comp = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            comp_list = list(comp)\n            backup = [sol[w-1] for w in comp_list]\n            # Swap colors on component\n            for w in comp_list:\n                if sol[w-1] == M:\n                    sol[w-1] = c\n                elif sol[w-1] == c:\n                    sol[w-1] = M\n            # Try recolor v into [1..M-1]\n            used2 = {sol[u-1] for u in adj[v]}\n            candidates2 = [cc for cc in range(1, M) if cc not in used2]\n            if candidates2:\n                old = M\n                sol[v-1] = min(candidates2)\n                return sol, \"kempe_reduce\"\n            # Revert swap\n            for w, col in zip(comp_list, backup):\n                sol[w-1] = col\n        # If no reduction possible, perform neutral recolor within 1..M to diversify\n        vertex = v\n        used3 = {sol[u-1] for u in adj[vertex]}\n        # Pick least-conflict color in 1..M\n        color_freq = {}\n        for u in adj[vertex]:\n            cu = sol[u-1]\n            color_freq[cu] = color_freq.get(cu, 0) + 1\n        best_c = sol[vertex-1]\n        best = (color_freq.get(best_c, 0), best_c)\n        for cc in range(1, M+1):\n            score = (color_freq.get(cc, 0), cc)\n            if score < best:\n                best = score\n                best_c = cc\n        sol[vertex-1] = best_c\n        return sol, \"feasible_explore\"\n\n    # Fallback (should be unreachable): random safe recolor\n    idx = random.randrange(n)\n    v = idx + 1\n    used = {sol[u-1] for u in adj[v]}\n    for cc in range(1, max(1, palette_size(sol)) + 1):\n        if cc not in used:\n            sol[v-1] = cc\n            return sol, \"fallback\"\n    return sol, \"noop\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def palette_size(arr):\n        m = 0\n        for c in arr:\n            if c > m:\n                m = c\n        return m\n\n    def conflict_vertices(arr):\n        bad = set()\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    M = palette_size(sol)\n\n    # Recolor a small set of vertices: prioritize conflicts and max-color class\n    bad = conflict_vertices(sol)\n    max_class = [i+1 for i, c in enumerate(sol) if c == M]\n    pool = list(set(bad + max_class)) or list(range(1, n+1))\n    k = min(len(pool), max(3, min(4, len(pool))))\n    chosen = random.sample(pool, k)\n\n    for v in chosen:\n        used = {sol[u-1] for u in adj[v]}\n        # Prefer colors within 1..max(3,M-1) to avoid palette growth\n        upper = max(3, M-1) if M > 1 else 1\n        candidates = [c for c in range(1, upper+1) if c not in used]\n        if candidates:\n            sol[v-1] = random.choice(candidates)\n        else:\n            # fallback to least-conflict color inside 1..M\n            freq = {}\n            for u in adj[v]:\n                cu = sol[u-1]\n                freq[cu] = freq.get(cu, 0) + 1\n            best_c = sol[v-1]\n            best = (freq.get(best_c, 0), best_c)\n            for c in range(1, max(1, M)):\n                score = (freq.get(c, 0), c)\n                if score < best:\n                    best = score\n                    best_c = c\n            sol[v-1] = best_c\n\n    # Perform 1-2 Kempe chain swaps to diversify without increasing palette\n    swaps = 1 + (0 if random.random() < 0.5 else 1)\n    M = palette_size(sol)\n    for _ in range(swaps):\n        if M < 2:\n            break\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if not allowed:\n            continue\n        seed = random.choice(list(allowed))\n        stack = [seed]\n        comp = {seed}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                    comp.add(y)\n                    stack.append(y)\n        comp_list = list(comp)\n        # Swap\n        for w in comp_list:\n            if sol[w-1] == c1:\n                sol[w-1] = c2\n            elif sol[w-1] == c2:\n                sol[w-1] = c1\n        M = palette_size(sol)\n\n    return sol\n","Resultados":[[1,1,1,1,1,1,1,1,1],240001,[1,1,1,1,1,1,1,1,1],240001],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002008075}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9; indices 1..9 map to vertices 1..9; integers >=1 denote colors; objective: minimize max color with hard edge constraints.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Guards\n    if not isinstance(solution, list):\n        return 10000000\n    if len(solution) != n:\n        return 10000000 + 1000000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10000000\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: lexicographic via scalarization (feasible prioritized, then palette size)\n    max_color = 0\n    for c in solution:\n        if c > max_color:\n            max_color = c\n    if conflicts > 0:\n        return conflicts * 10000 + max_color\n    return max_color\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize input\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def palette_size(arr):\n        m = 0\n        for c in arr:\n            if c > m:\n                m = c\n        return m\n\n    def count_conflicts_for_vertex(arr, v):\n        c = arr[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if arr[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def total_conflicts(arr):\n        cnt = 0\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    M = palette_size(sol)\n\n    # Identify conflicts and per-vertex conflict counts\n    conflict_count = [0] * (n + 1)\n    any_conflict = False\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            any_conflict = True\n\n    if any_conflict:\n        # Select target with max conflicts; break ties by degree and slight randomness\n        candidates = list(range(1, n+1))\n        target = max(candidates, key=lambda x: (conflict_count[x], len(adj[x]), random.random()))\n        # Try recoloring with minimal local conflicts; avoid increasing palette\n        neighbor_colors = {sol[u-1] for u in adj[target]}\n        best_c = None\n        best = (10**9, 10**9)\n        # Evaluate colors 1..M using O(deg(v)) delta\n        color_freq = {}\n        for u in adj[target]:\n            cu = sol[u-1]\n            color_freq[cu] = color_freq.get(cu, 0) + 1\n        for c in range(1, M+1):\n            local_conf = color_freq.get(c, 0)\n            score = (local_conf, c)\n            # Prefer zero-local-conflict colors not in neighbor set\n            if score < best and c not in neighbor_colors:\n                best = score\n                best_c = c\n        if best_c is None:\n            # Fall back to least-local-conflict color in 1..M\n            for c in range(1, M+1):\n                local_conf = color_freq.get(c, 0)\n                score = (local_conf, c)\n                if score < best:\n                    best = score\n                    best_c = c\n        # Apply move\n        old_c = sol[target-1]\n        sol[target-1] = best_c if best_c is not None else old_c\n        return sol, \"recolor_conflict\"\n\n    # Feasible phase: try to reduce palette without increasing it elsewhere\n    M = palette_size(sol)\n    max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        used = {sol[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, M) if c not in used]\n        if candidates:\n            old = sol[v-1]\n            sol[v-1] = min(candidates)\n            return sol, \"reduce_direct\"\n        # Kempe chain attempt to free a color < M for v\n        palette = list(range(1, M))\n        random.shuffle(palette)\n        for c in palette:\n            if sol[v-1] != M:\n                break\n            allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n            if v not in allowed:\n                continue\n            # Build alternating component containing v\n            stack = [v]\n            comp = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            comp_list = list(comp)\n            backup = [sol[w-1] for w in comp_list]\n            # Swap colors on component\n            for w in comp_list:\n                if sol[w-1] == M:\n                    sol[w-1] = c\n                elif sol[w-1] == c:\n                    sol[w-1] = M\n            # Try recolor v into [1..M-1]\n            used2 = {sol[u-1] for u in adj[v]}\n            candidates2 = [cc for cc in range(1, M) if cc not in used2]\n            if candidates2:\n                old = M\n                sol[v-1] = min(candidates2)\n                return sol, \"kempe_reduce\"\n            # Revert swap\n            for w, col in zip(comp_list, backup):\n                sol[w-1] = col\n        # If no reduction possible, perform neutral recolor within 1..M to diversify\n        vertex = v\n        used3 = {sol[u-1] for u in adj[vertex]}\n        # Pick least-conflict color in 1..M\n        color_freq = {}\n        for u in adj[vertex]:\n            cu = sol[u-1]\n            color_freq[cu] = color_freq.get(cu, 0) + 1\n        best_c = sol[vertex-1]\n        best = (color_freq.get(best_c, 0), best_c)\n        for cc in range(1, M+1):\n            score = (color_freq.get(cc, 0), cc)\n            if score < best:\n                best = score\n                best_c = cc\n        sol[vertex-1] = best_c\n        return sol, \"feasible_explore\"\n\n    # Fallback (should be unreachable): random safe recolor\n    idx = random.randrange(n)\n    v = idx + 1\n    used = {sol[u-1] for u in adj[v]}\n    for cc in range(1, max(1, palette_size(sol)) + 1):\n        if cc not in used:\n            sol[v-1] = cc\n            return sol, \"fallback\"\n    return sol, \"noop\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def palette_size(arr):\n        m = 0\n        for c in arr:\n            if c > m:\n                m = c\n        return m\n\n    def conflict_vertices(arr):\n        bad = set()\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    M = palette_size(sol)\n\n    # Recolor a small set of vertices: prioritize conflicts and max-color class\n    bad = conflict_vertices(sol)\n    max_class = [i+1 for i, c in enumerate(sol) if c == M]\n    pool = list(set(bad + max_class)) or list(range(1, n+1))\n    k = min(len(pool), max(3, min(4, len(pool))))\n    chosen = random.sample(pool, k)\n\n    for v in chosen:\n        used = {sol[u-1] for u in adj[v]}\n        # Prefer colors within 1..max(3,M-1) to avoid palette growth\n        upper = max(3, M-1) if M > 1 else 1\n        candidates = [c for c in range(1, upper+1) if c not in used]\n        if candidates:\n            sol[v-1] = random.choice(candidates)\n        else:\n            # fallback to least-conflict color inside 1..M\n            freq = {}\n            for u in adj[v]:\n                cu = sol[u-1]\n                freq[cu] = freq.get(cu, 0) + 1\n            best_c = sol[v-1]\n            best = (freq.get(best_c, 0), best_c)\n            for c in range(1, max(1, M)):\n                score = (freq.get(c, 0), c)\n                if score < best:\n                    best = score\n                    best_c = c\n            sol[v-1] = best_c\n\n    # Perform 1-2 Kempe chain swaps to diversify without increasing palette\n    swaps = 1 + (0 if random.random() < 0.5 else 1)\n    M = palette_size(sol)\n    for _ in range(swaps):\n        if M < 2:\n            break\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if not allowed:\n            continue\n        seed = random.choice(list(allowed))\n        stack = [seed]\n        comp = {seed}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                    comp.add(y)\n                    stack.append(y)\n        comp_list = list(comp)\n        # Swap\n        for w in comp_list:\n            if sol[w-1] == c1:\n                sol[w-1] = c2\n            elif sol[w-1] == c2:\n                sol[w-1] = c1\n        M = palette_size(sol)\n\n    return sol\n","Resultados":[[1,1,1,1,1,1,1,1,1],240001,"[1,2,3,4,4,1,1,3,2]",240001],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002604831}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"PY_LIST_INT_LEN_9; indices 1..9 map to vertices 1..9; integers >=1 denote colors; objective: minimize max color with hard edge constraints.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Guards\n    if not isinstance(solution, list):\n        return 10000000\n    if len(solution) != n:\n        return 10000000 + 1000000 * abs(len(solution) - n)\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10000000\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Objective: lexicographic via scalarization (feasible prioritized, then palette size)\n    max_color = 0\n    for c in solution:\n        if c > max_color:\n            max_color = c\n    if conflicts > 0:\n        return conflicts * 10000 + max_color\n    return max_color\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize input\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def palette_size(arr):\n        m = 0\n        for c in arr:\n            if c > m:\n                m = c\n        return m\n\n    def count_conflicts_for_vertex(arr, v):\n        c = arr[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if arr[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def total_conflicts(arr):\n        cnt = 0\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cnt += 1\n        return cnt\n\n    M = palette_size(sol)\n\n    # Identify conflicts and per-vertex conflict counts\n    conflict_count = [0] * (n + 1)\n    any_conflict = False\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            any_conflict = True\n\n    if any_conflict:\n        # Select target with max conflicts; break ties by degree and slight randomness\n        candidates = list(range(1, n+1))\n        target = max(candidates, key=lambda x: (conflict_count[x], len(adj[x]), random.random()))\n        # Try recoloring with minimal local conflicts; avoid increasing palette\n        neighbor_colors = {sol[u-1] for u in adj[target]}\n        best_c = None\n        best = (10**9, 10**9)\n        # Evaluate colors 1..M using O(deg(v)) delta\n        color_freq = {}\n        for u in adj[target]:\n            cu = sol[u-1]\n            color_freq[cu] = color_freq.get(cu, 0) + 1\n        for c in range(1, M+1):\n            local_conf = color_freq.get(c, 0)\n            score = (local_conf, c)\n            # Prefer zero-local-conflict colors not in neighbor set\n            if score < best and c not in neighbor_colors:\n                best = score\n                best_c = c\n        if best_c is None:\n            # Fall back to least-local-conflict color in 1..M\n            for c in range(1, M+1):\n                local_conf = color_freq.get(c, 0)\n                score = (local_conf, c)\n                if score < best:\n                    best = score\n                    best_c = c\n        # Apply move\n        old_c = sol[target-1]\n        sol[target-1] = best_c if best_c is not None else old_c\n        return sol, \"recolor_conflict\"\n\n    # Feasible phase: try to reduce palette without increasing it elsewhere\n    M = palette_size(sol)\n    max_vertices = [i+1 for i, c in enumerate(sol) if c == M]\n    if max_vertices:\n        v = random.choice(max_vertices)\n        used = {sol[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, M) if c not in used]\n        if candidates:\n            old = sol[v-1]\n            sol[v-1] = min(candidates)\n            return sol, \"reduce_direct\"\n        # Kempe chain attempt to free a color < M for v\n        palette = list(range(1, M))\n        random.shuffle(palette)\n        for c in palette:\n            if sol[v-1] != M:\n                break\n            allowed = {i+1 for i, col in enumerate(sol) if col == M or col == c}\n            if v not in allowed:\n                continue\n            # Build alternating component containing v\n            stack = [v]\n            comp = {v}\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                        comp.add(y)\n                        stack.append(y)\n            comp_list = list(comp)\n            backup = [sol[w-1] for w in comp_list]\n            # Swap colors on component\n            for w in comp_list:\n                if sol[w-1] == M:\n                    sol[w-1] = c\n                elif sol[w-1] == c:\n                    sol[w-1] = M\n            # Try recolor v into [1..M-1]\n            used2 = {sol[u-1] for u in adj[v]}\n            candidates2 = [cc for cc in range(1, M) if cc not in used2]\n            if candidates2:\n                old = M\n                sol[v-1] = min(candidates2)\n                return sol, \"kempe_reduce\"\n            # Revert swap\n            for w, col in zip(comp_list, backup):\n                sol[w-1] = col\n        # If no reduction possible, perform neutral recolor within 1..M to diversify\n        vertex = v\n        used3 = {sol[u-1] for u in adj[vertex]}\n        # Pick least-conflict color in 1..M\n        color_freq = {}\n        for u in adj[vertex]:\n            cu = sol[u-1]\n            color_freq[cu] = color_freq.get(cu, 0) + 1\n        best_c = sol[vertex-1]\n        best = (color_freq.get(best_c, 0), best_c)\n        for cc in range(1, M+1):\n            score = (color_freq.get(cc, 0), cc)\n            if score < best:\n                best = score\n                best_c = cc\n        sol[vertex-1] = best_c\n        return sol, \"feasible_explore\"\n\n    # Fallback (should be unreachable): random safe recolor\n    idx = random.randrange(n)\n    v = idx + 1\n    used = {sol[u-1] for u in adj[v]}\n    for cc in range(1, max(1, palette_size(sol)) + 1):\n        if cc not in used:\n            sol[v-1] = cc\n            return sol, \"fallback\"\n    return sol, \"noop\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded graph\n    n = 9\n    edges = (\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    )\n    # Normalize\n    if not isinstance(solution, list):\n        sol = [1] * n\n    else:\n        sol = list(solution[:n]) if len(solution) >= n else (list(solution) + [1] * (n - len(solution)))\n    sol = [int(c) if isinstance(c, int) and c >= 1 else 1 for c in sol]\n\n    # Adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def palette_size(arr):\n        m = 0\n        for c in arr:\n            if c > m:\n                m = c\n        return m\n\n    def conflict_vertices(arr):\n        bad = set()\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    M = palette_size(sol)\n\n    # Recolor a small set of vertices: prioritize conflicts and max-color class\n    bad = conflict_vertices(sol)\n    max_class = [i+1 for i, c in enumerate(sol) if c == M]\n    pool = list(set(bad + max_class)) or list(range(1, n+1))\n    k = min(len(pool), max(3, min(4, len(pool))))\n    chosen = random.sample(pool, k)\n\n    for v in chosen:\n        used = {sol[u-1] for u in adj[v]}\n        # Prefer colors within 1..max(3,M-1) to avoid palette growth\n        upper = max(3, M-1) if M > 1 else 1\n        candidates = [c for c in range(1, upper+1) if c not in used]\n        if candidates:\n            sol[v-1] = random.choice(candidates)\n        else:\n            # fallback to least-conflict color inside 1..M\n            freq = {}\n            for u in adj[v]:\n                cu = sol[u-1]\n                freq[cu] = freq.get(cu, 0) + 1\n            best_c = sol[v-1]\n            best = (freq.get(best_c, 0), best_c)\n            for c in range(1, max(1, M)):\n                score = (freq.get(c, 0), c)\n                if score < best:\n                    best = score\n                    best_c = c\n            sol[v-1] = best_c\n\n    # Perform 1-2 Kempe chain swaps to diversify without increasing palette\n    swaps = 1 + (0 if random.random() < 0.5 else 1)\n    M = palette_size(sol)\n    for _ in range(swaps):\n        if M < 2:\n            break\n        c1, c2 = random.sample(range(1, M+1), 2)\n        allowed = {i+1 for i, col in enumerate(sol) if col == c1 or col == c2}\n        if not allowed:\n            continue\n        seed = random.choice(list(allowed))\n        stack = [seed]\n        comp = {seed}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in allowed and y not in comp and sol[x-1] != sol[y-1]:\n                    comp.add(y)\n                    stack.append(y)\n        comp_list = list(comp)\n        # Swap\n        for w in comp_list:\n            if sol[w-1] == c1:\n                sol[w-1] = c2\n            elif sol[w-1] == c2:\n                sol[w-1] = c1\n        M = palette_size(sol)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001529048}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9 (example: \"1,2,3,2,4,1,1,1,2\"). Nodes are ordered 1..9; value i is color of node i.","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parse representation (CSV string of 9 positive ints)\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return []\n        return []\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Hard checks\n    if not isinstance(s, list):\n        return 10**9\n    if len(s) != N:\n        return 10**9 + abs(len(s) - N)\n    bad = 0\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            bad += 1\n    if bad:\n        return 10**8 + bad\n    k = max(s) if s else 0\n    # Edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    if violations:\n        return 10**6 * violations + k\n    used = set(s)\n    gap_count = k - len(used)\n    return float(k) + gap_count * 1e-6\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helper to parse and format, preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        # Repair to a feasible-length vector with random colors\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Choose a node to recolor\n    idx = random.randrange(N)\n    current_color = s[idx]\n    # Candidate colors: try to change to minimize conflicts locally\n    # Build adjacency\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    used_colors = set(s)\n    candidate_colors = list(range(1, max(4, max(used_colors) + 1) + 1))\n    random.shuffle(candidate_colors)\n    # Evaluate local conflicts if recolored\n    best_color = current_color\n    best_conf = 10**9\n    for col in candidate_colors:\n        conf = 0\n        for nb in adj[idx]:\n            if s[nb] == col:\n                conf += 1\n        # tie-break to prefer fewer colors\n        key = (conf, col)\n        if key < (best_conf, best_color):\n            best_conf = conf\n            best_color = col\n    new_s = s[:]\n    new_s[idx] = best_color\n    return fmt(new_s, kind), \"Coloring\", \"Recolor\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Parse and format helpers\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Strong perturbation: random recolor a subset and optionally swap two colors globally\n    m = max(2, N \/\/ 3)\n    idxs = random.sample(range(N), m)\n    maxc = max(s) if s else 4\n    for i in idxs:\n        s[i] = random.randint(1, max(4, maxc))\n    # Optional color relabeling perturbation\n    if random.random() < 0.5:\n        colors = list(set(s))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            s = [b if x == a else a if x == b else x for x in s]\n    return fmt(s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000989802}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9 (example: \"1,2,3,2,4,1,1,1,2\"). Nodes are ordered 1..9; value i is color of node i.","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parse representation (CSV string of 9 positive ints)\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return []\n        return []\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Hard checks\n    if not isinstance(s, list):\n        return 10**9\n    if len(s) != N:\n        return 10**9 + abs(len(s) - N)\n    bad = 0\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            bad += 1\n    if bad:\n        return 10**8 + bad\n    k = max(s) if s else 0\n    # Edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    if violations:\n        return 10**6 * violations + k\n    used = set(s)\n    gap_count = k - len(used)\n    return float(k) + gap_count * 1e-6\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helper to parse and format, preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        # Repair to a feasible-length vector with random colors\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Choose a node to recolor\n    idx = random.randrange(N)\n    current_color = s[idx]\n    # Candidate colors: try to change to minimize conflicts locally\n    # Build adjacency\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    used_colors = set(s)\n    candidate_colors = list(range(1, max(4, max(used_colors) + 1) + 1))\n    random.shuffle(candidate_colors)\n    # Evaluate local conflicts if recolored\n    best_color = current_color\n    best_conf = 10**9\n    for col in candidate_colors:\n        conf = 0\n        for nb in adj[idx]:\n            if s[nb] == col:\n                conf += 1\n        # tie-break to prefer fewer colors\n        key = (conf, col)\n        if key < (best_conf, best_color):\n            best_conf = conf\n            best_color = col\n    new_s = s[:]\n    new_s[idx] = best_color\n    return fmt(new_s, kind), \"Coloring\", \"Recolor\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Parse and format helpers\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Strong perturbation: random recolor a subset and optionally swap two colors globally\n    m = max(2, N \/\/ 3)\n    idxs = random.sample(range(N), m)\n    maxc = max(s) if s else 4\n    for i in idxs:\n        s[i] = random.randint(1, max(4, maxc))\n    # Optional color relabeling perturbation\n    if random.random() < 0.5:\n        colors = list(set(s))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            s = [b if x == a else a if x == b else x for x in s]\n    return fmt(s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001167054}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9 (example: \"1,2,3,2,4,1,1,1,2\"). Nodes are ordered 1..9; value i is color of node i.","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parse representation (CSV string of 9 positive ints)\n    def parse(sol: Union[str, List[int]]) -> List[int]:\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return []\n        return []\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Hard checks\n    if not isinstance(s, list):\n        return 10**9\n    if len(s) != N:\n        return 10**9 + abs(len(s) - N)\n    bad = 0\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            bad += 1\n    if bad:\n        return 10**8 + bad\n    k = max(s) if s else 0\n    # Edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    if violations:\n        return 10**6 * violations + k\n    used = set(s)\n    gap_count = k - len(used)\n    return float(k) + gap_count * 1e-6\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helper to parse and format, preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        # Repair to a feasible-length vector with random colors\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Choose a node to recolor\n    idx = random.randrange(N)\n    current_color = s[idx]\n    # Candidate colors: try to change to minimize conflicts locally\n    # Build adjacency\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    used_colors = set(s)\n    candidate_colors = list(range(1, max(4, max(used_colors) + 1) + 1))\n    random.shuffle(candidate_colors)\n    # Evaluate local conflicts if recolored\n    best_color = current_color\n    best_conf = 10**9\n    for col in candidate_colors:\n        conf = 0\n        for nb in adj[idx]:\n            if s[nb] == col:\n                conf += 1\n        # tie-break to prefer fewer colors\n        key = (conf, col)\n        if key < (best_conf, best_color):\n            best_conf = conf\n            best_color = col\n    new_s = s[:]\n    new_s[idx] = best_color\n    return fmt(new_s, kind), \"Coloring\", \"Recolor\"\n","Perturbacion":"import random\nfrom typing import List, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Parse and format helpers\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Strong perturbation: random recolor a subset and optionally swap two colors globally\n    m = max(2, N \/\/ 3)\n    idxs = random.sample(range(N), m)\n    maxc = max(s) if s else 4\n    for i in idxs:\n        s[i] = random.randint(1, max(4, maxc))\n    # Optional color relabeling perturbation\n    if random.random() < 0.5:\n        colors = list(set(s))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            s = [b if x == a else a if x == b else x for x in s]\n    return fmt(s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001094913}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parse representation (CSV string of 9 positive ints) or list of 9 ints\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list):\n        return 10**12\n    if len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    # Strong lexicographic penalty: violations dominate k\n    return violations * 10**6 + float(k)\n","Vecindad":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]):\n    # Parse and format helpers preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    # If malformed, initialize a simple feasible-length vector\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph data\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Utility: compute current conflict set and per-node conflicts\n    def node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u,v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    conf, total_conf = node_conflicts(s)\n    # Choose move type: Kempe swap on conflicted node or local recolor\n    move_type = None\n    if total_conf > 0 and random.random() < 0.35:\n        # Kempe-chain swap between two colors on the conflicted subgraph\n        conflicted_nodes = [i for i in range(N) if conf[i] > 0]\n        idx = random.choice(conflicted_nodes)\n        c1 = s[idx]\n        # Choose a neighbor color present in adjacency\n        neigh_colors = list({s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            # Build Kempe component of colors {c1,c2} containing idx\n            stack = [idx]\n            visited = set([idx])\n            component = []\n            while stack:\n                u = stack.pop()\n                component.append(u)\n                for v in adj[u]:\n                    if v not in visited and (s[v] == c1 or s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            # Swap colors on the component\n            new_s = s[:]\n            for u in component:\n                new_s[u] = c2 if s[u] == c1 else (c1 if s[u] == c2 else s[u])\n            s = new_s\n            move_type = (\"Kempe\", \"Swap\")\n        else:\n            move_type = None\n    if move_type is None:\n        # Conflict-driven single-node recolor\n        candidates = [i for i in range(N) if conf[i] > 0]\n        if not candidates:\n            # If no conflicts, pick a node with highest degree to attempt color compaction\n            deg = [len(adj[i]) for i in range(N)]\n            max_deg = max(deg)\n            candidates = [i for i in range(N) if deg[i] == max_deg]\n        idx = random.choice(candidates)\n        current_color = s[idx]\n        maxc = max(s) if s else 1\n        # Restrict to existing colors to avoid k inflation\n        candidate_colors = list(range(1, maxc+0)) + [current_color]\n        # Ensure at least one option\n        if not candidate_colors:\n            candidate_colors = [current_color]\n        random.shuffle(candidate_colors)\n        best_color = current_color\n        best_local = 10**9\n        # Evaluate local conflicts at idx for each candidate color\n        for col in candidate_colors:\n            if col == current_color:\n                # allow staying if it's the best\n                pass\n            conf_here = 0\n            for nb in adj[idx]:\n                if s[nb] == col:\n                    conf_here += 1\n            # Prefer strictly fewer conflicts; tie-break to prefer lower or equal max color usage\n            key = (conf_here, col > maxc)\n            if key < (best_local, best_color > maxc):\n                best_local = conf_here\n                best_color = col\n        new_s = s[:]\n        new_s[idx] = best_color\n        s = new_s\n        move_type = (\"Coloring\", \"Recolor\")\n    return fmt(s, kind), move_type[0], move_type[1]\n","Perturbacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Parse and format helpers preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph data\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Strong perturbation combining random recolors, color relabeling, and a Kempe swap\n    new_s = s[:]\n    maxc = max(new_s) if new_s else 4\n    # 1) Random recolor a subset (about N\/2)\n    m = max(3, N \/\/ 2)\n    idxs = random.sample(range(N), m)\n    allowed_colors = list(range(1, max(4, maxc)))  # avoid introducing new colors here\n    if not allowed_colors:\n        allowed_colors = [1]\n    for i in idxs:\n        new_s[i] = random.choice(allowed_colors)\n    # 2) Random color relabel swap\n    colors = list(set(new_s))\n    if len(colors) >= 2 and random.random() < 0.7:\n        a, b = random.sample(colors, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) Random Kempe-chain swap\n    if random.random() < 0.7:\n        # pick a random node and a neighbor color (if any)\n        idx = random.randrange(N)\n        c1 = new_s[idx]\n        neigh_colors = list({new_s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            stack = [idx]\n            visited = set([idx])\n            component = []\n            while stack:\n                u = stack.pop()\n                component.append(u)\n                for v in adj[u]:\n                    if v not in visited and (new_s[v] == c1 or new_s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            for u in component:\n                new_s[u] = c2 if new_s[u] == c1 else (c1 if new_s[u] == c2 else new_s[u])\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001181875}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parse representation (CSV string of 9 positive ints) or list of 9 ints\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list):\n        return 10**12\n    if len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    # Strong lexicographic penalty: violations dominate k\n    return violations * 10**6 + float(k)\n","Vecindad":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]):\n    # Parse and format helpers preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    # If malformed, initialize a simple feasible-length vector\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph data\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Utility: compute current conflict set and per-node conflicts\n    def node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u,v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    conf, total_conf = node_conflicts(s)\n    # Choose move type: Kempe swap on conflicted node or local recolor\n    move_type = None\n    if total_conf > 0 and random.random() < 0.35:\n        # Kempe-chain swap between two colors on the conflicted subgraph\n        conflicted_nodes = [i for i in range(N) if conf[i] > 0]\n        idx = random.choice(conflicted_nodes)\n        c1 = s[idx]\n        # Choose a neighbor color present in adjacency\n        neigh_colors = list({s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            # Build Kempe component of colors {c1,c2} containing idx\n            stack = [idx]\n            visited = set([idx])\n            component = []\n            while stack:\n                u = stack.pop()\n                component.append(u)\n                for v in adj[u]:\n                    if v not in visited and (s[v] == c1 or s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            # Swap colors on the component\n            new_s = s[:]\n            for u in component:\n                new_s[u] = c2 if s[u] == c1 else (c1 if s[u] == c2 else s[u])\n            s = new_s\n            move_type = (\"Kempe\", \"Swap\")\n        else:\n            move_type = None\n    if move_type is None:\n        # Conflict-driven single-node recolor\n        candidates = [i for i in range(N) if conf[i] > 0]\n        if not candidates:\n            # If no conflicts, pick a node with highest degree to attempt color compaction\n            deg = [len(adj[i]) for i in range(N)]\n            max_deg = max(deg)\n            candidates = [i for i in range(N) if deg[i] == max_deg]\n        idx = random.choice(candidates)\n        current_color = s[idx]\n        maxc = max(s) if s else 1\n        # Restrict to existing colors to avoid k inflation\n        candidate_colors = list(range(1, maxc+0)) + [current_color]\n        # Ensure at least one option\n        if not candidate_colors:\n            candidate_colors = [current_color]\n        random.shuffle(candidate_colors)\n        best_color = current_color\n        best_local = 10**9\n        # Evaluate local conflicts at idx for each candidate color\n        for col in candidate_colors:\n            if col == current_color:\n                # allow staying if it's the best\n                pass\n            conf_here = 0\n            for nb in adj[idx]:\n                if s[nb] == col:\n                    conf_here += 1\n            # Prefer strictly fewer conflicts; tie-break to prefer lower or equal max color usage\n            key = (conf_here, col > maxc)\n            if key < (best_local, best_color > maxc):\n                best_local = conf_here\n                best_color = col\n        new_s = s[:]\n        new_s[idx] = best_color\n        s = new_s\n        move_type = (\"Coloring\", \"Recolor\")\n    return fmt(s, kind), move_type[0], move_type[1]\n","Perturbacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Parse and format helpers preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph data\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Strong perturbation combining random recolors, color relabeling, and a Kempe swap\n    new_s = s[:]\n    maxc = max(new_s) if new_s else 4\n    # 1) Random recolor a subset (about N\/2)\n    m = max(3, N \/\/ 2)\n    idxs = random.sample(range(N), m)\n    allowed_colors = list(range(1, max(4, maxc)))  # avoid introducing new colors here\n    if not allowed_colors:\n        allowed_colors = [1]\n    for i in idxs:\n        new_s[i] = random.choice(allowed_colors)\n    # 2) Random color relabel swap\n    colors = list(set(new_s))\n    if len(colors) >= 2 and random.random() < 0.7:\n        a, b = random.sample(colors, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) Random Kempe-chain swap\n    if random.random() < 0.7:\n        # pick a random node and a neighbor color (if any)\n        idx = random.randrange(N)\n        c1 = new_s[idx]\n        neigh_colors = list({new_s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            stack = [idx]\n            visited = set([idx])\n            component = []\n            while stack:\n                u = stack.pop()\n                component.append(u)\n                for v in adj[u]:\n                    if v not in visited and (new_s[v] == c1 or new_s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            for u in component:\n                new_s[u] = c2 if new_s[u] == c1 else (c1 if new_s[u] == c2 else new_s[u])\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001389107}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parse representation (CSV string of 9 positive ints) or list of 9 ints\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list):\n        return 10**12\n    if len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    # Strong lexicographic penalty: violations dominate k\n    return violations * 10**6 + float(k)\n","Vecindad":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]):\n    # Parse and format helpers preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    # If malformed, initialize a simple feasible-length vector\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph data\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Utility: compute current conflict set and per-node conflicts\n    def node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u,v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    conf, total_conf = node_conflicts(s)\n    # Choose move type: Kempe swap on conflicted node or local recolor\n    move_type = None\n    if total_conf > 0 and random.random() < 0.35:\n        # Kempe-chain swap between two colors on the conflicted subgraph\n        conflicted_nodes = [i for i in range(N) if conf[i] > 0]\n        idx = random.choice(conflicted_nodes)\n        c1 = s[idx]\n        # Choose a neighbor color present in adjacency\n        neigh_colors = list({s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            # Build Kempe component of colors {c1,c2} containing idx\n            stack = [idx]\n            visited = set([idx])\n            component = []\n            while stack:\n                u = stack.pop()\n                component.append(u)\n                for v in adj[u]:\n                    if v not in visited and (s[v] == c1 or s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            # Swap colors on the component\n            new_s = s[:]\n            for u in component:\n                new_s[u] = c2 if s[u] == c1 else (c1 if s[u] == c2 else s[u])\n            s = new_s\n            move_type = (\"Kempe\", \"Swap\")\n        else:\n            move_type = None\n    if move_type is None:\n        # Conflict-driven single-node recolor\n        candidates = [i for i in range(N) if conf[i] > 0]\n        if not candidates:\n            # If no conflicts, pick a node with highest degree to attempt color compaction\n            deg = [len(adj[i]) for i in range(N)]\n            max_deg = max(deg)\n            candidates = [i for i in range(N) if deg[i] == max_deg]\n        idx = random.choice(candidates)\n        current_color = s[idx]\n        maxc = max(s) if s else 1\n        # Restrict to existing colors to avoid k inflation\n        candidate_colors = list(range(1, maxc+0)) + [current_color]\n        # Ensure at least one option\n        if not candidate_colors:\n            candidate_colors = [current_color]\n        random.shuffle(candidate_colors)\n        best_color = current_color\n        best_local = 10**9\n        # Evaluate local conflicts at idx for each candidate color\n        for col in candidate_colors:\n            if col == current_color:\n                # allow staying if it's the best\n                pass\n            conf_here = 0\n            for nb in adj[idx]:\n                if s[nb] == col:\n                    conf_here += 1\n            # Prefer strictly fewer conflicts; tie-break to prefer lower or equal max color usage\n            key = (conf_here, col > maxc)\n            if key < (best_local, best_color > maxc):\n                best_local = conf_here\n                best_color = col\n        new_s = s[:]\n        new_s[idx] = best_color\n        s = new_s\n        move_type = (\"Coloring\", \"Recolor\")\n    return fmt(s, kind), move_type[0], move_type[1]\n","Perturbacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Parse and format helpers preserving input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph data\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Strong perturbation combining random recolors, color relabeling, and a Kempe swap\n    new_s = s[:]\n    maxc = max(new_s) if new_s else 4\n    # 1) Random recolor a subset (about N\/2)\n    m = max(3, N \/\/ 2)\n    idxs = random.sample(range(N), m)\n    allowed_colors = list(range(1, max(4, maxc)))  # avoid introducing new colors here\n    if not allowed_colors:\n        allowed_colors = [1]\n    for i in idxs:\n        new_s[i] = random.choice(allowed_colors)\n    # 2) Random color relabel swap\n    colors = list(set(new_s))\n    if len(colors) >= 2 and random.random() < 0.7:\n        a, b = random.sample(colors, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) Random Kempe-chain swap\n    if random.random() < 0.7:\n        # pick a random node and a neighbor color (if any)\n        idx = random.randrange(N)\n        c1 = new_s[idx]\n        neigh_colors = list({new_s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            stack = [idx]\n            visited = set([idx])\n            component = []\n            while stack:\n                u = stack.pop()\n                component.append(u)\n                for v in adj[u]:\n                    if v not in visited and (new_s[v] == c1 or new_s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            for u in component:\n                new_s[u] = c2 if new_s[u] == c1 else (c1 if new_s[u] == c2 else new_s[u])\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001376137}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parses CSV string or list[int]; returns large penalty if malformed\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list) or len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    PEN_VIOL = 1_000_000\n    return violations * PEN_VIOL + int(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]):\n    # Return a neighbor of the input solution; preserves input type (CSV str or list[int])\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    # Initialize if malformed\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    def per_node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u, v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    conf, total_conf = per_node_conflicts(s)\n    new_s = s[:]\n    # Adaptive: more Kempe when conflicts>0\n    do_kempe = (total_conf > 0 and random.random() < 0.55) or (total_conf == 0 and random.random() < 0.15)\n    if do_kempe:\n        # pick a node (conflicted preferred)\n        nodes = [i for i in range(N) if conf[i] > 0] or list(range(N))\n        idx = random.choice(nodes)\n        c1 = new_s[idx]\n        neigh_colors = list({new_s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            # Build Kempe chain component on colors {c1,c2}\n            stack = [idx]\n            visited = {idx}\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in visited and (new_s[v] == c1 or new_s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            for u in comp:\n                if new_s[u] == c1:\n                    new_s[u] = c2\n                elif new_s[u] == c2:\n                    new_s[u] = c1\n        return fmt(new_s, kind)\n    # Otherwise conflict-driven recolor or compaction\n    candidates = [i for i in range(N) if conf[i] > 0]\n    if not candidates:\n        # choose node from highest color class to attempt k reduction\n        maxc = max(new_s) if new_s else 1\n        candidates = [i for i in range(N) if new_s[i] == maxc]\n        if not candidates:\n            candidates = list(range(N))\n    idx = random.choice(candidates)\n    current_color = new_s[idx]\n    maxc = max(new_s) if new_s else 1\n    # Allow existing colors 1..maxc (do not introduce new colors)\n    candidate_colors = list(range(1, maxc+1))\n    best_col = current_color\n    best_key = (10**9, True, current_color)\n    # Evaluate local conflicts at idx for each candidate color\n    for col in candidate_colors:\n        conf_here = 0\n        for nb in adj[idx]:\n            if new_s[nb] == col:\n                conf_here += 1\n        # Key: minimize conflicts, prefer smaller color, avoid increasing k implicitly\n        key = (conf_here, col > maxc, col)\n        if key < best_key:\n            best_key = key\n            best_col = col\n    new_s[idx] = best_col\n    return fmt(new_s, kind)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Strong perturbation: randomized recolors + one or two Kempe swaps; preserves input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    new_s = s[:]\n    maxc = max(new_s) if new_s else 4\n    # 1) Random recolor about N\/2 nodes, using existing color set (avoid increasing k)\n    m = max(3, N\/\/2)\n    idxs = random.sample(range(N), m)\n    colors = sorted(set(new_s))\n    if not colors:\n        colors = [1,2,3,4]\n    for i in idxs:\n        new_s[i] = random.choice(colors)\n    # 2) Random color relabel swap (diversification)\n    colors2 = sorted(set(new_s))\n    if len(colors2) >= 2 and random.random() < 0.8:\n        a, b = random.sample(colors2, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) One or two Kempe-chain swaps\n    def kempe_once(arr):\n        idx = random.randrange(N)\n        c1 = arr[idx]\n        neigh_colors = list({arr[j] for j in adj[idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [idx]\n        visited = {idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    if random.random() < 0.9:\n        new_s = kempe_once(new_s)\n    if random.random() < 0.5:\n        new_s = kempe_once(new_s)\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001137834}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parses CSV string or list[int]; returns large penalty if malformed\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list) or len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    PEN_VIOL = 1_000_000\n    return violations * PEN_VIOL + int(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]):\n    # Return a neighbor of the input solution; preserves input type (CSV str or list[int])\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    # Initialize if malformed\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    def per_node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u, v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    conf, total_conf = per_node_conflicts(s)\n    new_s = s[:]\n    # Adaptive: more Kempe when conflicts>0\n    do_kempe = (total_conf > 0 and random.random() < 0.55) or (total_conf == 0 and random.random() < 0.15)\n    if do_kempe:\n        # pick a node (conflicted preferred)\n        nodes = [i for i in range(N) if conf[i] > 0] or list(range(N))\n        idx = random.choice(nodes)\n        c1 = new_s[idx]\n        neigh_colors = list({new_s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            # Build Kempe chain component on colors {c1,c2}\n            stack = [idx]\n            visited = {idx}\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in visited and (new_s[v] == c1 or new_s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            for u in comp:\n                if new_s[u] == c1:\n                    new_s[u] = c2\n                elif new_s[u] == c2:\n                    new_s[u] = c1\n        return fmt(new_s, kind)\n    # Otherwise conflict-driven recolor or compaction\n    candidates = [i for i in range(N) if conf[i] > 0]\n    if not candidates:\n        # choose node from highest color class to attempt k reduction\n        maxc = max(new_s) if new_s else 1\n        candidates = [i for i in range(N) if new_s[i] == maxc]\n        if not candidates:\n            candidates = list(range(N))\n    idx = random.choice(candidates)\n    current_color = new_s[idx]\n    maxc = max(new_s) if new_s else 1\n    # Allow existing colors 1..maxc (do not introduce new colors)\n    candidate_colors = list(range(1, maxc+1))\n    best_col = current_color\n    best_key = (10**9, True, current_color)\n    # Evaluate local conflicts at idx for each candidate color\n    for col in candidate_colors:\n        conf_here = 0\n        for nb in adj[idx]:\n            if new_s[nb] == col:\n                conf_here += 1\n        # Key: minimize conflicts, prefer smaller color, avoid increasing k implicitly\n        key = (conf_here, col > maxc, col)\n        if key < best_key:\n            best_key = key\n            best_col = col\n    new_s[idx] = best_col\n    return fmt(new_s, kind)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Strong perturbation: randomized recolors + one or two Kempe swaps; preserves input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    new_s = s[:]\n    maxc = max(new_s) if new_s else 4\n    # 1) Random recolor about N\/2 nodes, using existing color set (avoid increasing k)\n    m = max(3, N\/\/2)\n    idxs = random.sample(range(N), m)\n    colors = sorted(set(new_s))\n    if not colors:\n        colors = [1,2,3,4]\n    for i in idxs:\n        new_s[i] = random.choice(colors)\n    # 2) Random color relabel swap (diversification)\n    colors2 = sorted(set(new_s))\n    if len(colors2) >= 2 and random.random() < 0.8:\n        a, b = random.sample(colors2, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) One or two Kempe-chain swaps\n    def kempe_once(arr):\n        idx = random.randrange(N)\n        c1 = arr[idx]\n        neigh_colors = list({arr[j] for j in adj[idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [idx]\n        visited = {idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    if random.random() < 0.9:\n        new_s = kempe_once(new_s)\n    if random.random() < 0.5:\n        new_s = kempe_once(new_s)\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001347677}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    # Parses CSV string or list[int]; returns large penalty if malformed\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list) or len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    PEN_VIOL = 1_000_000\n    return violations * PEN_VIOL + int(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[str, List[int]]):\n    # Return a neighbor of the input solution; preserves input type (CSV str or list[int])\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    # Initialize if malformed\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    # Graph\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    def per_node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u, v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    conf, total_conf = per_node_conflicts(s)\n    new_s = s[:]\n    # Adaptive: more Kempe when conflicts>0\n    do_kempe = (total_conf > 0 and random.random() < 0.55) or (total_conf == 0 and random.random() < 0.15)\n    if do_kempe:\n        # pick a node (conflicted preferred)\n        nodes = [i for i in range(N) if conf[i] > 0] or list(range(N))\n        idx = random.choice(nodes)\n        c1 = new_s[idx]\n        neigh_colors = list({new_s[j] for j in adj[idx]})\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            # Build Kempe chain component on colors {c1,c2}\n            stack = [idx]\n            visited = {idx}\n            comp = []\n            while stack:\n                u = stack.pop()\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in visited and (new_s[v] == c1 or new_s[v] == c2):\n                        visited.add(v)\n                        stack.append(v)\n            for u in comp:\n                if new_s[u] == c1:\n                    new_s[u] = c2\n                elif new_s[u] == c2:\n                    new_s[u] = c1\n        return fmt(new_s, kind)\n    # Otherwise conflict-driven recolor or compaction\n    candidates = [i for i in range(N) if conf[i] > 0]\n    if not candidates:\n        # choose node from highest color class to attempt k reduction\n        maxc = max(new_s) if new_s else 1\n        candidates = [i for i in range(N) if new_s[i] == maxc]\n        if not candidates:\n            candidates = list(range(N))\n    idx = random.choice(candidates)\n    current_color = new_s[idx]\n    maxc = max(new_s) if new_s else 1\n    # Allow existing colors 1..maxc (do not introduce new colors)\n    candidate_colors = list(range(1, maxc+1))\n    best_col = current_color\n    best_key = (10**9, True, current_color)\n    # Evaluate local conflicts at idx for each candidate color\n    for col in candidate_colors:\n        conf_here = 0\n        for nb in adj[idx]:\n            if new_s[nb] == col:\n                conf_here += 1\n        # Key: minimize conflicts, prefer smaller color, avoid increasing k implicitly\n        key = (conf_here, col > maxc, col)\n        if key < best_key:\n            best_key = key\n            best_col = col\n    new_s[idx] = best_col\n    return fmt(new_s, kind)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Strong perturbation: randomized recolors + one or two Kempe swaps; preserves input type\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    s, kind = parse(solution)\n    N = 9\n    if len(s) != N:\n        s = [random.randint(1, 4) for _ in range(N)]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    new_s = s[:]\n    maxc = max(new_s) if new_s else 4\n    # 1) Random recolor about N\/2 nodes, using existing color set (avoid increasing k)\n    m = max(3, N\/\/2)\n    idxs = random.sample(range(N), m)\n    colors = sorted(set(new_s))\n    if not colors:\n        colors = [1,2,3,4]\n    for i in idxs:\n        new_s[i] = random.choice(colors)\n    # 2) Random color relabel swap (diversification)\n    colors2 = sorted(set(new_s))\n    if len(colors2) >= 2 and random.random() < 0.8:\n        a, b = random.sample(colors2, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) One or two Kempe-chain swaps\n    def kempe_once(arr):\n        idx = random.randrange(N)\n        c1 = arr[idx]\n        neigh_colors = list({arr[j] for j in adj[idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [idx]\n        visited = {idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    if random.random() < 0.9:\n        new_s = kempe_once(new_s)\n    if random.random() < 0.5:\n        new_s = kempe_once(new_s)\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001252735}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    \"\"\"\n    Parses CSV string or list[int]; returns large penalty if malformed.\n    Cost = violations*1_000_000 + k where k=max color used; lower is better.\n    \"\"\"\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list) or len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    PEN_VIOL = 1_000_000\n    return violations * PEN_VIOL + int(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a neighbor of the input solution; preserves input type (CSV str or list[int]).\n    Move set: targeted Kempe chain, conflict-driven recolor, max-color-class ejection,\n    color-class swap, occasional relabeling.\n    When input malformed\/size!=9, builds a DSATUR initialization first.\n    \"\"\"\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    def dsatur_seed(N: int, adj: List[List[int]]) -> List[int]:\n        colors = [0]*N\n        sat = [0]*N\n        used = [set() for _ in range(N)]\n        remaining = set(range(N))\n        while remaining:\n            # select vertex with max saturation (ties by degree)\n            i = max(remaining, key=lambda v: (sat[v], len(adj[v])))\n            remaining.remove(i)\n            # smallest available color\n            c = 1\n            while c in used[i]:\n                c += 1\n            colors[i] = c\n            # update neighbors\n            for nb in adj[i]:\n                if colors[i] not in used[nb]:\n                    used[nb].add(colors[i])\n                    sat[nb] = len(used[nb])\n        return colors\n    # Problem data\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    s, kind = parse(solution)\n    if len(s) != N or any((not isinstance(x,int) or x < 1) for x in s):\n        s = dsatur_seed(N, adj)\n    new_s = s[:]\n    # helpers\n    def per_node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u, v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    def kempe_swap(arr, seed_idx):\n        c1 = arr[seed_idx]\n        neigh_colors = list({arr[j] for j in adj[seed_idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [seed_idx]\n        visited = {seed_idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    def max_color_class(arr):\n        if not arr:\n            return 0, []\n        from collections import defaultdict\n        d = defaultdict(list)\n        for i,c in enumerate(arr):\n            d[c].append(i)\n        mc = max(d.keys())\n        return mc, d[mc]\n    conf, total_conf = per_node_conflicts(new_s)\n    move_roll = random.random()\n    # Priority 1: if conflicts exist, try Kempe or direct conflict fix\n    if total_conf > 0 and move_roll < 0.55:\n        nodes = [i for i in range(N) if conf[i] > 0] or list(range(N))\n        idx = random.choice(nodes)\n        new_s = kempe_swap(new_s, idx)\n        return fmt(new_s, kind)\n    if total_conf > 0 and move_roll < 0.85:\n        # direct conflict fix on a conflicted vertex: choose best color from existing palette\n        idx = max(range(N), key=lambda i: conf[i])\n        current_color = new_s[idx]\n        maxc = max(new_s) if new_s else 1\n        best_col = current_color\n        best_key = (10**9, 10**9)\n        for col in range(1, maxc+1):\n            conf_here = 0\n            for nb in adj[idx]:\n                if new_s[nb] == col:\n                    conf_here += 1\n            key = (conf_here, col)\n            if key < best_key:\n                best_key = key\n                best_col = col\n        new_s[idx] = best_col\n        return fmt(new_s, kind)\n    # Priority 2: If feasible, target k reduction by ejecting from max color class and reinserting greedily\n    if total_conf == 0 and move_roll < 0.85:\n        maxc, members = max_color_class(new_s)\n        if members:\n            idx = random.choice(members)\n            # try to recolor idx to smallest feasible color < maxc\n            target_colors = list(range(1, maxc))\n            for col in target_colors:\n                ok = True\n                for nb in adj[idx]:\n                    if new_s[nb] == col:\n                        ok = False\n                        break\n                if ok:\n                    new_s[idx] = col\n                    return fmt(new_s, kind)\n            # If not feasible, attempt Kempe from idx to free a color\n            prev = new_s[:]\n            new_s = kempe_swap(new_s, idx)\n            # if kempe didn't help, keep as diversification\n            return fmt(new_s, kind)\n    # Priority 3: diversification via color-class swap or relabel\n    if random.random() < 0.30:\n        colors = sorted(set(new_s))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            new_s = [b if x == a else (a if x == b else x) for x in new_s]\n            return fmt(new_s, kind)\n    # Fallback: slight random recolor within existing palette\n    idx = random.randrange(N)\n    colors = sorted(set(new_s)) or [1,2,3,4]\n    new_s[idx] = random.choice(colors)\n    return fmt(new_s, kind)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: randomized recolors + 1-2 Kempe swaps + optional color relabel swap.\n    Preserves input type (CSV str or list[int]).\n    \"\"\"\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    # Problem data\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    s, kind = parse(solution)\n    if len(s) != N or any((not isinstance(x,int) or x < 1) for x in s):\n        # initialize with a simple greedy if malformed\n        order = sorted(range(N), key=lambda i: -len(adj[i]))\n        s = [0]*N\n        for i in order:\n            c = 1\n            while any(s[j] == c for j in adj[i]):\n                c += 1\n            s[i] = c\n    new_s = s[:]\n    # 1) Random recolor about N\/\/2 nodes within existing colors\n    colors = sorted(set(new_s)) or [1,2,3,4]\n    m = max(3, N\/\/2)\n    for i in random.sample(range(N), m):\n        new_s[i] = random.choice(colors)\n    # 2) Random color relabel swap (symmetry breaking)\n    colors2 = sorted(set(new_s))\n    if len(colors2) >= 2 and random.random() < 0.8:\n        a, b = random.sample(colors2, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) One or two Kempe-chain swaps\n    def kempe_once(arr):\n        if not arr:\n            return arr\n        idx = random.randrange(N)\n        c1 = arr[idx]\n        neigh_colors = list({arr[j] for j in adj[idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [idx]\n        visited = {idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    if random.random() < 0.9:\n        new_s = kempe_once(new_s)\n    if random.random() < 0.5:\n        new_s = kempe_once(new_s)\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001433308}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    \"\"\"\n    Parses CSV string or list[int]; returns large penalty if malformed.\n    Cost = violations*1_000_000 + k where k=max color used; lower is better.\n    \"\"\"\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list) or len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    PEN_VIOL = 1_000_000\n    return violations * PEN_VIOL + int(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a neighbor of the input solution; preserves input type (CSV str or list[int]).\n    Move set: targeted Kempe chain, conflict-driven recolor, max-color-class ejection,\n    color-class swap, occasional relabeling.\n    When input malformed\/size!=9, builds a DSATUR initialization first.\n    \"\"\"\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    def dsatur_seed(N: int, adj: List[List[int]]) -> List[int]:\n        colors = [0]*N\n        sat = [0]*N\n        used = [set() for _ in range(N)]\n        remaining = set(range(N))\n        while remaining:\n            # select vertex with max saturation (ties by degree)\n            i = max(remaining, key=lambda v: (sat[v], len(adj[v])))\n            remaining.remove(i)\n            # smallest available color\n            c = 1\n            while c in used[i]:\n                c += 1\n            colors[i] = c\n            # update neighbors\n            for nb in adj[i]:\n                if colors[i] not in used[nb]:\n                    used[nb].add(colors[i])\n                    sat[nb] = len(used[nb])\n        return colors\n    # Problem data\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    s, kind = parse(solution)\n    if len(s) != N or any((not isinstance(x,int) or x < 1) for x in s):\n        s = dsatur_seed(N, adj)\n    new_s = s[:]\n    # helpers\n    def per_node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u, v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    def kempe_swap(arr, seed_idx):\n        c1 = arr[seed_idx]\n        neigh_colors = list({arr[j] for j in adj[seed_idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [seed_idx]\n        visited = {seed_idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    def max_color_class(arr):\n        if not arr:\n            return 0, []\n        from collections import defaultdict\n        d = defaultdict(list)\n        for i,c in enumerate(arr):\n            d[c].append(i)\n        mc = max(d.keys())\n        return mc, d[mc]\n    conf, total_conf = per_node_conflicts(new_s)\n    move_roll = random.random()\n    # Priority 1: if conflicts exist, try Kempe or direct conflict fix\n    if total_conf > 0 and move_roll < 0.55:\n        nodes = [i for i in range(N) if conf[i] > 0] or list(range(N))\n        idx = random.choice(nodes)\n        new_s = kempe_swap(new_s, idx)\n        return fmt(new_s, kind)\n    if total_conf > 0 and move_roll < 0.85:\n        # direct conflict fix on a conflicted vertex: choose best color from existing palette\n        idx = max(range(N), key=lambda i: conf[i])\n        current_color = new_s[idx]\n        maxc = max(new_s) if new_s else 1\n        best_col = current_color\n        best_key = (10**9, 10**9)\n        for col in range(1, maxc+1):\n            conf_here = 0\n            for nb in adj[idx]:\n                if new_s[nb] == col:\n                    conf_here += 1\n            key = (conf_here, col)\n            if key < best_key:\n                best_key = key\n                best_col = col\n        new_s[idx] = best_col\n        return fmt(new_s, kind)\n    # Priority 2: If feasible, target k reduction by ejecting from max color class and reinserting greedily\n    if total_conf == 0 and move_roll < 0.85:\n        maxc, members = max_color_class(new_s)\n        if members:\n            idx = random.choice(members)\n            # try to recolor idx to smallest feasible color < maxc\n            target_colors = list(range(1, maxc))\n            for col in target_colors:\n                ok = True\n                for nb in adj[idx]:\n                    if new_s[nb] == col:\n                        ok = False\n                        break\n                if ok:\n                    new_s[idx] = col\n                    return fmt(new_s, kind)\n            # If not feasible, attempt Kempe from idx to free a color\n            prev = new_s[:]\n            new_s = kempe_swap(new_s, idx)\n            # if kempe didn't help, keep as diversification\n            return fmt(new_s, kind)\n    # Priority 3: diversification via color-class swap or relabel\n    if random.random() < 0.30:\n        colors = sorted(set(new_s))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            new_s = [b if x == a else (a if x == b else x) for x in new_s]\n            return fmt(new_s, kind)\n    # Fallback: slight random recolor within existing palette\n    idx = random.randrange(N)\n    colors = sorted(set(new_s)) or [1,2,3,4]\n    new_s[idx] = random.choice(colors)\n    return fmt(new_s, kind)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: randomized recolors + 1-2 Kempe swaps + optional color relabel swap.\n    Preserves input type (CSV str or list[int]).\n    \"\"\"\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    # Problem data\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    s, kind = parse(solution)\n    if len(s) != N or any((not isinstance(x,int) or x < 1) for x in s):\n        # initialize with a simple greedy if malformed\n        order = sorted(range(N), key=lambda i: -len(adj[i]))\n        s = [0]*N\n        for i in order:\n            c = 1\n            while any(s[j] == c for j in adj[i]):\n                c += 1\n            s[i] = c\n    new_s = s[:]\n    # 1) Random recolor about N\/\/2 nodes within existing colors\n    colors = sorted(set(new_s)) or [1,2,3,4]\n    m = max(3, N\/\/2)\n    for i in random.sample(range(N), m):\n        new_s[i] = random.choice(colors)\n    # 2) Random color relabel swap (symmetry breaking)\n    colors2 = sorted(set(new_s))\n    if len(colors2) >= 2 and random.random() < 0.8:\n        a, b = random.sample(colors2, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) One or two Kempe-chain swaps\n    def kempe_once(arr):\n        if not arr:\n            return arr\n        idx = random.randrange(N)\n        c1 = arr[idx]\n        neigh_colors = list({arr[j] for j in adj[idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [idx]\n        visited = {idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    if random.random() < 0.9:\n        new_s = kempe_once(new_s)\n    if random.random() < 0.5:\n        new_s = kempe_once(new_s)\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001794102}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN9_COLORS_1..9; nodes ordered 1..9; c_i is color of node i; example: \"1,2,3,2,4,1,1,1,2\"","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]):\n    \"\"\"\n    Parses CSV string or list[int]; returns large penalty if malformed.\n    Cost = violations*1_000_000 + k where k=max color used; lower is better.\n    \"\"\"\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                return None\n            return arr\n        return None\n    s = parse(solution)\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    if not isinstance(s, list) or len(s) != N:\n        return 10**12\n    for c in s:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n    violations = 0\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            violations += 1\n    k = max(s) if s else 0\n    PEN_VIOL = 1_000_000\n    return violations * PEN_VIOL + int(k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a neighbor of the input solution; preserves input type (CSV str or list[int]).\n    Move set: targeted Kempe chain, conflict-driven recolor, max-color-class ejection,\n    color-class swap, occasional relabeling.\n    When input malformed\/size!=9, builds a DSATUR initialization first.\n    \"\"\"\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    def dsatur_seed(N: int, adj: List[List[int]]) -> List[int]:\n        colors = [0]*N\n        sat = [0]*N\n        used = [set() for _ in range(N)]\n        remaining = set(range(N))\n        while remaining:\n            # select vertex with max saturation (ties by degree)\n            i = max(remaining, key=lambda v: (sat[v], len(adj[v])))\n            remaining.remove(i)\n            # smallest available color\n            c = 1\n            while c in used[i]:\n                c += 1\n            colors[i] = c\n            # update neighbors\n            for nb in adj[i]:\n                if colors[i] not in used[nb]:\n                    used[nb].add(colors[i])\n                    sat[nb] = len(used[nb])\n        return colors\n    # Problem data\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    s, kind = parse(solution)\n    if len(s) != N or any((not isinstance(x,int) or x < 1) for x in s):\n        s = dsatur_seed(N, adj)\n    new_s = s[:]\n    # helpers\n    def per_node_conflicts(arr):\n        conf = [0]*N\n        total = 0\n        for (u, v) in E:\n            if arr[u-1] == arr[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n                total += 1\n        return conf, total\n    def kempe_swap(arr, seed_idx):\n        c1 = arr[seed_idx]\n        neigh_colors = list({arr[j] for j in adj[seed_idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [seed_idx]\n        visited = {seed_idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    def max_color_class(arr):\n        if not arr:\n            return 0, []\n        from collections import defaultdict\n        d = defaultdict(list)\n        for i,c in enumerate(arr):\n            d[c].append(i)\n        mc = max(d.keys())\n        return mc, d[mc]\n    conf, total_conf = per_node_conflicts(new_s)\n    move_roll = random.random()\n    # Priority 1: if conflicts exist, try Kempe or direct conflict fix\n    if total_conf > 0 and move_roll < 0.55:\n        nodes = [i for i in range(N) if conf[i] > 0] or list(range(N))\n        idx = random.choice(nodes)\n        new_s = kempe_swap(new_s, idx)\n        return fmt(new_s, kind)\n    if total_conf > 0 and move_roll < 0.85:\n        # direct conflict fix on a conflicted vertex: choose best color from existing palette\n        idx = max(range(N), key=lambda i: conf[i])\n        current_color = new_s[idx]\n        maxc = max(new_s) if new_s else 1\n        best_col = current_color\n        best_key = (10**9, 10**9)\n        for col in range(1, maxc+1):\n            conf_here = 0\n            for nb in adj[idx]:\n                if new_s[nb] == col:\n                    conf_here += 1\n            key = (conf_here, col)\n            if key < best_key:\n                best_key = key\n                best_col = col\n        new_s[idx] = best_col\n        return fmt(new_s, kind)\n    # Priority 2: If feasible, target k reduction by ejecting from max color class and reinserting greedily\n    if total_conf == 0 and move_roll < 0.85:\n        maxc, members = max_color_class(new_s)\n        if members:\n            idx = random.choice(members)\n            # try to recolor idx to smallest feasible color < maxc\n            target_colors = list(range(1, maxc))\n            for col in target_colors:\n                ok = True\n                for nb in adj[idx]:\n                    if new_s[nb] == col:\n                        ok = False\n                        break\n                if ok:\n                    new_s[idx] = col\n                    return fmt(new_s, kind)\n            # If not feasible, attempt Kempe from idx to free a color\n            prev = new_s[:]\n            new_s = kempe_swap(new_s, idx)\n            # if kempe didn't help, keep as diversification\n            return fmt(new_s, kind)\n    # Priority 3: diversification via color-class swap or relabel\n    if random.random() < 0.30:\n        colors = sorted(set(new_s))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            new_s = [b if x == a else (a if x == b else x) for x in new_s]\n            return fmt(new_s, kind)\n    # Fallback: slight random recolor within existing palette\n    idx = random.randrange(N)\n    colors = sorted(set(new_s)) or [1,2,3,4]\n    new_s[idx] = random.choice(colors)\n    return fmt(new_s, kind)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: randomized recolors + 1-2 Kempe swaps + optional color relabel swap.\n    Preserves input type (CSV str or list[int]).\n    \"\"\"\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:], 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            try:\n                arr = [int(p) for p in parts]\n            except Exception:\n                arr = []\n            return arr, 'str'\n        return [], 'list'\n    def fmt(arr, kind):\n        if kind == 'str':\n            return ','.join(str(x) for x in arr)\n        return arr\n    # Problem data\n    N = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    s, kind = parse(solution)\n    if len(s) != N or any((not isinstance(x,int) or x < 1) for x in s):\n        # initialize with a simple greedy if malformed\n        order = sorted(range(N), key=lambda i: -len(adj[i]))\n        s = [0]*N\n        for i in order:\n            c = 1\n            while any(s[j] == c for j in adj[i]):\n                c += 1\n            s[i] = c\n    new_s = s[:]\n    # 1) Random recolor about N\/\/2 nodes within existing colors\n    colors = sorted(set(new_s)) or [1,2,3,4]\n    m = max(3, N\/\/2)\n    for i in random.sample(range(N), m):\n        new_s[i] = random.choice(colors)\n    # 2) Random color relabel swap (symmetry breaking)\n    colors2 = sorted(set(new_s))\n    if len(colors2) >= 2 and random.random() < 0.8:\n        a, b = random.sample(colors2, 2)\n        new_s = [b if x == a else (a if x == b else x) for x in new_s]\n    # 3) One or two Kempe-chain swaps\n    def kempe_once(arr):\n        if not arr:\n            return arr\n        idx = random.randrange(N)\n        c1 = arr[idx]\n        neigh_colors = list({arr[j] for j in adj[idx]})\n        if not neigh_colors:\n            return arr\n        c2 = random.choice(neigh_colors)\n        stack = [idx]\n        visited = {idx}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and (arr[v] == c1 or arr[v] == c2):\n                    visited.add(v)\n                    stack.append(v)\n        for u in comp:\n            if arr[u] == c1:\n                arr[u] = c2\n            elif arr[u] == c2:\n                arr[u] = c1\n        return arr\n    if random.random() < 0.9:\n        new_s = kempe_once(new_s)\n    if random.random() < 0.5:\n        new_s = kempe_once(new_s)\n    return fmt(new_s, kind)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001743962}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data (no globals used outside function scope)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k and contiguity\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = {x:1 for x in solution}\n    if set(labels.keys()) != set(range(1, k+1)):\n        return float(10**8 + k)\n    # Edge constraint violations\n    violations = 0\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return float(10**7 + violations * 10**4 + k)\n    # Feasible: objective equals k (minimize)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helper: compress labels to 1..k in a stable order of first appearance\ndef _compress_labels(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by either recoloring a single vertex or swapping two color labels\n    # Returns: (neighbor_solution, movement_type)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    n = len(sol)\n    if n == 0:\n        return (sol, \"noop\")\n    move = random.random()\n    if move < 0.6:\n        # Single-vertex recolor within current palette, with small chance to expand palette by +1\n        max_c = max(sol)\n        idx = random.randrange(n)\n        old = sol[idx]\n        choices = list(range(1, max_c + (1 if random.random() < 0.1 else 0) + 1))\n        if old in choices:\n            choices.remove(old)\n        if not choices:\n            return (sol, \"noop\")\n        sol[idx] = random.choice(choices)\n        sol = _compress_labels(sol)\n        return (sol, \"single_vertex_recolor\")\n    else:\n        # Swap two existing color labels globally\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop\")\n        a, b = random.sample(labels, 2)\n        swapped = []\n        for c in sol:\n            if c == a:\n                swapped.append(b)\n            elif c == b:\n                swapped.append(a)\n            else:\n                swapped.append(c)\n        swapped = _compress_labels(swapped)\n        return (swapped, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\n# Helper: compress labels to 1..k in a stable order of first appearance\ndef _compress_labels(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple random recolors and a possible label permutation\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    n = len(sol)\n    if n == 0:\n        return sol\n    max_c = max(sol)\n    # Recolor about 30% of vertices\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # Allow exploring up to max_c+1 colors occasionally\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        palette.remove(sol[idx])\n        sol[idx] = random.choice(palette) if palette else sol[idx]\n    # With some probability, permute color labels\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2 and random.random() < 0.7:\n        perm = labels[:]\n        random.shuffle(perm)\n        mapping = {labels[i]: perm[i] for i in range(len(labels))}\n        sol = [mapping[c] for c in sol]\n    sol = _compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000591428}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data (no globals used outside function scope)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k and contiguity\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = {x:1 for x in solution}\n    if set(labels.keys()) != set(range(1, k+1)):\n        return float(10**8 + k)\n    # Edge constraint violations\n    violations = 0\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return float(10**7 + violations * 10**4 + k)\n    # Feasible: objective equals k (minimize)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helper: compress labels to 1..k in a stable order of first appearance\ndef _compress_labels(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by either recoloring a single vertex or swapping two color labels\n    # Returns: (neighbor_solution, movement_type)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    n = len(sol)\n    if n == 0:\n        return (sol, \"noop\")\n    move = random.random()\n    if move < 0.6:\n        # Single-vertex recolor within current palette, with small chance to expand palette by +1\n        max_c = max(sol)\n        idx = random.randrange(n)\n        old = sol[idx]\n        choices = list(range(1, max_c + (1 if random.random() < 0.1 else 0) + 1))\n        if old in choices:\n            choices.remove(old)\n        if not choices:\n            return (sol, \"noop\")\n        sol[idx] = random.choice(choices)\n        sol = _compress_labels(sol)\n        return (sol, \"single_vertex_recolor\")\n    else:\n        # Swap two existing color labels globally\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop\")\n        a, b = random.sample(labels, 2)\n        swapped = []\n        for c in sol:\n            if c == a:\n                swapped.append(b)\n            elif c == b:\n                swapped.append(a)\n            else:\n                swapped.append(c)\n        swapped = _compress_labels(swapped)\n        return (swapped, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\n# Helper: compress labels to 1..k in a stable order of first appearance\ndef _compress_labels(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple random recolors and a possible label permutation\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    n = len(sol)\n    if n == 0:\n        return sol\n    max_c = max(sol)\n    # Recolor about 30% of vertices\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # Allow exploring up to max_c+1 colors occasionally\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        palette.remove(sol[idx])\n        sol[idx] = random.choice(palette) if palette else sol[idx]\n    # With some probability, permute color labels\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2 and random.random() < 0.7:\n        perm = labels[:]\n        random.shuffle(perm)\n        mapping = {labels[i]: perm[i] for i in range(len(labels))}\n        sol = [mapping[c] for c in sol]\n    sol = _compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000724079}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data (no globals used outside function scope)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k and contiguity\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = {x:1 for x in solution}\n    if set(labels.keys()) != set(range(1, k+1)):\n        return float(10**8 + k)\n    # Edge constraint violations\n    violations = 0\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return float(10**7 + violations * 10**4 + k)\n    # Feasible: objective equals k (minimize)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helper: compress labels to 1..k in a stable order of first appearance\ndef _compress_labels(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a neighbor by either recoloring a single vertex or swapping two color labels\n    # Returns: (neighbor_solution, movement_type)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    n = len(sol)\n    if n == 0:\n        return (sol, \"noop\")\n    move = random.random()\n    if move < 0.6:\n        # Single-vertex recolor within current palette, with small chance to expand palette by +1\n        max_c = max(sol)\n        idx = random.randrange(n)\n        old = sol[idx]\n        choices = list(range(1, max_c + (1 if random.random() < 0.1 else 0) + 1))\n        if old in choices:\n            choices.remove(old)\n        if not choices:\n            return (sol, \"noop\")\n        sol[idx] = random.choice(choices)\n        sol = _compress_labels(sol)\n        return (sol, \"single_vertex_recolor\")\n    else:\n        # Swap two existing color labels globally\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop\")\n        a, b = random.sample(labels, 2)\n        swapped = []\n        for c in sol:\n            if c == a:\n                swapped.append(b)\n            elif c == b:\n                swapped.append(a)\n            else:\n                swapped.append(c)\n        swapped = _compress_labels(swapped)\n        return (swapped, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\n# Helper: compress labels to 1..k in a stable order of first appearance\ndef _compress_labels(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple random recolors and a possible label permutation\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    n = len(sol)\n    if n == 0:\n        return sol\n    max_c = max(sol)\n    # Recolor about 30% of vertices\n    m = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for idx in idxs:\n        # Allow exploring up to max_c+1 colors occasionally\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        palette.remove(sol[idx])\n        sol[idx] = random.choice(palette) if palette else sol[idx]\n    # With some probability, permute color labels\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2 and random.random() < 0.7:\n        perm = labels[:]\n        random.shuffle(perm)\n        mapping = {labels[i]: perm[i] for i in range(len(labels))}\n        sol = [mapping[c] for c in sol]\n    sol = _compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000715659}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k and contiguity\n    k = 0\n    used = set()\n    for x in solution:\n        used.add(x)\n        if x > k:\n            k = x\n    # Label contiguity penalty (so solver can traverse non-contiguous states)\n    if used != set(range(1, k+1)):\n        return float(1e4 + k)\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return float(1e6 + 100 * violations + k)\n    # Feasible: objective equals k (minimize)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, movement_type)\n    # Embedded graph data and helpers\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Helper: conflicts count for a vertex if colored with color c\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.7:\n        # Conflict-driven recolor: pick a conflicted vertex and recolor to best color in 1..max_c\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # As a last resort allow exploring max_c+1 occasionally\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        return (sol, \"conflict_recolor\")\n    elif r < 0.9:\n        # Kempe-chain swap between two colors a and b\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex of color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        # BFS on subgraph induced by colors {a,b}\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        # swap a<->b on component\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n        return (sol, \"kempe_swap\")\n    else:\n        # Global label swap to change symmetry\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple conflict-driven recolors and a couple of Kempe swaps, then optional label compression\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        # try current palette plus optionally one new color\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        random.shuffle(palette)\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Apply multiple recolors on conflicting vertices\n    m = max(2, n \/\/ 3)\n    for _ in range(m):\n        bad = list(conflicts_set(sol))\n        if not bad:\n            # no conflicts: random vertex recolor to diversify\n            idx = random.randrange(n)\n            sol[idx] = best_recolor(idx)\n        else:\n            idx = random.choice(bad)\n            sol[idx] = best_recolor(idx)\n    # Apply a couple of Kempe swaps\n    for _ in range(2):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex\n        cand = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n    # Optional label compression to remove gaps if highest label is unused\n    used = list(dict.fromkeys(sol))\n    mapping = {c: i+1 for i, c in enumerate(used)}\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000887421}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k and contiguity\n    k = 0\n    used = set()\n    for x in solution:\n        used.add(x)\n        if x > k:\n            k = x\n    # Label contiguity penalty (so solver can traverse non-contiguous states)\n    if used != set(range(1, k+1)):\n        return float(1e4 + k)\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return float(1e6 + 100 * violations + k)\n    # Feasible: objective equals k (minimize)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, movement_type)\n    # Embedded graph data and helpers\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Helper: conflicts count for a vertex if colored with color c\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.7:\n        # Conflict-driven recolor: pick a conflicted vertex and recolor to best color in 1..max_c\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # As a last resort allow exploring max_c+1 occasionally\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        return (sol, \"conflict_recolor\")\n    elif r < 0.9:\n        # Kempe-chain swap between two colors a and b\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex of color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        # BFS on subgraph induced by colors {a,b}\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        # swap a<->b on component\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n        return (sol, \"kempe_swap\")\n    else:\n        # Global label swap to change symmetry\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple conflict-driven recolors and a couple of Kempe swaps, then optional label compression\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        # try current palette plus optionally one new color\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        random.shuffle(palette)\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Apply multiple recolors on conflicting vertices\n    m = max(2, n \/\/ 3)\n    for _ in range(m):\n        bad = list(conflicts_set(sol))\n        if not bad:\n            # no conflicts: random vertex recolor to diversify\n            idx = random.randrange(n)\n            sol[idx] = best_recolor(idx)\n        else:\n            idx = random.choice(bad)\n            sol[idx] = best_recolor(idx)\n    # Apply a couple of Kempe swaps\n    for _ in range(2):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex\n        cand = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n    # Optional label compression to remove gaps if highest label is unused\n    used = list(dict.fromkeys(sol))\n    mapping = {c: i+1 for i, c in enumerate(used)}\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001275876}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    # Element checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k and contiguity\n    k = 0\n    used = set()\n    for x in solution:\n        used.add(x)\n        if x > k:\n            k = x\n    # Label contiguity penalty (so solver can traverse non-contiguous states)\n    if used != set(range(1, k+1)):\n        return float(1e4 + k)\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return float(1e6 + 100 * violations + k)\n    # Feasible: objective equals k (minimize)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, movement_type)\n    # Embedded graph data and helpers\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Helper: conflicts count for a vertex if colored with color c\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.7:\n        # Conflict-driven recolor: pick a conflicted vertex and recolor to best color in 1..max_c\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # As a last resort allow exploring max_c+1 occasionally\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        return (sol, \"conflict_recolor\")\n    elif r < 0.9:\n        # Kempe-chain swap between two colors a and b\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex of color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        # BFS on subgraph induced by colors {a,b}\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        # swap a<->b on component\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n        return (sol, \"kempe_swap\")\n    else:\n        # Global label swap to change symmetry\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n        return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple conflict-driven recolors and a couple of Kempe swaps, then optional label compression\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        # try current palette plus optionally one new color\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        random.shuffle(palette)\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Apply multiple recolors on conflicting vertices\n    m = max(2, n \/\/ 3)\n    for _ in range(m):\n        bad = list(conflicts_set(sol))\n        if not bad:\n            # no conflicts: random vertex recolor to diversify\n            idx = random.randrange(n)\n            sol[idx] = best_recolor(idx)\n        else:\n            idx = random.choice(bad)\n            sol[idx] = best_recolor(idx)\n    # Apply a couple of Kempe swaps\n    for _ in range(2):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex\n        cand = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n    # Optional label compression to remove gaps if highest label is unused\n    used = list(dict.fromkeys(sol))\n    mapping = {c: i+1 for i, c in enumerate(used)}\n    sol = [mapping[c] for c in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001191795}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**12\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k, used labels, and violations\n    used = set()\n    k = 0\n    for x in solution:\n        used.add(x)\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Contiguity gap: how many labels in 1..k are unused\n    contiguity_gap = k - len(used) if k >= 1 else 0\n    # Lexicographic objective via weighted sum: minimize violations, then contiguity gap, then k\n    cost = 1_000_000.0 * violations + 10_000.0 * contiguity_gap + float(k)\n    return cost\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, movement_type)\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def normalize_labels(s):\n        # Deterministic compression of labels to 1..|used|\n        used_order = []\n        seen = set()\n        for c in s:\n            if c not in seen:\n                seen.add(c)\n                used_order.append(c)\n        mapping = {c: i+1 for i, c in enumerate(used_order)}\n        return [mapping[c] for c in s]\n    # Helper: conflicts for vertex if colored c\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.6:\n        # Conflict-driven recolor to reduce local conflicts\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # occasional exploration to new label\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        sol = normalize_labels(sol)\n        return (sol, \"conflict_recolor\")\n    elif r < 0.9:\n        # Kempe-chain swap between two colors a and b\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        # DFS on subgraph induced by colors {a,b}\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        # swap a<->b on component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        sol = normalize_labels(sol)\n        return (sol, \"kempe_swap\")\n    else:\n        # Attempt to eliminate highest label if possible via greedy recoloring of that class\n        labels = list(dict.fromkeys(sol))\n        k = len(labels)\n        if k <= 1:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        success = True\n        for idx in class_vertices:\n            # try assign a color in 1..highest-1 avoiding neighbor conflicts\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize_labels(sol)\n            return (sol, \"eliminate_highest\")\n        else:\n            # fallback: global label swap for symmetry breaking\n            a, b = random.sample(labels, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            sol = normalize_labels(sol)\n            return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolors on conflicts, Kempe swaps, then label compression\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def normalize_labels(s):\n        used_order = []\n        seen = set()\n        for c in s:\n            if c not in seen:\n                seen.add(c)\n                used_order.append(c)\n        mapping = {c: i+1 for i, c in enumerate(used_order)}\n        return [mapping[c] for c in s]\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        random.shuffle(palette)\n        # choose color minimizing conflicts locally\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Phase 1: multiple conflict-driven recolors or diversifying recolors\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        bad = list(conflicts_set(sol))\n        if bad:\n            idx = random.choice(bad)\n        else:\n            idx = random.randrange(n)\n        sol[idx] = best_recolor(idx)\n    # Phase 2: a few Kempe swaps on random color pairs\n    for _ in range(3):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex in {a,b}\n        cand = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n    # Phase 3: optional attempt to eliminate highest label\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2:\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        success = True\n        for idx in class_vertices:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        # even if failed, we keep the diversification performed\n    # Normalize labels to reduce symmetry\n    sol = normalize_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001300786}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**12\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k, used labels, and violations\n    used = set()\n    k = 0\n    for x in solution:\n        used.add(x)\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Contiguity gap: how many labels in 1..k are unused\n    contiguity_gap = k - len(used) if k >= 1 else 0\n    # Lexicographic objective via weighted sum: minimize violations, then contiguity gap, then k\n    cost = 1_000_000.0 * violations + 10_000.0 * contiguity_gap + float(k)\n    return cost\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, movement_type)\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def normalize_labels(s):\n        # Deterministic compression of labels to 1..|used|\n        used_order = []\n        seen = set()\n        for c in s:\n            if c not in seen:\n                seen.add(c)\n                used_order.append(c)\n        mapping = {c: i+1 for i, c in enumerate(used_order)}\n        return [mapping[c] for c in s]\n    # Helper: conflicts for vertex if colored c\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.6:\n        # Conflict-driven recolor to reduce local conflicts\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # occasional exploration to new label\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        sol = normalize_labels(sol)\n        return (sol, \"conflict_recolor\")\n    elif r < 0.9:\n        # Kempe-chain swap between two colors a and b\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        # DFS on subgraph induced by colors {a,b}\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        # swap a<->b on component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        sol = normalize_labels(sol)\n        return (sol, \"kempe_swap\")\n    else:\n        # Attempt to eliminate highest label if possible via greedy recoloring of that class\n        labels = list(dict.fromkeys(sol))\n        k = len(labels)\n        if k <= 1:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        success = True\n        for idx in class_vertices:\n            # try assign a color in 1..highest-1 avoiding neighbor conflicts\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize_labels(sol)\n            return (sol, \"eliminate_highest\")\n        else:\n            # fallback: global label swap for symmetry breaking\n            a, b = random.sample(labels, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            sol = normalize_labels(sol)\n            return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolors on conflicts, Kempe swaps, then label compression\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def normalize_labels(s):\n        used_order = []\n        seen = set()\n        for c in s:\n            if c not in seen:\n                seen.add(c)\n                used_order.append(c)\n        mapping = {c: i+1 for i, c in enumerate(used_order)}\n        return [mapping[c] for c in s]\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        random.shuffle(palette)\n        # choose color minimizing conflicts locally\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Phase 1: multiple conflict-driven recolors or diversifying recolors\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        bad = list(conflicts_set(sol))\n        if bad:\n            idx = random.choice(bad)\n        else:\n            idx = random.randrange(n)\n        sol[idx] = best_recolor(idx)\n    # Phase 2: a few Kempe swaps on random color pairs\n    for _ in range(3):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex in {a,b}\n        cand = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n    # Phase 3: optional attempt to eliminate highest label\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2:\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        success = True\n        for idx in class_vertices:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        # even if failed, we keep the diversification performed\n    # Normalize labels to reduce symmetry\n    sol = normalize_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001619921}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**12\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != len(V):\n        return float(BIG - 1)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Compute k, used labels, and violations\n    used = set()\n    k = 0\n    for x in solution:\n        used.add(x)\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Contiguity gap: how many labels in 1..k are unused\n    contiguity_gap = k - len(used) if k >= 1 else 0\n    # Lexicographic objective via weighted sum: minimize violations, then contiguity gap, then k\n    cost = 1_000_000.0 * violations + 10_000.0 * contiguity_gap + float(k)\n    return cost\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, movement_type)\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def normalize_labels(s):\n        # Deterministic compression of labels to 1..|used|\n        used_order = []\n        seen = set()\n        for c in s:\n            if c not in seen:\n                seen.add(c)\n                used_order.append(c)\n        mapping = {c: i+1 for i, c in enumerate(used_order)}\n        return [mapping[c] for c in s]\n    # Helper: conflicts for vertex if colored c\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.6:\n        # Conflict-driven recolor to reduce local conflicts\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # occasional exploration to new label\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        sol = normalize_labels(sol)\n        return (sol, \"conflict_recolor\")\n    elif r < 0.9:\n        # Kempe-chain swap between two colors a and b\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        # DFS on subgraph induced by colors {a,b}\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        # swap a<->b on component\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        sol = normalize_labels(sol)\n        return (sol, \"kempe_swap\")\n    else:\n        # Attempt to eliminate highest label if possible via greedy recoloring of that class\n        labels = list(dict.fromkeys(sol))\n        k = len(labels)\n        if k <= 1:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        success = True\n        for idx in class_vertices:\n            # try assign a color in 1..highest-1 avoiding neighbor conflicts\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize_labels(sol)\n            return (sol, \"eliminate_highest\")\n        else:\n            # fallback: global label swap for symmetry breaking\n            a, b = random.sample(labels, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            sol = normalize_labels(sol)\n            return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple recolors on conflicts, Kempe swaps, then label compression\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    def normalize_labels(s):\n        used_order = []\n        seen = set()\n        for c in s:\n            if c not in seen:\n                seen.add(c)\n                used_order.append(c)\n        mapping = {c: i+1 for i, c in enumerate(used_order)}\n        return [mapping[c] for c in s]\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        palette = list(range(1, max_c + (1 if random.random() < 0.3 else 0) + 1))\n        random.shuffle(palette)\n        # choose color minimizing conflicts locally\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Phase 1: multiple conflict-driven recolors or diversifying recolors\n    steps = max(3, n \/\/ 2)\n    for _ in range(steps):\n        bad = list(conflicts_set(sol))\n        if bad:\n            idx = random.choice(bad)\n        else:\n            idx = random.randrange(n)\n        sol[idx] = best_recolor(idx)\n    # Phase 2: a few Kempe swaps on random color pairs\n    for _ in range(3):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # pick a seed vertex in {a,b}\n        cand = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            continue\n        seed = random.choice(cand)\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        target = {a, b}\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n    # Phase 3: optional attempt to eliminate highest label\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2:\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        success = True\n        for idx in class_vertices:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        # even if failed, we keep the diversification performed\n    # Normalize labels to reduce symmetry\n    sol = normalize_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001593119}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    # Type\/shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**15\n    if len(solution) != n:\n        return 10**15 - 1\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**15 - 2\n    # Compute k, used labels\n    used = set(solution)\n    k = max(solution) if solution else 0\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Contiguity gap: missing labels in 1..k\n    contiguity_gap = 0\n    if k >= 1:\n        contiguity_gap = k - sum(1 for c in range(1, k+1) if c in used)\n    # Lexicographic scalarization with wide integer bands: (violations, contiguity_gap, k)\n    # Band widths chosen to avoid overlap: max k <= n, contiguity_gap <= n\n    cost = violations * (1 << 40) + contiguity_gap * (1 << 20) + k\n    return int(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    # Make a local copy\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Canonical normalization: labels ordered by increasing min vertex index of each label\n    def normalize_labels(s):\n        label_to_min_idx = {}\n        for i, c in enumerate(s):\n            if c not in label_to_min_idx:\n                label_to_min_idx[c] = i\n        # sort labels by min index\n        ordered = sorted(label_to_min_idx.items(), key=lambda x: x[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(ordered)}\n        return [mapping[c] for c in s]\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.55:\n        # Conflict-driven recolor toward least-conflict colors\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # occasional exploration to a new label\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        sol = normalize_labels(sol)\n        return (sol, \"conflict_recolor\")\n    elif r < 0.85:\n        # Kempe-chain swap, biased to include highest label when possible\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        if len(labels) >= 2 and random.random() < 0.7:\n            a = highest\n            b = random.choice([x for x in labels if x != a])\n        else:\n            a, b = random.sample(labels, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        sol = normalize_labels(sol)\n        return (sol, \"kempe_swap\")\n    else:\n        # Targeted elimination attempt of highest label via greedy recoloring\n        labels = list(dict.fromkeys(sol))\n        if len(labels) <= 1:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        order = class_vertices[:]\n        random.shuffle(order)\n        success = True\n        for idx in order:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize_labels(sol)\n            return (sol, \"eliminate_highest\")\n        else:\n            # Symmetry-breaking label swap\n            a, b = random.sample(labels, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            sol = normalize_labels(sol)\n            return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Canonical normalization\n    def normalize_labels(s):\n        label_to_min_idx = {}\n        for i, c in enumerate(s):\n            if c not in label_to_min_idx:\n                label_to_min_idx[c] = i\n        ordered = sorted(label_to_min_idx.items(), key=lambda x: x[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(ordered)}\n        return [mapping[c] for c in s]\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def local_best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        # Occasionally allow introducing a new color for diversification\n        allow_new = 1 if random.random() < 0.3 else 0\n        palette = list(range(1, max_c + allow_new + 1))\n        random.shuffle(palette)\n        # choose color minimizing conflicts locally\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = 0\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    c_conf += 1\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Phase 1: conflict-focused recolors or random recolors\n    steps = max(4, n)\n    for _ in range(steps):\n        bad = list(conflicts_set(sol))\n        if bad:\n            idx = random.choice(bad)\n        else:\n            idx = random.randrange(n)\n        sol[idx] = local_best_recolor(idx)\n    # Phase 2: multiple Kempe swaps on random color pairs\n    for _ in range(4):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            continue\n        seed = random.choice(candidates)\n        target = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n    # Phase 3: try to eliminate highest label greedily\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2:\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        random.shuffle(class_vertices)\n        success = True\n        for idx in class_vertices:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        # keep diversification regardless of success\n    sol = normalize_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001198835}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    # Type\/shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**15\n    if len(solution) != n:\n        return 10**15 - 1\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**15 - 2\n    # Compute k, used labels\n    used = set(solution)\n    k = max(solution) if solution else 0\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Contiguity gap: missing labels in 1..k\n    contiguity_gap = 0\n    if k >= 1:\n        contiguity_gap = k - sum(1 for c in range(1, k+1) if c in used)\n    # Lexicographic scalarization with wide integer bands: (violations, contiguity_gap, k)\n    # Band widths chosen to avoid overlap: max k <= n, contiguity_gap <= n\n    cost = violations * (1 << 40) + contiguity_gap * (1 << 20) + k\n    return int(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    # Make a local copy\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Canonical normalization: labels ordered by increasing min vertex index of each label\n    def normalize_labels(s):\n        label_to_min_idx = {}\n        for i, c in enumerate(s):\n            if c not in label_to_min_idx:\n                label_to_min_idx[c] = i\n        # sort labels by min index\n        ordered = sorted(label_to_min_idx.items(), key=lambda x: x[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(ordered)}\n        return [mapping[c] for c in s]\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.55:\n        # Conflict-driven recolor toward least-conflict colors\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # occasional exploration to a new label\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        sol = normalize_labels(sol)\n        return (sol, \"conflict_recolor\")\n    elif r < 0.85:\n        # Kempe-chain swap, biased to include highest label when possible\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        if len(labels) >= 2 and random.random() < 0.7:\n            a = highest\n            b = random.choice([x for x in labels if x != a])\n        else:\n            a, b = random.sample(labels, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        sol = normalize_labels(sol)\n        return (sol, \"kempe_swap\")\n    else:\n        # Targeted elimination attempt of highest label via greedy recoloring\n        labels = list(dict.fromkeys(sol))\n        if len(labels) <= 1:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        order = class_vertices[:]\n        random.shuffle(order)\n        success = True\n        for idx in order:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize_labels(sol)\n            return (sol, \"eliminate_highest\")\n        else:\n            # Symmetry-breaking label swap\n            a, b = random.sample(labels, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            sol = normalize_labels(sol)\n            return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Canonical normalization\n    def normalize_labels(s):\n        label_to_min_idx = {}\n        for i, c in enumerate(s):\n            if c not in label_to_min_idx:\n                label_to_min_idx[c] = i\n        ordered = sorted(label_to_min_idx.items(), key=lambda x: x[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(ordered)}\n        return [mapping[c] for c in s]\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def local_best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        # Occasionally allow introducing a new color for diversification\n        allow_new = 1 if random.random() < 0.3 else 0\n        palette = list(range(1, max_c + allow_new + 1))\n        random.shuffle(palette)\n        # choose color minimizing conflicts locally\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = 0\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    c_conf += 1\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Phase 1: conflict-focused recolors or random recolors\n    steps = max(4, n)\n    for _ in range(steps):\n        bad = list(conflicts_set(sol))\n        if bad:\n            idx = random.choice(bad)\n        else:\n            idx = random.randrange(n)\n        sol[idx] = local_best_recolor(idx)\n    # Phase 2: multiple Kempe swaps on random color pairs\n    for _ in range(4):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            continue\n        seed = random.choice(candidates)\n        target = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n    # Phase 3: try to eliminate highest label greedily\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2:\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        random.shuffle(class_vertices)\n        success = True\n        for idx in class_vertices:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        # keep diversification regardless of success\n    sol = normalize_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001671651}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    # Type\/shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**15\n    if len(solution) != n:\n        return 10**15 - 1\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**15 - 2\n    # Compute k, used labels\n    used = set(solution)\n    k = max(solution) if solution else 0\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Contiguity gap: missing labels in 1..k\n    contiguity_gap = 0\n    if k >= 1:\n        contiguity_gap = k - sum(1 for c in range(1, k+1) if c in used)\n    # Lexicographic scalarization with wide integer bands: (violations, contiguity_gap, k)\n    # Band widths chosen to avoid overlap: max k <= n, contiguity_gap <= n\n    cost = violations * (1 << 40) + contiguity_gap * (1 << 20) + k\n    return int(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    # Make a local copy\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return (sol, \"noop_invalid_len\")\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Canonical normalization: labels ordered by increasing min vertex index of each label\n    def normalize_labels(s):\n        label_to_min_idx = {}\n        for i, c in enumerate(s):\n            if c not in label_to_min_idx:\n                label_to_min_idx[c] = i\n        # sort labels by min index\n        ordered = sorted(label_to_min_idx.items(), key=lambda x: x[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(ordered)}\n        return [mapping[c] for c in s]\n    def vertex_conflicts(idx, c):\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    max_c = max(sol) if sol else 1\n    r = random.random()\n    if conflicts and r < 0.55:\n        # Conflict-driven recolor toward least-conflict colors\n        idx = random.choice(list(conflicts))\n        current = sol[idx]\n        best_c = current\n        best_score = vertex_conflicts(idx, current)\n        candidates = list(range(1, max_c+1))\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == current:\n                continue\n            sc = vertex_conflicts(idx, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n                if best_score == 0:\n                    break\n        # occasional exploration to a new label\n        if best_c == current and random.random() < 0.1:\n            best_c = max_c + 1\n        sol[idx] = best_c\n        sol = normalize_labels(sol)\n        return (sol, \"conflict_recolor\")\n    elif r < 0.85:\n        # Kempe-chain swap, biased to include highest label when possible\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        if len(labels) >= 2 and random.random() < 0.7:\n            a = highest\n            b = random.choice([x for x in labels if x != a])\n        else:\n            a, b = random.sample(labels, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return (sol, \"noop_no_ab\")\n        seed = random.choice(candidates)\n        target_colors = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target_colors:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        sol = normalize_labels(sol)\n        return (sol, \"kempe_swap\")\n    else:\n        # Targeted elimination attempt of highest label via greedy recoloring\n        labels = list(dict.fromkeys(sol))\n        if len(labels) <= 1:\n            return (sol, \"noop_labels<2\")\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        order = class_vertices[:]\n        random.shuffle(order)\n        success = True\n        for idx in order:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = normalize_labels(sol)\n            return (sol, \"eliminate_highest\")\n        else:\n            # Symmetry-breaking label swap\n            a, b = random.sample(labels, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            sol = normalize_labels(sol)\n            return (sol, \"swap_labels\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    n = len(V)\n    if not isinstance(solution, list):\n        sol = list(solution)\n    else:\n        sol = solution[:]\n    if len(sol) != n:\n        return sol\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n    # Canonical normalization\n    def normalize_labels(s):\n        label_to_min_idx = {}\n        for i, c in enumerate(s):\n            if c not in label_to_min_idx:\n                label_to_min_idx[c] = i\n        ordered = sorted(label_to_min_idx.items(), key=lambda x: x[1])\n        mapping = {c: i+1 for i, (c, _) in enumerate(ordered)}\n        return [mapping[c] for c in s]\n    def conflicts_set(s):\n        bad = set()\n        for (u, v) in E:\n            if s[u-1] == s[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return bad\n    def local_best_recolor(idx):\n        max_c = max(sol)\n        curr = sol[idx]\n        # Occasionally allow introducing a new color for diversification\n        allow_new = 1 if random.random() < 0.3 else 0\n        palette = list(range(1, max_c + allow_new + 1))\n        random.shuffle(palette)\n        # choose color minimizing conflicts locally\n        best_c = curr\n        best_conf = sum(1 for nb in adj[idx] if sol[nb] == curr)\n        for c in palette:\n            if c == curr:\n                continue\n            c_conf = 0\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    c_conf += 1\n            if c_conf < best_conf:\n                best_conf = c_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        return best_c\n    # Phase 1: conflict-focused recolors or random recolors\n    steps = max(4, n)\n    for _ in range(steps):\n        bad = list(conflicts_set(sol))\n        if bad:\n            idx = random.choice(bad)\n        else:\n            idx = random.randrange(n)\n        sol[idx] = local_best_recolor(idx)\n    # Phase 2: multiple Kempe swaps on random color pairs\n    for _ in range(4):\n        labels = list(dict.fromkeys(sol))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            continue\n        seed = random.choice(candidates)\n        target = {a, b}\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if not seen[w] and sol[w] in target:\n                    seen[w] = True\n                    stack.append(w)\n        for u in comp:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n    # Phase 3: try to eliminate highest label greedily\n    labels = list(dict.fromkeys(sol))\n    if len(labels) >= 2:\n        highest = max(labels)\n        class_vertices = [i for i, c in enumerate(sol) if c == highest]\n        random.shuffle(class_vertices)\n        success = True\n        for idx in class_vertices:\n            options = list(range(1, highest))\n            random.shuffle(options)\n            placed = False\n            for c in options:\n                ok = True\n                for nb in adj[idx]:\n                    if sol[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    sol[idx] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        # keep diversification regardless of success\n    sol = normalize_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001669101}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9  \/\/ solution is a Python-style list of 9 positive integers representing colors for vertices 1..9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        canon = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            canon.append(relabel[v])\n        return canon\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init():\n        # simple greedy initialization\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0]*n\n        for u in range(1, n+1):\n            used = {sol[v-1] for v in adj[u] if sol[v-1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u-1] = c\n        return sol\n    # Prepare working solution\n    if not is_valid_input(solution):\n        sol = random_init()\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u,v))\n    # Choose a vertex to modify\n    if conflicts:\n        # focus on conflicts\n        u,v = random.choice(conflicts)\n        target = random.choice([u,v])\n    else:\n        target = random.randint(1, n)\n    # Attempt recoloring\n    colors = sorted(set(sol))\n    best_color = None\n    best_conflicts = math.inf\n    for c in colors:\n        if c == sol[target-1]:\n            continue\n        conf = sum(1 for w in adj[target] if sol[w-1] == c)\n        if conf < best_conflicts:\n            best_conflicts = conf\n            best_color = c\n            if best_conflicts == 0:\n                break\n    # Optionally allow introducing a new color if all conflict\n    if best_color is None or best_conflicts > 0:\n        # with small probability use a new color to escape dead-ends\n        if random.random() < 0.1:\n            best_color = max(colors) + 1\n        else:\n            # fallback to least conflicting among existing\n            if best_color is None:\n                best_color = max(colors)  # no change safety; will be overwritten below\n                best_conflicts = sum(1 for w in adj[target] if sol[w-1] == best_color)\n    new_sol = list(sol)\n    # ensure a color different from current\n    if best_color is None or best_color == sol[target-1]:\n        # pick any different color (add new if needed)\n        cand = [c for c in colors if c != sol[target-1]]\n        if not cand:\n            cand = [max(colors)+1]\n        best_color = random.choice(cand)\n    new_sol[target-1] = best_color\n    # Canonicalize to keep color labels compact\n    new_sol = canonicalize(new_sol)\n    return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        canon = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            canon.append(relabel[v])\n        return canon\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0]*n\n        for u in range(1, n+1):\n            used = {sol[v-1] for v in adj[u] if sol[v-1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u-1] = c\n        return sol\n    # Prepare solution\n    if not is_valid_input(solution):\n        sol = random_init()\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(sol)\n    # 1) Kempe-chain swap on random colors\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        # BFS on subgraph induced by colors c1 and c2\n        visited = set()\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        # swap colors on the visited component\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n    # 2) Random multi-vertex recolors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        cand = [c for c in colors if c != new_sol[u-1]]\n        # occasionally introduce a new color to diversify\n        if random.random() < 0.15:\n            cand.append(max(colors) + 1)\n        new_sol[u-1] = random.choice(cand)\n    # Canonicalize\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000917009}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9  \/\/ solution is a Python-style list of 9 positive integers representing colors for vertices 1..9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        canon = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            canon.append(relabel[v])\n        return canon\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init():\n        # simple greedy initialization\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0]*n\n        for u in range(1, n+1):\n            used = {sol[v-1] for v in adj[u] if sol[v-1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u-1] = c\n        return sol\n    # Prepare working solution\n    if not is_valid_input(solution):\n        sol = random_init()\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u,v))\n    # Choose a vertex to modify\n    if conflicts:\n        # focus on conflicts\n        u,v = random.choice(conflicts)\n        target = random.choice([u,v])\n    else:\n        target = random.randint(1, n)\n    # Attempt recoloring\n    colors = sorted(set(sol))\n    best_color = None\n    best_conflicts = math.inf\n    for c in colors:\n        if c == sol[target-1]:\n            continue\n        conf = sum(1 for w in adj[target] if sol[w-1] == c)\n        if conf < best_conflicts:\n            best_conflicts = conf\n            best_color = c\n            if best_conflicts == 0:\n                break\n    # Optionally allow introducing a new color if all conflict\n    if best_color is None or best_conflicts > 0:\n        # with small probability use a new color to escape dead-ends\n        if random.random() < 0.1:\n            best_color = max(colors) + 1\n        else:\n            # fallback to least conflicting among existing\n            if best_color is None:\n                best_color = max(colors)  # no change safety; will be overwritten below\n                best_conflicts = sum(1 for w in adj[target] if sol[w-1] == best_color)\n    new_sol = list(sol)\n    # ensure a color different from current\n    if best_color is None or best_color == sol[target-1]:\n        # pick any different color (add new if needed)\n        cand = [c for c in colors if c != sol[target-1]]\n        if not cand:\n            cand = [max(colors)+1]\n        best_color = random.choice(cand)\n    new_sol[target-1] = best_color\n    # Canonicalize to keep color labels compact\n    new_sol = canonicalize(new_sol)\n    return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        canon = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            canon.append(relabel[v])\n        return canon\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0]*n\n        for u in range(1, n+1):\n            used = {sol[v-1] for v in adj[u] if sol[v-1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u-1] = c\n        return sol\n    # Prepare solution\n    if not is_valid_input(solution):\n        sol = random_init()\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(sol)\n    # 1) Kempe-chain swap on random colors\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        # BFS on subgraph induced by colors c1 and c2\n        visited = set()\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        # swap colors on the visited component\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n    # 2) Random multi-vertex recolors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        cand = [c for c in colors if c != new_sol[u-1]]\n        # occasionally introduce a new color to diversify\n        if random.random() < 0.15:\n            cand.append(max(colors) + 1)\n        new_sol[u-1] = random.choice(cand)\n    # Canonicalize\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00121043}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9  \/\/ solution is a Python-style list of 9 positive integers representing colors for vertices 1..9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        canon = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            canon.append(relabel[v])\n        return canon\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init():\n        # simple greedy initialization\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0]*n\n        for u in range(1, n+1):\n            used = {sol[v-1] for v in adj[u] if sol[v-1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u-1] = c\n        return sol\n    # Prepare working solution\n    if not is_valid_input(solution):\n        sol = random_init()\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u,v))\n    # Choose a vertex to modify\n    if conflicts:\n        # focus on conflicts\n        u,v = random.choice(conflicts)\n        target = random.choice([u,v])\n    else:\n        target = random.randint(1, n)\n    # Attempt recoloring\n    colors = sorted(set(sol))\n    best_color = None\n    best_conflicts = math.inf\n    for c in colors:\n        if c == sol[target-1]:\n            continue\n        conf = sum(1 for w in adj[target] if sol[w-1] == c)\n        if conf < best_conflicts:\n            best_conflicts = conf\n            best_color = c\n            if best_conflicts == 0:\n                break\n    # Optionally allow introducing a new color if all conflict\n    if best_color is None or best_conflicts > 0:\n        # with small probability use a new color to escape dead-ends\n        if random.random() < 0.1:\n            best_color = max(colors) + 1\n        else:\n            # fallback to least conflicting among existing\n            if best_color is None:\n                best_color = max(colors)  # no change safety; will be overwritten below\n                best_conflicts = sum(1 for w in adj[target] if sol[w-1] == best_color)\n    new_sol = list(sol)\n    # ensure a color different from current\n    if best_color is None or best_color == sol[target-1]:\n        # pick any different color (add new if needed)\n        cand = [c for c in colors if c != sol[target-1]]\n        if not cand:\n            cand = [max(colors)+1]\n        best_color = random.choice(cand)\n    new_sol[target-1] = best_color\n    # Canonicalize to keep color labels compact\n    new_sol = canonicalize(new_sol)\n    return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        canon = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            canon.append(relabel[v])\n        return canon\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        sol = [0]*n\n        for u in range(1, n+1):\n            used = {sol[v-1] for v in adj[u] if sol[v-1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[u-1] = c\n        return sol\n    # Prepare solution\n    if not is_valid_input(solution):\n        sol = random_init()\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = list(sol)\n    # 1) Kempe-chain swap on random colors\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        # BFS on subgraph induced by colors c1 and c2\n        visited = set()\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        # swap colors on the visited component\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n    # 2) Random multi-vertex recolors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        cand = [c for c in colors if c != new_sol[u-1]]\n        # occasionally introduce a new color to diversify\n        if random.random() < 0.15:\n            cand.append(max(colors) + 1)\n        new_sol[u-1] = random.choice(cand)\n    # Canonicalize\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001177151}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\n# Neighbor generator with multiple move types; returns (new_solution, NB_Type, Movement_Type)\n# Signature as required by contract\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init_dsatur():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        saturation = {i: 0 for i in range(1, n+1)}\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n    # Prepare base solution\n    if not is_valid_input(solution):\n        sol = random_init_dsatur()\n    else:\n        sol = list(solution)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    sol = canonicalize(sol)\n\n    # Utility: conflict list\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            cand_vertices = []\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            # fallback to recolor\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            new_sol = canonicalize(new_sol)\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class swap\/merge (attempt reduce K)\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        # try to merge a sparse color into others if possible; else swap labels\n        c_from = random.choice(colors)\n        # try recolor vertices of c_from greedily to existing other colors\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from:\n                new_sol[u-1] = best\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        # fallback trivial change\n        new_sol[0] = new_sol[0] + 1\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init_dsatur():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n    if not is_valid_input(solution):\n        sol = random_init_dsatur()\n    else:\n        sol = list(solution)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = canonicalize(sol)\n\n    # Apply a sequence of strong shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        new_sol = canonicalize(new_sol)\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 4)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.2:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n        new_sol = canonicalize(new_sol)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001445334}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\n# Neighbor generator with multiple move types; returns (new_solution, NB_Type, Movement_Type)\n# Signature as required by contract\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init_dsatur():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        saturation = {i: 0 for i in range(1, n+1)}\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n    # Prepare base solution\n    if not is_valid_input(solution):\n        sol = random_init_dsatur()\n    else:\n        sol = list(solution)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    sol = canonicalize(sol)\n\n    # Utility: conflict list\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            cand_vertices = []\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            # fallback to recolor\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            new_sol = canonicalize(new_sol)\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class swap\/merge (attempt reduce K)\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        # try to merge a sparse color into others if possible; else swap labels\n        c_from = random.choice(colors)\n        # try recolor vertices of c_from greedily to existing other colors\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from:\n                new_sol[u-1] = best\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        # fallback trivial change\n        new_sol[0] = new_sol[0] + 1\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init_dsatur():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n    if not is_valid_input(solution):\n        sol = random_init_dsatur()\n    else:\n        sol = list(solution)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = canonicalize(sol)\n\n    # Apply a sequence of strong shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        new_sol = canonicalize(new_sol)\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 4)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.2:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n        new_sol = canonicalize(new_sol)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001880149}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    # Objective: minimize K with zero conflicts; penalize conflicts heavily\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\n# Neighbor generator with multiple move types; returns (new_solution, NB_Type, Movement_Type)\n# Signature as required by contract\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init_dsatur():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        saturation = {i: 0 for i in range(1, n+1)}\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n    # Prepare base solution\n    if not is_valid_input(solution):\n        sol = random_init_dsatur()\n    else:\n        sol = list(solution)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    sol = canonicalize(sol)\n\n    # Utility: conflict list\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            cand_vertices = []\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            # fallback to recolor\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            new_sol = canonicalize(new_sol)\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class swap\/merge (attempt reduce K)\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        # try to merge a sparse color into others if possible; else swap labels\n        c_from = random.choice(colors)\n        # try recolor vertices of c_from greedily to existing other colors\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from:\n                new_sol[u-1] = best\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        # fallback trivial change\n        new_sol[0] = new_sol[0] + 1\n        new_sol = canonicalize(new_sol)\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != 9:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n    def random_init_dsatur():\n        n = 9\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n    if not is_valid_input(solution):\n        sol = random_init_dsatur()\n    else:\n        sol = list(solution)\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    new_sol = canonicalize(sol)\n\n    # Apply a sequence of strong shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        new_sol = canonicalize(new_sol)\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 4)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.2:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n        new_sol = canonicalize(new_sol)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001909909}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbor generator with multiple move types\n# Returns (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    # Base solution\n    sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Utility: compute conflict edges\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class merge attempt\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c_from = random.choice(colors)\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from:\n                new_sol[u-1] = best\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        new_sol[0] = new_sol[0] + 1\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n# Strong perturbation for ILS\/SA restarts\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    new_sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Kempe-chain shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 5)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.25:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001217193}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbor generator with multiple move types\n# Returns (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    # Base solution\n    sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Utility: compute conflict edges\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class merge attempt\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c_from = random.choice(colors)\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from:\n                new_sol[u-1] = best\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        new_sol[0] = new_sol[0] + 1\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n# Strong perturbation for ILS\/SA restarts\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    new_sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Kempe-chain shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 5)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.25:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001611787}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbor generator with multiple move types\n# Returns (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    # Base solution\n    sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Utility: compute conflict edges\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class merge attempt\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c_from = random.choice(colors)\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from:\n                new_sol[u-1] = best\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        new_sol[0] = new_sol[0] + 1\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n# Strong perturbation for ILS\/SA restarts\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    new_sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Kempe-chain shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start = random.randint(1, n)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 5)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.25:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001598707}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbor generator with multiple move types\n# Returns (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    # Base solution\n    sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Utility: compute conflict edges\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start_candidates = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n        if not start_candidates:\n            return (new_sol, \"NoOp\", \"Kempe-Empty\")\n        start = random.choice(start_candidates)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class merge attempt (restricted)\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c_from = random.choice(colors)\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from and best_conf == 0:\n                new_sol[u-1] = best\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        new_sol[0] = new_sol[0] + 1\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n# Strong perturbation for ILS\/SA restarts\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    new_sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Kempe-chain shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start_candidates = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n        if not start_candidates:\n            continue\n        start = random.choice(start_candidates)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 5)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.25:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Cannot instantiate typing.Union.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001226693}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbor generator with multiple move types\n# Returns (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    # Base solution\n    sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Utility: compute conflict edges\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start_candidates = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n        if not start_candidates:\n            return (new_sol, \"NoOp\", \"Kempe-Empty\")\n        start = random.choice(start_candidates)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class merge attempt (restricted)\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c_from = random.choice(colors)\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from and best_conf == 0:\n                new_sol[u-1] = best\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        new_sol[0] = new_sol[0] + 1\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n# Strong perturbation for ILS\/SA restarts\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    new_sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Kempe-chain shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start_candidates = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n        if not start_candidates:\n            continue\n        start = random.choice(start_candidates)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 5)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.25:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Cannot instantiate typing.Union.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001569868}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"PY_LIST_INT_LEN_9","Evaluacion":"import math\nimport random\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[list, tuple]):\n    # Validate input type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K in order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based indexing)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\nfrom typing import List, Tuple\n\n# Neighbor generator with multiple move types\n# Returns (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    # Base solution\n    sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Utility: compute conflict edges\n    def conflict_edges(s):\n        return [(u, v) for (u, v) in edges if s[u-1] == s[v-1]]\n\n    move_choice = random.random()\n\n    # Move 1: Single-vertex recolor (conflict-driven)\n    if move_choice < 0.5:\n        confs = conflict_edges(sol)\n        if confs:\n            deg_conf = {i: 0 for i in range(1, n+1)}\n            for (u, v) in confs:\n                deg_conf[u] += 1\n                deg_conf[v] += 1\n            max_conf = max(deg_conf.values())\n            cand_vertices = [i for i, c in deg_conf.items() if c == max_conf]\n            u = random.choice(cand_vertices)\n        else:\n            u = random.randint(1, n)\n        colors = sorted(set(sol))\n        best_c = None\n        best_conf = math.inf\n        for c in colors + [max(colors)+1]:\n            if c == sol[u-1]:\n                continue\n            conf = sum(1 for w in adj[u] if sol[w-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n                if conf == 0:\n                    break\n        new_sol = list(sol)\n        if best_c is None:\n            best_c = max(colors) + 1\n        new_sol[u-1] = best_c\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n\n    # Move 2: Kempe-chain swap between two colors\n    if move_choice < 0.8:\n        new_sol = list(sol)\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            u = random.randint(1, n)\n            cands = [c for c in colors] + [max(colors)+1]\n            c = random.choice([x for x in cands if x != new_sol[u-1]])\n            new_sol[u-1] = c\n            return (new_sol, \"Recolor\", \"Single-Vertex\")\n        c1, c2 = random.sample(colors, 2)\n        start_candidates = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n        if not start_candidates:\n            return (new_sol, \"NoOp\", \"Kempe-Empty\")\n        start = random.choice(start_candidates)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n        return (new_sol, \"KempeSwap\", \"Component-Swap\")\n\n    # Move 3: Color-class merge attempt (restricted)\n    new_sol = list(sol)\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        c_from = random.choice(colors)\n        verts = [i for i in range(1, n+1) if new_sol[i-1] == c_from]\n        random.shuffle(verts)\n        for u in verts:\n            best = None\n            best_conf = math.inf\n            for c in colors:\n                if c == c_from:\n                    continue\n                conf = sum(1 for w in adj[u] if new_sol[w-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best = c\n                    if conf == 0:\n                        break\n            if best is not None and best != c_from and best_conf == 0:\n                new_sol[u-1] = best\n        return (new_sol, \"ClassOp\", \"Multi-Vertex\")\n    else:\n        new_sol[0] = new_sol[0] + 1\n        return (new_sol, \"Recolor\", \"Single-Vertex\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\n# Strong perturbation for ILS\/SA restarts\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_valid_input(sol):\n        if not isinstance(sol, (list, tuple)):\n            return False\n        if len(sol) != n:\n            return False\n        for v in sol:\n            if not isinstance(v, int) or v < 1:\n                return False\n        return True\n\n    def random_init_dsatur():\n        colors = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x]), x))\n            used = neighbor_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for w in adj[u]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    new_sol = list(solution) if is_valid_input(solution) else random_init_dsatur()\n\n    # Kempe-chain shakes\n    steps_kempe = random.randint(2, 4)\n    for _ in range(steps_kempe):\n        colors = sorted(set(new_sol))\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        start_candidates = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n        if not start_candidates:\n            continue\n        start = random.choice(start_candidates)\n        q = deque([start])\n        visited = set()\n        while q:\n            u = q.popleft()\n            if u in visited:\n                continue\n            if new_sol[u-1] not in (c1, c2):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if new_sol[w-1] in (c1, c2) and w not in visited:\n                    q.append(w)\n        for u in visited:\n            if new_sol[u-1] == c1:\n                new_sol[u-1] = c2\n            elif new_sol[u-1] == c2:\n                new_sol[u-1] = c1\n\n    # Random multi-vertex recolors\n    steps_recolor = random.randint(2, 5)\n    for _ in range(steps_recolor):\n        u = random.randint(1, n)\n        colors = sorted(set(new_sol))\n        candidates = [c for c in colors if c != new_sol[u-1]]\n        if random.random() < 0.25:\n            candidates.append(max(colors) + 1)\n        if candidates:\n            new_sol[u-1] = random.choice(candidates)\n\n    return new_sol\n","Resultados":"Failed to run target heuristic: Cannot instantiate typing.Union.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002029772}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST of length 9 with positive integers >=1; position i gives color of vertex i (i in {1..9}). Objective: minimize max(color) subject to c(u)!=c(v) for all edges.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric fitness (lower is better).\n    - Proper colorings: fitness = k = max(color)\n    - Conflicts or invalid input: large penalty + (#conflicts)*1000 + k\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph definition kept internal to avoid globals\n    raw_edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize undirected edges\n    seen = set()\n    for (u,v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return k\n    return 10**6 + conflicts * 1000 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _bounded_recolor(sol: List[int]) -> List[int]:\n    # Single-vertex recolor to a color in [1, max_color+1]\n    n = len(sol)\n    out = sol[:]\n    i = random.randrange(n)\n    max_c = max(out)\n    # ensure at least one alternative color different from current\n    candidates = list(range(1, max_c + 2))\n    candidates.remove(out[i])\n    out[i] = random.choice(candidates)\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighborhood: single-vertex recolor.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Recolor\"\n    Movement_Type: \"1-Flip\"\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Provide a minimal valid seed if input is malformed\n        rng = random.Random(0)\n        neighbor = [rng.randint(1, 4) for _ in range(9)]\n    else:\n        neighbor = _bounded_recolor(solution)\n    return neighbor, \"Recolor\", \"1-Flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _multi_recolor(sol: List[int], moves: int) -> List[int]:\n    out = sol[:]\n    n = len(out)\n    max_c = max(out)\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(min(moves, n)):\n        i = idxs[t]\n        # Allow expansion up to max_c+2 to escape local minima\n        candidates = list(range(1, max_c + 3))\n        if out[i] in candidates:\n            candidates.remove(out[i])\n        out[i] = random.choice(candidates)\n        max_c = max(max_c, out[i])\n    return out\n\ndef perturb_solution(solution):\n    \"\"\"\n    Perturbation: recolor ~30-50% of vertices randomly (at least 3),\n    allowing up to two new colors beyond current max to shake the state.\n    Returns a new solution list.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n    n = len(solution)\n    frac = 0.4\n    moves = max(3, int(round(frac * n)))\n    return _multi_recolor(solution, moves)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000510536}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST of length 9 with positive integers >=1; position i gives color of vertex i (i in {1..9}). Objective: minimize max(color) subject to c(u)!=c(v) for all edges.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric fitness (lower is better).\n    - Proper colorings: fitness = k = max(color)\n    - Conflicts or invalid input: large penalty + (#conflicts)*1000 + k\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph definition kept internal to avoid globals\n    raw_edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize undirected edges\n    seen = set()\n    for (u,v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return k\n    return 10**6 + conflicts * 1000 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _bounded_recolor(sol: List[int]) -> List[int]:\n    # Single-vertex recolor to a color in [1, max_color+1]\n    n = len(sol)\n    out = sol[:]\n    i = random.randrange(n)\n    max_c = max(out)\n    # ensure at least one alternative color different from current\n    candidates = list(range(1, max_c + 2))\n    candidates.remove(out[i])\n    out[i] = random.choice(candidates)\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighborhood: single-vertex recolor.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Recolor\"\n    Movement_Type: \"1-Flip\"\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Provide a minimal valid seed if input is malformed\n        rng = random.Random(0)\n        neighbor = [rng.randint(1, 4) for _ in range(9)]\n    else:\n        neighbor = _bounded_recolor(solution)\n    return neighbor, \"Recolor\", \"1-Flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _multi_recolor(sol: List[int], moves: int) -> List[int]:\n    out = sol[:]\n    n = len(out)\n    max_c = max(out)\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(min(moves, n)):\n        i = idxs[t]\n        # Allow expansion up to max_c+2 to escape local minima\n        candidates = list(range(1, max_c + 3))\n        if out[i] in candidates:\n            candidates.remove(out[i])\n        out[i] = random.choice(candidates)\n        max_c = max(max_c, out[i])\n    return out\n\ndef perturb_solution(solution):\n    \"\"\"\n    Perturbation: recolor ~30-50% of vertices randomly (at least 3),\n    allowing up to two new colors beyond current max to shake the state.\n    Returns a new solution list.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n    n = len(solution)\n    frac = 0.4\n    moves = max(3, int(round(frac * n)))\n    return _multi_recolor(solution, moves)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000611737}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST of length 9 with positive integers >=1; position i gives color of vertex i (i in {1..9}). Objective: minimize max(color) subject to c(u)!=c(v) for all edges.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns numeric fitness (lower is better).\n    - Proper colorings: fitness = k = max(color)\n    - Conflicts or invalid input: large penalty + (#conflicts)*1000 + k\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph definition kept internal to avoid globals\n    raw_edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize undirected edges\n    seen = set()\n    for (u,v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return k\n    return 10**6 + conflicts * 1000 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _bounded_recolor(sol: List[int]) -> List[int]:\n    # Single-vertex recolor to a color in [1, max_color+1]\n    n = len(sol)\n    out = sol[:]\n    i = random.randrange(n)\n    max_c = max(out)\n    # ensure at least one alternative color different from current\n    candidates = list(range(1, max_c + 2))\n    candidates.remove(out[i])\n    out[i] = random.choice(candidates)\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Neighborhood: single-vertex recolor.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Recolor\"\n    Movement_Type: \"1-Flip\"\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Provide a minimal valid seed if input is malformed\n        rng = random.Random(0)\n        neighbor = [rng.randint(1, 4) for _ in range(9)]\n    else:\n        neighbor = _bounded_recolor(solution)\n    return neighbor, \"Recolor\", \"1-Flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _multi_recolor(sol: List[int], moves: int) -> List[int]:\n    out = sol[:]\n    n = len(out)\n    max_c = max(out)\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(min(moves, n)):\n        i = idxs[t]\n        # Allow expansion up to max_c+2 to escape local minima\n        candidates = list(range(1, max_c + 3))\n        if out[i] in candidates:\n            candidates.remove(out[i])\n        out[i] = random.choice(candidates)\n        max_c = max(max_c, out[i])\n    return out\n\ndef perturb_solution(solution):\n    \"\"\"\n    Perturbation: recolor ~30-50% of vertices randomly (at least 3),\n    allowing up to two new colors beyond current max to shake the state.\n    Returns a new solution list.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) != 9:\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n    n = len(solution)\n    frac = 0.4\n    moves = max(3, int(round(frac * n)))\n    return _multi_recolor(solution, moves)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000560486}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST of length 9; solution[i-1] gives color (>=1) of vertex i in V={1..9}. Objective: minimize k=max(solution) subject to c(u)!=c(v) for all edges E. Feasible example: [2,4,1,3,3,1,2,2,4].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness (lower is better).\n    - Proper colorings: fitness = k = max(color)\n    - Conflicts or invalid input: large penalty + (#conflicts)*1000 + k\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph definition internal\n    raw_edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize undirected edges\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(10**6 + conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Conflict-driven single-vertex recolor neighbor.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Recolor\"\n    Movement_Type: \"Conflict-Driven-1-Flip\"\n    \"\"\"\n    # Ensure a valid base solution if malformed\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(0)\n        sol = [rng.randint(1, 4) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Graph internal\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicted vertices\n    conflicted = []\n    for (u, v) in set((min(u,v), max(u,v)) for (u,v) in edges):\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # Choose target vertex: prefer conflicted; else random\n    if conflicted:\n        i = random.choice(conflicted) - 1\n    else:\n        i = random.randrange(9)\n    k = max(sol)\n    # Candidate colors: prefer staying within [1..k]\n    neighbor_colors = {sol[j-1] for j in adj[i+1]}\n    candidates_in_k = [c for c in range(1, k+1) if c != sol[i] and c not in neighbor_colors]\n    if candidates_in_k:\n        new_color = random.choice(candidates_in_k)\n    else:\n        # If none feasible in [1..k], allow k+1 to escape\n        candidates = [c for c in range(1, k+2) if c != sol[i]]\n        new_color = random.choice(candidates)\n    out = sol[:]\n    out[i] = new_color\n    return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Medium-strength perturbation: recolor ~40% of vertices (at least 3),\n    allowing up to two new colors beyond current max to diversify.\n    Returns a new solution list.\n    \"\"\"\n    # Ensure a valid base solution if malformed\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n    sol = list(solution)\n    n = len(sol)\n    k = max(sol)\n    moves = max(3, int(round(0.4 * n)))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(moves):\n        i = idxs[t]\n        # Allow expansion up to k+2\n        candidates = list(range(1, k + 3))\n        if sol[i] in candidates:\n            candidates.remove(sol[i])\n        sol[i] = random.choice(candidates)\n        k = max(k, sol[i])\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000696298}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST of length 9; solution[i-1] gives color (>=1) of vertex i in V={1..9}. Objective: minimize k=max(solution) subject to c(u)!=c(v) for all edges E. Feasible example: [2,4,1,3,3,1,2,2,4].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness (lower is better).\n    - Proper colorings: fitness = k = max(color)\n    - Conflicts or invalid input: large penalty + (#conflicts)*1000 + k\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph definition internal\n    raw_edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize undirected edges\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(10**6 + conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Conflict-driven single-vertex recolor neighbor.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Recolor\"\n    Movement_Type: \"Conflict-Driven-1-Flip\"\n    \"\"\"\n    # Ensure a valid base solution if malformed\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(0)\n        sol = [rng.randint(1, 4) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Graph internal\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicted vertices\n    conflicted = []\n    for (u, v) in set((min(u,v), max(u,v)) for (u,v) in edges):\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # Choose target vertex: prefer conflicted; else random\n    if conflicted:\n        i = random.choice(conflicted) - 1\n    else:\n        i = random.randrange(9)\n    k = max(sol)\n    # Candidate colors: prefer staying within [1..k]\n    neighbor_colors = {sol[j-1] for j in adj[i+1]}\n    candidates_in_k = [c for c in range(1, k+1) if c != sol[i] and c not in neighbor_colors]\n    if candidates_in_k:\n        new_color = random.choice(candidates_in_k)\n    else:\n        # If none feasible in [1..k], allow k+1 to escape\n        candidates = [c for c in range(1, k+2) if c != sol[i]]\n        new_color = random.choice(candidates)\n    out = sol[:]\n    out[i] = new_color\n    return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Medium-strength perturbation: recolor ~40% of vertices (at least 3),\n    allowing up to two new colors beyond current max to diversify.\n    Returns a new solution list.\n    \"\"\"\n    # Ensure a valid base solution if malformed\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n    sol = list(solution)\n    n = len(sol)\n    k = max(sol)\n    moves = max(3, int(round(0.4 * n)))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(moves):\n        i = idxs[t]\n        # Allow expansion up to k+2\n        candidates = list(range(1, k + 3))\n        if sol[i] in candidates:\n            candidates.remove(sol[i])\n        sol[i] = random.choice(candidates)\n        k = max(k, sol[i])\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000795619}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST of length 9; solution[i-1] gives color (>=1) of vertex i in V={1..9}. Objective: minimize k=max(solution) subject to c(u)!=c(v) for all edges E. Feasible example: [2,4,1,3,3,1,2,2,4].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Returns numeric fitness (lower is better).\n    - Proper colorings: fitness = k = max(color)\n    - Conflicts or invalid input: large penalty + (#conflicts)*1000 + k\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Graph definition internal\n    raw_edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize undirected edges\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(10**6 + conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]):\n    \"\"\"\n    Conflict-driven single-vertex recolor neighbor.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type: \"Recolor\"\n    Movement_Type: \"Conflict-Driven-1-Flip\"\n    \"\"\"\n    # Ensure a valid base solution if malformed\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(0)\n        sol = [rng.randint(1, 4) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Graph internal\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Identify conflicted vertices\n    conflicted = []\n    for (u, v) in set((min(u,v), max(u,v)) for (u,v) in edges):\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # Choose target vertex: prefer conflicted; else random\n    if conflicted:\n        i = random.choice(conflicted) - 1\n    else:\n        i = random.randrange(9)\n    k = max(sol)\n    # Candidate colors: prefer staying within [1..k]\n    neighbor_colors = {sol[j-1] for j in adj[i+1]}\n    candidates_in_k = [c for c in range(1, k+1) if c != sol[i] and c not in neighbor_colors]\n    if candidates_in_k:\n        new_color = random.choice(candidates_in_k)\n    else:\n        # If none feasible in [1..k], allow k+1 to escape\n        candidates = [c for c in range(1, k+2) if c != sol[i]]\n        new_color = random.choice(candidates)\n    out = sol[:]\n    out[i] = new_color\n    return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Medium-strength perturbation: recolor ~40% of vertices (at least 3),\n    allowing up to two new colors beyond current max to diversify.\n    Returns a new solution list.\n    \"\"\"\n    # Ensure a valid base solution if malformed\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n    sol = list(solution)\n    n = len(sol)\n    k = max(sol)\n    moves = max(3, int(round(0.4 * n)))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for t in range(moves):\n        i = idxs[t]\n        # Allow expansion up to k+2\n        candidates = list(range(1, k + 3))\n        if sol[i] in candidates:\n            candidates.remove(sol[i])\n        sol[i] = random.choice(candidates)\n        k = max(k, sol[i])\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000773539}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_LEN_9_COLORS_POSINT; solution[i-1] is color of vertex i (1-based).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Fitness (lower is better):\n    - Proper colorings: k = max(color)\n    - Infeasible: 1e5 + 1e3*conflicts + k\n    Invalid input: 1e9\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 1e9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1e9\n    # Internal immutable graph data\n    raw_edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(1e5 + conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generates a neighbor solution and describes the move type.\n    - If infeasible: conflict-driven recolor within current color set to reduce conflicts.\n    - If feasible: perform a Kempe-chain color swap (or simple color swap) that keeps k nonincreasing.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    \"\"\"\n    # Defensive copy \/ basic validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # Fallback: deterministic init within 1..4\n        rng = random.Random(0)\n        base = [rng.randint(1, 4) for _ in range(9)]\n        return base, \"Recolor\", \"Init-Random\"\n    sol = list(solution)\n    n = 9\n    # Graph data internal\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = set((min(u,v), max(u,v)) for (u,v) in edges if u != v)\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in undirected:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Deterministic RNG based on state to ensure reproducibility\n    rng_seed = hash(tuple(sol)) & 0xffffffff\n    rng = random.Random(rng_seed)\n    # Helper: count conflicts\n    def get_conflicts(s):\n        c = 0\n        for (u, v) in undirected:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n    conflicts = []\n    for (u, v) in undirected:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n    k = max(sol)\n    if conflicts:\n        # Conflict-driven recolor of a conflicted vertex\n        pick = rng.choice(conflicts)\n        i = pick[0] if rng.random() < 0.5 else pick[1]\n        i0 = i - 1\n        neighbor_colors = {sol[j-1] for j in adj[i]}\n        # Prefer colors in 1..k that are not used by neighbors\n        feasible = [c for c in range(1, k+1) if c != sol[i0] and c not in neighbor_colors]\n        if not feasible:\n            # Choose color within 1..k minimizing resulting conflicts\n            best_c = sol[i0]\n            best_val = 10**9\n            for c in range(1, k+1):\n                if c == sol[i0]:\n                    continue\n                val = sum(1 for j in adj[i] if sol[j-1] == c)\n                if val < best_val:\n                    best_val = val\n                    best_c = c\n            new_color = best_c\n        else:\n            new_color = rng.choice(feasible)\n        out = sol[:]\n        out[i0] = new_color\n        return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n    else:\n        # Feasible: attempt Kempe-chain swap between two colors a,b without increasing k\n        # Select two distinct colors from 1..k\n        colors = list(sorted(set(sol)))\n        if len(colors) < 2:\n            # Nothing to swap; perform a harmless recolor within same k on a random vertex\n            idx = rng.randrange(n)\n            alt = [c for c in colors if c != sol[idx]]\n            if not alt:\n                alt = colors\n            out = sol[:]\n            out[idx] = rng.choice(alt)\n            return out, \"Recolor\", \"Feasible-Nop\"\n        a, b = rng.sample(colors, 2)\n        # Build subgraph induced by colors a and b\n        nodes_ab = {i for i in range(1, n+1) if sol[i-1] in (a, b)}\n        visited = set()\n        # Pick a random start vertex with color a or b\n        start_candidates = [i for i in nodes_ab]\n        if not start_candidates:\n            return sol[:], \"Swap\", \"Feasible-Nop\"\n        start = rng.choice(start_candidates)\n        # BFS to get Kempe component containing start in colors {a,b}\n        comp = []\n        stack = [start]\n        visited.add(start)\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v in nodes_ab and v not in visited and (sol[v-1] in (a, b)):\n                    visited.add(v)\n                    stack.append(v)\n        # Swap colors a<->b on this component\n        out = sol[:]\n        for v in comp:\n            out[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        # Ensure k does not increase\n        new_k = max(out)\n        if new_k > k:\n            # Reject, fallback to simple color-swap between two colors on a random vertex keeping within k\n            idx = rng.randrange(n)\n            cur = out[idx]\n            options = [c for c in colors if c != cur]\n            if options:\n                out[idx] = rng.choice(options)\n        return out, \"Kempe-Swap\", \"Feasible-AB-Component\"\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Medium-strength perturbation tailored for graph coloring.\n    - If feasible: perform several random color swaps among existing colors (keeps k), plus a few recolors within 1..k.\n    - If infeasible: recolor ~50% vertices within 1..max(k,4) to diversify while not introducing k+ growth beyond need.\n    Returns new solution list.\n    \"\"\"\n    # Internal evaluation (duplicate minimal logic to avoid external dependencies)\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = set((min(u,v), max(u,v)) for (u,v) in edges if u != v)\n\n    def is_feasible(sol):\n        for (u, v) in undirected:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n\n    # Validate base\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n\n    sol = list(solution)\n    n = 9\n    k = max(sol)\n    rng_seed = (hash(tuple(sol)) ^ 0x9e3779b9) & 0xffffffff\n    rng = random.Random(rng_seed)\n\n    if is_feasible(sol):\n        colors = list(sorted(set(sol)))\n        swaps = max(3, int(0.3 * n))\n        out = sol[:]\n        for _ in range(swaps):\n            if len(colors) < 2:\n                break\n            a, b = rng.sample(colors, 2)\n            # swap colors a and b on a random subset (~half of vertices in {a,b})\n            idxs = [i for i in range(n) if out[i] in (a, b)]\n            rng.shuffle(idxs)\n            take = idxs[: max(1, len(idxs)\/\/2) ]\n            for i in take:\n                out[i] = a if out[i] == b else (b if out[i] == a else out[i])\n        # small recolors within 1..k\n        m = max(2, int(0.2 * n))\n        for _ in range(m):\n            i = rng.randrange(n)\n            opts = [c for c in range(1, k+1) if c != out[i]]\n            if opts:\n                out[i] = rng.choice(opts)\n        return out\n    else:\n        # Infeasible: stronger shake\n        out = sol[:]\n        moves = max(4, int(0.5 * n))\n        palette_max = max(k, 4)\n        idxs = list(range(n))\n        rng.shuffle(idxs)\n        for t in range(moves):\n            i = idxs[t]\n            new_c = rng.randint(1, palette_max)\n            if new_c == out[i]:\n                new_c = (new_c % palette_max) + 1\n            out[i] = new_c\n        return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000967172}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_LEN_9_COLORS_POSINT; solution[i-1] is color of vertex i (1-based).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Fitness (lower is better):\n    - Proper colorings: k = max(color)\n    - Infeasible: 1e5 + 1e3*conflicts + k\n    Invalid input: 1e9\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 1e9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1e9\n    # Internal immutable graph data\n    raw_edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(1e5 + conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generates a neighbor solution and describes the move type.\n    - If infeasible: conflict-driven recolor within current color set to reduce conflicts.\n    - If feasible: perform a Kempe-chain color swap (or simple color swap) that keeps k nonincreasing.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    \"\"\"\n    # Defensive copy \/ basic validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # Fallback: deterministic init within 1..4\n        rng = random.Random(0)\n        base = [rng.randint(1, 4) for _ in range(9)]\n        return base, \"Recolor\", \"Init-Random\"\n    sol = list(solution)\n    n = 9\n    # Graph data internal\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = set((min(u,v), max(u,v)) for (u,v) in edges if u != v)\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in undirected:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Deterministic RNG based on state to ensure reproducibility\n    rng_seed = hash(tuple(sol)) & 0xffffffff\n    rng = random.Random(rng_seed)\n    # Helper: count conflicts\n    def get_conflicts(s):\n        c = 0\n        for (u, v) in undirected:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n    conflicts = []\n    for (u, v) in undirected:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n    k = max(sol)\n    if conflicts:\n        # Conflict-driven recolor of a conflicted vertex\n        pick = rng.choice(conflicts)\n        i = pick[0] if rng.random() < 0.5 else pick[1]\n        i0 = i - 1\n        neighbor_colors = {sol[j-1] for j in adj[i]}\n        # Prefer colors in 1..k that are not used by neighbors\n        feasible = [c for c in range(1, k+1) if c != sol[i0] and c not in neighbor_colors]\n        if not feasible:\n            # Choose color within 1..k minimizing resulting conflicts\n            best_c = sol[i0]\n            best_val = 10**9\n            for c in range(1, k+1):\n                if c == sol[i0]:\n                    continue\n                val = sum(1 for j in adj[i] if sol[j-1] == c)\n                if val < best_val:\n                    best_val = val\n                    best_c = c\n            new_color = best_c\n        else:\n            new_color = rng.choice(feasible)\n        out = sol[:]\n        out[i0] = new_color\n        return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n    else:\n        # Feasible: attempt Kempe-chain swap between two colors a,b without increasing k\n        # Select two distinct colors from 1..k\n        colors = list(sorted(set(sol)))\n        if len(colors) < 2:\n            # Nothing to swap; perform a harmless recolor within same k on a random vertex\n            idx = rng.randrange(n)\n            alt = [c for c in colors if c != sol[idx]]\n            if not alt:\n                alt = colors\n            out = sol[:]\n            out[idx] = rng.choice(alt)\n            return out, \"Recolor\", \"Feasible-Nop\"\n        a, b = rng.sample(colors, 2)\n        # Build subgraph induced by colors a and b\n        nodes_ab = {i for i in range(1, n+1) if sol[i-1] in (a, b)}\n        visited = set()\n        # Pick a random start vertex with color a or b\n        start_candidates = [i for i in nodes_ab]\n        if not start_candidates:\n            return sol[:], \"Swap\", \"Feasible-Nop\"\n        start = rng.choice(start_candidates)\n        # BFS to get Kempe component containing start in colors {a,b}\n        comp = []\n        stack = [start]\n        visited.add(start)\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v in nodes_ab and v not in visited and (sol[v-1] in (a, b)):\n                    visited.add(v)\n                    stack.append(v)\n        # Swap colors a<->b on this component\n        out = sol[:]\n        for v in comp:\n            out[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        # Ensure k does not increase\n        new_k = max(out)\n        if new_k > k:\n            # Reject, fallback to simple color-swap between two colors on a random vertex keeping within k\n            idx = rng.randrange(n)\n            cur = out[idx]\n            options = [c for c in colors if c != cur]\n            if options:\n                out[idx] = rng.choice(options)\n        return out, \"Kempe-Swap\", \"Feasible-AB-Component\"\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Medium-strength perturbation tailored for graph coloring.\n    - If feasible: perform several random color swaps among existing colors (keeps k), plus a few recolors within 1..k.\n    - If infeasible: recolor ~50% vertices within 1..max(k,4) to diversify while not introducing k+ growth beyond need.\n    Returns new solution list.\n    \"\"\"\n    # Internal evaluation (duplicate minimal logic to avoid external dependencies)\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = set((min(u,v), max(u,v)) for (u,v) in edges if u != v)\n\n    def is_feasible(sol):\n        for (u, v) in undirected:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n\n    # Validate base\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n\n    sol = list(solution)\n    n = 9\n    k = max(sol)\n    rng_seed = (hash(tuple(sol)) ^ 0x9e3779b9) & 0xffffffff\n    rng = random.Random(rng_seed)\n\n    if is_feasible(sol):\n        colors = list(sorted(set(sol)))\n        swaps = max(3, int(0.3 * n))\n        out = sol[:]\n        for _ in range(swaps):\n            if len(colors) < 2:\n                break\n            a, b = rng.sample(colors, 2)\n            # swap colors a and b on a random subset (~half of vertices in {a,b})\n            idxs = [i for i in range(n) if out[i] in (a, b)]\n            rng.shuffle(idxs)\n            take = idxs[: max(1, len(idxs)\/\/2) ]\n            for i in take:\n                out[i] = a if out[i] == b else (b if out[i] == a else out[i])\n        # small recolors within 1..k\n        m = max(2, int(0.2 * n))\n        for _ in range(m):\n            i = rng.randrange(n)\n            opts = [c for c in range(1, k+1) if c != out[i]]\n            if opts:\n                out[i] = rng.choice(opts)\n        return out\n    else:\n        # Infeasible: stronger shake\n        out = sol[:]\n        moves = max(4, int(0.5 * n))\n        palette_max = max(k, 4)\n        idxs = list(range(n))\n        rng.shuffle(idxs)\n        for t in range(moves):\n            i = idxs[t]\n            new_c = rng.randint(1, palette_max)\n            if new_c == out[i]:\n                new_c = (new_c % palette_max) + 1\n            out[i] = new_c\n        return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001234564}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_LEN_9_COLORS_POSINT; solution[i-1] is color of vertex i (1-based).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Fitness (lower is better):\n    - Proper colorings: k = max(color)\n    - Infeasible: 1e5 + 1e3*conflicts + k\n    Invalid input: 1e9\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 1e9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1e9\n    # Internal immutable graph data\n    raw_edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(1e5 + conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generates a neighbor solution and describes the move type.\n    - If infeasible: conflict-driven recolor within current color set to reduce conflicts.\n    - If feasible: perform a Kempe-chain color swap (or simple color swap) that keeps k nonincreasing.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    \"\"\"\n    # Defensive copy \/ basic validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # Fallback: deterministic init within 1..4\n        rng = random.Random(0)\n        base = [rng.randint(1, 4) for _ in range(9)]\n        return base, \"Recolor\", \"Init-Random\"\n    sol = list(solution)\n    n = 9\n    # Graph data internal\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = set((min(u,v), max(u,v)) for (u,v) in edges if u != v)\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in undirected:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Deterministic RNG based on state to ensure reproducibility\n    rng_seed = hash(tuple(sol)) & 0xffffffff\n    rng = random.Random(rng_seed)\n    # Helper: count conflicts\n    def get_conflicts(s):\n        c = 0\n        for (u, v) in undirected:\n            if s[u-1] == s[v-1]:\n                c += 1\n        return c\n    conflicts = []\n    for (u, v) in undirected:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n    k = max(sol)\n    if conflicts:\n        # Conflict-driven recolor of a conflicted vertex\n        pick = rng.choice(conflicts)\n        i = pick[0] if rng.random() < 0.5 else pick[1]\n        i0 = i - 1\n        neighbor_colors = {sol[j-1] for j in adj[i]}\n        # Prefer colors in 1..k that are not used by neighbors\n        feasible = [c for c in range(1, k+1) if c != sol[i0] and c not in neighbor_colors]\n        if not feasible:\n            # Choose color within 1..k minimizing resulting conflicts\n            best_c = sol[i0]\n            best_val = 10**9\n            for c in range(1, k+1):\n                if c == sol[i0]:\n                    continue\n                val = sum(1 for j in adj[i] if sol[j-1] == c)\n                if val < best_val:\n                    best_val = val\n                    best_c = c\n            new_color = best_c\n        else:\n            new_color = rng.choice(feasible)\n        out = sol[:]\n        out[i0] = new_color\n        return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n    else:\n        # Feasible: attempt Kempe-chain swap between two colors a,b without increasing k\n        # Select two distinct colors from 1..k\n        colors = list(sorted(set(sol)))\n        if len(colors) < 2:\n            # Nothing to swap; perform a harmless recolor within same k on a random vertex\n            idx = rng.randrange(n)\n            alt = [c for c in colors if c != sol[idx]]\n            if not alt:\n                alt = colors\n            out = sol[:]\n            out[idx] = rng.choice(alt)\n            return out, \"Recolor\", \"Feasible-Nop\"\n        a, b = rng.sample(colors, 2)\n        # Build subgraph induced by colors a and b\n        nodes_ab = {i for i in range(1, n+1) if sol[i-1] in (a, b)}\n        visited = set()\n        # Pick a random start vertex with color a or b\n        start_candidates = [i for i in nodes_ab]\n        if not start_candidates:\n            return sol[:], \"Swap\", \"Feasible-Nop\"\n        start = rng.choice(start_candidates)\n        # BFS to get Kempe component containing start in colors {a,b}\n        comp = []\n        stack = [start]\n        visited.add(start)\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v in nodes_ab and v not in visited and (sol[v-1] in (a, b)):\n                    visited.add(v)\n                    stack.append(v)\n        # Swap colors a<->b on this component\n        out = sol[:]\n        for v in comp:\n            out[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        # Ensure k does not increase\n        new_k = max(out)\n        if new_k > k:\n            # Reject, fallback to simple color-swap between two colors on a random vertex keeping within k\n            idx = rng.randrange(n)\n            cur = out[idx]\n            options = [c for c in colors if c != cur]\n            if options:\n                out[idx] = rng.choice(options)\n        return out, \"Kempe-Swap\", \"Feasible-AB-Component\"\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Medium-strength perturbation tailored for graph coloring.\n    - If feasible: perform several random color swaps among existing colors (keeps k), plus a few recolors within 1..k.\n    - If infeasible: recolor ~50% vertices within 1..max(k,4) to diversify while not introducing k+ growth beyond need.\n    Returns new solution list.\n    \"\"\"\n    # Internal evaluation (duplicate minimal logic to avoid external dependencies)\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = set((min(u,v), max(u,v)) for (u,v) in edges if u != v)\n\n    def is_feasible(sol):\n        for (u, v) in undirected:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n\n    # Validate base\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        rng = random.Random(1)\n        return [rng.randint(1, 5) for _ in range(9)]\n\n    sol = list(solution)\n    n = 9\n    k = max(sol)\n    rng_seed = (hash(tuple(sol)) ^ 0x9e3779b9) & 0xffffffff\n    rng = random.Random(rng_seed)\n\n    if is_feasible(sol):\n        colors = list(sorted(set(sol)))\n        swaps = max(3, int(0.3 * n))\n        out = sol[:]\n        for _ in range(swaps):\n            if len(colors) < 2:\n                break\n            a, b = rng.sample(colors, 2)\n            # swap colors a and b on a random subset (~half of vertices in {a,b})\n            idxs = [i for i in range(n) if out[i] in (a, b)]\n            rng.shuffle(idxs)\n            take = idxs[: max(1, len(idxs)\/\/2) ]\n            for i in take:\n                out[i] = a if out[i] == b else (b if out[i] == a else out[i])\n        # small recolors within 1..k\n        m = max(2, int(0.2 * n))\n        for _ in range(m):\n            i = rng.randrange(n)\n            opts = [c for c in range(1, k+1) if c != out[i]]\n            if opts:\n                out[i] = rng.choice(opts)\n        return out\n    else:\n        # Infeasible: stronger shake\n        out = sol[:]\n        moves = max(4, int(0.5 * n))\n        palette_max = max(k, 4)\n        idxs = list(range(n))\n        rng.shuffle(idxs)\n        for t in range(moves):\n            i = idxs[t]\n            new_c = rng.randint(1, palette_max)\n            if new_c == out[i]:\n                new_c = (new_c % palette_max) + 1\n            out[i] = new_c\n        return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001204384}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_LEN_9_COLORS_POSINT","Evaluacion":"from typing import List\nimport math\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Fitness (lower is better):\n    - Proper colorings: k = max(color)\n    - Infeasible: 1e5 + 1e3*conflicts + k\n    Invalid input: 1e9\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 1e9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1e9\n    # Internal immutable graph data\n    raw_edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(1e5 + conflicts * 1000 + k)\n","Vecindad":"from typing import List, Tuple\nimport hashlib\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Deterministic RNG via sha256 of the solution to ensure reproducibility across runs.\n    - If infeasible: conflict-driven single-vertex recolor within existing palette (keeps k nonincreasing).\n    - If feasible: attempt a Kempe-chain swap; if it introduces conflicts, fall back to safe single-vertex recolor that preserves feasibility; otherwise no-op.\n    \"\"\"\n    # Validate \/ fallback initializer (deterministic greedy coloring)\n    def greedy_init() -> List[int]:\n        edges = (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n        undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n        adj = {i:set() for i in range(1,10)}\n        for (u,v) in undirected:\n            adj[u].add(v); adj[v].add(u)\n        sol = [0]*9\n        for i in range(1,10):\n            used = { sol[j-1] for j in adj[i] if sol[j-1]>0 }\n            c = 1\n            while c in used:\n                c+=1\n            sol[i-1]=c\n        return sol\n    if (not isinstance(solution, list)) or len(solution)!=9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return greedy_init(), \"Recolor\", \"Init-Greedy\"\n\n    sol = list(solution)\n    n = 9\n    # Graph data\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in undirected:\n        adj[u].add(v); adj[v].add(u)\n\n    def count_conflicts(s: List[int]) -> int:\n        c=0\n        for (u,v) in undirected:\n            if s[u-1]==s[v-1]:\n                c+=1\n        return c\n\n    def deterministic_rng_bytes(seed_list: List[int]) -> int:\n        h = hashlib.sha256(bytes(seed_list)).digest()\n        return int.from_bytes(h[:8], 'little')\n\n    k = max(sol)\n    base_seed = deterministic_rng_bytes([min(255, x) for x in sol])\n    # Simple deterministic selection helpers\n    def pick_from(seq, offset):\n        if not seq:\n            return None\n        return seq[offset % len(seq)]\n\n    conflicts = []\n    for (u,v) in sorted(undirected):\n        if sol[u-1]==sol[v-1]:\n            conflicts.append((u,v))\n\n    if conflicts:\n        # pick conflicted vertex with highest degree, tiebreak deterministically\n        idx = base_seed % len(conflicts)\n        a,b = conflicts[idx]\n        cand = [a,b]\n        cand.sort(key=lambda x:(-len(adj[x]), x))\n        i = cand[0]\n        i0 = i-1\n        palette = list(range(1, k+1))\n        # choose color minimizing resulting local conflicts; avoid current color\n        best_c = sol[i0]\n        best_val = 10**9\n        for c in palette:\n            if c == sol[i0]:\n                continue\n            val = sum(1 for j in adj[i] if sol[j-1]==c)\n            if val < best_val:\n                best_val = val\n                best_c = c\n        out = sol[:]\n        out[i0] = best_c\n        return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n    else:\n        # Feasible state: try Kempe swap between two existing colors\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:], \"Recolor\", \"Feasible-Nop\"\n        a = colors[base_seed % len(colors)]\n        b = colors[(base_seed \/\/ 7) % len(colors)]\n        if a == b:\n            b = colors[(colors.index(a)+1) % len(colors)]\n        nodes_ab = {i for i in range(1, n+1) if sol[i-1] in (a,b)}\n        if not nodes_ab:\n            return sol[:], \"Recolor\", \"Feasible-Nop\"\n        start_idx = (base_seed \/\/ 13) % len(nodes_ab)\n        start = sorted(nodes_ab)[start_idx]\n        # BFS component\n        stack = [start]\n        visited = {start}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v in nodes_ab and v not in visited and (sol[v-1] in (a,b)):\n                    visited.add(v)\n                    stack.append(v)\n        out = sol[:]\n        for v in comp:\n            cv = out[v-1]\n            out[v-1] = a if cv==b else (b if cv==a else cv)\n        # Ensure feasibility preserved (non-worsening conflicts; currently zero, so must stay zero)\n        if count_conflicts(out) == 0:\n            return out, \"Kempe-Swap\", \"Feasible-AB-Component\"\n        # Fallback: safe single-vertex recolor preserving feasibility if possible\n        i = ((base_seed \/\/ 17) % n) + 1\n        i0 = i-1\n        safe_colors = [c for c in colors if c != sol[i0] and all((c != sol[j-1]) for j in adj[i])]\n        if safe_colors:\n            out2 = sol[:]\n            out2[i0] = pick_from(safe_colors, base_seed)\n            return out2, \"Recolor\", \"Feasible-Safe-1-Flip\"\n        return sol[:], \"Recolor\", \"Feasible-Nop\"\n","Perturbacion":"from typing import List\nimport hashlib\n\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Deterministic medium-strength perturbation using sha256-based seeding.\n    - If feasible: perform several recolors within existing palette (may introduce conflicts) to escape local basin.\n    - If infeasible: recolor ~50% vertices within palette up to max(k,4) to diversify.\n    Returns new solution list of length 9 with positive integers.\n    \"\"\"\n    # Graph data for feasibility check\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n\n    def is_feasible(sol: List[int]) -> bool:\n        for (u,v) in undirected:\n            if sol[u-1]==sol[v-1]:\n                return False\n        return True\n\n    # Validate\n    if (not isinstance(solution, list)) or len(solution)!=9 or any((not isinstance(x,int) or x<1) for x in solution):\n        # Deterministic simple pattern\n        base = [1,2,3,4,2,3,1,2,4]\n        return base\n\n    sol = list(solution)\n    n = 9\n    k = max(sol)\n    seed_bytes = bytes([min(255, x) for x in sol])\n    h = hashlib.sha256(seed_bytes).digest()\n    seed = int.from_bytes(h[:8], 'little')\n\n    def next_rand(s: int) -> int:\n        # xorshift64*\n        x = (s + 0x9E3779B97F4A7C15) & ((1<<64)-1)\n        x ^= (x >> 30) & ((1<<64)-1)\n        x *= 0xBF58476D1CE4E5B9\n        x &= ((1<<64)-1)\n        x ^= (x >> 27) & ((1<<64)-1)\n        x *= 0x94D049BB133111EB\n        x &= ((1<<64)-1)\n        x ^= (x >> 31) & ((1<<64)-1)\n        return x\n\n    rng = seed or 1\n\n    if is_feasible(sol):\n        out = sol[:]\n        palette = sorted(set(out))\n        moves = max(3, n\/\/3)\n        for _ in range(moves):\n            rng = next_rand(rng)\n            i = (rng % n)\n            rng = next_rand(rng)\n            if palette:\n                c = palette[rng % len(palette)]\n                if c == out[i]:\n                    c = palette[(palette.index(c)+1) % len(palette)]\n                out[i] = c\n        return out\n    else:\n        out = sol[:]\n        moves = max(4, n\/\/2)\n        palette_max = max(k, 4)\n        for t in range(moves):\n            rng = next_rand(rng)\n            i = (rng + t) % n\n            rng = next_rand(rng)\n            c = (rng % palette_max) + 1\n            if c == out[i]:\n                c = ((c) % palette_max) + 1\n            out[i] = c\n        return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001375146}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_LEN_9_COLORS_POSINT","Evaluacion":"from typing import List\nimport math\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Fitness (lower is better):\n    - Proper colorings: k = max(color)\n    - Infeasible: 1e5 + 1e3*conflicts + k\n    Invalid input: 1e9\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 1e9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1e9\n    # Internal immutable graph data\n    raw_edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(1e5 + conflicts * 1000 + k)\n","Vecindad":"from typing import List, Tuple\nimport hashlib\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Deterministic RNG via sha256 of the solution to ensure reproducibility across runs.\n    - If infeasible: conflict-driven single-vertex recolor within existing palette (keeps k nonincreasing).\n    - If feasible: attempt a Kempe-chain swap; if it introduces conflicts, fall back to safe single-vertex recolor that preserves feasibility; otherwise no-op.\n    \"\"\"\n    # Validate \/ fallback initializer (deterministic greedy coloring)\n    def greedy_init() -> List[int]:\n        edges = (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n        undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n        adj = {i:set() for i in range(1,10)}\n        for (u,v) in undirected:\n            adj[u].add(v); adj[v].add(u)\n        sol = [0]*9\n        for i in range(1,10):\n            used = { sol[j-1] for j in adj[i] if sol[j-1]>0 }\n            c = 1\n            while c in used:\n                c+=1\n            sol[i-1]=c\n        return sol\n    if (not isinstance(solution, list)) or len(solution)!=9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return greedy_init(), \"Recolor\", \"Init-Greedy\"\n\n    sol = list(solution)\n    n = 9\n    # Graph data\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in undirected:\n        adj[u].add(v); adj[v].add(u)\n\n    def count_conflicts(s: List[int]) -> int:\n        c=0\n        for (u,v) in undirected:\n            if s[u-1]==s[v-1]:\n                c+=1\n        return c\n\n    def deterministic_rng_bytes(seed_list: List[int]) -> int:\n        h = hashlib.sha256(bytes(seed_list)).digest()\n        return int.from_bytes(h[:8], 'little')\n\n    k = max(sol)\n    base_seed = deterministic_rng_bytes([min(255, x) for x in sol])\n    # Simple deterministic selection helpers\n    def pick_from(seq, offset):\n        if not seq:\n            return None\n        return seq[offset % len(seq)]\n\n    conflicts = []\n    for (u,v) in sorted(undirected):\n        if sol[u-1]==sol[v-1]:\n            conflicts.append((u,v))\n\n    if conflicts:\n        # pick conflicted vertex with highest degree, tiebreak deterministically\n        idx = base_seed % len(conflicts)\n        a,b = conflicts[idx]\n        cand = [a,b]\n        cand.sort(key=lambda x:(-len(adj[x]), x))\n        i = cand[0]\n        i0 = i-1\n        palette = list(range(1, k+1))\n        # choose color minimizing resulting local conflicts; avoid current color\n        best_c = sol[i0]\n        best_val = 10**9\n        for c in palette:\n            if c == sol[i0]:\n                continue\n            val = sum(1 for j in adj[i] if sol[j-1]==c)\n            if val < best_val:\n                best_val = val\n                best_c = c\n        out = sol[:]\n        out[i0] = best_c\n        return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n    else:\n        # Feasible state: try Kempe swap between two existing colors\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:], \"Recolor\", \"Feasible-Nop\"\n        a = colors[base_seed % len(colors)]\n        b = colors[(base_seed \/\/ 7) % len(colors)]\n        if a == b:\n            b = colors[(colors.index(a)+1) % len(colors)]\n        nodes_ab = {i for i in range(1, n+1) if sol[i-1] in (a,b)}\n        if not nodes_ab:\n            return sol[:], \"Recolor\", \"Feasible-Nop\"\n        start_idx = (base_seed \/\/ 13) % len(nodes_ab)\n        start = sorted(nodes_ab)[start_idx]\n        # BFS component\n        stack = [start]\n        visited = {start}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v in nodes_ab and v not in visited and (sol[v-1] in (a,b)):\n                    visited.add(v)\n                    stack.append(v)\n        out = sol[:]\n        for v in comp:\n            cv = out[v-1]\n            out[v-1] = a if cv==b else (b if cv==a else cv)\n        # Ensure feasibility preserved (non-worsening conflicts; currently zero, so must stay zero)\n        if count_conflicts(out) == 0:\n            return out, \"Kempe-Swap\", \"Feasible-AB-Component\"\n        # Fallback: safe single-vertex recolor preserving feasibility if possible\n        i = ((base_seed \/\/ 17) % n) + 1\n        i0 = i-1\n        safe_colors = [c for c in colors if c != sol[i0] and all((c != sol[j-1]) for j in adj[i])]\n        if safe_colors:\n            out2 = sol[:]\n            out2[i0] = pick_from(safe_colors, base_seed)\n            return out2, \"Recolor\", \"Feasible-Safe-1-Flip\"\n        return sol[:], \"Recolor\", \"Feasible-Nop\"\n","Perturbacion":"from typing import List\nimport hashlib\n\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Deterministic medium-strength perturbation using sha256-based seeding.\n    - If feasible: perform several recolors within existing palette (may introduce conflicts) to escape local basin.\n    - If infeasible: recolor ~50% vertices within palette up to max(k,4) to diversify.\n    Returns new solution list of length 9 with positive integers.\n    \"\"\"\n    # Graph data for feasibility check\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n\n    def is_feasible(sol: List[int]) -> bool:\n        for (u,v) in undirected:\n            if sol[u-1]==sol[v-1]:\n                return False\n        return True\n\n    # Validate\n    if (not isinstance(solution, list)) or len(solution)!=9 or any((not isinstance(x,int) or x<1) for x in solution):\n        # Deterministic simple pattern\n        base = [1,2,3,4,2,3,1,2,4]\n        return base\n\n    sol = list(solution)\n    n = 9\n    k = max(sol)\n    seed_bytes = bytes([min(255, x) for x in sol])\n    h = hashlib.sha256(seed_bytes).digest()\n    seed = int.from_bytes(h[:8], 'little')\n\n    def next_rand(s: int) -> int:\n        # xorshift64*\n        x = (s + 0x9E3779B97F4A7C15) & ((1<<64)-1)\n        x ^= (x >> 30) & ((1<<64)-1)\n        x *= 0xBF58476D1CE4E5B9\n        x &= ((1<<64)-1)\n        x ^= (x >> 27) & ((1<<64)-1)\n        x *= 0x94D049BB133111EB\n        x &= ((1<<64)-1)\n        x ^= (x >> 31) & ((1<<64)-1)\n        return x\n\n    rng = seed or 1\n\n    if is_feasible(sol):\n        out = sol[:]\n        palette = sorted(set(out))\n        moves = max(3, n\/\/3)\n        for _ in range(moves):\n            rng = next_rand(rng)\n            i = (rng % n)\n            rng = next_rand(rng)\n            if palette:\n                c = palette[rng % len(palette)]\n                if c == out[i]:\n                    c = palette[(palette.index(c)+1) % len(palette)]\n                out[i] = c\n        return out\n    else:\n        out = sol[:]\n        moves = max(4, n\/\/2)\n        palette_max = max(k, 4)\n        for t in range(moves):\n            rng = next_rand(rng)\n            i = (rng + t) % n\n            rng = next_rand(rng)\n            c = (rng % palette_max) + 1\n            if c == out[i]:\n                c = ((c) % palette_max) + 1\n            out[i] = c\n        return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00171964}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_LEN_9_COLORS_POSINT","Evaluacion":"from typing import List\nimport math\n\ndef evaluate_solution(solution: List[int]) -> float:\n    \"\"\"\n    Fitness (lower is better):\n    - Proper colorings: k = max(color)\n    - Infeasible: 1e5 + 1e3*conflicts + k\n    Invalid input: 1e9\n    Graph: V={1..9}\n    E={(1,3),(1,4),(1,5),(1,9),(2,3),(2,5),(2,6),(2,7),(2,8),(3,4),(3,5),(3,7),(3,8),(3,9),(4,6),(4,7),(5,8),(5,9),(8,9)}\n    \"\"\"\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 1e9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1e9\n    # Internal immutable graph data\n    raw_edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    seen = set()\n    for (u, v) in raw_edges:\n        if u == v:\n            continue\n        a, b = (u, v) if u < v else (v, u)\n        seen.add((a, b))\n    edges = tuple(seen)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    k = max(solution)\n    if conflicts == 0:\n        return float(k)\n    return float(1e5 + conflicts * 1000 + k)\n","Vecindad":"from typing import List, Tuple\nimport hashlib\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Deterministic RNG via sha256 of the solution to ensure reproducibility across runs.\n    - If infeasible: conflict-driven single-vertex recolor within existing palette (keeps k nonincreasing).\n    - If feasible: attempt a Kempe-chain swap; if it introduces conflicts, fall back to safe single-vertex recolor that preserves feasibility; otherwise no-op.\n    \"\"\"\n    # Validate \/ fallback initializer (deterministic greedy coloring)\n    def greedy_init() -> List[int]:\n        edges = (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n        undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n        adj = {i:set() for i in range(1,10)}\n        for (u,v) in undirected:\n            adj[u].add(v); adj[v].add(u)\n        sol = [0]*9\n        for i in range(1,10):\n            used = { sol[j-1] for j in adj[i] if sol[j-1]>0 }\n            c = 1\n            while c in used:\n                c+=1\n            sol[i-1]=c\n        return sol\n    if (not isinstance(solution, list)) or len(solution)!=9 or any((not isinstance(x,int) or x<1) for x in solution):\n        return greedy_init(), \"Recolor\", \"Init-Greedy\"\n\n    sol = list(solution)\n    n = 9\n    # Graph data\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in undirected:\n        adj[u].add(v); adj[v].add(u)\n\n    def count_conflicts(s: List[int]) -> int:\n        c=0\n        for (u,v) in undirected:\n            if s[u-1]==s[v-1]:\n                c+=1\n        return c\n\n    def deterministic_rng_bytes(seed_list: List[int]) -> int:\n        h = hashlib.sha256(bytes(seed_list)).digest()\n        return int.from_bytes(h[:8], 'little')\n\n    k = max(sol)\n    base_seed = deterministic_rng_bytes([min(255, x) for x in sol])\n    # Simple deterministic selection helpers\n    def pick_from(seq, offset):\n        if not seq:\n            return None\n        return seq[offset % len(seq)]\n\n    conflicts = []\n    for (u,v) in sorted(undirected):\n        if sol[u-1]==sol[v-1]:\n            conflicts.append((u,v))\n\n    if conflicts:\n        # pick conflicted vertex with highest degree, tiebreak deterministically\n        idx = base_seed % len(conflicts)\n        a,b = conflicts[idx]\n        cand = [a,b]\n        cand.sort(key=lambda x:(-len(adj[x]), x))\n        i = cand[0]\n        i0 = i-1\n        palette = list(range(1, k+1))\n        # choose color minimizing resulting local conflicts; avoid current color\n        best_c = sol[i0]\n        best_val = 10**9\n        for c in palette:\n            if c == sol[i0]:\n                continue\n            val = sum(1 for j in adj[i] if sol[j-1]==c)\n            if val < best_val:\n                best_val = val\n                best_c = c\n        out = sol[:]\n        out[i0] = best_c\n        return out, \"Recolor\", \"Conflict-Driven-1-Flip\"\n    else:\n        # Feasible state: try Kempe swap between two existing colors\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:], \"Recolor\", \"Feasible-Nop\"\n        a = colors[base_seed % len(colors)]\n        b = colors[(base_seed \/\/ 7) % len(colors)]\n        if a == b:\n            b = colors[(colors.index(a)+1) % len(colors)]\n        nodes_ab = {i for i in range(1, n+1) if sol[i-1] in (a,b)}\n        if not nodes_ab:\n            return sol[:], \"Recolor\", \"Feasible-Nop\"\n        start_idx = (base_seed \/\/ 13) % len(nodes_ab)\n        start = sorted(nodes_ab)[start_idx]\n        # BFS component\n        stack = [start]\n        visited = {start}\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if v in nodes_ab and v not in visited and (sol[v-1] in (a,b)):\n                    visited.add(v)\n                    stack.append(v)\n        out = sol[:]\n        for v in comp:\n            cv = out[v-1]\n            out[v-1] = a if cv==b else (b if cv==a else cv)\n        # Ensure feasibility preserved (non-worsening conflicts; currently zero, so must stay zero)\n        if count_conflicts(out) == 0:\n            return out, \"Kempe-Swap\", \"Feasible-AB-Component\"\n        # Fallback: safe single-vertex recolor preserving feasibility if possible\n        i = ((base_seed \/\/ 17) % n) + 1\n        i0 = i-1\n        safe_colors = [c for c in colors if c != sol[i0] and all((c != sol[j-1]) for j in adj[i])]\n        if safe_colors:\n            out2 = sol[:]\n            out2[i0] = pick_from(safe_colors, base_seed)\n            return out2, \"Recolor\", \"Feasible-Safe-1-Flip\"\n        return sol[:], \"Recolor\", \"Feasible-Nop\"\n","Perturbacion":"from typing import List\nimport hashlib\n\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Deterministic medium-strength perturbation using sha256-based seeding.\n    - If feasible: perform several recolors within existing palette (may introduce conflicts) to escape local basin.\n    - If infeasible: recolor ~50% vertices within palette up to max(k,4) to diversify.\n    Returns new solution list of length 9 with positive integers.\n    \"\"\"\n    # Graph data for feasibility check\n    edges = (\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    )\n    undirected = { (min(u,v), max(u,v)) for (u,v) in edges if u!=v }\n\n    def is_feasible(sol: List[int]) -> bool:\n        for (u,v) in undirected:\n            if sol[u-1]==sol[v-1]:\n                return False\n        return True\n\n    # Validate\n    if (not isinstance(solution, list)) or len(solution)!=9 or any((not isinstance(x,int) or x<1) for x in solution):\n        # Deterministic simple pattern\n        base = [1,2,3,4,2,3,1,2,4]\n        return base\n\n    sol = list(solution)\n    n = 9\n    k = max(sol)\n    seed_bytes = bytes([min(255, x) for x in sol])\n    h = hashlib.sha256(seed_bytes).digest()\n    seed = int.from_bytes(h[:8], 'little')\n\n    def next_rand(s: int) -> int:\n        # xorshift64*\n        x = (s + 0x9E3779B97F4A7C15) & ((1<<64)-1)\n        x ^= (x >> 30) & ((1<<64)-1)\n        x *= 0xBF58476D1CE4E5B9\n        x &= ((1<<64)-1)\n        x ^= (x >> 27) & ((1<<64)-1)\n        x *= 0x94D049BB133111EB\n        x &= ((1<<64)-1)\n        x ^= (x >> 31) & ((1<<64)-1)\n        return x\n\n    rng = seed or 1\n\n    if is_feasible(sol):\n        out = sol[:]\n        palette = sorted(set(out))\n        moves = max(3, n\/\/3)\n        for _ in range(moves):\n            rng = next_rand(rng)\n            i = (rng % n)\n            rng = next_rand(rng)\n            if palette:\n                c = palette[rng % len(palette)]\n                if c == out[i]:\n                    c = palette[(palette.index(c)+1) % len(palette)]\n                out[i] = c\n        return out\n    else:\n        out = sol[:]\n        moves = max(4, n\/\/2)\n        palette_max = max(k, 4)\n        for t in range(moves):\n            rng = next_rand(rng)\n            i = (rng + t) % n\n            rng = next_rand(rng)\n            c = (rng % palette_max) + 1\n            if c == out[i]:\n                c = ((c) % palette_max) + 1\n            out[i] = c\n        return out\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001350076}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; colors are contiguous integers 1..k with no gaps.","Evaluacion":"import math\nimport itertools\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns large penalties for invalid solutions.\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    PENALTY_INVALID = 10**6\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 10**5\n    if len(solution) != n:\n        return PENALTY_INVALID + 10**5 + abs(len(solution)-n)\n    if any((not isinstance(x,int) or x<1) for x in solution):\n        return PENALTY_INVALID + 10**4\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k+1)):\n        # Enforce contiguity requirement\n        return PENALTY_INVALID + 5000 + abs(k - len(used))\n    # Proper-coloring constraint\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 1000*conflicts + k\n    # Valid solution: objective is k (minimize)\n    # Add minimality verification (optional but robust)\n    # Lower bound via max clique (exact for n=9)\n    adj = {i:set() for i in range(1,n+1)}\n    edge_set = set(edges)\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def max_clique_size():\n        best = 1\n        nodes = list(range(1,n+1))\n        for r in range(2, n+1):\n            found = False\n            for comb in itertools.combinations(nodes, r):\n                ok = True\n                for i in range(r):\n                    ui = comb[i]\n                    for j in range(i+1, r):\n                        vj = comb[j]\n                        a = ui if ui<vj else vj\n                        b = vj if ui<vj else ui\n                        if (a,b) not in edge_set:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    best = r\n                    found = True\n                    break\n            if not found:\n                break\n        return best\n    def exists_k_coloring(ktry):\n        order = sorted(range(1,n+1), key=lambda x: len(adj[x]), reverse=True)\n        assign = [0]*n\n        def bt(t):\n            if t == n:\n                return True\n            u = order[t]\n            forbidden = set(assign[v-1] for v in adj[u] if assign[v-1] != 0)\n            for c in range(1, ktry+1):\n                if c in forbidden:\n                    continue\n                assign[u-1] = c\n                if bt(t+1):\n                    return True\n                assign[u-1] = 0\n            return False\n        return bt(0)\n    lb = max_clique_size()\n    penalty = 0\n    if k < lb:\n        penalty += PENALTY_INVALID\n    if k > 1 and exists_k_coloring(k-1):\n        penalty += 10**5 + (k-1)\n    return k + penalty\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). Neighbor is INDEX_LIST like input.\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random valid-shaped solution if malformed\n        k = 3\n        sol = [random.randint(1,k) for _ in range(n)]\n        # relabel to contiguous 1..k actually already ok; ensure at least one of each\n        sol[0] = 1; sol[1] = 2; sol[2] = 3\n        return (sol, \"init-repair\")\n    sol = list(solution)\n    # Helper: compress labels to 1..k preserving order of first appearance\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Problem data local\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k = max(sol) if sol else 1\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u,v))\n    move_type = \"recolor\"\n    if conflicts:\n        # Target one endpoint of a random conflicting edge, recolor to least conflicting color\n        u,v = random.choice(conflicts)\n        target = random.choice([u,v])\n        used_by_neigh = set(sol[w-1] for w in adj[target])\n        candidate_colors = list(range(1, k+1)) + [k+1]\n        random.shuffle(candidate_colors)\n        best_c = None\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w-1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        sol[target-1] = best_c\n        sol = compress_labels(sol)\n        return (sol, move_type)\n    # If no conflicts, try to reduce k by merging two colors or recoloring a vertex to lower color\n    # Pick a vertex with highest color label and try recolor to a lower feasible color\n    order = sorted(range(1,n+1), key=lambda x: sol[x-1], reverse=True)\n    for u in order:\n        neigh_colors = set(sol[w-1] for w in adj[u])\n        for c in range(1, sol[u-1]):\n            if c not in neigh_colors:\n                sol[u-1] = c\n                sol = compress_labels(sol)\n                return (sol, \"reduce-k\")\n    # Otherwise perform a random small recolor to escape plateaus\n    u = random.randint(1, n)\n    candidate_colors = list(range(1, k+1)) + [k+1]\n    candidate_colors = [c for c in candidate_colors if c != sol[u-1]]\n    sol[u-1] = random.choice(candidate_colors) if candidate_colors else sol[u-1]\n    sol = compress_labels(sol)\n    return (sol, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: random recolors and optional color merge\/split\n    n = 9\n    sol = list(solution) if isinstance(solution, list) and len(solution)==n else [1,2,1,2,1,3,3,1,3]\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Problem data local\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k = max(sol)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # With some probability, try merging two random colors\n        if random.random() < 0.3 and k > 1:\n            c1, c2 = random.sample(range(1, k+1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x==source else x for x in sol]\n            sol = compress_labels(sol)\n            k = max(sol)\n            continue\n        # Otherwise recolor a random vertex to a random color (including new color)\n        u = random.randint(1, n)\n        candidate_colors = list(range(1, k+1))\n        if random.random() < 0.25:\n            candidate_colors.append(k+1)\n        # Avoid current color\n        candidate_colors = [c for c in candidate_colors if c != sol[u-1]] or [sol[u-1]]\n        # Prefer colors not used by neighbors\n        neigh_colors = set(sol[w-1] for w in adj[u])\n        safe = [c for c in candidate_colors if c not in neigh_colors]\n        sol[u-1] = random.choice(safe if safe else candidate_colors)\n        sol = compress_labels(sol)\n        k = max(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001377437}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; colors are contiguous integers 1..k with no gaps.","Evaluacion":"import math\nimport itertools\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns large penalties for invalid solutions.\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    PENALTY_INVALID = 10**6\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 10**5\n    if len(solution) != n:\n        return PENALTY_INVALID + 10**5 + abs(len(solution)-n)\n    if any((not isinstance(x,int) or x<1) for x in solution):\n        return PENALTY_INVALID + 10**4\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k+1)):\n        # Enforce contiguity requirement\n        return PENALTY_INVALID + 5000 + abs(k - len(used))\n    # Proper-coloring constraint\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 1000*conflicts + k\n    # Valid solution: objective is k (minimize)\n    # Add minimality verification (optional but robust)\n    # Lower bound via max clique (exact for n=9)\n    adj = {i:set() for i in range(1,n+1)}\n    edge_set = set(edges)\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def max_clique_size():\n        best = 1\n        nodes = list(range(1,n+1))\n        for r in range(2, n+1):\n            found = False\n            for comb in itertools.combinations(nodes, r):\n                ok = True\n                for i in range(r):\n                    ui = comb[i]\n                    for j in range(i+1, r):\n                        vj = comb[j]\n                        a = ui if ui<vj else vj\n                        b = vj if ui<vj else ui\n                        if (a,b) not in edge_set:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    best = r\n                    found = True\n                    break\n            if not found:\n                break\n        return best\n    def exists_k_coloring(ktry):\n        order = sorted(range(1,n+1), key=lambda x: len(adj[x]), reverse=True)\n        assign = [0]*n\n        def bt(t):\n            if t == n:\n                return True\n            u = order[t]\n            forbidden = set(assign[v-1] for v in adj[u] if assign[v-1] != 0)\n            for c in range(1, ktry+1):\n                if c in forbidden:\n                    continue\n                assign[u-1] = c\n                if bt(t+1):\n                    return True\n                assign[u-1] = 0\n            return False\n        return bt(0)\n    lb = max_clique_size()\n    penalty = 0\n    if k < lb:\n        penalty += PENALTY_INVALID\n    if k > 1 and exists_k_coloring(k-1):\n        penalty += 10**5 + (k-1)\n    return k + penalty\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). Neighbor is INDEX_LIST like input.\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random valid-shaped solution if malformed\n        k = 3\n        sol = [random.randint(1,k) for _ in range(n)]\n        # relabel to contiguous 1..k actually already ok; ensure at least one of each\n        sol[0] = 1; sol[1] = 2; sol[2] = 3\n        return (sol, \"init-repair\")\n    sol = list(solution)\n    # Helper: compress labels to 1..k preserving order of first appearance\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Problem data local\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k = max(sol) if sol else 1\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u,v))\n    move_type = \"recolor\"\n    if conflicts:\n        # Target one endpoint of a random conflicting edge, recolor to least conflicting color\n        u,v = random.choice(conflicts)\n        target = random.choice([u,v])\n        used_by_neigh = set(sol[w-1] for w in adj[target])\n        candidate_colors = list(range(1, k+1)) + [k+1]\n        random.shuffle(candidate_colors)\n        best_c = None\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w-1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        sol[target-1] = best_c\n        sol = compress_labels(sol)\n        return (sol, move_type)\n    # If no conflicts, try to reduce k by merging two colors or recoloring a vertex to lower color\n    # Pick a vertex with highest color label and try recolor to a lower feasible color\n    order = sorted(range(1,n+1), key=lambda x: sol[x-1], reverse=True)\n    for u in order:\n        neigh_colors = set(sol[w-1] for w in adj[u])\n        for c in range(1, sol[u-1]):\n            if c not in neigh_colors:\n                sol[u-1] = c\n                sol = compress_labels(sol)\n                return (sol, \"reduce-k\")\n    # Otherwise perform a random small recolor to escape plateaus\n    u = random.randint(1, n)\n    candidate_colors = list(range(1, k+1)) + [k+1]\n    candidate_colors = [c for c in candidate_colors if c != sol[u-1]]\n    sol[u-1] = random.choice(candidate_colors) if candidate_colors else sol[u-1]\n    sol = compress_labels(sol)\n    return (sol, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: random recolors and optional color merge\/split\n    n = 9\n    sol = list(solution) if isinstance(solution, list) and len(solution)==n else [1,2,1,2,1,3,3,1,3]\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Problem data local\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k = max(sol)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # With some probability, try merging two random colors\n        if random.random() < 0.3 and k > 1:\n            c1, c2 = random.sample(range(1, k+1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x==source else x for x in sol]\n            sol = compress_labels(sol)\n            k = max(sol)\n            continue\n        # Otherwise recolor a random vertex to a random color (including new color)\n        u = random.randint(1, n)\n        candidate_colors = list(range(1, k+1))\n        if random.random() < 0.25:\n            candidate_colors.append(k+1)\n        # Avoid current color\n        candidate_colors = [c for c in candidate_colors if c != sol[u-1]] or [sol[u-1]]\n        # Prefer colors not used by neighbors\n        neigh_colors = set(sol[w-1] for w in adj[u])\n        safe = [c for c in candidate_colors if c not in neigh_colors]\n        sol[u-1] = random.choice(safe if safe else candidate_colors)\n        sol = compress_labels(sol)\n        k = max(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001523348}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; colors are contiguous integers 1..k with no gaps.","Evaluacion":"import math\nimport itertools\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns large penalties for invalid solutions.\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    PENALTY_INVALID = 10**6\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 10**5\n    if len(solution) != n:\n        return PENALTY_INVALID + 10**5 + abs(len(solution)-n)\n    if any((not isinstance(x,int) or x<1) for x in solution):\n        return PENALTY_INVALID + 10**4\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k+1)):\n        # Enforce contiguity requirement\n        return PENALTY_INVALID + 5000 + abs(k - len(used))\n    # Proper-coloring constraint\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 1000*conflicts + k\n    # Valid solution: objective is k (minimize)\n    # Add minimality verification (optional but robust)\n    # Lower bound via max clique (exact for n=9)\n    adj = {i:set() for i in range(1,n+1)}\n    edge_set = set(edges)\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def max_clique_size():\n        best = 1\n        nodes = list(range(1,n+1))\n        for r in range(2, n+1):\n            found = False\n            for comb in itertools.combinations(nodes, r):\n                ok = True\n                for i in range(r):\n                    ui = comb[i]\n                    for j in range(i+1, r):\n                        vj = comb[j]\n                        a = ui if ui<vj else vj\n                        b = vj if ui<vj else ui\n                        if (a,b) not in edge_set:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    best = r\n                    found = True\n                    break\n            if not found:\n                break\n        return best\n    def exists_k_coloring(ktry):\n        order = sorted(range(1,n+1), key=lambda x: len(adj[x]), reverse=True)\n        assign = [0]*n\n        def bt(t):\n            if t == n:\n                return True\n            u = order[t]\n            forbidden = set(assign[v-1] for v in adj[u] if assign[v-1] != 0)\n            for c in range(1, ktry+1):\n                if c in forbidden:\n                    continue\n                assign[u-1] = c\n                if bt(t+1):\n                    return True\n                assign[u-1] = 0\n            return False\n        return bt(0)\n    lb = max_clique_size()\n    penalty = 0\n    if k < lb:\n        penalty += PENALTY_INVALID\n    if k > 1 and exists_k_coloring(k-1):\n        penalty += 10**5 + (k-1)\n    return k + penalty\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). Neighbor is INDEX_LIST like input.\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random valid-shaped solution if malformed\n        k = 3\n        sol = [random.randint(1,k) for _ in range(n)]\n        # relabel to contiguous 1..k actually already ok; ensure at least one of each\n        sol[0] = 1; sol[1] = 2; sol[2] = 3\n        return (sol, \"init-repair\")\n    sol = list(solution)\n    # Helper: compress labels to 1..k preserving order of first appearance\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Problem data local\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k = max(sol) if sol else 1\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u,v))\n    move_type = \"recolor\"\n    if conflicts:\n        # Target one endpoint of a random conflicting edge, recolor to least conflicting color\n        u,v = random.choice(conflicts)\n        target = random.choice([u,v])\n        used_by_neigh = set(sol[w-1] for w in adj[target])\n        candidate_colors = list(range(1, k+1)) + [k+1]\n        random.shuffle(candidate_colors)\n        best_c = None\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w-1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        sol[target-1] = best_c\n        sol = compress_labels(sol)\n        return (sol, move_type)\n    # If no conflicts, try to reduce k by merging two colors or recoloring a vertex to lower color\n    # Pick a vertex with highest color label and try recolor to a lower feasible color\n    order = sorted(range(1,n+1), key=lambda x: sol[x-1], reverse=True)\n    for u in order:\n        neigh_colors = set(sol[w-1] for w in adj[u])\n        for c in range(1, sol[u-1]):\n            if c not in neigh_colors:\n                sol[u-1] = c\n                sol = compress_labels(sol)\n                return (sol, \"reduce-k\")\n    # Otherwise perform a random small recolor to escape plateaus\n    u = random.randint(1, n)\n    candidate_colors = list(range(1, k+1)) + [k+1]\n    candidate_colors = [c for c in candidate_colors if c != sol[u-1]]\n    sol[u-1] = random.choice(candidate_colors) if candidate_colors else sol[u-1]\n    sol = compress_labels(sol)\n    return (sol, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: random recolors and optional color merge\/split\n    n = 9\n    sol = list(solution) if isinstance(solution, list) and len(solution)==n else [1,2,1,2,1,3,3,1,3]\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Problem data local\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = sorted(set([(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]))\n    adj = {i:set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    k = max(sol)\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # With some probability, try merging two random colors\n        if random.random() < 0.3 and k > 1:\n            c1, c2 = random.sample(range(1, k+1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x==source else x for x in sol]\n            sol = compress_labels(sol)\n            k = max(sol)\n            continue\n        # Otherwise recolor a random vertex to a random color (including new color)\n        u = random.randint(1, n)\n        candidate_colors = list(range(1, k+1))\n        if random.random() < 0.25:\n            candidate_colors.append(k+1)\n        # Avoid current color\n        candidate_colors = [c for c in candidate_colors if c != sol[u-1]] or [sol[u-1]]\n        # Prefer colors not used by neighbors\n        neigh_colors = set(sol[w-1] for w in adj[u])\n        safe = [c for c in candidate_colors if c not in neigh_colors]\n        sol[u-1] = random.choice(safe if safe else candidate_colors)\n        sol = compress_labels(sol)\n        k = max(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type Tuple cannot be instantiated; use tuple() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001388376}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST of length 9. Colors are positive integers with contiguous labels 1..k (no gaps). Example: [1,1,2,2,1,3,3,2,3].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize conflicts and non-contiguous labels strongly.\n    PENALTY_INVALID = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 10**5\n    if len(solution) != n:\n        return PENALTY_INVALID + 10**5 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 10**5\n    # Contiguity check 1..k\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        # Non-contiguous labels: penalize but keep informative scale\n        gaps = abs(k - len(used))\n        return PENALTY_INVALID \/\/ 2 + 1000 * gaps + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 1000 * conflicts + k\n    # Feasible: objective is k (minimize number of colors)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, movement_type_string)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Helpers\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(sol: List[int]):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        # BFS over subgraph induced by colors {a,b}; swap a<->b on the reached component\n        if a == b:\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            new_sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return new_sol\n\n    def try_reduce_k(sol: List[int], adj) -> Tuple[List[int], bool]:\n        # Attempt to eliminate the highest color class by greedy reassignment\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # Order by saturation (number of distinct neighbor colors), then degree\n        def sat(u):\n            return len(set(sol[w - 1] for w in adj[u] if w != u))\n        verts.sort(key=lambda u: ( -sat(u), -len(adj[u]) ))\n        for u in verts:\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        sol = compress_labels(sol)\n        return sol, True\n\n    # Init\/repair malformed inputs\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(n)]\n        # Ensure at least one of each 1..3\n        sol[0] = 1; sol[1] = 2; sol[2] = 3\n        sol = compress_labels(sol)\n        return (sol, \"init-repair\")\n\n    sol = compress_labels(list(solution))\n    adj = build_adj()\n\n    conf = conflicts_list(sol)\n    if conf:\n        # Conflict-driven move: recolor one endpoint with least-conflicting color; fallback to Kempe swap\n        u, v = random.choice(conf)\n        target = random.choice([u, v])\n        k = max(sol)\n        candidate_colors = list(range(1, k + 1)) + [k + 1]\n        random.shuffle(candidate_colors)\n        best_c = sol[target - 1]\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        new_sol = compress_labels(new_sol)\n        if not conflicts_list(new_sol):\n            return (new_sol, \"recolor\")\n        # Fallback: Kempe chain with a neighbor color\n        neigh_colors = list(set(sol[w - 1] for w in adj[target]))\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            c1 = sol[target - 1]\n            new_sol = kempe_chain_swap(sol, target, c1, c2, adj)\n            new_sol = compress_labels(new_sol)\n            return (new_sol, \"kempe\")\n        return (new_sol, \"recolor\")\n\n    # No conflicts: attempt k-reduction\n    if random.random() < 0.7:  # bias towards k reduction when feasible\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification: Kempe swap between two colors from a random vertex\n    u = random.randint(1, n)\n    k = max(sol)\n    neigh_colors = [sol[w - 1] for w in adj[u]]\n    if neigh_colors:\n        c2 = random.choice(neigh_colors)\n        c1 = sol[u - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback random recolor\n    candidate_colors = [c for c in (list(range(1, k + 1)) + [k + 1]) if c != sol[u - 1]] or [sol[u - 1]]\n    sol[u - 1] = random.choice(candidate_colors)\n    sol = compress_labels(sol)\n    return (sol, \"random-recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-step perturbation combining color merges, Kempe swaps, and random recolors\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b:\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            new_sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return new_sol\n\n    # Start from a repaired baseline if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n    sol = compress_labels(sol)\n    adj = build_adj()\n\n    steps = random.randint(4, 8)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.30 and k > 1:\n            # Merge two random colors, then compress\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            sol = compress_labels(sol)\n        elif r < 0.65:\n            # Kempe chain from a random vertex with a random neighbor color\n            u = random.randint(1, n)\n            neigh = list(adj[u])\n            if neigh:\n                c1 = sol[u - 1]\n                c2 = sol[random.choice(neigh) - 1]\n                sol = kempe_chain_swap(sol, u, c1, c2, adj)\n                sol = compress_labels(sol)\n        else:\n            # Random recolor, possibly introducing a new color\n            u = random.randint(1, n)\n            candidate_colors = list(range(1, k + 1))\n            if random.random() < 0.35:\n                candidate_colors.append(k + 1)\n            candidate_colors = [c for c in candidate_colors if c != sol[u - 1]] or [sol[u - 1]]\n            # Prefer colors not in neighbors if available\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            safe = [c for c in candidate_colors if c not in neigh_colors]\n            sol[u - 1] = random.choice(safe if safe else candidate_colors)\n            sol = compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00170842}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST of length 9. Colors are positive integers with contiguous labels 1..k (no gaps). Example: [1,1,2,2,1,3,3,2,3].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize conflicts and non-contiguous labels strongly.\n    PENALTY_INVALID = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 10**5\n    if len(solution) != n:\n        return PENALTY_INVALID + 10**5 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 10**5\n    # Contiguity check 1..k\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        # Non-contiguous labels: penalize but keep informative scale\n        gaps = abs(k - len(used))\n        return PENALTY_INVALID \/\/ 2 + 1000 * gaps + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 1000 * conflicts + k\n    # Feasible: objective is k (minimize number of colors)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, movement_type_string)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Helpers\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(sol: List[int]):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        # BFS over subgraph induced by colors {a,b}; swap a<->b on the reached component\n        if a == b:\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            new_sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return new_sol\n\n    def try_reduce_k(sol: List[int], adj) -> Tuple[List[int], bool]:\n        # Attempt to eliminate the highest color class by greedy reassignment\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # Order by saturation (number of distinct neighbor colors), then degree\n        def sat(u):\n            return len(set(sol[w - 1] for w in adj[u] if w != u))\n        verts.sort(key=lambda u: ( -sat(u), -len(adj[u]) ))\n        for u in verts:\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        sol = compress_labels(sol)\n        return sol, True\n\n    # Init\/repair malformed inputs\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(n)]\n        # Ensure at least one of each 1..3\n        sol[0] = 1; sol[1] = 2; sol[2] = 3\n        sol = compress_labels(sol)\n        return (sol, \"init-repair\")\n\n    sol = compress_labels(list(solution))\n    adj = build_adj()\n\n    conf = conflicts_list(sol)\n    if conf:\n        # Conflict-driven move: recolor one endpoint with least-conflicting color; fallback to Kempe swap\n        u, v = random.choice(conf)\n        target = random.choice([u, v])\n        k = max(sol)\n        candidate_colors = list(range(1, k + 1)) + [k + 1]\n        random.shuffle(candidate_colors)\n        best_c = sol[target - 1]\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        new_sol = compress_labels(new_sol)\n        if not conflicts_list(new_sol):\n            return (new_sol, \"recolor\")\n        # Fallback: Kempe chain with a neighbor color\n        neigh_colors = list(set(sol[w - 1] for w in adj[target]))\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            c1 = sol[target - 1]\n            new_sol = kempe_chain_swap(sol, target, c1, c2, adj)\n            new_sol = compress_labels(new_sol)\n            return (new_sol, \"kempe\")\n        return (new_sol, \"recolor\")\n\n    # No conflicts: attempt k-reduction\n    if random.random() < 0.7:  # bias towards k reduction when feasible\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification: Kempe swap between two colors from a random vertex\n    u = random.randint(1, n)\n    k = max(sol)\n    neigh_colors = [sol[w - 1] for w in adj[u]]\n    if neigh_colors:\n        c2 = random.choice(neigh_colors)\n        c1 = sol[u - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback random recolor\n    candidate_colors = [c for c in (list(range(1, k + 1)) + [k + 1]) if c != sol[u - 1]] or [sol[u - 1]]\n    sol[u - 1] = random.choice(candidate_colors)\n    sol = compress_labels(sol)\n    return (sol, \"random-recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-step perturbation combining color merges, Kempe swaps, and random recolors\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b:\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            new_sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return new_sol\n\n    # Start from a repaired baseline if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n    sol = compress_labels(sol)\n    adj = build_adj()\n\n    steps = random.randint(4, 8)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.30 and k > 1:\n            # Merge two random colors, then compress\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            sol = compress_labels(sol)\n        elif r < 0.65:\n            # Kempe chain from a random vertex with a random neighbor color\n            u = random.randint(1, n)\n            neigh = list(adj[u])\n            if neigh:\n                c1 = sol[u - 1]\n                c2 = sol[random.choice(neigh) - 1]\n                sol = kempe_chain_swap(sol, u, c1, c2, adj)\n                sol = compress_labels(sol)\n        else:\n            # Random recolor, possibly introducing a new color\n            u = random.randint(1, n)\n            candidate_colors = list(range(1, k + 1))\n            if random.random() < 0.35:\n                candidate_colors.append(k + 1)\n            candidate_colors = [c for c in candidate_colors if c != sol[u - 1]] or [sol[u - 1]]\n            # Prefer colors not in neighbors if available\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            safe = [c for c in candidate_colors if c not in neigh_colors]\n            sol[u - 1] = random.choice(safe if safe else candidate_colors)\n            sol = compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002256097}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST of length 9. Colors are positive integers with contiguous labels 1..k (no gaps). Example: [1,1,2,2,1,3,3,2,3].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize conflicts and non-contiguous labels strongly.\n    PENALTY_INVALID = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 10**5\n    if len(solution) != n:\n        return PENALTY_INVALID + 10**5 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 10**5\n    # Contiguity check 1..k\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        # Non-contiguous labels: penalize but keep informative scale\n        gaps = abs(k - len(used))\n        return PENALTY_INVALID \/\/ 2 + 1000 * gaps + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 1000 * conflicts + k\n    # Feasible: objective is k (minimize number of colors)\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, movement_type_string)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Helpers\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(sol: List[int]):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        # BFS over subgraph induced by colors {a,b}; swap a<->b on the reached component\n        if a == b:\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            new_sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return new_sol\n\n    def try_reduce_k(sol: List[int], adj) -> Tuple[List[int], bool]:\n        # Attempt to eliminate the highest color class by greedy reassignment\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # Order by saturation (number of distinct neighbor colors), then degree\n        def sat(u):\n            return len(set(sol[w - 1] for w in adj[u] if w != u))\n        verts.sort(key=lambda u: ( -sat(u), -len(adj[u]) ))\n        for u in verts:\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        sol = compress_labels(sol)\n        return sol, True\n\n    # Init\/repair malformed inputs\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(n)]\n        # Ensure at least one of each 1..3\n        sol[0] = 1; sol[1] = 2; sol[2] = 3\n        sol = compress_labels(sol)\n        return (sol, \"init-repair\")\n\n    sol = compress_labels(list(solution))\n    adj = build_adj()\n\n    conf = conflicts_list(sol)\n    if conf:\n        # Conflict-driven move: recolor one endpoint with least-conflicting color; fallback to Kempe swap\n        u, v = random.choice(conf)\n        target = random.choice([u, v])\n        k = max(sol)\n        candidate_colors = list(range(1, k + 1)) + [k + 1]\n        random.shuffle(candidate_colors)\n        best_c = sol[target - 1]\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        new_sol = compress_labels(new_sol)\n        if not conflicts_list(new_sol):\n            return (new_sol, \"recolor\")\n        # Fallback: Kempe chain with a neighbor color\n        neigh_colors = list(set(sol[w - 1] for w in adj[target]))\n        if neigh_colors:\n            c2 = random.choice(neigh_colors)\n            c1 = sol[target - 1]\n            new_sol = kempe_chain_swap(sol, target, c1, c2, adj)\n            new_sol = compress_labels(new_sol)\n            return (new_sol, \"kempe\")\n        return (new_sol, \"recolor\")\n\n    # No conflicts: attempt k-reduction\n    if random.random() < 0.7:  # bias towards k reduction when feasible\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification: Kempe swap between two colors from a random vertex\n    u = random.randint(1, n)\n    k = max(sol)\n    neigh_colors = [sol[w - 1] for w in adj[u]]\n    if neigh_colors:\n        c2 = random.choice(neigh_colors)\n        c1 = sol[u - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback random recolor\n    candidate_colors = [c for c in (list(range(1, k + 1)) + [k + 1]) if c != sol[u - 1]] or [sol[u - 1]]\n    sol[u - 1] = random.choice(candidate_colors)\n    sol = compress_labels(sol)\n    return (sol, \"random-recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-step perturbation combining color merges, Kempe swaps, and random recolors\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b:\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            new_sol[u - 1] = a if sol[u - 1] == b else (b if sol[u - 1] == a else sol[u - 1])\n        return new_sol\n\n    # Start from a repaired baseline if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n    sol = compress_labels(sol)\n    adj = build_adj()\n\n    steps = random.randint(4, 8)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.30 and k > 1:\n            # Merge two random colors, then compress\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            sol = compress_labels(sol)\n        elif r < 0.65:\n            # Kempe chain from a random vertex with a random neighbor color\n            u = random.randint(1, n)\n            neigh = list(adj[u])\n            if neigh:\n                c1 = sol[u - 1]\n                c2 = sol[random.choice(neigh) - 1]\n                sol = kempe_chain_swap(sol, u, c1, c2, adj)\n                sol = compress_labels(sol)\n        else:\n            # Random recolor, possibly introducing a new color\n            u = random.randint(1, n)\n            candidate_colors = list(range(1, k + 1))\n            if random.random() < 0.35:\n                candidate_colors.append(k + 1)\n            candidate_colors = [c for c in candidate_colors if c != sol[u - 1]] or [sol[u - 1]]\n            # Prefer colors not in neighbors if available\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            safe = [c for c in candidate_colors if c not in neigh_colors]\n            sol[u - 1] = random.choice(safe if safe else candidate_colors)\n            sol = compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002295518}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST of length 9. Colors are positive integers with contiguous labels 1..k (no gaps). Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY_INVALID = 10**5\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Structure checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 20000\n    if len(solution) != n:\n        return PENALTY_INVALID + 20000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 30000\n    # Contiguity check 1..k\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        gaps = abs(k - len(used))\n        # Soft penalty for non-contiguous labels\n        return PENALTY_INVALID \/\/ 2 + 100 * gaps + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize conflicts; keep scale informative\n        return PENALTY_INVALID + 100 * conflicts + k\n    # Feasible: objective is to minimize k\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(sol: List[int]):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def try_reduce_k(sol: List[int], adj) -> Tuple[List[int], bool]:\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # Order by saturation then degree\n        def sat(u):\n            return len(set(sol[w - 1] for w in adj[u]))\n        verts.sort(key=lambda u: (-sat(u), -len(adj[u])))\n        for u in verts:\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        # Only compress when no conflicts (attempted reduction)\n        if not conflicts_list(sol):\n            sol = compress_labels(sol)\n        return sol, True\n\n    # Input repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        # DSATUR-like quick seed\n        adj = build_adj()\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        colors = [0]*n\n        for u in order:\n            used = set(colors[w-1] for w in adj[u] if colors[w-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n        colors = compress_labels(colors)\n        return (colors, \"init-repair\")\n\n    sol = list(solution)\n    adj = build_adj()\n\n    conf = conflicts_list(sol)\n    if conf:\n        # Focus on most conflicted vertex\n        degree_conf = {i:0 for i in range(1, n+1)}\n        for (u,v) in conf:\n            degree_conf[u] += 1\n            degree_conf[v] += 1\n        target = max(degree_conf.keys(), key=lambda u: (degree_conf[u], len(adj[u])))\n        k = max(sol)\n        # Restrict to existing colors during conflict repair\n        candidate_colors = [c for c in range(1, k+1) if c != sol[target-1]]\n        random.shuffle(candidate_colors)\n        best_c = sol[target-1]\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        return (new_sol, \"recolor-conflict\")\n\n    # No conflicts: attempt to reduce k\n    if random.random() < 0.8:\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification via Kempe swap along an edge color pair\n    u = random.randint(1, n)\n    if adj[u]:\n        v = random.choice(list(adj[u]))\n        c1 = sol[u - 1]\n        c2 = sol[v - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        if not conflicts_list(new_sol):\n            new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback: allow introducing a new color sparingly\n    k = max(sol)\n    new_sol = sol[:]\n    cand = list(range(1, k + 2))\n    cand = [c for c in cand if c != new_sol[u - 1]] or [new_sol[u - 1]]\n    new_sol[u - 1] = random.choice(cand)\n    return (new_sol, \"random-recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    # Baseline repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [2,2,3,3,2,1,1,3,1]\n    else:\n        sol = list(solution)\n\n    adj = build_adj()\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.30 and k > 1:\n            # Merge two color classes to force exploration\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            # Do not compress immediately; allow later steps to adjust\n        elif r < 0.70:\n            # Kempe chain along a random edge\n            u = random.randint(1, n)\n            if adj[u]:\n                v = random.choice(list(adj[u]))\n                a, b = sol[u - 1], sol[v - 1]\n                sol = kempe_chain_swap(sol, u, a, b, adj)\n        else:\n            # Random recolor; may introduce a new color with small prob\n            u = random.randint(1, n)\n            cand = list(range(1, k + 1))\n            if random.random() < 0.25:\n                cand.append(k + 1)\n            cand = [c for c in cand if c != sol[u - 1]] or [sol[u - 1]]\n            # Prefer colors not used by neighbors\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            safe = [c for c in cand if c not in neigh_colors]\n            sol[u - 1] = random.choice(safe if safe else cand)\n    # Compress at the end to restore contiguity\n    sol = compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001374606}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST of length 9. Colors are positive integers with contiguous labels 1..k (no gaps). Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY_INVALID = 10**5\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Structure checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 20000\n    if len(solution) != n:\n        return PENALTY_INVALID + 20000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 30000\n    # Contiguity check 1..k\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        gaps = abs(k - len(used))\n        # Soft penalty for non-contiguous labels\n        return PENALTY_INVALID \/\/ 2 + 100 * gaps + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize conflicts; keep scale informative\n        return PENALTY_INVALID + 100 * conflicts + k\n    # Feasible: objective is to minimize k\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(sol: List[int]):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def try_reduce_k(sol: List[int], adj) -> Tuple[List[int], bool]:\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # Order by saturation then degree\n        def sat(u):\n            return len(set(sol[w - 1] for w in adj[u]))\n        verts.sort(key=lambda u: (-sat(u), -len(adj[u])))\n        for u in verts:\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        # Only compress when no conflicts (attempted reduction)\n        if not conflicts_list(sol):\n            sol = compress_labels(sol)\n        return sol, True\n\n    # Input repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        # DSATUR-like quick seed\n        adj = build_adj()\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        colors = [0]*n\n        for u in order:\n            used = set(colors[w-1] for w in adj[u] if colors[w-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n        colors = compress_labels(colors)\n        return (colors, \"init-repair\")\n\n    sol = list(solution)\n    adj = build_adj()\n\n    conf = conflicts_list(sol)\n    if conf:\n        # Focus on most conflicted vertex\n        degree_conf = {i:0 for i in range(1, n+1)}\n        for (u,v) in conf:\n            degree_conf[u] += 1\n            degree_conf[v] += 1\n        target = max(degree_conf.keys(), key=lambda u: (degree_conf[u], len(adj[u])))\n        k = max(sol)\n        # Restrict to existing colors during conflict repair\n        candidate_colors = [c for c in range(1, k+1) if c != sol[target-1]]\n        random.shuffle(candidate_colors)\n        best_c = sol[target-1]\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        return (new_sol, \"recolor-conflict\")\n\n    # No conflicts: attempt to reduce k\n    if random.random() < 0.8:\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification via Kempe swap along an edge color pair\n    u = random.randint(1, n)\n    if adj[u]:\n        v = random.choice(list(adj[u]))\n        c1 = sol[u - 1]\n        c2 = sol[v - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        if not conflicts_list(new_sol):\n            new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback: allow introducing a new color sparingly\n    k = max(sol)\n    new_sol = sol[:]\n    cand = list(range(1, k + 2))\n    cand = [c for c in cand if c != new_sol[u - 1]] or [new_sol[u - 1]]\n    new_sol[u - 1] = random.choice(cand)\n    return (new_sol, \"random-recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    # Baseline repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [2,2,3,3,2,1,1,3,1]\n    else:\n        sol = list(solution)\n\n    adj = build_adj()\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.30 and k > 1:\n            # Merge two color classes to force exploration\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            # Do not compress immediately; allow later steps to adjust\n        elif r < 0.70:\n            # Kempe chain along a random edge\n            u = random.randint(1, n)\n            if adj[u]:\n                v = random.choice(list(adj[u]))\n                a, b = sol[u - 1], sol[v - 1]\n                sol = kempe_chain_swap(sol, u, a, b, adj)\n        else:\n            # Random recolor; may introduce a new color with small prob\n            u = random.randint(1, n)\n            cand = list(range(1, k + 1))\n            if random.random() < 0.25:\n                cand.append(k + 1)\n            cand = [c for c in cand if c != sol[u - 1]] or [sol[u - 1]]\n            # Prefer colors not used by neighbors\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            safe = [c for c in cand if c not in neigh_colors]\n            sol[u - 1] = random.choice(safe if safe else cand)\n    # Compress at the end to restore contiguity\n    sol = compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.0018239919}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST of length 9. Colors are positive integers with contiguous labels 1..k (no gaps). Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    PENALTY_INVALID = 10**5\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Structure checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 20000\n    if len(solution) != n:\n        return PENALTY_INVALID + 20000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 30000\n    # Contiguity check 1..k\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        gaps = abs(k - len(used))\n        # Soft penalty for non-contiguous labels\n        return PENALTY_INVALID \/\/ 2 + 100 * gaps + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize conflicts; keep scale informative\n        return PENALTY_INVALID + 100 * conflicts + k\n    # Feasible: objective is to minimize k\n    return float(k)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def conflicts_list(sol: List[int]):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def try_reduce_k(sol: List[int], adj) -> Tuple[List[int], bool]:\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # Order by saturation then degree\n        def sat(u):\n            return len(set(sol[w - 1] for w in adj[u]))\n        verts.sort(key=lambda u: (-sat(u), -len(adj[u])))\n        for u in verts:\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        # Only compress when no conflicts (attempted reduction)\n        if not conflicts_list(sol):\n            sol = compress_labels(sol)\n        return sol, True\n\n    # Input repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        # DSATUR-like quick seed\n        adj = build_adj()\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        colors = [0]*n\n        for u in order:\n            used = set(colors[w-1] for w in adj[u] if colors[w-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n        colors = compress_labels(colors)\n        return (colors, \"init-repair\")\n\n    sol = list(solution)\n    adj = build_adj()\n\n    conf = conflicts_list(sol)\n    if conf:\n        # Focus on most conflicted vertex\n        degree_conf = {i:0 for i in range(1, n+1)}\n        for (u,v) in conf:\n            degree_conf[u] += 1\n            degree_conf[v] += 1\n        target = max(degree_conf.keys(), key=lambda u: (degree_conf[u], len(adj[u])))\n        k = max(sol)\n        # Restrict to existing colors during conflict repair\n        candidate_colors = [c for c in range(1, k+1) if c != sol[target-1]]\n        random.shuffle(candidate_colors)\n        best_c = sol[target-1]\n        best_hits = 10**9\n        for c in candidate_colors:\n            hits = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        return (new_sol, \"recolor-conflict\")\n\n    # No conflicts: attempt to reduce k\n    if random.random() < 0.8:\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification via Kempe swap along an edge color pair\n    u = random.randint(1, n)\n    if adj[u]:\n        v = random.choice(list(adj[u]))\n        c1 = sol[u - 1]\n        c2 = sol[v - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        if not conflicts_list(new_sol):\n            new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback: allow introducing a new color sparingly\n    k = max(sol)\n    new_sol = sol[:]\n    cand = list(range(1, k + 2))\n    cand = [c for c in cand if c != new_sol[u - 1]] or [new_sol[u - 1]]\n    new_sol[u - 1] = random.choice(cand)\n    return (new_sol, \"random-recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol: List[int], start_v: int, a: int, b: int, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    # Baseline repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [2,2,3,3,2,1,1,3,1]\n    else:\n        sol = list(solution)\n\n    adj = build_adj()\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.30 and k > 1:\n            # Merge two color classes to force exploration\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            # Do not compress immediately; allow later steps to adjust\n        elif r < 0.70:\n            # Kempe chain along a random edge\n            u = random.randint(1, n)\n            if adj[u]:\n                v = random.choice(list(adj[u]))\n                a, b = sol[u - 1], sol[v - 1]\n                sol = kempe_chain_swap(sol, u, a, b, adj)\n        else:\n            # Random recolor; may introduce a new color with small prob\n            u = random.randint(1, n)\n            cand = list(range(1, k + 1))\n            if random.random() < 0.25:\n                cand.append(k + 1)\n            cand = [c for c in cand if c != sol[u - 1]] or [sol[u - 1]]\n            # Prefer colors not used by neighbors\n            neigh_colors = set(sol[w - 1] for w in adj[u])\n            safe = [c for c in cand if c not in neigh_colors]\n            sol[u - 1] = random.choice(safe if safe else cand)\n    # Compress at the end to restore contiguity\n    sol = compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001847942}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length 9. Values are positive integers representing colors. Labels must be contiguous 1..k with no gaps.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY_INVALID = 10**5\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 20000\n    if len(solution) != n:\n        return PENALTY_INVALID + 20000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 30000\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        gaps = abs(k - len(used))\n        return PENALTY_INVALID \/\/ 2 + 100 * gaps + k\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 100 * conflicts + k\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(sol):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def kempe_chain_swap(sol, start_v, a, b, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def try_reduce_k(sol, adj):\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # order by saturation then degree\n        def sat(u):\n            return len({sol[w - 1] for w in adj[u]})\n        verts.sort(key=lambda u: (-sat(u), -len(adj[u])))\n        for u in verts:\n            neigh_colors = {sol[w - 1] for w in adj[u]}\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        new_sol = compress_labels(sol)\n        return new_sol, True\n\n    adj = build_adj()\n\n    # Seed\/repair malformed inputs via greedy DSATUR-like coloring\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        colors = [0] * n\n        for u in order:\n            used = {colors[w - 1] for w in adj[u] if colors[w - 1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[u - 1] = c\n        colors = compress_labels(colors)\n        return (colors, \"init-repair\")\n\n    sol = list(solution)\n    sol = compress_labels(sol)\n\n    conf = conflicts_list(sol)\n    if conf:\n        degree_conf = {i: 0 for i in range(1, n + 1)}\n        for (u, v) in conf:\n            degree_conf[u] += 1\n            degree_conf[v] += 1\n        # DSATUR-guided target selection\n        def sat(u):\n            return len({sol[w - 1] for w in adj[u]})\n        target = max(range(1, n + 1), key=lambda u: (degree_conf[u], sat(u), len(adj[u])))\n        k = max(sol)\n        candidate_colors = [c for c in range(1, k + 1) if c != sol[target - 1]]\n        random.shuffle(candidate_colors)\n        best_c = sol[target - 1]\n        best_hits = 10**9\n        # tie-break by minimizing sum of degrees of neighbors with that color\n        for c in candidate_colors:\n            hits = 0\n            tie = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n                    tie += len(adj[w])\n            if (hits < best_hits) or (hits == best_hits and tie < 10**9):\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"recolor-conflict\")\n\n    # No conflicts: attempt reduce-k often\n    if random.random() < 0.8:\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification via Kempe swap along a random edge\n    u = random.randint(1, n)\n    if adj[u]:\n        v = random.choice(list(adj[u]))\n        c1, c2 = sol[u - 1], sol[v - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback: safe recolor within existing palette (no new colors)\n    u = random.randint(1, n)\n    k = max(sol)\n    cand = [c for c in range(1, k + 1) if c != sol[u - 1]] or [sol[u - 1]]\n    neigh_colors = {sol[w - 1] for w in adj[u]}\n    safe = [c for c in cand if c not in neigh_colors]\n    new_sol = sol[:]\n    new_sol[u - 1] = random.choice(safe if safe else cand)\n    new_sol = compress_labels(new_sol)\n    return (new_sol, \"random-recolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol, start_v, a, b, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def greedy_repair(sol, adj, max_steps=20):\n        sol = sol[:]\n        for _ in range(max_steps):\n            # find a conflict\n            bad = None\n            for (u, v) in edges:\n                if sol[u - 1] == sol[v - 1]:\n                    bad = u\n                    break\n            if bad is None:\n                break\n            k = max(sol)\n            neigh = {sol[w - 1] for w in adj[bad]}\n            cand = [c for c in range(1, k + 1) if c != sol[bad - 1]]\n            safe = [c for c in cand if c not in neigh]\n            sol[bad - 1] = safe[0] if safe else random.choice(cand or [sol[bad - 1]])\n        return sol\n\n    # Baseline repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = list(solution)\n\n    sol = compress_labels(sol)\n    adj = build_adj()\n\n    steps = random.randint(5, 9)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.35 and k > 1:\n            # Merge two color classes to force exploration\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            sol = greedy_repair(sol, adj, max_steps=10)\n        elif r < 0.75:\n            # Kempe chain along a random edge\/color pair\n            u = random.randint(1, n)\n            if adj[u]:\n                v = random.choice(list(adj[u]))\n                a, b = sol[u - 1], sol[v - 1]\n                sol = kempe_chain_swap(sol, u, a, b, adj)\n        else:\n            # Random recolor with small chance to introduce a new color\n            use_new = random.random() < 0.25\n            k = max(sol)\n            u = random.randint(1, n)\n            cand = list(range(1, k + 2 if use_new else k + 1))\n            if sol[u - 1] in cand:\n                cand.remove(sol[u - 1])\n            neigh = {sol[w - 1] for w in adj[u]}\n            safe = [c for c in cand if c not in neigh]\n            sol[u - 1] = random.choice(safe if safe else cand or [sol[u - 1]])\n    sol = greedy_repair(sol, adj, max_steps=30)\n    sol = compress_labels(sol)\n    return sol\n","Resultados":[[1,2,3,3,2,4,4,3,1],4.0,[1,2,3,2,1,4,4,3,4],4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.002134507}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length 9. Values are positive integers representing colors. Labels must be contiguous 1..k with no gaps.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY_INVALID = 10**5\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 20000\n    if len(solution) != n:\n        return PENALTY_INVALID + 20000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 30000\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        gaps = abs(k - len(used))\n        return PENALTY_INVALID \/\/ 2 + 100 * gaps + k\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 100 * conflicts + k\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(sol):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def kempe_chain_swap(sol, start_v, a, b, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def try_reduce_k(sol, adj):\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # order by saturation then degree\n        def sat(u):\n            return len({sol[w - 1] for w in adj[u]})\n        verts.sort(key=lambda u: (-sat(u), -len(adj[u])))\n        for u in verts:\n            neigh_colors = {sol[w - 1] for w in adj[u]}\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        new_sol = compress_labels(sol)\n        return new_sol, True\n\n    adj = build_adj()\n\n    # Seed\/repair malformed inputs via greedy DSATUR-like coloring\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        colors = [0] * n\n        for u in order:\n            used = {colors[w - 1] for w in adj[u] if colors[w - 1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[u - 1] = c\n        colors = compress_labels(colors)\n        return (colors, \"init-repair\")\n\n    sol = list(solution)\n    sol = compress_labels(sol)\n\n    conf = conflicts_list(sol)\n    if conf:\n        degree_conf = {i: 0 for i in range(1, n + 1)}\n        for (u, v) in conf:\n            degree_conf[u] += 1\n            degree_conf[v] += 1\n        # DSATUR-guided target selection\n        def sat(u):\n            return len({sol[w - 1] for w in adj[u]})\n        target = max(range(1, n + 1), key=lambda u: (degree_conf[u], sat(u), len(adj[u])))\n        k = max(sol)\n        candidate_colors = [c for c in range(1, k + 1) if c != sol[target - 1]]\n        random.shuffle(candidate_colors)\n        best_c = sol[target - 1]\n        best_hits = 10**9\n        # tie-break by minimizing sum of degrees of neighbors with that color\n        for c in candidate_colors:\n            hits = 0\n            tie = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n                    tie += len(adj[w])\n            if (hits < best_hits) or (hits == best_hits and tie < 10**9):\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"recolor-conflict\")\n\n    # No conflicts: attempt reduce-k often\n    if random.random() < 0.8:\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification via Kempe swap along a random edge\n    u = random.randint(1, n)\n    if adj[u]:\n        v = random.choice(list(adj[u]))\n        c1, c2 = sol[u - 1], sol[v - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback: safe recolor within existing palette (no new colors)\n    u = random.randint(1, n)\n    k = max(sol)\n    cand = [c for c in range(1, k + 1) if c != sol[u - 1]] or [sol[u - 1]]\n    neigh_colors = {sol[w - 1] for w in adj[u]}\n    safe = [c for c in cand if c not in neigh_colors]\n    new_sol = sol[:]\n    new_sol[u - 1] = random.choice(safe if safe else cand)\n    new_sol = compress_labels(new_sol)\n    return (new_sol, \"random-recolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol, start_v, a, b, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def greedy_repair(sol, adj, max_steps=20):\n        sol = sol[:]\n        for _ in range(max_steps):\n            # find a conflict\n            bad = None\n            for (u, v) in edges:\n                if sol[u - 1] == sol[v - 1]:\n                    bad = u\n                    break\n            if bad is None:\n                break\n            k = max(sol)\n            neigh = {sol[w - 1] for w in adj[bad]}\n            cand = [c for c in range(1, k + 1) if c != sol[bad - 1]]\n            safe = [c for c in cand if c not in neigh]\n            sol[bad - 1] = safe[0] if safe else random.choice(cand or [sol[bad - 1]])\n        return sol\n\n    # Baseline repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = list(solution)\n\n    sol = compress_labels(sol)\n    adj = build_adj()\n\n    steps = random.randint(5, 9)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.35 and k > 1:\n            # Merge two color classes to force exploration\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            sol = greedy_repair(sol, adj, max_steps=10)\n        elif r < 0.75:\n            # Kempe chain along a random edge\/color pair\n            u = random.randint(1, n)\n            if adj[u]:\n                v = random.choice(list(adj[u]))\n                a, b = sol[u - 1], sol[v - 1]\n                sol = kempe_chain_swap(sol, u, a, b, adj)\n        else:\n            # Random recolor with small chance to introduce a new color\n            use_new = random.random() < 0.25\n            k = max(sol)\n            u = random.randint(1, n)\n            cand = list(range(1, k + 2 if use_new else k + 1))\n            if sol[u - 1] in cand:\n                cand.remove(sol[u - 1])\n            neigh = {sol[w - 1] for w in adj[u]}\n            safe = [c for c in cand if c not in neigh]\n            sol[u - 1] = random.choice(safe if safe else cand or [sol[u - 1]])\n    sol = greedy_repair(sol, adj, max_steps=30)\n    sol = compress_labels(sol)\n    return sol\n","Resultados":[[1,1,1,1,1,1,1,1,1],4.0,"[1,1,2,2,1,3,3,2,3]",4.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.004453946}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length 9. Values are positive integers representing colors. Labels must be contiguous 1..k with no gaps.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    PENALTY_INVALID = 10**5\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 20000\n    if len(solution) != n:\n        return PENALTY_INVALID + 20000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 30000\n    k = max(solution) if solution else 0\n    used = set(solution)\n    if used != set(range(1, k + 1)):\n        gaps = abs(k - len(used))\n        return PENALTY_INVALID \/\/ 2 + 100 * gaps + k\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_INVALID + 100 * conflicts + k\n    return float(k)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_list(sol):\n        conf = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.append((u, v))\n        return conf\n\n    def kempe_chain_swap(sol, start_v, a, b, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def try_reduce_k(sol, adj):\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        highest = k\n        verts = [i for i in range(1, n + 1) if sol[i - 1] == highest]\n        # order by saturation then degree\n        def sat(u):\n            return len({sol[w - 1] for w in adj[u]})\n        verts.sort(key=lambda u: (-sat(u), -len(adj[u])))\n        for u in verts:\n            neigh_colors = {sol[w - 1] for w in adj[u]}\n            placed = False\n            for c in range(1, highest):\n                if c not in neigh_colors:\n                    sol[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                return sol, False\n        new_sol = compress_labels(sol)\n        return new_sol, True\n\n    adj = build_adj()\n\n    # Seed\/repair malformed inputs via greedy DSATUR-like coloring\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        order = sorted(range(1, n + 1), key=lambda u: -len(adj[u]))\n        colors = [0] * n\n        for u in order:\n            used = {colors[w - 1] for w in adj[u] if colors[w - 1] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[u - 1] = c\n        colors = compress_labels(colors)\n        return (colors, \"init-repair\")\n\n    sol = list(solution)\n    sol = compress_labels(sol)\n\n    conf = conflicts_list(sol)\n    if conf:\n        degree_conf = {i: 0 for i in range(1, n + 1)}\n        for (u, v) in conf:\n            degree_conf[u] += 1\n            degree_conf[v] += 1\n        # DSATUR-guided target selection\n        def sat(u):\n            return len({sol[w - 1] for w in adj[u]})\n        target = max(range(1, n + 1), key=lambda u: (degree_conf[u], sat(u), len(adj[u])))\n        k = max(sol)\n        candidate_colors = [c for c in range(1, k + 1) if c != sol[target - 1]]\n        random.shuffle(candidate_colors)\n        best_c = sol[target - 1]\n        best_hits = 10**9\n        # tie-break by minimizing sum of degrees of neighbors with that color\n        for c in candidate_colors:\n            hits = 0\n            tie = 0\n            for w in adj[target]:\n                if sol[w - 1] == c:\n                    hits += 1\n                    tie += len(adj[w])\n            if (hits < best_hits) or (hits == best_hits and tie < 10**9):\n                best_hits = hits\n                best_c = c\n                if hits == 0:\n                    break\n        new_sol = sol[:]\n        new_sol[target - 1] = best_c\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"recolor-conflict\")\n\n    # No conflicts: attempt reduce-k often\n    if random.random() < 0.8:\n        reduced, ok = try_reduce_k(sol, adj)\n        if ok:\n            return (reduced, \"reduce-k\")\n\n    # Diversification via Kempe swap along a random edge\n    u = random.randint(1, n)\n    if adj[u]:\n        v = random.choice(list(adj[u]))\n        c1, c2 = sol[u - 1], sol[v - 1]\n        new_sol = kempe_chain_swap(sol, u, c1, c2, adj)\n        new_sol = compress_labels(new_sol)\n        return (new_sol, \"kempe-diversify\")\n\n    # Fallback: safe recolor within existing palette (no new colors)\n    u = random.randint(1, n)\n    k = max(sol)\n    cand = [c for c in range(1, k + 1) if c != sol[u - 1]] or [sol[u - 1]]\n    neigh_colors = {sol[w - 1] for w in adj[u]}\n    safe = [c for c in cand if c not in neigh_colors]\n    new_sol = sol[:]\n    new_sol[u - 1] = random.choice(safe if safe else cand)\n    new_sol = compress_labels(new_sol)\n    return (new_sol, \"random-recolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    def build_adj():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compress_labels(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(sol, start_v, a, b, adj):\n        if a == b or sol[start_v - 1] not in (a, b):\n            return sol\n        visited = set()\n        stack = [start_v]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if sol[u - 1] not in (a, b):\n                continue\n            visited.add(u)\n            for w in adj[u]:\n                if sol[w - 1] in (a, b) and w not in visited:\n                    stack.append(w)\n        if not visited:\n            return sol\n        new_sol = sol[:]\n        for u in visited:\n            if new_sol[u - 1] == a:\n                new_sol[u - 1] = b\n            elif new_sol[u - 1] == b:\n                new_sol[u - 1] = a\n        return new_sol\n\n    def greedy_repair(sol, adj, max_steps=20):\n        sol = sol[:]\n        for _ in range(max_steps):\n            # find a conflict\n            bad = None\n            for (u, v) in edges:\n                if sol[u - 1] == sol[v - 1]:\n                    bad = u\n                    break\n            if bad is None:\n                break\n            k = max(sol)\n            neigh = {sol[w - 1] for w in adj[bad]}\n            cand = [c for c in range(1, k + 1) if c != sol[bad - 1]]\n            safe = [c for c in cand if c not in neigh]\n            sol[bad - 1] = safe[0] if safe else random.choice(cand or [sol[bad - 1]])\n        return sol\n\n    # Baseline repair if malformed\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = list(solution)\n\n    sol = compress_labels(sol)\n    adj = build_adj()\n\n    steps = random.randint(5, 9)\n    for _ in range(steps):\n        k = max(sol)\n        r = random.random()\n        if r < 0.35 and k > 1:\n            # Merge two color classes to force exploration\n            c1, c2 = random.sample(range(1, k + 1), 2)\n            target = min(c1, c2)\n            source = max(c1, c2)\n            sol = [target if x == source else x for x in sol]\n            sol = greedy_repair(sol, adj, max_steps=10)\n        elif r < 0.75:\n            # Kempe chain along a random edge\/color pair\n            u = random.randint(1, n)\n            if adj[u]:\n                v = random.choice(list(adj[u]))\n                a, b = sol[u - 1], sol[v - 1]\n                sol = kempe_chain_swap(sol, u, a, b, adj)\n        else:\n            # Random recolor with small chance to introduce a new color\n            use_new = random.random() < 0.25\n            k = max(sol)\n            u = random.randint(1, n)\n            cand = list(range(1, k + 2 if use_new else k + 1))\n            if sol[u - 1] in cand:\n                cand.remove(sol[u - 1])\n            neigh = {sol[w - 1] for w in adj[u]}\n            safe = [c for c in cand if c not in neigh]\n            sol[u - 1] = random.choice(safe if safe else cand or [sol[u - 1]])\n    sol = greedy_repair(sol, adj, max_steps=30)\n    sol = compress_labels(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001699032}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST of length 9; position i (0-based) stores color (integer >=1) for vertex i+1. Colors need not be contiguous; objective K is max value in the list.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns numeric fitness (lower is better). Feasible solutions return number of colors used (max label).\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != 9:\n        return PENALTY_BASE * 50 + abs(len(solution) - 9)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n    # Conflict count\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # Feasible: objective is number of colors used (max label)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Neighbor generated by recoloring one random vertex to a possibly different color.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    n = 9\n    curr = list(solution)\n    idx = random.randrange(n)\n    # Allow colors in [1, max_color+1] to enable exploration\n    max_c = max(curr) if curr else 1\n    new_color = random.randint(1, max_c + 1)\n    # Ensure a change if possible\n    tries = 0\n    while new_color == curr[idx] and tries < 5:\n        new_color = random.randint(1, max_c + 1)\n        tries += 1\n    curr[idx] = new_color\n    return curr, \"Recolor\", \"RandomVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger random shake: recolor multiple random vertices and optionally remap labels.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    s = list(solution)\n    max_c = max(s) if s else 1\n    # Recolor m random vertices\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        s[i] = random.randint(1, max_c + 1)\n    # Optional relabel: compress labels to 1..k to reduce bloat\n    # Build mapping in order of first appearance\n    seen = {}\n    next_label = 1\n    for i in range(n):\n        c = s[i]\n        if c not in seen:\n            seen[c] = next_label\n            next_label += 1\n        s[i] = seen[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000547597}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST of length 9; position i (0-based) stores color (integer >=1) for vertex i+1. Colors need not be contiguous; objective K is max value in the list.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns numeric fitness (lower is better). Feasible solutions return number of colors used (max label).\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != 9:\n        return PENALTY_BASE * 50 + abs(len(solution) - 9)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n    # Conflict count\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # Feasible: objective is number of colors used (max label)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Neighbor generated by recoloring one random vertex to a possibly different color.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    n = 9\n    curr = list(solution)\n    idx = random.randrange(n)\n    # Allow colors in [1, max_color+1] to enable exploration\n    max_c = max(curr) if curr else 1\n    new_color = random.randint(1, max_c + 1)\n    # Ensure a change if possible\n    tries = 0\n    while new_color == curr[idx] and tries < 5:\n        new_color = random.randint(1, max_c + 1)\n        tries += 1\n    curr[idx] = new_color\n    return curr, \"Recolor\", \"RandomVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger random shake: recolor multiple random vertices and optionally remap labels.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    s = list(solution)\n    max_c = max(s) if s else 1\n    # Recolor m random vertices\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        s[i] = random.randint(1, max_c + 1)\n    # Optional relabel: compress labels to 1..k to reduce bloat\n    # Build mapping in order of first appearance\n    seen = {}\n    next_label = 1\n    for i in range(n):\n        c = s[i]\n        if c not in seen:\n            seen[c] = next_label\n            next_label += 1\n        s[i] = seen[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000464766}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST of length 9; position i (0-based) stores color (integer >=1) for vertex i+1. Colors need not be contiguous; objective K is max value in the list.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns numeric fitness (lower is better). Feasible solutions return number of colors used (max label).\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != 9:\n        return PENALTY_BASE * 50 + abs(len(solution) - 9)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n    # Conflict count\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + conflicts\n    # Feasible: objective is number of colors used (max label)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Neighbor generated by recoloring one random vertex to a possibly different color.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    n = 9\n    curr = list(solution)\n    idx = random.randrange(n)\n    # Allow colors in [1, max_color+1] to enable exploration\n    max_c = max(curr) if curr else 1\n    new_color = random.randint(1, max_c + 1)\n    # Ensure a change if possible\n    tries = 0\n    while new_color == curr[idx] and tries < 5:\n        new_color = random.randint(1, max_c + 1)\n        tries += 1\n    curr[idx] = new_color\n    return curr, \"Recolor\", \"RandomVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger random shake: recolor multiple random vertices and optionally remap labels.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    s = list(solution)\n    max_c = max(s) if s else 1\n    # Recolor m random vertices\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        s[i] = random.randint(1, max_c + 1)\n    # Optional relabel: compress labels to 1..k to reduce bloat\n    # Build mapping in order of first appearance\n    seen = {}\n    next_label = 1\n    for i in range(n):\n        c = s[i]\n        if c not in seen:\n            seen[c] = next_label\n            next_label += 1\n        s[i] = seen[c]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000437605}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST: length=9; position i (0-based) stores integer color (>=1) for vertex i+1. Colors need not be contiguous; objective minimizes K = max(solution).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns numeric fitness (lower is better). Any feasible coloring is always strictly better than any infeasible.\n    # Feasible: primary = K (number of colors), tie-breakers: fewer vertices in color K, then smaller sum of colors.\n    # Infeasible: large base + conflicts\/violations to guide repair.\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n    # Validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n    # Compute conflicts and violated vertices set\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        # Penalize conflicts with additional structure for search gradient\n        max_color = max(solution) if solution else 0\n        return INFEAS_BASE + conflicts * 10_000 + len(violated_vertices) * 100 + max_color\n    # Feasible: compute K and tie-breakers\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Count how many in highest color class\n    count_k = 0\n    ssum = 0\n    for x in solution:\n        ssum += x\n        if x == k:\n            count_k += 1\n    # Scale to ensure lexicographic ordering: K first, then count_k, then sum\n    return k * 10_000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators:\n      - ConflictDrivenRecolor: pick a conflicted vertex and recolor with biased choice among existing colors; repair then canonicalize.\n      - ColorSwap: swap labels of two randomly chosen existing color classes; canonicalize.\n      - KempeChainSwap: pick vertex and two colors, swap along its Kempe chain; repair then canonicalize.\n      - RandomRecolor (fallback): recolor a random vertex.\n    Always returns a valid-length list with colors >=1. Labels canonicalized to contiguous 1..K to reduce symmetry.\n    \"\"\"\n    # Internal graph and helpers (embedded; no globals)\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, list(conflict_vertices)\n\n    def feasible_color_for_vertex(sol: List[int], v_idx: int, max_allow: int) -> int:\n        # Smallest available color in 1..max_allow that doesn't conflict, else return current\n        used = set()\n        for (u,v) in E:\n            if u-1 == v_idx:\n                used.add(sol[v-1])\n            elif v-1 == v_idx:\n                used.add(sol[u-1])\n        for c in range(1, max_allow+1):\n            if c not in used:\n                return c\n        return sol[v_idx]\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        s = sol[:]\n        # Try to eliminate conflicts by recoloring conflicted vertices with smallest available color up to current max\n        max_c = max(s) if s else 1\n        changed = True\n        iters = 0\n        while changed and iters < N:\n            changed = False\n            iters += 1\n            _, conflicted = conflicts_of(s)\n            if not conflicted:\n                break\n            random.shuffle(conflicted)\n            for v in conflicted:\n                newc = feasible_color_for_vertex(s, v, max_c)\n                if newc != s[v]:\n                    s[v] = newc\n                    changed = True\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    # Choose operator with bias\n    r = random.random()\n    if r < 0.45:\n        # Conflict-driven recolor\n        _, conflicted = conflicts_of(curr)\n        if not conflicted:\n            idx = random.randrange(N)\n        else:\n            idx = random.choice(conflicted)\n        # Prefer existing colors, occasionally try K+1\n        try_new_color = random.random() < 0.1\n        candidate_colors = list(range(1, K + (1 if try_new_color else 0) + 1))\n        random.shuffle(candidate_colors)\n        new_color = curr[idx]\n        for c in candidate_colors:\n            if c != curr[idx]:\n                # check conflict locally\n                ok = True\n                for (u,v) in E:\n                    if u-1 == idx and c == curr[v-1]:\n                        ok = False; break\n                    if v-1 == idx and c == curr[u-1]:\n                        ok = False; break\n                if ok:\n                    new_color = c\n                    break\n        neigh = curr[:]\n        neigh[idx] = new_color\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Recolor\", \"ConflictDriven\")\n\n    elif r < 0.70:\n        # Color class swap\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            neigh = [ (c2 if c==c1 else (c1 if c==c2 else c)) for c in curr ]\n        else:\n            idx = random.randrange(N)\n            neigh = curr[:]\n            neigh[idx] = 1\n        neigh = canonicalize(neigh)\n        return (neigh, \"ColorSwap\", \"ClassSwap\")\n\n    else:\n        # Kempe chain swap between two colors starting at a random (conflicted if exists) vertex\n        _, conflicted = conflicts_of(curr)\n        start = random.choice(conflicted) if conflicted else random.randrange(N)\n        if K >= 2:\n            cA = curr[start]\n            # pick a different color (existing if possible)\n            palette = [c for c in range(1, K+1) if c != cA]\n            if not palette:\n                palette = [cA % K + 1]\n            cB = random.choice(palette)\n            # Build Kempe chain (BFS) in subgraph induced by colors {cA, cB}\n            adj = [[] for _ in range(N)]\n            for (u,v) in E:\n                u0, v0 = u-1, v-1\n                adj[u0].append(v0)\n                adj[v0].append(u0)\n            visited = [False]*N\n            stack = [start]\n            visited[start] = True\n            chain = []\n            while stack:\n                v = stack.pop()\n                if curr[v] in (cA, cB):\n                    chain.append(v)\n                    for w in adj[v]:\n                        if not visited[w] and curr[w] in (cA, cB):\n                            visited[w] = True\n                            stack.append(w)\n            neigh = curr[:]\n            for v in chain:\n                neigh[v] = cA if curr[v] == cB else (cB if curr[v] == cA else curr[v])\n        else:\n            neigh = curr[:]\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger shake to escape local minima:\n      1) Empty highest color class by attempting greedy reassignment into lower colors; if impossible, temporarily allow one new color then canonicalize.\n      2) Apply several random Kempe-chain swaps between random color pairs.\n      3) Multi-vertex recolor on a random subset with bias toward existing colors.\n    Always returns a valid-length list with colors >=1 and canonicalized labels.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def can_assign(sol: List[int], v_idx: int, color: int) -> bool:\n        for (u,v) in E:\n            if u-1 == v_idx and sol[v-1] == color:\n                return False\n            if v-1 == v_idx and sol[u-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        adj = [[] for _ in range(N)]\n        for (u,v) in E:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        visited = [False]*N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Try to empty highest color class\n    highest = K\n    idxs_high = [i for i,c in enumerate(s) if c == highest]\n    if idxs_high:\n        for v in idxs_high:\n            placed = False\n            for c in range(1, highest):\n                if can_assign(s, v, c):\n                    s[v] = c\n                    placed = True\n                    break\n            if not placed:\n                # allow temporary spill to highest or new color (rare)\n                alt = random.randint(1, max(highest, 1))\n                s[v] = alt\n    s = canonicalize(s)\n\n    # 2) Apply several Kempe-chain swaps\n    K = max(s) if s else 1\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if K >= 2:\n            v = random.randrange(N)\n            cA = s[v]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if not palette:\n                continue\n            cB = random.choice(palette)\n            s = kempe_swap(s, v, cA, cB)\n            s = canonicalize(s)\n\n    # 3) Multi-vertex biased recolor\n    m = random.randint(2, 4)\n    K = max(s) if s else 1\n    for v in random.sample(range(N), m):\n        # Prefer existing colors; with small probability try K+1\n        palette = list(range(1, K+1))\n        if random.random() < 0.1:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == s[v]:\n                continue\n            if c <= K and can_assign(s, v, c):\n                s[v] = c\n                break\n            if c == K+1:\n                s[v] = c\n                break\n    s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001383957}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST: length=9; position i (0-based) stores integer color (>=1) for vertex i+1. Colors need not be contiguous; objective minimizes K = max(solution).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns numeric fitness (lower is better). Any feasible coloring is always strictly better than any infeasible.\n    # Feasible: primary = K (number of colors), tie-breakers: fewer vertices in color K, then smaller sum of colors.\n    # Infeasible: large base + conflicts\/violations to guide repair.\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n    # Validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n    # Compute conflicts and violated vertices set\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        # Penalize conflicts with additional structure for search gradient\n        max_color = max(solution) if solution else 0\n        return INFEAS_BASE + conflicts * 10_000 + len(violated_vertices) * 100 + max_color\n    # Feasible: compute K and tie-breakers\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Count how many in highest color class\n    count_k = 0\n    ssum = 0\n    for x in solution:\n        ssum += x\n        if x == k:\n            count_k += 1\n    # Scale to ensure lexicographic ordering: K first, then count_k, then sum\n    return k * 10_000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators:\n      - ConflictDrivenRecolor: pick a conflicted vertex and recolor with biased choice among existing colors; repair then canonicalize.\n      - ColorSwap: swap labels of two randomly chosen existing color classes; canonicalize.\n      - KempeChainSwap: pick vertex and two colors, swap along its Kempe chain; repair then canonicalize.\n      - RandomRecolor (fallback): recolor a random vertex.\n    Always returns a valid-length list with colors >=1. Labels canonicalized to contiguous 1..K to reduce symmetry.\n    \"\"\"\n    # Internal graph and helpers (embedded; no globals)\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, list(conflict_vertices)\n\n    def feasible_color_for_vertex(sol: List[int], v_idx: int, max_allow: int) -> int:\n        # Smallest available color in 1..max_allow that doesn't conflict, else return current\n        used = set()\n        for (u,v) in E:\n            if u-1 == v_idx:\n                used.add(sol[v-1])\n            elif v-1 == v_idx:\n                used.add(sol[u-1])\n        for c in range(1, max_allow+1):\n            if c not in used:\n                return c\n        return sol[v_idx]\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        s = sol[:]\n        # Try to eliminate conflicts by recoloring conflicted vertices with smallest available color up to current max\n        max_c = max(s) if s else 1\n        changed = True\n        iters = 0\n        while changed and iters < N:\n            changed = False\n            iters += 1\n            _, conflicted = conflicts_of(s)\n            if not conflicted:\n                break\n            random.shuffle(conflicted)\n            for v in conflicted:\n                newc = feasible_color_for_vertex(s, v, max_c)\n                if newc != s[v]:\n                    s[v] = newc\n                    changed = True\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    # Choose operator with bias\n    r = random.random()\n    if r < 0.45:\n        # Conflict-driven recolor\n        _, conflicted = conflicts_of(curr)\n        if not conflicted:\n            idx = random.randrange(N)\n        else:\n            idx = random.choice(conflicted)\n        # Prefer existing colors, occasionally try K+1\n        try_new_color = random.random() < 0.1\n        candidate_colors = list(range(1, K + (1 if try_new_color else 0) + 1))\n        random.shuffle(candidate_colors)\n        new_color = curr[idx]\n        for c in candidate_colors:\n            if c != curr[idx]:\n                # check conflict locally\n                ok = True\n                for (u,v) in E:\n                    if u-1 == idx and c == curr[v-1]:\n                        ok = False; break\n                    if v-1 == idx and c == curr[u-1]:\n                        ok = False; break\n                if ok:\n                    new_color = c\n                    break\n        neigh = curr[:]\n        neigh[idx] = new_color\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Recolor\", \"ConflictDriven\")\n\n    elif r < 0.70:\n        # Color class swap\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            neigh = [ (c2 if c==c1 else (c1 if c==c2 else c)) for c in curr ]\n        else:\n            idx = random.randrange(N)\n            neigh = curr[:]\n            neigh[idx] = 1\n        neigh = canonicalize(neigh)\n        return (neigh, \"ColorSwap\", \"ClassSwap\")\n\n    else:\n        # Kempe chain swap between two colors starting at a random (conflicted if exists) vertex\n        _, conflicted = conflicts_of(curr)\n        start = random.choice(conflicted) if conflicted else random.randrange(N)\n        if K >= 2:\n            cA = curr[start]\n            # pick a different color (existing if possible)\n            palette = [c for c in range(1, K+1) if c != cA]\n            if not palette:\n                palette = [cA % K + 1]\n            cB = random.choice(palette)\n            # Build Kempe chain (BFS) in subgraph induced by colors {cA, cB}\n            adj = [[] for _ in range(N)]\n            for (u,v) in E:\n                u0, v0 = u-1, v-1\n                adj[u0].append(v0)\n                adj[v0].append(u0)\n            visited = [False]*N\n            stack = [start]\n            visited[start] = True\n            chain = []\n            while stack:\n                v = stack.pop()\n                if curr[v] in (cA, cB):\n                    chain.append(v)\n                    for w in adj[v]:\n                        if not visited[w] and curr[w] in (cA, cB):\n                            visited[w] = True\n                            stack.append(w)\n            neigh = curr[:]\n            for v in chain:\n                neigh[v] = cA if curr[v] == cB else (cB if curr[v] == cA else curr[v])\n        else:\n            neigh = curr[:]\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger shake to escape local minima:\n      1) Empty highest color class by attempting greedy reassignment into lower colors; if impossible, temporarily allow one new color then canonicalize.\n      2) Apply several random Kempe-chain swaps between random color pairs.\n      3) Multi-vertex recolor on a random subset with bias toward existing colors.\n    Always returns a valid-length list with colors >=1 and canonicalized labels.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def can_assign(sol: List[int], v_idx: int, color: int) -> bool:\n        for (u,v) in E:\n            if u-1 == v_idx and sol[v-1] == color:\n                return False\n            if v-1 == v_idx and sol[u-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        adj = [[] for _ in range(N)]\n        for (u,v) in E:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        visited = [False]*N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Try to empty highest color class\n    highest = K\n    idxs_high = [i for i,c in enumerate(s) if c == highest]\n    if idxs_high:\n        for v in idxs_high:\n            placed = False\n            for c in range(1, highest):\n                if can_assign(s, v, c):\n                    s[v] = c\n                    placed = True\n                    break\n            if not placed:\n                # allow temporary spill to highest or new color (rare)\n                alt = random.randint(1, max(highest, 1))\n                s[v] = alt\n    s = canonicalize(s)\n\n    # 2) Apply several Kempe-chain swaps\n    K = max(s) if s else 1\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if K >= 2:\n            v = random.randrange(N)\n            cA = s[v]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if not palette:\n                continue\n            cB = random.choice(palette)\n            s = kempe_swap(s, v, cA, cB)\n            s = canonicalize(s)\n\n    # 3) Multi-vertex biased recolor\n    m = random.randint(2, 4)\n    K = max(s) if s else 1\n    for v in random.sample(range(N), m):\n        # Prefer existing colors; with small probability try K+1\n        palette = list(range(1, K+1))\n        if random.random() < 0.1:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == s[v]:\n                continue\n            if c <= K and can_assign(s, v, c):\n                s[v] = c\n                break\n            if c == K+1:\n                s[v] = c\n                break\n    s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00156635}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST: length=9; position i (0-based) stores integer color (>=1) for vertex i+1. Colors need not be contiguous; objective minimizes K = max(solution).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Returns numeric fitness (lower is better). Any feasible coloring is always strictly better than any infeasible.\n    # Feasible: primary = K (number of colors), tie-breakers: fewer vertices in color K, then smaller sum of colors.\n    # Infeasible: large base + conflicts\/violations to guide repair.\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n    # Validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n    # Compute conflicts and violated vertices set\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        # Penalize conflicts with additional structure for search gradient\n        max_color = max(solution) if solution else 0\n        return INFEAS_BASE + conflicts * 10_000 + len(violated_vertices) * 100 + max_color\n    # Feasible: compute K and tie-breakers\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Count how many in highest color class\n    count_k = 0\n    ssum = 0\n    for x in solution:\n        ssum += x\n        if x == k:\n            count_k += 1\n    # Scale to ensure lexicographic ordering: K first, then count_k, then sum\n    return k * 10_000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators:\n      - ConflictDrivenRecolor: pick a conflicted vertex and recolor with biased choice among existing colors; repair then canonicalize.\n      - ColorSwap: swap labels of two randomly chosen existing color classes; canonicalize.\n      - KempeChainSwap: pick vertex and two colors, swap along its Kempe chain; repair then canonicalize.\n      - RandomRecolor (fallback): recolor a random vertex.\n    Always returns a valid-length list with colors >=1. Labels canonicalized to contiguous 1..K to reduce symmetry.\n    \"\"\"\n    # Internal graph and helpers (embedded; no globals)\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, list(conflict_vertices)\n\n    def feasible_color_for_vertex(sol: List[int], v_idx: int, max_allow: int) -> int:\n        # Smallest available color in 1..max_allow that doesn't conflict, else return current\n        used = set()\n        for (u,v) in E:\n            if u-1 == v_idx:\n                used.add(sol[v-1])\n            elif v-1 == v_idx:\n                used.add(sol[u-1])\n        for c in range(1, max_allow+1):\n            if c not in used:\n                return c\n        return sol[v_idx]\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        s = sol[:]\n        # Try to eliminate conflicts by recoloring conflicted vertices with smallest available color up to current max\n        max_c = max(s) if s else 1\n        changed = True\n        iters = 0\n        while changed and iters < N:\n            changed = False\n            iters += 1\n            _, conflicted = conflicts_of(s)\n            if not conflicted:\n                break\n            random.shuffle(conflicted)\n            for v in conflicted:\n                newc = feasible_color_for_vertex(s, v, max_c)\n                if newc != s[v]:\n                    s[v] = newc\n                    changed = True\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    # Choose operator with bias\n    r = random.random()\n    if r < 0.45:\n        # Conflict-driven recolor\n        _, conflicted = conflicts_of(curr)\n        if not conflicted:\n            idx = random.randrange(N)\n        else:\n            idx = random.choice(conflicted)\n        # Prefer existing colors, occasionally try K+1\n        try_new_color = random.random() < 0.1\n        candidate_colors = list(range(1, K + (1 if try_new_color else 0) + 1))\n        random.shuffle(candidate_colors)\n        new_color = curr[idx]\n        for c in candidate_colors:\n            if c != curr[idx]:\n                # check conflict locally\n                ok = True\n                for (u,v) in E:\n                    if u-1 == idx and c == curr[v-1]:\n                        ok = False; break\n                    if v-1 == idx and c == curr[u-1]:\n                        ok = False; break\n                if ok:\n                    new_color = c\n                    break\n        neigh = curr[:]\n        neigh[idx] = new_color\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Recolor\", \"ConflictDriven\")\n\n    elif r < 0.70:\n        # Color class swap\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            neigh = [ (c2 if c==c1 else (c1 if c==c2 else c)) for c in curr ]\n        else:\n            idx = random.randrange(N)\n            neigh = curr[:]\n            neigh[idx] = 1\n        neigh = canonicalize(neigh)\n        return (neigh, \"ColorSwap\", \"ClassSwap\")\n\n    else:\n        # Kempe chain swap between two colors starting at a random (conflicted if exists) vertex\n        _, conflicted = conflicts_of(curr)\n        start = random.choice(conflicted) if conflicted else random.randrange(N)\n        if K >= 2:\n            cA = curr[start]\n            # pick a different color (existing if possible)\n            palette = [c for c in range(1, K+1) if c != cA]\n            if not palette:\n                palette = [cA % K + 1]\n            cB = random.choice(palette)\n            # Build Kempe chain (BFS) in subgraph induced by colors {cA, cB}\n            adj = [[] for _ in range(N)]\n            for (u,v) in E:\n                u0, v0 = u-1, v-1\n                adj[u0].append(v0)\n                adj[v0].append(u0)\n            visited = [False]*N\n            stack = [start]\n            visited[start] = True\n            chain = []\n            while stack:\n                v = stack.pop()\n                if curr[v] in (cA, cB):\n                    chain.append(v)\n                    for w in adj[v]:\n                        if not visited[w] and curr[w] in (cA, cB):\n                            visited[w] = True\n                            stack.append(w)\n            neigh = curr[:]\n            for v in chain:\n                neigh[v] = cA if curr[v] == cB else (cB if curr[v] == cA else curr[v])\n        else:\n            neigh = curr[:]\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger shake to escape local minima:\n      1) Empty highest color class by attempting greedy reassignment into lower colors; if impossible, temporarily allow one new color then canonicalize.\n      2) Apply several random Kempe-chain swaps between random color pairs.\n      3) Multi-vertex recolor on a random subset with bias toward existing colors.\n    Always returns a valid-length list with colors >=1 and canonicalized labels.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def can_assign(sol: List[int], v_idx: int, color: int) -> bool:\n        for (u,v) in E:\n            if u-1 == v_idx and sol[v-1] == color:\n                return False\n            if v-1 == v_idx and sol[u-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        adj = [[] for _ in range(N)]\n        for (u,v) in E:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        visited = [False]*N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Try to empty highest color class\n    highest = K\n    idxs_high = [i for i,c in enumerate(s) if c == highest]\n    if idxs_high:\n        for v in idxs_high:\n            placed = False\n            for c in range(1, highest):\n                if can_assign(s, v, c):\n                    s[v] = c\n                    placed = True\n                    break\n            if not placed:\n                # allow temporary spill to highest or new color (rare)\n                alt = random.randint(1, max(highest, 1))\n                s[v] = alt\n    s = canonicalize(s)\n\n    # 2) Apply several Kempe-chain swaps\n    K = max(s) if s else 1\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if K >= 2:\n            v = random.randrange(N)\n            cA = s[v]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if not palette:\n                continue\n            cB = random.choice(palette)\n            s = kempe_swap(s, v, cA, cB)\n            s = canonicalize(s)\n\n    # 3) Multi-vertex biased recolor\n    m = random.randint(2, 4)\n    K = max(s) if s else 1\n    for v in random.sample(range(N), m):\n        # Prefer existing colors; with small probability try K+1\n        palette = list(range(1, K+1))\n        if random.random() < 0.1:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == s[v]:\n                continue\n            if c <= K and can_assign(s, v, c):\n                s[v] = c\n                break\n            if c == K+1:\n                s[v] = c\n                break\n    s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001558999}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST: length=9; index i (0-based) stores integer color (>=1) for vertex i+1. Colors need not be contiguous; objective K = max(solution).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    \"\"\"\n    Returns numeric fitness (lower is better). Any feasible coloring is strictly better than any infeasible.\n    Feasible: primary = K (number of colors), tie-breakers: fewer vertices in color K, then smaller sum of colors.\n    Infeasible: large base + conflicts\/violations to guide repair.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n    # Validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n    # Compute conflicts and violated vertices set\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        # Penalize conflicts with additional structure for search gradient\n        max_color = max(solution) if solution else 0\n        return INFEAS_BASE + conflicts * 10_000 + len(violated_vertices) * 100 + max_color\n    # Feasible: compute K and tie-breakers\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Count how many in highest color class\n    count_k = 0\n    ssum = 0\n    for x in solution:\n        ssum += x\n        if x == k:\n            count_k += 1\n    # Scale to ensure lexicographic ordering: K first, then count_k, then sum\n    return k * 10_000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators:\n      - ConflictDrivenRecolor: pick a conflicted vertex and recolor with biased choice among existing colors; repair then canonicalize.\n      - ColorSwap: swap labels of two randomly chosen existing color classes; canonicalize.\n      - KempeChainSwap: pick vertex and two colors, swap along its Kempe chain; repair then canonicalize.\n      - RandomRecolor (fallback inside recolor path).\n    Always returns a valid-length list with colors >=1. Labels canonicalized to contiguous 1..K to reduce symmetry.\n    \"\"\"\n    # Internal graph and helpers (embedded; no globals)\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, list(conflict_vertices)\n\n    def feasible_color_for_vertex(sol: List[int], v_idx: int, max_allow: int) -> int:\n        used = set()\n        for (u,v) in E:\n            if u-1 == v_idx:\n                used.add(sol[v-1])\n            elif v-1 == v_idx:\n                used.add(sol[u-1])\n        for c in range(1, max_allow+1):\n            if c not in used:\n                return c\n        return sol[v_idx]\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        s = sol[:]\n        max_c = max(s) if s else 1\n        changed = True\n        iters = 0\n        while changed and iters < N:\n            changed = False\n            iters += 1\n            _, conflicted = conflicts_of(s)\n            if not conflicted:\n                break\n            random.shuffle(conflicted)\n            for v in conflicted:\n                newc = feasible_color_for_vertex(s, v, max_c + 1)  # allow temporary K+1 to escape\n                if newc != s[v]:\n                    s[v] = newc\n                    changed = True\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    # Choose operator with bias\n    r = random.random()\n    if r < 0.50:\n        # Conflict-driven recolor\n        _, conflicted = conflicts_of(curr)\n        if not conflicted:\n            # target vertex from highest color class to encourage K reduction\n            maxc = K\n            candidates = [i for i,c in enumerate(curr) if c == maxc]\n            idx = random.choice(candidates) if candidates else random.randrange(N)\n        else:\n            idx = random.choice(conflicted)\n        try_new_color = random.random() < 0.15\n        candidate_colors = list(range(1, K + (1 if try_new_color else 0) + 1))\n        random.shuffle(candidate_colors)\n        new_color = curr[idx]\n        for c in candidate_colors:\n            if c == curr[idx]:\n                continue\n            ok = True\n            for (u,v) in E:\n                if (u-1 == idx and c == curr[v-1]) or (v-1 == idx and c == curr[u-1]):\n                    ok = False\n                    break\n            if ok:\n                new_color = c\n                break\n        neigh = curr[:]\n        neigh[idx] = new_color\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Recolor\", \"ConflictDriven\")\n\n    elif r < 0.75:\n        # Color class swap with acceptance guard (avoid pure relabels that change nothing meaningful)\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            neigh = [(c2 if c==c1 else (c1 if c==c2 else c)) for c in curr]\n            if neigh == curr:\n                # force a change by recoloring a random vertex to c1\n                idx = random.randrange(N)\n                neigh[idx] = c1 if curr[idx] != c1 else c2\n        else:\n            idx = random.randrange(N)\n            neigh = curr[:]\n            neigh[idx] = 1\n        neigh = canonicalize(neigh)\n        return (neigh, \"ColorSwap\", \"ClassSwap\")\n\n    else:\n        # Kempe chain swap prioritized to include max color when possible\n        start_candidates = [i for i,c in enumerate(curr) if c == K]\n        start = random.choice(start_candidates) if start_candidates else random.randrange(N)\n        if K >= 2:\n            cA = curr[start]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if K >= 2 and cA != K and K in palette:\n                # target max color to drive reduction\n                cB = K\n            else:\n                cB = random.choice(palette) if palette else cA\n            # Build adjacency\n            adj = [[] for _ in range(N)]\n            for (u,v) in E:\n                u0, v0 = u-1, v-1\n                adj[u0].append(v0)\n                adj[v0].append(u0)\n            visited = [False]*N\n            stack = [start]\n            visited[start] = True\n            chain = []\n            while stack:\n                v = stack.pop()\n                if curr[v] in (cA, cB):\n                    chain.append(v)\n                    for w in adj[v]:\n                        if not visited[w] and curr[w] in (cA, cB):\n                            visited[w] = True\n                            stack.append(w)\n            neigh = curr[:]\n            for v in chain:\n                neigh[v] = cA if curr[v] == cB else (cB if curr[v] == cA else curr[v])\n        else:\n            neigh = curr[:]\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger shake to escape local minima:\n      1) Empty highest color class by attempting greedy reassignment into lower colors; allow temporary K+1 during reassignment; canonicalize.\n      2) Apply several random Kempe-chain swaps between random color pairs with a bias to include max color.\n      3) Multi-vertex biased recolor on a random subset with preference to existing lower colors; canonicalize.\n    Always returns a valid-length list with colors >=1 and canonicalized labels.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def can_assign(sol: List[int], v_idx: int, color: int) -> bool:\n        for (u,v) in E:\n            if u-1 == v_idx and sol[v-1] == color:\n                return False\n            if v-1 == v_idx and sol[u-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        adj = [[] for _ in range(N)]\n        for (u,v) in E:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        visited = [False]*N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Try to empty highest color class with temporary allowance of K+1\n    highest = K\n    idxs_high = [i for i,c in enumerate(s) if c == highest]\n    for v in idxs_high:\n        placed = False\n        for c in range(1, highest):\n            if can_assign(s, v, c):\n                s[v] = c\n                placed = True\n                break\n        if not placed:\n            # temporary spill to any color including K+1 to break stalemate\n            alt_palette = list(range(1, highest+2))\n            random.shuffle(alt_palette)\n            for alt in alt_palette:\n                if alt == s[v]:\n                    continue\n                if alt <= highest and can_assign(s, v, alt):\n                    s[v] = alt\n                    placed = True\n                    break\n                if alt == highest+1:\n                    s[v] = alt\n                    placed = True\n                    break\n    s = canonicalize(s)\n\n    # 2) Apply several Kempe-chain swaps with bias to involve max color\n    K = max(s) if s else 1\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        if K >= 2:\n            v = random.randrange(N)\n            cA = s[v]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if K in palette and random.random() < 0.7:\n                cB = K\n            else:\n                cB = random.choice(palette)\n            s = kempe_swap(s, v, cA, cB)\n            s = canonicalize(s)\n\n    # 3) Multi-vertex biased recolor focusing on current max class\n    m = random.randint(3, 5)\n    K = max(s) if s else 1\n    targets = [i for i,c in enumerate(s) if c == K]\n    others = [i for i in range(N) if i not in targets]\n    pick_from = targets + random.sample(others, k=min(len(others), max(0, m - len(targets))))\n    for v in pick_from:\n        palette = list(range(1, K+1))\n        if random.random() < 0.2:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == s[v]:\n                continue\n            if c <= K and can_assign(s, v, c):\n                s[v] = c\n                break\n            if c == K+1:\n                s[v] = c\n                break\n    s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001373828}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST: length=9; index i (0-based) stores integer color (>=1) for vertex i+1. Colors need not be contiguous; objective K = max(solution).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    \"\"\"\n    Returns numeric fitness (lower is better). Any feasible coloring is strictly better than any infeasible.\n    Feasible: primary = K (number of colors), tie-breakers: fewer vertices in color K, then smaller sum of colors.\n    Infeasible: large base + conflicts\/violations to guide repair.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n    # Validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n    # Compute conflicts and violated vertices set\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        # Penalize conflicts with additional structure for search gradient\n        max_color = max(solution) if solution else 0\n        return INFEAS_BASE + conflicts * 10_000 + len(violated_vertices) * 100 + max_color\n    # Feasible: compute K and tie-breakers\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Count how many in highest color class\n    count_k = 0\n    ssum = 0\n    for x in solution:\n        ssum += x\n        if x == k:\n            count_k += 1\n    # Scale to ensure lexicographic ordering: K first, then count_k, then sum\n    return k * 10_000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators:\n      - ConflictDrivenRecolor: pick a conflicted vertex and recolor with biased choice among existing colors; repair then canonicalize.\n      - ColorSwap: swap labels of two randomly chosen existing color classes; canonicalize.\n      - KempeChainSwap: pick vertex and two colors, swap along its Kempe chain; repair then canonicalize.\n      - RandomRecolor (fallback inside recolor path).\n    Always returns a valid-length list with colors >=1. Labels canonicalized to contiguous 1..K to reduce symmetry.\n    \"\"\"\n    # Internal graph and helpers (embedded; no globals)\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, list(conflict_vertices)\n\n    def feasible_color_for_vertex(sol: List[int], v_idx: int, max_allow: int) -> int:\n        used = set()\n        for (u,v) in E:\n            if u-1 == v_idx:\n                used.add(sol[v-1])\n            elif v-1 == v_idx:\n                used.add(sol[u-1])\n        for c in range(1, max_allow+1):\n            if c not in used:\n                return c\n        return sol[v_idx]\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        s = sol[:]\n        max_c = max(s) if s else 1\n        changed = True\n        iters = 0\n        while changed and iters < N:\n            changed = False\n            iters += 1\n            _, conflicted = conflicts_of(s)\n            if not conflicted:\n                break\n            random.shuffle(conflicted)\n            for v in conflicted:\n                newc = feasible_color_for_vertex(s, v, max_c + 1)  # allow temporary K+1 to escape\n                if newc != s[v]:\n                    s[v] = newc\n                    changed = True\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    # Choose operator with bias\n    r = random.random()\n    if r < 0.50:\n        # Conflict-driven recolor\n        _, conflicted = conflicts_of(curr)\n        if not conflicted:\n            # target vertex from highest color class to encourage K reduction\n            maxc = K\n            candidates = [i for i,c in enumerate(curr) if c == maxc]\n            idx = random.choice(candidates) if candidates else random.randrange(N)\n        else:\n            idx = random.choice(conflicted)\n        try_new_color = random.random() < 0.15\n        candidate_colors = list(range(1, K + (1 if try_new_color else 0) + 1))\n        random.shuffle(candidate_colors)\n        new_color = curr[idx]\n        for c in candidate_colors:\n            if c == curr[idx]:\n                continue\n            ok = True\n            for (u,v) in E:\n                if (u-1 == idx and c == curr[v-1]) or (v-1 == idx and c == curr[u-1]):\n                    ok = False\n                    break\n            if ok:\n                new_color = c\n                break\n        neigh = curr[:]\n        neigh[idx] = new_color\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Recolor\", \"ConflictDriven\")\n\n    elif r < 0.75:\n        # Color class swap with acceptance guard (avoid pure relabels that change nothing meaningful)\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            neigh = [(c2 if c==c1 else (c1 if c==c2 else c)) for c in curr]\n            if neigh == curr:\n                # force a change by recoloring a random vertex to c1\n                idx = random.randrange(N)\n                neigh[idx] = c1 if curr[idx] != c1 else c2\n        else:\n            idx = random.randrange(N)\n            neigh = curr[:]\n            neigh[idx] = 1\n        neigh = canonicalize(neigh)\n        return (neigh, \"ColorSwap\", \"ClassSwap\")\n\n    else:\n        # Kempe chain swap prioritized to include max color when possible\n        start_candidates = [i for i,c in enumerate(curr) if c == K]\n        start = random.choice(start_candidates) if start_candidates else random.randrange(N)\n        if K >= 2:\n            cA = curr[start]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if K >= 2 and cA != K and K in palette:\n                # target max color to drive reduction\n                cB = K\n            else:\n                cB = random.choice(palette) if palette else cA\n            # Build adjacency\n            adj = [[] for _ in range(N)]\n            for (u,v) in E:\n                u0, v0 = u-1, v-1\n                adj[u0].append(v0)\n                adj[v0].append(u0)\n            visited = [False]*N\n            stack = [start]\n            visited[start] = True\n            chain = []\n            while stack:\n                v = stack.pop()\n                if curr[v] in (cA, cB):\n                    chain.append(v)\n                    for w in adj[v]:\n                        if not visited[w] and curr[w] in (cA, cB):\n                            visited[w] = True\n                            stack.append(w)\n            neigh = curr[:]\n            for v in chain:\n                neigh[v] = cA if curr[v] == cB else (cB if curr[v] == cA else curr[v])\n        else:\n            neigh = curr[:]\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger shake to escape local minima:\n      1) Empty highest color class by attempting greedy reassignment into lower colors; allow temporary K+1 during reassignment; canonicalize.\n      2) Apply several random Kempe-chain swaps between random color pairs with a bias to include max color.\n      3) Multi-vertex biased recolor on a random subset with preference to existing lower colors; canonicalize.\n    Always returns a valid-length list with colors >=1 and canonicalized labels.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def can_assign(sol: List[int], v_idx: int, color: int) -> bool:\n        for (u,v) in E:\n            if u-1 == v_idx and sol[v-1] == color:\n                return False\n            if v-1 == v_idx and sol[u-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        adj = [[] for _ in range(N)]\n        for (u,v) in E:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        visited = [False]*N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Try to empty highest color class with temporary allowance of K+1\n    highest = K\n    idxs_high = [i for i,c in enumerate(s) if c == highest]\n    for v in idxs_high:\n        placed = False\n        for c in range(1, highest):\n            if can_assign(s, v, c):\n                s[v] = c\n                placed = True\n                break\n        if not placed:\n            # temporary spill to any color including K+1 to break stalemate\n            alt_palette = list(range(1, highest+2))\n            random.shuffle(alt_palette)\n            for alt in alt_palette:\n                if alt == s[v]:\n                    continue\n                if alt <= highest and can_assign(s, v, alt):\n                    s[v] = alt\n                    placed = True\n                    break\n                if alt == highest+1:\n                    s[v] = alt\n                    placed = True\n                    break\n    s = canonicalize(s)\n\n    # 2) Apply several Kempe-chain swaps with bias to involve max color\n    K = max(s) if s else 1\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        if K >= 2:\n            v = random.randrange(N)\n            cA = s[v]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if K in palette and random.random() < 0.7:\n                cB = K\n            else:\n                cB = random.choice(palette)\n            s = kempe_swap(s, v, cA, cB)\n            s = canonicalize(s)\n\n    # 3) Multi-vertex biased recolor focusing on current max class\n    m = random.randint(3, 5)\n    K = max(s) if s else 1\n    targets = [i for i,c in enumerate(s) if c == K]\n    others = [i for i in range(N) if i not in targets]\n    pick_from = targets + random.sample(others, k=min(len(others), max(0, m - len(targets))))\n    for v in pick_from:\n        palette = list(range(1, K+1))\n        if random.random() < 0.2:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == s[v]:\n                continue\n            if c <= K and can_assign(s, v, c):\n                s[v] = c\n                break\n            if c == K+1:\n                s[v] = c\n                break\n    s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001759791}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST: length=9; index i (0-based) stores integer color (>=1) for vertex i+1. Colors need not be contiguous; objective K = max(solution).","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    \"\"\"\n    Returns numeric fitness (lower is better). Any feasible coloring is strictly better than any infeasible.\n    Feasible: primary = K (number of colors), tie-breakers: fewer vertices in color K, then smaller sum of colors.\n    Infeasible: large base + conflicts\/violations to guide repair.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n    # Validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n    # Compute conflicts and violated vertices set\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        # Penalize conflicts with additional structure for search gradient\n        max_color = max(solution) if solution else 0\n        return INFEAS_BASE + conflicts * 10_000 + len(violated_vertices) * 100 + max_color\n    # Feasible: compute K and tie-breakers\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Count how many in highest color class\n    count_k = 0\n    ssum = 0\n    for x in solution:\n        ssum += x\n        if x == k:\n            count_k += 1\n    # Scale to ensure lexicographic ordering: K first, then count_k, then sum\n    return k * 10_000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators:\n      - ConflictDrivenRecolor: pick a conflicted vertex and recolor with biased choice among existing colors; repair then canonicalize.\n      - ColorSwap: swap labels of two randomly chosen existing color classes; canonicalize.\n      - KempeChainSwap: pick vertex and two colors, swap along its Kempe chain; repair then canonicalize.\n      - RandomRecolor (fallback inside recolor path).\n    Always returns a valid-length list with colors >=1. Labels canonicalized to contiguous 1..K to reduce symmetry.\n    \"\"\"\n    # Internal graph and helpers (embedded; no globals)\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u,v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, list(conflict_vertices)\n\n    def feasible_color_for_vertex(sol: List[int], v_idx: int, max_allow: int) -> int:\n        used = set()\n        for (u,v) in E:\n            if u-1 == v_idx:\n                used.add(sol[v-1])\n            elif v-1 == v_idx:\n                used.add(sol[u-1])\n        for c in range(1, max_allow+1):\n            if c not in used:\n                return c\n        return sol[v_idx]\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        s = sol[:]\n        max_c = max(s) if s else 1\n        changed = True\n        iters = 0\n        while changed and iters < N:\n            changed = False\n            iters += 1\n            _, conflicted = conflicts_of(s)\n            if not conflicted:\n                break\n            random.shuffle(conflicted)\n            for v in conflicted:\n                newc = feasible_color_for_vertex(s, v, max_c + 1)  # allow temporary K+1 to escape\n                if newc != s[v]:\n                    s[v] = newc\n                    changed = True\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    # Choose operator with bias\n    r = random.random()\n    if r < 0.50:\n        # Conflict-driven recolor\n        _, conflicted = conflicts_of(curr)\n        if not conflicted:\n            # target vertex from highest color class to encourage K reduction\n            maxc = K\n            candidates = [i for i,c in enumerate(curr) if c == maxc]\n            idx = random.choice(candidates) if candidates else random.randrange(N)\n        else:\n            idx = random.choice(conflicted)\n        try_new_color = random.random() < 0.15\n        candidate_colors = list(range(1, K + (1 if try_new_color else 0) + 1))\n        random.shuffle(candidate_colors)\n        new_color = curr[idx]\n        for c in candidate_colors:\n            if c == curr[idx]:\n                continue\n            ok = True\n            for (u,v) in E:\n                if (u-1 == idx and c == curr[v-1]) or (v-1 == idx and c == curr[u-1]):\n                    ok = False\n                    break\n            if ok:\n                new_color = c\n                break\n        neigh = curr[:]\n        neigh[idx] = new_color\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Recolor\", \"ConflictDriven\")\n\n    elif r < 0.75:\n        # Color class swap with acceptance guard (avoid pure relabels that change nothing meaningful)\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            neigh = [(c2 if c==c1 else (c1 if c==c2 else c)) for c in curr]\n            if neigh == curr:\n                # force a change by recoloring a random vertex to c1\n                idx = random.randrange(N)\n                neigh[idx] = c1 if curr[idx] != c1 else c2\n        else:\n            idx = random.randrange(N)\n            neigh = curr[:]\n            neigh[idx] = 1\n        neigh = canonicalize(neigh)\n        return (neigh, \"ColorSwap\", \"ClassSwap\")\n\n    else:\n        # Kempe chain swap prioritized to include max color when possible\n        start_candidates = [i for i,c in enumerate(curr) if c == K]\n        start = random.choice(start_candidates) if start_candidates else random.randrange(N)\n        if K >= 2:\n            cA = curr[start]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if K >= 2 and cA != K and K in palette:\n                # target max color to drive reduction\n                cB = K\n            else:\n                cB = random.choice(palette) if palette else cA\n            # Build adjacency\n            adj = [[] for _ in range(N)]\n            for (u,v) in E:\n                u0, v0 = u-1, v-1\n                adj[u0].append(v0)\n                adj[v0].append(u0)\n            visited = [False]*N\n            stack = [start]\n            visited[start] = True\n            chain = []\n            while stack:\n                v = stack.pop()\n                if curr[v] in (cA, cB):\n                    chain.append(v)\n                    for w in adj[v]:\n                        if not visited[w] and curr[w] in (cA, cB):\n                            visited[w] = True\n                            stack.append(w)\n            neigh = curr[:]\n            for v in chain:\n                neigh[v] = cA if curr[v] == cB else (cB if curr[v] == cA else curr[v])\n        else:\n            neigh = curr[:]\n        neigh = greedy_repair(neigh)\n        neigh = canonicalize(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Stronger shake to escape local minima:\n      1) Empty highest color class by attempting greedy reassignment into lower colors; allow temporary K+1 during reassignment; canonicalize.\n      2) Apply several random Kempe-chain swaps between random color pairs with a bias to include max color.\n      3) Multi-vertex biased recolor on a random subset with preference to existing lower colors; canonicalize.\n    Always returns a valid-length list with colors >=1 and canonicalized labels.\n    \"\"\"\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_lbl = 1\n        out = []\n        for c in labels:\n            if c not in mapping:\n                mapping[c] = next_lbl\n                next_lbl += 1\n            out.append(mapping[c])\n        return out\n\n    def can_assign(sol: List[int], v_idx: int, color: int) -> bool:\n        for (u,v) in E:\n            if u-1 == v_idx and sol[v-1] == color:\n                return False\n            if v-1 == v_idx and sol[u-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        adj = [[] for _ in range(N)]\n        for (u,v) in E:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        visited = [False]*N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Try to empty highest color class with temporary allowance of K+1\n    highest = K\n    idxs_high = [i for i,c in enumerate(s) if c == highest]\n    for v in idxs_high:\n        placed = False\n        for c in range(1, highest):\n            if can_assign(s, v, c):\n                s[v] = c\n                placed = True\n                break\n        if not placed:\n            # temporary spill to any color including K+1 to break stalemate\n            alt_palette = list(range(1, highest+2))\n            random.shuffle(alt_palette)\n            for alt in alt_palette:\n                if alt == s[v]:\n                    continue\n                if alt <= highest and can_assign(s, v, alt):\n                    s[v] = alt\n                    placed = True\n                    break\n                if alt == highest+1:\n                    s[v] = alt\n                    placed = True\n                    break\n    s = canonicalize(s)\n\n    # 2) Apply several Kempe-chain swaps with bias to involve max color\n    K = max(s) if s else 1\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        if K >= 2:\n            v = random.randrange(N)\n            cA = s[v]\n            palette = [c for c in range(1, K+1) if c != cA]\n            if K in palette and random.random() < 0.7:\n                cB = K\n            else:\n                cB = random.choice(palette)\n            s = kempe_swap(s, v, cA, cB)\n            s = canonicalize(s)\n\n    # 3) Multi-vertex biased recolor focusing on current max class\n    m = random.randint(3, 5)\n    K = max(s) if s else 1\n    targets = [i for i,c in enumerate(s) if c == K]\n    others = [i for i in range(N) if i not in targets]\n    pick_from = targets + random.sample(others, k=min(len(others), max(0, m - len(targets))))\n    for v in pick_from:\n        palette = list(range(1, K+1))\n        if random.random() < 0.2:\n            palette.append(K+1)\n        random.shuffle(palette)\n        for c in palette:\n            if c == s[v]:\n                continue\n            if c <= K and can_assign(s, v, c):\n                s[v] = c\n                break\n            if c == K+1:\n                s[v] = c\n                break\n    s = canonicalize(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001901884}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    \"\"\"\n    Fitness: lower is better. Any feasible coloring is strictly better than any infeasible.\n    Feasible ordering (lexicographic):\n      1) K = max color (minimize)\n      2) count of vertices using color K (minimize)\n      3) sum of colors after deterministic canonicalization (minimize)\n    Infeasible penalty: large base + conflicts and violated vertices to guide repair.\n    A deterministic canonicalization is applied to stabilize evaluation against label permutations:\n      - Sort color classes by decreasing size, then by smallest vertex index in class; map to 1..K.\n    \"\"\"\n    # Embedded problem data\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n\n    # Deterministic canonicalization\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        # group vertices by color\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        # sort colors by (-size, min_index)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    lab = canonicalize_stable(solution)\n\n    # Count conflicts\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if lab[u-1] == lab[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        max_color = max(lab) if lab else 0\n        return INFEAS_BASE + conflicts * 10000 + len(violated_vertices) * 100 + max_color\n\n    # Feasible metrics\n    k = 0\n    for x in lab:\n        if x > k:\n            k = x\n    count_k = 0\n    ssum = 0\n    for x in lab:\n        ssum += x\n        if x == k:\n            count_k += 1\n    return k * 10000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators (randomly selected):\n      - Recolor.DSATURConflict: pick a high-saturation conflicted vertex (or a vertex in max color if none) and recolor feasibly, preferring lower colors.\n      - Kempe.ChainSwap: perform a Kempe chain swap between two colors (biased to include max color) from a random start.\n      - Exchange.Balanced: pick two color classes and swap one vertex each if both assignments remain feasible (structural, not mere relabel).\n      - MaxClass.Shrink: attempt to move a subset of vertices from the highest color class into lower colors greedily.\n    Always returns a list of length 9 with colors >= 1, followed by type labels.\n    \"\"\"\n    # Embedded problem\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    # Build adjacency once\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, sorted(list(conflict_vertices))\n\n    def can_assign(sol: List[int], v: int, color: int) -> bool:\n        for w in adj[v]:\n            if sol[w] == color:\n                return False\n        return True\n\n    def saturation_degree(sol: List[int], v: int) -> int:\n        seen = set()\n        for w in adj[v]:\n            seen.add(sol[w])\n        return len(seen)\n\n    def dsatur_order(conflicted: List[int]) -> List[int]:\n        return sorted(conflicted, key=lambda v: (-saturation_degree(curr, v), -len(adj[v]), v))\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        visited = [False] * N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    def shrink_max_class(sol: List[int]) -> List[int]:\n        s = sol[:]\n        K = max(s) if s else 1\n        targets = [i for i, c in enumerate(s) if c == K]\n        random.shuffle(targets)\n        for v in targets:\n            # try assign to the smallest feasible color < K\n            for c in range(1, K):\n                if can_assign(s, v, c):\n                    s[v] = c\n                    break\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    op_r = random.random()\n\n    if op_r < 0.4:\n        # Recolor with DSATUR bias\n        conf_cnt, conflicted = conflicts_of(curr)\n        if conflicted:\n            ordered = dsatur_order(conflicted)\n            v = ordered[0]\n        else:\n            # pick from max color class to drive K reduction\n            max_class = [i for i, c in enumerate(curr) if c == K]\n            v = random.choice(max_class) if max_class else random.randrange(N)\n        # Prefer lower colors first; allow trying K+1 only if no feasible in [1..K]\n        palette = list(range(1, K)) + ([K] if curr[v] != K else [])\n        newc = curr[v]\n        for c in palette:\n            if c != curr[v] and can_assign(curr, v, c):\n                newc = c\n                break\n        # fallback: explore a different color including K (not K+1 here to avoid inflation)\n        if newc == curr[v]:\n            alt = [c for c in range(1, K+1) if c != curr[v]]\n            random.shuffle(alt)\n            for c in alt:\n                if can_assign(curr, v, c):\n                    newc = c\n                    break\n        neigh = curr[:]\n        neigh[v] = newc\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Recolor\", \"DSATURConflict\")\n\n    elif op_r < 0.7:\n        # Kempe chain swap biased to include max color\n        start = random.randrange(N)\n        cA = curr[start]\n        palette = [c for c in range(1, K+1) if c != cA]\n        if palette:\n            if K in palette and random.random() < 0.7:\n                cB = K\n            else:\n                cB = random.choice(palette)\n            neigh = kempe_swap(curr, start, cA, cB)\n        else:\n            neigh = curr[:]\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n\n    elif op_r < 0.9:\n        # Balanced exchange between two classes (structural)\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            C1 = [i for i, c in enumerate(curr) if c == c1]\n            C2 = [i for i, c in enumerate(curr) if c == c2]\n            if C1 and C2:\n                v1 = random.choice(C1)\n                v2 = random.choice(C2)\n                neigh = curr[:]\n                if can_assign(neigh, v1, c2) and can_assign(neigh, v2, c1):\n                    neigh[v1], neigh[v2] = c2, c1\n                else:\n                    # try one-sided feasible move\n                    if can_assign(neigh, v1, c2):\n                        neigh[v1] = c2\n                    elif can_assign(neigh, v2, c1):\n                        neigh[v2] = c1\n                    # else keep as is\n            else:\n                neigh = curr[:]\n        else:\n            neigh = curr[:]\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Exchange\", \"BalancedSwap\")\n\n    else:\n        # Max class shrink\n        neigh = shrink_max_class(curr)\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"MaxClass\", \"Shrink\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation to escape local minima:\n      1) Greedy attempt to empty the highest color class by reassigning its vertices into lower colors.\n      2) Apply several Kempe chain swaps, biased to involve the current maximum color.\n      3) Multi-vertex recolor on a random subset, favoring lower colors.\n    Returns a canonicalized solution of length 9 with colors >= 1.\n    \"\"\"\n    # Embedded problem\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    def can_assign(sol: List[int], v: int, color: int) -> bool:\n        for w in adj[v]:\n            if sol[w] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        visited = [False] * N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Empty or shrink highest color class\n    highest = K\n    highs = [i for i, c in enumerate(s) if c == highest]\n    random.shuffle(highs)\n    for v in highs:\n        placed = False\n        for c in range(1, highest):\n            if can_assign(s, v, c):\n                s[v] = c\n                placed = True\n                break\n        if not placed:\n            # try any other existing color first (avoid creating K+1 here)\n            palette = [c for c in range(1, highest+1) if c != s[v]]\n            random.shuffle(palette)\n            for c in palette:\n                if can_assign(s, v, c):\n                    s[v] = c\n                    placed = True\n                    break\n    s = canonicalize_stable(s)\n\n    # 2) Several Kempe swaps\n    K = max(s) if s else 1\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        v = random.randrange(N)\n        cA = s[v]\n        palette = [c for c in range(1, K+1) if c != cA]\n        if not palette:\n            continue\n        if K in palette and random.random() < 0.7:\n            cB = K\n        else:\n            cB = random.choice(palette)\n        s = kempe_swap(s, v, cA, cB)\n        s = canonicalize_stable(s)\n\n    # 3) Multi-vertex recolor on subset\n    K = max(s) if s else 1\n    m = random.randint(3, 5)\n    targets = [i for i, c in enumerate(s) if c == K]\n    others = [i for i in range(N) if i not in targets]\n    sample_others = random.sample(others, k=min(len(others), max(0, m - len(targets)))) if others else []\n    pick = targets + sample_others\n    random.shuffle(pick)\n    for v in pick:\n        palette = list(range(1, K+1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != s[v] and can_assign(s, v, c):\n                s[v] = c\n                break\n    s = canonicalize_stable(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001473478}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    \"\"\"\n    Fitness: lower is better. Any feasible coloring is strictly better than any infeasible.\n    Feasible ordering (lexicographic):\n      1) K = max color (minimize)\n      2) count of vertices using color K (minimize)\n      3) sum of colors after deterministic canonicalization (minimize)\n    Infeasible penalty: large base + conflicts and violated vertices to guide repair.\n    A deterministic canonicalization is applied to stabilize evaluation against label permutations:\n      - Sort color classes by decreasing size, then by smallest vertex index in class; map to 1..K.\n    \"\"\"\n    # Embedded problem data\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n\n    # Deterministic canonicalization\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        # group vertices by color\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        # sort colors by (-size, min_index)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    lab = canonicalize_stable(solution)\n\n    # Count conflicts\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if lab[u-1] == lab[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        max_color = max(lab) if lab else 0\n        return INFEAS_BASE + conflicts * 10000 + len(violated_vertices) * 100 + max_color\n\n    # Feasible metrics\n    k = 0\n    for x in lab:\n        if x > k:\n            k = x\n    count_k = 0\n    ssum = 0\n    for x in lab:\n        ssum += x\n        if x == k:\n            count_k += 1\n    return k * 10000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators (randomly selected):\n      - Recolor.DSATURConflict: pick a high-saturation conflicted vertex (or a vertex in max color if none) and recolor feasibly, preferring lower colors.\n      - Kempe.ChainSwap: perform a Kempe chain swap between two colors (biased to include max color) from a random start.\n      - Exchange.Balanced: pick two color classes and swap one vertex each if both assignments remain feasible (structural, not mere relabel).\n      - MaxClass.Shrink: attempt to move a subset of vertices from the highest color class into lower colors greedily.\n    Always returns a list of length 9 with colors >= 1, followed by type labels.\n    \"\"\"\n    # Embedded problem\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    # Build adjacency once\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, sorted(list(conflict_vertices))\n\n    def can_assign(sol: List[int], v: int, color: int) -> bool:\n        for w in adj[v]:\n            if sol[w] == color:\n                return False\n        return True\n\n    def saturation_degree(sol: List[int], v: int) -> int:\n        seen = set()\n        for w in adj[v]:\n            seen.add(sol[w])\n        return len(seen)\n\n    def dsatur_order(conflicted: List[int]) -> List[int]:\n        return sorted(conflicted, key=lambda v: (-saturation_degree(curr, v), -len(adj[v]), v))\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        visited = [False] * N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    def shrink_max_class(sol: List[int]) -> List[int]:\n        s = sol[:]\n        K = max(s) if s else 1\n        targets = [i for i, c in enumerate(s) if c == K]\n        random.shuffle(targets)\n        for v in targets:\n            # try assign to the smallest feasible color < K\n            for c in range(1, K):\n                if can_assign(s, v, c):\n                    s[v] = c\n                    break\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    op_r = random.random()\n\n    if op_r < 0.4:\n        # Recolor with DSATUR bias\n        conf_cnt, conflicted = conflicts_of(curr)\n        if conflicted:\n            ordered = dsatur_order(conflicted)\n            v = ordered[0]\n        else:\n            # pick from max color class to drive K reduction\n            max_class = [i for i, c in enumerate(curr) if c == K]\n            v = random.choice(max_class) if max_class else random.randrange(N)\n        # Prefer lower colors first; allow trying K+1 only if no feasible in [1..K]\n        palette = list(range(1, K)) + ([K] if curr[v] != K else [])\n        newc = curr[v]\n        for c in palette:\n            if c != curr[v] and can_assign(curr, v, c):\n                newc = c\n                break\n        # fallback: explore a different color including K (not K+1 here to avoid inflation)\n        if newc == curr[v]:\n            alt = [c for c in range(1, K+1) if c != curr[v]]\n            random.shuffle(alt)\n            for c in alt:\n                if can_assign(curr, v, c):\n                    newc = c\n                    break\n        neigh = curr[:]\n        neigh[v] = newc\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Recolor\", \"DSATURConflict\")\n\n    elif op_r < 0.7:\n        # Kempe chain swap biased to include max color\n        start = random.randrange(N)\n        cA = curr[start]\n        palette = [c for c in range(1, K+1) if c != cA]\n        if palette:\n            if K in palette and random.random() < 0.7:\n                cB = K\n            else:\n                cB = random.choice(palette)\n            neigh = kempe_swap(curr, start, cA, cB)\n        else:\n            neigh = curr[:]\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n\n    elif op_r < 0.9:\n        # Balanced exchange between two classes (structural)\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            C1 = [i for i, c in enumerate(curr) if c == c1]\n            C2 = [i for i, c in enumerate(curr) if c == c2]\n            if C1 and C2:\n                v1 = random.choice(C1)\n                v2 = random.choice(C2)\n                neigh = curr[:]\n                if can_assign(neigh, v1, c2) and can_assign(neigh, v2, c1):\n                    neigh[v1], neigh[v2] = c2, c1\n                else:\n                    # try one-sided feasible move\n                    if can_assign(neigh, v1, c2):\n                        neigh[v1] = c2\n                    elif can_assign(neigh, v2, c1):\n                        neigh[v2] = c1\n                    # else keep as is\n            else:\n                neigh = curr[:]\n        else:\n            neigh = curr[:]\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Exchange\", \"BalancedSwap\")\n\n    else:\n        # Max class shrink\n        neigh = shrink_max_class(curr)\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"MaxClass\", \"Shrink\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation to escape local minima:\n      1) Greedy attempt to empty the highest color class by reassigning its vertices into lower colors.\n      2) Apply several Kempe chain swaps, biased to involve the current maximum color.\n      3) Multi-vertex recolor on a random subset, favoring lower colors.\n    Returns a canonicalized solution of length 9 with colors >= 1.\n    \"\"\"\n    # Embedded problem\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    def can_assign(sol: List[int], v: int, color: int) -> bool:\n        for w in adj[v]:\n            if sol[w] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        visited = [False] * N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Empty or shrink highest color class\n    highest = K\n    highs = [i for i, c in enumerate(s) if c == highest]\n    random.shuffle(highs)\n    for v in highs:\n        placed = False\n        for c in range(1, highest):\n            if can_assign(s, v, c):\n                s[v] = c\n                placed = True\n                break\n        if not placed:\n            # try any other existing color first (avoid creating K+1 here)\n            palette = [c for c in range(1, highest+1) if c != s[v]]\n            random.shuffle(palette)\n            for c in palette:\n                if can_assign(s, v, c):\n                    s[v] = c\n                    placed = True\n                    break\n    s = canonicalize_stable(s)\n\n    # 2) Several Kempe swaps\n    K = max(s) if s else 1\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        v = random.randrange(N)\n        cA = s[v]\n        palette = [c for c in range(1, K+1) if c != cA]\n        if not palette:\n            continue\n        if K in palette and random.random() < 0.7:\n            cB = K\n        else:\n            cB = random.choice(palette)\n        s = kempe_swap(s, v, cA, cB)\n        s = canonicalize_stable(s)\n\n    # 3) Multi-vertex recolor on subset\n    K = max(s) if s else 1\n    m = random.randint(3, 5)\n    targets = [i for i, c in enumerate(s) if c == K]\n    others = [i for i in range(N) if i not in targets]\n    sample_others = random.sample(others, k=min(len(others), max(0, m - len(targets)))) if others else []\n    pick = targets + sample_others\n    random.shuffle(pick)\n    for v in pick:\n        palette = list(range(1, K+1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != s[v] and can_assign(s, v, c):\n                s[v] = c\n                break\n    s = canonicalize_stable(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001885753}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    \"\"\"\n    Fitness: lower is better. Any feasible coloring is strictly better than any infeasible.\n    Feasible ordering (lexicographic):\n      1) K = max color (minimize)\n      2) count of vertices using color K (minimize)\n      3) sum of colors after deterministic canonicalization (minimize)\n    Infeasible penalty: large base + conflicts and violated vertices to guide repair.\n    A deterministic canonicalization is applied to stabilize evaluation against label permutations:\n      - Sort color classes by decreasing size, then by smallest vertex index in class; map to 1..K.\n    \"\"\"\n    # Embedded problem data\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n    INFEAS_BASE = 10**9\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return INFEAS_BASE + 10**6\n    if len(solution) != N:\n        return INFEAS_BASE + 10**6 + abs(len(solution) - N)\n    for x in solution:\n        if not isinstance(x, int):\n            return INFEAS_BASE + 10**6 + 1\n        if x < 1:\n            return INFEAS_BASE + 10**6 + 2\n\n    # Deterministic canonicalization\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        # group vertices by color\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        # sort colors by (-size, min_index)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    lab = canonicalize_stable(solution)\n\n    # Count conflicts\n    conflicts = 0\n    violated_vertices = set()\n    for (u, v) in E:\n        if lab[u-1] == lab[v-1]:\n            conflicts += 1\n            violated_vertices.add(u-1)\n            violated_vertices.add(v-1)\n    if conflicts > 0:\n        max_color = max(lab) if lab else 0\n        return INFEAS_BASE + conflicts * 10000 + len(violated_vertices) * 100 + max_color\n\n    # Feasible metrics\n    k = 0\n    for x in lab:\n        if x > k:\n            k = x\n    count_k = 0\n    ssum = 0\n    for x in lab:\n        ssum += x\n        if x == k:\n            count_k += 1\n    return k * 10000 + count_k * 100 + ssum\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    \"\"\"\n    Returns (neighbor_solution, NB_Type, Movement_Type)\n    Operators (randomly selected):\n      - Recolor.DSATURConflict: pick a high-saturation conflicted vertex (or a vertex in max color if none) and recolor feasibly, preferring lower colors.\n      - Kempe.ChainSwap: perform a Kempe chain swap between two colors (biased to include max color) from a random start.\n      - Exchange.Balanced: pick two color classes and swap one vertex each if both assignments remain feasible (structural, not mere relabel).\n      - MaxClass.Shrink: attempt to move a subset of vertices from the highest color class into lower colors greedily.\n    Always returns a list of length 9 with colors >= 1, followed by type labels.\n    \"\"\"\n    # Embedded problem\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    # Build adjacency once\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    def conflicts_of(sol: List[int]) -> Tuple[int, List[int]]:\n        conflict_vertices = set()\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n                conflict_vertices.add(u-1)\n                conflict_vertices.add(v-1)\n        return cnt, sorted(list(conflict_vertices))\n\n    def can_assign(sol: List[int], v: int, color: int) -> bool:\n        for w in adj[v]:\n            if sol[w] == color:\n                return False\n        return True\n\n    def saturation_degree(sol: List[int], v: int) -> int:\n        seen = set()\n        for w in adj[v]:\n            seen.add(sol[w])\n        return len(seen)\n\n    def dsatur_order(conflicted: List[int]) -> List[int]:\n        return sorted(conflicted, key=lambda v: (-saturation_degree(curr, v), -len(adj[v]), v))\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        visited = [False] * N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    def shrink_max_class(sol: List[int]) -> List[int]:\n        s = sol[:]\n        K = max(s) if s else 1\n        targets = [i for i, c in enumerate(s) if c == K]\n        random.shuffle(targets)\n        for v in targets:\n            # try assign to the smallest feasible color < K\n            for c in range(1, K):\n                if can_assign(s, v, c):\n                    s[v] = c\n                    break\n        return s\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return (solution, \"Invalid\", \"NoOp\")\n\n    curr = list(solution)\n    K = max(curr) if curr else 1\n\n    op_r = random.random()\n\n    if op_r < 0.4:\n        # Recolor with DSATUR bias\n        conf_cnt, conflicted = conflicts_of(curr)\n        if conflicted:\n            ordered = dsatur_order(conflicted)\n            v = ordered[0]\n        else:\n            # pick from max color class to drive K reduction\n            max_class = [i for i, c in enumerate(curr) if c == K]\n            v = random.choice(max_class) if max_class else random.randrange(N)\n        # Prefer lower colors first; allow trying K+1 only if no feasible in [1..K]\n        palette = list(range(1, K)) + ([K] if curr[v] != K else [])\n        newc = curr[v]\n        for c in palette:\n            if c != curr[v] and can_assign(curr, v, c):\n                newc = c\n                break\n        # fallback: explore a different color including K (not K+1 here to avoid inflation)\n        if newc == curr[v]:\n            alt = [c for c in range(1, K+1) if c != curr[v]]\n            random.shuffle(alt)\n            for c in alt:\n                if can_assign(curr, v, c):\n                    newc = c\n                    break\n        neigh = curr[:]\n        neigh[v] = newc\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Recolor\", \"DSATURConflict\")\n\n    elif op_r < 0.7:\n        # Kempe chain swap biased to include max color\n        start = random.randrange(N)\n        cA = curr[start]\n        palette = [c for c in range(1, K+1) if c != cA]\n        if palette:\n            if K in palette and random.random() < 0.7:\n                cB = K\n            else:\n                cB = random.choice(palette)\n            neigh = kempe_swap(curr, start, cA, cB)\n        else:\n            neigh = curr[:]\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Kempe\", \"ChainSwap\")\n\n    elif op_r < 0.9:\n        # Balanced exchange between two classes (structural)\n        if K >= 2:\n            c1, c2 = random.sample(range(1, K+1), 2)\n            C1 = [i for i, c in enumerate(curr) if c == c1]\n            C2 = [i for i, c in enumerate(curr) if c == c2]\n            if C1 and C2:\n                v1 = random.choice(C1)\n                v2 = random.choice(C2)\n                neigh = curr[:]\n                if can_assign(neigh, v1, c2) and can_assign(neigh, v2, c1):\n                    neigh[v1], neigh[v2] = c2, c1\n                else:\n                    # try one-sided feasible move\n                    if can_assign(neigh, v1, c2):\n                        neigh[v1] = c2\n                    elif can_assign(neigh, v2, c1):\n                        neigh[v2] = c1\n                    # else keep as is\n            else:\n                neigh = curr[:]\n        else:\n            neigh = curr[:]\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"Exchange\", \"BalancedSwap\")\n\n    else:\n        # Max class shrink\n        neigh = shrink_max_class(curr)\n        neigh = canonicalize_stable(neigh)\n        return (neigh, \"MaxClass\", \"Shrink\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    \"\"\"\n    Strong perturbation to escape local minima:\n      1) Greedy attempt to empty the highest color class by reassigning its vertices into lower colors.\n      2) Apply several Kempe chain swaps, biased to involve the current maximum color.\n      3) Multi-vertex recolor on a random subset, favoring lower colors.\n    Returns a canonicalized solution of length 9 with colors >= 1.\n    \"\"\"\n    # Embedded problem\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    N = 9\n\n    adj = [[] for _ in range(N)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def canonicalize_stable(labels: List[int]) -> List[int]:\n        groups = {}\n        for i, c in enumerate(labels):\n            groups.setdefault(c, []).append(i)\n        order = sorted(groups.keys(), key=lambda c: (-len(groups[c]), min(groups[c])))\n        mapping = {c: i+1 for i, c in enumerate(order)}\n        return [mapping[c] for c in labels]\n\n    def can_assign(sol: List[int], v: int, color: int) -> bool:\n        for w in adj[v]:\n            if sol[w] == color:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start: int, cA: int, cB: int) -> List[int]:\n        visited = [False] * N\n        stack = [start]\n        visited[start] = True\n        chain = []\n        while stack:\n            v = stack.pop()\n            if sol[v] in (cA, cB):\n                chain.append(v)\n                for w in adj[v]:\n                    if not visited[w] and sol[w] in (cA, cB):\n                        visited[w] = True\n                        stack.append(w)\n        out = sol[:]\n        for v in chain:\n            out[v] = cA if sol[v] == cB else (cB if sol[v] == cA else sol[v])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n\n    s = list(solution)\n    K = max(s) if s else 1\n\n    # 1) Empty or shrink highest color class\n    highest = K\n    highs = [i for i, c in enumerate(s) if c == highest]\n    random.shuffle(highs)\n    for v in highs:\n        placed = False\n        for c in range(1, highest):\n            if can_assign(s, v, c):\n                s[v] = c\n                placed = True\n                break\n        if not placed:\n            # try any other existing color first (avoid creating K+1 here)\n            palette = [c for c in range(1, highest+1) if c != s[v]]\n            random.shuffle(palette)\n            for c in palette:\n                if can_assign(s, v, c):\n                    s[v] = c\n                    placed = True\n                    break\n    s = canonicalize_stable(s)\n\n    # 2) Several Kempe swaps\n    K = max(s) if s else 1\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        v = random.randrange(N)\n        cA = s[v]\n        palette = [c for c in range(1, K+1) if c != cA]\n        if not palette:\n            continue\n        if K in palette and random.random() < 0.7:\n            cB = K\n        else:\n            cB = random.choice(palette)\n        s = kempe_swap(s, v, cA, cB)\n        s = canonicalize_stable(s)\n\n    # 3) Multi-vertex recolor on subset\n    K = max(s) if s else 1\n    m = random.randint(3, 5)\n    targets = [i for i, c in enumerate(s) if c == K]\n    others = [i for i in range(N) if i not in targets]\n    sample_others = random.sample(others, k=min(len(others), max(0, m - len(targets)))) if others else []\n    pick = targets + sample_others\n    random.shuffle(pick)\n    for v in pick:\n        palette = list(range(1, K+1))\n        random.shuffle(palette)\n        for c in palette:\n            if c != s[v] and can_assign(s, v, c):\n                s[v] = c\n                break\n    s = canonicalize_stable(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001775542}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST. A Python list of length 9 where position i-1 holds the color (positive int starting at 1) assigned to vertex i. Example: [1,1,2,2,1,3,3,2,3].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place local recolor of a single vertex respecting constraints as much as possible.\n    # Returns metadata (NB_Type, Movement_Type) as required.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return (\"local\", \"invalid-input\")\n    # Ensure all entries are positive ints; if not, initialize to 1\n    for i in range(n):\n        if not isinstance(solution[i], int) or solution[i] < 1:\n            solution[i] = 1\n    # Pick a random vertex to recolor\n    v = random.randrange(1, n+1)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u == v:\n            forbidden.add(solution[w-1])\n        elif w == v:\n            forbidden.add(solution[u-1])\n    current_max = max(solution) if solution else 1\n    # Candidate colors prefer existing palette to reduce color count\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if candidates:\n        # Heuristic: choose the smallest feasible color\n        new_color = min(candidates)\n    else:\n        # If no feasible within current palette, introduce a new color\n        new_color = current_max + 1\n    solution[v-1] = new_color\n    return (\"local\", \"recolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger move: multiple vertex recolors with greedy feasibility restoration.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Start from a safe copy and sanitize entries\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a simple feasible seed using a greedy pass\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Decide number of vertices to perturb\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    # First, randomize chosen vertices within current palette +\/- 1\n    base_max = max(sol) if sol else 1\n    for v in chosen:\n        sol[v-1] = random.randint(1, base_max + 1)\n    # Then, perform a greedy feasibility repair pass over all vertices\n    def neighbors_colors(v, arr):\n        cols = set()\n        for (u, w) in E:\n            if u == v:\n                cols.add(arr[w-1])\n            elif w == v:\n                cols.add(arr[u-1])\n        return cols\n    for v in range(1, n+1):\n        forb = neighbors_colors(v, sol)\n        if sol[v-1] in forb:\n            # Assign smallest feasible color; if none in current palette, open a new color\n            current_max = max(sol)\n            candidates = [c for c in range(1, current_max + 1) if c not in forb]\n            sol[v-1] = min(candidates) if candidates else (current_max + 1)\n    # Optional compression: relabel colors to 1..m without gaps for compactness\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":["[1,1,2,2,1,3,3,2,3]",null,"[1,1,2,2,1,3,3,2,3]",null],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000484146}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST. A Python list of length 9 where position i-1 holds the color (positive int starting at 1) assigned to vertex i. Example: [1,1,2,2,1,3,3,2,3].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place local recolor of a single vertex respecting constraints as much as possible.\n    # Returns metadata (NB_Type, Movement_Type) as required.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return (\"local\", \"invalid-input\")\n    # Ensure all entries are positive ints; if not, initialize to 1\n    for i in range(n):\n        if not isinstance(solution[i], int) or solution[i] < 1:\n            solution[i] = 1\n    # Pick a random vertex to recolor\n    v = random.randrange(1, n+1)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u == v:\n            forbidden.add(solution[w-1])\n        elif w == v:\n            forbidden.add(solution[u-1])\n    current_max = max(solution) if solution else 1\n    # Candidate colors prefer existing palette to reduce color count\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if candidates:\n        # Heuristic: choose the smallest feasible color\n        new_color = min(candidates)\n    else:\n        # If no feasible within current palette, introduce a new color\n        new_color = current_max + 1\n    solution[v-1] = new_color\n    return (\"local\", \"recolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger move: multiple vertex recolors with greedy feasibility restoration.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Start from a safe copy and sanitize entries\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a simple feasible seed using a greedy pass\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Decide number of vertices to perturb\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    # First, randomize chosen vertices within current palette +\/- 1\n    base_max = max(sol) if sol else 1\n    for v in chosen:\n        sol[v-1] = random.randint(1, base_max + 1)\n    # Then, perform a greedy feasibility repair pass over all vertices\n    def neighbors_colors(v, arr):\n        cols = set()\n        for (u, w) in E:\n            if u == v:\n                cols.add(arr[w-1])\n            elif w == v:\n                cols.add(arr[u-1])\n        return cols\n    for v in range(1, n+1):\n        forb = neighbors_colors(v, sol)\n        if sol[v-1] in forb:\n            # Assign smallest feasible color; if none in current palette, open a new color\n            current_max = max(sol)\n            candidates = [c for c in range(1, current_max + 1) if c not in forb]\n            sol[v-1] = min(candidates) if candidates else (current_max + 1)\n    # Optional compression: relabel colors to 1..m without gaps for compactness\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":["local",null,"[1,1,2,2,1,3,3,2,3]",null],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001448607}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST. A Python list of length 9 where position i-1 holds the color (positive int starting at 1) assigned to vertex i. Example: [1,1,2,2,1,3,3,2,3].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return len(set(solution))\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place local recolor of a single vertex respecting constraints as much as possible.\n    # Returns metadata (NB_Type, Movement_Type) as required.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return (\"local\", \"invalid-input\")\n    # Ensure all entries are positive ints; if not, initialize to 1\n    for i in range(n):\n        if not isinstance(solution[i], int) or solution[i] < 1:\n            solution[i] = 1\n    # Pick a random vertex to recolor\n    v = random.randrange(1, n+1)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u == v:\n            forbidden.add(solution[w-1])\n        elif w == v:\n            forbidden.add(solution[u-1])\n    current_max = max(solution) if solution else 1\n    # Candidate colors prefer existing palette to reduce color count\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if candidates:\n        # Heuristic: choose the smallest feasible color\n        new_color = min(candidates)\n    else:\n        # If no feasible within current palette, introduce a new color\n        new_color = current_max + 1\n    solution[v-1] = new_color\n    return (\"local\", \"recolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger move: multiple vertex recolors with greedy feasibility restoration.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Start from a safe copy and sanitize entries\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a simple feasible seed using a greedy pass\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    # Decide number of vertices to perturb\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    # First, randomize chosen vertices within current palette +\/- 1\n    base_max = max(sol) if sol else 1\n    for v in chosen:\n        sol[v-1] = random.randint(1, base_max + 1)\n    # Then, perform a greedy feasibility repair pass over all vertices\n    def neighbors_colors(v, arr):\n        cols = set()\n        for (u, w) in E:\n            if u == v:\n                cols.add(arr[w-1])\n            elif w == v:\n                cols.add(arr[u-1])\n        return cols\n    for v in range(1, n+1):\n        forb = neighbors_colors(v, sol)\n        if sol[v-1] in forb:\n            # Assign smallest feasible color; if none in current palette, open a new color\n            current_max = max(sol)\n            candidates = [c for c in range(1, current_max + 1) if c not in forb]\n            sol[v-1] = min(candidates) if candidates else (current_max + 1)\n    # Optional compression: relabel colors to 1..m without gaps for compactness\n    mapping = {}\n    next_c = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000650858}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST. A Python list of length 9 where position i-1 holds the color (positive int starting at 1) assigned to vertex i.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return float(len(set(solution)))\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Guard and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a feasible seed greedily if input invalid\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    new_sol = sol[:]\n    # Choose a vertex; prefer conflicted if any\n    def is_conflicted(v, arr):\n        for (u, w) in E:\n            if u == v and arr[u-1] == arr[w-1]:\n                return True\n            if w == v and arr[u-1] == arr[w-1]:\n                return True\n        return False\n    conflicted = [v for v in range(1, n+1) if is_conflicted(v, new_sol)]\n    if conflicted:\n        v = random.choice(conflicted)\n    else:\n        v = random.randrange(1, n+1)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u == v:\n            forbidden.add(new_sol[w-1])\n        elif w == v:\n            forbidden.add(new_sol[u-1])\n    current_max = max(new_sol) if new_sol else 1\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if candidates:\n        # Pick a color different from current if possible; otherwise keep feasible\n        current = new_sol[v-1]\n        feas = [c for c in candidates if c != current]\n        new_color = min(feas) if feas else min(candidates)\n    else:\n        new_color = current_max + 1\n    new_sol[v-1] = new_color\n    return (new_sol, (\"local\", \"recolor\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex recolor with greedy repair and color compaction\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Sanitize base solution\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n    # Select k vertices to perturb\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    base_max = max(sol) if sol else 1\n    for v in chosen:\n        sol[v-1] = random.randint(1, base_max + 1)\n    # Greedy feasibility repair\n    def neigh_colors(v, arr):\n        cols = set()\n        for (u, w) in E:\n            if u == v:\n                cols.add(arr[w-1])\n            elif w == v:\n                cols.add(arr[u-1])\n        return cols\n    for v in range(1, n+1):\n        forb = neigh_colors(v, sol)\n        if sol[v-1] in forb:\n            cur_max = max(sol)\n            candidates = [c for c in range(1, cur_max + 1) if c not in forb]\n            sol[v-1] = min(candidates) if candidates else (cur_max + 1)\n    # Color compaction: relabel to 1..m without gaps\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":["[1,1,2,2,1,3,3,2,3]",null,"[1,1,2,2,1,3,3,2,3]",null],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00080082}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST. A Python list of length 9 where position i-1 holds the color (positive int starting at 1) assigned to vertex i.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return float(len(set(solution)))\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Guard and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a feasible seed greedily if input invalid\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    new_sol = sol[:]\n    # Choose a vertex; prefer conflicted if any\n    def is_conflicted(v, arr):\n        for (u, w) in E:\n            if u == v and arr[u-1] == arr[w-1]:\n                return True\n            if w == v and arr[u-1] == arr[w-1]:\n                return True\n        return False\n    conflicted = [v for v in range(1, n+1) if is_conflicted(v, new_sol)]\n    if conflicted:\n        v = random.choice(conflicted)\n    else:\n        v = random.randrange(1, n+1)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u == v:\n            forbidden.add(new_sol[w-1])\n        elif w == v:\n            forbidden.add(new_sol[u-1])\n    current_max = max(new_sol) if new_sol else 1\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if candidates:\n        # Pick a color different from current if possible; otherwise keep feasible\n        current = new_sol[v-1]\n        feas = [c for c in candidates if c != current]\n        new_color = min(feas) if feas else min(candidates)\n    else:\n        new_color = current_max + 1\n    new_sol[v-1] = new_color\n    return (new_sol, (\"local\", \"recolor\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex recolor with greedy repair and color compaction\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Sanitize base solution\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n    # Select k vertices to perturb\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    base_max = max(sol) if sol else 1\n    for v in chosen:\n        sol[v-1] = random.randint(1, base_max + 1)\n    # Greedy feasibility repair\n    def neigh_colors(v, arr):\n        cols = set()\n        for (u, w) in E:\n            if u == v:\n                cols.add(arr[w-1])\n            elif w == v:\n                cols.add(arr[u-1])\n        return cols\n    for v in range(1, n+1):\n        forb = neigh_colors(v, sol)\n        if sol[v-1] in forb:\n            cur_max = max(sol)\n            candidates = [c for c in range(1, cur_max + 1) if c not in forb]\n            sol[v-1] = min(candidates) if candidates else (cur_max + 1)\n    # Color compaction: relabel to 1..m without gaps\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":[[1,1,2,2,3,5,4,2,5],null,[1,1,2,2,1,3,3,2,3],3.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001907393}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST. A Python list of length 9 where position i-1 holds the color (positive int starting at 1) assigned to vertex i.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return float(len(set(solution)))\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Guard and sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a feasible seed greedily if input invalid\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    new_sol = sol[:]\n    # Choose a vertex; prefer conflicted if any\n    def is_conflicted(v, arr):\n        for (u, w) in E:\n            if u == v and arr[u-1] == arr[w-1]:\n                return True\n            if w == v and arr[u-1] == arr[w-1]:\n                return True\n        return False\n    conflicted = [v for v in range(1, n+1) if is_conflicted(v, new_sol)]\n    if conflicted:\n        v = random.choice(conflicted)\n    else:\n        v = random.randrange(1, n+1)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u == v:\n            forbidden.add(new_sol[w-1])\n        elif w == v:\n            forbidden.add(new_sol[u-1])\n    current_max = max(new_sol) if new_sol else 1\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if candidates:\n        # Pick a color different from current if possible; otherwise keep feasible\n        current = new_sol[v-1]\n        feas = [c for c in candidates if c != current]\n        new_color = min(feas) if feas else min(candidates)\n    else:\n        new_color = current_max + 1\n    new_sol[v-1] = new_color\n    return (new_sol, (\"local\", \"recolor\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex recolor with greedy repair and color compaction\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Sanitize base solution\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n    # Select k vertices to perturb\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    base_max = max(sol) if sol else 1\n    for v in chosen:\n        sol[v-1] = random.randint(1, base_max + 1)\n    # Greedy feasibility repair\n    def neigh_colors(v, arr):\n        cols = set()\n        for (u, w) in E:\n            if u == v:\n                cols.add(arr[w-1])\n            elif w == v:\n                cols.add(arr[u-1])\n        return cols\n    for v in range(1, n+1):\n        forb = neigh_colors(v, sol)\n        if sol[v-1] in forb:\n            cur_max = max(sol)\n            candidates = [c for c in range(1, cur_max + 1) if c not in forb]\n            sol[v-1] = min(candidates) if candidates else (cur_max + 1)\n    # Color compaction: relabel to 1..m without gaps\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = sol[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sol[i] = mapping[c]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000724179}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return float(len(set(solution)))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize input\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Helper functions\n    def conflicts(arr: List[int]) -> List[int]:\n        bad = set()\n        for u,v in E:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    def smallest_feasible_color(v: int, arr: List[int], cap: int) -> int:\n        forb = {arr[w-1] for w in adj[v]}\n        for c in range(1, cap+1):\n            if c not in forb:\n                return c\n        return 0  # signal none within cap\n\n    def greedy_repair(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        changed = True\n        # Cap colors to current max; allow +1 only if strictly necessary\n        while changed:\n            changed = False\n            current_max = max(arr)\n            bad = conflicts(arr)\n            if not bad:\n                break\n            random.shuffle(bad)\n            for v in bad:\n                cap = max(arr)\n                c = smallest_feasible_color(v, arr, cap)\n                if c == 0:\n                    c = cap + 1\n                if arr[v-1] != c:\n                    arr[v-1] = c\n                    changed = True\n        return arr\n\n    def compact(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        mapping = {}\n        nxt = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            arr[i] = mapping[c]\n        return arr\n\n    # Ensure feasibility before generating a neighbour\n    sol = greedy_repair(sol)\n    sol = compact(sol)\n\n    # Choose move type\n    move_roll = random.random()\n    new_sol = sol[:]\n    meta = (\"local\", \"recolor\")\n\n    if move_roll < 0.5:\n        # Recolor a (preferably conflicted) vertex with an in-range color\n        bad = conflicts(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(1, n+1)\n        current_max = max(new_sol)\n        forb = {new_sol[w-1] for w in adj[v]}\n        candidates = [c for c in range(1, current_max+0) if c not in forb]  # strictly within existing colors except none if 1..current_max-1\n        # Correct candidates to 1..current_max without creating gaps\n        candidates = [c for c in range(1, current_max+1) if c not in forb and c != new_sol[v-1]]\n        if candidates:\n            new_sol[v-1] = random.choice(candidates)\n        # else keep as is (feasible)\n        meta = (\"local\", \"recolor\")\n    else:\n        # Try color swap between two vertices to potentially reduce colors or diversify\n        attempts = 10\n        done = False\n        for _ in range(attempts):\n            i, j = random.sample(range(1, n+1), 2)\n            if new_sol[i-1] == new_sol[j-1]:\n                continue\n            ci, cj = new_sol[i-1], new_sol[j-1]\n            ok_i = all(new_sol[w-1] != cj for w in adj[i])\n            ok_j = all(new_sol[w-1] != ci for w in adj[j])\n            if ok_i and ok_j:\n                new_sol[i-1], new_sol[j-1] = cj, ci\n                done = True\n                break\n        meta = (\"local\", \"swap\" if done else \"noop\")\n\n    # Post-move repair (safety) and compaction\n    new_sol = greedy_repair(new_sol)\n    new_sol = compact(new_sol)\n\n    return (new_sol, meta)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def conflicts(arr: List[int]):\n        bad = set()\n        for u,v in E:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def greedy_repair(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        changed = True\n        while changed:\n            changed = False\n            for v in range(1, n+1):\n                forb = {arr[w-1] for w in adj[v]}\n                if arr[v-1] in forb:\n                    cap = max(arr)\n                    candidates = [c for c in range(1, cap+1) if c not in forb]\n                    if candidates:\n                        newc = random.choice(candidates)\n                    else:\n                        newc = cap + 1\n                    if newc != arr[v-1]:\n                        arr[v-1] = newc\n                        changed = True\n        return arr\n\n    def compact(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        mapping = {}\n        nxt = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            arr[i] = mapping[c]\n        return arr\n\n    # Multi-vertex recolor into existing palette +\/- 1\n    current_max = max(sol)\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    for v in chosen:\n        sol[v-1] = random.randint(1, current_max + 1)\n\n    # Optional Kempe-chain between two random colors to diversify\n    colors = list(range(1, max(sol)+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Pick a random start vertex with color c1 or c2\n        V = [i for i in range(1, n+1) if sol[i-1] in (c1, c2)]\n        if V:\n            start = random.choice(V)\n            stack = [start]\n            visited = set([start])\n            comp = []\n            while stack:\n                v = stack.pop()\n                comp.append(v)\n                for w in adj[v]:\n                    if w not in visited and sol[w-1] in (c1, c2):\n                        visited.add(w)\n                        stack.append(w)\n            # Swap c1 <-> c2 on this component\n            for v in comp:\n                if sol[v-1] == c1:\n                    sol[v-1] = c2\n                elif sol[v-1] == c2:\n                    sol[v-1] = c1\n\n    # Repair and compact\n    sol = greedy_repair(sol)\n    sol = compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001015233}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return float(len(set(solution)))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize input\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Helper functions\n    def conflicts(arr: List[int]) -> List[int]:\n        bad = set()\n        for u,v in E:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    def smallest_feasible_color(v: int, arr: List[int], cap: int) -> int:\n        forb = {arr[w-1] for w in adj[v]}\n        for c in range(1, cap+1):\n            if c not in forb:\n                return c\n        return 0  # signal none within cap\n\n    def greedy_repair(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        changed = True\n        # Cap colors to current max; allow +1 only if strictly necessary\n        while changed:\n            changed = False\n            current_max = max(arr)\n            bad = conflicts(arr)\n            if not bad:\n                break\n            random.shuffle(bad)\n            for v in bad:\n                cap = max(arr)\n                c = smallest_feasible_color(v, arr, cap)\n                if c == 0:\n                    c = cap + 1\n                if arr[v-1] != c:\n                    arr[v-1] = c\n                    changed = True\n        return arr\n\n    def compact(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        mapping = {}\n        nxt = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            arr[i] = mapping[c]\n        return arr\n\n    # Ensure feasibility before generating a neighbour\n    sol = greedy_repair(sol)\n    sol = compact(sol)\n\n    # Choose move type\n    move_roll = random.random()\n    new_sol = sol[:]\n    meta = (\"local\", \"recolor\")\n\n    if move_roll < 0.5:\n        # Recolor a (preferably conflicted) vertex with an in-range color\n        bad = conflicts(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(1, n+1)\n        current_max = max(new_sol)\n        forb = {new_sol[w-1] for w in adj[v]}\n        candidates = [c for c in range(1, current_max+0) if c not in forb]  # strictly within existing colors except none if 1..current_max-1\n        # Correct candidates to 1..current_max without creating gaps\n        candidates = [c for c in range(1, current_max+1) if c not in forb and c != new_sol[v-1]]\n        if candidates:\n            new_sol[v-1] = random.choice(candidates)\n        # else keep as is (feasible)\n        meta = (\"local\", \"recolor\")\n    else:\n        # Try color swap between two vertices to potentially reduce colors or diversify\n        attempts = 10\n        done = False\n        for _ in range(attempts):\n            i, j = random.sample(range(1, n+1), 2)\n            if new_sol[i-1] == new_sol[j-1]:\n                continue\n            ci, cj = new_sol[i-1], new_sol[j-1]\n            ok_i = all(new_sol[w-1] != cj for w in adj[i])\n            ok_j = all(new_sol[w-1] != ci for w in adj[j])\n            if ok_i and ok_j:\n                new_sol[i-1], new_sol[j-1] = cj, ci\n                done = True\n                break\n        meta = (\"local\", \"swap\" if done else \"noop\")\n\n    # Post-move repair (safety) and compaction\n    new_sol = greedy_repair(new_sol)\n    new_sol = compact(new_sol)\n\n    return (new_sol, meta)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def conflicts(arr: List[int]):\n        bad = set()\n        for u,v in E:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def greedy_repair(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        changed = True\n        while changed:\n            changed = False\n            for v in range(1, n+1):\n                forb = {arr[w-1] for w in adj[v]}\n                if arr[v-1] in forb:\n                    cap = max(arr)\n                    candidates = [c for c in range(1, cap+1) if c not in forb]\n                    if candidates:\n                        newc = random.choice(candidates)\n                    else:\n                        newc = cap + 1\n                    if newc != arr[v-1]:\n                        arr[v-1] = newc\n                        changed = True\n        return arr\n\n    def compact(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        mapping = {}\n        nxt = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            arr[i] = mapping[c]\n        return arr\n\n    # Multi-vertex recolor into existing palette +\/- 1\n    current_max = max(sol)\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    for v in chosen:\n        sol[v-1] = random.randint(1, current_max + 1)\n\n    # Optional Kempe-chain between two random colors to diversify\n    colors = list(range(1, max(sol)+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Pick a random start vertex with color c1 or c2\n        V = [i for i in range(1, n+1) if sol[i-1] in (c1, c2)]\n        if V:\n            start = random.choice(V)\n            stack = [start]\n            visited = set([start])\n            comp = []\n            while stack:\n                v = stack.pop()\n                comp.append(v)\n                for w in adj[v]:\n                    if w not in visited and sol[w-1] in (c1, c2):\n                        visited.add(w)\n                        stack.append(w)\n            # Swap c1 <-> c2 on this component\n            for v in comp:\n                if sol[v-1] == c1:\n                    sol[v-1] = c2\n                elif sol[v-1] == c2:\n                    sol[v-1] = c1\n\n    # Repair and compact\n    sol = greedy_repair(sol)\n    sol = compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001464028}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Check constraints\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Objective: minimize number of distinct colors\n    return float(len(set(solution)))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize input\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n\n    # Helper functions\n    def conflicts(arr: List[int]) -> List[int]:\n        bad = set()\n        for u,v in E:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    def smallest_feasible_color(v: int, arr: List[int], cap: int) -> int:\n        forb = {arr[w-1] for w in adj[v]}\n        for c in range(1, cap+1):\n            if c not in forb:\n                return c\n        return 0  # signal none within cap\n\n    def greedy_repair(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        changed = True\n        # Cap colors to current max; allow +1 only if strictly necessary\n        while changed:\n            changed = False\n            current_max = max(arr)\n            bad = conflicts(arr)\n            if not bad:\n                break\n            random.shuffle(bad)\n            for v in bad:\n                cap = max(arr)\n                c = smallest_feasible_color(v, arr, cap)\n                if c == 0:\n                    c = cap + 1\n                if arr[v-1] != c:\n                    arr[v-1] = c\n                    changed = True\n        return arr\n\n    def compact(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        mapping = {}\n        nxt = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            arr[i] = mapping[c]\n        return arr\n\n    # Ensure feasibility before generating a neighbour\n    sol = greedy_repair(sol)\n    sol = compact(sol)\n\n    # Choose move type\n    move_roll = random.random()\n    new_sol = sol[:]\n    meta = (\"local\", \"recolor\")\n\n    if move_roll < 0.5:\n        # Recolor a (preferably conflicted) vertex with an in-range color\n        bad = conflicts(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(1, n+1)\n        current_max = max(new_sol)\n        forb = {new_sol[w-1] for w in adj[v]}\n        candidates = [c for c in range(1, current_max+0) if c not in forb]  # strictly within existing colors except none if 1..current_max-1\n        # Correct candidates to 1..current_max without creating gaps\n        candidates = [c for c in range(1, current_max+1) if c not in forb and c != new_sol[v-1]]\n        if candidates:\n            new_sol[v-1] = random.choice(candidates)\n        # else keep as is (feasible)\n        meta = (\"local\", \"recolor\")\n    else:\n        # Try color swap between two vertices to potentially reduce colors or diversify\n        attempts = 10\n        done = False\n        for _ in range(attempts):\n            i, j = random.sample(range(1, n+1), 2)\n            if new_sol[i-1] == new_sol[j-1]:\n                continue\n            ci, cj = new_sol[i-1], new_sol[j-1]\n            ok_i = all(new_sol[w-1] != cj for w in adj[i])\n            ok_j = all(new_sol[w-1] != ci for w in adj[j])\n            if ok_i and ok_j:\n                new_sol[i-1], new_sol[j-1] = cj, ci\n                done = True\n                break\n        meta = (\"local\", \"swap\" if done else \"noop\")\n\n    # Post-move repair (safety) and compaction\n    new_sol = greedy_repair(new_sol)\n    new_sol = compact(new_sol)\n\n    return (new_sol, meta)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u,v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def conflicts(arr: List[int]):\n        bad = set()\n        for u,v in E:\n            if arr[u-1] == arr[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def greedy_repair(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        changed = True\n        while changed:\n            changed = False\n            for v in range(1, n+1):\n                forb = {arr[w-1] for w in adj[v]}\n                if arr[v-1] in forb:\n                    cap = max(arr)\n                    candidates = [c for c in range(1, cap+1) if c not in forb]\n                    if candidates:\n                        newc = random.choice(candidates)\n                    else:\n                        newc = cap + 1\n                    if newc != arr[v-1]:\n                        arr[v-1] = newc\n                        changed = True\n        return arr\n\n    def compact(arr: List[int]) -> List[int]:\n        arr = arr[:]\n        mapping = {}\n        nxt = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            arr[i] = mapping[c]\n        return arr\n\n    # Multi-vertex recolor into existing palette +\/- 1\n    current_max = max(sol)\n    k = max(2, n \/\/ 3)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    for v in chosen:\n        sol[v-1] = random.randint(1, current_max + 1)\n\n    # Optional Kempe-chain between two random colors to diversify\n    colors = list(range(1, max(sol)+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        # Pick a random start vertex with color c1 or c2\n        V = [i for i in range(1, n+1) if sol[i-1] in (c1, c2)]\n        if V:\n            start = random.choice(V)\n            stack = [start]\n            visited = set([start])\n            comp = []\n            while stack:\n                v = stack.pop()\n                comp.append(v)\n                for w in adj[v]:\n                    if w not in visited and sol[w-1] in (c1, c2):\n                        visited.add(w)\n                        stack.append(w)\n            # Swap c1 <-> c2 on this component\n            for v in comp:\n                if sol[v-1] == c1:\n                    sol[v-1] = c2\n                elif sol[v-1] == c2:\n                    sol[v-1] = c1\n\n    # Repair and compact\n    sol = greedy_repair(sol)\n    sol = compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001358556}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Problem data (internal)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Type and bounds validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Count conflicts and distinct colors\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    distinct = len(set(solution))\n    # Feasible: minimize number of colors\n    if conflicts == 0:\n        return float(distinct)\n    # Infeasible: finite penalty with gradient\n    base_penalty = 1000.0\n    return base_penalty + conflicts + 0.001 * distinct\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def count_conflicts(arr):\n        c = 0\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n\n    def feasible_color(v, color, arr):\n        for w in adj[v]:\n            if arr[w-1] == color:\n                return False\n        return True\n\n    def try_repair_under_cap(arr, cap):\n        # Greedy repair without introducing new colors beyond cap\n        arr = arr[:]\n        changed = True\n        while changed:\n            changed = False\n            for v in range(1, n+1):\n                forb = {arr[w-1] for w in adj[v]}\n                if arr[v-1] in forb:\n                    candidates = [c for c in range(1, cap+1) if c not in forb]\n                    if candidates:\n                        newc = min(candidates)\n                        if newc != arr[v-1]:\n                            arr[v-1] = newc\n                            changed = True\n                    # else: fail to repair under cap; leave as-is\n        return arr\n\n    def drop_empty_colors(arr):\n        # Remove gaps only at the top if the highest color class is empty\n        arr = arr[:]\n        used = set(arr)\n        maxc = max(arr)\n        while maxc > 0 and (maxc not in used):\n            maxc -= 1\n        return arr\n\n    # Ensure we start from a lightly repaired state (under current cap)\n    cap = max(sol)\n    sol = try_repair_under_cap(sol, cap)\n\n    new_sol = sol[:]\n    meta = {\"move\": \"noop\", \"verts\": [], \"delta\": 0}\n\n    move_roll = random.random()\n\n    if move_roll < 0.45:\n        # Move 1: recolor a vertex (bias to highest color and lowest feasible color)\n        highest = max(new_sol)\n        candidates_v = [i for i in range(1, n+1) if new_sol[i-1] == highest]\n        if not candidates_v:\n            candidates_v = list(range(1, n+1))\n        v = random.choice(candidates_v)\n        forb = {new_sol[w-1] for w in adj[v]}\n        colors = [c for c in range(1, highest) if c not in forb]\n        if colors:\n            best_c = min(colors)\n            old = count_conflicts(new_sol)\n            new_sol[v-1] = best_c\n            new = count_conflicts(new_sol)\n            meta = {\"move\": \"recolor\", \"verts\": [v], \"delta\": new - old}\n        else:\n            meta = {\"move\": \"recolor_fail\", \"verts\": [v], \"delta\": 0}\n\n    elif move_roll < 0.8:\n        # Move 2: color squeeze - try to eliminate highest color by reassigning its vertices\n        K = max(new_sol)\n        cls = [i for i in range(1, n+1) if new_sol[i-1] == K]\n        success = True\n        touched = []\n        for v in random.sample(cls, len(cls)):\n            forb = {new_sol[w-1] for w in adj[v]}\n            feasible = [c for c in range(1, K) if c not in forb]\n            if feasible:\n                new_sol[v-1] = min(feasible)\n                touched.append(v)\n            else:\n                success = False\n                break\n        if not success:\n            # rollback\n            for v in touched:\n                new_sol[v-1] = K\n            meta = {\"move\": \"squeeze_fail\", \"verts\": cls, \"delta\": 0}\n        else:\n            # success: class K eliminated implicitly\n            meta = {\"move\": \"squeeze\", \"verts\": cls, \"delta\": -1}\n\n    else:\n        # Move 3: Kempe-chain interchange between two existing colors\n        colors = list(sorted(set(new_sol)))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick random start with color c1 or c2\n            V12 = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n            if V12:\n                start = random.choice(V12)\n                stack = [start]\n                visited = set([start])\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    comp.append(v)\n                    for w in adj[v]:\n                        if w not in visited and new_sol[w-1] in (c1, c2):\n                            visited.add(w)\n                            stack.append(w)\n                # swap c1 <-> c2 on this component\n                before = count_conflicts(new_sol)\n                for v in comp:\n                    if new_sol[v-1] == c1:\n                        new_sol[v-1] = c2\n                    elif new_sol[v-1] == c2:\n                        new_sol[v-1] = c1\n                after = count_conflicts(new_sol)\n                meta = {\"move\": \"kempe\", \"verts\": comp, \"delta\": after - before}\n            else:\n                meta = {\"move\": \"kempe_fail\", \"verts\": [], \"delta\": 0}\n        else:\n            meta = {\"move\": \"kempe_fail\", \"verts\": [], \"delta\": 0}\n\n    # Post-move bounded repair (under current cap or reduced cap if squeeze succeeded)\n    cap_after = max(new_sol)\n    new_sol = try_repair_under_cap(new_sol, cap_after)\n    new_sol = drop_empty_colors(new_sol)\n\n    return (new_sol, meta)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def feasible_color(v, color, arr):\n        for w in adj[v]:\n            if arr[w-1] == color:\n                return False\n        return True\n\n    def count_conflicts(arr):\n        c = 0\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n\n    # Controlled diversification\n    K = max(sol)\n    colors = list(range(1, K+1))\n\n    # Step 1: choose a color class and try to push some vertices downwards\n    cls = random.choice(colors) if colors else 1\n    vertices = [i for i in range(1, n+1) if sol[i-1] == cls]\n    random.shuffle(vertices)\n    intensity = max(2, len(vertices) \/\/ 2) if vertices else 2\n    touched = 0\n    for v in vertices:\n        lower = [c for c in range(1, sol[v-1]) if feasible_color(v, c, sol)]\n        if lower:\n            sol[v-1] = random.choice(lower)\n            touched += 1\n            if touched >= intensity:\n                break\n\n    # Step 2: If no vertices moved, apply a Kempe-chain swap to diversify palette structure\n    if touched == 0 and K >= 2:\n        c1, c2 = random.sample(list(range(1, K+1)), 2)\n        V12 = [i for i in range(1, n+1) if sol[i-1] in (c1, c2)]\n        if V12:\n            start = random.choice(V12)\n            stack = [start]\n            visited = set([start])\n            comp = []\n            while stack:\n                v = stack.pop()\n                comp.append(v)\n                for w in adj[v]:\n                    if w not in visited and sol[w-1] in (c1, c2):\n                        visited.add(w)\n                        stack.append(w)\n            for v in comp:\n                if sol[v-1] == c1:\n                    sol[v-1] = c2\n                elif sol[v-1] == c2:\n                    sol[v-1] = c1\n\n    # Step 3: light repair without increasing number of colors\n    cap = max(sol)\n    changed = True\n    while changed:\n        changed = False\n        for v in range(1, n+1):\n            forb = {sol[w-1] for w in adj[v]}\n            if sol[v-1] in forb:\n                candidates = [c for c in range(1, cap+1) if c not in forb]\n                if candidates:\n                    newc = min(candidates)\n                    if newc != sol[v-1]:\n                        sol[v-1] = newc\n                        changed = True\n                # else: keep as is; accept temporary conflicts (evaluation handles penalty)\n\n    return sol\n","Resultados":[[1,1,1,1,1,1,1,1,1],1018.001,[1,1,1,1,1,1,1,1,1],1018.001],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001917463}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Problem data (internal)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Type and bounds validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Count conflicts and distinct colors\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    distinct = len(set(solution))\n    # Feasible: minimize number of colors\n    if conflicts == 0:\n        return float(distinct)\n    # Infeasible: finite penalty with gradient\n    base_penalty = 1000.0\n    return base_penalty + conflicts + 0.001 * distinct\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def count_conflicts(arr):\n        c = 0\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n\n    def feasible_color(v, color, arr):\n        for w in adj[v]:\n            if arr[w-1] == color:\n                return False\n        return True\n\n    def try_repair_under_cap(arr, cap):\n        # Greedy repair without introducing new colors beyond cap\n        arr = arr[:]\n        changed = True\n        while changed:\n            changed = False\n            for v in range(1, n+1):\n                forb = {arr[w-1] for w in adj[v]}\n                if arr[v-1] in forb:\n                    candidates = [c for c in range(1, cap+1) if c not in forb]\n                    if candidates:\n                        newc = min(candidates)\n                        if newc != arr[v-1]:\n                            arr[v-1] = newc\n                            changed = True\n                    # else: fail to repair under cap; leave as-is\n        return arr\n\n    def drop_empty_colors(arr):\n        # Remove gaps only at the top if the highest color class is empty\n        arr = arr[:]\n        used = set(arr)\n        maxc = max(arr)\n        while maxc > 0 and (maxc not in used):\n            maxc -= 1\n        return arr\n\n    # Ensure we start from a lightly repaired state (under current cap)\n    cap = max(sol)\n    sol = try_repair_under_cap(sol, cap)\n\n    new_sol = sol[:]\n    meta = {\"move\": \"noop\", \"verts\": [], \"delta\": 0}\n\n    move_roll = random.random()\n\n    if move_roll < 0.45:\n        # Move 1: recolor a vertex (bias to highest color and lowest feasible color)\n        highest = max(new_sol)\n        candidates_v = [i for i in range(1, n+1) if new_sol[i-1] == highest]\n        if not candidates_v:\n            candidates_v = list(range(1, n+1))\n        v = random.choice(candidates_v)\n        forb = {new_sol[w-1] for w in adj[v]}\n        colors = [c for c in range(1, highest) if c not in forb]\n        if colors:\n            best_c = min(colors)\n            old = count_conflicts(new_sol)\n            new_sol[v-1] = best_c\n            new = count_conflicts(new_sol)\n            meta = {\"move\": \"recolor\", \"verts\": [v], \"delta\": new - old}\n        else:\n            meta = {\"move\": \"recolor_fail\", \"verts\": [v], \"delta\": 0}\n\n    elif move_roll < 0.8:\n        # Move 2: color squeeze - try to eliminate highest color by reassigning its vertices\n        K = max(new_sol)\n        cls = [i for i in range(1, n+1) if new_sol[i-1] == K]\n        success = True\n        touched = []\n        for v in random.sample(cls, len(cls)):\n            forb = {new_sol[w-1] for w in adj[v]}\n            feasible = [c for c in range(1, K) if c not in forb]\n            if feasible:\n                new_sol[v-1] = min(feasible)\n                touched.append(v)\n            else:\n                success = False\n                break\n        if not success:\n            # rollback\n            for v in touched:\n                new_sol[v-1] = K\n            meta = {\"move\": \"squeeze_fail\", \"verts\": cls, \"delta\": 0}\n        else:\n            # success: class K eliminated implicitly\n            meta = {\"move\": \"squeeze\", \"verts\": cls, \"delta\": -1}\n\n    else:\n        # Move 3: Kempe-chain interchange between two existing colors\n        colors = list(sorted(set(new_sol)))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick random start with color c1 or c2\n            V12 = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n            if V12:\n                start = random.choice(V12)\n                stack = [start]\n                visited = set([start])\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    comp.append(v)\n                    for w in adj[v]:\n                        if w not in visited and new_sol[w-1] in (c1, c2):\n                            visited.add(w)\n                            stack.append(w)\n                # swap c1 <-> c2 on this component\n                before = count_conflicts(new_sol)\n                for v in comp:\n                    if new_sol[v-1] == c1:\n                        new_sol[v-1] = c2\n                    elif new_sol[v-1] == c2:\n                        new_sol[v-1] = c1\n                after = count_conflicts(new_sol)\n                meta = {\"move\": \"kempe\", \"verts\": comp, \"delta\": after - before}\n            else:\n                meta = {\"move\": \"kempe_fail\", \"verts\": [], \"delta\": 0}\n        else:\n            meta = {\"move\": \"kempe_fail\", \"verts\": [], \"delta\": 0}\n\n    # Post-move bounded repair (under current cap or reduced cap if squeeze succeeded)\n    cap_after = max(new_sol)\n    new_sol = try_repair_under_cap(new_sol, cap_after)\n    new_sol = drop_empty_colors(new_sol)\n\n    return (new_sol, meta)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def feasible_color(v, color, arr):\n        for w in adj[v]:\n            if arr[w-1] == color:\n                return False\n        return True\n\n    def count_conflicts(arr):\n        c = 0\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n\n    # Controlled diversification\n    K = max(sol)\n    colors = list(range(1, K+1))\n\n    # Step 1: choose a color class and try to push some vertices downwards\n    cls = random.choice(colors) if colors else 1\n    vertices = [i for i in range(1, n+1) if sol[i-1] == cls]\n    random.shuffle(vertices)\n    intensity = max(2, len(vertices) \/\/ 2) if vertices else 2\n    touched = 0\n    for v in vertices:\n        lower = [c for c in range(1, sol[v-1]) if feasible_color(v, c, sol)]\n        if lower:\n            sol[v-1] = random.choice(lower)\n            touched += 1\n            if touched >= intensity:\n                break\n\n    # Step 2: If no vertices moved, apply a Kempe-chain swap to diversify palette structure\n    if touched == 0 and K >= 2:\n        c1, c2 = random.sample(list(range(1, K+1)), 2)\n        V12 = [i for i in range(1, n+1) if sol[i-1] in (c1, c2)]\n        if V12:\n            start = random.choice(V12)\n            stack = [start]\n            visited = set([start])\n            comp = []\n            while stack:\n                v = stack.pop()\n                comp.append(v)\n                for w in adj[v]:\n                    if w not in visited and sol[w-1] in (c1, c2):\n                        visited.add(w)\n                        stack.append(w)\n            for v in comp:\n                if sol[v-1] == c1:\n                    sol[v-1] = c2\n                elif sol[v-1] == c2:\n                    sol[v-1] = c1\n\n    # Step 3: light repair without increasing number of colors\n    cap = max(sol)\n    changed = True\n    while changed:\n        changed = False\n        for v in range(1, n+1):\n            forb = {sol[w-1] for w in adj[v]}\n            if sol[v-1] in forb:\n                candidates = [c for c in range(1, cap+1) if c not in forb]\n                if candidates:\n                    newc = min(candidates)\n                    if newc != sol[v-1]:\n                        sol[v-1] = newc\n                        changed = True\n                # else: keep as is; accept temporary conflicts (evaluation handles penalty)\n\n    return sol\n","Resultados":[[1,1,1,1,1,1,1,1,1],1018.001,"[1,1,2,2,1,3,3,2,4]",1018.001],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002637952}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Problem data (internal)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    # Type and bounds validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Count conflicts and distinct colors\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    distinct = len(set(solution))\n    # Feasible: minimize number of colors\n    if conflicts == 0:\n        return float(distinct)\n    # Infeasible: finite penalty with gradient\n    base_penalty = 1000.0\n    return base_penalty + conflicts + 0.001 * distinct\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def count_conflicts(arr):\n        c = 0\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n\n    def feasible_color(v, color, arr):\n        for w in adj[v]:\n            if arr[w-1] == color:\n                return False\n        return True\n\n    def try_repair_under_cap(arr, cap):\n        # Greedy repair without introducing new colors beyond cap\n        arr = arr[:]\n        changed = True\n        while changed:\n            changed = False\n            for v in range(1, n+1):\n                forb = {arr[w-1] for w in adj[v]}\n                if arr[v-1] in forb:\n                    candidates = [c for c in range(1, cap+1) if c not in forb]\n                    if candidates:\n                        newc = min(candidates)\n                        if newc != arr[v-1]:\n                            arr[v-1] = newc\n                            changed = True\n                    # else: fail to repair under cap; leave as-is\n        return arr\n\n    def drop_empty_colors(arr):\n        # Remove gaps only at the top if the highest color class is empty\n        arr = arr[:]\n        used = set(arr)\n        maxc = max(arr)\n        while maxc > 0 and (maxc not in used):\n            maxc -= 1\n        return arr\n\n    # Ensure we start from a lightly repaired state (under current cap)\n    cap = max(sol)\n    sol = try_repair_under_cap(sol, cap)\n\n    new_sol = sol[:]\n    meta = {\"move\": \"noop\", \"verts\": [], \"delta\": 0}\n\n    move_roll = random.random()\n\n    if move_roll < 0.45:\n        # Move 1: recolor a vertex (bias to highest color and lowest feasible color)\n        highest = max(new_sol)\n        candidates_v = [i for i in range(1, n+1) if new_sol[i-1] == highest]\n        if not candidates_v:\n            candidates_v = list(range(1, n+1))\n        v = random.choice(candidates_v)\n        forb = {new_sol[w-1] for w in adj[v]}\n        colors = [c for c in range(1, highest) if c not in forb]\n        if colors:\n            best_c = min(colors)\n            old = count_conflicts(new_sol)\n            new_sol[v-1] = best_c\n            new = count_conflicts(new_sol)\n            meta = {\"move\": \"recolor\", \"verts\": [v], \"delta\": new - old}\n        else:\n            meta = {\"move\": \"recolor_fail\", \"verts\": [v], \"delta\": 0}\n\n    elif move_roll < 0.8:\n        # Move 2: color squeeze - try to eliminate highest color by reassigning its vertices\n        K = max(new_sol)\n        cls = [i for i in range(1, n+1) if new_sol[i-1] == K]\n        success = True\n        touched = []\n        for v in random.sample(cls, len(cls)):\n            forb = {new_sol[w-1] for w in adj[v]}\n            feasible = [c for c in range(1, K) if c not in forb]\n            if feasible:\n                new_sol[v-1] = min(feasible)\n                touched.append(v)\n            else:\n                success = False\n                break\n        if not success:\n            # rollback\n            for v in touched:\n                new_sol[v-1] = K\n            meta = {\"move\": \"squeeze_fail\", \"verts\": cls, \"delta\": 0}\n        else:\n            # success: class K eliminated implicitly\n            meta = {\"move\": \"squeeze\", \"verts\": cls, \"delta\": -1}\n\n    else:\n        # Move 3: Kempe-chain interchange between two existing colors\n        colors = list(sorted(set(new_sol)))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # pick random start with color c1 or c2\n            V12 = [i for i in range(1, n+1) if new_sol[i-1] in (c1, c2)]\n            if V12:\n                start = random.choice(V12)\n                stack = [start]\n                visited = set([start])\n                comp = []\n                while stack:\n                    v = stack.pop()\n                    comp.append(v)\n                    for w in adj[v]:\n                        if w not in visited and new_sol[w-1] in (c1, c2):\n                            visited.add(w)\n                            stack.append(w)\n                # swap c1 <-> c2 on this component\n                before = count_conflicts(new_sol)\n                for v in comp:\n                    if new_sol[v-1] == c1:\n                        new_sol[v-1] = c2\n                    elif new_sol[v-1] == c2:\n                        new_sol[v-1] = c1\n                after = count_conflicts(new_sol)\n                meta = {\"move\": \"kempe\", \"verts\": comp, \"delta\": after - before}\n            else:\n                meta = {\"move\": \"kempe_fail\", \"verts\": [], \"delta\": 0}\n        else:\n            meta = {\"move\": \"kempe_fail\", \"verts\": [], \"delta\": 0}\n\n    # Post-move bounded repair (under current cap or reduced cap if squeeze succeeded)\n    cap_after = max(new_sol)\n    new_sol = try_repair_under_cap(new_sol, cap_after)\n    new_sol = drop_empty_colors(new_sol)\n\n    return (new_sol, meta)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Internal problem data\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Sanitize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1] * n\n    else:\n        sol = [x if isinstance(x, int) and x >= 1 else 1 for x in solution]\n    sol = sol[:]\n\n    def feasible_color(v, color, arr):\n        for w in adj[v]:\n            if arr[w-1] == color:\n                return False\n        return True\n\n    def count_conflicts(arr):\n        c = 0\n        for u, v in E:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n\n    # Controlled diversification\n    K = max(sol)\n    colors = list(range(1, K+1))\n\n    # Step 1: choose a color class and try to push some vertices downwards\n    cls = random.choice(colors) if colors else 1\n    vertices = [i for i in range(1, n+1) if sol[i-1] == cls]\n    random.shuffle(vertices)\n    intensity = max(2, len(vertices) \/\/ 2) if vertices else 2\n    touched = 0\n    for v in vertices:\n        lower = [c for c in range(1, sol[v-1]) if feasible_color(v, c, sol)]\n        if lower:\n            sol[v-1] = random.choice(lower)\n            touched += 1\n            if touched >= intensity:\n                break\n\n    # Step 2: If no vertices moved, apply a Kempe-chain swap to diversify palette structure\n    if touched == 0 and K >= 2:\n        c1, c2 = random.sample(list(range(1, K+1)), 2)\n        V12 = [i for i in range(1, n+1) if sol[i-1] in (c1, c2)]\n        if V12:\n            start = random.choice(V12)\n            stack = [start]\n            visited = set([start])\n            comp = []\n            while stack:\n                v = stack.pop()\n                comp.append(v)\n                for w in adj[v]:\n                    if w not in visited and sol[w-1] in (c1, c2):\n                        visited.add(w)\n                        stack.append(w)\n            for v in comp:\n                if sol[v-1] == c1:\n                    sol[v-1] = c2\n                elif sol[v-1] == c2:\n                    sol[v-1] = c1\n\n    # Step 3: light repair without increasing number of colors\n    cap = max(sol)\n    changed = True\n    while changed:\n        changed = False\n        for v in range(1, n+1):\n            forb = {sol[w-1] for w in adj[v]}\n            if sol[v-1] in forb:\n                candidates = [c for c in range(1, cap+1) if c not in forb]\n                if candidates:\n                    newc = min(candidates)\n                    if newc != sol[v-1]:\n                        sol[v-1] = newc\n                        changed = True\n                # else: keep as is; accept temporary conflicts (evaluation handles penalty)\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001378057}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1:\n            return 10**9\n    # Problem data embedded\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"Invalid\", \"No-Op\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"Invalid\", \"No-Op\")\n    s = solution[:]\n    n = 9\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    def fitness(sol: List[int]) -> int:\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * 1000 + len(set(sol))\n    # Choose a random vertex to recolor\n    v = random.randrange(n)\n    # Candidate colors: existing colors plus (with small prob) a new color\n    colors = sorted(set(s))\n    max_color = max(colors) if colors else 1\n    candidate_colors = colors[:]\n    if random.random() < 0.2:\n        candidate_colors.append(max_color + 1)\n    # Evaluate recolor moves\n    best_col = s[v]\n    best_fit = fitness(s)\n    original_color = s[v]\n    random.shuffle(candidate_colors)\n    for col in candidate_colors:\n        if col == original_color:\n            continue\n        s[v] = col\n        f = fitness(s)\n        if f < best_fit:\n            best_fit = f\n            best_col = col\n    s[v] = best_col\n    # Optional post-step: relabel colors to 1..m compactly for stability\n    mapping = {}\n    nxt = 1\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    s = [mapping[c] for c in s]\n    return (s, \"AdjacentRecolor\", \"Single-Vertex-Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    def fitness(sol: List[int]) -> int:\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * 1000 + len(set(sol))\n    # Apply k random recolors and occasional color-merge to escape local minima\n    k = 4\n    for _ in range(k):\n        v = random.randrange(n)\n        colors = sorted(set(s))\n        max_color = max(colors)\n        # Try a random existing color different from current; fallback keep\n        candidate = random.choice(colors)\n        if candidate == s[v]:\n            candidate = ((candidate) % max_color) + 1 if max_color > 1 else candidate\n        old = s[v]\n        s[v] = candidate\n        # Accept if not worse; otherwise revert with 50% probability\n        if fitness(s) > fitness(solution):\n            if random.random() < 0.5:\n                s[v] = old\n    # Attempt a greedy color compaction: try to reduce highest color\n    colors = sorted(set(s))\n    if len(colors) > 1:\n        highest = colors[-1]\n        for target in colors[:-1]:\n            improved = True\n            while improved:\n                improved = False\n                for i in range(n):\n                    if s[i] == highest:\n                        old = s[i]\n                        s[i] = target\n                        # Check conflicts only for affected vertex to speed up\n                        conflict = False\n                        for (u, v) in edges:\n                            a, b = u-1, v-1\n                            if a == i or b == i:\n                                if s[a] == s[b]:\n                                    conflict = True\n                                    break\n                        if conflict:\n                            s[i] = old\n                        else:\n                            improved = True\n            # If highest no longer used, break\n            if highest not in s:\n                break\n    # Relabel colors to compact 1..m\n    mapping = {}\n    nxt = 1\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    s = [mapping[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000514416}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1:\n            return 10**9\n    # Problem data embedded\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"Invalid\", \"No-Op\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"Invalid\", \"No-Op\")\n    s = solution[:]\n    n = 9\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    def fitness(sol: List[int]) -> int:\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * 1000 + len(set(sol))\n    # Choose a random vertex to recolor\n    v = random.randrange(n)\n    # Candidate colors: existing colors plus (with small prob) a new color\n    colors = sorted(set(s))\n    max_color = max(colors) if colors else 1\n    candidate_colors = colors[:]\n    if random.random() < 0.2:\n        candidate_colors.append(max_color + 1)\n    # Evaluate recolor moves\n    best_col = s[v]\n    best_fit = fitness(s)\n    original_color = s[v]\n    random.shuffle(candidate_colors)\n    for col in candidate_colors:\n        if col == original_color:\n            continue\n        s[v] = col\n        f = fitness(s)\n        if f < best_fit:\n            best_fit = f\n            best_col = col\n    s[v] = best_col\n    # Optional post-step: relabel colors to 1..m compactly for stability\n    mapping = {}\n    nxt = 1\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    s = [mapping[c] for c in s]\n    return (s, \"AdjacentRecolor\", \"Single-Vertex-Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    def fitness(sol: List[int]) -> int:\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * 1000 + len(set(sol))\n    # Apply k random recolors and occasional color-merge to escape local minima\n    k = 4\n    for _ in range(k):\n        v = random.randrange(n)\n        colors = sorted(set(s))\n        max_color = max(colors)\n        # Try a random existing color different from current; fallback keep\n        candidate = random.choice(colors)\n        if candidate == s[v]:\n            candidate = ((candidate) % max_color) + 1 if max_color > 1 else candidate\n        old = s[v]\n        s[v] = candidate\n        # Accept if not worse; otherwise revert with 50% probability\n        if fitness(s) > fitness(solution):\n            if random.random() < 0.5:\n                s[v] = old\n    # Attempt a greedy color compaction: try to reduce highest color\n    colors = sorted(set(s))\n    if len(colors) > 1:\n        highest = colors[-1]\n        for target in colors[:-1]:\n            improved = True\n            while improved:\n                improved = False\n                for i in range(n):\n                    if s[i] == highest:\n                        old = s[i]\n                        s[i] = target\n                        # Check conflicts only for affected vertex to speed up\n                        conflict = False\n                        for (u, v) in edges:\n                            a, b = u-1, v-1\n                            if a == i or b == i:\n                                if s[a] == s[b]:\n                                    conflict = True\n                                    break\n                        if conflict:\n                            s[i] = old\n                        else:\n                            improved = True\n            # If highest no longer used, break\n            if highest not in s:\n                break\n    # Relabel colors to compact 1..m\n    mapping = {}\n    nxt = 1\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    s = [mapping[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00077331}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1:\n            return 10**9\n    # Problem data embedded\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"Invalid\", \"No-Op\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"Invalid\", \"No-Op\")\n    s = solution[:]\n    n = 9\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    def fitness(sol: List[int]) -> int:\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * 1000 + len(set(sol))\n    # Choose a random vertex to recolor\n    v = random.randrange(n)\n    # Candidate colors: existing colors plus (with small prob) a new color\n    colors = sorted(set(s))\n    max_color = max(colors) if colors else 1\n    candidate_colors = colors[:]\n    if random.random() < 0.2:\n        candidate_colors.append(max_color + 1)\n    # Evaluate recolor moves\n    best_col = s[v]\n    best_fit = fitness(s)\n    original_color = s[v]\n    random.shuffle(candidate_colors)\n    for col in candidate_colors:\n        if col == original_color:\n            continue\n        s[v] = col\n        f = fitness(s)\n        if f < best_fit:\n            best_fit = f\n            best_col = col\n    s[v] = best_col\n    # Optional post-step: relabel colors to 1..m compactly for stability\n    mapping = {}\n    nxt = 1\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    s = [mapping[c] for c in s]\n    return (s, \"AdjacentRecolor\", \"Single-Vertex-Recolor\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    edges = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    def fitness(sol: List[int]) -> int:\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        return conflicts * 1000 + len(set(sol))\n    # Apply k random recolors and occasional color-merge to escape local minima\n    k = 4\n    for _ in range(k):\n        v = random.randrange(n)\n        colors = sorted(set(s))\n        max_color = max(colors)\n        # Try a random existing color different from current; fallback keep\n        candidate = random.choice(colors)\n        if candidate == s[v]:\n            candidate = ((candidate) % max_color) + 1 if max_color > 1 else candidate\n        old = s[v]\n        s[v] = candidate\n        # Accept if not worse; otherwise revert with 50% probability\n        if fitness(s) > fitness(solution):\n            if random.random() < 0.5:\n                s[v] = old\n    # Attempt a greedy color compaction: try to reduce highest color\n    colors = sorted(set(s))\n    if len(colors) > 1:\n        highest = colors[-1]\n        for target in colors[:-1]:\n            improved = True\n            while improved:\n                improved = False\n                for i in range(n):\n                    if s[i] == highest:\n                        old = s[i]\n                        s[i] = target\n                        # Check conflicts only for affected vertex to speed up\n                        conflict = False\n                        for (u, v) in edges:\n                            a, b = u-1, v-1\n                            if a == i or b == i:\n                                if s[a] == s[b]:\n                                    conflict = True\n                                    break\n                        if conflict:\n                            s[i] = old\n                        else:\n                            improved = True\n            # If highest no longer used, break\n            if highest not in s:\n                break\n    # Relabel colors to compact 1..m\n    mapping = {}\n    nxt = 1\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    s = [mapping[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000749389}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Problem data embedded\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness with strong penalty for any violation\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple, Dict\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"Invalid\", \"No-Op\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"Invalid\", \"No-Op\")\n    s = solution[:]\n    n = 9\n    # Embedded graph\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: compute conflicts count fast\n    def count_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    # Current state metrics\n    current_conf = count_conflicts(s)\n    colors_set = set(s)\n    num_colors = len(colors_set)\n    # Choose move type: Kempe-chain (20%) or delta recolor (80%)\n    use_kempe = random.random() < 0.2\n    if use_kempe and num_colors >= 2:\n        # Pick a seed vertex; prefer conflicting vertices if any\n        conflicting_vertices = []\n        if current_conf > 0:\n            conflict_marks = [False]*n\n            for (u,v) in edges:\n                if s[u-1] == s[v-1]:\n                    conflict_marks[u-1] = True\n                    conflict_marks[v-1] = True\n            conflicting_vertices = [i for i in range(n) if conflict_marks[i]]\n        seed = random.choice(conflicting_vertices) if conflicting_vertices else random.randrange(n)\n        a = s[seed]\n        # Choose a second color b present in neighborhood or in the solution\n        neigh_colors = {s[v] for v in adj[seed]}\n        pool = list(neigh_colors | (colors_set - {a}))\n        if not pool:\n            pool = list(colors_set)\n        b = random.choice(pool)\n        if b == a:\n            # fallback to recolor if degenerate\n            use_kempe = False\n        else:\n            # BFS on subgraph induced by colors {a,b} starting from seed\n            from collections import deque\n            comp = []\n            seen = [False]*n\n            dq = deque([seed])\n            seen[seed] = True\n            while dq:\n                u = dq.popleft()\n                if s[u] == a or s[u] == b:\n                    comp.append(u)\n                    for w in adj[u]:\n                        if not seen[w] and (s[w] == a or s[w] == b):\n                            seen[w] = True\n                            dq.append(w)\n            # Propose swap a<->b on component\n            cand = s[:]\n            for u in comp:\n                if cand[u] == a:\n                    cand[u] = b\n                elif cand[u] == b:\n                    cand[u] = a\n            # Guard: when violations==0, do not increase color count\n            new_conf = count_conflicts(cand)\n            if current_conf == 0:\n                # color count unchanged by a<->b swap; safe\n                pass\n            # Accept swap if it improves or keeps equal with diversity chance\n            old_F = current_conf*1000 + num_colors\n            new_F = new_conf*1000 + len(set(cand))\n            if new_F <= old_F or random.random() < 0.1:\n                return (cand, \"KempeChain\", \"Swap-2-Colors-Component\")\n            # If rejected, fall through to recolor\n            s = s\n            use_kempe = False\n    # Vertex recolor with delta evaluation\n    # Choose vertex: if conflicts exist, pick from conflicting vertices with prob 0.8\n    conflict_marks = [False]*n\n    if current_conf > 0:\n        for (u,v) in edges:\n            if s[u-1] == s[v-1]:\n                conflict_marks[u-1] = True\n                conflict_marks[v-1] = True\n        conflict_vertices = [i for i in range(n) if conflict_marks[i]]\n        if random.random() < 0.8 and conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n    else:\n        v = random.randrange(n)\n    old_color = s[v]\n    # Candidate colors: existing colors; allow new color only if conflicts>0\n    candidate_colors = sorted(colors_set)\n    if current_conf > 0:\n        # Include one potential new color cautiously\n        mx = max(candidate_colors) if candidate_colors else 1\n        if random.random() < 0.1:\n            candidate_colors.append(mx+1)\n    # Prioritize colors seen in neighborhood to limit palette\n    neigh_colors = {s[w] for w in adj[v]}\n    ordered = list(neigh_colors) + [c for c in candidate_colors if c not in neigh_colors]\n    best_col = old_color\n    best_delta = 0  # \u0394F (new-old); we seek negative\n    # Precompute old conflicts involving v\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n    old_F_local = old_same*1000\n    for col in ordered:\n        if col == old_color:\n            continue\n        # Delta conflicts only around v\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = (new_same - old_same)\n        # Delta colors count\n        # If we change v's color, old_color may disappear; col may be new\n        col_set_after = colors_set\n        delta_colors = 0\n        lone_old = True\n        if old_color in colors_set:\n            # check if any other vertex uses old_color besides v\n            lone_old = True\n            for i in range(n):\n                if i != v and s[i] == old_color:\n                    lone_old = False\n                    break\n        # New color introduction\n        introduces_new = col not in colors_set\n        if introduces_new:\n            delta_colors += 1\n        if lone_old and col != old_color:\n            delta_colors -= 1\n        delta_F = delta_conf*1000 + delta_colors\n        # Guard: when no violations, do not accept moves that increase color count\n        if current_conf == 0 and (introduces_new and not lone_old):\n            continue\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n    cand = s[:]\n    cand[v] = best_col\n    move_type = \"VertexRecolor-Delta\"\n    return (cand, \"LocalMove\", move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    curr_conf = conflicts(s)\n    colors_set = set(s)\n    # Strength: 1 to 3 moves\n    steps = 1 + (0 if random.random()<0.5 else 1) + (0 if random.random()<0.3 else 1)\n    for _ in range(steps):\n        # Prefer Kempe-chain swap perturbation\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            # choose b from neighborhood or existing colors\n            neigh_colors = {s[v] for v in adj[seed]}\n            pool = list(neigh_colors | (colors_set - {a}))\n            if not pool:\n                pool = list(colors_set)\n            b = random.choice(pool)\n            if b != a:\n                # BFS component on colors {a,b}\n                from collections import deque\n                seen = [False]*n\n                dq = deque([seed])\n                seen[seed] = True\n                comp = []\n                while dq:\n                    u = dq.popleft()\n                    if s[u] == a or s[u] == b:\n                        comp.append(u)\n                        for w in adj[u]:\n                            if not seen[w] and (s[w] == a or s[w] == b):\n                                seen[w] = True\n                                dq.append(w)\n                for u in comp:\n                    s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Random recolor avoiding unnecessary new colors when feasible\n            v = random.randrange(n)\n            old = s[v]\n            candidate_colors = sorted(colors_set)\n            if curr_conf > 0 and random.random() < 0.2:\n                candidate_colors.append(max(candidate_colors)+1)\n            s[v] = random.choice(candidate_colors) if candidate_colors else 1\n            if s[v] == old and len(candidate_colors) > 1:\n                s[v] = candidate_colors[(candidate_colors.index(old)+1) % len(candidate_colors)]\n        colors_set = set(s)\n        curr_conf = conflicts(s)\n        # If currently feasible, avoid inflating colors by merging attempts\n        if curr_conf == 0 and len(colors_set) > 1 and random.random() < 0.5:\n            # Try move some vertices from highest color to lower if no conflict\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                # attempt to reassign a few highest-colored vertices\n                changed = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        conflict = False\n                        for w in adj[i]:\n                            if s[w] == target:\n                                conflict = True\n                                break\n                        if not conflict:\n                            s[i] = target\n                            changed += 1\n                        if changed >= 2:\n                            break\n            colors_set = set(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001218977}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Problem data embedded\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness with strong penalty for any violation\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple, Dict\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"Invalid\", \"No-Op\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"Invalid\", \"No-Op\")\n    s = solution[:]\n    n = 9\n    # Embedded graph\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: compute conflicts count fast\n    def count_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    # Current state metrics\n    current_conf = count_conflicts(s)\n    colors_set = set(s)\n    num_colors = len(colors_set)\n    # Choose move type: Kempe-chain (20%) or delta recolor (80%)\n    use_kempe = random.random() < 0.2\n    if use_kempe and num_colors >= 2:\n        # Pick a seed vertex; prefer conflicting vertices if any\n        conflicting_vertices = []\n        if current_conf > 0:\n            conflict_marks = [False]*n\n            for (u,v) in edges:\n                if s[u-1] == s[v-1]:\n                    conflict_marks[u-1] = True\n                    conflict_marks[v-1] = True\n            conflicting_vertices = [i for i in range(n) if conflict_marks[i]]\n        seed = random.choice(conflicting_vertices) if conflicting_vertices else random.randrange(n)\n        a = s[seed]\n        # Choose a second color b present in neighborhood or in the solution\n        neigh_colors = {s[v] for v in adj[seed]}\n        pool = list(neigh_colors | (colors_set - {a}))\n        if not pool:\n            pool = list(colors_set)\n        b = random.choice(pool)\n        if b == a:\n            # fallback to recolor if degenerate\n            use_kempe = False\n        else:\n            # BFS on subgraph induced by colors {a,b} starting from seed\n            from collections import deque\n            comp = []\n            seen = [False]*n\n            dq = deque([seed])\n            seen[seed] = True\n            while dq:\n                u = dq.popleft()\n                if s[u] == a or s[u] == b:\n                    comp.append(u)\n                    for w in adj[u]:\n                        if not seen[w] and (s[w] == a or s[w] == b):\n                            seen[w] = True\n                            dq.append(w)\n            # Propose swap a<->b on component\n            cand = s[:]\n            for u in comp:\n                if cand[u] == a:\n                    cand[u] = b\n                elif cand[u] == b:\n                    cand[u] = a\n            # Guard: when violations==0, do not increase color count\n            new_conf = count_conflicts(cand)\n            if current_conf == 0:\n                # color count unchanged by a<->b swap; safe\n                pass\n            # Accept swap if it improves or keeps equal with diversity chance\n            old_F = current_conf*1000 + num_colors\n            new_F = new_conf*1000 + len(set(cand))\n            if new_F <= old_F or random.random() < 0.1:\n                return (cand, \"KempeChain\", \"Swap-2-Colors-Component\")\n            # If rejected, fall through to recolor\n            s = s\n            use_kempe = False\n    # Vertex recolor with delta evaluation\n    # Choose vertex: if conflicts exist, pick from conflicting vertices with prob 0.8\n    conflict_marks = [False]*n\n    if current_conf > 0:\n        for (u,v) in edges:\n            if s[u-1] == s[v-1]:\n                conflict_marks[u-1] = True\n                conflict_marks[v-1] = True\n        conflict_vertices = [i for i in range(n) if conflict_marks[i]]\n        if random.random() < 0.8 and conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n    else:\n        v = random.randrange(n)\n    old_color = s[v]\n    # Candidate colors: existing colors; allow new color only if conflicts>0\n    candidate_colors = sorted(colors_set)\n    if current_conf > 0:\n        # Include one potential new color cautiously\n        mx = max(candidate_colors) if candidate_colors else 1\n        if random.random() < 0.1:\n            candidate_colors.append(mx+1)\n    # Prioritize colors seen in neighborhood to limit palette\n    neigh_colors = {s[w] for w in adj[v]}\n    ordered = list(neigh_colors) + [c for c in candidate_colors if c not in neigh_colors]\n    best_col = old_color\n    best_delta = 0  # \u0394F (new-old); we seek negative\n    # Precompute old conflicts involving v\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n    old_F_local = old_same*1000\n    for col in ordered:\n        if col == old_color:\n            continue\n        # Delta conflicts only around v\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = (new_same - old_same)\n        # Delta colors count\n        # If we change v's color, old_color may disappear; col may be new\n        col_set_after = colors_set\n        delta_colors = 0\n        lone_old = True\n        if old_color in colors_set:\n            # check if any other vertex uses old_color besides v\n            lone_old = True\n            for i in range(n):\n                if i != v and s[i] == old_color:\n                    lone_old = False\n                    break\n        # New color introduction\n        introduces_new = col not in colors_set\n        if introduces_new:\n            delta_colors += 1\n        if lone_old and col != old_color:\n            delta_colors -= 1\n        delta_F = delta_conf*1000 + delta_colors\n        # Guard: when no violations, do not accept moves that increase color count\n        if current_conf == 0 and (introduces_new and not lone_old):\n            continue\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n    cand = s[:]\n    cand[v] = best_col\n    move_type = \"VertexRecolor-Delta\"\n    return (cand, \"LocalMove\", move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    curr_conf = conflicts(s)\n    colors_set = set(s)\n    # Strength: 1 to 3 moves\n    steps = 1 + (0 if random.random()<0.5 else 1) + (0 if random.random()<0.3 else 1)\n    for _ in range(steps):\n        # Prefer Kempe-chain swap perturbation\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            # choose b from neighborhood or existing colors\n            neigh_colors = {s[v] for v in adj[seed]}\n            pool = list(neigh_colors | (colors_set - {a}))\n            if not pool:\n                pool = list(colors_set)\n            b = random.choice(pool)\n            if b != a:\n                # BFS component on colors {a,b}\n                from collections import deque\n                seen = [False]*n\n                dq = deque([seed])\n                seen[seed] = True\n                comp = []\n                while dq:\n                    u = dq.popleft()\n                    if s[u] == a or s[u] == b:\n                        comp.append(u)\n                        for w in adj[u]:\n                            if not seen[w] and (s[w] == a or s[w] == b):\n                                seen[w] = True\n                                dq.append(w)\n                for u in comp:\n                    s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Random recolor avoiding unnecessary new colors when feasible\n            v = random.randrange(n)\n            old = s[v]\n            candidate_colors = sorted(colors_set)\n            if curr_conf > 0 and random.random() < 0.2:\n                candidate_colors.append(max(candidate_colors)+1)\n            s[v] = random.choice(candidate_colors) if candidate_colors else 1\n            if s[v] == old and len(candidate_colors) > 1:\n                s[v] = candidate_colors[(candidate_colors.index(old)+1) % len(candidate_colors)]\n        colors_set = set(s)\n        curr_conf = conflicts(s)\n        # If currently feasible, avoid inflating colors by merging attempts\n        if curr_conf == 0 and len(colors_set) > 1 and random.random() < 0.5:\n            # Try move some vertices from highest color to lower if no conflict\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                # attempt to reassign a few highest-colored vertices\n                changed = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        conflict = False\n                        for w in adj[i]:\n                            if s[w] == target:\n                                conflict = True\n                                break\n                        if not conflict:\n                            s[i] = target\n                            changed += 1\n                        if changed >= 2:\n                            break\n            colors_set = set(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001569012}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Problem data embedded\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness with strong penalty for any violation\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import List, Tuple, Dict\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"Invalid\", \"No-Op\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"Invalid\", \"No-Op\")\n    s = solution[:]\n    n = 9\n    # Embedded graph\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Helper: compute conflicts count fast\n    def count_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    # Current state metrics\n    current_conf = count_conflicts(s)\n    colors_set = set(s)\n    num_colors = len(colors_set)\n    # Choose move type: Kempe-chain (20%) or delta recolor (80%)\n    use_kempe = random.random() < 0.2\n    if use_kempe and num_colors >= 2:\n        # Pick a seed vertex; prefer conflicting vertices if any\n        conflicting_vertices = []\n        if current_conf > 0:\n            conflict_marks = [False]*n\n            for (u,v) in edges:\n                if s[u-1] == s[v-1]:\n                    conflict_marks[u-1] = True\n                    conflict_marks[v-1] = True\n            conflicting_vertices = [i for i in range(n) if conflict_marks[i]]\n        seed = random.choice(conflicting_vertices) if conflicting_vertices else random.randrange(n)\n        a = s[seed]\n        # Choose a second color b present in neighborhood or in the solution\n        neigh_colors = {s[v] for v in adj[seed]}\n        pool = list(neigh_colors | (colors_set - {a}))\n        if not pool:\n            pool = list(colors_set)\n        b = random.choice(pool)\n        if b == a:\n            # fallback to recolor if degenerate\n            use_kempe = False\n        else:\n            # BFS on subgraph induced by colors {a,b} starting from seed\n            from collections import deque\n            comp = []\n            seen = [False]*n\n            dq = deque([seed])\n            seen[seed] = True\n            while dq:\n                u = dq.popleft()\n                if s[u] == a or s[u] == b:\n                    comp.append(u)\n                    for w in adj[u]:\n                        if not seen[w] and (s[w] == a or s[w] == b):\n                            seen[w] = True\n                            dq.append(w)\n            # Propose swap a<->b on component\n            cand = s[:]\n            for u in comp:\n                if cand[u] == a:\n                    cand[u] = b\n                elif cand[u] == b:\n                    cand[u] = a\n            # Guard: when violations==0, do not increase color count\n            new_conf = count_conflicts(cand)\n            if current_conf == 0:\n                # color count unchanged by a<->b swap; safe\n                pass\n            # Accept swap if it improves or keeps equal with diversity chance\n            old_F = current_conf*1000 + num_colors\n            new_F = new_conf*1000 + len(set(cand))\n            if new_F <= old_F or random.random() < 0.1:\n                return (cand, \"KempeChain\", \"Swap-2-Colors-Component\")\n            # If rejected, fall through to recolor\n            s = s\n            use_kempe = False\n    # Vertex recolor with delta evaluation\n    # Choose vertex: if conflicts exist, pick from conflicting vertices with prob 0.8\n    conflict_marks = [False]*n\n    if current_conf > 0:\n        for (u,v) in edges:\n            if s[u-1] == s[v-1]:\n                conflict_marks[u-1] = True\n                conflict_marks[v-1] = True\n        conflict_vertices = [i for i in range(n) if conflict_marks[i]]\n        if random.random() < 0.8 and conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n    else:\n        v = random.randrange(n)\n    old_color = s[v]\n    # Candidate colors: existing colors; allow new color only if conflicts>0\n    candidate_colors = sorted(colors_set)\n    if current_conf > 0:\n        # Include one potential new color cautiously\n        mx = max(candidate_colors) if candidate_colors else 1\n        if random.random() < 0.1:\n            candidate_colors.append(mx+1)\n    # Prioritize colors seen in neighborhood to limit palette\n    neigh_colors = {s[w] for w in adj[v]}\n    ordered = list(neigh_colors) + [c for c in candidate_colors if c not in neigh_colors]\n    best_col = old_color\n    best_delta = 0  # \u0394F (new-old); we seek negative\n    # Precompute old conflicts involving v\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n    old_F_local = old_same*1000\n    for col in ordered:\n        if col == old_color:\n            continue\n        # Delta conflicts only around v\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = (new_same - old_same)\n        # Delta colors count\n        # If we change v's color, old_color may disappear; col may be new\n        col_set_after = colors_set\n        delta_colors = 0\n        lone_old = True\n        if old_color in colors_set:\n            # check if any other vertex uses old_color besides v\n            lone_old = True\n            for i in range(n):\n                if i != v and s[i] == old_color:\n                    lone_old = False\n                    break\n        # New color introduction\n        introduces_new = col not in colors_set\n        if introduces_new:\n            delta_colors += 1\n        if lone_old and col != old_color:\n            delta_colors -= 1\n        delta_F = delta_conf*1000 + delta_colors\n        # Guard: when no violations, do not accept moves that increase color count\n        if current_conf == 0 and (introduces_new and not lone_old):\n            continue\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n    cand = s[:]\n    cand[v] = best_col\n    move_type = \"VertexRecolor-Delta\"\n    return (cand, \"LocalMove\", move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    )\n    # Build adjacency\n    adj: List[List[int]] = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    def conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                c += 1\n        return c\n    curr_conf = conflicts(s)\n    colors_set = set(s)\n    # Strength: 1 to 3 moves\n    steps = 1 + (0 if random.random()<0.5 else 1) + (0 if random.random()<0.3 else 1)\n    for _ in range(steps):\n        # Prefer Kempe-chain swap perturbation\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            # choose b from neighborhood or existing colors\n            neigh_colors = {s[v] for v in adj[seed]}\n            pool = list(neigh_colors | (colors_set - {a}))\n            if not pool:\n                pool = list(colors_set)\n            b = random.choice(pool)\n            if b != a:\n                # BFS component on colors {a,b}\n                from collections import deque\n                seen = [False]*n\n                dq = deque([seed])\n                seen[seed] = True\n                comp = []\n                while dq:\n                    u = dq.popleft()\n                    if s[u] == a or s[u] == b:\n                        comp.append(u)\n                        for w in adj[u]:\n                            if not seen[w] and (s[w] == a or s[w] == b):\n                                seen[w] = True\n                                dq.append(w)\n                for u in comp:\n                    s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Random recolor avoiding unnecessary new colors when feasible\n            v = random.randrange(n)\n            old = s[v]\n            candidate_colors = sorted(colors_set)\n            if curr_conf > 0 and random.random() < 0.2:\n                candidate_colors.append(max(candidate_colors)+1)\n            s[v] = random.choice(candidate_colors) if candidate_colors else 1\n            if s[v] == old and len(candidate_colors) > 1:\n                s[v] = candidate_colors[(candidate_colors.index(old)+1) % len(candidate_colors)]\n        colors_set = set(s)\n        curr_conf = conflicts(s)\n        # If currently feasible, avoid inflating colors by merging attempts\n        if curr_conf == 0 and len(colors_set) > 1 and random.random() < 0.5:\n            # Try move some vertices from highest color to lower if no conflict\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                # attempt to reassign a few highest-colored vertices\n                changed = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        conflict = False\n                        for w in adj[i]:\n                            if s[w] == target:\n                                conflict = True\n                                break\n                        if not conflict:\n                            s[i] = target\n                            changed += 1\n                        if changed >= 2:\n                            break\n            colors_set = set(s)\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001569431}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Problem data embedded (1-based vertices in spec; use 0-based here)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness with strong penalty for any violation\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"InvalidInput\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"InvalidInput\")\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Build adjacency once per call\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    current_conf = count_conflicts(s)\n    colors_set = set(s)\n\n    # Try Kempe-chain with some probability for diversification\n    if random.random() < 0.35 and len(colors_set) >= 2:\n        seed = random.randrange(n)\n        a = s[seed]\n        neigh_colors = {s[v] for v in adj[seed]}\n        pool = list((colors_set - {a}) | neigh_colors)\n        if not pool:\n            pool = list(colors_set)\n        b = random.choice(pool)\n        if b != a:\n            # BFS component on colors {a,b}\n            from collections import deque\n            seen = [False] * n\n            dq = deque([seed])\n            seen[seed] = True\n            comp = []\n            while dq:\n                u = dq.popleft()\n                if s[u] == a or s[u] == b:\n                    comp.append(u)\n                    for w in adj[u]:\n                        if not seen[w] and (s[w] == a or s[w] == b):\n                            seen[w] = True\n                            dq.append(w)\n            cand = s[:]\n            for u in comp:\n                cand[u] = b if cand[u] == a else (a if cand[u] == b else cand[u])\n            # Guard: if currently feasible, avoid increasing number of colors (swap keeps palette size)\n            return (cand, \"KempeSwap\")\n\n    # Otherwise do a vertex recolor\n    # Prefer conflicting vertices if any\n    v = random.randrange(n)\n    if current_conf > 0:\n        conflict_marks = [False] * n\n        for (u, w) in edges:\n            if s[u] == s[w]:\n                conflict_marks[u] = True\n                conflict_marks[w] = True\n        conflicted = [i for i in range(n) if conflict_marks[i]]\n        if conflicted and random.random() < 0.85:\n            v = random.choice(conflicted)\n    old_color = s[v]\n\n    # Candidate colors: existing colors; optionally allow new color when infeasible\n    candidate_colors = sorted(colors_set)\n    if current_conf > 0 and random.random() < 0.1:\n        candidate_colors.append((max(candidate_colors) if candidate_colors else 1) + 1)\n\n    # Order: neighbor colors first to limit palette growth\n    neigh_colors = {s[w] for w in adj[v]}\n    ordered = list(neigh_colors) + [c for c in candidate_colors if c not in neigh_colors]\n    if not ordered:\n        ordered = [old_color]\n\n    # Choose a color that reduces conflicts if possible, else random from ordered (diversity)\n    best_col = old_color\n    best_delta = 10**9\n\n    # Compute old same-color conflicts involving v\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n\n    for col in ordered:\n        if col == old_color:\n            continue\n        # If currently feasible, never introduce a new color different from old_color if that increases palette\n        if current_conf == 0 and (col not in colors_set) and any((i != v and s[i] == old_color) for i in range(n)):\n            continue\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = new_same - old_same\n        # Delta colors count\n        introduces_new = col not in colors_set\n        removes_old = all((i == v or s[i] != old_color) for i in range(n))\n        delta_colors = (1 if introduces_new else 0) - (1 if removes_old else 0)\n        delta_F = delta_conf * 1000 + delta_colors\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n\n    cand = s[:]\n    if best_col == old_color:\n        # fallback random different color if possible\n        alt = [c for c in ordered if c != old_color]\n        if alt:\n            best_col = random.choice(alt)\n    cand[v] = best_col\n\n    return (cand, \"VertexRecolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    curr_conf = conflicts(s)\n    colors_set = set(s)\n\n    # Apply a small number of disruptive moves\n    steps = 2 + (1 if random.random() < 0.6 else 0)\n    for _ in range(steps):\n        # Prefer Kempe swaps for structure-preserving perturbations\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            neigh_colors = {s[v] for v in adj[seed]}\n            pool = list((colors_set - {a}) | neigh_colors)\n            if not pool:\n                pool = list(colors_set)\n            b = random.choice(pool)\n            if b != a:\n                from collections import deque\n                seen = [False] * n\n                dq = deque([seed])\n                seen[seed] = True\n                comp = []\n                while dq:\n                    u = dq.popleft()\n                    if s[u] == a or s[u] == b:\n                        comp.append(u)\n                        for w in adj[u]:\n                            if not seen[w] and (s[w] == a or s[w] == b):\n                                seen[w] = True\n                                dq.append(w)\n                for u in comp:\n                    s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Random recolor, sometimes allowing a new color only if infeasible\n            v = random.randrange(n)\n            old = s[v]\n            candidate_colors = sorted(colors_set)\n            if curr_conf > 0 and random.random() < 0.25:\n                candidate_colors.append((max(candidate_colors) if candidate_colors else 1) + 1)\n            s[v] = random.choice(candidate_colors) if candidate_colors else 1\n            if s[v] == old and len(candidate_colors) > 1:\n                s[v] = candidate_colors[(candidate_colors.index(old) + 1) % len(candidate_colors)]\n\n        colors_set = set(s)\n        curr_conf = conflicts(s)\n\n        # If feasible, attempt to merge highest color down to reduce palette inflation\n        if curr_conf == 0 and len(colors_set) > 1 and random.random() < 0.5:\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                changes = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        conflict = False\n                        for w in adj[i]:\n                            if s[w] == target:\n                                conflict = True\n                                break\n                        if not conflict:\n                            s[i] = target\n                            changes += 1\n                        if changes >= 2:\n                            break\n            colors_set = set(s)\n            curr_conf = conflicts(s)\n\n    return s\n","Resultados":["[1, 1, 2, 1, 1, 3, 3, 2, 2]",1000000000.0,"[1, 1, 2, 1, 1, 3, 3, 2, 2]",1000000000.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001025074}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Problem data embedded (1-based vertices in spec; use 0-based here)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness with strong penalty for any violation\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"InvalidInput\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"InvalidInput\")\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Build adjacency once per call\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    current_conf = count_conflicts(s)\n    colors_set = set(s)\n\n    # Try Kempe-chain with some probability for diversification\n    if random.random() < 0.35 and len(colors_set) >= 2:\n        seed = random.randrange(n)\n        a = s[seed]\n        neigh_colors = {s[v] for v in adj[seed]}\n        pool = list((colors_set - {a}) | neigh_colors)\n        if not pool:\n            pool = list(colors_set)\n        b = random.choice(pool)\n        if b != a:\n            # BFS component on colors {a,b}\n            from collections import deque\n            seen = [False] * n\n            dq = deque([seed])\n            seen[seed] = True\n            comp = []\n            while dq:\n                u = dq.popleft()\n                if s[u] == a or s[u] == b:\n                    comp.append(u)\n                    for w in adj[u]:\n                        if not seen[w] and (s[w] == a or s[w] == b):\n                            seen[w] = True\n                            dq.append(w)\n            cand = s[:]\n            for u in comp:\n                cand[u] = b if cand[u] == a else (a if cand[u] == b else cand[u])\n            # Guard: if currently feasible, avoid increasing number of colors (swap keeps palette size)\n            return (cand, \"KempeSwap\")\n\n    # Otherwise do a vertex recolor\n    # Prefer conflicting vertices if any\n    v = random.randrange(n)\n    if current_conf > 0:\n        conflict_marks = [False] * n\n        for (u, w) in edges:\n            if s[u] == s[w]:\n                conflict_marks[u] = True\n                conflict_marks[w] = True\n        conflicted = [i for i in range(n) if conflict_marks[i]]\n        if conflicted and random.random() < 0.85:\n            v = random.choice(conflicted)\n    old_color = s[v]\n\n    # Candidate colors: existing colors; optionally allow new color when infeasible\n    candidate_colors = sorted(colors_set)\n    if current_conf > 0 and random.random() < 0.1:\n        candidate_colors.append((max(candidate_colors) if candidate_colors else 1) + 1)\n\n    # Order: neighbor colors first to limit palette growth\n    neigh_colors = {s[w] for w in adj[v]}\n    ordered = list(neigh_colors) + [c for c in candidate_colors if c not in neigh_colors]\n    if not ordered:\n        ordered = [old_color]\n\n    # Choose a color that reduces conflicts if possible, else random from ordered (diversity)\n    best_col = old_color\n    best_delta = 10**9\n\n    # Compute old same-color conflicts involving v\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n\n    for col in ordered:\n        if col == old_color:\n            continue\n        # If currently feasible, never introduce a new color different from old_color if that increases palette\n        if current_conf == 0 and (col not in colors_set) and any((i != v and s[i] == old_color) for i in range(n)):\n            continue\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = new_same - old_same\n        # Delta colors count\n        introduces_new = col not in colors_set\n        removes_old = all((i == v or s[i] != old_color) for i in range(n))\n        delta_colors = (1 if introduces_new else 0) - (1 if removes_old else 0)\n        delta_F = delta_conf * 1000 + delta_colors\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n\n    cand = s[:]\n    if best_col == old_color:\n        # fallback random different color if possible\n        alt = [c for c in ordered if c != old_color]\n        if alt:\n            best_col = random.choice(alt)\n    cand[v] = best_col\n\n    return (cand, \"VertexRecolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    curr_conf = conflicts(s)\n    colors_set = set(s)\n\n    # Apply a small number of disruptive moves\n    steps = 2 + (1 if random.random() < 0.6 else 0)\n    for _ in range(steps):\n        # Prefer Kempe swaps for structure-preserving perturbations\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            neigh_colors = {s[v] for v in adj[seed]}\n            pool = list((colors_set - {a}) | neigh_colors)\n            if not pool:\n                pool = list(colors_set)\n            b = random.choice(pool)\n            if b != a:\n                from collections import deque\n                seen = [False] * n\n                dq = deque([seed])\n                seen[seed] = True\n                comp = []\n                while dq:\n                    u = dq.popleft()\n                    if s[u] == a or s[u] == b:\n                        comp.append(u)\n                        for w in adj[u]:\n                            if not seen[w] and (s[w] == a or s[w] == b):\n                                seen[w] = True\n                                dq.append(w)\n                for u in comp:\n                    s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Random recolor, sometimes allowing a new color only if infeasible\n            v = random.randrange(n)\n            old = s[v]\n            candidate_colors = sorted(colors_set)\n            if curr_conf > 0 and random.random() < 0.25:\n                candidate_colors.append((max(candidate_colors) if candidate_colors else 1) + 1)\n            s[v] = random.choice(candidate_colors) if candidate_colors else 1\n            if s[v] == old and len(candidate_colors) > 1:\n                s[v] = candidate_colors[(candidate_colors.index(old) + 1) % len(candidate_colors)]\n\n        colors_set = set(s)\n        curr_conf = conflicts(s)\n\n        # If feasible, attempt to merge highest color down to reduce palette inflation\n        if curr_conf == 0 and len(colors_set) > 1 and random.random() < 0.5:\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                changes = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        conflict = False\n                        for w in adj[i]:\n                            if s[w] == target:\n                                conflict = True\n                                break\n                        if not conflict:\n                            s[i] = target\n                            changes += 1\n                        if changes >= 2:\n                            break\n            colors_set = set(s)\n            curr_conf = conflicts(s)\n\n    return s\n","Resultados":["[1, 1, 2, 1, 1, 3, 3, 2, 2]",1000000000.0,"[1, 1, 2, 1, 1, 3, 3, 2, 2]",1000000000.0],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001355538}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type and structure\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Problem data embedded (1-based vertices in spec; use 0-based here)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Number of used colors\n    num_colors = len(set(solution))\n    # Fitness with strong penalty for any violation\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"InvalidInput\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"InvalidInput\")\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Build adjacency once per call\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    current_conf = count_conflicts(s)\n    colors_set = set(s)\n\n    # Try Kempe-chain with some probability for diversification\n    if random.random() < 0.35 and len(colors_set) >= 2:\n        seed = random.randrange(n)\n        a = s[seed]\n        neigh_colors = {s[v] for v in adj[seed]}\n        pool = list((colors_set - {a}) | neigh_colors)\n        if not pool:\n            pool = list(colors_set)\n        b = random.choice(pool)\n        if b != a:\n            # BFS component on colors {a,b}\n            from collections import deque\n            seen = [False] * n\n            dq = deque([seed])\n            seen[seed] = True\n            comp = []\n            while dq:\n                u = dq.popleft()\n                if s[u] == a or s[u] == b:\n                    comp.append(u)\n                    for w in adj[u]:\n                        if not seen[w] and (s[w] == a or s[w] == b):\n                            seen[w] = True\n                            dq.append(w)\n            cand = s[:]\n            for u in comp:\n                cand[u] = b if cand[u] == a else (a if cand[u] == b else cand[u])\n            # Guard: if currently feasible, avoid increasing number of colors (swap keeps palette size)\n            return (cand, \"KempeSwap\")\n\n    # Otherwise do a vertex recolor\n    # Prefer conflicting vertices if any\n    v = random.randrange(n)\n    if current_conf > 0:\n        conflict_marks = [False] * n\n        for (u, w) in edges:\n            if s[u] == s[w]:\n                conflict_marks[u] = True\n                conflict_marks[w] = True\n        conflicted = [i for i in range(n) if conflict_marks[i]]\n        if conflicted and random.random() < 0.85:\n            v = random.choice(conflicted)\n    old_color = s[v]\n\n    # Candidate colors: existing colors; optionally allow new color when infeasible\n    candidate_colors = sorted(colors_set)\n    if current_conf > 0 and random.random() < 0.1:\n        candidate_colors.append((max(candidate_colors) if candidate_colors else 1) + 1)\n\n    # Order: neighbor colors first to limit palette growth\n    neigh_colors = {s[w] for w in adj[v]}\n    ordered = list(neigh_colors) + [c for c in candidate_colors if c not in neigh_colors]\n    if not ordered:\n        ordered = [old_color]\n\n    # Choose a color that reduces conflicts if possible, else random from ordered (diversity)\n    best_col = old_color\n    best_delta = 10**9\n\n    # Compute old same-color conflicts involving v\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n\n    for col in ordered:\n        if col == old_color:\n            continue\n        # If currently feasible, never introduce a new color different from old_color if that increases palette\n        if current_conf == 0 and (col not in colors_set) and any((i != v and s[i] == old_color) for i in range(n)):\n            continue\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = new_same - old_same\n        # Delta colors count\n        introduces_new = col not in colors_set\n        removes_old = all((i == v or s[i] != old_color) for i in range(n))\n        delta_colors = (1 if introduces_new else 0) - (1 if removes_old else 0)\n        delta_F = delta_conf * 1000 + delta_colors\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n\n    cand = s[:]\n    if best_col == old_color:\n        # fallback random different color if possible\n        alt = [c for c in ordered if c != old_color]\n        if alt:\n            best_col = random.choice(alt)\n    cand[v] = best_col\n\n    return (cand, \"VertexRecolor\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    curr_conf = conflicts(s)\n    colors_set = set(s)\n\n    # Apply a small number of disruptive moves\n    steps = 2 + (1 if random.random() < 0.6 else 0)\n    for _ in range(steps):\n        # Prefer Kempe swaps for structure-preserving perturbations\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            neigh_colors = {s[v] for v in adj[seed]}\n            pool = list((colors_set - {a}) | neigh_colors)\n            if not pool:\n                pool = list(colors_set)\n            b = random.choice(pool)\n            if b != a:\n                from collections import deque\n                seen = [False] * n\n                dq = deque([seed])\n                seen[seed] = True\n                comp = []\n                while dq:\n                    u = dq.popleft()\n                    if s[u] == a or s[u] == b:\n                        comp.append(u)\n                        for w in adj[u]:\n                            if not seen[w] and (s[w] == a or s[w] == b):\n                                seen[w] = True\n                                dq.append(w)\n                for u in comp:\n                    s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Random recolor, sometimes allowing a new color only if infeasible\n            v = random.randrange(n)\n            old = s[v]\n            candidate_colors = sorted(colors_set)\n            if curr_conf > 0 and random.random() < 0.25:\n                candidate_colors.append((max(candidate_colors) if candidate_colors else 1) + 1)\n            s[v] = random.choice(candidate_colors) if candidate_colors else 1\n            if s[v] == old and len(candidate_colors) > 1:\n                s[v] = candidate_colors[(candidate_colors.index(old) + 1) % len(candidate_colors)]\n\n        colors_set = set(s)\n        curr_conf = conflicts(s)\n\n        # If feasible, attempt to merge highest color down to reduce palette inflation\n        if curr_conf == 0 and len(colors_set) > 1 and random.random() < 0.5:\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                changes = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        conflict = False\n                        for w in adj[i]:\n                            if s[w] == target:\n                                conflict = True\n                                break\n                        if not conflict:\n                            s[i] = target\n                            changes += 1\n                        if changes >= 2:\n                            break\n            colors_set = set(s)\n            curr_conf = conflicts(s)\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001426149}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type and structure validation\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Embedded graph, 0-based indexing\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Count violations\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Color count\n    num_colors = len(set(solution))\n    # Fitness\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"InvalidInput\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"InvalidInput\")\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        col = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == col)\n\n    colors_set = set(s)\n    total_conf = count_conflicts(s)\n\n    # Strategy: if conflicts exist, pick the vertex with maximum same-color conflicts\n    # else use DSATUR-inspired choice (max saturation degree, tie by degree)\n    if total_conf > 0:\n        best_v = 0\n        best_c = -1\n        for v in range(n):\n            vc = vertex_conflicts(s, v)\n            if vc > best_c:\n                best_c = vc\n                best_v = v\n        v = best_v\n    else:\n        # DSATUR heuristic selection when feasible: try to reduce palette without creating conflicts\n        best_v = 0\n        best_key = (-1, -1)\n        for v in range(n):\n            neigh_cols = {s[w] for w in adj[v]}\n            sat = len(neigh_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        v = best_v\n\n    old_color = s[v]\n\n    # Candidate colors: prefer neighbor colors to limit palette, then existing others; allow new color only if infeasible\n    neigh_colors = {s[w] for w in adj[v]}\n    candidate_colors = list(neigh_colors) + [c for c in sorted(colors_set) if c not in neigh_colors and c != old_color]\n    if total_conf > 0:\n        # With small probability allow adding a new color for diversification\n        if random.random() < 0.05:\n            candidate_colors.append((max(colors_set) if colors_set else 1) + 1)\n    # Ensure at least one candidate different from old_color\n    if not candidate_colors:\n        # fallback keep same if no alternative\n        return (s, \"NoOp\")\n\n    # Evaluate delta cost for each candidate color\n    best_col = old_color\n    best_delta = 10**18\n\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n\n    for col in candidate_colors:\n        if col == old_color:\n            continue\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = new_same - old_same\n        introduces_new = col not in colors_set\n        removes_old = all((i == v or s[i] != old_color) for i in range(n))\n        delta_colors = (1 if introduces_new else 0) - (1 if removes_old else 0)\n        delta_F = delta_conf * 1000 + delta_colors\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n\n    cand = s[:]\n    if best_col == old_color:\n        # Diversification Kempe swap attempt only if at least two colors exist\n        if len(colors_set) >= 2:\n            seed = v\n            a = s[seed]\n            pool = list((colors_set - {a}) | {s[w] for w in adj[seed]})\n            if pool:\n                b = random.choice(pool)\n                if b != a:\n                    from collections import deque\n                    seen = [False] * n\n                    dq = deque([seed])\n                    seen[seed] = True\n                    comp = []\n                    while dq:\n                        u = dq.popleft()\n                        if s[u] == a or s[u] == b:\n                            comp.append(u)\n                            for w in adj[u]:\n                                if not seen[w] and (s[w] == a or s[w] == b):\n                                    seen[w] = True\n                                    dq.append(w)\n                    cand = s[:]\n                    for u in comp:\n                        cand[u] = b if cand[u] == a else (a if cand[u] == b else cand[u])\n                    return (cand, \"KempeSwap\")\n        # If no Kempe applied, attempt random different color if available\n        alts = [c for c in sorted(colors_set) if c != old_color]\n        if alts:\n            cand[v] = random.choice(alts)\n            return (cand, \"VertexRecolorRnd\")\n        else:\n            return (s, \"NoOp\")\n    else:\n        cand[v] = best_col\n        return (cand, \"VertexRecolorBest\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    rng_steps = 2 + (1 if random.random() < 0.5 else 0)\n    colors_set = set(s)\n\n    for _ in range(rng_steps):\n        # Prefer Kempe chain shuffles to preserve palette but change structure\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            pool = list((colors_set - {a}) | {s[w] for w in adj[seed]})\n            if pool:\n                b = random.choice(pool)\n                if a != b:\n                    from collections import deque\n                    seen = [False] * n\n                    dq = deque([seed])\n                    seen[seed] = True\n                    comp = []\n                    while dq:\n                        u = dq.popleft()\n                        if s[u] == a or s[u] == b:\n                            comp.append(u)\n                            for w in adj[u]:\n                                if not seen[w] and (s[w] == a or s[w] == b):\n                                    seen[w] = True\n                                    dq.append(w)\n                    for u in comp:\n                        s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Targeted recolor of a high-conflict vertex, avoid introducing new colors\n            # Identify vertex with max same-color conflicts\n            best_v = 0\n            best_c = -1\n            for v in range(n):\n                c = 0\n                col = s[v]\n                for w in adj[v]:\n                    if s[w] == col:\n                        c += 1\n                if c > best_c:\n                    best_c = c\n                    best_v = v\n            v = best_v\n            old = s[v]\n            neigh_cols = {s[w] for w in adj[v]}\n            cand_cols = list(neigh_cols) + [c for c in sorted(colors_set) if c not in neigh_cols and c != old]\n            if cand_cols:\n                s[v] = random.choice(cand_cols)\n        colors_set = set(s)\n\n        # If feasible, attempt controlled palette merge (reduce highest color when safe)\n        if conflicts(s) == 0 and len(colors_set) > 1 and random.random() < 0.6:\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                changed = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        if all(s[w] != target for w in adj[i]):\n                            s[i] = target\n                            changed += 1\n                        if changed >= 2:\n                            break\n            colors_set = set(s)\n\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001111775}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type and structure validation\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Embedded graph, 0-based indexing\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Count violations\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Color count\n    num_colors = len(set(solution))\n    # Fitness\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"InvalidInput\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"InvalidInput\")\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        col = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == col)\n\n    colors_set = set(s)\n    total_conf = count_conflicts(s)\n\n    # Strategy: if conflicts exist, pick the vertex with maximum same-color conflicts\n    # else use DSATUR-inspired choice (max saturation degree, tie by degree)\n    if total_conf > 0:\n        best_v = 0\n        best_c = -1\n        for v in range(n):\n            vc = vertex_conflicts(s, v)\n            if vc > best_c:\n                best_c = vc\n                best_v = v\n        v = best_v\n    else:\n        # DSATUR heuristic selection when feasible: try to reduce palette without creating conflicts\n        best_v = 0\n        best_key = (-1, -1)\n        for v in range(n):\n            neigh_cols = {s[w] for w in adj[v]}\n            sat = len(neigh_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        v = best_v\n\n    old_color = s[v]\n\n    # Candidate colors: prefer neighbor colors to limit palette, then existing others; allow new color only if infeasible\n    neigh_colors = {s[w] for w in adj[v]}\n    candidate_colors = list(neigh_colors) + [c for c in sorted(colors_set) if c not in neigh_colors and c != old_color]\n    if total_conf > 0:\n        # With small probability allow adding a new color for diversification\n        if random.random() < 0.05:\n            candidate_colors.append((max(colors_set) if colors_set else 1) + 1)\n    # Ensure at least one candidate different from old_color\n    if not candidate_colors:\n        # fallback keep same if no alternative\n        return (s, \"NoOp\")\n\n    # Evaluate delta cost for each candidate color\n    best_col = old_color\n    best_delta = 10**18\n\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n\n    for col in candidate_colors:\n        if col == old_color:\n            continue\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = new_same - old_same\n        introduces_new = col not in colors_set\n        removes_old = all((i == v or s[i] != old_color) for i in range(n))\n        delta_colors = (1 if introduces_new else 0) - (1 if removes_old else 0)\n        delta_F = delta_conf * 1000 + delta_colors\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n\n    cand = s[:]\n    if best_col == old_color:\n        # Diversification Kempe swap attempt only if at least two colors exist\n        if len(colors_set) >= 2:\n            seed = v\n            a = s[seed]\n            pool = list((colors_set - {a}) | {s[w] for w in adj[seed]})\n            if pool:\n                b = random.choice(pool)\n                if b != a:\n                    from collections import deque\n                    seen = [False] * n\n                    dq = deque([seed])\n                    seen[seed] = True\n                    comp = []\n                    while dq:\n                        u = dq.popleft()\n                        if s[u] == a or s[u] == b:\n                            comp.append(u)\n                            for w in adj[u]:\n                                if not seen[w] and (s[w] == a or s[w] == b):\n                                    seen[w] = True\n                                    dq.append(w)\n                    cand = s[:]\n                    for u in comp:\n                        cand[u] = b if cand[u] == a else (a if cand[u] == b else cand[u])\n                    return (cand, \"KempeSwap\")\n        # If no Kempe applied, attempt random different color if available\n        alts = [c for c in sorted(colors_set) if c != old_color]\n        if alts:\n            cand[v] = random.choice(alts)\n            return (cand, \"VertexRecolorRnd\")\n        else:\n            return (s, \"NoOp\")\n    else:\n        cand[v] = best_col\n        return (cand, \"VertexRecolorBest\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    rng_steps = 2 + (1 if random.random() < 0.5 else 0)\n    colors_set = set(s)\n\n    for _ in range(rng_steps):\n        # Prefer Kempe chain shuffles to preserve palette but change structure\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            pool = list((colors_set - {a}) | {s[w] for w in adj[seed]})\n            if pool:\n                b = random.choice(pool)\n                if a != b:\n                    from collections import deque\n                    seen = [False] * n\n                    dq = deque([seed])\n                    seen[seed] = True\n                    comp = []\n                    while dq:\n                        u = dq.popleft()\n                        if s[u] == a or s[u] == b:\n                            comp.append(u)\n                            for w in adj[u]:\n                                if not seen[w] and (s[w] == a or s[w] == b):\n                                    seen[w] = True\n                                    dq.append(w)\n                    for u in comp:\n                        s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Targeted recolor of a high-conflict vertex, avoid introducing new colors\n            # Identify vertex with max same-color conflicts\n            best_v = 0\n            best_c = -1\n            for v in range(n):\n                c = 0\n                col = s[v]\n                for w in adj[v]:\n                    if s[w] == col:\n                        c += 1\n                if c > best_c:\n                    best_c = c\n                    best_v = v\n            v = best_v\n            old = s[v]\n            neigh_cols = {s[w] for w in adj[v]}\n            cand_cols = list(neigh_cols) + [c for c in sorted(colors_set) if c not in neigh_cols and c != old]\n            if cand_cols:\n                s[v] = random.choice(cand_cols)\n        colors_set = set(s)\n\n        # If feasible, attempt controlled palette merge (reduce highest color when safe)\n        if conflicts(s) == 0 and len(colors_set) > 1 and random.random() < 0.6:\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                changed = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        if all(s[w] != target for w in adj[i]):\n                            s[i] = target\n                            changed += 1\n                        if changed >= 2:\n                            break\n            colors_set = set(s)\n\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001377638}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type and structure validation\n    if not isinstance(solution, list):\n        return float(10**9)\n    n = 9\n    if len(solution) != n:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(10**9)\n    # Embedded graph, 0-based indexing\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    # Count violations\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Color count\n    num_colors = len(set(solution))\n    # Fitness\n    fitness = conflicts * 1000 + num_colors\n    return float(fitness)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"InvalidInput\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"InvalidInput\")\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        col = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == col)\n\n    colors_set = set(s)\n    total_conf = count_conflicts(s)\n\n    # Strategy: if conflicts exist, pick the vertex with maximum same-color conflicts\n    # else use DSATUR-inspired choice (max saturation degree, tie by degree)\n    if total_conf > 0:\n        best_v = 0\n        best_c = -1\n        for v in range(n):\n            vc = vertex_conflicts(s, v)\n            if vc > best_c:\n                best_c = vc\n                best_v = v\n        v = best_v\n    else:\n        # DSATUR heuristic selection when feasible: try to reduce palette without creating conflicts\n        best_v = 0\n        best_key = (-1, -1)\n        for v in range(n):\n            neigh_cols = {s[w] for w in adj[v]}\n            sat = len(neigh_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        v = best_v\n\n    old_color = s[v]\n\n    # Candidate colors: prefer neighbor colors to limit palette, then existing others; allow new color only if infeasible\n    neigh_colors = {s[w] for w in adj[v]}\n    candidate_colors = list(neigh_colors) + [c for c in sorted(colors_set) if c not in neigh_colors and c != old_color]\n    if total_conf > 0:\n        # With small probability allow adding a new color for diversification\n        if random.random() < 0.05:\n            candidate_colors.append((max(colors_set) if colors_set else 1) + 1)\n    # Ensure at least one candidate different from old_color\n    if not candidate_colors:\n        # fallback keep same if no alternative\n        return (s, \"NoOp\")\n\n    # Evaluate delta cost for each candidate color\n    best_col = old_color\n    best_delta = 10**18\n\n    old_same = 0\n    for w in adj[v]:\n        if s[w] == old_color:\n            old_same += 1\n\n    for col in candidate_colors:\n        if col == old_color:\n            continue\n        new_same = 0\n        for w in adj[v]:\n            if s[w] == col:\n                new_same += 1\n        delta_conf = new_same - old_same\n        introduces_new = col not in colors_set\n        removes_old = all((i == v or s[i] != old_color) for i in range(n))\n        delta_colors = (1 if introduces_new else 0) - (1 if removes_old else 0)\n        delta_F = delta_conf * 1000 + delta_colors\n        if delta_F < best_delta:\n            best_delta = delta_F\n            best_col = col\n\n    cand = s[:]\n    if best_col == old_color:\n        # Diversification Kempe swap attempt only if at least two colors exist\n        if len(colors_set) >= 2:\n            seed = v\n            a = s[seed]\n            pool = list((colors_set - {a}) | {s[w] for w in adj[seed]})\n            if pool:\n                b = random.choice(pool)\n                if b != a:\n                    from collections import deque\n                    seen = [False] * n\n                    dq = deque([seed])\n                    seen[seed] = True\n                    comp = []\n                    while dq:\n                        u = dq.popleft()\n                        if s[u] == a or s[u] == b:\n                            comp.append(u)\n                            for w in adj[u]:\n                                if not seen[w] and (s[w] == a or s[w] == b):\n                                    seen[w] = True\n                                    dq.append(w)\n                    cand = s[:]\n                    for u in comp:\n                        cand[u] = b if cand[u] == a else (a if cand[u] == b else cand[u])\n                    return (cand, \"KempeSwap\")\n        # If no Kempe applied, attempt random different color if available\n        alts = [c for c in sorted(colors_set) if c != old_color]\n        if alts:\n            cand[v] = random.choice(alts)\n            return (cand, \"VertexRecolorRnd\")\n        else:\n            return (s, \"NoOp\")\n    else:\n        cand[v] = best_col\n        return (cand, \"VertexRecolorBest\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\n\ndef perturb_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    s = solution[:]\n    n = 9\n    # Embedded graph (0-based)\n    edges = (\n        (0,6),(0,7),\n        (1,2),(1,5),(1,7),(1,8),\n        (2,4),(2,5),(2,6),\n        (3,6),(3,7),(3,8),\n        (4,5),(4,6),(4,7),\n        (5,7),\n        (6,8)\n    )\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n\n    rng_steps = 2 + (1 if random.random() < 0.5 else 0)\n    colors_set = set(s)\n\n    for _ in range(rng_steps):\n        # Prefer Kempe chain shuffles to preserve palette but change structure\n        if len(colors_set) >= 2 and random.random() < 0.7:\n            seed = random.randrange(n)\n            a = s[seed]\n            pool = list((colors_set - {a}) | {s[w] for w in adj[seed]})\n            if pool:\n                b = random.choice(pool)\n                if a != b:\n                    from collections import deque\n                    seen = [False] * n\n                    dq = deque([seed])\n                    seen[seed] = True\n                    comp = []\n                    while dq:\n                        u = dq.popleft()\n                        if s[u] == a or s[u] == b:\n                            comp.append(u)\n                            for w in adj[u]:\n                                if not seen[w] and (s[w] == a or s[w] == b):\n                                    seen[w] = True\n                                    dq.append(w)\n                    for u in comp:\n                        s[u] = b if s[u] == a else (a if s[u] == b else s[u])\n        else:\n            # Targeted recolor of a high-conflict vertex, avoid introducing new colors\n            # Identify vertex with max same-color conflicts\n            best_v = 0\n            best_c = -1\n            for v in range(n):\n                c = 0\n                col = s[v]\n                for w in adj[v]:\n                    if s[w] == col:\n                        c += 1\n                if c > best_c:\n                    best_c = c\n                    best_v = v\n            v = best_v\n            old = s[v]\n            neigh_cols = {s[w] for w in adj[v]}\n            cand_cols = list(neigh_cols) + [c for c in sorted(colors_set) if c not in neigh_cols and c != old]\n            if cand_cols:\n                s[v] = random.choice(cand_cols)\n        colors_set = set(s)\n\n        # If feasible, attempt controlled palette merge (reduce highest color when safe)\n        if conflicts(s) == 0 and len(colors_set) > 1 and random.random() < 0.6:\n            colors = sorted(colors_set)\n            highest = colors[-1]\n            targets = colors[:-1]\n            if targets:\n                target = random.choice(targets)\n                changed = 0\n                for i in range(n):\n                    if s[i] == highest:\n                        if all(s[w] != target for w in adj[i]):\n                            s[i] = target\n                            changed += 1\n                        if changed >= 2:\n                            break\n            colors_set = set(s)\n\n    return s\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001359228}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize colors with heavy penalties for invalidity and conflicts; return negative objective as fitness\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based)\n        edges = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        max_group = 0\n        groups: List[int] = []\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                if x > max_group:\n                    max_group = x\n                groups.append(x)\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def get_edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        # Ensure proper length and positivity; fill\/repair to 1 if needed\n        out = [1]*9\n        if isinstance(sol, list):\n            for i in range(min(9, len(sol))):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, edges: List[Tuple[int,int]]) -> List[int]:\n        res = []\n        for u, w in edges:\n            if u == v:\n                res.append(w)\n            elif w == v:\n                res.append(u)\n        return res\n    sol = sanitize(solution)\n    edges = get_edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    # Pick a random vertex\n    v = random.randrange(1, n+1)\n    nbrs = neighbors_of(v, edges)\n    used = {sol[u-1] for u in nbrs}\n    # Try to recolor to the smallest available color to encourage compression\n    new_color = None\n    for c in range(1, max_c+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        # No existing color fits; with small prob introduce a new color, else random existing\n        if random.random() < 0.3:\n            new_color = max_c + 1\n        else:\n            # pick a color that minimizes resulting conflicts locally\n            cand = list(range(1, max_c+1))\n            random.shuffle(cand)\n            best_c = cand[0]\n            best_conf = 10**9\n            for c in cand:\n                conf = sum(1 for u in nbrs if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_color = best_c\n    neighbor = sol[:]\n    neighbor[v-1] = new_color\n    # Optional post-step: relabel colors to keep them compact (1..k without gaps)\n    # This helps the objective landscape by reducing symmetry\n    mapping = {}\n    next_c = 1\n    for x in neighbor:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n    neighbor = [mapping[x] for x in neighbor]\n    return (neighbor, \"Recolor\", \"Local\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Stronger random shake: recolor multiple vertices and attempt greedy repair, then compact color labels\n    def get_edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            for i in range(min(9, len(sol))):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, edges: List[Tuple[int,int]]) -> List[int]:\n        res = []\n        for u, w in edges:\n            if u == v:\n                res.append(w)\n            elif w == v:\n                res.append(u)\n        return res\n    def greedy_repair(sol: List[int], edges: List[Tuple[int,int]]) -> List[int]:\n        # Try to assign smallest feasible color per vertex in random order\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            nbrs = neighbors_of(v, edges)\n            used = {sol[u-1] for u in nbrs}\n            c = 1\n            while c in used and c <= max(sol)+1:\n                c += 1\n            sol[v-1] = c\n        return sol\n    sol = sanitize(solution)\n    edges = get_edges()\n    n_changes = random.randint(2, 4)\n    n = 9\n    idxs = random.sample(range(n), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        # Assign either a random existing color or a new one with small probability\n        if random.random() < 0.25:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n        else:\n            sol[i] = random.randint(1, max_c)\n    sol = greedy_repair(sol, edges)\n    # Compact labels\n    mapping = {}\n    next_c = 1\n    compact = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n        compact.append(mapping[x])\n    return compact\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00075263}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize colors with heavy penalties for invalidity and conflicts; return negative objective as fitness\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based)\n        edges = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        max_group = 0\n        groups: List[int] = []\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                if x > max_group:\n                    max_group = x\n                groups.append(x)\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def get_edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        # Ensure proper length and positivity; fill\/repair to 1 if needed\n        out = [1]*9\n        if isinstance(sol, list):\n            for i in range(min(9, len(sol))):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, edges: List[Tuple[int,int]]) -> List[int]:\n        res = []\n        for u, w in edges:\n            if u == v:\n                res.append(w)\n            elif w == v:\n                res.append(u)\n        return res\n    sol = sanitize(solution)\n    edges = get_edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    # Pick a random vertex\n    v = random.randrange(1, n+1)\n    nbrs = neighbors_of(v, edges)\n    used = {sol[u-1] for u in nbrs}\n    # Try to recolor to the smallest available color to encourage compression\n    new_color = None\n    for c in range(1, max_c+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        # No existing color fits; with small prob introduce a new color, else random existing\n        if random.random() < 0.3:\n            new_color = max_c + 1\n        else:\n            # pick a color that minimizes resulting conflicts locally\n            cand = list(range(1, max_c+1))\n            random.shuffle(cand)\n            best_c = cand[0]\n            best_conf = 10**9\n            for c in cand:\n                conf = sum(1 for u in nbrs if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_color = best_c\n    neighbor = sol[:]\n    neighbor[v-1] = new_color\n    # Optional post-step: relabel colors to keep them compact (1..k without gaps)\n    # This helps the objective landscape by reducing symmetry\n    mapping = {}\n    next_c = 1\n    for x in neighbor:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n    neighbor = [mapping[x] for x in neighbor]\n    return (neighbor, \"Recolor\", \"Local\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Stronger random shake: recolor multiple vertices and attempt greedy repair, then compact color labels\n    def get_edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            for i in range(min(9, len(sol))):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, edges: List[Tuple[int,int]]) -> List[int]:\n        res = []\n        for u, w in edges:\n            if u == v:\n                res.append(w)\n            elif w == v:\n                res.append(u)\n        return res\n    def greedy_repair(sol: List[int], edges: List[Tuple[int,int]]) -> List[int]:\n        # Try to assign smallest feasible color per vertex in random order\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            nbrs = neighbors_of(v, edges)\n            used = {sol[u-1] for u in nbrs}\n            c = 1\n            while c in used and c <= max(sol)+1:\n                c += 1\n            sol[v-1] = c\n        return sol\n    sol = sanitize(solution)\n    edges = get_edges()\n    n_changes = random.randint(2, 4)\n    n = 9\n    idxs = random.sample(range(n), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        # Assign either a random existing color or a new one with small probability\n        if random.random() < 0.25:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n        else:\n            sol[i] = random.randint(1, max_c)\n    sol = greedy_repair(sol, edges)\n    # Compact labels\n    mapping = {}\n    next_c = 1\n    compact = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n        compact.append(mapping[x])\n    return compact\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001015134}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize colors with heavy penalties for invalidity and conflicts; return negative objective as fitness\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based)\n        edges = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        max_group = 0\n        groups: List[int] = []\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                if x > max_group:\n                    max_group = x\n                groups.append(x)\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def get_edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        # Ensure proper length and positivity; fill\/repair to 1 if needed\n        out = [1]*9\n        if isinstance(sol, list):\n            for i in range(min(9, len(sol))):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, edges: List[Tuple[int,int]]) -> List[int]:\n        res = []\n        for u, w in edges:\n            if u == v:\n                res.append(w)\n            elif w == v:\n                res.append(u)\n        return res\n    sol = sanitize(solution)\n    edges = get_edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    # Pick a random vertex\n    v = random.randrange(1, n+1)\n    nbrs = neighbors_of(v, edges)\n    used = {sol[u-1] for u in nbrs}\n    # Try to recolor to the smallest available color to encourage compression\n    new_color = None\n    for c in range(1, max_c+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        # No existing color fits; with small prob introduce a new color, else random existing\n        if random.random() < 0.3:\n            new_color = max_c + 1\n        else:\n            # pick a color that minimizes resulting conflicts locally\n            cand = list(range(1, max_c+1))\n            random.shuffle(cand)\n            best_c = cand[0]\n            best_conf = 10**9\n            for c in cand:\n                conf = sum(1 for u in nbrs if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_color = best_c\n    neighbor = sol[:]\n    neighbor[v-1] = new_color\n    # Optional post-step: relabel colors to keep them compact (1..k without gaps)\n    # This helps the objective landscape by reducing symmetry\n    mapping = {}\n    next_c = 1\n    for x in neighbor:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n    neighbor = [mapping[x] for x in neighbor]\n    return (neighbor, \"Recolor\", \"Local\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Stronger random shake: recolor multiple vertices and attempt greedy repair, then compact color labels\n    def get_edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            for i in range(min(9, len(sol))):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, edges: List[Tuple[int,int]]) -> List[int]:\n        res = []\n        for u, w in edges:\n            if u == v:\n                res.append(w)\n            elif w == v:\n                res.append(u)\n        return res\n    def greedy_repair(sol: List[int], edges: List[Tuple[int,int]]) -> List[int]:\n        # Try to assign smallest feasible color per vertex in random order\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            nbrs = neighbors_of(v, edges)\n            used = {sol[u-1] for u in nbrs}\n            c = 1\n            while c in used and c <= max(sol)+1:\n                c += 1\n            sol[v-1] = c\n        return sol\n    sol = sanitize(solution)\n    edges = get_edges()\n    n_changes = random.randint(2, 4)\n    n = 9\n    idxs = random.sample(range(n), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        # Assign either a random existing color or a new one with small probability\n        if random.random() < 0.25:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n        else:\n            sol[i] = random.randint(1, max_c)\n    sol = greedy_repair(sol, edges)\n    # Compact labels\n    mapping = {}\n    next_c = 1\n    compact = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n        compact.append(mapping[x])\n    return compact\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000994673}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based indices)\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        # Deterministic relabel: sort color classes by smallest-index vertex\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        next_c = 1\n        for c, _verts in order:\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in sol]\n    sol = sanitize(solution)\n    es = edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    move_choice = random.random()\n    # 1) Conflict-driven recolor (local)\n    def conflict_vertices(s: List[int]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n    if move_choice < 0.5:\n        # pick conflicting vertex if any else random\n        bad = conflict_vertices(sol)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        # try smallest available existing color else maybe new\n        new_c = None\n        for c in range(1, max_c+1):\n            if c not in used:\n                new_c = c\n                break\n        if new_c is None:\n            if random.random() < 0.25:\n                new_c = max_c + 1\n            else:\n                cand = list(range(1, max_c+1))\n                random.shuffle(cand)\n                best_c = cand[0]\n                best_conf = 10**9\n                for c in cand:\n                    conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_c = best_c\n        neigh = sol[:]\n        neigh[v-1] = new_c\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"Recolor\", \"Local\")\n    # 2) Kempe chain swap between two colors (non-local)\n    elif move_choice < 0.85:\n        if max_c < 2:\n            # fallback to recolor\n            v = random.randrange(1, n+1)\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            new_c = 1\n            while new_c in used:\n                new_c += 1\n            neigh = sol[:]\n            neigh[v-1] = new_c\n            neigh = normalize_compact_stable(neigh)\n            return (neigh, \"Recolor\", \"Local\")\n        c1, c2 = random.sample(range(1, max_c+1), 2)\n        # pick a seed vertex among {c1,c2}\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return (sol[:], \"NoOp\", \"Local\")\n        seed = random.choice(candidates)\n        # build Kempe chain component reachable via edges restricted to colors {c1,c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        allowed = {c1, c2}\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            neigh[v-1] = c1 if sol[v-1] == c2 else (c2 if sol[v-1] == c1 else sol[v-1])\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"KempeSwap\", \"NonLocal\")\n    # 3) Color merge attempt: try to eliminate a color by reassigning its vertices greedily\n    else:\n        if max_c == 1:\n            return (sol[:], \"NoOp\", \"Local\")\n        target = random.randrange(1, max_c+1)\n        neigh = sol[:]\n        # try to move vertices of 'target' into existing colors if feasible; else leave\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of(v, es)}\n            moved = False\n            for c in range(1, max_c+1):\n                if c == target:\n                    continue\n                if c not in used:\n                    neigh[v-1] = c\n                    moved = True\n                    break\n            if not moved:\n                # leave as is\n                pass\n        # if target becomes empty, compact\n        if all(c != target for c in neigh):\n            neigh = normalize_compact_stable(neigh)\n        else:\n            neigh = normalize_compact_stable(neigh)\n        return (neigh, \"ColorMerge\", \"Global\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair and stable compaction.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        nxt = 1\n        for c, _verts in order:\n            mapping[c] = nxt\n            nxt += 1\n        return [mapping[c] for c in sol]\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            # allow using up to current max + 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n    sol = greedy_repair(sol, es)\n    sol = normalize_compact_stable(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001323747}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based indices)\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        # Deterministic relabel: sort color classes by smallest-index vertex\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        next_c = 1\n        for c, _verts in order:\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in sol]\n    sol = sanitize(solution)\n    es = edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    move_choice = random.random()\n    # 1) Conflict-driven recolor (local)\n    def conflict_vertices(s: List[int]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n    if move_choice < 0.5:\n        # pick conflicting vertex if any else random\n        bad = conflict_vertices(sol)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        # try smallest available existing color else maybe new\n        new_c = None\n        for c in range(1, max_c+1):\n            if c not in used:\n                new_c = c\n                break\n        if new_c is None:\n            if random.random() < 0.25:\n                new_c = max_c + 1\n            else:\n                cand = list(range(1, max_c+1))\n                random.shuffle(cand)\n                best_c = cand[0]\n                best_conf = 10**9\n                for c in cand:\n                    conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_c = best_c\n        neigh = sol[:]\n        neigh[v-1] = new_c\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"Recolor\", \"Local\")\n    # 2) Kempe chain swap between two colors (non-local)\n    elif move_choice < 0.85:\n        if max_c < 2:\n            # fallback to recolor\n            v = random.randrange(1, n+1)\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            new_c = 1\n            while new_c in used:\n                new_c += 1\n            neigh = sol[:]\n            neigh[v-1] = new_c\n            neigh = normalize_compact_stable(neigh)\n            return (neigh, \"Recolor\", \"Local\")\n        c1, c2 = random.sample(range(1, max_c+1), 2)\n        # pick a seed vertex among {c1,c2}\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return (sol[:], \"NoOp\", \"Local\")\n        seed = random.choice(candidates)\n        # build Kempe chain component reachable via edges restricted to colors {c1,c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        allowed = {c1, c2}\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            neigh[v-1] = c1 if sol[v-1] == c2 else (c2 if sol[v-1] == c1 else sol[v-1])\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"KempeSwap\", \"NonLocal\")\n    # 3) Color merge attempt: try to eliminate a color by reassigning its vertices greedily\n    else:\n        if max_c == 1:\n            return (sol[:], \"NoOp\", \"Local\")\n        target = random.randrange(1, max_c+1)\n        neigh = sol[:]\n        # try to move vertices of 'target' into existing colors if feasible; else leave\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of(v, es)}\n            moved = False\n            for c in range(1, max_c+1):\n                if c == target:\n                    continue\n                if c not in used:\n                    neigh[v-1] = c\n                    moved = True\n                    break\n            if not moved:\n                # leave as is\n                pass\n        # if target becomes empty, compact\n        if all(c != target for c in neigh):\n            neigh = normalize_compact_stable(neigh)\n        else:\n            neigh = normalize_compact_stable(neigh)\n        return (neigh, \"ColorMerge\", \"Global\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair and stable compaction.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        nxt = 1\n        for c, _verts in order:\n            mapping[c] = nxt\n            nxt += 1\n        return [mapping[c] for c in sol]\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            # allow using up to current max + 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n    sol = greedy_repair(sol, es)\n    sol = normalize_compact_stable(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001847763}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based indices)\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        # Deterministic relabel: sort color classes by smallest-index vertex\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        next_c = 1\n        for c, _verts in order:\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in sol]\n    sol = sanitize(solution)\n    es = edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    move_choice = random.random()\n    # 1) Conflict-driven recolor (local)\n    def conflict_vertices(s: List[int]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n    if move_choice < 0.5:\n        # pick conflicting vertex if any else random\n        bad = conflict_vertices(sol)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        # try smallest available existing color else maybe new\n        new_c = None\n        for c in range(1, max_c+1):\n            if c not in used:\n                new_c = c\n                break\n        if new_c is None:\n            if random.random() < 0.25:\n                new_c = max_c + 1\n            else:\n                cand = list(range(1, max_c+1))\n                random.shuffle(cand)\n                best_c = cand[0]\n                best_conf = 10**9\n                for c in cand:\n                    conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_c = best_c\n        neigh = sol[:]\n        neigh[v-1] = new_c\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"Recolor\", \"Local\")\n    # 2) Kempe chain swap between two colors (non-local)\n    elif move_choice < 0.85:\n        if max_c < 2:\n            # fallback to recolor\n            v = random.randrange(1, n+1)\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            new_c = 1\n            while new_c in used:\n                new_c += 1\n            neigh = sol[:]\n            neigh[v-1] = new_c\n            neigh = normalize_compact_stable(neigh)\n            return (neigh, \"Recolor\", \"Local\")\n        c1, c2 = random.sample(range(1, max_c+1), 2)\n        # pick a seed vertex among {c1,c2}\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return (sol[:], \"NoOp\", \"Local\")\n        seed = random.choice(candidates)\n        # build Kempe chain component reachable via edges restricted to colors {c1,c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        allowed = {c1, c2}\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            neigh[v-1] = c1 if sol[v-1] == c2 else (c2 if sol[v-1] == c1 else sol[v-1])\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"KempeSwap\", \"NonLocal\")\n    # 3) Color merge attempt: try to eliminate a color by reassigning its vertices greedily\n    else:\n        if max_c == 1:\n            return (sol[:], \"NoOp\", \"Local\")\n        target = random.randrange(1, max_c+1)\n        neigh = sol[:]\n        # try to move vertices of 'target' into existing colors if feasible; else leave\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of(v, es)}\n            moved = False\n            for c in range(1, max_c+1):\n                if c == target:\n                    continue\n                if c not in used:\n                    neigh[v-1] = c\n                    moved = True\n                    break\n            if not moved:\n                # leave as is\n                pass\n        # if target becomes empty, compact\n        if all(c != target for c in neigh):\n            neigh = normalize_compact_stable(neigh)\n        else:\n            neigh = normalize_compact_stable(neigh)\n        return (neigh, \"ColorMerge\", \"Global\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair and stable compaction.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        nxt = 1\n        for c, _verts in order:\n            mapping[c] = nxt\n            nxt += 1\n        return [mapping[c] for c in sol]\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            # allow using up to current max + 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n    sol = greedy_repair(sol, es)\n    sol = normalize_compact_stable(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001819893}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based indices)\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        # Deterministic relabel: sort color classes by smallest-index vertex\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        next_c = 1\n        for c, _verts in order:\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in sol]\n    def conflict_vertices(s: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    sol = sanitize(solution)\n    es = edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    move_choice = random.random()\n\n    # 1) Conflict-driven recolor (local)\n    if move_choice < 0.5:\n        bad = conflict_vertices(sol, es)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        # try smallest available existing color else maybe new\n        new_c = None\n        for c in range(1, max_c+1):\n            if c not in used:\n                new_c = c\n                break\n        if new_c is None:\n            if random.random() < 0.25:\n                new_c = max_c + 1\n            else:\n                cand = list(range(1, max_c+1))\n                random.shuffle(cand)\n                best_c = cand[0]\n                best_conf = 10**9\n                for c in cand:\n                    conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_c = best_c\n        neigh = sol[:]\n        neigh[v-1] = new_c\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"Recolor\", \"Local\")\n\n    # 2) Kempe chain swap between two colors (non-local)\n    elif move_choice < 0.85:\n        if max_c < 2:\n            # fallback to recolor\n            v = random.randrange(1, n+1)\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            new_c = 1\n            while new_c in used:\n                new_c += 1\n            neigh = sol[:]\n            neigh[v-1] = new_c\n            neigh = normalize_compact_stable(neigh)\n            return (neigh, \"Recolor\", \"Local\")\n        c1, c2 = random.sample(range(1, max_c+1), 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return (sol[:], \"NoOp\", \"Local\")\n        seed = random.choice(candidates)\n        # build Kempe chain component reachable via edges restricted to colors {c1,c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        allowed = {c1, c2}\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            neigh[v-1] = c1 if sol[v-1] == c2 else (c2 if sol[v-1] == c1 else sol[v-1])\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"KempeSwap\", \"NonLocal\")\n\n    # 3) Color merge attempt: try to eliminate a color by reassigning its vertices greedily\n    else:\n        if max_c == 1:\n            return (sol[:], \"NoOp\", \"Local\")\n        target = random.randrange(1, max_c+1)\n        neigh = sol[:]\n        # try to move vertices of 'target' into existing colors if feasible; else leave\n        def neighbors_of_v(v):\n            return neighbors_of(v, es)\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of_v(v)}\n            moved = False\n            for c in range(1, max_c+1):\n                if c == target:\n                    continue\n                if c not in used:\n                    neigh[v-1] = c\n                    moved = True\n                    break\n            if not moved:\n                pass\n        # Compact labels deterministically\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"ColorMerge\", \"Global\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair and stable compaction.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        nxt = 1\n        for c, _verts in order:\n            mapping[c] = nxt\n            nxt += 1\n        return [mapping[c] for c in sol]\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n    sol = greedy_repair(sol, es)\n    sol = normalize_compact_stable(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001145765}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based indices)\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        # Deterministic relabel: sort color classes by smallest-index vertex\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        next_c = 1\n        for c, _verts in order:\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in sol]\n    def conflict_vertices(s: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    sol = sanitize(solution)\n    es = edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    move_choice = random.random()\n\n    # 1) Conflict-driven recolor (local)\n    if move_choice < 0.5:\n        bad = conflict_vertices(sol, es)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        # try smallest available existing color else maybe new\n        new_c = None\n        for c in range(1, max_c+1):\n            if c not in used:\n                new_c = c\n                break\n        if new_c is None:\n            if random.random() < 0.25:\n                new_c = max_c + 1\n            else:\n                cand = list(range(1, max_c+1))\n                random.shuffle(cand)\n                best_c = cand[0]\n                best_conf = 10**9\n                for c in cand:\n                    conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_c = best_c\n        neigh = sol[:]\n        neigh[v-1] = new_c\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"Recolor\", \"Local\")\n\n    # 2) Kempe chain swap between two colors (non-local)\n    elif move_choice < 0.85:\n        if max_c < 2:\n            # fallback to recolor\n            v = random.randrange(1, n+1)\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            new_c = 1\n            while new_c in used:\n                new_c += 1\n            neigh = sol[:]\n            neigh[v-1] = new_c\n            neigh = normalize_compact_stable(neigh)\n            return (neigh, \"Recolor\", \"Local\")\n        c1, c2 = random.sample(range(1, max_c+1), 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return (sol[:], \"NoOp\", \"Local\")\n        seed = random.choice(candidates)\n        # build Kempe chain component reachable via edges restricted to colors {c1,c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        allowed = {c1, c2}\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            neigh[v-1] = c1 if sol[v-1] == c2 else (c2 if sol[v-1] == c1 else sol[v-1])\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"KempeSwap\", \"NonLocal\")\n\n    # 3) Color merge attempt: try to eliminate a color by reassigning its vertices greedily\n    else:\n        if max_c == 1:\n            return (sol[:], \"NoOp\", \"Local\")\n        target = random.randrange(1, max_c+1)\n        neigh = sol[:]\n        # try to move vertices of 'target' into existing colors if feasible; else leave\n        def neighbors_of_v(v):\n            return neighbors_of(v, es)\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of_v(v)}\n            moved = False\n            for c in range(1, max_c+1):\n                if c == target:\n                    continue\n                if c not in used:\n                    neigh[v-1] = c\n                    moved = True\n                    break\n            if not moved:\n                pass\n        # Compact labels deterministically\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"ColorMerge\", \"Global\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair and stable compaction.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        nxt = 1\n        for c, _verts in order:\n            mapping[c] = nxt\n            nxt += 1\n        return [mapping[c] for c in sol]\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n    sol = greedy_repair(sol, es)\n    sol = normalize_compact_stable(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001405988}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        # Validate structure\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        # Embedded edges (1-based indices)\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        # Deterministic relabel: sort color classes by smallest-index vertex\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        next_c = 1\n        for c, _verts in order:\n            mapping[c] = next_c\n            next_c += 1\n        return [mapping[c] for c in sol]\n    def conflict_vertices(s: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n\n    sol = sanitize(solution)\n    es = edges()\n    n = 9\n    max_c = max(sol) if sol else 1\n    move_choice = random.random()\n\n    # 1) Conflict-driven recolor (local)\n    if move_choice < 0.5:\n        bad = conflict_vertices(sol, es)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        # try smallest available existing color else maybe new\n        new_c = None\n        for c in range(1, max_c+1):\n            if c not in used:\n                new_c = c\n                break\n        if new_c is None:\n            if random.random() < 0.25:\n                new_c = max_c + 1\n            else:\n                cand = list(range(1, max_c+1))\n                random.shuffle(cand)\n                best_c = cand[0]\n                best_conf = 10**9\n                for c in cand:\n                    conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_c = c\n                new_c = best_c\n        neigh = sol[:]\n        neigh[v-1] = new_c\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"Recolor\", \"Local\")\n\n    # 2) Kempe chain swap between two colors (non-local)\n    elif move_choice < 0.85:\n        if max_c < 2:\n            # fallback to recolor\n            v = random.randrange(1, n+1)\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            new_c = 1\n            while new_c in used:\n                new_c += 1\n            neigh = sol[:]\n            neigh[v-1] = new_c\n            neigh = normalize_compact_stable(neigh)\n            return (neigh, \"Recolor\", \"Local\")\n        c1, c2 = random.sample(range(1, max_c+1), 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return (sol[:], \"NoOp\", \"Local\")\n        seed = random.choice(candidates)\n        # build Kempe chain component reachable via edges restricted to colors {c1,c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        allowed = {c1, c2}\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            neigh[v-1] = c1 if sol[v-1] == c2 else (c2 if sol[v-1] == c1 else sol[v-1])\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"KempeSwap\", \"NonLocal\")\n\n    # 3) Color merge attempt: try to eliminate a color by reassigning its vertices greedily\n    else:\n        if max_c == 1:\n            return (sol[:], \"NoOp\", \"Local\")\n        target = random.randrange(1, max_c+1)\n        neigh = sol[:]\n        # try to move vertices of 'target' into existing colors if feasible; else leave\n        def neighbors_of_v(v):\n            return neighbors_of(v, es)\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of_v(v)}\n            moved = False\n            for c in range(1, max_c+1):\n                if c == target:\n                    continue\n                if c not in used:\n                    neigh[v-1] = c\n                    moved = True\n                    break\n            if not moved:\n                pass\n        # Compact labels deterministically\n        neigh = normalize_compact_stable(neigh)\n        return (neigh, \"ColorMerge\", \"Global\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair and stable compaction.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def normalize_compact_stable(sol: List[int]) -> List[int]:\n        classes: dict[int, List[int]] = {}\n        for idx, c in enumerate(sol, start=1):\n            classes.setdefault(c, []).append(idx)\n        order = sorted(classes.items(), key=lambda kv: min(kv[1]))\n        mapping: dict[int, int] = {}\n        nxt = 1\n        for c, _verts in order:\n            mapping[c] = nxt\n            nxt += 1\n        return [mapping[c] for c in sol]\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            max_c = max(max_c, sol[i])\n    sol = greedy_repair(sol, es)\n    sol = normalize_compact_stable(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001364357}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def conflict_vertices(s: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n    def try_recolor(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = conflict_vertices(sol, es)\n        n = 9\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        max_c = max(sol) if sol else 1\n        # Prefer existing colors that avoid conflict\n        for c in range(1, max_c+1):\n            if c not in used:\n                neigh = sol[:]\n                neigh[v-1] = c\n                return neigh\n        # As fallback, use color with minimal conflicts or introduce new color with small chance\n        if random.random() < 0.2:\n            neigh = sol[:]\n            neigh[v-1] = max_c + 1\n            return neigh\n        best_c = 1\n        best_conf = 10**9\n        for c in range(1, max_c+1):\n            conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        neigh = sol[:]\n        neigh[v-1] = best_c\n        return neigh\n    def kempe_swap(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        max_c = max(sol)\n        if max_c < 2:\n            return sol[:]\n        # Bias selection toward colors present in conflicts\n        bad = conflict_vertices(sol, es)\n        if bad:\n            involved_colors = {sol[v-1] for v in bad}\n            pool = list(involved_colors)\n            if len(pool) >= 2:\n                c1, c2 = random.sample(pool, 2)\n            else:\n                c1, c2 = random.sample(range(1, max_c+1), 2)\n        else:\n            c1, c2 = random.sample(range(1, max_c+1), 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return sol[:]\n        seed = random.choice(candidates)\n        allowed = {c1, c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            if sol[v-1] == c1:\n                neigh[v-1] = c2\n            elif sol[v-1] == c2:\n                neigh[v-1] = c1\n        return neigh\n    def color_merge(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        # Target eliminating the highest color index\n        max_c = max(sol)\n        if max_c == 1:\n            return sol[:]\n        target = max_c\n        neigh = sol[:]\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of(v, es)}\n            for c in range(1, max_c):\n                if c not in used:\n                    neigh[v-1] = c\n                    break\n        return neigh\n    sol = sanitize(solution)\n    es = edges()\n    # Try multiple times to avoid no-op\n    for _ in range(20):\n        move_choice = random.random()\n        if move_choice < 0.5:\n            cand = try_recolor(sol, es)\n            if cand != sol:\n                return (cand, \"Recolor\", \"Local\")\n        elif move_choice < 0.85:\n            cand = kempe_swap(sol, es)\n            if cand != sol:\n                return (cand, \"KempeSwap\", \"NonLocal\")\n        else:\n            cand = color_merge(sol, es)\n            if cand != sol:\n                return (cand, \"ColorMerge\", \"Global\")\n    # Forced change fallback: random vertex recolor to random permissible or new color\n    n = 9\n    v = random.randrange(1, n+1)\n    used = {sol[u-1] for u in neighbors_of(v, es)}\n    max_c = max(sol)\n    choices = [c for c in range(1, max_c+1) if c not in used]\n    if not choices:\n        sol[v-1] = max_c + 1\n    else:\n        sol[v-1] = random.choice(choices)\n    return (sol, \"ForcedRecolor\", \"Local\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            if sol[i] > max_c:\n                max_c = sol[i]\n    sol = greedy_repair(sol, es)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001277646}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def conflict_vertices(s: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n    def try_recolor(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = conflict_vertices(sol, es)\n        n = 9\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        max_c = max(sol) if sol else 1\n        # Prefer existing colors that avoid conflict\n        for c in range(1, max_c+1):\n            if c not in used:\n                neigh = sol[:]\n                neigh[v-1] = c\n                return neigh\n        # As fallback, use color with minimal conflicts or introduce new color with small chance\n        if random.random() < 0.2:\n            neigh = sol[:]\n            neigh[v-1] = max_c + 1\n            return neigh\n        best_c = 1\n        best_conf = 10**9\n        for c in range(1, max_c+1):\n            conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        neigh = sol[:]\n        neigh[v-1] = best_c\n        return neigh\n    def kempe_swap(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        max_c = max(sol)\n        if max_c < 2:\n            return sol[:]\n        # Bias selection toward colors present in conflicts\n        bad = conflict_vertices(sol, es)\n        if bad:\n            involved_colors = {sol[v-1] for v in bad}\n            pool = list(involved_colors)\n            if len(pool) >= 2:\n                c1, c2 = random.sample(pool, 2)\n            else:\n                c1, c2 = random.sample(range(1, max_c+1), 2)\n        else:\n            c1, c2 = random.sample(range(1, max_c+1), 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return sol[:]\n        seed = random.choice(candidates)\n        allowed = {c1, c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            if sol[v-1] == c1:\n                neigh[v-1] = c2\n            elif sol[v-1] == c2:\n                neigh[v-1] = c1\n        return neigh\n    def color_merge(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        # Target eliminating the highest color index\n        max_c = max(sol)\n        if max_c == 1:\n            return sol[:]\n        target = max_c\n        neigh = sol[:]\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of(v, es)}\n            for c in range(1, max_c):\n                if c not in used:\n                    neigh[v-1] = c\n                    break\n        return neigh\n    sol = sanitize(solution)\n    es = edges()\n    # Try multiple times to avoid no-op\n    for _ in range(20):\n        move_choice = random.random()\n        if move_choice < 0.5:\n            cand = try_recolor(sol, es)\n            if cand != sol:\n                return (cand, \"Recolor\", \"Local\")\n        elif move_choice < 0.85:\n            cand = kempe_swap(sol, es)\n            if cand != sol:\n                return (cand, \"KempeSwap\", \"NonLocal\")\n        else:\n            cand = color_merge(sol, es)\n            if cand != sol:\n                return (cand, \"ColorMerge\", \"Global\")\n    # Forced change fallback: random vertex recolor to random permissible or new color\n    n = 9\n    v = random.randrange(1, n+1)\n    used = {sol[u-1] for u in neighbors_of(v, es)}\n    max_c = max(sol)\n    choices = [c for c in range(1, max_c+1) if c not in used]\n    if not choices:\n        sol[v-1] = max_c + 1\n    else:\n        sol[v-1] = random.choice(choices)\n    return (sol, \"ForcedRecolor\", \"Local\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            if sol[i] > max_c:\n                max_c = sol[i]\n    sol = greedy_repair(sol, es)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001385808}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"LIST9_POSITIVE_INTS_GROUP_INDEX_1BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Objective: minimize number of colors (max index) with penalties for invalidity and edge conflicts.\n    # Returns negative objective as fitness (higher is better).\n    def objective_function(sol: List[int]) -> int:\n        if not isinstance(sol, list) or len(sol) != 9:\n            return 10**9\n        edges: List[Tuple[int, int]] = [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n        invalid = 0\n        groups: List[int] = []\n        max_group = 0\n        for x in sol:\n            if isinstance(x, bool) or not isinstance(x, int) or x < 1:\n                invalid += 1\n                groups.append(0)\n            else:\n                groups.append(x)\n                if x > max_group:\n                    max_group = x\n        conflicts = 0\n        for u, v in edges:\n            gu = groups[u-1]\n            gv = groups[v-1]\n            if gu != 0 and gv != 0 and gu == gv:\n                conflicts += 1\n        penalty = 1_000_000 * invalid + 100_000 * conflicts\n        return max_group + penalty\n    return -float(objective_function(solution))\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def conflict_vertices(s: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = set()\n        for u, v in es:\n            if s[u-1] == s[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return list(bad)\n    def try_recolor(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        bad = conflict_vertices(sol, es)\n        n = 9\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        used = {sol[u-1] for u in neighbors_of(v, es)}\n        max_c = max(sol) if sol else 1\n        # Prefer existing colors that avoid conflict\n        for c in range(1, max_c+1):\n            if c not in used:\n                neigh = sol[:]\n                neigh[v-1] = c\n                return neigh\n        # As fallback, use color with minimal conflicts or introduce new color with small chance\n        if random.random() < 0.2:\n            neigh = sol[:]\n            neigh[v-1] = max_c + 1\n            return neigh\n        best_c = 1\n        best_conf = 10**9\n        for c in range(1, max_c+1):\n            conf = sum(1 for u in neighbors_of(v, es) if sol[u-1] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        neigh = sol[:]\n        neigh[v-1] = best_c\n        return neigh\n    def kempe_swap(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        max_c = max(sol)\n        if max_c < 2:\n            return sol[:]\n        # Bias selection toward colors present in conflicts\n        bad = conflict_vertices(sol, es)\n        if bad:\n            involved_colors = {sol[v-1] for v in bad}\n            pool = list(involved_colors)\n            if len(pool) >= 2:\n                c1, c2 = random.sample(pool, 2)\n            else:\n                c1, c2 = random.sample(range(1, max_c+1), 2)\n        else:\n            c1, c2 = random.sample(range(1, max_c+1), 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c == c1 or c == c2]\n        if not candidates:\n            return sol[:]\n        seed = random.choice(candidates)\n        allowed = {c1, c2}\n        in_chain = set([seed])\n        frontier = [seed]\n        while frontier:\n            v = frontier.pop()\n            for u in neighbors_of(v, es):\n                if u not in in_chain and sol[u-1] in allowed:\n                    in_chain.add(u)\n                    frontier.append(u)\n        neigh = sol[:]\n        for v in in_chain:\n            if sol[v-1] == c1:\n                neigh[v-1] = c2\n            elif sol[v-1] == c2:\n                neigh[v-1] = c1\n        return neigh\n    def color_merge(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        # Target eliminating the highest color index\n        max_c = max(sol)\n        if max_c == 1:\n            return sol[:]\n        target = max_c\n        neigh = sol[:]\n        verts = [i+1 for i, c in enumerate(neigh) if c == target]\n        for v in verts:\n            used = {neigh[u-1] for u in neighbors_of(v, es)}\n            for c in range(1, max_c):\n                if c not in used:\n                    neigh[v-1] = c\n                    break\n        return neigh\n    sol = sanitize(solution)\n    es = edges()\n    # Try multiple times to avoid no-op\n    for _ in range(20):\n        move_choice = random.random()\n        if move_choice < 0.5:\n            cand = try_recolor(sol, es)\n            if cand != sol:\n                return (cand, \"Recolor\", \"Local\")\n        elif move_choice < 0.85:\n            cand = kempe_swap(sol, es)\n            if cand != sol:\n                return (cand, \"KempeSwap\", \"NonLocal\")\n        else:\n            cand = color_merge(sol, es)\n            if cand != sol:\n                return (cand, \"ColorMerge\", \"Global\")\n    # Forced change fallback: random vertex recolor to random permissible or new color\n    n = 9\n    v = random.randrange(1, n+1)\n    used = {sol[u-1] for u in neighbors_of(v, es)}\n    max_c = max(sol)\n    choices = [c for c in range(1, max_c+1) if c not in used]\n    if not choices:\n        sol[v-1] = max_c + 1\n    else:\n        sol[v-1] = random.choice(choices)\n    return (sol, \"ForcedRecolor\", \"Local\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolors on a subset, then greedy repair.\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,7),(1,8),\n            (2,3),(2,6),(2,8),(2,9),\n            (3,5),(3,6),(3,7),\n            (4,7),(4,8),(4,9),\n            (5,6),(5,7),(5,8),\n            (6,8),\n            (7,9)\n        ]\n    def neighbors_of(v: int, es: List[Tuple[int,int]]) -> List[int]:\n        res: List[int] = []\n        for a, b in es:\n            if a == v:\n                res.append(b)\n            elif b == v:\n                res.append(a)\n        return res\n    def sanitize(sol: List[int]) -> List[int]:\n        out = [1]*9\n        if isinstance(sol, list):\n            m = min(9, len(sol))\n            for i in range(m):\n                x = sol[i]\n                out[i] = x if isinstance(x, int) and not isinstance(x, bool) and x >= 1 else 1\n        return out\n    def greedy_repair(sol: List[int], es: List[Tuple[int,int]]) -> List[int]:\n        order = list(range(1, 10))\n        random.shuffle(order)\n        for v in order:\n            used = {sol[u-1] for u in neighbors_of(v, es)}\n            c = 1\n            limit = max(sol) + 1\n            while c in used and c <= limit:\n                c += 1\n            sol[v-1] = c\n        return sol\n    es = edges()\n    sol = sanitize(solution)\n    n_changes = random.randint(3, 5)\n    idxs = random.sample(range(9), n_changes)\n    max_c = max(sol)\n    for i in idxs:\n        if random.random() < 0.5:\n            sol[i] = random.randint(1, max_c)\n        else:\n            sol[i] = max_c + 1\n            if sol[i] > max_c:\n                max_c = sol[i]\n    sol = greedy_repair(sol, es)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001294136}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1 Each solution is a list of 9 positive integers [c1,...,c9] where ci>=1 denotes the color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Problem constants (embedded)\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure check\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    invalid_label_penalty = 0\n    labels: List[int] = []\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n        labels.append(x)\n\n    # Edge conflicts\n    conflict_penalty = 0\n    for (u, v) in edges:\n        cu = labels[u-1]\n        cv = labels[v-1]\n        if cu == cv:\n            conflict_penalty += 10**4\n\n    # Objective: minimize number of distinct colors\n    distinct_colors = len(set(labels))\n\n    return float(distinct_colors + invalid_label_penalty + conflict_penalty)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    # NB_Type in {\"Local\"}; Movement_Type in {\"RecolorOne\",\"SwapTwo\"}\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    curr = list(solution)\n    move = random.random()\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to consecutive integers starting at 1 (order-preserving by first appearance)\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    if move < 0.5:\n        # Recolor one vertex to an existing or a new color (up to 9)\n        i = random.randrange(9)\n        used = list(set(curr))\n        # candidate colors: existing plus possibly a new one\n        max_new = 9\n        candidates = set(used)\n        if len(used) < max_new:\n            candidates.add(max(used + [0]) + 1)\n        new_color = random.choice(list(candidates))\n        curr[i] = new_color\n        curr = compress_colors(curr)\n        return (curr, (\"Local\",\"RecolorOne\"))\n    else:\n        # Swap colors between two vertices\n        i, j = random.sample(range(9), 2)\n        curr[i], curr[j] = curr[j], curr[i]\n        curr = compress_colors(curr)\n        return (curr, (\"Local\",\"SwapTwo\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    curr = list(solution)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Apply multiple random recolors and a random relabel shuffle\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(9)\n        used = list(set(curr))\n        max_new = 9\n        candidates = set(used)\n        if len(used) < max_new:\n            candidates.add(max(used + [0]) + 1)\n        curr[i] = random.choice(list(candidates))\n\n    # Random relabeling permutation of current used colors\n    used = sorted(set(curr))\n    perm = used[:]\n    random.shuffle(perm)\n    relabel = {c: perm[idx] for idx, c in enumerate(used)}\n    curr = [relabel[c] for c in curr]\n\n    # Compress to keep labels contiguous starting at 1\n    curr = compress_colors(curr)\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000488446}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1 Each solution is a list of 9 positive integers [c1,...,c9] where ci>=1 denotes the color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Problem constants (embedded)\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure check\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    invalid_label_penalty = 0\n    labels: List[int] = []\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n        labels.append(x)\n\n    # Edge conflicts\n    conflict_penalty = 0\n    for (u, v) in edges:\n        cu = labels[u-1]\n        cv = labels[v-1]\n        if cu == cv:\n            conflict_penalty += 10**4\n\n    # Objective: minimize number of distinct colors\n    distinct_colors = len(set(labels))\n\n    return float(distinct_colors + invalid_label_penalty + conflict_penalty)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    # NB_Type in {\"Local\"}; Movement_Type in {\"RecolorOne\",\"SwapTwo\"}\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    curr = list(solution)\n    move = random.random()\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to consecutive integers starting at 1 (order-preserving by first appearance)\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    if move < 0.5:\n        # Recolor one vertex to an existing or a new color (up to 9)\n        i = random.randrange(9)\n        used = list(set(curr))\n        # candidate colors: existing plus possibly a new one\n        max_new = 9\n        candidates = set(used)\n        if len(used) < max_new:\n            candidates.add(max(used + [0]) + 1)\n        new_color = random.choice(list(candidates))\n        curr[i] = new_color\n        curr = compress_colors(curr)\n        return (curr, (\"Local\",\"RecolorOne\"))\n    else:\n        # Swap colors between two vertices\n        i, j = random.sample(range(9), 2)\n        curr[i], curr[j] = curr[j], curr[i]\n        curr = compress_colors(curr)\n        return (curr, (\"Local\",\"SwapTwo\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    curr = list(solution)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Apply multiple random recolors and a random relabel shuffle\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(9)\n        used = list(set(curr))\n        max_new = 9\n        candidates = set(used)\n        if len(used) < max_new:\n            candidates.add(max(used + [0]) + 1)\n        curr[i] = random.choice(list(candidates))\n\n    # Random relabeling permutation of current used colors\n    used = sorted(set(curr))\n    perm = used[:]\n    random.shuffle(perm)\n    relabel = {c: perm[idx] for idx, c in enumerate(used)}\n    curr = [relabel[c] for c in curr]\n\n    # Compress to keep labels contiguous starting at 1\n    curr = compress_colors(curr)\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.0005975279}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1 Each solution is a list of 9 positive integers [c1,...,c9] where ci>=1 denotes the color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Problem constants (embedded)\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure check\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    invalid_label_penalty = 0\n    labels: List[int] = []\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n        labels.append(x)\n\n    # Edge conflicts\n    conflict_penalty = 0\n    for (u, v) in edges:\n        cu = labels[u-1]\n        cv = labels[v-1]\n        if cu == cv:\n            conflict_penalty += 10**4\n\n    # Objective: minimize number of distinct colors\n    distinct_colors = len(set(labels))\n\n    return float(distinct_colors + invalid_label_penalty + conflict_penalty)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    # NB_Type in {\"Local\"}; Movement_Type in {\"RecolorOne\",\"SwapTwo\"}\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    curr = list(solution)\n    move = random.random()\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to consecutive integers starting at 1 (order-preserving by first appearance)\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    if move < 0.5:\n        # Recolor one vertex to an existing or a new color (up to 9)\n        i = random.randrange(9)\n        used = list(set(curr))\n        # candidate colors: existing plus possibly a new one\n        max_new = 9\n        candidates = set(used)\n        if len(used) < max_new:\n            candidates.add(max(used + [0]) + 1)\n        new_color = random.choice(list(candidates))\n        curr[i] = new_color\n        curr = compress_colors(curr)\n        return (curr, (\"Local\",\"RecolorOne\"))\n    else:\n        # Swap colors between two vertices\n        i, j = random.sample(range(9), 2)\n        curr[i], curr[j] = curr[j], curr[i]\n        curr = compress_colors(curr)\n        return (curr, (\"Local\",\"SwapTwo\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    curr = list(solution)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Apply multiple random recolors and a random relabel shuffle\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(9)\n        used = list(set(curr))\n        max_new = 9\n        candidates = set(used)\n        if len(used) < max_new:\n            candidates.add(max(used + [0]) + 1)\n        curr[i] = random.choice(list(candidates))\n\n    # Random relabeling permutation of current used colors\n    used = sorted(set(curr))\n    perm = used[:]\n    random.shuffle(perm)\n    relabel = {c: perm[idx] for idx, c in enumerate(used)}\n    curr = [relabel[c] for c in curr]\n\n    # Compress to keep labels contiguous starting at 1\n    curr = compress_colors(curr)\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000579367}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1. Solution is a Python list of 9 positive integers [c1,...,c9], where ci>=1 denotes the color assigned to vertex i (1-indexed vertices).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels: List[int] = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n        labels.append(int(x) if isinstance(x, int) else 0)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else 9\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\nfrom typing import List, Tuple, Dict\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _kempe_chain_component(sol: List[int], adj: List[List[int]], start: int, a: int, b: int) -> List[int]:\n    n = len(sol)\n    visited = [False]*n\n    stack = [start]\n    comp = []\n    while stack:\n        u = stack.pop()\n        if visited[u]:\n            continue\n        if sol[u] != a and sol[u] != b:\n            continue\n        visited[u] = True\n        comp.append(u)\n        for v in adj[u]:\n            if not visited[v] and (sol[v] == a or sol[v] == b):\n                stack.append(v)\n    return comp\n\ndef _targeted_recolor(sol: List[int], adj: List[List[int]], u: int) -> List[int]:\n    n = len(sol)\n    curr = list(sol)\n    used_colors = set(curr)\n    neighbor_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in sorted(used_colors):\n        if c not in neighbor_colors:\n            curr[u] = c\n            return curr\n    # Otherwise open a new color id = max+1 (bounded by n)\n    new_c = min(max(used_colors)+1, n)\n    curr[u] = new_c\n    return curr\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    adj = _adjacency_list()\n    curr = list(solution)\n\n    # Choose move type adaptively: if conflicts exist, prefer fixing them\n    bad = _conflicting_vertices(curr, adj)\n    r = random.random()\n\n    if bad and r < 0.7:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor(curr, adj, u)\n        return (neigh, (\"Local\",\"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        # Pick second color present in neighborhood or from used palette\n        palette = list(sorted(set(curr)))\n        if len(palette) == 1:\n            b = a if a != 2 else 1\n        else:\n            # Prefer a color seen in neighbors to have effect\n            neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n            else:\n                b = random.choice([c for c in palette if c != a])\n        comp = _kempe_chain_component(curr, adj, u, a, b)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        return (neigh, (\"Local\",\"KempeChain\"))\n","Perturbacion":"import random\nfrom typing import List\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    # Determine conflicting vertices\n    def conflicts(sol: List[int]) -> List[int]:\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Apply 3-5 random aggressive moves focusing on conflicts\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        bad = conflicts(curr)\n        if bad and random.random() < 0.7:\n            # Targeted recolor\n            u = random.choice(bad)\n            neigh_colors = {curr[v] for v in adj[u]}\n            palette = set(curr)\n            candidates = [c for c in sorted(palette) if c not in neigh_colors]\n            if candidates:\n                curr[u] = random.choice(candidates)\n            else:\n                curr[u] = min(max(palette) + 1, 9)\n        else:\n            # Random Kempe chain to escape local basin\n            u = random.randrange(9)\n            a = curr[u]\n            palette = list(sorted(set(curr)))\n            b_choices = [c for c in palette if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            # Build component\n            visited = [False]*9\n            stack = [u]\n            comp = []\n            while stack:\n                x = stack.pop()\n                if visited[x]:\n                    continue\n                if curr[x] != a and curr[x] != b:\n                    continue\n                visited[x] = True\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (curr[y] == a or curr[y] == b):\n                        stack.append(y)\n            for w in comp:\n                curr[w] = b if curr[w] == a else a\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000912672}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1. Solution is a Python list of 9 positive integers [c1,...,c9], where ci>=1 denotes the color assigned to vertex i (1-indexed vertices).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels: List[int] = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n        labels.append(int(x) if isinstance(x, int) else 0)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else 9\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\nfrom typing import List, Tuple, Dict\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _kempe_chain_component(sol: List[int], adj: List[List[int]], start: int, a: int, b: int) -> List[int]:\n    n = len(sol)\n    visited = [False]*n\n    stack = [start]\n    comp = []\n    while stack:\n        u = stack.pop()\n        if visited[u]:\n            continue\n        if sol[u] != a and sol[u] != b:\n            continue\n        visited[u] = True\n        comp.append(u)\n        for v in adj[u]:\n            if not visited[v] and (sol[v] == a or sol[v] == b):\n                stack.append(v)\n    return comp\n\ndef _targeted_recolor(sol: List[int], adj: List[List[int]], u: int) -> List[int]:\n    n = len(sol)\n    curr = list(sol)\n    used_colors = set(curr)\n    neighbor_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in sorted(used_colors):\n        if c not in neighbor_colors:\n            curr[u] = c\n            return curr\n    # Otherwise open a new color id = max+1 (bounded by n)\n    new_c = min(max(used_colors)+1, n)\n    curr[u] = new_c\n    return curr\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    adj = _adjacency_list()\n    curr = list(solution)\n\n    # Choose move type adaptively: if conflicts exist, prefer fixing them\n    bad = _conflicting_vertices(curr, adj)\n    r = random.random()\n\n    if bad and r < 0.7:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor(curr, adj, u)\n        return (neigh, (\"Local\",\"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        # Pick second color present in neighborhood or from used palette\n        palette = list(sorted(set(curr)))\n        if len(palette) == 1:\n            b = a if a != 2 else 1\n        else:\n            # Prefer a color seen in neighbors to have effect\n            neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n            else:\n                b = random.choice([c for c in palette if c != a])\n        comp = _kempe_chain_component(curr, adj, u, a, b)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        return (neigh, (\"Local\",\"KempeChain\"))\n","Perturbacion":"import random\nfrom typing import List\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    # Determine conflicting vertices\n    def conflicts(sol: List[int]) -> List[int]:\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Apply 3-5 random aggressive moves focusing on conflicts\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        bad = conflicts(curr)\n        if bad and random.random() < 0.7:\n            # Targeted recolor\n            u = random.choice(bad)\n            neigh_colors = {curr[v] for v in adj[u]}\n            palette = set(curr)\n            candidates = [c for c in sorted(palette) if c not in neigh_colors]\n            if candidates:\n                curr[u] = random.choice(candidates)\n            else:\n                curr[u] = min(max(palette) + 1, 9)\n        else:\n            # Random Kempe chain to escape local basin\n            u = random.randrange(9)\n            a = curr[u]\n            palette = list(sorted(set(curr)))\n            b_choices = [c for c in palette if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            # Build component\n            visited = [False]*9\n            stack = [u]\n            comp = []\n            while stack:\n                x = stack.pop()\n                if visited[x]:\n                    continue\n                if curr[x] != a and curr[x] != b:\n                    continue\n                visited[x] = True\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (curr[y] == a or curr[y] == b):\n                        stack.append(y)\n            for w in comp:\n                curr[w] = b if curr[w] == a else a\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001221485}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1. Solution is a Python list of 9 positive integers [c1,...,c9], where ci>=1 denotes the color assigned to vertex i (1-indexed vertices).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels: List[int] = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n        labels.append(int(x) if isinstance(x, int) else 0)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else 9\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\nfrom typing import List, Tuple, Dict\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices(sol: List[int], adj: List[List[int]]) -> List[int]:\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _kempe_chain_component(sol: List[int], adj: List[List[int]], start: int, a: int, b: int) -> List[int]:\n    n = len(sol)\n    visited = [False]*n\n    stack = [start]\n    comp = []\n    while stack:\n        u = stack.pop()\n        if visited[u]:\n            continue\n        if sol[u] != a and sol[u] != b:\n            continue\n        visited[u] = True\n        comp.append(u)\n        for v in adj[u]:\n            if not visited[v] and (sol[v] == a or sol[v] == b):\n                stack.append(v)\n    return comp\n\ndef _targeted_recolor(sol: List[int], adj: List[List[int]], u: int) -> List[int]:\n    n = len(sol)\n    curr = list(sol)\n    used_colors = set(curr)\n    neighbor_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in sorted(used_colors):\n        if c not in neighbor_colors:\n            curr[u] = c\n            return curr\n    # Otherwise open a new color id = max+1 (bounded by n)\n    new_c = min(max(used_colors)+1, n)\n    curr[u] = new_c\n    return curr\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    adj = _adjacency_list()\n    curr = list(solution)\n\n    # Choose move type adaptively: if conflicts exist, prefer fixing them\n    bad = _conflicting_vertices(curr, adj)\n    r = random.random()\n\n    if bad and r < 0.7:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor(curr, adj, u)\n        return (neigh, (\"Local\",\"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        # Pick second color present in neighborhood or from used palette\n        palette = list(sorted(set(curr)))\n        if len(palette) == 1:\n            b = a if a != 2 else 1\n        else:\n            # Prefer a color seen in neighbors to have effect\n            neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n            else:\n                b = random.choice([c for c in palette if c != a])\n        comp = _kempe_chain_component(curr, adj, u, a, b)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        return (neigh, (\"Local\",\"KempeChain\"))\n","Perturbacion":"import random\nfrom typing import List\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    # Determine conflicting vertices\n    def conflicts(sol: List[int]) -> List[int]:\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Apply 3-5 random aggressive moves focusing on conflicts\n    steps = random.randint(3, 5)\n    for _ in range(steps):\n        bad = conflicts(curr)\n        if bad and random.random() < 0.7:\n            # Targeted recolor\n            u = random.choice(bad)\n            neigh_colors = {curr[v] for v in adj[u]}\n            palette = set(curr)\n            candidates = [c for c in sorted(palette) if c not in neigh_colors]\n            if candidates:\n                curr[u] = random.choice(candidates)\n            else:\n                curr[u] = min(max(palette) + 1, 9)\n        else:\n            # Random Kempe chain to escape local basin\n            u = random.randrange(9)\n            a = curr[u]\n            palette = list(sorted(set(curr)))\n            b_choices = [c for c in palette if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            # Build component\n            visited = [False]*9\n            stack = [u]\n            comp = []\n            while stack:\n                x = stack.pop()\n                if visited[x]:\n                    continue\n                if curr[x] != a and curr[x] != b:\n                    continue\n                visited[x] = True\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and (curr[y] == a or curr[y] == b):\n                        stack.append(y)\n            for w in comp:\n                curr[w] = b if curr[w] == a else a\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001174615}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1. Solution is a Python list of 9 positive integers [c1,...,c9], where vertex indices are 1..9 and each ci>=1 denotes the color assigned to vertex i.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels: List[int] = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n            labels.append(1 if not isinstance(x, int) or x < 1 else int(x))\n        else:\n            labels.append(int(x))\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else n\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\nfrom typing import List\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list_nb() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices_nb(sol: List[int], adj: List[List[int]]) -> List[int]:\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _compact_colors_nb(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..m by order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef _targeted_recolor_nb(sol: List[int], adj: List[List[int]], u: int) -> List[int]:\n    curr = list(sol)\n    used = sorted(set(curr))\n    neigh_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in used:\n        if c not in neigh_colors:\n            curr[u] = c\n            return _compact_colors_nb(curr)\n    # If all existing are blocked, try introducing at most one new color = max+1\n    new_c = max(used) + 1\n    curr[u] = new_c\n    return _compact_colors_nb(curr)\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\",\"NoOp\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    adj = _adjacency_list_nb()\n    curr = list(solution)\n\n    bad = _conflicting_vertices_nb(curr, adj)\n    # Adaptive probability to prioritize conflict removal\n    p_recolor = min(0.95, 0.5 + 0.05*len(bad)) if bad else 0.25\n\n    r = random.random()\n    if bad and r < p_recolor:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor_nb(curr, adj, u)\n        return (neigh, (\"Local\",\"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return (list(curr), (\"Local\",\"NoOp\"))\n        # Prefer neighbor color to increase effect\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        # Build component of colors a and b\n        visited = [False]*9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        neigh = _compact_colors_nb(neigh)\n        return (neigh, (\"Local\",\"KempeChain\"))\n","Perturbacion":"import random\nfrom typing import List\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _compact_colors_p(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    def conflicts(sol: List[int]) -> List[int]:\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Two-tier perturbation\n    steps_conflict = random.randint(2, 3)  # conflict-focused recolors\n    for _ in range(steps_conflict):\n        bad = conflicts(curr)\n        if not bad:\n            break\n        u = random.choice(bad)\n        neigh_colors = {curr[v] for v in adj[u]}\n        palette = sorted(set(curr))\n        candidates = [c for c in palette if c not in neigh_colors]\n        if candidates:\n            curr[u] = random.choice(candidates)\n        else:\n            curr[u] = max(palette) + 1  # open one new color if necessary\n        curr = _compact_colors_p(curr)\n\n    # Diversification: 1\u20132 random Kempe chain swaps\n    steps_div = random.randint(1, 2)\n    for _ in range(steps_div):\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        visited = [False]*9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        for w in comp:\n            curr[w] = b if curr[w] == a else a\n        curr = _compact_colors_p(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000891361}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1. Solution is a Python list of 9 positive integers [c1,...,c9], where vertex indices are 1..9 and each ci>=1 denotes the color assigned to vertex i.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels: List[int] = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n            labels.append(1 if not isinstance(x, int) or x < 1 else int(x))\n        else:\n            labels.append(int(x))\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else n\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\nfrom typing import List\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list_nb() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices_nb(sol: List[int], adj: List[List[int]]) -> List[int]:\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _compact_colors_nb(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..m by order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef _targeted_recolor_nb(sol: List[int], adj: List[List[int]], u: int) -> List[int]:\n    curr = list(sol)\n    used = sorted(set(curr))\n    neigh_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in used:\n        if c not in neigh_colors:\n            curr[u] = c\n            return _compact_colors_nb(curr)\n    # If all existing are blocked, try introducing at most one new color = max+1\n    new_c = max(used) + 1\n    curr[u] = new_c\n    return _compact_colors_nb(curr)\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\",\"NoOp\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    adj = _adjacency_list_nb()\n    curr = list(solution)\n\n    bad = _conflicting_vertices_nb(curr, adj)\n    # Adaptive probability to prioritize conflict removal\n    p_recolor = min(0.95, 0.5 + 0.05*len(bad)) if bad else 0.25\n\n    r = random.random()\n    if bad and r < p_recolor:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor_nb(curr, adj, u)\n        return (neigh, (\"Local\",\"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return (list(curr), (\"Local\",\"NoOp\"))\n        # Prefer neighbor color to increase effect\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        # Build component of colors a and b\n        visited = [False]*9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        neigh = _compact_colors_nb(neigh)\n        return (neigh, (\"Local\",\"KempeChain\"))\n","Perturbacion":"import random\nfrom typing import List\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _compact_colors_p(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    def conflicts(sol: List[int]) -> List[int]:\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Two-tier perturbation\n    steps_conflict = random.randint(2, 3)  # conflict-focused recolors\n    for _ in range(steps_conflict):\n        bad = conflicts(curr)\n        if not bad:\n            break\n        u = random.choice(bad)\n        neigh_colors = {curr[v] for v in adj[u]}\n        palette = sorted(set(curr))\n        candidates = [c for c in palette if c not in neigh_colors]\n        if candidates:\n            curr[u] = random.choice(candidates)\n        else:\n            curr[u] = max(palette) + 1  # open one new color if necessary\n        curr = _compact_colors_p(curr)\n\n    # Diversification: 1\u20132 random Kempe chain swaps\n    steps_div = random.randint(1, 2)\n    for _ in range(steps_div):\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        visited = [False]*9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        for w in comp:\n            curr[w] = b if curr[w] == a else a\n        curr = _compact_colors_p(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001226666}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1. Solution is a Python list of 9 positive integers [c1,...,c9], where vertex indices are 1..9 and each ci>=1 denotes the color assigned to vertex i.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels: List[int] = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n            labels.append(1 if not isinstance(x, int) or x < 1 else int(x))\n        else:\n            labels.append(int(x))\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else n\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\nfrom typing import List\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list_nb() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices_nb(sol: List[int], adj: List[List[int]]) -> List[int]:\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _compact_colors_nb(sol: List[int]) -> List[int]:\n    # Relabel colors to 1..m by order of first appearance\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef _targeted_recolor_nb(sol: List[int], adj: List[List[int]], u: int) -> List[int]:\n    curr = list(sol)\n    used = sorted(set(curr))\n    neigh_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in used:\n        if c not in neigh_colors:\n            curr[u] = c\n            return _compact_colors_nb(curr)\n    # If all existing are blocked, try introducing at most one new color = max+1\n    new_c = max(used) + 1\n    curr[u] = new_c\n    return _compact_colors_nb(curr)\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\",\"NoOp\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\",\"NoOp\"))\n\n    adj = _adjacency_list_nb()\n    curr = list(solution)\n\n    bad = _conflicting_vertices_nb(curr, adj)\n    # Adaptive probability to prioritize conflict removal\n    p_recolor = min(0.95, 0.5 + 0.05*len(bad)) if bad else 0.25\n\n    r = random.random()\n    if bad and r < p_recolor:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor_nb(curr, adj, u)\n        return (neigh, (\"Local\",\"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            return (list(curr), (\"Local\",\"NoOp\"))\n        # Prefer neighbor color to increase effect\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        # Build component of colors a and b\n        visited = [False]*9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        neigh = _compact_colors_nb(neigh)\n        return (neigh, (\"Local\",\"KempeChain\"))\n","Perturbacion":"import random\nfrom typing import List\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p() -> List[List[int]]:\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _compact_colors_p(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    def conflicts(sol: List[int]) -> List[int]:\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Two-tier perturbation\n    steps_conflict = random.randint(2, 3)  # conflict-focused recolors\n    for _ in range(steps_conflict):\n        bad = conflicts(curr)\n        if not bad:\n            break\n        u = random.choice(bad)\n        neigh_colors = {curr[v] for v in adj[u]}\n        palette = sorted(set(curr))\n        candidates = [c for c in palette if c not in neigh_colors]\n        if candidates:\n            curr[u] = random.choice(candidates)\n        else:\n            curr[u] = max(palette) + 1  # open one new color if necessary\n        curr = _compact_colors_p(curr)\n\n    # Diversification: 1\u20132 random Kempe chain swaps\n    steps_div = random.randint(1, 2)\n    for _ in range(steps_div):\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        visited = [False]*9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        for w in comp:\n            curr[w] = b if curr[w] == a else a\n        curr = _compact_colors_p(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001153314}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n            labels.append(1)\n        else:\n            labels.append(int(x))\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else n\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list_nb():\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices_nb(sol, adj):\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _compact_colors_nb(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef _targeted_recolor_nb(sol, adj, u):\n    curr = list(sol)\n    used = sorted(set(curr))\n    neigh_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in used:\n        if c not in neigh_colors:\n            curr[u] = c\n            return _compact_colors_nb(curr)\n    # If all existing are blocked, introduce a new color = max+1\n    new_c = (max(used) + 1) if used else 1\n    curr[u] = new_c\n    return _compact_colors_nb(curr)\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\",\"NoOp\",\"Invalid\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\", \"NoOp\"))\n\n    adj = _adjacency_list_nb()\n    curr = list(solution)\n\n    bad = _conflicting_vertices_nb(curr, adj)\n    # Adaptive probability to prioritize conflict removal\n    p_recolor = min(0.95, 0.5 + 0.05 * len(bad)) if bad else 0.25\n\n    r = random.random()\n    if bad and r < p_recolor:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor_nb(curr, adj, u)\n        return (neigh, (\"Local\", \"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            # Fallback to targeted recolor to avoid NoOp\n            neigh = _targeted_recolor_nb(curr, adj, u)\n            return (neigh, (\"Local\", \"TargetedRecolor\"))\n        # Prefer neighbor color to increase effect\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        # Build component of colors a and b\n        visited = [False] * 9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        neigh = _compact_colors_nb(neigh)\n        return (neigh, (\"Local\", \"KempeChain\"))\n","Perturbacion":"import random\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p():\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _compact_colors_p(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    def conflicts(sol):\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Tier 1: conflict-focused recolors (2-3 steps)\n    steps_conflict = random.randint(2, 3)\n    for _ in range(steps_conflict):\n        bad = conflicts(curr)\n        if not bad:\n            break\n        u = random.choice(bad)\n        neigh_colors = {curr[v] for v in adj[u]}\n        palette = sorted(set(curr))\n        candidates = [c for c in palette if c not in neigh_colors]\n        if candidates:\n            curr[u] = random.choice(candidates)\n        else:\n            curr[u] = (max(palette) + 1) if palette else 1\n        curr = _compact_colors_p(curr)\n\n    # Tier 2: diversification via 1\u20132 Kempe chain swaps\n    steps_div = random.randint(1, 2)\n    for _ in range(steps_div):\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        # Prefer adjacent color if available\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        visited = [False] * 9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        for w in comp:\n            curr[w] = b if curr[w] == a else a\n        curr = _compact_colors_p(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: _adjacency_list_nb() takes 0 positional arguments but 1 was given.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000835871}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n            labels.append(1)\n        else:\n            labels.append(int(x))\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else n\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list_nb():\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices_nb(sol, adj):\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _compact_colors_nb(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef _targeted_recolor_nb(sol, adj, u):\n    curr = list(sol)\n    used = sorted(set(curr))\n    neigh_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in used:\n        if c not in neigh_colors:\n            curr[u] = c\n            return _compact_colors_nb(curr)\n    # If all existing are blocked, introduce a new color = max+1\n    new_c = (max(used) + 1) if used else 1\n    curr[u] = new_c\n    return _compact_colors_nb(curr)\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\",\"NoOp\",\"Invalid\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\", \"NoOp\"))\n\n    adj = _adjacency_list_nb()\n    curr = list(solution)\n\n    bad = _conflicting_vertices_nb(curr, adj)\n    # Adaptive probability to prioritize conflict removal\n    p_recolor = min(0.95, 0.5 + 0.05 * len(bad)) if bad else 0.25\n\n    r = random.random()\n    if bad and r < p_recolor:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor_nb(curr, adj, u)\n        return (neigh, (\"Local\", \"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            # Fallback to targeted recolor to avoid NoOp\n            neigh = _targeted_recolor_nb(curr, adj, u)\n            return (neigh, (\"Local\", \"TargetedRecolor\"))\n        # Prefer neighbor color to increase effect\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        # Build component of colors a and b\n        visited = [False] * 9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        neigh = _compact_colors_nb(neigh)\n        return (neigh, (\"Local\", \"KempeChain\"))\n","Perturbacion":"import random\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p():\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _compact_colors_p(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    def conflicts(sol):\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Tier 1: conflict-focused recolors (2-3 steps)\n    steps_conflict = random.randint(2, 3)\n    for _ in range(steps_conflict):\n        bad = conflicts(curr)\n        if not bad:\n            break\n        u = random.choice(bad)\n        neigh_colors = {curr[v] for v in adj[u]}\n        palette = sorted(set(curr))\n        candidates = [c for c in palette if c not in neigh_colors]\n        if candidates:\n            curr[u] = random.choice(candidates)\n        else:\n            curr[u] = (max(palette) + 1) if palette else 1\n        curr = _compact_colors_p(curr)\n\n    # Tier 2: diversification via 1\u20132 Kempe chain swaps\n    steps_div = random.randint(1, 2)\n    for _ in range(steps_div):\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        # Prefer adjacent color if available\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        visited = [False] * 9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        for w in comp:\n            curr[w] = b if curr[w] == a else a\n        curr = _compact_colors_p(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: _adjacency_list_nb() takes 0 positional arguments but 1 was given.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001159744}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POS_INT>=1","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem definition\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n\n    # Structure validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(10**9)\n\n    labels = []\n    invalid_label_penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_label_penalty += 10**6\n            labels.append(1)\n        else:\n            labels.append(int(x))\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = labels[u - 1]\n        cv = labels[v - 1]\n        if cu == cv:\n            conflicts += 1\n\n    # Minimize distinct colors with heavy precedence for feasibility\n    distinct_colors = len(set(labels)) if invalid_label_penalty == 0 else n\n\n    # Scalarized objective: conflicts first (large weight), then colors\n    W = 10000  # conflict weight\n    score = conflicts * W + distinct_colors + invalid_label_penalty\n    return float(score)\n","Vecindad":"import random\n\n# Helper utilities embedded to keep function self-contained\n\ndef _adjacency_list_nb():\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef _conflicting_vertices_nb(sol, adj):\n    bad = []\n    for u in range(len(sol)):\n        cu = sol[u]\n        for v in adj[u]:\n            if cu == sol[v]:\n                bad.append(u)\n                break\n    return bad\n\ndef _compact_colors_nb(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef _targeted_recolor_nb(sol, adj, u):\n    curr = list(sol)\n    used = sorted(set(curr))\n    neigh_colors = {curr[v] for v in adj[u]}\n    # Try lowest feasible existing color first\n    for c in used:\n        if c not in neigh_colors:\n            curr[u] = c\n            return _compact_colors_nb(curr)\n    # If all existing are blocked, introduce a new color = max+1\n    new_c = (max(used) + 1) if used else 1\n    curr[u] = new_c\n    return _compact_colors_nb(curr)\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"Local\"}\n    Movement_Type in {\"TargetedRecolor\",\"KempeChain\",\"NoOp\",\"Invalid\"}\n    \"\"\"\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"Invalid\", \"NoOp\"))\n\n    adj = _adjacency_list_nb()\n    curr = list(solution)\n\n    bad = _conflicting_vertices_nb(curr, adj)\n    # Adaptive probability to prioritize conflict removal\n    p_recolor = min(0.95, 0.5 + 0.05 * len(bad)) if bad else 0.25\n\n    r = random.random()\n    if bad and r < p_recolor:\n        # Targeted recolor a conflicting vertex\n        u = random.choice(bad)\n        neigh = _targeted_recolor_nb(curr, adj, u)\n        return (neigh, (\"Local\", \"TargetedRecolor\"))\n    else:\n        # Kempe chain between two colors through a random vertex\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            # Fallback to targeted recolor to avoid NoOp\n            neigh = _targeted_recolor_nb(curr, adj, u)\n            return (neigh, (\"Local\", \"TargetedRecolor\"))\n        # Prefer neighbor color to increase effect\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        # Build component of colors a and b\n        visited = [False] * 9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        neigh = list(curr)\n        for w in comp:\n            neigh[w] = b if curr[w] == a else a\n        neigh = _compact_colors_nb(neigh)\n        return (neigh, (\"Local\", \"KempeChain\"))\n","Perturbacion":"import random\n\n# Reuse local helpers (duplicated for self-containment)\n\ndef _adjacency_list_p():\n    n = 9\n    edges = [\n        (1,7),(1,8),(2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),(6,8),(7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _compact_colors_p(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    adj = _adjacency_list_p()\n    curr = list(solution)\n\n    def conflicts(sol):\n        out = []\n        for u in range(len(sol)):\n            cu = sol[u]\n            for v in adj[u]:\n                if cu == sol[v]:\n                    out.append(u)\n                    break\n        return out\n\n    # Tier 1: conflict-focused recolors (2-3 steps)\n    steps_conflict = random.randint(2, 3)\n    for _ in range(steps_conflict):\n        bad = conflicts(curr)\n        if not bad:\n            break\n        u = random.choice(bad)\n        neigh_colors = {curr[v] for v in adj[u]}\n        palette = sorted(set(curr))\n        candidates = [c for c in palette if c not in neigh_colors]\n        if candidates:\n            curr[u] = random.choice(candidates)\n        else:\n            curr[u] = (max(palette) + 1) if palette else 1\n        curr = _compact_colors_p(curr)\n\n    # Tier 2: diversification via 1\u20132 Kempe chain swaps\n    steps_div = random.randint(1, 2)\n    for _ in range(steps_div):\n        u = random.randrange(9)\n        a = curr[u]\n        palette = list(sorted(set(curr)))\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        # Prefer adjacent color if available\n        neigh_colors = [curr[v] for v in adj[u] if curr[v] != a]\n        b = random.choice(neigh_colors) if neigh_colors else random.choice(b_choices)\n        visited = [False] * 9\n        stack = [u]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if visited[x]:\n                continue\n            if curr[x] != a and curr[x] != b:\n                continue\n            visited[x] = True\n            comp.append(x)\n            for y in adj[x]:\n                if not visited[y] and (curr[y] == a or curr[y] == b):\n                    stack.append(y)\n        for w in comp:\n            curr[w] = b if curr[w] == a else a\n        curr = _compact_colors_p(curr)\n\n    return curr\n","Resultados":"Failed to run target heuristic: _adjacency_list_nb() takes 0 positional arguments but 1 was given.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001089034}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    PEN_LEN = 1_000_000\n    PEN_TYPE = 10_000\n    PEN_NONPOS = 1_000\n    PEN_CONFLICT = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    n = 9\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n    return conflicts * PEN_CONFLICT + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _count_conflicts(sol: List[int], edges: List[tuple]) -> int:\n    c = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            c += 1\n    return c\n\ndef _node_conflicts(sol: List[int], edges: List[tuple]) -> List[int]:\n    # return per-node conflict counts\n    n = len(sol)\n    cnt = [0]*n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            cnt[u-1] += 1\n            cnt[v-1] += 1\n    return cnt\n\ndef _best_recolor(sol: List[int], idx: int, edges: List[tuple]) -> int:\n    # choose color in 1..max_k+1 minimizing conflicts for node idx\n    current = sol[idx]\n    max_k = max(sol) if sol else 1\n    candidate_colors = list(range(1, max_k + 2))\n    random.shuffle(candidate_colors)\n    best_c = current\n    best_conf = None\n    for c in candidate_colors:\n        if c == current:\n            # evaluate as well to allow staying\n            pass\n        tmp = sol[:]\n        tmp[idx] = c\n        # compute conflicts touching idx only\n        conf = 0\n        for (u, v) in edges:\n            if u-1 == idx or v-1 == idx:\n                if tmp[u-1] == tmp[v-1]:\n                    conf += 1\n        if (best_conf is None) or (conf < best_conf):\n            best_conf = conf\n            best_c = c\n    return best_c\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x <= 0) for x in solution):\n        # initialize a random coloring with small number of colors\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(9)]\n    else:\n        sol = solution[:]\n\n    n = len(sol)\n    node_conf = _node_conflicts(sol, edges)\n    total_conf = sum(node_conf)\/\/2\n\n    if total_conf > 0:\n        # Focused recolor on a conflicting node\n        conflicted_indices = [i for i, c in enumerate(node_conf) if c > 0]\n        idx = random.choice(conflicted_indices)\n        new_color = _best_recolor(sol, idx, edges)\n        sol[idx] = new_color\n        return (sol, \"LOCAL\", \"RECOLOR\")\n    else:\n        # No conflicts: attempt color reduction or mild diversification\n        move_type = \"RECOLOR\"\n        if random.random() < 0.5:\n            # Try to merge colors by recoloring a node to another existing color\n            idx = random.randrange(n)\n            existing = list(set(sol))\n            if len(existing) > 1:\n                target = random.choice([c for c in existing if c != sol[idx]])\n                sol[idx] = target\n                move_type = \"MERGE_RECOLOR\"\n            else:\n                # introduce slight perturbation\n                sol[idx] = max(sol)  # keep same color set\n        else:\n            # Swap colors between two nodes\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n            move_type = \"SWAP\"\n        return (sol, \"LOCAL\", move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Start from a safe copy or random init if invalid\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x <= 0) for x in solution):\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(9)]\n    else:\n        sol = solution[:]\n\n    n = len(sol)\n    k = max(sol)\n    steps = max(2, n \/\/ 4)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        # diversify within 1..k+1\n        new_c = random.randint(1, k + 1)\n        # avoid trivial no-op\n        if new_c == sol[idx]:\n            new_c = (new_c % (k + 1)) + 1\n        sol[idx] = new_c\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00083692}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    PEN_LEN = 1_000_000\n    PEN_TYPE = 10_000\n    PEN_NONPOS = 1_000\n    PEN_CONFLICT = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    n = 9\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n    return conflicts * PEN_CONFLICT + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _count_conflicts(sol: List[int], edges: List[tuple]) -> int:\n    c = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            c += 1\n    return c\n\ndef _node_conflicts(sol: List[int], edges: List[tuple]) -> List[int]:\n    # return per-node conflict counts\n    n = len(sol)\n    cnt = [0]*n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            cnt[u-1] += 1\n            cnt[v-1] += 1\n    return cnt\n\ndef _best_recolor(sol: List[int], idx: int, edges: List[tuple]) -> int:\n    # choose color in 1..max_k+1 minimizing conflicts for node idx\n    current = sol[idx]\n    max_k = max(sol) if sol else 1\n    candidate_colors = list(range(1, max_k + 2))\n    random.shuffle(candidate_colors)\n    best_c = current\n    best_conf = None\n    for c in candidate_colors:\n        if c == current:\n            # evaluate as well to allow staying\n            pass\n        tmp = sol[:]\n        tmp[idx] = c\n        # compute conflicts touching idx only\n        conf = 0\n        for (u, v) in edges:\n            if u-1 == idx or v-1 == idx:\n                if tmp[u-1] == tmp[v-1]:\n                    conf += 1\n        if (best_conf is None) or (conf < best_conf):\n            best_conf = conf\n            best_c = c\n    return best_c\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x <= 0) for x in solution):\n        # initialize a random coloring with small number of colors\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(9)]\n    else:\n        sol = solution[:]\n\n    n = len(sol)\n    node_conf = _node_conflicts(sol, edges)\n    total_conf = sum(node_conf)\/\/2\n\n    if total_conf > 0:\n        # Focused recolor on a conflicting node\n        conflicted_indices = [i for i, c in enumerate(node_conf) if c > 0]\n        idx = random.choice(conflicted_indices)\n        new_color = _best_recolor(sol, idx, edges)\n        sol[idx] = new_color\n        return (sol, \"LOCAL\", \"RECOLOR\")\n    else:\n        # No conflicts: attempt color reduction or mild diversification\n        move_type = \"RECOLOR\"\n        if random.random() < 0.5:\n            # Try to merge colors by recoloring a node to another existing color\n            idx = random.randrange(n)\n            existing = list(set(sol))\n            if len(existing) > 1:\n                target = random.choice([c for c in existing if c != sol[idx]])\n                sol[idx] = target\n                move_type = \"MERGE_RECOLOR\"\n            else:\n                # introduce slight perturbation\n                sol[idx] = max(sol)  # keep same color set\n        else:\n            # Swap colors between two nodes\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n            move_type = \"SWAP\"\n        return (sol, \"LOCAL\", move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Start from a safe copy or random init if invalid\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x <= 0) for x in solution):\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(9)]\n    else:\n        sol = solution[:]\n\n    n = len(sol)\n    k = max(sol)\n    steps = max(2, n \/\/ 4)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        # diversify within 1..k+1\n        new_c = random.randint(1, k + 1)\n        # avoid trivial no-op\n        if new_c == sol[idx]:\n            new_c = (new_c % (k + 1)) + 1\n        sol[idx] = new_c\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000889521}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    PEN_LEN = 1_000_000\n    PEN_TYPE = 10_000\n    PEN_NONPOS = 1_000\n    PEN_CONFLICT = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    n = 9\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n    return conflicts * PEN_CONFLICT + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef _count_conflicts(sol: List[int], edges: List[tuple]) -> int:\n    c = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            c += 1\n    return c\n\ndef _node_conflicts(sol: List[int], edges: List[tuple]) -> List[int]:\n    # return per-node conflict counts\n    n = len(sol)\n    cnt = [0]*n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            cnt[u-1] += 1\n            cnt[v-1] += 1\n    return cnt\n\ndef _best_recolor(sol: List[int], idx: int, edges: List[tuple]) -> int:\n    # choose color in 1..max_k+1 minimizing conflicts for node idx\n    current = sol[idx]\n    max_k = max(sol) if sol else 1\n    candidate_colors = list(range(1, max_k + 2))\n    random.shuffle(candidate_colors)\n    best_c = current\n    best_conf = None\n    for c in candidate_colors:\n        if c == current:\n            # evaluate as well to allow staying\n            pass\n        tmp = sol[:]\n        tmp[idx] = c\n        # compute conflicts touching idx only\n        conf = 0\n        for (u, v) in edges:\n            if u-1 == idx or v-1 == idx:\n                if tmp[u-1] == tmp[v-1]:\n                    conf += 1\n        if (best_conf is None) or (conf < best_conf):\n            best_conf = conf\n            best_c = c\n    return best_c\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x <= 0) for x in solution):\n        # initialize a random coloring with small number of colors\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(9)]\n    else:\n        sol = solution[:]\n\n    n = len(sol)\n    node_conf = _node_conflicts(sol, edges)\n    total_conf = sum(node_conf)\/\/2\n\n    if total_conf > 0:\n        # Focused recolor on a conflicting node\n        conflicted_indices = [i for i, c in enumerate(node_conf) if c > 0]\n        idx = random.choice(conflicted_indices)\n        new_color = _best_recolor(sol, idx, edges)\n        sol[idx] = new_color\n        return (sol, \"LOCAL\", \"RECOLOR\")\n    else:\n        # No conflicts: attempt color reduction or mild diversification\n        move_type = \"RECOLOR\"\n        if random.random() < 0.5:\n            # Try to merge colors by recoloring a node to another existing color\n            idx = random.randrange(n)\n            existing = list(set(sol))\n            if len(existing) > 1:\n                target = random.choice([c for c in existing if c != sol[idx]])\n                sol[idx] = target\n                move_type = \"MERGE_RECOLOR\"\n            else:\n                # introduce slight perturbation\n                sol[idx] = max(sol)  # keep same color set\n        else:\n            # Swap colors between two nodes\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n            move_type = \"SWAP\"\n        return (sol, \"LOCAL\", move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Start from a safe copy or random init if invalid\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x <= 0) for x in solution):\n        k0 = 3\n        sol = [random.randint(1, k0) for _ in range(9)]\n    else:\n        sol = solution[:]\n\n    n = len(sol)\n    k = max(sol)\n    steps = max(2, n \/\/ 4)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        # diversify within 1..k+1\n        new_c = random.randint(1, k + 1)\n        # avoid trivial no-op\n        if new_c == sol[idx]:\n            new_c = (new_c % (k + 1)) + 1\n        sol[idx] = new_c\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000866881}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Validation: do not reinitialize here; if invalid, return NOOP for upstream fix\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        return (solution, \"INVALID\", \"NOOP\")\n\n    sol = solution[:]\n\n    # Utility structures\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Color counts\n    color_counts = {}\n    for c in sol:\n        color_counts[c] = color_counts.get(c, 0) + 1\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n\n    # Total conflicts\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n\n    def try_color(idx: int, new_c: int) -> Tuple[int, int]:\n        # returns (delta_conflicts, delta_k) relative to current sol\n        old_c = sol[idx]\n        if new_c == old_c:\n            return (0, 0)\n        # compute conflicts incident to idx\n        before = 0\n        after = 0\n        for nb in adj[idx]:\n            before += 1 if sol[nb] == old_c else 0\n            after += 1 if sol[nb] == new_c else 0\n        delta_conf = after - before\n        # k change\n        current_k = max(sol)\n        delta_k = 0\n        if new_c > current_k:\n            delta_k = 1\n        else:\n            # if removing last of old color reduces k and old color is the max color\n            if color_counts.get(old_c, 0) == 1 and old_c == current_k:\n                # Removing last occurrence of current max may reduce k by 1 if no other color equals current_k after relabeling.\n                # Conservative: check if there exists any node with color == current_k other than idx\n                delta_k = -1\n        return (delta_conf, delta_k)\n\n    def best_recolor(idx: int) -> int:\n        current_k = max(sol)\n        candidates = list(range(1, current_k + 2))\n        random.shuffle(candidates)\n        best_c = sol[idx]\n        best_score = (10**9, 10**9)  # (delta_conflicts, delta_k)\n        for c in candidates:\n            dc, dk = try_color(idx, c)\n            score = (dc, dk)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    if total_conflicts > 0:\n        # Focus on most problematic nodes (conflict- and degree-weighted)\n        degrees = [len(adj[i]) for i in range(n)]\n        scores = [(per_node_conf[i] * 100 + degrees[i], i) for i in range(n) if per_node_conf[i] > 0]\n        scores.sort(reverse=True)\n        idx = scores[0][1]\n        new_color = best_recolor(idx)\n        old_color = sol[idx]\n        if new_color != old_color:\n            # update color counts\n            color_counts[old_color] -= 1\n            color_counts[new_color] = color_counts.get(new_color, 0) + 1\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Conflict-free: attempt targeted color elimination\n        # Pick a color class to eliminate (smallest class > 0, excluding color 1 to reduce relabel churn)\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        target_color = None\n        for c, nodes in sorted(classes.items(), key=lambda kv: (len(kv[1]), kv[0])):\n            if len(nodes) > 0:\n                target_color = c\n                break\n        if target_color is not None and len(classes) > 1:\n            movable = classes[target_color][:]\n            current_k = max(sol)\n            success = True\n            for idx in movable:\n                # try recolor into existing colors 1..current_k except target_color with no conflicts\n                moved = False\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    # check feasibility\n                    feasible = True\n                    for nb in adj[idx]:\n                        if sol[nb] == c:\n                            feasible = False\n                            break\n                    if feasible:\n                        sol[idx] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (sol, \"LOCAL\", \"COLOR_ELIM\")\n            else:\n                # revert partially failed moves by no-op since we work on a copy; mark as attempt\n                return (solution[:], \"LOCAL\", \"ELIM_FAIL\")\n        # fallback mild diversification without increasing k: single safe recolor if possible\n        idx = random.randrange(n)\n        current_k = max(sol)\n        for c in range(1, current_k + 1):\n            if c == sol[idx]:\n                continue\n            feasible = True\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    feasible = False\n                    break\n            if feasible:\n                sol[idx] = c\n                return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        # deterministic fallback perturbation: assign 1..3 cyclically\n        base = [1,2,3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    k = max(sol)\n\n    # Conflict-aware kick strength\n    s = max(2, n \/\/ 3)\n    # Select nodes: prioritize highest conflict; if all zero, random distinct nodes\n    if sum(per_node_conf) > 0:\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n    else:\n        indices = random.sample(range(n), s)\n\n    for idx in indices:\n        new_c = random.randint(1, k + 1)\n        if new_c == sol[idx]:\n            new_c = (new_c % (k + 1)) + 1\n        sol[idx] = new_c\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001080814}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Validation: do not reinitialize here; if invalid, return NOOP for upstream fix\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        return (solution, \"INVALID\", \"NOOP\")\n\n    sol = solution[:]\n\n    # Utility structures\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Color counts\n    color_counts = {}\n    for c in sol:\n        color_counts[c] = color_counts.get(c, 0) + 1\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n\n    # Total conflicts\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n\n    def try_color(idx: int, new_c: int) -> Tuple[int, int]:\n        # returns (delta_conflicts, delta_k) relative to current sol\n        old_c = sol[idx]\n        if new_c == old_c:\n            return (0, 0)\n        # compute conflicts incident to idx\n        before = 0\n        after = 0\n        for nb in adj[idx]:\n            before += 1 if sol[nb] == old_c else 0\n            after += 1 if sol[nb] == new_c else 0\n        delta_conf = after - before\n        # k change\n        current_k = max(sol)\n        delta_k = 0\n        if new_c > current_k:\n            delta_k = 1\n        else:\n            # if removing last of old color reduces k and old color is the max color\n            if color_counts.get(old_c, 0) == 1 and old_c == current_k:\n                # Removing last occurrence of current max may reduce k by 1 if no other color equals current_k after relabeling.\n                # Conservative: check if there exists any node with color == current_k other than idx\n                delta_k = -1\n        return (delta_conf, delta_k)\n\n    def best_recolor(idx: int) -> int:\n        current_k = max(sol)\n        candidates = list(range(1, current_k + 2))\n        random.shuffle(candidates)\n        best_c = sol[idx]\n        best_score = (10**9, 10**9)  # (delta_conflicts, delta_k)\n        for c in candidates:\n            dc, dk = try_color(idx, c)\n            score = (dc, dk)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    if total_conflicts > 0:\n        # Focus on most problematic nodes (conflict- and degree-weighted)\n        degrees = [len(adj[i]) for i in range(n)]\n        scores = [(per_node_conf[i] * 100 + degrees[i], i) for i in range(n) if per_node_conf[i] > 0]\n        scores.sort(reverse=True)\n        idx = scores[0][1]\n        new_color = best_recolor(idx)\n        old_color = sol[idx]\n        if new_color != old_color:\n            # update color counts\n            color_counts[old_color] -= 1\n            color_counts[new_color] = color_counts.get(new_color, 0) + 1\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Conflict-free: attempt targeted color elimination\n        # Pick a color class to eliminate (smallest class > 0, excluding color 1 to reduce relabel churn)\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        target_color = None\n        for c, nodes in sorted(classes.items(), key=lambda kv: (len(kv[1]), kv[0])):\n            if len(nodes) > 0:\n                target_color = c\n                break\n        if target_color is not None and len(classes) > 1:\n            movable = classes[target_color][:]\n            current_k = max(sol)\n            success = True\n            for idx in movable:\n                # try recolor into existing colors 1..current_k except target_color with no conflicts\n                moved = False\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    # check feasibility\n                    feasible = True\n                    for nb in adj[idx]:\n                        if sol[nb] == c:\n                            feasible = False\n                            break\n                    if feasible:\n                        sol[idx] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (sol, \"LOCAL\", \"COLOR_ELIM\")\n            else:\n                # revert partially failed moves by no-op since we work on a copy; mark as attempt\n                return (solution[:], \"LOCAL\", \"ELIM_FAIL\")\n        # fallback mild diversification without increasing k: single safe recolor if possible\n        idx = random.randrange(n)\n        current_k = max(sol)\n        for c in range(1, current_k + 1):\n            if c == sol[idx]:\n                continue\n            feasible = True\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    feasible = False\n                    break\n            if feasible:\n                sol[idx] = c\n                return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        # deterministic fallback perturbation: assign 1..3 cyclically\n        base = [1,2,3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    k = max(sol)\n\n    # Conflict-aware kick strength\n    s = max(2, n \/\/ 3)\n    # Select nodes: prioritize highest conflict; if all zero, random distinct nodes\n    if sum(per_node_conf) > 0:\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n    else:\n        indices = random.sample(range(n), s)\n\n    for idx in indices:\n        new_c = random.randint(1, k + 1)\n        if new_c == sol[idx]:\n            new_c = (new_c % (k + 1)) + 1\n        sol[idx] = new_c\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001226575}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Validation: do not reinitialize here; if invalid, return NOOP for upstream fix\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        return (solution, \"INVALID\", \"NOOP\")\n\n    sol = solution[:]\n\n    # Utility structures\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Color counts\n    color_counts = {}\n    for c in sol:\n        color_counts[c] = color_counts.get(c, 0) + 1\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        cnt = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                cnt += 1\n        return cnt\n\n    # Total conflicts\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n\n    def try_color(idx: int, new_c: int) -> Tuple[int, int]:\n        # returns (delta_conflicts, delta_k) relative to current sol\n        old_c = sol[idx]\n        if new_c == old_c:\n            return (0, 0)\n        # compute conflicts incident to idx\n        before = 0\n        after = 0\n        for nb in adj[idx]:\n            before += 1 if sol[nb] == old_c else 0\n            after += 1 if sol[nb] == new_c else 0\n        delta_conf = after - before\n        # k change\n        current_k = max(sol)\n        delta_k = 0\n        if new_c > current_k:\n            delta_k = 1\n        else:\n            # if removing last of old color reduces k and old color is the max color\n            if color_counts.get(old_c, 0) == 1 and old_c == current_k:\n                # Removing last occurrence of current max may reduce k by 1 if no other color equals current_k after relabeling.\n                # Conservative: check if there exists any node with color == current_k other than idx\n                delta_k = -1\n        return (delta_conf, delta_k)\n\n    def best_recolor(idx: int) -> int:\n        current_k = max(sol)\n        candidates = list(range(1, current_k + 2))\n        random.shuffle(candidates)\n        best_c = sol[idx]\n        best_score = (10**9, 10**9)  # (delta_conflicts, delta_k)\n        for c in candidates:\n            dc, dk = try_color(idx, c)\n            score = (dc, dk)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    if total_conflicts > 0:\n        # Focus on most problematic nodes (conflict- and degree-weighted)\n        degrees = [len(adj[i]) for i in range(n)]\n        scores = [(per_node_conf[i] * 100 + degrees[i], i) for i in range(n) if per_node_conf[i] > 0]\n        scores.sort(reverse=True)\n        idx = scores[0][1]\n        new_color = best_recolor(idx)\n        old_color = sol[idx]\n        if new_color != old_color:\n            # update color counts\n            color_counts[old_color] -= 1\n            color_counts[new_color] = color_counts.get(new_color, 0) + 1\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Conflict-free: attempt targeted color elimination\n        # Pick a color class to eliminate (smallest class > 0, excluding color 1 to reduce relabel churn)\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        target_color = None\n        for c, nodes in sorted(classes.items(), key=lambda kv: (len(kv[1]), kv[0])):\n            if len(nodes) > 0:\n                target_color = c\n                break\n        if target_color is not None and len(classes) > 1:\n            movable = classes[target_color][:]\n            current_k = max(sol)\n            success = True\n            for idx in movable:\n                # try recolor into existing colors 1..current_k except target_color with no conflicts\n                moved = False\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    # check feasibility\n                    feasible = True\n                    for nb in adj[idx]:\n                        if sol[nb] == c:\n                            feasible = False\n                            break\n                    if feasible:\n                        sol[idx] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (sol, \"LOCAL\", \"COLOR_ELIM\")\n            else:\n                # revert partially failed moves by no-op since we work on a copy; mark as attempt\n                return (solution[:], \"LOCAL\", \"ELIM_FAIL\")\n        # fallback mild diversification without increasing k: single safe recolor if possible\n        idx = random.randrange(n)\n        current_k = max(sol)\n        for c in range(1, current_k + 1):\n            if c == sol[idx]:\n                continue\n            feasible = True\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    feasible = False\n                    break\n            if feasible:\n                sol[idx] = c\n                return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        # deterministic fallback perturbation: assign 1..3 cyclically\n        base = [1,2,3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    k = max(sol)\n\n    # Conflict-aware kick strength\n    s = max(2, n \/\/ 3)\n    # Select nodes: prioritize highest conflict; if all zero, random distinct nodes\n    if sum(per_node_conf) > 0:\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n    else:\n        indices = random.sample(range(n), s)\n\n    for idx in indices:\n        new_c = random.randint(1, k + 1)\n        if new_c == sol[idx]:\n            new_c = (new_c % (k + 1)) + 1\n        sol[idx] = new_c\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001186615}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Validation: return NOOP if invalid; upstream should repair\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        return (solution, \"INVALID\", \"NOOP\")\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Helpers\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    current_k = max(sol)\n\n    def try_color(idx: int, new_c: int) -> Tuple[int, int]:\n        old_c = sol[idx]\n        if new_c == old_c:\n            return (0, 0)\n        # incident conflict delta\n        before = 0\n        after = 0\n        for nb in adj[idx]:\n            before += 1 if sol[nb] == old_c else 0\n            after += 1 if sol[nb] == new_c else 0\n        delta_conf = after - before\n        # new k\n        # compute max color among all nodes except idx\n        other_max = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if sol[j] > other_max:\n                other_max = sol[j]\n        new_k = new_c if new_c > other_max else other_max\n        delta_k = 0\n        if new_k > current_k:\n            delta_k = 1\n        elif new_k < current_k:\n            delta_k = -1\n        return (delta_conf, delta_k)\n\n    def best_recolor(idx: int) -> int:\n        # Candidates: 1..current_k+1\n        candidates = list(range(1, current_k + 2))\n        # Prefer smaller resulting k then lower color index; shuffle within same class for diversification\n        random.shuffle(candidates)\n        best_c = sol[idx]\n        best_score = (10**9, 10**9)\n        for c in candidates:\n            dc, dk = try_color(idx, c)\n            score = (dc, dk, c)\n            # Compare lexicographically on (delta_conflicts, delta_k, color)\n            if (score[0], score[1], score[2]) < (best_score[0], best_score[1], best_c):\n                best_score = (dc, dk)\n                best_c = c\n        return best_c\n\n    if total_conflicts > 0:\n        # Select node with highest conflicts; break ties by degree then index\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], degrees[i], -i), reverse=True)\n        idx = order[0]\n        new_color = best_recolor(idx)\n        old_color = sol[idx]\n        if new_color != old_color:\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Conflict-free: attempt targeted color elimination, skip color 1 to reduce churn\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        if len(classes) > 1:\n            # choose smallest non-empty color class excluding 1 if possible\n            candidates = [c for c in classes.keys() if c != 1]\n            if not candidates:\n                candidates = list(classes.keys())\n            target_color = min(candidates, key=lambda c: (len(classes[c]), c))\n            movable = classes[target_color][:]\n            # Order by mobility: fewer feasible colors first\n            def mobility(idx: int) -> int:\n                feas = 0\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    if all(sol[nb] != c for nb in adj[idx]):\n                        feas += 1\n                return feas\n            movable.sort(key=lambda i: (mobility(i), len(adj[i])))\n            temp_sol = sol[:]\n            success = True\n            for idx in movable:\n                moved = False\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    if all(temp_sol[nb] != c for nb in adj[idx]):\n                        temp_sol[idx] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (temp_sol, \"LOCAL\", \"COLOR_ELIM\")\n        # Fallback: safe recolor that does not increase k and keeps conflict-free\n        idx = random.randrange(n)\n        for c in range(1, current_k + 1):\n            if c == sol[idx]:\n                continue\n            if all(sol[nb] != c for nb in adj[idx]):\n                sol[idx] = c\n                return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Deterministic fallback for invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    k = max(sol)\n\n    rng = random.Random()\n\n    if total_conflicts > 0:\n        # Conflict-aware kick: recolor s highest-conflict nodes arbitrarily within 1..k+1\n        s = max(2, n \/\/ 3)\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n        for idx in indices:\n            new_c = rng.randint(1, k + 1)\n            if new_c == sol[idx]:\n                new_c = (new_c % (k + 1)) + 1\n            sol[idx] = new_c\n        return sol\n    else:\n        # Conflict-free strong perturbation: swap two random color classes (Kempe-like shuffle)\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        if len(classes) >= 2:\n            colors = list(classes.keys())\n            a, b = rng.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n        else:\n            # If only one color present (unlikely), random recolor a few nodes to diversify\n            s = max(2, n \/\/ 3)\n            for idx in rng.sample(range(n), s):\n                sol[idx] = rng.randint(1, k + 1)\n        return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001165195}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Validation: return NOOP if invalid; upstream should repair\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        return (solution, \"INVALID\", \"NOOP\")\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Helpers\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    current_k = max(sol)\n\n    def try_color(idx: int, new_c: int) -> Tuple[int, int]:\n        old_c = sol[idx]\n        if new_c == old_c:\n            return (0, 0)\n        # incident conflict delta\n        before = 0\n        after = 0\n        for nb in adj[idx]:\n            before += 1 if sol[nb] == old_c else 0\n            after += 1 if sol[nb] == new_c else 0\n        delta_conf = after - before\n        # new k\n        # compute max color among all nodes except idx\n        other_max = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if sol[j] > other_max:\n                other_max = sol[j]\n        new_k = new_c if new_c > other_max else other_max\n        delta_k = 0\n        if new_k > current_k:\n            delta_k = 1\n        elif new_k < current_k:\n            delta_k = -1\n        return (delta_conf, delta_k)\n\n    def best_recolor(idx: int) -> int:\n        # Candidates: 1..current_k+1\n        candidates = list(range(1, current_k + 2))\n        # Prefer smaller resulting k then lower color index; shuffle within same class for diversification\n        random.shuffle(candidates)\n        best_c = sol[idx]\n        best_score = (10**9, 10**9)\n        for c in candidates:\n            dc, dk = try_color(idx, c)\n            score = (dc, dk, c)\n            # Compare lexicographically on (delta_conflicts, delta_k, color)\n            if (score[0], score[1], score[2]) < (best_score[0], best_score[1], best_c):\n                best_score = (dc, dk)\n                best_c = c\n        return best_c\n\n    if total_conflicts > 0:\n        # Select node with highest conflicts; break ties by degree then index\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], degrees[i], -i), reverse=True)\n        idx = order[0]\n        new_color = best_recolor(idx)\n        old_color = sol[idx]\n        if new_color != old_color:\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Conflict-free: attempt targeted color elimination, skip color 1 to reduce churn\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        if len(classes) > 1:\n            # choose smallest non-empty color class excluding 1 if possible\n            candidates = [c for c in classes.keys() if c != 1]\n            if not candidates:\n                candidates = list(classes.keys())\n            target_color = min(candidates, key=lambda c: (len(classes[c]), c))\n            movable = classes[target_color][:]\n            # Order by mobility: fewer feasible colors first\n            def mobility(idx: int) -> int:\n                feas = 0\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    if all(sol[nb] != c for nb in adj[idx]):\n                        feas += 1\n                return feas\n            movable.sort(key=lambda i: (mobility(i), len(adj[i])))\n            temp_sol = sol[:]\n            success = True\n            for idx in movable:\n                moved = False\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    if all(temp_sol[nb] != c for nb in adj[idx]):\n                        temp_sol[idx] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (temp_sol, \"LOCAL\", \"COLOR_ELIM\")\n        # Fallback: safe recolor that does not increase k and keeps conflict-free\n        idx = random.randrange(n)\n        for c in range(1, current_k + 1):\n            if c == sol[idx]:\n                continue\n            if all(sol[nb] != c for nb in adj[idx]):\n                sol[idx] = c\n                return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Deterministic fallback for invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    k = max(sol)\n\n    rng = random.Random()\n\n    if total_conflicts > 0:\n        # Conflict-aware kick: recolor s highest-conflict nodes arbitrarily within 1..k+1\n        s = max(2, n \/\/ 3)\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n        for idx in indices:\n            new_c = rng.randint(1, k + 1)\n            if new_c == sol[idx]:\n                new_c = (new_c % (k + 1)) + 1\n            sol[idx] = new_c\n        return sol\n    else:\n        # Conflict-free strong perturbation: swap two random color classes (Kempe-like shuffle)\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        if len(classes) >= 2:\n            colors = list(classes.keys())\n            a, b = rng.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n        else:\n            # If only one color present (unlikely), random recolor a few nodes to diversify\n            s = max(2, n \/\/ 3)\n            for idx in rng.sample(range(n), s):\n                sol[idx] = rng.randint(1, k + 1)\n        return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001460248}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Validation: return NOOP if invalid; upstream should repair\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        return (solution, \"INVALID\", \"NOOP\")\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Helpers\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    current_k = max(sol)\n\n    def try_color(idx: int, new_c: int) -> Tuple[int, int]:\n        old_c = sol[idx]\n        if new_c == old_c:\n            return (0, 0)\n        # incident conflict delta\n        before = 0\n        after = 0\n        for nb in adj[idx]:\n            before += 1 if sol[nb] == old_c else 0\n            after += 1 if sol[nb] == new_c else 0\n        delta_conf = after - before\n        # new k\n        # compute max color among all nodes except idx\n        other_max = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if sol[j] > other_max:\n                other_max = sol[j]\n        new_k = new_c if new_c > other_max else other_max\n        delta_k = 0\n        if new_k > current_k:\n            delta_k = 1\n        elif new_k < current_k:\n            delta_k = -1\n        return (delta_conf, delta_k)\n\n    def best_recolor(idx: int) -> int:\n        # Candidates: 1..current_k+1\n        candidates = list(range(1, current_k + 2))\n        # Prefer smaller resulting k then lower color index; shuffle within same class for diversification\n        random.shuffle(candidates)\n        best_c = sol[idx]\n        best_score = (10**9, 10**9)\n        for c in candidates:\n            dc, dk = try_color(idx, c)\n            score = (dc, dk, c)\n            # Compare lexicographically on (delta_conflicts, delta_k, color)\n            if (score[0], score[1], score[2]) < (best_score[0], best_score[1], best_c):\n                best_score = (dc, dk)\n                best_c = c\n        return best_c\n\n    if total_conflicts > 0:\n        # Select node with highest conflicts; break ties by degree then index\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], degrees[i], -i), reverse=True)\n        idx = order[0]\n        new_color = best_recolor(idx)\n        old_color = sol[idx]\n        if new_color != old_color:\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Conflict-free: attempt targeted color elimination, skip color 1 to reduce churn\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        if len(classes) > 1:\n            # choose smallest non-empty color class excluding 1 if possible\n            candidates = [c for c in classes.keys() if c != 1]\n            if not candidates:\n                candidates = list(classes.keys())\n            target_color = min(candidates, key=lambda c: (len(classes[c]), c))\n            movable = classes[target_color][:]\n            # Order by mobility: fewer feasible colors first\n            def mobility(idx: int) -> int:\n                feas = 0\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    if all(sol[nb] != c for nb in adj[idx]):\n                        feas += 1\n                return feas\n            movable.sort(key=lambda i: (mobility(i), len(adj[i])))\n            temp_sol = sol[:]\n            success = True\n            for idx in movable:\n                moved = False\n                for c in range(1, current_k + 1):\n                    if c == target_color:\n                        continue\n                    if all(temp_sol[nb] != c for nb in adj[idx]):\n                        temp_sol[idx] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (temp_sol, \"LOCAL\", \"COLOR_ELIM\")\n        # Fallback: safe recolor that does not increase k and keeps conflict-free\n        idx = random.randrange(n)\n        for c in range(1, current_k + 1):\n            if c == sol[idx]:\n                continue\n            if all(sol[nb] != c for nb in adj[idx]):\n                sol[idx] = c\n                return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Deterministic fallback for invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u-1, v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    k = max(sol)\n\n    rng = random.Random()\n\n    if total_conflicts > 0:\n        # Conflict-aware kick: recolor s highest-conflict nodes arbitrarily within 1..k+1\n        s = max(2, n \/\/ 3)\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n        for idx in indices:\n            new_c = rng.randint(1, k + 1)\n            if new_c == sol[idx]:\n                new_c = (new_c % (k + 1)) + 1\n            sol[idx] = new_c\n        return sol\n    else:\n        # Conflict-free strong perturbation: swap two random color classes (Kempe-like shuffle)\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        if len(classes) >= 2:\n            colors = list(classes.keys())\n            a, b = rng.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n        else:\n            # If only one color present (unlikely), random recolor a few nodes to diversify\n            s = max(2, n \/\/ 3)\n            for idx in rng.sample(range(n), s):\n                sol[idx] = rng.randint(1, k + 1)\n        return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001326746}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import Dict, List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Basic validation and minimal repair\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        repaired = [base[i % 3] for i in range(n)]\n        return (repaired, \"REPAIR\", \"INIT_BASELINE\")\n\n    sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Neighbor color counts per node\n    def neighbor_color_counts(s: List[int]) -> List[Dict[int, int]]:\n        counts = [dict() for _ in range(n)]\n        for i in range(n):\n            for nb in adj[i]:\n                c = s[nb]\n                counts[i][c] = counts[i].get(c, 0) + 1\n        return counts\n\n    adj_colors = neighbor_color_counts(sol)\n\n    # Per-node conflicts and totals\n    per_node_conflicts = [adj_colors[i].get(sol[i], 0) for i in range(n)]\n    total_conflicts = sum(per_node_conflicts) \/\/ 2\n\n    # Color frequencies and current k\n    color_freq: Dict[int, int] = {}\n    for c in sol:\n        color_freq[c] = color_freq.get(c, 0) + 1\n    current_k = max(color_freq.keys()) if color_freq else 0\n\n    rng = random.Random()\n\n    def new_k_after_move(idx: int, new_c: int) -> int:\n        old_c = sol[idx]\n        if new_c > current_k:\n            return new_c\n        # If removing the last occurrence of current_k and moving below it, k may drop\n        if old_c == current_k and color_freq.get(current_k, 0) == 1 and new_c < current_k:\n            # find next lower present color label\n            candidate = current_k - 1\n            while candidate >= 1 and color_freq.get(candidate, 0) == 0:\n                candidate -= 1\n            return candidate if candidate >= 1 else new_c\n        return current_k\n\n    def best_recolor(idx: int) -> Tuple[int, int]:\n        old_c = sol[idx]\n        candidates = list(range(1, current_k + 2))  # allow introducing a new color temporarily\n        rng.shuffle(candidates)\n        best_c = old_c\n        best_tuple = (10**9, 10**9, 10**9)\n        old_conf_here = adj_colors[idx].get(old_c, 0)\n        for c in candidates:\n            if c == old_c:\n                continue\n            # delta conflicts at idx only (dominant factor)\n            after_conf_here = adj_colors[idx].get(c, 0)\n            delta_conf = after_conf_here - old_conf_here\n            # delta k\n            nk = new_k_after_move(idx, c)\n            delta_k = nk - current_k\n            # prefer lower delta_conf, then lower delta_k, then lower color index\n            score = (delta_conf, delta_k, c)\n            if score < best_tuple:\n                best_tuple = score\n                best_c = c\n        return best_c, best_tuple[0]\n\n    if total_conflicts > 0:\n        # Choose the most conflicted node; tie-break by degree then index\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (per_node_conflicts[i], degrees[i], -i), reverse=True)\n        idx = order[0]\n        new_color, _ = best_recolor(idx)\n        if new_color != sol[idx]:\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Attempt to eliminate the highest color class (current_k)\n        if current_k >= 2:\n            targets = [i for i in range(n) if sol[i] == current_k]\n            if targets:\n                tmp = list(sol)\n                success = True\n                for idx in targets:\n                    moved = False\n                    # try colors 1..current_k-1\n                    for c in range(1, current_k):\n                        if all(tmp[nb] != c for nb in adj[idx]):\n                            tmp[idx] = c\n                            moved = True\n                            break\n                    if not moved:\n                        success = False\n                        break\n                if success:\n                    return (tmp, \"LOCAL\", \"COLOR_ELIM\")\n        # Fallback: safe recolor within existing colors to diversify without adding conflicts\n        # Prefer nodes in larger color classes with higher mobility\n        classes: Dict[int, List[int]] = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        # pick node from the largest class with available alternative colors\n        candidate_nodes = []\n        for c, nodes in classes.items():\n            for i in nodes:\n                mobility = 0\n                for nc in range(1, current_k + 1):\n                    if nc == sol[i]:\n                        continue\n                    if all(sol[nb] != nc for nb in adj[i]):\n                        mobility += 1\n                if mobility > 0:\n                    candidate_nodes.append((len(nodes), -mobility, i))\n        if candidate_nodes:\n            candidate_nodes.sort(reverse=True)\n            _, _, idx = candidate_nodes[0]\n            for nc in range(1, current_k + 1):\n                if nc != sol[idx] and all(sol[nb] != nc for nb in adj[idx]):\n                    sol[idx] = nc\n                    return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Deterministic baseline if invalid\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    k = max(sol)\n\n    rng = random.Random()\n\n    if total_conflicts > 0:\n        # Recolor s highest-conflict nodes randomly within [1..k+1]\n        s = max(2, n \/\/ 3)\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n        for idx in indices:\n            new_c = rng.randint(1, k + 1)\n            if new_c == sol[idx]:\n                new_c = (new_c % (k + 1)) + 1\n            sol[idx] = new_c\n        return sol\n    else:\n        # Kempe-like color class swap between two random classes\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        colors = list(classes.keys())\n        if len(colors) >= 2:\n            a, b = rng.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            return sol\n        # If only one color present, random recolor a few nodes\n        s = max(2, n \/\/ 3)\n        for idx in rng.sample(range(n), s):\n            sol[idx] = rng.randint(1, k + 1)\n        return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001269036}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import Dict, List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Basic validation and minimal repair\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        repaired = [base[i % 3] for i in range(n)]\n        return (repaired, \"REPAIR\", \"INIT_BASELINE\")\n\n    sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Neighbor color counts per node\n    def neighbor_color_counts(s: List[int]) -> List[Dict[int, int]]:\n        counts = [dict() for _ in range(n)]\n        for i in range(n):\n            for nb in adj[i]:\n                c = s[nb]\n                counts[i][c] = counts[i].get(c, 0) + 1\n        return counts\n\n    adj_colors = neighbor_color_counts(sol)\n\n    # Per-node conflicts and totals\n    per_node_conflicts = [adj_colors[i].get(sol[i], 0) for i in range(n)]\n    total_conflicts = sum(per_node_conflicts) \/\/ 2\n\n    # Color frequencies and current k\n    color_freq: Dict[int, int] = {}\n    for c in sol:\n        color_freq[c] = color_freq.get(c, 0) + 1\n    current_k = max(color_freq.keys()) if color_freq else 0\n\n    rng = random.Random()\n\n    def new_k_after_move(idx: int, new_c: int) -> int:\n        old_c = sol[idx]\n        if new_c > current_k:\n            return new_c\n        # If removing the last occurrence of current_k and moving below it, k may drop\n        if old_c == current_k and color_freq.get(current_k, 0) == 1 and new_c < current_k:\n            # find next lower present color label\n            candidate = current_k - 1\n            while candidate >= 1 and color_freq.get(candidate, 0) == 0:\n                candidate -= 1\n            return candidate if candidate >= 1 else new_c\n        return current_k\n\n    def best_recolor(idx: int) -> Tuple[int, int]:\n        old_c = sol[idx]\n        candidates = list(range(1, current_k + 2))  # allow introducing a new color temporarily\n        rng.shuffle(candidates)\n        best_c = old_c\n        best_tuple = (10**9, 10**9, 10**9)\n        old_conf_here = adj_colors[idx].get(old_c, 0)\n        for c in candidates:\n            if c == old_c:\n                continue\n            # delta conflicts at idx only (dominant factor)\n            after_conf_here = adj_colors[idx].get(c, 0)\n            delta_conf = after_conf_here - old_conf_here\n            # delta k\n            nk = new_k_after_move(idx, c)\n            delta_k = nk - current_k\n            # prefer lower delta_conf, then lower delta_k, then lower color index\n            score = (delta_conf, delta_k, c)\n            if score < best_tuple:\n                best_tuple = score\n                best_c = c\n        return best_c, best_tuple[0]\n\n    if total_conflicts > 0:\n        # Choose the most conflicted node; tie-break by degree then index\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (per_node_conflicts[i], degrees[i], -i), reverse=True)\n        idx = order[0]\n        new_color, _ = best_recolor(idx)\n        if new_color != sol[idx]:\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Attempt to eliminate the highest color class (current_k)\n        if current_k >= 2:\n            targets = [i for i in range(n) if sol[i] == current_k]\n            if targets:\n                tmp = list(sol)\n                success = True\n                for idx in targets:\n                    moved = False\n                    # try colors 1..current_k-1\n                    for c in range(1, current_k):\n                        if all(tmp[nb] != c for nb in adj[idx]):\n                            tmp[idx] = c\n                            moved = True\n                            break\n                    if not moved:\n                        success = False\n                        break\n                if success:\n                    return (tmp, \"LOCAL\", \"COLOR_ELIM\")\n        # Fallback: safe recolor within existing colors to diversify without adding conflicts\n        # Prefer nodes in larger color classes with higher mobility\n        classes: Dict[int, List[int]] = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        # pick node from the largest class with available alternative colors\n        candidate_nodes = []\n        for c, nodes in classes.items():\n            for i in nodes:\n                mobility = 0\n                for nc in range(1, current_k + 1):\n                    if nc == sol[i]:\n                        continue\n                    if all(sol[nb] != nc for nb in adj[i]):\n                        mobility += 1\n                if mobility > 0:\n                    candidate_nodes.append((len(nodes), -mobility, i))\n        if candidate_nodes:\n            candidate_nodes.sort(reverse=True)\n            _, _, idx = candidate_nodes[0]\n            for nc in range(1, current_k + 1):\n                if nc != sol[idx] and all(sol[nb] != nc for nb in adj[idx]):\n                    sol[idx] = nc\n                    return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Deterministic baseline if invalid\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    k = max(sol)\n\n    rng = random.Random()\n\n    if total_conflicts > 0:\n        # Recolor s highest-conflict nodes randomly within [1..k+1]\n        s = max(2, n \/\/ 3)\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n        for idx in indices:\n            new_c = rng.randint(1, k + 1)\n            if new_c == sol[idx]:\n                new_c = (new_c % (k + 1)) + 1\n            sol[idx] = new_c\n        return sol\n    else:\n        # Kempe-like color class swap between two random classes\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        colors = list(classes.keys())\n        if len(colors) >= 2:\n            a, b = rng.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            return sol\n        # If only one color present, random recolor a few nodes\n        s = max(2, n \/\/ 3)\n        for idx in rng.sample(range(n), s):\n            sol[idx] = rng.randint(1, k + 1)\n        return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001379007}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_LEN9_INT","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Penalties for invalid inputs\n    PEN_TYPE = 10_000\n    PEN_LEN = 1_000_000\n    PEN_NONPOS = 1_000\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    invalid_type = 0\n    nonpos = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        elif x <= 0:\n            nonpos += 1\n    if invalid_type > 0 or nonpos > 0:\n        return PEN_TYPE * invalid_type + nonpos * PEN_NONPOS\n\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    k = max(solution) if solution else 0\n\n    # Lexicographic scalarization: conflicts dominate, then k\n    # |E| = 17, so multiplier = |E|+1 = 18 ensures conflicts strictly dominate k\n    return conflicts * 18 + k\n","Vecindad":"import random\nfrom typing import Dict, List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Basic validation and minimal repair\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        repaired = [base[i % 3] for i in range(n)]\n        return (repaired, \"REPAIR\", \"INIT_BASELINE\")\n\n    sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Neighbor color counts per node\n    def neighbor_color_counts(s: List[int]) -> List[Dict[int, int]]:\n        counts = [dict() for _ in range(n)]\n        for i in range(n):\n            for nb in adj[i]:\n                c = s[nb]\n                counts[i][c] = counts[i].get(c, 0) + 1\n        return counts\n\n    adj_colors = neighbor_color_counts(sol)\n\n    # Per-node conflicts and totals\n    per_node_conflicts = [adj_colors[i].get(sol[i], 0) for i in range(n)]\n    total_conflicts = sum(per_node_conflicts) \/\/ 2\n\n    # Color frequencies and current k\n    color_freq: Dict[int, int] = {}\n    for c in sol:\n        color_freq[c] = color_freq.get(c, 0) + 1\n    current_k = max(color_freq.keys()) if color_freq else 0\n\n    rng = random.Random()\n\n    def new_k_after_move(idx: int, new_c: int) -> int:\n        old_c = sol[idx]\n        if new_c > current_k:\n            return new_c\n        # If removing the last occurrence of current_k and moving below it, k may drop\n        if old_c == current_k and color_freq.get(current_k, 0) == 1 and new_c < current_k:\n            # find next lower present color label\n            candidate = current_k - 1\n            while candidate >= 1 and color_freq.get(candidate, 0) == 0:\n                candidate -= 1\n            return candidate if candidate >= 1 else new_c\n        return current_k\n\n    def best_recolor(idx: int) -> Tuple[int, int]:\n        old_c = sol[idx]\n        candidates = list(range(1, current_k + 2))  # allow introducing a new color temporarily\n        rng.shuffle(candidates)\n        best_c = old_c\n        best_tuple = (10**9, 10**9, 10**9)\n        old_conf_here = adj_colors[idx].get(old_c, 0)\n        for c in candidates:\n            if c == old_c:\n                continue\n            # delta conflicts at idx only (dominant factor)\n            after_conf_here = adj_colors[idx].get(c, 0)\n            delta_conf = after_conf_here - old_conf_here\n            # delta k\n            nk = new_k_after_move(idx, c)\n            delta_k = nk - current_k\n            # prefer lower delta_conf, then lower delta_k, then lower color index\n            score = (delta_conf, delta_k, c)\n            if score < best_tuple:\n                best_tuple = score\n                best_c = c\n        return best_c, best_tuple[0]\n\n    if total_conflicts > 0:\n        # Choose the most conflicted node; tie-break by degree then index\n        degrees = [len(adj[i]) for i in range(n)]\n        order = sorted(range(n), key=lambda i: (per_node_conflicts[i], degrees[i], -i), reverse=True)\n        idx = order[0]\n        new_color, _ = best_recolor(idx)\n        if new_color != sol[idx]:\n            sol[idx] = new_color\n            return (sol, \"LOCAL\", \"RECOLOR\")\n        else:\n            return (sol, \"LOCAL\", \"NOOP\")\n    else:\n        # Attempt to eliminate the highest color class (current_k)\n        if current_k >= 2:\n            targets = [i for i in range(n) if sol[i] == current_k]\n            if targets:\n                tmp = list(sol)\n                success = True\n                for idx in targets:\n                    moved = False\n                    # try colors 1..current_k-1\n                    for c in range(1, current_k):\n                        if all(tmp[nb] != c for nb in adj[idx]):\n                            tmp[idx] = c\n                            moved = True\n                            break\n                    if not moved:\n                        success = False\n                        break\n                if success:\n                    return (tmp, \"LOCAL\", \"COLOR_ELIM\")\n        # Fallback: safe recolor within existing colors to diversify without adding conflicts\n        # Prefer nodes in larger color classes with higher mobility\n        classes: Dict[int, List[int]] = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        # pick node from the largest class with available alternative colors\n        candidate_nodes = []\n        for c, nodes in classes.items():\n            for i in nodes:\n                mobility = 0\n                for nc in range(1, current_k + 1):\n                    if nc == sol[i]:\n                        continue\n                    if all(sol[nb] != nc for nb in adj[i]):\n                        mobility += 1\n                if mobility > 0:\n                    candidate_nodes.append((len(nodes), -mobility, i))\n        if candidate_nodes:\n            candidate_nodes.sort(reverse=True)\n            _, _, idx = candidate_nodes[0]\n            for nc in range(1, current_k + 1):\n                if nc != sol[idx] and all(sol[nb] != nc for nb in adj[idx]):\n                    sol[idx] = nc\n                    return (sol, \"LOCAL\", \"SAFE_RECOLOR\")\n        return (sol, \"LOCAL\", \"NOOP\")\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Deterministic baseline if invalid\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1, 2, 3]\n        return [base[i % 3] for i in range(n)]\n\n    sol = list(solution)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def node_conflicts(idx: int) -> int:\n        c = sol[idx]\n        return sum(1 for nb in adj[idx] if sol[nb] == c)\n\n    per_node_conf = [node_conflicts(i) for i in range(n)]\n    total_conflicts = sum(per_node_conf) \/\/ 2\n    k = max(sol)\n\n    rng = random.Random()\n\n    if total_conflicts > 0:\n        # Recolor s highest-conflict nodes randomly within [1..k+1]\n        s = max(2, n \/\/ 3)\n        order = sorted(range(n), key=lambda i: (per_node_conf[i], len(adj[i])), reverse=True)\n        indices = order[:s]\n        for idx in indices:\n            new_c = rng.randint(1, k + 1)\n            if new_c == sol[idx]:\n                new_c = (new_c % (k + 1)) + 1\n            sol[idx] = new_c\n        return sol\n    else:\n        # Kempe-like color class swap between two random classes\n        classes = {}\n        for i, c in enumerate(sol):\n            classes.setdefault(c, []).append(i)\n        colors = list(classes.keys())\n        if len(colors) >= 2:\n            a, b = rng.sample(colors, 2)\n            for i in range(n):\n                if sol[i] == a:\n                    sol[i] = b\n                elif sol[i] == b:\n                    sol[i] = a\n            return sol\n        # If only one color present, random recolor a few nodes\n        s = max(2, n \/\/ 3)\n        for idx in rng.sample(range(n), s):\n            sol[idx] = rng.randint(1, k + 1)\n        return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001320397}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9; solution is a list of 9 positive integers where index i-1 stores color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate type and basic shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: heavy penalty on conflicts, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    # Fitness: lower objective is better -> return negative\n    return -float(objective)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _safe_colors(solution: List[int]) -> List[int]:\n    # Limit palette to existing colors plus possibly one extra to escape local minima\n    colors = sorted(set(solution))\n    # Allow introduction of at most one new color = max_color+1, capped small for stability\n    max_color = max(colors) if colors else 1\n    colors.append(max_color + 1)\n    return colors\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Recolor a single vertex to a (possibly) different color\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    n = 9\n    idx = random.randrange(n)\n    palette = _safe_colors(solution)\n    current_color = solution[idx]\n    # Ensure a different color is chosen when possible\n    choices = [c for c in palette if c != current_color] or palette\n    new_color = random.choice(choices)\n    new_solution = solution.copy()\n    new_solution[idx] = new_color\n    return new_solution, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger move: multiple recolorings and optional color merge\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    new_solution = solution.copy()\n    # Randomly recolor k vertices\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    palette = sorted(set(new_solution))\n    max_color = max(palette) if palette else 1\n    # Optionally introduce one new color\n    if random.random() < 0.5:\n        palette.append(max_color + 1)\n    for idx in indices:\n        new_solution[idx] = random.choice(palette)\n    # Optional merge: map one color to another to reduce palette\n    if len(set(new_solution)) > 1 and random.random() < 0.5:\n        colors = list(set(new_solution))\n        c_from, c_to = random.sample(colors, 2)\n        new_solution = [c_to if c == c_from else c for c in new_solution]\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000446286}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9; solution is a list of 9 positive integers where index i-1 stores color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate type and basic shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: heavy penalty on conflicts, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    # Fitness: lower objective is better -> return negative\n    return -float(objective)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _safe_colors(solution: List[int]) -> List[int]:\n    # Limit palette to existing colors plus possibly one extra to escape local minima\n    colors = sorted(set(solution))\n    # Allow introduction of at most one new color = max_color+1, capped small for stability\n    max_color = max(colors) if colors else 1\n    colors.append(max_color + 1)\n    return colors\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Recolor a single vertex to a (possibly) different color\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    n = 9\n    idx = random.randrange(n)\n    palette = _safe_colors(solution)\n    current_color = solution[idx]\n    # Ensure a different color is chosen when possible\n    choices = [c for c in palette if c != current_color] or palette\n    new_color = random.choice(choices)\n    new_solution = solution.copy()\n    new_solution[idx] = new_color\n    return new_solution, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger move: multiple recolorings and optional color merge\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    new_solution = solution.copy()\n    # Randomly recolor k vertices\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    palette = sorted(set(new_solution))\n    max_color = max(palette) if palette else 1\n    # Optionally introduce one new color\n    if random.random() < 0.5:\n        palette.append(max_color + 1)\n    for idx in indices:\n        new_solution[idx] = random.choice(palette)\n    # Optional merge: map one color to another to reduce palette\n    if len(set(new_solution)) > 1 and random.random() < 0.5:\n        colors = list(set(new_solution))\n        c_from, c_to = random.sample(colors, 2)\n        new_solution = [c_to if c == c_from else c for c in new_solution]\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000511076}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9; solution is a list of 9 positive integers where index i-1 stores color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate type and basic shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Graph edges (1-indexed)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: heavy penalty on conflicts, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    # Fitness: lower objective is better -> return negative\n    return -float(objective)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _safe_colors(solution: List[int]) -> List[int]:\n    # Limit palette to existing colors plus possibly one extra to escape local minima\n    colors = sorted(set(solution))\n    # Allow introduction of at most one new color = max_color+1, capped small for stability\n    max_color = max(colors) if colors else 1\n    colors.append(max_color + 1)\n    return colors\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Recolor a single vertex to a (possibly) different color\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n    n = 9\n    idx = random.randrange(n)\n    palette = _safe_colors(solution)\n    current_color = solution[idx]\n    # Ensure a different color is chosen when possible\n    choices = [c for c in palette if c != current_color] or palette\n    new_color = random.choice(choices)\n    new_solution = solution.copy()\n    new_solution[idx] = new_color\n    return new_solution, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger move: multiple recolorings and optional color merge\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    new_solution = solution.copy()\n    # Randomly recolor k vertices\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    palette = sorted(set(new_solution))\n    max_color = max(palette) if palette else 1\n    # Optionally introduce one new color\n    if random.random() < 0.5:\n        palette.append(max_color + 1)\n    for idx in indices:\n        new_solution[idx] = random.choice(palette)\n    # Optional merge: map one color to another to reduce palette\n    if len(set(new_solution)) > 1 and random.random() < 0.5:\n        colors = list(set(new_solution))\n        c_from, c_to = random.sample(colors, 2)\n        new_solution = [c_to if c == c_from else c for c in new_solution]\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000486236}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9; solution is a Python list of 9 positive integers where position i-1 stores the color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate type and shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Internal problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used  # integer\n    return -float(objective)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Return format: (new_solution, NB_Type, Movement_Type)\n    # Uses min-conflict recoloring on conflicted vertices when present; otherwise mild diversification.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    # Internal problem data\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Build adjacency list (0-indexed)\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    new_solution = solution.copy()\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n\n    # Palette limited to existing colors\n    palette = sorted(set(new_solution))\n\n    if conflicted:\n        # Choose a conflicted vertex, prefer higher conflict degree\n        conflicted.sort(key=lambda v: (-vertex_conflicts(new_solution, v), -len(adj[v])))\n        v = conflicted[0]\n        current_color = new_solution[v]\n        # Evaluate conflicts for each candidate color in current palette\n        best_colors = []\n        best_conf = 10**9\n        for col in palette:\n            if col == current_color:\n                continue\n            tmp_conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n            if tmp_conf < best_conf:\n                best_conf = tmp_conf\n                best_colors = [col]\n            elif tmp_conf == best_conf:\n                best_colors.append(col)\n        if best_colors:\n            chosen = random.choice(best_colors)\n            new_solution[v] = chosen\n            return new_solution, \"Recolor\", \"MinConflict\"\n        # If no alternative in palette reduces conflicts, optionally introduce a new color\n        max_color = max(palette) if palette else 1\n        new_color = max_color + 1\n        new_solution[v] = new_color\n        return new_solution, \"Recolor\", \"NewColorEscape\"\n    else:\n        # No conflicts: try a gentle color swap between two vertices to reduce palette pressure\n        colors = list(sorted(set(new_solution)))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # Try a Kempe-like swap on a small induced component\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                # Randomly pick a seed and swap that entire (c1,c2) subset\n                for i in indices:\n                    new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                return new_solution, \"KempeSwap\", \"TwoColor\"\n        # Fallback: recolor a random vertex to an existing color (keeping feasibility likely intact)\n        idx = random.randrange(n)\n        current_color = new_solution[idx]\n        choices = [c for c in palette if c != current_color]\n        if choices:\n            new_solution[idx] = random.choice(choices)\n        return new_solution, \"Recolor\", \"Diversify\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger diversification: perform a sequence of 2-3 Kempe-like swaps or multi-vertex recolors\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    new_solution = solution.copy()\n    colors = list(sorted(set(new_solution)))\n\n    # Apply t random moves\n    t = random.randint(2, 3)\n    for _ in range(t):\n        if len(colors) >= 2 and random.random() < 0.7:\n            c1, c2 = random.sample(colors, 2)\n            subset = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if subset:\n                for i in subset:\n                    new_solution[i] = c1 if new_solution[i] == c2 else (c2 if new_solution[i] == c1 else new_solution[i])\n        else:\n            # Multi-vertex recolor within existing palette; rare chance to introduce one new color\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            palette = list(sorted(set(new_solution)))\n            if random.random() < 0.2:\n                palette.append((max(palette) if palette else 1) + 1)\n            for idx in idxs:\n                # Prefer colors that minimize local conflicts\n                best_col = None\n                best_conf = 10**9\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                if best_col is not None:\n                    new_solution[idx] = best_col\n        colors = list(sorted(set(new_solution)))\n\n    # Optional color merge attempt: try to map the highest color to an existing color if conflicts stay moderate\n    if len(colors) > 1:\n        highest = max(colors)\n        target_candidates = [c for c in colors if c != highest]\n        if target_candidates:\n            target = random.choice(target_candidates)\n            merged = [target if c == highest else c for c in new_solution]\n            new_solution = merged\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000832797}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9; solution is a Python list of 9 positive integers where position i-1 stores the color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate type and shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Internal problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used  # integer\n    return -float(objective)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Return format: (new_solution, NB_Type, Movement_Type)\n    # Uses min-conflict recoloring on conflicted vertices when present; otherwise mild diversification.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    # Internal problem data\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Build adjacency list (0-indexed)\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    new_solution = solution.copy()\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n\n    # Palette limited to existing colors\n    palette = sorted(set(new_solution))\n\n    if conflicted:\n        # Choose a conflicted vertex, prefer higher conflict degree\n        conflicted.sort(key=lambda v: (-vertex_conflicts(new_solution, v), -len(adj[v])))\n        v = conflicted[0]\n        current_color = new_solution[v]\n        # Evaluate conflicts for each candidate color in current palette\n        best_colors = []\n        best_conf = 10**9\n        for col in palette:\n            if col == current_color:\n                continue\n            tmp_conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n            if tmp_conf < best_conf:\n                best_conf = tmp_conf\n                best_colors = [col]\n            elif tmp_conf == best_conf:\n                best_colors.append(col)\n        if best_colors:\n            chosen = random.choice(best_colors)\n            new_solution[v] = chosen\n            return new_solution, \"Recolor\", \"MinConflict\"\n        # If no alternative in palette reduces conflicts, optionally introduce a new color\n        max_color = max(palette) if palette else 1\n        new_color = max_color + 1\n        new_solution[v] = new_color\n        return new_solution, \"Recolor\", \"NewColorEscape\"\n    else:\n        # No conflicts: try a gentle color swap between two vertices to reduce palette pressure\n        colors = list(sorted(set(new_solution)))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # Try a Kempe-like swap on a small induced component\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                # Randomly pick a seed and swap that entire (c1,c2) subset\n                for i in indices:\n                    new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                return new_solution, \"KempeSwap\", \"TwoColor\"\n        # Fallback: recolor a random vertex to an existing color (keeping feasibility likely intact)\n        idx = random.randrange(n)\n        current_color = new_solution[idx]\n        choices = [c for c in palette if c != current_color]\n        if choices:\n            new_solution[idx] = random.choice(choices)\n        return new_solution, \"Recolor\", \"Diversify\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger diversification: perform a sequence of 2-3 Kempe-like swaps or multi-vertex recolors\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    new_solution = solution.copy()\n    colors = list(sorted(set(new_solution)))\n\n    # Apply t random moves\n    t = random.randint(2, 3)\n    for _ in range(t):\n        if len(colors) >= 2 and random.random() < 0.7:\n            c1, c2 = random.sample(colors, 2)\n            subset = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if subset:\n                for i in subset:\n                    new_solution[i] = c1 if new_solution[i] == c2 else (c2 if new_solution[i] == c1 else new_solution[i])\n        else:\n            # Multi-vertex recolor within existing palette; rare chance to introduce one new color\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            palette = list(sorted(set(new_solution)))\n            if random.random() < 0.2:\n                palette.append((max(palette) if palette else 1) + 1)\n            for idx in idxs:\n                # Prefer colors that minimize local conflicts\n                best_col = None\n                best_conf = 10**9\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                if best_col is not None:\n                    new_solution[idx] = best_col\n        colors = list(sorted(set(new_solution)))\n\n    # Optional color merge attempt: try to map the highest color to an existing color if conflicts stay moderate\n    if len(colors) > 1:\n        highest = max(colors)\n        target_candidates = [c for c in colors if c != highest]\n        if target_candidates:\n            target = random.choice(target_candidates)\n            merged = [target if c == highest else c for c in new_solution]\n            new_solution = merged\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001090328}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9; solution is a Python list of 9 positive integers where position i-1 stores the color of vertex i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate type and shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Internal problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used  # integer\n    return -float(objective)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Return format: (new_solution, NB_Type, Movement_Type)\n    # Uses min-conflict recoloring on conflicted vertices when present; otherwise mild diversification.\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    # Internal problem data\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Build adjacency list (0-indexed)\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    new_solution = solution.copy()\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n\n    # Palette limited to existing colors\n    palette = sorted(set(new_solution))\n\n    if conflicted:\n        # Choose a conflicted vertex, prefer higher conflict degree\n        conflicted.sort(key=lambda v: (-vertex_conflicts(new_solution, v), -len(adj[v])))\n        v = conflicted[0]\n        current_color = new_solution[v]\n        # Evaluate conflicts for each candidate color in current palette\n        best_colors = []\n        best_conf = 10**9\n        for col in palette:\n            if col == current_color:\n                continue\n            tmp_conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n            if tmp_conf < best_conf:\n                best_conf = tmp_conf\n                best_colors = [col]\n            elif tmp_conf == best_conf:\n                best_colors.append(col)\n        if best_colors:\n            chosen = random.choice(best_colors)\n            new_solution[v] = chosen\n            return new_solution, \"Recolor\", \"MinConflict\"\n        # If no alternative in palette reduces conflicts, optionally introduce a new color\n        max_color = max(palette) if palette else 1\n        new_color = max_color + 1\n        new_solution[v] = new_color\n        return new_solution, \"Recolor\", \"NewColorEscape\"\n    else:\n        # No conflicts: try a gentle color swap between two vertices to reduce palette pressure\n        colors = list(sorted(set(new_solution)))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            # Try a Kempe-like swap on a small induced component\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                # Randomly pick a seed and swap that entire (c1,c2) subset\n                for i in indices:\n                    new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                return new_solution, \"KempeSwap\", \"TwoColor\"\n        # Fallback: recolor a random vertex to an existing color (keeping feasibility likely intact)\n        idx = random.randrange(n)\n        current_color = new_solution[idx]\n        choices = [c for c in palette if c != current_color]\n        if choices:\n            new_solution[idx] = random.choice(choices)\n        return new_solution, \"Recolor\", \"Diversify\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger diversification: perform a sequence of 2-3 Kempe-like swaps or multi-vertex recolors\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    new_solution = solution.copy()\n    colors = list(sorted(set(new_solution)))\n\n    # Apply t random moves\n    t = random.randint(2, 3)\n    for _ in range(t):\n        if len(colors) >= 2 and random.random() < 0.7:\n            c1, c2 = random.sample(colors, 2)\n            subset = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if subset:\n                for i in subset:\n                    new_solution[i] = c1 if new_solution[i] == c2 else (c2 if new_solution[i] == c1 else new_solution[i])\n        else:\n            # Multi-vertex recolor within existing palette; rare chance to introduce one new color\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            palette = list(sorted(set(new_solution)))\n            if random.random() < 0.2:\n                palette.append((max(palette) if palette else 1) + 1)\n            for idx in idxs:\n                # Prefer colors that minimize local conflicts\n                best_col = None\n                best_conf = 10**9\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                if best_col is not None:\n                    new_solution[idx] = best_col\n        colors = list(sorted(set(new_solution)))\n\n    # Optional color merge attempt: try to map the highest color to an existing color if conflicts stay moderate\n    if len(colors) > 1:\n        highest = max(colors)\n        target_candidates = [c for c in colors if c != highest]\n        if target_candidates:\n            target = random.choice(target_candidates)\n            merged = [target if c == highest else c for c in new_solution]\n            new_solution = merged\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001037638}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Internal problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    return -float(objective)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def vertex_conflicts(sol, v):\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    def kempe_chain_indices(sol, start, c1, c2):\n        # BFS within subgraph induced by colors c1 and c2\n        visited = set()\n        q = deque([start])\n        while q:\n            v = q.popleft()\n            if v in visited:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            visited.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in visited:\n                    q.append(nb)\n        return visited\n\n    new_solution = list(solution)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n    palette = sorted(set(new_solution))\n\n    if conflicted:\n        # Choose a conflicted vertex (tie-break with random for diversification)\n        conflicted.sort(key=lambda v: (-(vertex_conflicts(new_solution, v)), -len(adj[v]), v))\n        # Random tie-breaking among top-k\n        topk = [conflicted[0]]\n        best_score = (vertex_conflicts(new_solution, conflicted[0]), len(adj[conflicted[0]]))\n        for v in conflicted[1:]:\n            if (vertex_conflicts(new_solution, v), len(adj[v])) == best_score:\n                topk.append(v)\n            else:\n                break\n        v = random.choice(topk)\n        cur = new_solution[v]\n        # Evaluate colors that minimize local conflicts (do not introduce new colors)\n        best_cols = []\n        best_conf = 10**9\n        for col in palette:\n            if col == cur:\n                continue\n            tmp_conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n            if tmp_conf < best_conf:\n                best_conf = tmp_conf\n                best_cols = [col]\n            elif tmp_conf == best_conf:\n                best_cols.append(col)\n        # Commit only if it does not increase conflicts at v\n        if best_cols:\n            # Prefer colors with no local conflict if available\n            zero_conf = [c for c in best_cols if sum(1 for nb in adj[v] if new_solution[nb] == c) == 0]\n            chosen = random.choice(zero_conf) if zero_conf else random.choice(best_cols)\n            if sum(1 for nb in adj[v] if new_solution[nb] == chosen) <= vertex_conflicts(new_solution, v):\n                new_solution[v] = chosen\n                return new_solution, \"Recolor\", \"MinConflict\"\n        # If recolor not improving, attempt a small Kempe swap between two existing colors\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            comp = kempe_chain_indices(new_solution, v, c1, c2)\n            if comp:\n                for i in comp:\n                    new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                return new_solution, \"KempeSwap\", \"ConflictRelief\"\n        # Fallback: no-op to avoid worsening\n        return solution, \"NoOp\", \"SafeGuard\"\n    else:\n        # Conflict-free: try targeted color elimination\n        color_counts = {c: 0 for c in palette}\n        for x in new_solution:\n            color_counts[x] += 1\n        # choose least-used color to eliminate\n        target_color = min(color_counts, key=lambda c: (color_counts[c], c)) if palette else None\n        if target_color is not None and len(palette) > 1:\n            # Try to move its vertices to other existing colors using min-conflict\n            verts = [i for i, c in enumerate(new_solution) if c == target_color]\n            moved_any = False\n            for v in verts:\n                # try colors except target_color\n                candidates = [c for c in palette if c != target_color]\n                random.shuffle(candidates)\n                best_col = None\n                best_conf = 10**9\n                for col in candidates:\n                    conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None and best_conf == 0:\n                    new_solution[v] = best_col\n                    moved_any = True\n                else:\n                    moved_any = False\n                    break\n            if moved_any:\n                # If all vertices moved, drop the color implicitly\n                return new_solution, \"ColorElim\", \"GreedyMove\"\n        # If elimination not possible, attempt a Kempe swap between two colors to enable future elimination\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # pick a random seed with color in {c1,c2}\n            candidates = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                comp = kempe_chain_indices(new_solution, seed, c1, c2)\n                if comp:\n                    for i in comp:\n                        new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                    return new_solution, \"KempeSwap\", \"TwoColor\"\n        return solution, \"NoOp\", \"Steady\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def kempe_chain(sol, start, c1, c2):\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n    palette = sorted(set(new_solution))\n\n    # Apply 2-4 perturbation moves\n    t = random.randint(2, 4)\n    for _ in range(t):\n        move_type = random.random()\n        palette = sorted(set(new_solution))\n        if len(palette) >= 2 and move_type < 0.6:\n            c1, c2 = random.sample(palette, 2)\n            # pick random seed in c1\/c2\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                seed = random.choice(indices)\n                comp = kempe_chain(new_solution, seed, c1, c2)\n                for i in comp:\n                    new_solution[i] = c1 if new_solution[i] == c2 else (c2 if new_solution[i] == c1 else new_solution[i])\n        else:\n            # recolor a small random subset with min-conflict within existing palette\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            for idx in idxs:\n                best_col = None\n                best_conf = 10**9\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None:\n                    new_solution[idx] = best_col\n    # Final attempt: try to eliminate highest color if possible with zero-conflict moves\n    palette = sorted(set(new_solution))\n    if len(palette) > 1:\n        high = max(palette)\n        others = [c for c in palette if c != high]\n        can_elim = True\n        for v, c in enumerate(new_solution):\n            if c == high:\n                # try assign any other color with zero local conflict\n                assigned = False\n                for col in others:\n                    if all(new_solution[nb] != col for nb in adj[v]):\n                        new_solution[v] = col\n                        assigned = True\n                        break\n                if not assigned:\n                    can_elim = False\n                    break\n        # if not eliminable, revert; otherwise high color removed implicitly\n        if not can_elim:\n            return list(solution)\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001292271}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Internal problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    return -float(objective)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def vertex_conflicts(sol, v):\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    def kempe_chain_indices(sol, start, c1, c2):\n        # BFS within subgraph induced by colors c1 and c2\n        visited = set()\n        q = deque([start])\n        while q:\n            v = q.popleft()\n            if v in visited:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            visited.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in visited:\n                    q.append(nb)\n        return visited\n\n    new_solution = list(solution)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n    palette = sorted(set(new_solution))\n\n    if conflicted:\n        # Choose a conflicted vertex (tie-break with random for diversification)\n        conflicted.sort(key=lambda v: (-(vertex_conflicts(new_solution, v)), -len(adj[v]), v))\n        # Random tie-breaking among top-k\n        topk = [conflicted[0]]\n        best_score = (vertex_conflicts(new_solution, conflicted[0]), len(adj[conflicted[0]]))\n        for v in conflicted[1:]:\n            if (vertex_conflicts(new_solution, v), len(adj[v])) == best_score:\n                topk.append(v)\n            else:\n                break\n        v = random.choice(topk)\n        cur = new_solution[v]\n        # Evaluate colors that minimize local conflicts (do not introduce new colors)\n        best_cols = []\n        best_conf = 10**9\n        for col in palette:\n            if col == cur:\n                continue\n            tmp_conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n            if tmp_conf < best_conf:\n                best_conf = tmp_conf\n                best_cols = [col]\n            elif tmp_conf == best_conf:\n                best_cols.append(col)\n        # Commit only if it does not increase conflicts at v\n        if best_cols:\n            # Prefer colors with no local conflict if available\n            zero_conf = [c for c in best_cols if sum(1 for nb in adj[v] if new_solution[nb] == c) == 0]\n            chosen = random.choice(zero_conf) if zero_conf else random.choice(best_cols)\n            if sum(1 for nb in adj[v] if new_solution[nb] == chosen) <= vertex_conflicts(new_solution, v):\n                new_solution[v] = chosen\n                return new_solution, \"Recolor\", \"MinConflict\"\n        # If recolor not improving, attempt a small Kempe swap between two existing colors\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            comp = kempe_chain_indices(new_solution, v, c1, c2)\n            if comp:\n                for i in comp:\n                    new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                return new_solution, \"KempeSwap\", \"ConflictRelief\"\n        # Fallback: no-op to avoid worsening\n        return solution, \"NoOp\", \"SafeGuard\"\n    else:\n        # Conflict-free: try targeted color elimination\n        color_counts = {c: 0 for c in palette}\n        for x in new_solution:\n            color_counts[x] += 1\n        # choose least-used color to eliminate\n        target_color = min(color_counts, key=lambda c: (color_counts[c], c)) if palette else None\n        if target_color is not None and len(palette) > 1:\n            # Try to move its vertices to other existing colors using min-conflict\n            verts = [i for i, c in enumerate(new_solution) if c == target_color]\n            moved_any = False\n            for v in verts:\n                # try colors except target_color\n                candidates = [c for c in palette if c != target_color]\n                random.shuffle(candidates)\n                best_col = None\n                best_conf = 10**9\n                for col in candidates:\n                    conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None and best_conf == 0:\n                    new_solution[v] = best_col\n                    moved_any = True\n                else:\n                    moved_any = False\n                    break\n            if moved_any:\n                # If all vertices moved, drop the color implicitly\n                return new_solution, \"ColorElim\", \"GreedyMove\"\n        # If elimination not possible, attempt a Kempe swap between two colors to enable future elimination\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # pick a random seed with color in {c1,c2}\n            candidates = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                comp = kempe_chain_indices(new_solution, seed, c1, c2)\n                if comp:\n                    for i in comp:\n                        new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                    return new_solution, \"KempeSwap\", \"TwoColor\"\n        return solution, \"NoOp\", \"Steady\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def kempe_chain(sol, start, c1, c2):\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n    palette = sorted(set(new_solution))\n\n    # Apply 2-4 perturbation moves\n    t = random.randint(2, 4)\n    for _ in range(t):\n        move_type = random.random()\n        palette = sorted(set(new_solution))\n        if len(palette) >= 2 and move_type < 0.6:\n            c1, c2 = random.sample(palette, 2)\n            # pick random seed in c1\/c2\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                seed = random.choice(indices)\n                comp = kempe_chain(new_solution, seed, c1, c2)\n                for i in comp:\n                    new_solution[i] = c1 if new_solution[i] == c2 else (c2 if new_solution[i] == c1 else new_solution[i])\n        else:\n            # recolor a small random subset with min-conflict within existing palette\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            for idx in idxs:\n                best_col = None\n                best_conf = 10**9\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None:\n                    new_solution[idx] = best_col\n    # Final attempt: try to eliminate highest color if possible with zero-conflict moves\n    palette = sorted(set(new_solution))\n    if len(palette) > 1:\n        high = max(palette)\n        others = [c for c in palette if c != high]\n        can_elim = True\n        for v, c in enumerate(new_solution):\n            if c == high:\n                # try assign any other color with zero local conflict\n                assigned = False\n                for col in others:\n                    if all(new_solution[nb] != col for nb in adj[v]):\n                        new_solution[v] = col\n                        assigned = True\n                        break\n                if not assigned:\n                    can_elim = False\n                    break\n        # if not eliminable, revert; otherwise high color removed implicitly\n        if not can_elim:\n            return list(solution)\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001810216}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and shape\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Internal problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    return -float(objective)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def vertex_conflicts(sol, v):\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    def kempe_chain_indices(sol, start, c1, c2):\n        # BFS within subgraph induced by colors c1 and c2\n        visited = set()\n        q = deque([start])\n        while q:\n            v = q.popleft()\n            if v in visited:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            visited.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in visited:\n                    q.append(nb)\n        return visited\n\n    new_solution = list(solution)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n    palette = sorted(set(new_solution))\n\n    if conflicted:\n        # Choose a conflicted vertex (tie-break with random for diversification)\n        conflicted.sort(key=lambda v: (-(vertex_conflicts(new_solution, v)), -len(adj[v]), v))\n        # Random tie-breaking among top-k\n        topk = [conflicted[0]]\n        best_score = (vertex_conflicts(new_solution, conflicted[0]), len(adj[conflicted[0]]))\n        for v in conflicted[1:]:\n            if (vertex_conflicts(new_solution, v), len(adj[v])) == best_score:\n                topk.append(v)\n            else:\n                break\n        v = random.choice(topk)\n        cur = new_solution[v]\n        # Evaluate colors that minimize local conflicts (do not introduce new colors)\n        best_cols = []\n        best_conf = 10**9\n        for col in palette:\n            if col == cur:\n                continue\n            tmp_conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n            if tmp_conf < best_conf:\n                best_conf = tmp_conf\n                best_cols = [col]\n            elif tmp_conf == best_conf:\n                best_cols.append(col)\n        # Commit only if it does not increase conflicts at v\n        if best_cols:\n            # Prefer colors with no local conflict if available\n            zero_conf = [c for c in best_cols if sum(1 for nb in adj[v] if new_solution[nb] == c) == 0]\n            chosen = random.choice(zero_conf) if zero_conf else random.choice(best_cols)\n            if sum(1 for nb in adj[v] if new_solution[nb] == chosen) <= vertex_conflicts(new_solution, v):\n                new_solution[v] = chosen\n                return new_solution, \"Recolor\", \"MinConflict\"\n        # If recolor not improving, attempt a small Kempe swap between two existing colors\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            comp = kempe_chain_indices(new_solution, v, c1, c2)\n            if comp:\n                for i in comp:\n                    new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                return new_solution, \"KempeSwap\", \"ConflictRelief\"\n        # Fallback: no-op to avoid worsening\n        return solution, \"NoOp\", \"SafeGuard\"\n    else:\n        # Conflict-free: try targeted color elimination\n        color_counts = {c: 0 for c in palette}\n        for x in new_solution:\n            color_counts[x] += 1\n        # choose least-used color to eliminate\n        target_color = min(color_counts, key=lambda c: (color_counts[c], c)) if palette else None\n        if target_color is not None and len(palette) > 1:\n            # Try to move its vertices to other existing colors using min-conflict\n            verts = [i for i, c in enumerate(new_solution) if c == target_color]\n            moved_any = False\n            for v in verts:\n                # try colors except target_color\n                candidates = [c for c in palette if c != target_color]\n                random.shuffle(candidates)\n                best_col = None\n                best_conf = 10**9\n                for col in candidates:\n                    conf = sum(1 for nb in adj[v] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None and best_conf == 0:\n                    new_solution[v] = best_col\n                    moved_any = True\n                else:\n                    moved_any = False\n                    break\n            if moved_any:\n                # If all vertices moved, drop the color implicitly\n                return new_solution, \"ColorElim\", \"GreedyMove\"\n        # If elimination not possible, attempt a Kempe swap between two colors to enable future elimination\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            # pick a random seed with color in {c1,c2}\n            candidates = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                comp = kempe_chain_indices(new_solution, seed, c1, c2)\n                if comp:\n                    for i in comp:\n                        new_solution[i] = c1 if solution[i] == c2 else (c2 if solution[i] == c1 else solution[i])\n                    return new_solution, \"KempeSwap\", \"TwoColor\"\n        return solution, \"NoOp\", \"Steady\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def kempe_chain(sol, start, c1, c2):\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n    palette = sorted(set(new_solution))\n\n    # Apply 2-4 perturbation moves\n    t = random.randint(2, 4)\n    for _ in range(t):\n        move_type = random.random()\n        palette = sorted(set(new_solution))\n        if len(palette) >= 2 and move_type < 0.6:\n            c1, c2 = random.sample(palette, 2)\n            # pick random seed in c1\/c2\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                seed = random.choice(indices)\n                comp = kempe_chain(new_solution, seed, c1, c2)\n                for i in comp:\n                    new_solution[i] = c1 if new_solution[i] == c2 else (c2 if new_solution[i] == c1 else new_solution[i])\n        else:\n            # recolor a small random subset with min-conflict within existing palette\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            for idx in idxs:\n                best_col = None\n                best_conf = 10**9\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None:\n                    new_solution[idx] = best_col\n    # Final attempt: try to eliminate highest color if possible with zero-conflict moves\n    palette = sorted(set(new_solution))\n    if len(palette) > 1:\n        high = max(palette)\n        others = [c for c in palette if c != high]\n        can_elim = True\n        for v, c in enumerate(new_solution):\n            if c == high:\n                # try assign any other color with zero local conflict\n                assigned = False\n                for col in others:\n                    if all(new_solution[nb] != col for nb in adj[v]):\n                        new_solution[v] = col\n                        assigned = True\n                        break\n                if not assigned:\n                    can_elim = False\n                    break\n        # if not eliminable, revert; otherwise high color removed implicitly\n        if not can_elim:\n            return list(solution)\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001624664}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Type and shape checks\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    return -float(objective)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Build adjacency (0-indexed)\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u - 1, v - 1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to 1..m preserving partition\n        palette = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in sol]\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    def delta_conflicts_recolor(sol: List[int], v: int, new_c: int) -> int:\n        # Change color of v to new_c; compute change in number of conflicting edges incident to v\n        old_c = sol[v]\n        if new_c == old_c:\n            return 0\n        dec = sum(1 for nb in adj[v] if sol[nb] == old_c)\n        inc = sum(1 for nb in adj[v] if sol[nb] == new_c)\n        return inc - dec\n\n    def kempe_chain_indices(sol: List[int], start: int, c1: int, c2: int):\n        # BFS within subgraph induced by colors c1 and c2\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n    palette = sorted(set(new_solution))\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n\n    if conflicted:\n        # Weighted random choice biased by conflicts and degree\n        weights = []\n        for v in conflicted:\n            w = 1 + 3 * vertex_conflicts(new_solution, v) + len(adj[v])\n            weights.append(max(1, w))\n        v = random.choices(conflicted, weights=weights, k=1)[0]\n        cur = new_solution[v]\n        # Try recolor within palette minimizing incident conflicts (allow non-worsening or slight worsening)\n        candidates = [c for c in palette if c != cur]\n        if candidates:\n            best_conf = None\n            best_cols = []\n            for col in candidates:\n                d = delta_conflicts_recolor(new_solution, v, col)\n                if best_conf is None or d < best_conf:\n                    best_conf = d\n                    best_cols = [col]\n                elif d == best_conf:\n                    best_cols.append(col)\n            chosen = random.choice(best_cols)\n            # Accept if not worse, or with small probability if slightly worse to avoid stagnation\n            d = delta_conflicts_recolor(new_solution, v, chosen)\n            if d <= 0 or random.random() < 0.2:\n                new_solution[v] = chosen\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"Recolor\", \"MinConflict\"\n        # Kempe swap between two existing colors to relieve conflicts\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            comp = kempe_chain_indices(new_solution, v, c1, c2)\n            if comp:\n                for i in comp:\n                    col = new_solution[i]\n                    new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"KempeSwap\", \"ConflictRelief\"\n        return solution, \"NoOp\", \"SafeGuard\"\n    else:\n        # Conflict-free: attempt to reduce number of colors\n        color_counts = {c: 0 for c in palette}\n        for x in new_solution:\n            color_counts[x] += 1\n        if len(palette) > 1:\n            # target least-used color for elimination\n            target_color = min(palette, key=lambda c: (color_counts[c], c))\n            verts = [i for i, c in enumerate(new_solution) if c == target_color]\n            moved = 0\n            for v in verts:\n                # Try assign to an existing color (excluding target) with zero local conflict if possible\n                candidates = [c for c in palette if c != target_color]\n                random.shuffle(candidates)\n                best_col = None\n                best_inc = None\n                for col in candidates:\n                    inc = sum(1 for nb in adj[v] if new_solution[nb] == col)\n                    if best_inc is None or inc < best_inc:\n                        best_inc = inc\n                        best_col = col\n                        if inc == 0:\n                            break\n                if best_col is not None and best_inc == 0:\n                    new_solution[v] = best_col\n                    moved += 1\n                else:\n                    # Try enable via Kempe swap with best_col\n                    if best_col is not None:\n                        comp = kempe_chain_indices(new_solution, v, new_solution[v], best_col)\n                        if comp:\n                            for i in comp:\n                                col = new_solution[i]\n                                new_solution[i] = new_solution[v] if col == best_col else (best_col if col == new_solution[v] else col)\n                            if all(all(new_solution[nb] != best_col for nb in adj[v2]) for v2 in [v]):\n                                new_solution[v] = best_col\n                                moved += 1\n                            else:\n                                # rollback by recomputing from original solution state\n                                new_solution = list(solution)\n                                break\n                        else:\n                            break\n                    else:\n                        break\n            if moved == len(verts):\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"ColorElim\", \"GreedyMove\"\n        # If elimination not possible, do a neutral Kempe swap to diversify\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            candidates = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                comp = kempe_chain_indices(new_solution, seed, c1, c2)\n                if comp:\n                    for i in comp:\n                        col = new_solution[i]\n                        new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n                    new_solution = compress_colors(new_solution)\n                    return new_solution, \"KempeSwap\", \"TwoColor\"\n        return solution, \"NoOp\", \"Steady\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u - 1, v - 1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        palette = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in sol]\n\n    def kempe_chain(sol: List[int], start: int, c1: int, c2: int):\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n\n    # Apply 2-4 random perturbation moves\n    t = random.randint(2, 4)\n    for _ in range(t):\n        palette = sorted(set(new_solution))\n        move_type = random.random()\n        if len(palette) >= 2 and move_type < 0.6:\n            c1, c2 = random.sample(palette, 2)\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                seed = random.choice(indices)\n                comp = kempe_chain(new_solution, seed, c1, c2)\n                for i in comp:\n                    col = new_solution[i]\n                    new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n        else:\n            # recolor a small random subset within existing palette minimizing local conflicts\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            palette = sorted(set(new_solution))\n            for idx in idxs:\n                best_col = None\n                best_conf = None\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if best_conf is None or conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None:\n                    new_solution[idx] = best_col\n    new_solution = compress_colors(new_solution)\n\n    # Attempt to eliminate the highest color greedily if possible\n    palette = sorted(set(new_solution))\n    if len(palette) > 1:\n        high = max(palette)\n        others = [c for c in palette if c != high]\n        can_elim = True\n        for v, c in enumerate(new_solution):\n            if c == high:\n                assigned = False\n                for col in others:\n                    if all(new_solution[nb] != col for nb in adj[v]):\n                        new_solution[v] = col\n                        assigned = True\n                        break\n                if not assigned:\n                    can_elim = False\n                    break\n        if not can_elim:\n            return list(solution)\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001339153}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Type and shape checks\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    return -float(objective)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Build adjacency (0-indexed)\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u - 1, v - 1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to 1..m preserving partition\n        palette = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in sol]\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    def delta_conflicts_recolor(sol: List[int], v: int, new_c: int) -> int:\n        # Change color of v to new_c; compute change in number of conflicting edges incident to v\n        old_c = sol[v]\n        if new_c == old_c:\n            return 0\n        dec = sum(1 for nb in adj[v] if sol[nb] == old_c)\n        inc = sum(1 for nb in adj[v] if sol[nb] == new_c)\n        return inc - dec\n\n    def kempe_chain_indices(sol: List[int], start: int, c1: int, c2: int):\n        # BFS within subgraph induced by colors c1 and c2\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n    palette = sorted(set(new_solution))\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n\n    if conflicted:\n        # Weighted random choice biased by conflicts and degree\n        weights = []\n        for v in conflicted:\n            w = 1 + 3 * vertex_conflicts(new_solution, v) + len(adj[v])\n            weights.append(max(1, w))\n        v = random.choices(conflicted, weights=weights, k=1)[0]\n        cur = new_solution[v]\n        # Try recolor within palette minimizing incident conflicts (allow non-worsening or slight worsening)\n        candidates = [c for c in palette if c != cur]\n        if candidates:\n            best_conf = None\n            best_cols = []\n            for col in candidates:\n                d = delta_conflicts_recolor(new_solution, v, col)\n                if best_conf is None or d < best_conf:\n                    best_conf = d\n                    best_cols = [col]\n                elif d == best_conf:\n                    best_cols.append(col)\n            chosen = random.choice(best_cols)\n            # Accept if not worse, or with small probability if slightly worse to avoid stagnation\n            d = delta_conflicts_recolor(new_solution, v, chosen)\n            if d <= 0 or random.random() < 0.2:\n                new_solution[v] = chosen\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"Recolor\", \"MinConflict\"\n        # Kempe swap between two existing colors to relieve conflicts\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            comp = kempe_chain_indices(new_solution, v, c1, c2)\n            if comp:\n                for i in comp:\n                    col = new_solution[i]\n                    new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"KempeSwap\", \"ConflictRelief\"\n        return solution, \"NoOp\", \"SafeGuard\"\n    else:\n        # Conflict-free: attempt to reduce number of colors\n        color_counts = {c: 0 for c in palette}\n        for x in new_solution:\n            color_counts[x] += 1\n        if len(palette) > 1:\n            # target least-used color for elimination\n            target_color = min(palette, key=lambda c: (color_counts[c], c))\n            verts = [i for i, c in enumerate(new_solution) if c == target_color]\n            moved = 0\n            for v in verts:\n                # Try assign to an existing color (excluding target) with zero local conflict if possible\n                candidates = [c for c in palette if c != target_color]\n                random.shuffle(candidates)\n                best_col = None\n                best_inc = None\n                for col in candidates:\n                    inc = sum(1 for nb in adj[v] if new_solution[nb] == col)\n                    if best_inc is None or inc < best_inc:\n                        best_inc = inc\n                        best_col = col\n                        if inc == 0:\n                            break\n                if best_col is not None and best_inc == 0:\n                    new_solution[v] = best_col\n                    moved += 1\n                else:\n                    # Try enable via Kempe swap with best_col\n                    if best_col is not None:\n                        comp = kempe_chain_indices(new_solution, v, new_solution[v], best_col)\n                        if comp:\n                            for i in comp:\n                                col = new_solution[i]\n                                new_solution[i] = new_solution[v] if col == best_col else (best_col if col == new_solution[v] else col)\n                            if all(all(new_solution[nb] != best_col for nb in adj[v2]) for v2 in [v]):\n                                new_solution[v] = best_col\n                                moved += 1\n                            else:\n                                # rollback by recomputing from original solution state\n                                new_solution = list(solution)\n                                break\n                        else:\n                            break\n                    else:\n                        break\n            if moved == len(verts):\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"ColorElim\", \"GreedyMove\"\n        # If elimination not possible, do a neutral Kempe swap to diversify\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            candidates = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                comp = kempe_chain_indices(new_solution, seed, c1, c2)\n                if comp:\n                    for i in comp:\n                        col = new_solution[i]\n                        new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n                    new_solution = compress_colors(new_solution)\n                    return new_solution, \"KempeSwap\", \"TwoColor\"\n        return solution, \"NoOp\", \"Steady\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u - 1, v - 1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        palette = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in sol]\n\n    def kempe_chain(sol: List[int], start: int, c1: int, c2: int):\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n\n    # Apply 2-4 random perturbation moves\n    t = random.randint(2, 4)\n    for _ in range(t):\n        palette = sorted(set(new_solution))\n        move_type = random.random()\n        if len(palette) >= 2 and move_type < 0.6:\n            c1, c2 = random.sample(palette, 2)\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                seed = random.choice(indices)\n                comp = kempe_chain(new_solution, seed, c1, c2)\n                for i in comp:\n                    col = new_solution[i]\n                    new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n        else:\n            # recolor a small random subset within existing palette minimizing local conflicts\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            palette = sorted(set(new_solution))\n            for idx in idxs:\n                best_col = None\n                best_conf = None\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if best_conf is None or conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None:\n                    new_solution[idx] = best_col\n    new_solution = compress_colors(new_solution)\n\n    # Attempt to eliminate the highest color greedily if possible\n    palette = sorted(set(new_solution))\n    if len(palette) > 1:\n        high = max(palette)\n        others = [c for c in palette if c != high]\n        can_elim = True\n        for v, c in enumerate(new_solution):\n            if c == high:\n                assigned = False\n                for col in others:\n                    if all(new_solution[nb] != col for nb in adj[v]):\n                        new_solution[v] = col\n                        assigned = True\n                        break\n                if not assigned:\n                    can_elim = False\n                    break\n        if not can_elim:\n            return list(solution)\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001688255}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Type and shape checks\n    if not isinstance(solution, list):\n        return -10**12\n    n = 9\n    if len(solution) != n:\n        return -10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return -10**12\n    # Problem data (1-indexed edges)\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Objective: prioritize feasibility, then minimize colors\n    objective = conflicts * 1_000_000 + colors_used\n    return -float(objective)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"Invalid\", \"NoOp\"\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    # Build adjacency (0-indexed)\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u - 1, v - 1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        # Relabel colors to 1..m preserving partition\n        palette = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in sol]\n\n    def vertex_conflicts(sol: List[int], v: int) -> int:\n        c = sol[v]\n        return sum(1 for nb in adj[v] if sol[nb] == c)\n\n    def delta_conflicts_recolor(sol: List[int], v: int, new_c: int) -> int:\n        # Change color of v to new_c; compute change in number of conflicting edges incident to v\n        old_c = sol[v]\n        if new_c == old_c:\n            return 0\n        dec = sum(1 for nb in adj[v] if sol[nb] == old_c)\n        inc = sum(1 for nb in adj[v] if sol[nb] == new_c)\n        return inc - dec\n\n    def kempe_chain_indices(sol: List[int], start: int, c1: int, c2: int):\n        # BFS within subgraph induced by colors c1 and c2\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n    palette = sorted(set(new_solution))\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if any(new_solution[i] == new_solution[j] for j in adj[i])]\n\n    if conflicted:\n        # Weighted random choice biased by conflicts and degree\n        weights = []\n        for v in conflicted:\n            w = 1 + 3 * vertex_conflicts(new_solution, v) + len(adj[v])\n            weights.append(max(1, w))\n        v = random.choices(conflicted, weights=weights, k=1)[0]\n        cur = new_solution[v]\n        # Try recolor within palette minimizing incident conflicts (allow non-worsening or slight worsening)\n        candidates = [c for c in palette if c != cur]\n        if candidates:\n            best_conf = None\n            best_cols = []\n            for col in candidates:\n                d = delta_conflicts_recolor(new_solution, v, col)\n                if best_conf is None or d < best_conf:\n                    best_conf = d\n                    best_cols = [col]\n                elif d == best_conf:\n                    best_cols.append(col)\n            chosen = random.choice(best_cols)\n            # Accept if not worse, or with small probability if slightly worse to avoid stagnation\n            d = delta_conflicts_recolor(new_solution, v, chosen)\n            if d <= 0 or random.random() < 0.2:\n                new_solution[v] = chosen\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"Recolor\", \"MinConflict\"\n        # Kempe swap between two existing colors to relieve conflicts\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            comp = kempe_chain_indices(new_solution, v, c1, c2)\n            if comp:\n                for i in comp:\n                    col = new_solution[i]\n                    new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"KempeSwap\", \"ConflictRelief\"\n        return solution, \"NoOp\", \"SafeGuard\"\n    else:\n        # Conflict-free: attempt to reduce number of colors\n        color_counts = {c: 0 for c in palette}\n        for x in new_solution:\n            color_counts[x] += 1\n        if len(palette) > 1:\n            # target least-used color for elimination\n            target_color = min(palette, key=lambda c: (color_counts[c], c))\n            verts = [i for i, c in enumerate(new_solution) if c == target_color]\n            moved = 0\n            for v in verts:\n                # Try assign to an existing color (excluding target) with zero local conflict if possible\n                candidates = [c for c in palette if c != target_color]\n                random.shuffle(candidates)\n                best_col = None\n                best_inc = None\n                for col in candidates:\n                    inc = sum(1 for nb in adj[v] if new_solution[nb] == col)\n                    if best_inc is None or inc < best_inc:\n                        best_inc = inc\n                        best_col = col\n                        if inc == 0:\n                            break\n                if best_col is not None and best_inc == 0:\n                    new_solution[v] = best_col\n                    moved += 1\n                else:\n                    # Try enable via Kempe swap with best_col\n                    if best_col is not None:\n                        comp = kempe_chain_indices(new_solution, v, new_solution[v], best_col)\n                        if comp:\n                            for i in comp:\n                                col = new_solution[i]\n                                new_solution[i] = new_solution[v] if col == best_col else (best_col if col == new_solution[v] else col)\n                            if all(all(new_solution[nb] != best_col for nb in adj[v2]) for v2 in [v]):\n                                new_solution[v] = best_col\n                                moved += 1\n                            else:\n                                # rollback by recomputing from original solution state\n                                new_solution = list(solution)\n                                break\n                        else:\n                            break\n                    else:\n                        break\n            if moved == len(verts):\n                new_solution = compress_colors(new_solution)\n                return new_solution, \"ColorElim\", \"GreedyMove\"\n        # If elimination not possible, do a neutral Kempe swap to diversify\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            candidates = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                comp = kempe_chain_indices(new_solution, seed, c1, c2)\n                if comp:\n                    for i in comp:\n                        col = new_solution[i]\n                        new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n                    new_solution = compress_colors(new_solution)\n                    return new_solution, \"KempeSwap\", \"TwoColor\"\n        return solution, \"NoOp\", \"Steady\"\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        u0, v0 = u - 1, v - 1\n        adj[u0].add(v0)\n        adj[v0].add(u0)\n\n    def compress_colors(sol: List[int]) -> List[int]:\n        palette = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(palette)}\n        return [mapping[c] for c in sol]\n\n    def kempe_chain(sol: List[int], start: int, c1: int, c2: int):\n        q = deque([start])\n        comp = set()\n        while q:\n            v = q.popleft()\n            if v in comp:\n                continue\n            if sol[v] not in (c1, c2):\n                continue\n            comp.add(v)\n            for nb in adj[v]:\n                if sol[nb] in (c1, c2) and nb not in comp:\n                    q.append(nb)\n        return comp\n\n    new_solution = list(solution)\n\n    # Apply 2-4 random perturbation moves\n    t = random.randint(2, 4)\n    for _ in range(t):\n        palette = sorted(set(new_solution))\n        move_type = random.random()\n        if len(palette) >= 2 and move_type < 0.6:\n            c1, c2 = random.sample(palette, 2)\n            indices = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n            if indices:\n                seed = random.choice(indices)\n                comp = kempe_chain(new_solution, seed, c1, c2)\n                for i in comp:\n                    col = new_solution[i]\n                    new_solution[i] = c1 if col == c2 else (c2 if col == c1 else col)\n        else:\n            # recolor a small random subset within existing palette minimizing local conflicts\n            k = random.randint(2, 4)\n            idxs = random.sample(range(n), k)\n            palette = sorted(set(new_solution))\n            for idx in idxs:\n                best_col = None\n                best_conf = None\n                for col in palette:\n                    conf = sum(1 for nb in adj[idx] if new_solution[nb] == col)\n                    if best_conf is None or conf < best_conf:\n                        best_conf = conf\n                        best_col = col\n                        if conf == 0:\n                            break\n                if best_col is not None:\n                    new_solution[idx] = best_col\n    new_solution = compress_colors(new_solution)\n\n    # Attempt to eliminate the highest color greedily if possible\n    palette = sorted(set(new_solution))\n    if len(palette) > 1:\n        high = max(palette)\n        others = [c for c in palette if c != high]\n        can_elim = True\n        for v, c in enumerate(new_solution):\n            if c == high:\n                assigned = False\n                for col in others:\n                    if all(new_solution[nb] != col for nb in adj[v]):\n                        new_solution[v] = col\n                        assigned = True\n                        break\n                if not assigned:\n                    can_elim = False\n                    break\n        if not can_elim:\n            return list(solution)\n    return new_solution\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001517535}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph edges (1-based indexing)\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    # Validate structure\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            invalid += 1\n    if invalid > 0:\n        return 1e9 + invalid\n    # Count conflicts (same color on an edge)\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    distinct_groups = len(set(solution))\n    penalty = 1_000_000 * conflicts\n    tie_break = 1e-6 * max(solution)\n    return penalty + float(distinct_groups) + tie_break\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Heuristic recolor: pick a vertex and recolor to reduce conflicts \/ colors\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # fallback to a simple valid shape\n        sol = [i % 3 + 1 for i in range(n)]\n        return (sol, \"Recolor\", \"SingleVertex\")\n    sol = solution[:]\n    # Build adjacency list for quick checks\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Pick a vertex with probability biased towards conflicting ones\n    conflicts_per_node = [0]*n\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_node[u-1] += 1\n            conflicts_per_node[v-1] += 1\n    population = list(range(n))\n    weights = [c + 1 for c in conflicts_per_node]  # ensure nonzero weight\n    idx = random.choices(population, weights=weights, k=1)[0]\n    current_color = sol[idx]\n    used_colors = sorted(set(sol))\n    max_color = max(used_colors) if used_colors else 1\n    candidate_colors = used_colors + [max_color + 1]\n    # Evaluate best color for this vertex by minimizing local conflicts then color count impact\n    best_color = current_color\n    best_score = (10**9, 10**9)  # (local_conflicts, color_count_after)\n    for c in candidate_colors:\n        if c == current_color:\n            # still consider to allow color count tie-break\n            pass\n        local_conflicts = 0\n        for nb in adj[idx+1]:\n            if sol[nb-1] == c:\n                local_conflicts += 1\n        tmp = sol[:]\n        tmp[idx] = c\n        # color count after move\n        after_colors = set(tmp)\n        # remove any orphaned colors (if current_color disappears)\n        color_count_after = len(after_colors)\n        cand = (local_conflicts, color_count_after)\n        if cand < best_score:\n            best_score = cand\n            best_color = c\n    sol[idx] = best_color\n    # Optional relabel to keep labels compact (1..k) without changing structure\n    mapping = {}\n    next_label = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    sol = [mapping[x] for x in sol]\n    return (sol, \"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex randomized recolor with occasional color introduction, then relabel\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = solution[:]\n    max_color = max(sol) if sol else 1\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        # recompute neighborhood colors\n        nb_colors = set()\n        for (u,v) in edges:\n            if u-1 == idx:\n                nb_colors.add(sol[v-1])\n            elif v-1 == idx:\n                nb_colors.add(sol[u-1])\n        allow_new = random.random() < 0.3\n        candidate_colors = set(range(1, max_color + 1)) - nb_colors\n        if allow_new:\n            candidate_colors.add(max_color + 1)\n        if not candidate_colors:\n            # fallback: any color except one neighbor color if possible\n            candidate_colors = set(range(1, max_color + 2))\n        new_color = random.choice(sorted(candidate_colors))\n        sol[idx] = new_color\n        max_color = max(max_color, new_color)\n    # Relabel to compact color indices (1..k)\n    mapping = {}\n    next_label = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    sol = [mapping[x] for x in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000673776}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph edges (1-based indexing)\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    # Validate structure\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            invalid += 1\n    if invalid > 0:\n        return 1e9 + invalid\n    # Count conflicts (same color on an edge)\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    distinct_groups = len(set(solution))\n    penalty = 1_000_000 * conflicts\n    tie_break = 1e-6 * max(solution)\n    return penalty + float(distinct_groups) + tie_break\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Heuristic recolor: pick a vertex and recolor to reduce conflicts \/ colors\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # fallback to a simple valid shape\n        sol = [i % 3 + 1 for i in range(n)]\n        return (sol, \"Recolor\", \"SingleVertex\")\n    sol = solution[:]\n    # Build adjacency list for quick checks\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Pick a vertex with probability biased towards conflicting ones\n    conflicts_per_node = [0]*n\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_node[u-1] += 1\n            conflicts_per_node[v-1] += 1\n    population = list(range(n))\n    weights = [c + 1 for c in conflicts_per_node]  # ensure nonzero weight\n    idx = random.choices(population, weights=weights, k=1)[0]\n    current_color = sol[idx]\n    used_colors = sorted(set(sol))\n    max_color = max(used_colors) if used_colors else 1\n    candidate_colors = used_colors + [max_color + 1]\n    # Evaluate best color for this vertex by minimizing local conflicts then color count impact\n    best_color = current_color\n    best_score = (10**9, 10**9)  # (local_conflicts, color_count_after)\n    for c in candidate_colors:\n        if c == current_color:\n            # still consider to allow color count tie-break\n            pass\n        local_conflicts = 0\n        for nb in adj[idx+1]:\n            if sol[nb-1] == c:\n                local_conflicts += 1\n        tmp = sol[:]\n        tmp[idx] = c\n        # color count after move\n        after_colors = set(tmp)\n        # remove any orphaned colors (if current_color disappears)\n        color_count_after = len(after_colors)\n        cand = (local_conflicts, color_count_after)\n        if cand < best_score:\n            best_score = cand\n            best_color = c\n    sol[idx] = best_color\n    # Optional relabel to keep labels compact (1..k) without changing structure\n    mapping = {}\n    next_label = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    sol = [mapping[x] for x in sol]\n    return (sol, \"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex randomized recolor with occasional color introduction, then relabel\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = solution[:]\n    max_color = max(sol) if sol else 1\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        # recompute neighborhood colors\n        nb_colors = set()\n        for (u,v) in edges:\n            if u-1 == idx:\n                nb_colors.add(sol[v-1])\n            elif v-1 == idx:\n                nb_colors.add(sol[u-1])\n        allow_new = random.random() < 0.3\n        candidate_colors = set(range(1, max_color + 1)) - nb_colors\n        if allow_new:\n            candidate_colors.add(max_color + 1)\n        if not candidate_colors:\n            # fallback: any color except one neighbor color if possible\n            candidate_colors = set(range(1, max_color + 2))\n        new_color = random.choice(sorted(candidate_colors))\n        sol[idx] = new_color\n        max_color = max(max_color, new_color)\n    # Relabel to compact color indices (1..k)\n    mapping = {}\n    next_label = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    sol = [mapping[x] for x in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000831678}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph edges (1-based indexing)\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    # Validate structure\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    invalid = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            invalid += 1\n    if invalid > 0:\n        return 1e9 + invalid\n    # Count conflicts (same color on an edge)\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    distinct_groups = len(set(solution))\n    penalty = 1_000_000 * conflicts\n    tie_break = 1e-6 * max(solution)\n    return penalty + float(distinct_groups) + tie_break\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Heuristic recolor: pick a vertex and recolor to reduce conflicts \/ colors\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # fallback to a simple valid shape\n        sol = [i % 3 + 1 for i in range(n)]\n        return (sol, \"Recolor\", \"SingleVertex\")\n    sol = solution[:]\n    # Build adjacency list for quick checks\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Pick a vertex with probability biased towards conflicting ones\n    conflicts_per_node = [0]*n\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_node[u-1] += 1\n            conflicts_per_node[v-1] += 1\n    population = list(range(n))\n    weights = [c + 1 for c in conflicts_per_node]  # ensure nonzero weight\n    idx = random.choices(population, weights=weights, k=1)[0]\n    current_color = sol[idx]\n    used_colors = sorted(set(sol))\n    max_color = max(used_colors) if used_colors else 1\n    candidate_colors = used_colors + [max_color + 1]\n    # Evaluate best color for this vertex by minimizing local conflicts then color count impact\n    best_color = current_color\n    best_score = (10**9, 10**9)  # (local_conflicts, color_count_after)\n    for c in candidate_colors:\n        if c == current_color:\n            # still consider to allow color count tie-break\n            pass\n        local_conflicts = 0\n        for nb in adj[idx+1]:\n            if sol[nb-1] == c:\n                local_conflicts += 1\n        tmp = sol[:]\n        tmp[idx] = c\n        # color count after move\n        after_colors = set(tmp)\n        # remove any orphaned colors (if current_color disappears)\n        color_count_after = len(after_colors)\n        cand = (local_conflicts, color_count_after)\n        if cand < best_score:\n            best_score = cand\n            best_color = c\n    sol[idx] = best_color\n    # Optional relabel to keep labels compact (1..k) without changing structure\n    mapping = {}\n    next_label = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    sol = [mapping[x] for x in sol]\n    return (sol, \"Recolor\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Multi-vertex randomized recolor with occasional color introduction, then relabel\n    edges = [(1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),(3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = solution[:]\n    max_color = max(sol) if sol else 1\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        idx = random.randrange(n)\n        # recompute neighborhood colors\n        nb_colors = set()\n        for (u,v) in edges:\n            if u-1 == idx:\n                nb_colors.add(sol[v-1])\n            elif v-1 == idx:\n                nb_colors.add(sol[u-1])\n        allow_new = random.random() < 0.3\n        candidate_colors = set(range(1, max_color + 1)) - nb_colors\n        if allow_new:\n            candidate_colors.add(max_color + 1)\n        if not candidate_colors:\n            # fallback: any color except one neighbor color if possible\n            candidate_colors = set(range(1, max_color + 2))\n        new_color = random.choice(sorted(candidate_colors))\n        sol[idx] = new_color\n        max_color = max(max_color, new_color)\n    # Relabel to compact color indices (1..k)\n    mapping = {}\n    next_label = 1\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n    sol = [mapping[x] for x in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000798888}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Integer lexicographic score: conflicts first, then k\n    # M must exceed the maximum possible k; here choose M=1000\n    M = 1000\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Multi-move neighbourhood with deterministic RNG seeded from solution\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = solution[:]\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG tied to current solution\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val = (seed_val ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    # Helper: relabel to compact 1..k without changing partition\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    # Helper: compute conflicts per node\n    def node_conflicts(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (greedy, with option to add a new color)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = node_conflicts(arr2)\n        pop = list(range(n))\n        w = [c+1 for c in cp]\n        i = rng.choices(population=pop, weights=w, k=1)[0]\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        candidates = used + [maxc+1]\n        best = (10**9, 10**9)\n        bestc = arr2[i]\n        for c in candidates:\n            local = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            tmpc = c\n            # color count after\n            after = set(arr2)\n            if tmpc not in after:\n                after.add(tmpc)\n            if arr2[i] in after and all((arr2[j] != arr2[i]) for j in range(n) if j != i):\n                after.discard(arr2[i])\n            cand = (local, len(after))\n            if cand < best:\n                best = cand\n                bestc = c\n        arr2[i] = bestc\n        return relabel(arr2)\n\n    # Move 2: Kempe-chain swap between two colors starting at a random vertex\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) == 1:\n            return arr2\n        v = rng.randrange(n)\n        colors = list(set(arr2))\n        a = arr2[v]\n        b = rng.choice([c for c in colors if c != a])\n        # BFS on subgraph induced by colors a and b\n        from collections import deque\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return relabel(arr2)\n\n    # Move 3: Color-class label swap (two colors)\n    def move_class_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cols = sorted(set(arr2))\n        if len(cols) < 2:\n            return arr2\n        a, b = rng.sample(cols, 2)\n        for i in range(n):\n            if arr2[i] == a:\n                arr2[i] = b\n            elif arr2[i] == b:\n                arr2[i] = a\n        return relabel(arr2)\n\n    # Move 4: Pair relocate (two vertices recolored jointly)\n    def move_pair_relocate(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        i, j = sorted(rng.sample(range(n), 2))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        cand = used + [maxc+1]\n        ci = rng.choice(cand)\n        cj = rng.choice(cand)\n        arr2[i] = ci\n        arr2[j] = cj\n        return relabel(arr2)\n\n    moves = [\n        (move_recolor, \"Recolor_SingleVertex\"),\n        (move_kempe, \"KempeSwap\"),\n        (move_class_swap, \"ClassSwap\"),\n        (move_pair_relocate, \"PairRelocate\")\n    ]\n    mv, label = rng.choices(moves, weights=[4,3,1,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Deterministic, side-effect-free multi-step perturbation using Kempe swaps and recolors\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n    else:\n        sol = solution[:]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG seeded by solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val ^ (x * 0x9e3779b97f4a7c15)) * 6364136223846793005 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    # Kempe swap helper\n    def kempe_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        from collections import deque\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    # Least-conflicting recolor of a high-conflict vertex\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        # conflicts per node\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr2[u-1] == arr2[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        # pick highest conflict (deterministic tie-break by index)\n        idx = max(range(n), key=lambda i: (cp[i], i))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        best = (10**9, 10**9, arr2[idx])\n        for c in used + [maxc+1]:\n            local = 0\n            for nb in adj[idx+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            # color count after\n            after = set(arr2)\n            after.add(c)\n            if all(arr2[j] != arr2[idx] for j in range(n) if j != idx):\n                after.discard(arr2[idx])\n            cand = (local, len(after), c)\n            if cand < best:\n                best = cand\n        arr2[idx] = best[2]\n        return arr2\n\n    steps = 4 + (sum(sol) % 3)\n    cur = sol[:]\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return relabel(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001110882}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Integer lexicographic score: conflicts first, then k\n    # M must exceed the maximum possible k; here choose M=1000\n    M = 1000\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Multi-move neighbourhood with deterministic RNG seeded from solution\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = solution[:]\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG tied to current solution\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val = (seed_val ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    # Helper: relabel to compact 1..k without changing partition\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    # Helper: compute conflicts per node\n    def node_conflicts(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (greedy, with option to add a new color)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = node_conflicts(arr2)\n        pop = list(range(n))\n        w = [c+1 for c in cp]\n        i = rng.choices(population=pop, weights=w, k=1)[0]\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        candidates = used + [maxc+1]\n        best = (10**9, 10**9)\n        bestc = arr2[i]\n        for c in candidates:\n            local = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            tmpc = c\n            # color count after\n            after = set(arr2)\n            if tmpc not in after:\n                after.add(tmpc)\n            if arr2[i] in after and all((arr2[j] != arr2[i]) for j in range(n) if j != i):\n                after.discard(arr2[i])\n            cand = (local, len(after))\n            if cand < best:\n                best = cand\n                bestc = c\n        arr2[i] = bestc\n        return relabel(arr2)\n\n    # Move 2: Kempe-chain swap between two colors starting at a random vertex\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) == 1:\n            return arr2\n        v = rng.randrange(n)\n        colors = list(set(arr2))\n        a = arr2[v]\n        b = rng.choice([c for c in colors if c != a])\n        # BFS on subgraph induced by colors a and b\n        from collections import deque\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return relabel(arr2)\n\n    # Move 3: Color-class label swap (two colors)\n    def move_class_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cols = sorted(set(arr2))\n        if len(cols) < 2:\n            return arr2\n        a, b = rng.sample(cols, 2)\n        for i in range(n):\n            if arr2[i] == a:\n                arr2[i] = b\n            elif arr2[i] == b:\n                arr2[i] = a\n        return relabel(arr2)\n\n    # Move 4: Pair relocate (two vertices recolored jointly)\n    def move_pair_relocate(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        i, j = sorted(rng.sample(range(n), 2))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        cand = used + [maxc+1]\n        ci = rng.choice(cand)\n        cj = rng.choice(cand)\n        arr2[i] = ci\n        arr2[j] = cj\n        return relabel(arr2)\n\n    moves = [\n        (move_recolor, \"Recolor_SingleVertex\"),\n        (move_kempe, \"KempeSwap\"),\n        (move_class_swap, \"ClassSwap\"),\n        (move_pair_relocate, \"PairRelocate\")\n    ]\n    mv, label = rng.choices(moves, weights=[4,3,1,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Deterministic, side-effect-free multi-step perturbation using Kempe swaps and recolors\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n    else:\n        sol = solution[:]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG seeded by solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val ^ (x * 0x9e3779b97f4a7c15)) * 6364136223846793005 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    # Kempe swap helper\n    def kempe_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        from collections import deque\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    # Least-conflicting recolor of a high-conflict vertex\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        # conflicts per node\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr2[u-1] == arr2[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        # pick highest conflict (deterministic tie-break by index)\n        idx = max(range(n), key=lambda i: (cp[i], i))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        best = (10**9, 10**9, arr2[idx])\n        for c in used + [maxc+1]:\n            local = 0\n            for nb in adj[idx+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            # color count after\n            after = set(arr2)\n            after.add(c)\n            if all(arr2[j] != arr2[idx] for j in range(n) if j != idx):\n                after.discard(arr2[idx])\n            cand = (local, len(after), c)\n            if cand < best:\n                best = cand\n        arr2[idx] = best[2]\n        return arr2\n\n    steps = 4 + (sum(sol) % 3)\n    cur = sol[:]\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return relabel(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001563025}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Integer lexicographic score: conflicts first, then k\n    # M must exceed the maximum possible k; here choose M=1000\n    M = 1000\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Multi-move neighbourhood with deterministic RNG seeded from solution\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = solution[:]\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG tied to current solution\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val = (seed_val ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    # Helper: relabel to compact 1..k without changing partition\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    # Helper: compute conflicts per node\n    def node_conflicts(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (greedy, with option to add a new color)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = node_conflicts(arr2)\n        pop = list(range(n))\n        w = [c+1 for c in cp]\n        i = rng.choices(population=pop, weights=w, k=1)[0]\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        candidates = used + [maxc+1]\n        best = (10**9, 10**9)\n        bestc = arr2[i]\n        for c in candidates:\n            local = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            tmpc = c\n            # color count after\n            after = set(arr2)\n            if tmpc not in after:\n                after.add(tmpc)\n            if arr2[i] in after and all((arr2[j] != arr2[i]) for j in range(n) if j != i):\n                after.discard(arr2[i])\n            cand = (local, len(after))\n            if cand < best:\n                best = cand\n                bestc = c\n        arr2[i] = bestc\n        return relabel(arr2)\n\n    # Move 2: Kempe-chain swap between two colors starting at a random vertex\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) == 1:\n            return arr2\n        v = rng.randrange(n)\n        colors = list(set(arr2))\n        a = arr2[v]\n        b = rng.choice([c for c in colors if c != a])\n        # BFS on subgraph induced by colors a and b\n        from collections import deque\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return relabel(arr2)\n\n    # Move 3: Color-class label swap (two colors)\n    def move_class_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cols = sorted(set(arr2))\n        if len(cols) < 2:\n            return arr2\n        a, b = rng.sample(cols, 2)\n        for i in range(n):\n            if arr2[i] == a:\n                arr2[i] = b\n            elif arr2[i] == b:\n                arr2[i] = a\n        return relabel(arr2)\n\n    # Move 4: Pair relocate (two vertices recolored jointly)\n    def move_pair_relocate(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        i, j = sorted(rng.sample(range(n), 2))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        cand = used + [maxc+1]\n        ci = rng.choice(cand)\n        cj = rng.choice(cand)\n        arr2[i] = ci\n        arr2[j] = cj\n        return relabel(arr2)\n\n    moves = [\n        (move_recolor, \"Recolor_SingleVertex\"),\n        (move_kempe, \"KempeSwap\"),\n        (move_class_swap, \"ClassSwap\"),\n        (move_pair_relocate, \"PairRelocate\")\n    ]\n    mv, label = rng.choices(moves, weights=[4,3,1,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Deterministic, side-effect-free multi-step perturbation using Kempe swaps and recolors\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n    else:\n        sol = solution[:]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG seeded by solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val ^ (x * 0x9e3779b97f4a7c15)) * 6364136223846793005 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    # Kempe swap helper\n    def kempe_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        from collections import deque\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    # Least-conflicting recolor of a high-conflict vertex\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        # conflicts per node\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr2[u-1] == arr2[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        # pick highest conflict (deterministic tie-break by index)\n        idx = max(range(n), key=lambda i: (cp[i], i))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        best = (10**9, 10**9, arr2[idx])\n        for c in used + [maxc+1]:\n            local = 0\n            for nb in adj[idx+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            # color count after\n            after = set(arr2)\n            after.add(c)\n            if all(arr2[j] != arr2[idx] for j in range(n) if j != idx):\n                after.discard(arr2[idx])\n            cand = (local, len(after), c)\n            if cand < best:\n                best = cand\n        arr2[idx] = best[2]\n        return arr2\n\n    steps = 4 + (sum(sol) % 3)\n    cur = sol[:]\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return relabel(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.0014156351}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Integer lexicographic score: conflicts first, then k\n    M = 1000  # must exceed max possible k\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Fallback if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = solution[:]\n    # Build adjacency list locally\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG seeded from content to keep reproducible behaviour\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val = (seed_val ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def node_conflicts(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (try existing colors and one new)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = node_conflicts(arr2)\n        pop = list(range(n))\n        w = [c+1 for c in cp]\n        i = rng.choices(population=pop, weights=w, k=1)[0]\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        candidates = used + [maxc+1]\n        best = (10**9, 10**9)\n        bestc = arr2[i]\n        for c in candidates:\n            local = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            after = set(arr2)\n            after.add(c)\n            if all((arr2[j] != arr2[i]) for j in range(n) if j != i):\n                after.discard(arr2[i])\n            cand = (local, len(after))\n            if cand < best:\n                best = cand\n                bestc = c\n        arr2[i] = bestc\n        return relabel(arr2)\n\n    # Move 2: Kempe-chain swap between two colors starting at a random vertex\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return relabel(arr2)\n\n    # Move 3: Color-class label swap (pure relabeling)\n    def move_class_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cols = sorted(set(arr2))\n        if len(cols) < 2:\n            return arr2\n        a, b = rng.sample(cols, 2)\n        for i in range(n):\n            if arr2[i] == a:\n                arr2[i] = b\n            elif arr2[i] == b:\n                arr2[i] = a\n        return relabel(arr2)\n\n    # Move 4: Pair relocate with penalty awareness\n    def move_pair_relocate(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        i, j = sorted(rng.sample(range(n), 2))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        cand = used + [maxc+1]\n        # Bias toward existing colors to avoid color drift\n        ci = rng.choices(cand, weights=[3]*(len(used)) + [1]).pop()\n        cj = rng.choices(cand, weights=[3]*(len(used)) + [1]).pop()\n        arr2[i] = ci\n        arr2[j] = cj\n        return relabel(arr2)\n\n    moves = [\n        (move_recolor, \"Recolor_SingleVertex\"),\n        (move_kempe, \"KempeSwap\"),\n        (move_class_swap, \"ClassSwap\"),\n        (move_pair_relocate, \"PairRelocate\")\n    ]\n    mv, label = rng.choices(moves, weights=[4,3,1,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\nfrom collections import deque\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Deterministic, side-effect-free multi-step perturbation using Kempe swaps and targeted recolors\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Validate \/ fallback\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n    else:\n        sol = solution[:]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Seed RNG deterministically from the solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val ^ (x * 0x9e3779b97f4a7c15)) * 6364136223846793005 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    def kempe_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = conflicts_per_node(arr2)\n        idx = max(range(n), key=lambda i: (cp[i], i))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        best = (10**9, 10**9, arr2[idx])\n        for c in used + [maxc+1]:\n            local = 0\n            for nb in adj[idx+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            after = set(arr2)\n            after.add(c)\n            if all(arr2[j] != arr2[idx] for j in range(n) if j != idx):\n                after.discard(arr2[idx])\n            cand = (local, len(after), c)\n            if cand < best:\n                best = cand\n        arr2[idx] = best[2]\n        return arr2\n\n    steps = 6 + (sum(sol) % 3)\n    cur = sol[:]\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return relabel(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0011536721}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Integer lexicographic score: conflicts first, then k\n    M = 1000  # must exceed max possible k\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Fallback if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = solution[:]\n    # Build adjacency list locally\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG seeded from content to keep reproducible behaviour\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val = (seed_val ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def node_conflicts(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (try existing colors and one new)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = node_conflicts(arr2)\n        pop = list(range(n))\n        w = [c+1 for c in cp]\n        i = rng.choices(population=pop, weights=w, k=1)[0]\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        candidates = used + [maxc+1]\n        best = (10**9, 10**9)\n        bestc = arr2[i]\n        for c in candidates:\n            local = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            after = set(arr2)\n            after.add(c)\n            if all((arr2[j] != arr2[i]) for j in range(n) if j != i):\n                after.discard(arr2[i])\n            cand = (local, len(after))\n            if cand < best:\n                best = cand\n                bestc = c\n        arr2[i] = bestc\n        return relabel(arr2)\n\n    # Move 2: Kempe-chain swap between two colors starting at a random vertex\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return relabel(arr2)\n\n    # Move 3: Color-class label swap (pure relabeling)\n    def move_class_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cols = sorted(set(arr2))\n        if len(cols) < 2:\n            return arr2\n        a, b = rng.sample(cols, 2)\n        for i in range(n):\n            if arr2[i] == a:\n                arr2[i] = b\n            elif arr2[i] == b:\n                arr2[i] = a\n        return relabel(arr2)\n\n    # Move 4: Pair relocate with penalty awareness\n    def move_pair_relocate(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        i, j = sorted(rng.sample(range(n), 2))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        cand = used + [maxc+1]\n        # Bias toward existing colors to avoid color drift\n        ci = rng.choices(cand, weights=[3]*(len(used)) + [1]).pop()\n        cj = rng.choices(cand, weights=[3]*(len(used)) + [1]).pop()\n        arr2[i] = ci\n        arr2[j] = cj\n        return relabel(arr2)\n\n    moves = [\n        (move_recolor, \"Recolor_SingleVertex\"),\n        (move_kempe, \"KempeSwap\"),\n        (move_class_swap, \"ClassSwap\"),\n        (move_pair_relocate, \"PairRelocate\")\n    ]\n    mv, label = rng.choices(moves, weights=[4,3,1,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\nfrom collections import deque\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Deterministic, side-effect-free multi-step perturbation using Kempe swaps and targeted recolors\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Validate \/ fallback\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n    else:\n        sol = solution[:]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Seed RNG deterministically from the solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val ^ (x * 0x9e3779b97f4a7c15)) * 6364136223846793005 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    def kempe_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = conflicts_per_node(arr2)\n        idx = max(range(n), key=lambda i: (cp[i], i))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        best = (10**9, 10**9, arr2[idx])\n        for c in used + [maxc+1]:\n            local = 0\n            for nb in adj[idx+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            after = set(arr2)\n            after.add(c)\n            if all(arr2[j] != arr2[idx] for j in range(n) if j != idx):\n                after.discard(arr2[idx])\n            cand = (local, len(after), c)\n            if cand < best:\n                best = cand\n        arr2[idx] = best[2]\n        return arr2\n\n    steps = 6 + (sum(sol) % 3)\n    cur = sol[:]\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return relabel(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001617957}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Integer lexicographic score: conflicts first, then k\n    M = 1000  # must exceed max possible k\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Fallback if invalid input\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = solution[:]\n    # Build adjacency list locally\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Deterministic RNG seeded from content to keep reproducible behaviour\n    seed_val = 1469598103934665603\n    for x in sol:\n        seed_val = (seed_val ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def node_conflicts(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (try existing colors and one new)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = node_conflicts(arr2)\n        pop = list(range(n))\n        w = [c+1 for c in cp]\n        i = rng.choices(population=pop, weights=w, k=1)[0]\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        candidates = used + [maxc+1]\n        best = (10**9, 10**9)\n        bestc = arr2[i]\n        for c in candidates:\n            local = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            after = set(arr2)\n            after.add(c)\n            if all((arr2[j] != arr2[i]) for j in range(n) if j != i):\n                after.discard(arr2[i])\n            cand = (local, len(after))\n            if cand < best:\n                best = cand\n                bestc = c\n        arr2[i] = bestc\n        return relabel(arr2)\n\n    # Move 2: Kempe-chain swap between two colors starting at a random vertex\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return relabel(arr2)\n\n    # Move 3: Color-class label swap (pure relabeling)\n    def move_class_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cols = sorted(set(arr2))\n        if len(cols) < 2:\n            return arr2\n        a, b = rng.sample(cols, 2)\n        for i in range(n):\n            if arr2[i] == a:\n                arr2[i] = b\n            elif arr2[i] == b:\n                arr2[i] = a\n        return relabel(arr2)\n\n    # Move 4: Pair relocate with penalty awareness\n    def move_pair_relocate(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        i, j = sorted(rng.sample(range(n), 2))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        cand = used + [maxc+1]\n        # Bias toward existing colors to avoid color drift\n        ci = rng.choices(cand, weights=[3]*(len(used)) + [1]).pop()\n        cj = rng.choices(cand, weights=[3]*(len(used)) + [1]).pop()\n        arr2[i] = ci\n        arr2[j] = cj\n        return relabel(arr2)\n\n    moves = [\n        (move_recolor, \"Recolor_SingleVertex\"),\n        (move_kempe, \"KempeSwap\"),\n        (move_class_swap, \"ClassSwap\"),\n        (move_pair_relocate, \"PairRelocate\")\n    ]\n    mv, label = rng.choices(moves, weights=[4,3,1,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\nfrom collections import deque\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Deterministic, side-effect-free multi-step perturbation using Kempe swaps and targeted recolors\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Validate \/ fallback\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x <= 0) for x in solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n    else:\n        sol = solution[:]\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Seed RNG deterministically from the solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val ^ (x * 0x9e3779b97f4a7c15)) * 6364136223846793005 & ((1<<64)-1)\n    rng = random.Random(seed_val)\n\n    def relabel(arr: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    def kempe_swap(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        if len(set(arr2)) < 2:\n            return arr2\n        v = rng.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        b = rng.choice(b_choices)\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a,b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = arr[:]\n        cp = conflicts_per_node(arr2)\n        idx = max(range(n), key=lambda i: (cp[i], i))\n        used = sorted(set(arr2))\n        maxc = used[-1]\n        best = (10**9, 10**9, arr2[idx])\n        for c in used + [maxc+1]:\n            local = 0\n            for nb in adj[idx+1]:\n                if arr2[nb-1] == c:\n                    local += 1\n            after = set(arr2)\n            after.add(c)\n            if all(arr2[j] != arr2[idx] for j in range(n) if j != idx):\n                after.discard(arr2[idx])\n            cand = (local, len(after), c)\n            if cand < best:\n                best = cand\n        arr2[idx] = best[2]\n        return arr2\n\n    steps = 6 + (sum(sol) % 3)\n    cur = sol[:]\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return relabel(cur)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001484336}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Lexicographic score: conflicts first, then k\n    M = 1000  # must exceed max possible k\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Validate \/ fallback\n    def valid(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol)\n    if not valid(solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = list(solution)\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (prioritize colors not in neighbourhood)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        cp = conflicts_per_node(arr2)\n        # pick vertex with highest conflicts; tie-break by degree\n        deg = [len(adj[i+1]) for i in range(n)]\n        i = max(range(n), key=lambda t: (cp[t], deg[t], random.random()))\n        used = sorted(set(arr2))\n        neigh_colors = {arr2[j-1] for j in adj[i+1]}\n        candidates = [c for c in used if c not in neigh_colors]\n        if not candidates:\n            # allow existing colors and at most one new color\n            maxc = max(used)\n            candidates = used + [maxc+1]\n        bestc = arr2[i]\n        best_local = (10**9, 10**9)\n        for c in candidates:\n            local_conf = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local_conf += 1\n            new_colors = set(arr2)\n            new_colors.add(c)\n            if all(arr2[j] != arr2[i] for j in range(n) if j != i):\n                new_colors.discard(arr2[i])\n            cand_key = (local_conf, len(new_colors))\n            if cand_key < best_local:\n                best_local = cand_key\n                bestc = c\n        arr2[i] = bestc\n        return arr2\n\n    # Move 2: Kempe-chain swap between two colors starting from a random conflicting vertex if any\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        if len(set(arr2)) < 2:\n            return arr2\n        cp = conflicts_per_node(arr2)\n        conflict_vertices = [i for i in range(n) if cp[i] > 0]\n        v = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        a = arr2[v]\n        neigh_cols = [arr2[nb-1] for nb in adj[v+1] if arr2[nb-1] != a]\n        if neigh_cols:\n            # bias b toward frequent neighbour color\n            b = max(set(neigh_cols), key=neigh_cols.count)\n        else:\n            b_choices = [c for c in set(arr2) if c != a]\n            if not b_choices:\n                return arr2\n            b = random.choice(b_choices)\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a, b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    # Choose move\n    moves = [(move_recolor, \"Recolor\"), (move_kempe, \"KempeSwap\")]\n    mv, label = random.choices(moves, weights=[3,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\nfrom collections import deque\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    def valid(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol)\n    if not valid(solution):\n        base = [1,2,3]\n        cur = [base[i % 3] for i in range(n)]\n    else:\n        cur = list(solution)\n    # adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    def kempe_swap_once(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        if len(set(arr2)) < 2:\n            return arr2\n        v = random.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        # prefer neighbour colors\n        neigh_cols = [arr2[nb-1] for nb in adj[v+1] if arr2[nb-1] != a]\n        if neigh_cols:\n            b = max(set(neigh_cols), key=neigh_cols.count)\n        else:\n            b = random.choice(b_choices)\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a, b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        cp = conflicts_per_node(arr2)\n        deg = [len(adj[i+1]) for i in range(n)]\n        i = max(range(n), key=lambda t: (cp[t], deg[t], random.random()))\n        used = sorted(set(arr2))\n        neigh_colors = {arr2[j-1] for j in adj[i+1]}\n        candidates = [c for c in used if c not in neigh_colors]\n        if not candidates:\n            maxc = max(used)\n            candidates = used + [maxc+1]\n        bestc = arr2[i]\n        best_local = (10**9, 10**9)\n        for c in candidates:\n            local_conf = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local_conf += 1\n            new_colors = set(arr2)\n            new_colors.add(c)\n            if all(arr2[j] != arr2[i] for j in range(n) if j != i):\n                new_colors.discard(arr2[i])\n            cand_key = (local_conf, len(new_colors))\n            if cand_key < best_local:\n                best_local = cand_key\n                bestc = c\n        arr2[i] = bestc\n        return arr2\n\n    steps = 7  # moderate intensity\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap_once(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001077932}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Lexicographic score: conflicts first, then k\n    M = 1000  # must exceed max possible k\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Validate \/ fallback\n    def valid(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol)\n    if not valid(solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = list(solution)\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (prioritize colors not in neighbourhood)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        cp = conflicts_per_node(arr2)\n        # pick vertex with highest conflicts; tie-break by degree\n        deg = [len(adj[i+1]) for i in range(n)]\n        i = max(range(n), key=lambda t: (cp[t], deg[t], random.random()))\n        used = sorted(set(arr2))\n        neigh_colors = {arr2[j-1] for j in adj[i+1]}\n        candidates = [c for c in used if c not in neigh_colors]\n        if not candidates:\n            # allow existing colors and at most one new color\n            maxc = max(used)\n            candidates = used + [maxc+1]\n        bestc = arr2[i]\n        best_local = (10**9, 10**9)\n        for c in candidates:\n            local_conf = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local_conf += 1\n            new_colors = set(arr2)\n            new_colors.add(c)\n            if all(arr2[j] != arr2[i] for j in range(n) if j != i):\n                new_colors.discard(arr2[i])\n            cand_key = (local_conf, len(new_colors))\n            if cand_key < best_local:\n                best_local = cand_key\n                bestc = c\n        arr2[i] = bestc\n        return arr2\n\n    # Move 2: Kempe-chain swap between two colors starting from a random conflicting vertex if any\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        if len(set(arr2)) < 2:\n            return arr2\n        cp = conflicts_per_node(arr2)\n        conflict_vertices = [i for i in range(n) if cp[i] > 0]\n        v = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        a = arr2[v]\n        neigh_cols = [arr2[nb-1] for nb in adj[v+1] if arr2[nb-1] != a]\n        if neigh_cols:\n            # bias b toward frequent neighbour color\n            b = max(set(neigh_cols), key=neigh_cols.count)\n        else:\n            b_choices = [c for c in set(arr2) if c != a]\n            if not b_choices:\n                return arr2\n            b = random.choice(b_choices)\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a, b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    # Choose move\n    moves = [(move_recolor, \"Recolor\"), (move_kempe, \"KempeSwap\")]\n    mv, label = random.choices(moves, weights=[3,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\nfrom collections import deque\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    def valid(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol)\n    if not valid(solution):\n        base = [1,2,3]\n        cur = [base[i % 3] for i in range(n)]\n    else:\n        cur = list(solution)\n    # adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    def kempe_swap_once(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        if len(set(arr2)) < 2:\n            return arr2\n        v = random.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        # prefer neighbour colors\n        neigh_cols = [arr2[nb-1] for nb in adj[v+1] if arr2[nb-1] != a]\n        if neigh_cols:\n            b = max(set(neigh_cols), key=neigh_cols.count)\n        else:\n            b = random.choice(b_choices)\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a, b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        cp = conflicts_per_node(arr2)\n        deg = [len(adj[i+1]) for i in range(n)]\n        i = max(range(n), key=lambda t: (cp[t], deg[t], random.random()))\n        used = sorted(set(arr2))\n        neigh_colors = {arr2[j-1] for j in adj[i+1]}\n        candidates = [c for c in used if c not in neigh_colors]\n        if not candidates:\n            maxc = max(used)\n            candidates = used + [maxc+1]\n        bestc = arr2[i]\n        best_local = (10**9, 10**9)\n        for c in candidates:\n            local_conf = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local_conf += 1\n            new_colors = set(arr2)\n            new_colors.add(c)\n            if all(arr2[j] != arr2[i] for j in range(n) if j != i):\n                new_colors.discard(arr2[i])\n            cand_key = (local_conf, len(new_colors))\n            if cand_key < best_local:\n                best_local = cand_key\n                bestc = c\n        arr2[i] = bestc\n        return arr2\n\n    steps = 7  # moderate intensity\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap_once(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001571887}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"COLOR_LIST_LEN9_POSITIVE_INTS","Evaluacion":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded graph (1-based vertices)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k = len(set(solution))\n    # Lexicographic score: conflicts first, then k\n    M = 1000  # must exceed max possible k\n    return M * conflicts + k\n","Vecindad":"import random\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_label)\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    # Validate \/ fallback\n    def valid(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol)\n    if not valid(solution):\n        base = [1,2,3]\n        sol = [base[i % 3] for i in range(n)]\n        return (sol, \"InitFallback\")\n    sol = list(solution)\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    # Move 1: Single-vertex best recolor (prioritize colors not in neighbourhood)\n    def move_recolor(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        cp = conflicts_per_node(arr2)\n        # pick vertex with highest conflicts; tie-break by degree\n        deg = [len(adj[i+1]) for i in range(n)]\n        i = max(range(n), key=lambda t: (cp[t], deg[t], random.random()))\n        used = sorted(set(arr2))\n        neigh_colors = {arr2[j-1] for j in adj[i+1]}\n        candidates = [c for c in used if c not in neigh_colors]\n        if not candidates:\n            # allow existing colors and at most one new color\n            maxc = max(used)\n            candidates = used + [maxc+1]\n        bestc = arr2[i]\n        best_local = (10**9, 10**9)\n        for c in candidates:\n            local_conf = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local_conf += 1\n            new_colors = set(arr2)\n            new_colors.add(c)\n            if all(arr2[j] != arr2[i] for j in range(n) if j != i):\n                new_colors.discard(arr2[i])\n            cand_key = (local_conf, len(new_colors))\n            if cand_key < best_local:\n                best_local = cand_key\n                bestc = c\n        arr2[i] = bestc\n        return arr2\n\n    # Move 2: Kempe-chain swap between two colors starting from a random conflicting vertex if any\n    def move_kempe(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        if len(set(arr2)) < 2:\n            return arr2\n        cp = conflicts_per_node(arr2)\n        conflict_vertices = [i for i in range(n) if cp[i] > 0]\n        v = random.choice(conflict_vertices) if conflict_vertices else random.randrange(n)\n        a = arr2[v]\n        neigh_cols = [arr2[nb-1] for nb in adj[v+1] if arr2[nb-1] != a]\n        if neigh_cols:\n            # bias b toward frequent neighbour color\n            b = max(set(neigh_cols), key=neigh_cols.count)\n        else:\n            b_choices = [c for c in set(arr2) if c != a]\n            if not b_choices:\n                return arr2\n            b = random.choice(b_choices)\n        comp = set()\n        dq = deque([v+1])\n        comp.add(v+1)\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a, b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    # Choose move\n    moves = [(move_recolor, \"Recolor\"), (move_kempe, \"KempeSwap\")]\n    mv, label = random.choices(moves, weights=[3,2], k=1)[0]\n    return (mv(sol), label)\n","Perturbacion":"import random\nfrom typing import List\nfrom collections import deque\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    edges = [\n        (1,2),(1,7),(1,9),(2,3),(2,6),(2,7),(2,8),\n        (3,4),(4,6),(4,7),(4,8),(4,9),(5,7),(5,8),(5,9),(7,9),(8,9)\n    ]\n    n = 9\n    def valid(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol)\n    if not valid(solution):\n        base = [1,2,3]\n        cur = [base[i % 3] for i in range(n)]\n    else:\n        cur = list(solution)\n    # adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_per_node(arr: List[int]) -> List[int]:\n        cp = [0]*n\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                cp[u-1] += 1\n                cp[v-1] += 1\n        return cp\n\n    def kempe_swap_once(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        if len(set(arr2)) < 2:\n            return arr2\n        v = random.randrange(n)\n        a = arr2[v]\n        b_choices = [c for c in set(arr2) if c != a]\n        if not b_choices:\n            return arr2\n        # prefer neighbour colors\n        neigh_cols = [arr2[nb-1] for nb in adj[v+1] if arr2[nb-1] != a]\n        if neigh_cols:\n            b = max(set(neigh_cols), key=neigh_cols.count)\n        else:\n            b = random.choice(b_choices)\n        comp = set([v+1])\n        dq = deque([v+1])\n        while dq:\n            u = dq.popleft()\n            for nb in adj[u]:\n                if arr2[nb-1] in (a, b) and nb not in comp:\n                    comp.add(nb)\n                    dq.append(nb)\n        for u in comp:\n            arr2[u-1] = a if arr2[u-1] == b else (b if arr2[u-1] == a else arr2[u-1])\n        return arr2\n\n    def recolor_high_conflict(arr: List[int]) -> List[int]:\n        arr2 = list(arr)\n        cp = conflicts_per_node(arr2)\n        deg = [len(adj[i+1]) for i in range(n)]\n        i = max(range(n), key=lambda t: (cp[t], deg[t], random.random()))\n        used = sorted(set(arr2))\n        neigh_colors = {arr2[j-1] for j in adj[i+1]}\n        candidates = [c for c in used if c not in neigh_colors]\n        if not candidates:\n            maxc = max(used)\n            candidates = used + [maxc+1]\n        bestc = arr2[i]\n        best_local = (10**9, 10**9)\n        for c in candidates:\n            local_conf = 0\n            for nb in adj[i+1]:\n                if arr2[nb-1] == c:\n                    local_conf += 1\n            new_colors = set(arr2)\n            new_colors.add(c)\n            if all(arr2[j] != arr2[i] for j in range(n) if j != i):\n                new_colors.discard(arr2[i])\n            cand_key = (local_conf, len(new_colors))\n            if cand_key < best_local:\n                best_local = cand_key\n                bestc = c\n        arr2[i] = bestc\n        return arr2\n\n    steps = 7  # moderate intensity\n    for t in range(steps):\n        if t % 2 == 0:\n            cur = kempe_swap_once(cur)\n        else:\n            cur = recolor_high_conflict(cur)\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001475356}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    def objective_function(sol: List[int]) -> float:\n        # Type and length checks\n        if not isinstance(sol, (list, tuple)):\n            return float('inf')\n        if len(sol) != 9:\n            return float('inf')\n        # Validate entries are positive integers\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return float('inf')\n        # Graph edges (0-based indices)\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        # Count conflicts\n        conflicts = 0\n        for i,j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        rooms_used = len(set(sol))\n        # Strong penalty for conflicts\n        return rooms_used + 1000 * conflicts\n    obj = objective_function(solution)\n    if obj == float('inf'):\n        return -1e18\n    return -obj\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def edges_0() -> List[Tuple[int,int]]:\n        return [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n    def conflicts_for_vertex(sol: List[int], v: int, color: int) -> int:\n        c = 0\n        for (i,j) in edges:\n            if i == v:\n                c += 1 if color == sol[j] else 0\n            elif j == v:\n                c += 1 if color == sol[i] else 0\n        return c\n    def relabel_compact(sol: List[int]) -> List[int]:\n        # Map existing colors to 1..k in order of appearance for stability\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n    # Work on a copy\n    edges = edges_0()\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        # Fallback: random feasible-ish initialization\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(int(max(1, x)) for x in solution)\n    max_c = max(sol) if sol else 1\n    v = random.randrange(n)\n    # Candidate colors: existing palette plus optional new color with small prob\n    palette = set(sol)\n    candidates = list(palette)\n    if random.random() < 0.15:\n        candidates.append(max_c + 1)\n    # Evaluate each candidate by (conflicts, color_count_if_applied)\n    best_color = None\n    best_key = None\n    for col in candidates:\n        conf = conflicts_for_vertex(sol, v, col)\n        # Estimate rooms used if this color applied\n        new_rooms = len(palette | {col}) if col not in palette else len(palette)\n        key = (conf, new_rooms, random.random())\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    sol[v] = best_color\n    sol = relabel_compact(sol)\n    return (sol, \"VertexRecolor\", \"LocalSearch\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    def edges_0() -> List[Tuple[int,int]]:\n        return [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n    def relabel_compact(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n    def try_merge(sol: List[int]) -> List[int]:\n        # Attempt to merge two colors by reassigning one color class to another if no conflicts created for those vertices\n        edges = edges_0()\n        colors = list(sorted(set(sol)))\n        if len(colors) <= 1:\n            return sol\n        a, b = random.sample(colors, 2)\n        target = a\n        source = b\n        new_sol = sol[:]\n        # For each vertex of 'source', check if recoloring to 'target' would conflict\n        for v, col in enumerate(sol):\n            if col != source:\n                continue\n            ok = True\n            for (i,j) in edges:\n                u = j if i == v else (i if j == v else None)\n                if u is None:\n                    continue\n                if new_sol[u] == target:\n                    ok = False\n                    break\n            if ok:\n                new_sol[v] = target\n        return relabel_compact(new_sol)\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(int(max(1, x)) for x in solution)\n    # With some probability, attempt a color-merge perturbation\n    if random.random() < 0.5:\n        sol = try_merge(sol)\n    # Randomly reassign t vertices to random existing or new colors\n    edges = edges_0()\n    colors = list(sorted(set(sol)))\n    max_c = max(colors) if colors else 1\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for v in idxs:\n        if random.random() < 0.7 and colors:\n            sol[v] = random.choice(colors)\n        else:\n            sol[v] = max_c + 1\n            max_c += 1\n            colors = list(sorted(set(sol)))\n    sol = relabel_compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00091152}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    def objective_function(sol: List[int]) -> float:\n        # Type and length checks\n        if not isinstance(sol, (list, tuple)):\n            return float('inf')\n        if len(sol) != 9:\n            return float('inf')\n        # Validate entries are positive integers\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return float('inf')\n        # Graph edges (0-based indices)\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        # Count conflicts\n        conflicts = 0\n        for i,j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        rooms_used = len(set(sol))\n        # Strong penalty for conflicts\n        return rooms_used + 1000 * conflicts\n    obj = objective_function(solution)\n    if obj == float('inf'):\n        return -1e18\n    return -obj\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def edges_0() -> List[Tuple[int,int]]:\n        return [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n    def conflicts_for_vertex(sol: List[int], v: int, color: int) -> int:\n        c = 0\n        for (i,j) in edges:\n            if i == v:\n                c += 1 if color == sol[j] else 0\n            elif j == v:\n                c += 1 if color == sol[i] else 0\n        return c\n    def relabel_compact(sol: List[int]) -> List[int]:\n        # Map existing colors to 1..k in order of appearance for stability\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n    # Work on a copy\n    edges = edges_0()\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        # Fallback: random feasible-ish initialization\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(int(max(1, x)) for x in solution)\n    max_c = max(sol) if sol else 1\n    v = random.randrange(n)\n    # Candidate colors: existing palette plus optional new color with small prob\n    palette = set(sol)\n    candidates = list(palette)\n    if random.random() < 0.15:\n        candidates.append(max_c + 1)\n    # Evaluate each candidate by (conflicts, color_count_if_applied)\n    best_color = None\n    best_key = None\n    for col in candidates:\n        conf = conflicts_for_vertex(sol, v, col)\n        # Estimate rooms used if this color applied\n        new_rooms = len(palette | {col}) if col not in palette else len(palette)\n        key = (conf, new_rooms, random.random())\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    sol[v] = best_color\n    sol = relabel_compact(sol)\n    return (sol, \"VertexRecolor\", \"LocalSearch\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    def edges_0() -> List[Tuple[int,int]]:\n        return [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n    def relabel_compact(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n    def try_merge(sol: List[int]) -> List[int]:\n        # Attempt to merge two colors by reassigning one color class to another if no conflicts created for those vertices\n        edges = edges_0()\n        colors = list(sorted(set(sol)))\n        if len(colors) <= 1:\n            return sol\n        a, b = random.sample(colors, 2)\n        target = a\n        source = b\n        new_sol = sol[:]\n        # For each vertex of 'source', check if recoloring to 'target' would conflict\n        for v, col in enumerate(sol):\n            if col != source:\n                continue\n            ok = True\n            for (i,j) in edges:\n                u = j if i == v else (i if j == v else None)\n                if u is None:\n                    continue\n                if new_sol[u] == target:\n                    ok = False\n                    break\n            if ok:\n                new_sol[v] = target\n        return relabel_compact(new_sol)\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(int(max(1, x)) for x in solution)\n    # With some probability, attempt a color-merge perturbation\n    if random.random() < 0.5:\n        sol = try_merge(sol)\n    # Randomly reassign t vertices to random existing or new colors\n    edges = edges_0()\n    colors = list(sorted(set(sol)))\n    max_c = max(colors) if colors else 1\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for v in idxs:\n        if random.random() < 0.7 and colors:\n            sol[v] = random.choice(colors)\n        else:\n            sol[v] = max_c + 1\n            max_c += 1\n            colors = list(sorted(set(sol)))\n    sol = relabel_compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001362155}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    def objective_function(sol: List[int]) -> float:\n        # Type and length checks\n        if not isinstance(sol, (list, tuple)):\n            return float('inf')\n        if len(sol) != 9:\n            return float('inf')\n        # Validate entries are positive integers\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return float('inf')\n        # Graph edges (0-based indices)\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        # Count conflicts\n        conflicts = 0\n        for i,j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        rooms_used = len(set(sol))\n        # Strong penalty for conflicts\n        return rooms_used + 1000 * conflicts\n    obj = objective_function(solution)\n    if obj == float('inf'):\n        return -1e18\n    return -obj\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def edges_0() -> List[Tuple[int,int]]:\n        return [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n    def conflicts_for_vertex(sol: List[int], v: int, color: int) -> int:\n        c = 0\n        for (i,j) in edges:\n            if i == v:\n                c += 1 if color == sol[j] else 0\n            elif j == v:\n                c += 1 if color == sol[i] else 0\n        return c\n    def relabel_compact(sol: List[int]) -> List[int]:\n        # Map existing colors to 1..k in order of appearance for stability\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n    # Work on a copy\n    edges = edges_0()\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        # Fallback: random feasible-ish initialization\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(int(max(1, x)) for x in solution)\n    max_c = max(sol) if sol else 1\n    v = random.randrange(n)\n    # Candidate colors: existing palette plus optional new color with small prob\n    palette = set(sol)\n    candidates = list(palette)\n    if random.random() < 0.15:\n        candidates.append(max_c + 1)\n    # Evaluate each candidate by (conflicts, color_count_if_applied)\n    best_color = None\n    best_key = None\n    for col in candidates:\n        conf = conflicts_for_vertex(sol, v, col)\n        # Estimate rooms used if this color applied\n        new_rooms = len(palette | {col}) if col not in palette else len(palette)\n        key = (conf, new_rooms, random.random())\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    sol[v] = best_color\n    sol = relabel_compact(sol)\n    return (sol, \"VertexRecolor\", \"LocalSearch\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    def edges_0() -> List[Tuple[int,int]]:\n        return [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n    def relabel_compact(sol: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n    def try_merge(sol: List[int]) -> List[int]:\n        # Attempt to merge two colors by reassigning one color class to another if no conflicts created for those vertices\n        edges = edges_0()\n        colors = list(sorted(set(sol)))\n        if len(colors) <= 1:\n            return sol\n        a, b = random.sample(colors, 2)\n        target = a\n        source = b\n        new_sol = sol[:]\n        # For each vertex of 'source', check if recoloring to 'target' would conflict\n        for v, col in enumerate(sol):\n            if col != source:\n                continue\n            ok = True\n            for (i,j) in edges:\n                u = j if i == v else (i if j == v else None)\n                if u is None:\n                    continue\n                if new_sol[u] == target:\n                    ok = False\n                    break\n            if ok:\n                new_sol[v] = target\n        return relabel_compact(new_sol)\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(int(max(1, x)) for x in solution)\n    # With some probability, attempt a color-merge perturbation\n    if random.random() < 0.5:\n        sol = try_merge(sol)\n    # Randomly reassign t vertices to random existing or new colors\n    edges = edges_0()\n    colors = list(sorted(set(sol)))\n    max_c = max(colors) if colors else 1\n    t = random.randint(2, 4)\n    idxs = random.sample(range(n), t)\n    for v in idxs:\n        if random.random() < 0.7 and colors:\n            sol[v] = random.choice(colors)\n        else:\n            sol[v] = max_c + 1\n            max_c += 1\n            colors = list(sorted(set(sol)))\n    sol = relabel_compact(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001049611}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns higher is better; use negative cost: -(conflicts*1_000_000 + colors)\n    # Invalid solutions get a dominated but finite score.\n    def objective(sol: List[int]) -> int:\n        if not isinstance(sol, (list, tuple)):\n            return 10**12  # very bad cost\n        if len(sol) != 9:\n            return 10**12\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**12\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -float(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improvement single-vertex recolor using existing palette.\n    # Does not relabel colors; introduces a new color only if conflicts>0 and no non-worsening recolor exists.\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Compute current conflicts per vertex\n    in_conflict = [False]*n\n    total_conflicts = 0\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n            total_conflicts += 1\n    palette = sorted(set(sol))\n    # Choose a vertex: prefer conflicted vertices; else random\n    cand_vertices = [v for v in range(n) if in_conflict[v]]\n    if not cand_vertices:\n        cand_vertices = list(range(n))\n    v = random.choice(cand_vertices)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_used_if)\n    # Evaluate recoloring to existing colors\n    for col in palette:\n        if col == current_color:\n            # evaluate staying as-is as well\n            pass\n        # count conflicts if v is col\n        conflicts = 0\n        for u in adj[v]:\n            if (col == sol[u]):\n                conflicts += 1\n        colors_if = len(palette)\n        key = (conflicts, colors_if)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if currently conflicted and no zero-conflict option\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = max(palette) + 1\n            conflicts = 0  # new color cannot conflict at v\n            colors_if = len(palette) + 1\n            key = (conflicts, colors_if)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = sol[:]\n    new_sol[v] = best_color\n    # If we increased palette but a color became unused, compact by removing gaps while preserving label identity ordering\n    # Only compact when a color class becomes empty\n    used = set(new_sol)\n    if len(used) < len(palette):\n        mapping = {}\n        next_c = 1\n        for x in sorted(used):\n            mapping[x] = next_c\n            next_c += 1\n        new_sol = [mapping[x] for x in new_sol]\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Kempe-chain swap on two colors through a random conflicted or random vertex; pure function\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicted vertices\n    conflicted = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            conflicted[i] = True\n            conflicted[j] = True\n    # Pick seed vertex\n    vertices = [v for v in range(n) if conflicted[v]]\n    if not vertices:\n        vertices = list(range(n))\n    v = random.choice(vertices)\n    c1 = sol[v]\n    # Pick second color: neighbor color if possible; else random existing\n    neigh_colors = {sol[u] for u in adj[v] if sol[u] != c1}\n    if neigh_colors:\n        c2 = random.choice(list(neigh_colors))\n    else:\n        palette = list(sorted(set(sol)))\n        if len(palette) == 1:\n            # split color to create diversity\n            c2 = max(palette) + 1\n        else:\n            palette_no_v = [c for c in palette if c != c1]\n            c2 = random.choice(palette_no_v)\n    # Build Kempe chain component reachable from v using only colors c1 and c2\n    stack = [v]\n    in_chain = [False]*n\n    in_chain[v] = True\n    while stack:\n        x = stack.pop()\n        for u in adj[x]:\n            if in_chain[u]:\n                continue\n            if sol[u] == c1 or sol[u] == c2:\n                in_chain[u] = True\n                stack.append(u)\n    # Swap colors on the chain\n    new_sol = sol[:]\n    for i in range(n):\n        if in_chain[i]:\n            if new_sol[i] == c1:\n                new_sol[i] = c2\n            elif new_sol[i] == c2:\n                new_sol[i] = c1\n    # Optional palette compaction if a color becomes empty\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000768829}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns higher is better; use negative cost: -(conflicts*1_000_000 + colors)\n    # Invalid solutions get a dominated but finite score.\n    def objective(sol: List[int]) -> int:\n        if not isinstance(sol, (list, tuple)):\n            return 10**12  # very bad cost\n        if len(sol) != 9:\n            return 10**12\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**12\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -float(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improvement single-vertex recolor using existing palette.\n    # Does not relabel colors; introduces a new color only if conflicts>0 and no non-worsening recolor exists.\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Compute current conflicts per vertex\n    in_conflict = [False]*n\n    total_conflicts = 0\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n            total_conflicts += 1\n    palette = sorted(set(sol))\n    # Choose a vertex: prefer conflicted vertices; else random\n    cand_vertices = [v for v in range(n) if in_conflict[v]]\n    if not cand_vertices:\n        cand_vertices = list(range(n))\n    v = random.choice(cand_vertices)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_used_if)\n    # Evaluate recoloring to existing colors\n    for col in palette:\n        if col == current_color:\n            # evaluate staying as-is as well\n            pass\n        # count conflicts if v is col\n        conflicts = 0\n        for u in adj[v]:\n            if (col == sol[u]):\n                conflicts += 1\n        colors_if = len(palette)\n        key = (conflicts, colors_if)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if currently conflicted and no zero-conflict option\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = max(palette) + 1\n            conflicts = 0  # new color cannot conflict at v\n            colors_if = len(palette) + 1\n            key = (conflicts, colors_if)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = sol[:]\n    new_sol[v] = best_color\n    # If we increased palette but a color became unused, compact by removing gaps while preserving label identity ordering\n    # Only compact when a color class becomes empty\n    used = set(new_sol)\n    if len(used) < len(palette):\n        mapping = {}\n        next_c = 1\n        for x in sorted(used):\n            mapping[x] = next_c\n            next_c += 1\n        new_sol = [mapping[x] for x in new_sol]\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Kempe-chain swap on two colors through a random conflicted or random vertex; pure function\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicted vertices\n    conflicted = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            conflicted[i] = True\n            conflicted[j] = True\n    # Pick seed vertex\n    vertices = [v for v in range(n) if conflicted[v]]\n    if not vertices:\n        vertices = list(range(n))\n    v = random.choice(vertices)\n    c1 = sol[v]\n    # Pick second color: neighbor color if possible; else random existing\n    neigh_colors = {sol[u] for u in adj[v] if sol[u] != c1}\n    if neigh_colors:\n        c2 = random.choice(list(neigh_colors))\n    else:\n        palette = list(sorted(set(sol)))\n        if len(palette) == 1:\n            # split color to create diversity\n            c2 = max(palette) + 1\n        else:\n            palette_no_v = [c for c in palette if c != c1]\n            c2 = random.choice(palette_no_v)\n    # Build Kempe chain component reachable from v using only colors c1 and c2\n    stack = [v]\n    in_chain = [False]*n\n    in_chain[v] = True\n    while stack:\n        x = stack.pop()\n        for u in adj[x]:\n            if in_chain[u]:\n                continue\n            if sol[u] == c1 or sol[u] == c2:\n                in_chain[u] = True\n                stack.append(u)\n    # Swap colors on the chain\n    new_sol = sol[:]\n    for i in range(n):\n        if in_chain[i]:\n            if new_sol[i] == c1:\n                new_sol[i] = c2\n            elif new_sol[i] == c2:\n                new_sol[i] = c1\n    # Optional palette compaction if a color becomes empty\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001011571}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns higher is better; use negative cost: -(conflicts*1_000_000 + colors)\n    # Invalid solutions get a dominated but finite score.\n    def objective(sol: List[int]) -> int:\n        if not isinstance(sol, (list, tuple)):\n            return 10**12  # very bad cost\n        if len(sol) != 9:\n            return 10**12\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**12\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -float(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improvement single-vertex recolor using existing palette.\n    # Does not relabel colors; introduces a new color only if conflicts>0 and no non-worsening recolor exists.\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Compute current conflicts per vertex\n    in_conflict = [False]*n\n    total_conflicts = 0\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n            total_conflicts += 1\n    palette = sorted(set(sol))\n    # Choose a vertex: prefer conflicted vertices; else random\n    cand_vertices = [v for v in range(n) if in_conflict[v]]\n    if not cand_vertices:\n        cand_vertices = list(range(n))\n    v = random.choice(cand_vertices)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_used_if)\n    # Evaluate recoloring to existing colors\n    for col in palette:\n        if col == current_color:\n            # evaluate staying as-is as well\n            pass\n        # count conflicts if v is col\n        conflicts = 0\n        for u in adj[v]:\n            if (col == sol[u]):\n                conflicts += 1\n        colors_if = len(palette)\n        key = (conflicts, colors_if)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if currently conflicted and no zero-conflict option\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = max(palette) + 1\n            conflicts = 0  # new color cannot conflict at v\n            colors_if = len(palette) + 1\n            key = (conflicts, colors_if)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = sol[:]\n    new_sol[v] = best_color\n    # If we increased palette but a color became unused, compact by removing gaps while preserving label identity ordering\n    # Only compact when a color class becomes empty\n    used = set(new_sol)\n    if len(used) < len(palette):\n        mapping = {}\n        next_c = 1\n        for x in sorted(used):\n            mapping[x] = next_c\n            next_c += 1\n        new_sol = [mapping[x] for x in new_sol]\n    return new_sol\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Kempe-chain swap on two colors through a random conflicted or random vertex; pure function\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicted vertices\n    conflicted = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            conflicted[i] = True\n            conflicted[j] = True\n    # Pick seed vertex\n    vertices = [v for v in range(n) if conflicted[v]]\n    if not vertices:\n        vertices = list(range(n))\n    v = random.choice(vertices)\n    c1 = sol[v]\n    # Pick second color: neighbor color if possible; else random existing\n    neigh_colors = {sol[u] for u in adj[v] if sol[u] != c1}\n    if neigh_colors:\n        c2 = random.choice(list(neigh_colors))\n    else:\n        palette = list(sorted(set(sol)))\n        if len(palette) == 1:\n            # split color to create diversity\n            c2 = max(palette) + 1\n        else:\n            palette_no_v = [c for c in palette if c != c1]\n            c2 = random.choice(palette_no_v)\n    # Build Kempe chain component reachable from v using only colors c1 and c2\n    stack = [v]\n    in_chain = [False]*n\n    in_chain[v] = True\n    while stack:\n        x = stack.pop()\n        for u in adj[x]:\n            if in_chain[u]:\n                continue\n            if sol[u] == c1 or sol[u] == c2:\n                in_chain[u] = True\n                stack.append(u)\n    # Swap colors on the chain\n    new_sol = sol[:]\n    for i in range(n):\n        if in_chain[i]:\n            if new_sol[i] == c1:\n                new_sol[i] = c2\n            elif new_sol[i] == c2:\n                new_sol[i] = c1\n    # Optional palette compaction if a color becomes empty\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000944531}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns higher is better; use negative cost: -(conflicts*1_000_000 + colors)\n    # Invalid solutions get a dominated but finite score.\n    def objective(sol):\n        # Validate structure\n        if not isinstance(sol, (list, tuple)):\n            return 10**15\n        if len(sol) != 9:\n            return 10**15\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**15\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -(cost)","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improvement recolor of a single vertex using existing palette; add a new color only if necessary to eliminate a conflict when no zero-conflict color exists.\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicts per vertex\n    in_conflict = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n    palette = sorted(set(sol))\n    # Candidate vertices: prefer conflicted\n    cand_vertices = [v for v in range(n) if in_conflict[v]]\n    if not cand_vertices:\n        cand_vertices = list(range(n))\n    v = random.choice(cand_vertices)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_used_if)\n    # Try recoloring to existing colors (including staying)\n    for col in palette:\n        # count conflicts if v recolored to col\n        conflicts = 0\n        for u in adj[v]:\n            if col == sol[u]:\n                conflicts += 1\n        colors_if = len(palette)\n        key = (conflicts, colors_if)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if v is currently in conflict and no zero-conflict option exists\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = (max(palette) + 1) if palette else 1\n            conflicts = 0\n            colors_if = len(palette) + 1\n            key = (conflicts, colors_if)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = list(sol)\n    new_sol[v] = best_color\n    # Palette compaction if a color class became empty\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Kempe-chain swap between two colors selected via a seed vertex; maintains feasibility if input is feasible\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicted vertices\n    conflicted = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            conflicted[i] = True\n            conflicted[j] = True\n    # Pick seed vertex\n    vertices = [v for v in range(n) if conflicted[v]]\n    if not vertices:\n        vertices = list(range(n))\n    v = random.choice(vertices)\n    c1 = sol[v]\n    # Choose second color\n    neigh_colors = {sol[u] for u in adj[v] if sol[u] != c1}\n    palette = list(sorted(set(sol)))\n    if neigh_colors:\n        c2 = random.choice(list(neigh_colors))\n    else:\n        if len(palette) == 1:\n            c2 = max(palette) + 1\n        else:\n            palette_no_v = [c for c in palette if c != c1]\n            c2 = random.choice(palette_no_v)\n    # Build Kempe chain component from v using colors c1 and c2\n    stack = [v]\n    in_chain = [False]*n\n    in_chain[v] = True\n    allowed = {c1, c2}\n    while stack:\n        x = stack.pop()\n        for u in adj[x]:\n            if in_chain[u]:\n                continue\n            if sol[u] in allowed:\n                in_chain[u] = True\n                stack.append(u)\n    # Swap colors on the chain\n    new_sol = list(sol)\n    for i in range(n):\n        if in_chain[i]:\n            if new_sol[i] == c1:\n                new_sol[i] = c2\n            elif new_sol[i] == c2:\n                new_sol[i] = c1\n    # Compact palette labels\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000768339}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns higher is better; use negative cost: -(conflicts*1_000_000 + colors)\n    # Invalid solutions get a dominated but finite score.\n    def objective(sol):\n        # Validate structure\n        if not isinstance(sol, (list, tuple)):\n            return 10**15\n        if len(sol) != 9:\n            return 10**15\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**15\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -(cost)","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improvement recolor of a single vertex using existing palette; add a new color only if necessary to eliminate a conflict when no zero-conflict color exists.\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicts per vertex\n    in_conflict = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n    palette = sorted(set(sol))\n    # Candidate vertices: prefer conflicted\n    cand_vertices = [v for v in range(n) if in_conflict[v]]\n    if not cand_vertices:\n        cand_vertices = list(range(n))\n    v = random.choice(cand_vertices)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_used_if)\n    # Try recoloring to existing colors (including staying)\n    for col in palette:\n        # count conflicts if v recolored to col\n        conflicts = 0\n        for u in adj[v]:\n            if col == sol[u]:\n                conflicts += 1\n        colors_if = len(palette)\n        key = (conflicts, colors_if)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if v is currently in conflict and no zero-conflict option exists\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = (max(palette) + 1) if palette else 1\n            conflicts = 0\n            colors_if = len(palette) + 1\n            key = (conflicts, colors_if)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = list(sol)\n    new_sol[v] = best_color\n    # Palette compaction if a color class became empty\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Kempe-chain swap between two colors selected via a seed vertex; maintains feasibility if input is feasible\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicted vertices\n    conflicted = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            conflicted[i] = True\n            conflicted[j] = True\n    # Pick seed vertex\n    vertices = [v for v in range(n) if conflicted[v]]\n    if not vertices:\n        vertices = list(range(n))\n    v = random.choice(vertices)\n    c1 = sol[v]\n    # Choose second color\n    neigh_colors = {sol[u] for u in adj[v] if sol[u] != c1}\n    palette = list(sorted(set(sol)))\n    if neigh_colors:\n        c2 = random.choice(list(neigh_colors))\n    else:\n        if len(palette) == 1:\n            c2 = max(palette) + 1\n        else:\n            palette_no_v = [c for c in palette if c != c1]\n            c2 = random.choice(palette_no_v)\n    # Build Kempe chain component from v using colors c1 and c2\n    stack = [v]\n    in_chain = [False]*n\n    in_chain[v] = True\n    allowed = {c1, c2}\n    while stack:\n        x = stack.pop()\n        for u in adj[x]:\n            if in_chain[u]:\n                continue\n            if sol[u] in allowed:\n                in_chain[u] = True\n                stack.append(u)\n    # Swap colors on the chain\n    new_sol = list(sol)\n    for i in range(n):\n        if in_chain[i]:\n            if new_sol[i] == c1:\n                new_sol[i] = c2\n            elif new_sol[i] == c2:\n                new_sol[i] = c1\n    # Compact palette labels\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001076172}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns higher is better; use negative cost: -(conflicts*1_000_000 + colors)\n    # Invalid solutions get a dominated but finite score.\n    def objective(sol):\n        # Validate structure\n        if not isinstance(sol, (list, tuple)):\n            return 10**15\n        if len(sol) != 9:\n            return 10**15\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**15\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -(cost)","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Best-improvement recolor of a single vertex using existing palette; add a new color only if necessary to eliminate a conflict when no zero-conflict color exists.\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicts per vertex\n    in_conflict = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n    palette = sorted(set(sol))\n    # Candidate vertices: prefer conflicted\n    cand_vertices = [v for v in range(n) if in_conflict[v]]\n    if not cand_vertices:\n        cand_vertices = list(range(n))\n    v = random.choice(cand_vertices)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_used_if)\n    # Try recoloring to existing colors (including staying)\n    for col in palette:\n        # count conflicts if v recolored to col\n        conflicts = 0\n        for u in adj[v]:\n            if col == sol[u]:\n                conflicts += 1\n        colors_if = len(palette)\n        key = (conflicts, colors_if)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if v is currently in conflict and no zero-conflict option exists\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = (max(palette) + 1) if palette else 1\n            conflicts = 0\n            colors_if = len(palette) + 1\n            key = (conflicts, colors_if)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = list(sol)\n    new_sol[v] = best_color\n    # Palette compaction if a color class became empty\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Kempe-chain swap between two colors selected via a seed vertex; maintains feasibility if input is feasible\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Identify conflicted vertices\n    conflicted = [False]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            conflicted[i] = True\n            conflicted[j] = True\n    # Pick seed vertex\n    vertices = [v for v in range(n) if conflicted[v]]\n    if not vertices:\n        vertices = list(range(n))\n    v = random.choice(vertices)\n    c1 = sol[v]\n    # Choose second color\n    neigh_colors = {sol[u] for u in adj[v] if sol[u] != c1}\n    palette = list(sorted(set(sol)))\n    if neigh_colors:\n        c2 = random.choice(list(neigh_colors))\n    else:\n        if len(palette) == 1:\n            c2 = max(palette) + 1\n        else:\n            palette_no_v = [c for c in palette if c != c1]\n            c2 = random.choice(palette_no_v)\n    # Build Kempe chain component from v using colors c1 and c2\n    stack = [v]\n    in_chain = [False]*n\n    in_chain[v] = True\n    allowed = {c1, c2}\n    while stack:\n        x = stack.pop()\n        for u in adj[x]:\n            if in_chain[u]:\n                continue\n            if sol[u] in allowed:\n                in_chain[u] = True\n                stack.append(u)\n    # Swap colors on the chain\n    new_sol = list(sol)\n    for i in range(n):\n        if in_chain[i]:\n            if new_sol[i] == c1:\n                new_sol[i] = c2\n            elif new_sol[i] == c2:\n                new_sol[i] = c1\n    # Compact palette labels\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    return new_sol","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001024711}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Negative cost: conflicts heavily penalized, then colors used\n    def objective(sol):\n        if not isinstance(sol, (list, tuple)):\n            return 10**15\n        if len(sol) != 9:\n            return 10**15\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**15\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (nb_type, movement_type))\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Conflict flags and degrees\n    in_conflict = [False]*n\n    conflict_deg = [0]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n            conflict_deg[i] += 1\n            conflict_deg[j] += 1\n    palette = sorted(set(sol))\n\n    def compaction_colors_after(tmp_sol):\n        used = set(tmp_sol)\n        return len(used)\n\n    # Candidate vertex selection: prioritize highest conflict degree, then random among ties; if none, use highest degree w.r.t. different colors\n    candidates = [v for v in range(n) if in_conflict[v]]\n    if candidates:\n        max_cd = max(conflict_deg[v] for v in candidates)\n        cand_vertices = [v for v in candidates if conflict_deg[v] == max_cd]\n    else:\n        # DSATUR-style: pick vertex with max number of distinct neighbor colors\n        sat = []\n        for v in range(n):\n            sat.append(len({sol[u] for u in adj[v]}))\n        max_sat = max(sat)\n        cand_vertices = [v for v in range(n) if sat[v] == max_sat]\n    v = random.choice(cand_vertices)\n\n    # With small probability, perform a Kempe-chain swap move\n    if random.random() < 0.25 and len(palette) >= 2:\n        c1 = sol[v]\n        neigh_cols = list({sol[u] for u in adj[v] if sol[u] != c1})\n        if not neigh_cols:\n            neigh_cols = [c for c in palette if c != c1]\n        if neigh_cols:\n            c2 = random.choice(neigh_cols)\n            # Build component on colors c1,c2 starting at v\n            allowed = {c1, c2}\n            stack = [v]\n            in_chain = [False]*n\n            in_chain[v] = True\n            while stack:\n                x = stack.pop()\n                for u in adj[x]:\n                    if not in_chain[u] and sol[u] in allowed:\n                        in_chain[u] = True\n                        stack.append(u)\n            new_sol = list(sol)\n            for i in range(n):\n                if in_chain[i]:\n                    new_sol[i] = c2 if new_sol[i] == c1 else (c1 if new_sol[i] == c2 else new_sol[i])\n            # Compact labels\n            used = sorted(set(new_sol))\n            mapping = {c: idx+1 for idx, c in enumerate(used)}\n            new_sol = [mapping[c] for c in new_sol]\n            return new_sol, (\"kempe\", \"swap\")\n    # Otherwise do best-improvement single-vertex recolor (including potential color reduction)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_after, post_conflict_degree)\n    # Try all existing colors (including staying)\n    for col in palette:\n        # Compute conflicts after recoloring v to col\n        conflicts_after = 0\n        for u in adj[v]:\n            if col == sol[u]:\n                conflicts_after += 1\n        tmp = list(sol)\n        tmp[v] = col\n        # If a color class becomes empty, compaction reduces colors\n        colors_after = compaction_colors_after(tmp)\n        # Post-move conflict degree of v\n        post_cd = conflicts_after\n        key = (conflicts_after, colors_after, post_cd)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if v is in conflict and zero-conflict option is absent\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = (max(palette) + 1) if palette else 1\n            conflicts_after = 0\n            tmp = list(sol)\n            tmp[v] = new_color\n            colors_after = compaction_colors_after(tmp)\n            post_cd = 0\n            key = (conflicts_after, colors_after, post_cd)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = list(sol)\n    new_sol[v] = best_color\n    # Palette compaction if any color class emptied\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    move_type = \"recolor\"\n    return new_sol, (\"recolor\", \"single\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Apply a small sequence of randomized Kempe-chain swaps \/ recolors to escape local minima\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n\n    k = 3  # perturbation strength\n    new_sol = list(sol)\n    for _ in range(k):\n        palette = sorted(set(new_sol))\n        if len(palette) >= 2 and random.random() < 0.7:\n            # Kempe-chain swap from random vertex and random neighbor color\n            v = random.randrange(n)\n            c1 = new_sol[v]\n            neigh_colors = [new_sol[u] for u in adj[v] if new_sol[u] != c1]\n            if not neigh_colors:\n                others = [c for c in palette if c != c1]\n                if not others:\n                    continue\n                c2 = random.choice(others)\n            else:\n                c2 = random.choice(neigh_colors)\n            allowed = {c1, c2}\n            stack = [v]\n            in_chain = [False]*n\n            in_chain[v] = True\n            while stack:\n                x = stack.pop()\n                for u in adj[x]:\n                    if not in_chain[u] and new_sol[u] in allowed:\n                        in_chain[u] = True\n                        stack.append(u)\n            for i in range(n):\n                if in_chain[i]:\n                    new_sol[i] = c2 if new_sol[i] == c1 else (c1 if new_sol[i] == c2 else new_sol[i])\n        else:\n            # Random recolor of a conflicted or random vertex\n            conflicted = [False]*n\n            for i, j in edges:\n                if new_sol[i] == new_sol[j]:\n                    conflicted[i] = True\n                    conflicted[j] = True\n            cand = [i for i in range(n) if conflicted[i]] or list(range(n))\n            v = random.choice(cand)\n            palette = sorted(set(new_sol))\n            choices = list(palette)\n            if random.random() < 0.2:\n                choices.append(max(palette)+1)\n            if choices:\n                new_sol[v] = random.choice(choices)\n        # Compact labels after each sub-move\n        used = sorted(set(new_sol))\n        mapping = {c: idx+1 for idx, c in enumerate(used)}\n        new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001050502}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Negative cost: conflicts heavily penalized, then colors used\n    def objective(sol):\n        if not isinstance(sol, (list, tuple)):\n            return 10**15\n        if len(sol) != 9:\n            return 10**15\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**15\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (nb_type, movement_type))\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Conflict flags and degrees\n    in_conflict = [False]*n\n    conflict_deg = [0]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n            conflict_deg[i] += 1\n            conflict_deg[j] += 1\n    palette = sorted(set(sol))\n\n    def compaction_colors_after(tmp_sol):\n        used = set(tmp_sol)\n        return len(used)\n\n    # Candidate vertex selection: prioritize highest conflict degree, then random among ties; if none, use highest degree w.r.t. different colors\n    candidates = [v for v in range(n) if in_conflict[v]]\n    if candidates:\n        max_cd = max(conflict_deg[v] for v in candidates)\n        cand_vertices = [v for v in candidates if conflict_deg[v] == max_cd]\n    else:\n        # DSATUR-style: pick vertex with max number of distinct neighbor colors\n        sat = []\n        for v in range(n):\n            sat.append(len({sol[u] for u in adj[v]}))\n        max_sat = max(sat)\n        cand_vertices = [v for v in range(n) if sat[v] == max_sat]\n    v = random.choice(cand_vertices)\n\n    # With small probability, perform a Kempe-chain swap move\n    if random.random() < 0.25 and len(palette) >= 2:\n        c1 = sol[v]\n        neigh_cols = list({sol[u] for u in adj[v] if sol[u] != c1})\n        if not neigh_cols:\n            neigh_cols = [c for c in palette if c != c1]\n        if neigh_cols:\n            c2 = random.choice(neigh_cols)\n            # Build component on colors c1,c2 starting at v\n            allowed = {c1, c2}\n            stack = [v]\n            in_chain = [False]*n\n            in_chain[v] = True\n            while stack:\n                x = stack.pop()\n                for u in adj[x]:\n                    if not in_chain[u] and sol[u] in allowed:\n                        in_chain[u] = True\n                        stack.append(u)\n            new_sol = list(sol)\n            for i in range(n):\n                if in_chain[i]:\n                    new_sol[i] = c2 if new_sol[i] == c1 else (c1 if new_sol[i] == c2 else new_sol[i])\n            # Compact labels\n            used = sorted(set(new_sol))\n            mapping = {c: idx+1 for idx, c in enumerate(used)}\n            new_sol = [mapping[c] for c in new_sol]\n            return new_sol, (\"kempe\", \"swap\")\n    # Otherwise do best-improvement single-vertex recolor (including potential color reduction)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_after, post_conflict_degree)\n    # Try all existing colors (including staying)\n    for col in palette:\n        # Compute conflicts after recoloring v to col\n        conflicts_after = 0\n        for u in adj[v]:\n            if col == sol[u]:\n                conflicts_after += 1\n        tmp = list(sol)\n        tmp[v] = col\n        # If a color class becomes empty, compaction reduces colors\n        colors_after = compaction_colors_after(tmp)\n        # Post-move conflict degree of v\n        post_cd = conflicts_after\n        key = (conflicts_after, colors_after, post_cd)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if v is in conflict and zero-conflict option is absent\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = (max(palette) + 1) if palette else 1\n            conflicts_after = 0\n            tmp = list(sol)\n            tmp[v] = new_color\n            colors_after = compaction_colors_after(tmp)\n            post_cd = 0\n            key = (conflicts_after, colors_after, post_cd)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = list(sol)\n    new_sol[v] = best_color\n    # Palette compaction if any color class emptied\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    move_type = \"recolor\"\n    return new_sol, (\"recolor\", \"single\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Apply a small sequence of randomized Kempe-chain swaps \/ recolors to escape local minima\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n\n    k = 3  # perturbation strength\n    new_sol = list(sol)\n    for _ in range(k):\n        palette = sorted(set(new_sol))\n        if len(palette) >= 2 and random.random() < 0.7:\n            # Kempe-chain swap from random vertex and random neighbor color\n            v = random.randrange(n)\n            c1 = new_sol[v]\n            neigh_colors = [new_sol[u] for u in adj[v] if new_sol[u] != c1]\n            if not neigh_colors:\n                others = [c for c in palette if c != c1]\n                if not others:\n                    continue\n                c2 = random.choice(others)\n            else:\n                c2 = random.choice(neigh_colors)\n            allowed = {c1, c2}\n            stack = [v]\n            in_chain = [False]*n\n            in_chain[v] = True\n            while stack:\n                x = stack.pop()\n                for u in adj[x]:\n                    if not in_chain[u] and new_sol[u] in allowed:\n                        in_chain[u] = True\n                        stack.append(u)\n            for i in range(n):\n                if in_chain[i]:\n                    new_sol[i] = c2 if new_sol[i] == c1 else (c1 if new_sol[i] == c2 else new_sol[i])\n        else:\n            # Random recolor of a conflicted or random vertex\n            conflicted = [False]*n\n            for i, j in edges:\n                if new_sol[i] == new_sol[j]:\n                    conflicted[i] = True\n                    conflicted[j] = True\n            cand = [i for i in range(n) if conflicted[i]] or list(range(n))\n            v = random.choice(cand)\n            palette = sorted(set(new_sol))\n            choices = list(palette)\n            if random.random() < 0.2:\n                choices.append(max(palette)+1)\n            if choices:\n                new_sol[v] = random.choice(choices)\n        # Compact labels after each sub-move\n        used = sorted(set(new_sol))\n        mapping = {c: idx+1 for idx, c in enumerate(used)}\n        new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001391966}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_INT_COLORING_START_AT_1","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Negative cost: conflicts heavily penalized, then colors used\n    def objective(sol):\n        if not isinstance(sol, (list, tuple)):\n            return 10**15\n        if len(sol) != 9:\n            return 10**15\n        for x in sol:\n            if not isinstance(x, int) or x <= 0:\n                return 10**15\n        edges = [\n            (0,1),(0,6),(0,8),\n            (1,2),(1,5),(1,6),(1,7),\n            (2,3),\n            (3,5),(3,6),(3,7),(3,8),\n            (4,6),(4,7),(4,8),\n            (6,8),(7,8)\n        ]\n        conflicts = 0\n        for i, j in edges:\n            if sol[i] == sol[j]:\n                conflicts += 1\n        colors_used = len(set(sol))\n        return conflicts * 1_000_000 + colors_used\n    cost = objective(solution)\n    return -(cost)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (nb_type, movement_type))\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n    # Conflict flags and degrees\n    in_conflict = [False]*n\n    conflict_deg = [0]*n\n    for i, j in edges:\n        if sol[i] == sol[j]:\n            in_conflict[i] = True\n            in_conflict[j] = True\n            conflict_deg[i] += 1\n            conflict_deg[j] += 1\n    palette = sorted(set(sol))\n\n    def compaction_colors_after(tmp_sol):\n        used = set(tmp_sol)\n        return len(used)\n\n    # Candidate vertex selection: prioritize highest conflict degree, then random among ties; if none, use highest degree w.r.t. different colors\n    candidates = [v for v in range(n) if in_conflict[v]]\n    if candidates:\n        max_cd = max(conflict_deg[v] for v in candidates)\n        cand_vertices = [v for v in candidates if conflict_deg[v] == max_cd]\n    else:\n        # DSATUR-style: pick vertex with max number of distinct neighbor colors\n        sat = []\n        for v in range(n):\n            sat.append(len({sol[u] for u in adj[v]}))\n        max_sat = max(sat)\n        cand_vertices = [v for v in range(n) if sat[v] == max_sat]\n    v = random.choice(cand_vertices)\n\n    # With small probability, perform a Kempe-chain swap move\n    if random.random() < 0.25 and len(palette) >= 2:\n        c1 = sol[v]\n        neigh_cols = list({sol[u] for u in adj[v] if sol[u] != c1})\n        if not neigh_cols:\n            neigh_cols = [c for c in palette if c != c1]\n        if neigh_cols:\n            c2 = random.choice(neigh_cols)\n            # Build component on colors c1,c2 starting at v\n            allowed = {c1, c2}\n            stack = [v]\n            in_chain = [False]*n\n            in_chain[v] = True\n            while stack:\n                x = stack.pop()\n                for u in adj[x]:\n                    if not in_chain[u] and sol[u] in allowed:\n                        in_chain[u] = True\n                        stack.append(u)\n            new_sol = list(sol)\n            for i in range(n):\n                if in_chain[i]:\n                    new_sol[i] = c2 if new_sol[i] == c1 else (c1 if new_sol[i] == c2 else new_sol[i])\n            # Compact labels\n            used = sorted(set(new_sol))\n            mapping = {c: idx+1 for idx, c in enumerate(used)}\n            new_sol = [mapping[c] for c in new_sol]\n            return new_sol, (\"kempe\", \"swap\")\n    # Otherwise do best-improvement single-vertex recolor (including potential color reduction)\n    current_color = sol[v]\n    best_color = current_color\n    best_key = None  # (conflicts_after, colors_after, post_conflict_degree)\n    # Try all existing colors (including staying)\n    for col in palette:\n        # Compute conflicts after recoloring v to col\n        conflicts_after = 0\n        for u in adj[v]:\n            if col == sol[u]:\n                conflicts_after += 1\n        tmp = list(sol)\n        tmp[v] = col\n        # If a color class becomes empty, compaction reduces colors\n        colors_after = compaction_colors_after(tmp)\n        # Post-move conflict degree of v\n        post_cd = conflicts_after\n        key = (conflicts_after, colors_after, post_cd)\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = col\n    # Consider adding a new color only if v is in conflict and zero-conflict option is absent\n    if in_conflict[v]:\n        zero_exists = (best_key is not None and best_key[0] == 0)\n        if not zero_exists:\n            new_color = (max(palette) + 1) if palette else 1\n            conflicts_after = 0\n            tmp = list(sol)\n            tmp[v] = new_color\n            colors_after = compaction_colors_after(tmp)\n            post_cd = 0\n            key = (conflicts_after, colors_after, post_cd)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_color = new_color\n    new_sol = list(sol)\n    new_sol[v] = best_color\n    # Palette compaction if any color class emptied\n    used = sorted(set(new_sol))\n    mapping = {c: idx+1 for idx, c in enumerate(used)}\n    new_sol = [mapping[c] for c in new_sol]\n    move_type = \"recolor\"\n    return new_sol, (\"recolor\", \"single\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Apply a small sequence of randomized Kempe-chain swaps \/ recolors to escape local minima\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Sanitize\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        sol = [1]*n\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    adj = [[] for _ in range(n)]\n    for i, j in edges:\n        adj[i].append(j)\n        adj[j].append(i)\n\n    k = 3  # perturbation strength\n    new_sol = list(sol)\n    for _ in range(k):\n        palette = sorted(set(new_sol))\n        if len(palette) >= 2 and random.random() < 0.7:\n            # Kempe-chain swap from random vertex and random neighbor color\n            v = random.randrange(n)\n            c1 = new_sol[v]\n            neigh_colors = [new_sol[u] for u in adj[v] if new_sol[u] != c1]\n            if not neigh_colors:\n                others = [c for c in palette if c != c1]\n                if not others:\n                    continue\n                c2 = random.choice(others)\n            else:\n                c2 = random.choice(neigh_colors)\n            allowed = {c1, c2}\n            stack = [v]\n            in_chain = [False]*n\n            in_chain[v] = True\n            while stack:\n                x = stack.pop()\n                for u in adj[x]:\n                    if not in_chain[u] and new_sol[u] in allowed:\n                        in_chain[u] = True\n                        stack.append(u)\n            for i in range(n):\n                if in_chain[i]:\n                    new_sol[i] = c2 if new_sol[i] == c1 else (c1 if new_sol[i] == c2 else new_sol[i])\n        else:\n            # Random recolor of a conflicted or random vertex\n            conflicted = [False]*n\n            for i, j in edges:\n                if new_sol[i] == new_sol[j]:\n                    conflicted[i] = True\n                    conflicted[j] = True\n            cand = [i for i in range(n) if conflicted[i]] or list(range(n))\n            v = random.choice(cand)\n            palette = sorted(set(new_sol))\n            choices = list(palette)\n            if random.random() < 0.2:\n                choices.append(max(palette)+1)\n            if choices:\n                new_sol[v] = random.choice(choices)\n        # Compact labels after each sub-move\n        used = sorted(set(new_sol))\n        mapping = {c: idx+1 for idx, c in enumerate(used)}\n        new_sol = [mapping[c] for c in new_sol]\n    return new_sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001589498}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"LIST_OF_9_POSITIVE_INTEGERS c[0..8], where c[i] is the color (>=1) of node i+1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Penalize conflicts heavily; tie-break by fewer colors.\n    # Representation: list of 9 positive integers (colors for nodes 1..9)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Edges as 0-based indices for nodes 1..9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    num_colors = len(set(solution))\n    return conflicts * 10**6 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_descriptor)\n    # Ensure a valid base to generate a neighbour from\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # initialize a simple random feasible-shaped vector (not necessarily conflict-free)\n        solution = [random.randint(1, 3) for _ in range(9)]\n    neighbor = solution.copy()\n    n = len(neighbor)\n    i = random.randrange(n)\n    current_colors = set(neighbor)\n    max_color_allowed = min(9, max(current_colors) + 1)\n    # Propose a different color\n    new_color = neighbor[i]\n    tries = 0\n    while new_color == neighbor[i] and tries < 10:\n        new_color = random.randint(1, max_color_allowed)\n        tries += 1\n    neighbor[i] = new_color if new_color != solution[i] else ((new_color % max_color_allowed) + 1)\n    return neighbor, \"1-change\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-change perturbation to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        solution = [random.randint(1, 3) for _ in range(9)]\n    perturbed = solution.copy()\n    n = len(perturbed)\n    k = random.randint(2, 4)  # number of positions to change\n    indices = random.sample(range(n), k)\n    current_colors = set(perturbed)\n    max_color_allowed = min(9, max(current_colors) + 1)\n    for i in indices:\n        new_color = perturbed[i]\n        tries = 0\n        while new_color == perturbed[i] and tries < 10:\n            # Occasionally allow expanding color set by 1\n            cap = max_color_allowed if random.random() < 0.8 else min(9, max_color_allowed + 1)\n            new_color = random.randint(1, cap)\n            tries += 1\n        perturbed[i] = new_color if new_color != solution[i] else ((new_color % max(1, cap)) + 1)\n    return perturbed\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000557266}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"LIST_OF_9_POSITIVE_INTEGERS c[0..8], where c[i] is the color (>=1) of node i+1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Penalize conflicts heavily; tie-break by fewer colors.\n    # Representation: list of 9 positive integers (colors for nodes 1..9)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Edges as 0-based indices for nodes 1..9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    num_colors = len(set(solution))\n    return conflicts * 10**6 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_descriptor)\n    # Ensure a valid base to generate a neighbour from\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # initialize a simple random feasible-shaped vector (not necessarily conflict-free)\n        solution = [random.randint(1, 3) for _ in range(9)]\n    neighbor = solution.copy()\n    n = len(neighbor)\n    i = random.randrange(n)\n    current_colors = set(neighbor)\n    max_color_allowed = min(9, max(current_colors) + 1)\n    # Propose a different color\n    new_color = neighbor[i]\n    tries = 0\n    while new_color == neighbor[i] and tries < 10:\n        new_color = random.randint(1, max_color_allowed)\n        tries += 1\n    neighbor[i] = new_color if new_color != solution[i] else ((new_color % max_color_allowed) + 1)\n    return neighbor, \"1-change\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-change perturbation to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        solution = [random.randint(1, 3) for _ in range(9)]\n    perturbed = solution.copy()\n    n = len(perturbed)\n    k = random.randint(2, 4)  # number of positions to change\n    indices = random.sample(range(n), k)\n    current_colors = set(perturbed)\n    max_color_allowed = min(9, max(current_colors) + 1)\n    for i in indices:\n        new_color = perturbed[i]\n        tries = 0\n        while new_color == perturbed[i] and tries < 10:\n            # Occasionally allow expanding color set by 1\n            cap = max_color_allowed if random.random() < 0.8 else min(9, max_color_allowed + 1)\n            new_color = random.randint(1, cap)\n            tries += 1\n        perturbed[i] = new_color if new_color != solution[i] else ((new_color % max(1, cap)) + 1)\n    return perturbed\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000520457}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"LIST_OF_9_POSITIVE_INTEGERS c[0..8], where c[i] is the color (>=1) of node i+1","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Penalize conflicts heavily; tie-break by fewer colors.\n    # Representation: list of 9 positive integers (colors for nodes 1..9)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Edges as 0-based indices for nodes 1..9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    num_colors = len(set(solution))\n    return conflicts * 10**6 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_descriptor)\n    # Ensure a valid base to generate a neighbour from\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        # initialize a simple random feasible-shaped vector (not necessarily conflict-free)\n        solution = [random.randint(1, 3) for _ in range(9)]\n    neighbor = solution.copy()\n    n = len(neighbor)\n    i = random.randrange(n)\n    current_colors = set(neighbor)\n    max_color_allowed = min(9, max(current_colors) + 1)\n    # Propose a different color\n    new_color = neighbor[i]\n    tries = 0\n    while new_color == neighbor[i] and tries < 10:\n        new_color = random.randint(1, max_color_allowed)\n        tries += 1\n    neighbor[i] = new_color if new_color != solution[i] else ((new_color % max_color_allowed) + 1)\n    return neighbor, \"1-change\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-change perturbation to escape local minima\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        solution = [random.randint(1, 3) for _ in range(9)]\n    perturbed = solution.copy()\n    n = len(perturbed)\n    k = random.randint(2, 4)  # number of positions to change\n    indices = random.sample(range(n), k)\n    current_colors = set(perturbed)\n    max_color_allowed = min(9, max(current_colors) + 1)\n    for i in indices:\n        new_color = perturbed[i]\n        tries = 0\n        while new_color == perturbed[i] and tries < 10:\n            # Occasionally allow expanding color set by 1\n            cap = max_color_allowed if random.random() < 0.8 else min(9, max_color_allowed + 1)\n            new_color = random.randint(1, cap)\n            tries += 1\n        perturbed[i] = new_color if new_color != solution[i] else ((new_color % max(1, cap)) + 1)\n    return perturbed\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000502355}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9. solution[i] is the color (positive int >=1) assigned to node i+1 for i in [0..8].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Penalize conflicts heavily; tie-break by fewer colors.\n    # Representation: list of 9 positive integers (colors for nodes 1..9)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Edges as 0-based indices for nodes 1..9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_descriptor)\n    # Robustify input; if invalid, initialize a basic 3-color assignment\n    def initial_feasible_like():\n        return [random.randint(1, 3) for _ in range(9)]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        solution = initial_feasible_like()\n\n    n = 9\n    # Problem data local\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    current = list(solution)\n    palette = sorted(set(current))\n\n    # Identify conflicting nodes\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n\n    # With small probability, perform a color-class swap to diversify (keeps palette size)\n    if not conflict_nodes and len(palette) >= 2 and random.random() < 0.1:\n        a, b = random.sample(palette, 2)\n        neighbor = [b if x == a else (a if x == b else x) for x in current]\n        return neighbor, \"swap-colors\"\n\n    # Select target node: max conflicts if any, else a high-degree node\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), len(adj[i]), random.random()))\n    else:\n        # pick among top-degree nodes\n        degrees = [len(adj[i]) for i in range(n)]\n        maxdeg = max(degrees)\n        candidates = [i for i,d in enumerate(degrees) if d >= maxdeg - 0]\n        target = random.choice(candidates)\n\n    # Try recoloring target using only existing palette (no new colors in neighbour)\n    best_color = current[target]\n    best_local = node_conflicts(current, target)\n\n    for color in palette:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        if local < best_local or (local == best_local and color < best_color):\n            best_local = local\n            best_color = color\n\n    neighbor = list(current)\n    # If no improvement found and there are >=2 colors, attempt a palette-preserving reassignment\n    if best_color == current[target] and len(palette) >= 2:\n        # pick a different color uniformly from palette\n        alt_colors = [c for c in palette if c != current[target]]\n        best_color = random.choice(alt_colors)\n    neighbor[target] = best_color\n\n    return neighbor, \"recolor-1\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Structured multi-change perturbation using Kempe-chain inspired swaps\n    def init_solution():\n        return [random.randint(1, 3) for _ in range(9)]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        base = init_solution()\n    else:\n        base = list(solution)\n\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_list(sol):\n        cl = [0]*n\n        for i in range(n):\n            c = sol[i]\n            cl[i] = sum(1 for j in adj[i] if sol[j] == c)\n        return cl\n\n    pert = list(base)\n    palette = sorted(set(pert))\n\n    t = random.randint(1, 2)\n    for _ in range(t):\n        # Prefer a conflicting edge; else pick a random edge\n        cl = conflicts_list(pert)\n        conflict_edges = []\n        for u,v in edges:\n            if pert[u] == pert[v]:\n                conflict_edges.append((u,v))\n        if conflict_edges:\n            u,v = random.choice(conflict_edges)\n        else:\n            u,v = random.choice(edges)\n        ca, cb = pert[u], pert[v]\n        if ca == cb:\n            # pick a different color from palette for v to define a Kempe pair\n            alt = [c for c in palette if c != ca]\n            if not alt:\n                continue\n            cb = random.choice(alt)\n        # Build Kempe-chain component reachable from u using only colors ca and cb\n        stack = [u]\n        seen = set([u])\n        use_colors = {ca, cb}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and pert[y] in use_colors:\n                    if (pert[x] == ca and pert[y] == cb) or (pert[x] == cb and pert[y] == ca) or (pert[x] == pert[y]):\n                        seen.add(y)\n                        stack.append(y)\n        # Swap colors on this component\n        for x in seen:\n            if pert[x] == ca:\n                pert[x] = cb\n            elif pert[x] == cb:\n                pert[x] = ca\n        # Occasionally perform a random class swap for diversification\n        if random.random() < 0.2 and len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            pert = [b if x == a else (a if x == b else x) for x in pert]\n        palette = sorted(set(pert))\n\n    return pert\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00081042}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9. solution[i] is the color (positive int >=1) assigned to node i+1 for i in [0..8].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Penalize conflicts heavily; tie-break by fewer colors.\n    # Representation: list of 9 positive integers (colors for nodes 1..9)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Edges as 0-based indices for nodes 1..9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_descriptor)\n    # Robustify input; if invalid, initialize a basic 3-color assignment\n    def initial_feasible_like():\n        return [random.randint(1, 3) for _ in range(9)]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        solution = initial_feasible_like()\n\n    n = 9\n    # Problem data local\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    current = list(solution)\n    palette = sorted(set(current))\n\n    # Identify conflicting nodes\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n\n    # With small probability, perform a color-class swap to diversify (keeps palette size)\n    if not conflict_nodes and len(palette) >= 2 and random.random() < 0.1:\n        a, b = random.sample(palette, 2)\n        neighbor = [b if x == a else (a if x == b else x) for x in current]\n        return neighbor, \"swap-colors\"\n\n    # Select target node: max conflicts if any, else a high-degree node\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), len(adj[i]), random.random()))\n    else:\n        # pick among top-degree nodes\n        degrees = [len(adj[i]) for i in range(n)]\n        maxdeg = max(degrees)\n        candidates = [i for i,d in enumerate(degrees) if d >= maxdeg - 0]\n        target = random.choice(candidates)\n\n    # Try recoloring target using only existing palette (no new colors in neighbour)\n    best_color = current[target]\n    best_local = node_conflicts(current, target)\n\n    for color in palette:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        if local < best_local or (local == best_local and color < best_color):\n            best_local = local\n            best_color = color\n\n    neighbor = list(current)\n    # If no improvement found and there are >=2 colors, attempt a palette-preserving reassignment\n    if best_color == current[target] and len(palette) >= 2:\n        # pick a different color uniformly from palette\n        alt_colors = [c for c in palette if c != current[target]]\n        best_color = random.choice(alt_colors)\n    neighbor[target] = best_color\n\n    return neighbor, \"recolor-1\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Structured multi-change perturbation using Kempe-chain inspired swaps\n    def init_solution():\n        return [random.randint(1, 3) for _ in range(9)]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        base = init_solution()\n    else:\n        base = list(solution)\n\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_list(sol):\n        cl = [0]*n\n        for i in range(n):\n            c = sol[i]\n            cl[i] = sum(1 for j in adj[i] if sol[j] == c)\n        return cl\n\n    pert = list(base)\n    palette = sorted(set(pert))\n\n    t = random.randint(1, 2)\n    for _ in range(t):\n        # Prefer a conflicting edge; else pick a random edge\n        cl = conflicts_list(pert)\n        conflict_edges = []\n        for u,v in edges:\n            if pert[u] == pert[v]:\n                conflict_edges.append((u,v))\n        if conflict_edges:\n            u,v = random.choice(conflict_edges)\n        else:\n            u,v = random.choice(edges)\n        ca, cb = pert[u], pert[v]\n        if ca == cb:\n            # pick a different color from palette for v to define a Kempe pair\n            alt = [c for c in palette if c != ca]\n            if not alt:\n                continue\n            cb = random.choice(alt)\n        # Build Kempe-chain component reachable from u using only colors ca and cb\n        stack = [u]\n        seen = set([u])\n        use_colors = {ca, cb}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and pert[y] in use_colors:\n                    if (pert[x] == ca and pert[y] == cb) or (pert[x] == cb and pert[y] == ca) or (pert[x] == pert[y]):\n                        seen.add(y)\n                        stack.append(y)\n        # Swap colors on this component\n        for x in seen:\n            if pert[x] == ca:\n                pert[x] = cb\n            elif pert[x] == cb:\n                pert[x] = ca\n        # Occasionally perform a random class swap for diversification\n        if random.random() < 0.2 and len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            pert = [b if x == a else (a if x == b else x) for x in pert]\n        palette = sorted(set(pert))\n\n    return pert\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001145123}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9. solution[i] is the color (positive int >=1) assigned to node i+1 for i in [0..8].","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness: lower is better. Penalize conflicts heavily; tie-break by fewer colors.\n    # Representation: list of 9 positive integers (colors for nodes 1..9)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Edges as 0-based indices for nodes 1..9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_descriptor)\n    # Robustify input; if invalid, initialize a basic 3-color assignment\n    def initial_feasible_like():\n        return [random.randint(1, 3) for _ in range(9)]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        solution = initial_feasible_like()\n\n    n = 9\n    # Problem data local\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    current = list(solution)\n    palette = sorted(set(current))\n\n    # Identify conflicting nodes\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n\n    # With small probability, perform a color-class swap to diversify (keeps palette size)\n    if not conflict_nodes and len(palette) >= 2 and random.random() < 0.1:\n        a, b = random.sample(palette, 2)\n        neighbor = [b if x == a else (a if x == b else x) for x in current]\n        return neighbor, \"swap-colors\"\n\n    # Select target node: max conflicts if any, else a high-degree node\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), len(adj[i]), random.random()))\n    else:\n        # pick among top-degree nodes\n        degrees = [len(adj[i]) for i in range(n)]\n        maxdeg = max(degrees)\n        candidates = [i for i,d in enumerate(degrees) if d >= maxdeg - 0]\n        target = random.choice(candidates)\n\n    # Try recoloring target using only existing palette (no new colors in neighbour)\n    best_color = current[target]\n    best_local = node_conflicts(current, target)\n\n    for color in palette:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        if local < best_local or (local == best_local and color < best_color):\n            best_local = local\n            best_color = color\n\n    neighbor = list(current)\n    # If no improvement found and there are >=2 colors, attempt a palette-preserving reassignment\n    if best_color == current[target] and len(palette) >= 2:\n        # pick a different color uniformly from palette\n        alt_colors = [c for c in palette if c != current[target]]\n        best_color = random.choice(alt_colors)\n    neighbor[target] = best_color\n\n    return neighbor, \"recolor-1\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Structured multi-change perturbation using Kempe-chain inspired swaps\n    def init_solution():\n        return [random.randint(1, 3) for _ in range(9)]\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        base = init_solution()\n    else:\n        base = list(solution)\n\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_list(sol):\n        cl = [0]*n\n        for i in range(n):\n            c = sol[i]\n            cl[i] = sum(1 for j in adj[i] if sol[j] == c)\n        return cl\n\n    pert = list(base)\n    palette = sorted(set(pert))\n\n    t = random.randint(1, 2)\n    for _ in range(t):\n        # Prefer a conflicting edge; else pick a random edge\n        cl = conflicts_list(pert)\n        conflict_edges = []\n        for u,v in edges:\n            if pert[u] == pert[v]:\n                conflict_edges.append((u,v))\n        if conflict_edges:\n            u,v = random.choice(conflict_edges)\n        else:\n            u,v = random.choice(edges)\n        ca, cb = pert[u], pert[v]\n        if ca == cb:\n            # pick a different color from palette for v to define a Kempe pair\n            alt = [c for c in palette if c != ca]\n            if not alt:\n                continue\n            cb = random.choice(alt)\n        # Build Kempe-chain component reachable from u using only colors ca and cb\n        stack = [u]\n        seen = set([u])\n        use_colors = {ca, cb}\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in seen and pert[y] in use_colors:\n                    if (pert[x] == ca and pert[y] == cb) or (pert[x] == cb and pert[y] == ca) or (pert[x] == pert[y]):\n                        seen.add(y)\n                        stack.append(y)\n        # Swap colors on this component\n        for x in seen:\n            if pert[x] == ca:\n                pert[x] = cb\n            elif pert[x] == cb:\n                pert[x] = ca\n        # Occasionally perform a random class swap for diversification\n        if random.random() < 0.2 and len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            pert = [b if x == a else (a if x == b else x) for x in pert]\n        palette = sorted(set(pert))\n\n    return pert\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001104543}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9; solution[i] is a positive int color (>=1) assigned to node i+1 for i in 0..8.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Problem data (0-based indices)\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Primary: minimize conflicts; Secondary: minimize number of colors\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        # Degree ordering greedy coloring\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    current = list(solution) if valid_rep(solution) else greedy_init()\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def count_conflicts(sol):\n        return sum(1 for (u,v) in edges if sol[u] == sol[v])\n\n    def compact_palette(sol):\n        # Map existing colors to 1..k in consistent order\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    current = compact_palette(current)\n    palette = sorted(set(current))\n\n    # Identify conflict status\n    conflicts = count_conflicts(current)\n\n    # If conflict-free, try color elimination move\n    if conflicts == 0:\n        # Pick a color class to try to eliminate (prefer rarest)\n        counts = {c:0 for c in palette}\n        for x in current:\n            counts[x] += 1\n        removable_colors = sorted(palette, key=lambda c: (counts[c], c))\n        for c_remove in removable_colors:\n            neighbor = list(current)\n            ok = True\n            for v in [i for i,x in enumerate(neighbor) if x == c_remove]:\n                # Try assign the least conflicting color among remaining palette\n                best_c = None\n                best_conf = 10**9\n                for c in palette:\n                    if c == c_remove:\n                        continue\n                    local = sum(1 for u in adj[v] if neighbor[u] == c)\n                    if local < best_conf:\n                        best_conf = local\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                neighbor[v] = best_c if best_c is not None else neighbor[v]\n                # If assignment created conflict at v, fail this elimination\n                if any(neighbor[v] == neighbor[u] for u in adj[v]):\n                    ok = False\n                    break\n            if ok:\n                # Drop color and compact\n                neighbor = [x for x in neighbor]\n                neighbor = compact_palette(neighbor)\n                move = {\"type\":\"color-elim\",\"removed\":int(c_remove)}\n                return neighbor, move\n        # If elimination failed, perform a Kempe-chain swap for diversification\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            # BFS component containing a random vertex of color a or b\n            cand = [i for i,x in enumerate(current) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                comp = set([start])\n                stack = [start]\n                allowed = {a,b}\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and current[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                neighbor = list(current)\n                for x in comp:\n                    neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n                return compact_palette(neighbor), {\"type\":\"kempe\",\"colors\":[int(a),int(b)]}\n        # Fallback: swap two colors globally\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            neighbor = [b if x == a else (a if x == b else x) for x in current]\n            return compact_palette(neighbor), {\"type\":\"swap-colors\",\"a\":int(a),\"b\":int(b)}\n        return current, {\"type\":\"noop\"}\n\n    # If conflicts exist, try repairing recolor first\n    # Select a target vertex by max conflict then saturation degree\n    def saturation(sol, i):\n        return len({sol[j] for j in adj[i]})\n\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), saturation(current, i), len(adj[i]), random.random()))\n    else:\n        target = random.randrange(n)\n\n    best_color = current[target]\n    best_local = node_conflicts(current, target)\n    for color in palette:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        if local < best_local or (local == best_local and color < best_color):\n            best_local = local\n            best_color = color\n\n    neighbor = list(current)\n    if best_color == current[target]:\n        # Allow introducing a new color if no existing color reduces conflicts\n        new_color = max(palette) + 1\n        neighbor[target] = new_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"new-color\",\"v\":int(target),\"old\":int(current[target]),\"new\":int(max(palette)+1)}\n    else:\n        neighbor[target] = best_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"recolor\",\"v\":int(target),\"old\":int(current[target]),\"new\":int(best_color)}\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    base = list(solution) if valid_rep(solution) else greedy_init()\n    base = compact_palette(base)\n\n    pert = list(base)\n    palette = sorted(set(pert))\n\n    # Apply a few Kempe-chain swaps and random recolors\n    rounds = random.randint(2, 3)\n    for _ in range(rounds):\n        palette = sorted(set(pert))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            # Pick a start vertex from {a,b}\n            cand = [i for i,x in enumerate(pert) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                comp = set([start])\n                stack = [start]\n                allowed = {a,b}\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and pert[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                for x in comp:\n                    pert[x] = a if pert[x] == b else (b if pert[x] == a else pert[x])\n        # With small prob, recolor a high-conflict vertex (may introduce new color)\n        if random.random() < 0.4:\n            # Compute conflicts per node\n            def node_conflicts(sol, i):\n                c = sol[i]\n                return sum(1 for j in adj[i] if sol[j] == c)\n            conflicts = [node_conflicts(pert, i) for i in range(n)]\n            target = max(range(n), key=lambda i: (conflicts[i], len(adj[i]), random.random()))\n            pal = sorted(set(pert))\n            best_c = pert[target]\n            best_local = conflicts[target]\n            for c in pal:\n                if c == pert[target]:\n                    continue\n                local = sum(1 for j in adj[target] if pert[j] == c)\n                if local < best_local:\n                    best_local = local\n                    best_c = c\n            if best_c == pert[target]:\n                best_c = max(pal) + 1\n            pert[target] = best_c\n    return compact_palette(pert)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001605508}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9; solution[i] is a positive int color (>=1) assigned to node i+1 for i in 0..8.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Problem data (0-based indices)\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Primary: minimize conflicts; Secondary: minimize number of colors\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        # Degree ordering greedy coloring\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    current = list(solution) if valid_rep(solution) else greedy_init()\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def count_conflicts(sol):\n        return sum(1 for (u,v) in edges if sol[u] == sol[v])\n\n    def compact_palette(sol):\n        # Map existing colors to 1..k in consistent order\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    current = compact_palette(current)\n    palette = sorted(set(current))\n\n    # Identify conflict status\n    conflicts = count_conflicts(current)\n\n    # If conflict-free, try color elimination move\n    if conflicts == 0:\n        # Pick a color class to try to eliminate (prefer rarest)\n        counts = {c:0 for c in palette}\n        for x in current:\n            counts[x] += 1\n        removable_colors = sorted(palette, key=lambda c: (counts[c], c))\n        for c_remove in removable_colors:\n            neighbor = list(current)\n            ok = True\n            for v in [i for i,x in enumerate(neighbor) if x == c_remove]:\n                # Try assign the least conflicting color among remaining palette\n                best_c = None\n                best_conf = 10**9\n                for c in palette:\n                    if c == c_remove:\n                        continue\n                    local = sum(1 for u in adj[v] if neighbor[u] == c)\n                    if local < best_conf:\n                        best_conf = local\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                neighbor[v] = best_c if best_c is not None else neighbor[v]\n                # If assignment created conflict at v, fail this elimination\n                if any(neighbor[v] == neighbor[u] for u in adj[v]):\n                    ok = False\n                    break\n            if ok:\n                # Drop color and compact\n                neighbor = [x for x in neighbor]\n                neighbor = compact_palette(neighbor)\n                move = {\"type\":\"color-elim\",\"removed\":int(c_remove)}\n                return neighbor, move\n        # If elimination failed, perform a Kempe-chain swap for diversification\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            # BFS component containing a random vertex of color a or b\n            cand = [i for i,x in enumerate(current) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                comp = set([start])\n                stack = [start]\n                allowed = {a,b}\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and current[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                neighbor = list(current)\n                for x in comp:\n                    neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n                return compact_palette(neighbor), {\"type\":\"kempe\",\"colors\":[int(a),int(b)]}\n        # Fallback: swap two colors globally\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            neighbor = [b if x == a else (a if x == b else x) for x in current]\n            return compact_palette(neighbor), {\"type\":\"swap-colors\",\"a\":int(a),\"b\":int(b)}\n        return current, {\"type\":\"noop\"}\n\n    # If conflicts exist, try repairing recolor first\n    # Select a target vertex by max conflict then saturation degree\n    def saturation(sol, i):\n        return len({sol[j] for j in adj[i]})\n\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), saturation(current, i), len(adj[i]), random.random()))\n    else:\n        target = random.randrange(n)\n\n    best_color = current[target]\n    best_local = node_conflicts(current, target)\n    for color in palette:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        if local < best_local or (local == best_local and color < best_color):\n            best_local = local\n            best_color = color\n\n    neighbor = list(current)\n    if best_color == current[target]:\n        # Allow introducing a new color if no existing color reduces conflicts\n        new_color = max(palette) + 1\n        neighbor[target] = new_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"new-color\",\"v\":int(target),\"old\":int(current[target]),\"new\":int(max(palette)+1)}\n    else:\n        neighbor[target] = best_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"recolor\",\"v\":int(target),\"old\":int(current[target]),\"new\":int(best_color)}\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    base = list(solution) if valid_rep(solution) else greedy_init()\n    base = compact_palette(base)\n\n    pert = list(base)\n    palette = sorted(set(pert))\n\n    # Apply a few Kempe-chain swaps and random recolors\n    rounds = random.randint(2, 3)\n    for _ in range(rounds):\n        palette = sorted(set(pert))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            # Pick a start vertex from {a,b}\n            cand = [i for i,x in enumerate(pert) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                comp = set([start])\n                stack = [start]\n                allowed = {a,b}\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and pert[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                for x in comp:\n                    pert[x] = a if pert[x] == b else (b if pert[x] == a else pert[x])\n        # With small prob, recolor a high-conflict vertex (may introduce new color)\n        if random.random() < 0.4:\n            # Compute conflicts per node\n            def node_conflicts(sol, i):\n                c = sol[i]\n                return sum(1 for j in adj[i] if sol[j] == c)\n            conflicts = [node_conflicts(pert, i) for i in range(n)]\n            target = max(range(n), key=lambda i: (conflicts[i], len(adj[i]), random.random()))\n            pal = sorted(set(pert))\n            best_c = pert[target]\n            best_local = conflicts[target]\n            for c in pal:\n                if c == pert[target]:\n                    continue\n                local = sum(1 for j in adj[target] if pert[j] == c)\n                if local < best_local:\n                    best_local = local\n                    best_c = c\n            if best_c == pert[target]:\n                best_c = max(pal) + 1\n            pert[target] = best_c\n    return compact_palette(pert)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001912653}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9; solution[i] is a positive int color (>=1) assigned to node i+1 for i in 0..8.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Problem data (0-based indices)\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Primary: minimize conflicts; Secondary: minimize number of colors\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        # Degree ordering greedy coloring\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    current = list(solution) if valid_rep(solution) else greedy_init()\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def count_conflicts(sol):\n        return sum(1 for (u,v) in edges if sol[u] == sol[v])\n\n    def compact_palette(sol):\n        # Map existing colors to 1..k in consistent order\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    current = compact_palette(current)\n    palette = sorted(set(current))\n\n    # Identify conflict status\n    conflicts = count_conflicts(current)\n\n    # If conflict-free, try color elimination move\n    if conflicts == 0:\n        # Pick a color class to try to eliminate (prefer rarest)\n        counts = {c:0 for c in palette}\n        for x in current:\n            counts[x] += 1\n        removable_colors = sorted(palette, key=lambda c: (counts[c], c))\n        for c_remove in removable_colors:\n            neighbor = list(current)\n            ok = True\n            for v in [i for i,x in enumerate(neighbor) if x == c_remove]:\n                # Try assign the least conflicting color among remaining palette\n                best_c = None\n                best_conf = 10**9\n                for c in palette:\n                    if c == c_remove:\n                        continue\n                    local = sum(1 for u in adj[v] if neighbor[u] == c)\n                    if local < best_conf:\n                        best_conf = local\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                neighbor[v] = best_c if best_c is not None else neighbor[v]\n                # If assignment created conflict at v, fail this elimination\n                if any(neighbor[v] == neighbor[u] for u in adj[v]):\n                    ok = False\n                    break\n            if ok:\n                # Drop color and compact\n                neighbor = [x for x in neighbor]\n                neighbor = compact_palette(neighbor)\n                move = {\"type\":\"color-elim\",\"removed\":int(c_remove)}\n                return neighbor, move\n        # If elimination failed, perform a Kempe-chain swap for diversification\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            # BFS component containing a random vertex of color a or b\n            cand = [i for i,x in enumerate(current) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                comp = set([start])\n                stack = [start]\n                allowed = {a,b}\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and current[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                neighbor = list(current)\n                for x in comp:\n                    neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n                return compact_palette(neighbor), {\"type\":\"kempe\",\"colors\":[int(a),int(b)]}\n        # Fallback: swap two colors globally\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            neighbor = [b if x == a else (a if x == b else x) for x in current]\n            return compact_palette(neighbor), {\"type\":\"swap-colors\",\"a\":int(a),\"b\":int(b)}\n        return current, {\"type\":\"noop\"}\n\n    # If conflicts exist, try repairing recolor first\n    # Select a target vertex by max conflict then saturation degree\n    def saturation(sol, i):\n        return len({sol[j] for j in adj[i]})\n\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), saturation(current, i), len(adj[i]), random.random()))\n    else:\n        target = random.randrange(n)\n\n    best_color = current[target]\n    best_local = node_conflicts(current, target)\n    for color in palette:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        if local < best_local or (local == best_local and color < best_color):\n            best_local = local\n            best_color = color\n\n    neighbor = list(current)\n    if best_color == current[target]:\n        # Allow introducing a new color if no existing color reduces conflicts\n        new_color = max(palette) + 1\n        neighbor[target] = new_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"new-color\",\"v\":int(target),\"old\":int(current[target]),\"new\":int(max(palette)+1)}\n    else:\n        neighbor[target] = best_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"recolor\",\"v\":int(target),\"old\":int(current[target]),\"new\":int(best_color)}\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    base = list(solution) if valid_rep(solution) else greedy_init()\n    base = compact_palette(base)\n\n    pert = list(base)\n    palette = sorted(set(pert))\n\n    # Apply a few Kempe-chain swaps and random recolors\n    rounds = random.randint(2, 3)\n    for _ in range(rounds):\n        palette = sorted(set(pert))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            # Pick a start vertex from {a,b}\n            cand = [i for i,x in enumerate(pert) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                comp = set([start])\n                stack = [start]\n                allowed = {a,b}\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and pert[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                for x in comp:\n                    pert[x] = a if pert[x] == b else (b if pert[x] == a else pert[x])\n        # With small prob, recolor a high-conflict vertex (may introduce new color)\n        if random.random() < 0.4:\n            # Compute conflicts per node\n            def node_conflicts(sol, i):\n                c = sol[i]\n                return sum(1 for j in adj[i] if sol[j] == c)\n            conflicts = [node_conflicts(pert, i) for i in range(n)]\n            target = max(range(n), key=lambda i: (conflicts[i], len(adj[i]), random.random()))\n            pal = sorted(set(pert))\n            best_c = pert[target]\n            best_local = conflicts[target]\n            for c in pal:\n                if c == pert[target]:\n                    continue\n                local = sum(1 for j in adj[target] if pert[j] == c)\n                if local < best_local:\n                    best_local = local\n                    best_c = c\n            if best_c == pert[target]:\n                best_c = max(pal) + 1\n            pert[target] = best_c\n    return compact_palette(pert)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.002170325}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9 where index i (0-based) corresponds to node i+1 and value >=1 is the color assigned.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Problem data (0-based indices)\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Primary: minimize conflicts; Secondary: minimize number of colors\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def count_conflicts(sol):\n        return sum(1 for (u,v) in edges if sol[u] == sol[v])\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    current = list(solution) if valid_rep(solution) else greedy_init()\n    current = compact_palette(current)\n    palette = sorted(set(current))\n\n    conflicts = count_conflicts(current)\n\n    if conflicts == 0:\n        # Attempt color elimination: try removing the rarest color\n        counts = {c:0 for c in palette}\n        for x in current:\n            counts[x] += 1\n        for c_remove in sorted(palette, key=lambda c: (counts[c], c)):\n            cls = [i for i,x in enumerate(current) if x == c_remove]\n            neighbor = list(current)\n            ok = True\n            for v in cls:\n                # choose color that causes no conflict if possible, else minimum local conflicts\n                best_c = None\n                best_conf = 10**9\n                for c in palette:\n                    if c == c_remove:\n                        continue\n                    local = sum(1 for u in adj[v] if neighbor[u] == c)\n                    if local < best_conf:\n                        best_conf = local\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                if best_c is None:\n                    ok = False\n                    break\n                neighbor[v] = best_c\n                if any(neighbor[v] == neighbor[u] for u in adj[v]):\n                    ok = False\n                    break\n            if ok:\n                neighbor = compact_palette(neighbor)\n                return neighbor, {\"type\":\"color-elim\",\"removed\":int(c_remove)}\n        # Diversification via Kempe-chain swap on two random colors within one induced component\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            cand = [i for i,x in enumerate(current) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                allowed = {a, b}\n                comp = set([start])\n                stack = [start]\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and current[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                neighbor = list(current)\n                for x in comp:\n                    neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n                neighbor = compact_palette(neighbor)\n                return neighbor, {\"type\":\"kempe\",\"colors\":[int(a),int(b)],\"size\":len(comp)}\n        # Fallback: swap two color labels globally\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            neighbor = [b if x == a else (a if x == b else x) for x in current]\n            neighbor = compact_palette(neighbor)\n            return neighbor, {\"type\":\"swap-colors\",\"a\":int(a),\"b\":int(b)}\n        return current, {\"type\":\"noop\"}\n\n    # Conflicted state: repair by recoloring a high-conflict vertex with DSATUR tie-breaks\n    def saturation(sol, i):\n        return len({sol[j] for j in adj[i]})\n\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), saturation(current, i), len(adj[i]), random.random()))\n    else:\n        target = random.randrange(n)\n\n    # Try recoloring target to existing palette minimizing local conflicts; break ties randomly\n    pal = sorted(set(current))\n    costs = []\n    for color in pal:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        costs.append((local, color))\n    if costs:\n        min_local = min(c for c,_ in costs)\n        candidates = [c for l,c in costs if l == min_local]\n        best_color = random.choice(candidates)\n        neighbor = list(current)\n        neighbor[target] = best_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"recolor\",\"v\":int(target),\"new\":int(best_color)}\n\n    # If no alternative colors, attempt Kempe swap with a neighbor color of target\n    neigh_colors = list({current[j] for j in adj[target]})\n    if neigh_colors:\n        a = current[target]\n        b = random.choice(neigh_colors)\n        allowed = {a, b}\n        # build (a,b)-induced component containing target\n        comp = set([target])\n        stack = [target]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in comp and current[y] in allowed:\n                    comp.add(y)\n                    stack.append(y)\n        neighbor = list(current)\n        for x in comp:\n            neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"kempe-local\",\"a\":int(a),\"b\":int(b),\"size\":len(comp)}\n\n    # Last resort: no-op\n    return current, {\"type\":\"noop\"}\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    state = list(solution) if valid_rep(solution) else greedy_init()\n    state = compact_palette(state)\n\n    pal = sorted(set(state))\n    rounds = random.randint(2, 4)\n    for _ in range(rounds):\n        pal = sorted(set(state))\n        if len(pal) >= 2:\n            a, b = random.sample(pal, 2)\n            # pick random start among vertices colored a or b\n            cand = [i for i,x in enumerate(state) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                allowed = {a, b}\n                comp = set([start])\n                stack = [start]\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and state[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                for x in comp:\n                    state[x] = a if state[x] == b else (b if state[x] == a else state[x])\n        # With small probability, swap two random color labels globally for diversification\n        if random.random() < 0.35 and len(pal) >= 2:\n            a, b = random.sample(pal, 2)\n            state = [b if x == a else (a if x == b else x) for x in state]\n    return compact_palette(state)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001580439}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9 where index i (0-based) corresponds to node i+1 and value >=1 is the color assigned.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Problem data (0-based indices)\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Primary: minimize conflicts; Secondary: minimize number of colors\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def count_conflicts(sol):\n        return sum(1 for (u,v) in edges if sol[u] == sol[v])\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    current = list(solution) if valid_rep(solution) else greedy_init()\n    current = compact_palette(current)\n    palette = sorted(set(current))\n\n    conflicts = count_conflicts(current)\n\n    if conflicts == 0:\n        # Attempt color elimination: try removing the rarest color\n        counts = {c:0 for c in palette}\n        for x in current:\n            counts[x] += 1\n        for c_remove in sorted(palette, key=lambda c: (counts[c], c)):\n            cls = [i for i,x in enumerate(current) if x == c_remove]\n            neighbor = list(current)\n            ok = True\n            for v in cls:\n                # choose color that causes no conflict if possible, else minimum local conflicts\n                best_c = None\n                best_conf = 10**9\n                for c in palette:\n                    if c == c_remove:\n                        continue\n                    local = sum(1 for u in adj[v] if neighbor[u] == c)\n                    if local < best_conf:\n                        best_conf = local\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                if best_c is None:\n                    ok = False\n                    break\n                neighbor[v] = best_c\n                if any(neighbor[v] == neighbor[u] for u in adj[v]):\n                    ok = False\n                    break\n            if ok:\n                neighbor = compact_palette(neighbor)\n                return neighbor, {\"type\":\"color-elim\",\"removed\":int(c_remove)}\n        # Diversification via Kempe-chain swap on two random colors within one induced component\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            cand = [i for i,x in enumerate(current) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                allowed = {a, b}\n                comp = set([start])\n                stack = [start]\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and current[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                neighbor = list(current)\n                for x in comp:\n                    neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n                neighbor = compact_palette(neighbor)\n                return neighbor, {\"type\":\"kempe\",\"colors\":[int(a),int(b)],\"size\":len(comp)}\n        # Fallback: swap two color labels globally\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            neighbor = [b if x == a else (a if x == b else x) for x in current]\n            neighbor = compact_palette(neighbor)\n            return neighbor, {\"type\":\"swap-colors\",\"a\":int(a),\"b\":int(b)}\n        return current, {\"type\":\"noop\"}\n\n    # Conflicted state: repair by recoloring a high-conflict vertex with DSATUR tie-breaks\n    def saturation(sol, i):\n        return len({sol[j] for j in adj[i]})\n\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), saturation(current, i), len(adj[i]), random.random()))\n    else:\n        target = random.randrange(n)\n\n    # Try recoloring target to existing palette minimizing local conflicts; break ties randomly\n    pal = sorted(set(current))\n    costs = []\n    for color in pal:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        costs.append((local, color))\n    if costs:\n        min_local = min(c for c,_ in costs)\n        candidates = [c for l,c in costs if l == min_local]\n        best_color = random.choice(candidates)\n        neighbor = list(current)\n        neighbor[target] = best_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"recolor\",\"v\":int(target),\"new\":int(best_color)}\n\n    # If no alternative colors, attempt Kempe swap with a neighbor color of target\n    neigh_colors = list({current[j] for j in adj[target]})\n    if neigh_colors:\n        a = current[target]\n        b = random.choice(neigh_colors)\n        allowed = {a, b}\n        # build (a,b)-induced component containing target\n        comp = set([target])\n        stack = [target]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in comp and current[y] in allowed:\n                    comp.add(y)\n                    stack.append(y)\n        neighbor = list(current)\n        for x in comp:\n            neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"kempe-local\",\"a\":int(a),\"b\":int(b),\"size\":len(comp)}\n\n    # Last resort: no-op\n    return current, {\"type\":\"noop\"}\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    state = list(solution) if valid_rep(solution) else greedy_init()\n    state = compact_palette(state)\n\n    pal = sorted(set(state))\n    rounds = random.randint(2, 4)\n    for _ in range(rounds):\n        pal = sorted(set(state))\n        if len(pal) >= 2:\n            a, b = random.sample(pal, 2)\n            # pick random start among vertices colored a or b\n            cand = [i for i,x in enumerate(state) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                allowed = {a, b}\n                comp = set([start])\n                stack = [start]\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and state[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                for x in comp:\n                    state[x] = a if state[x] == b else (b if state[x] == a else state[x])\n        # With small probability, swap two random color labels globally for diversification\n        if random.random() < 0.35 and len(pal) >= 2:\n            a, b = random.sample(pal, 2)\n            state = [b if x == a else (a if x == b else x) for x in state]\n    return compact_palette(state)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00173055}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_textbook_standard","Representacion":"List[int] of length 9 where index i (0-based) corresponds to node i+1 and value >=1 is the color assigned.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate representation: list of 9 positive integers\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**12\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n    # Problem data (0-based indices)\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Primary: minimize conflicts; Secondary: minimize number of colors\n    num_colors = len(set(solution))\n    return conflicts * 10000 + num_colors\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def count_conflicts(sol):\n        return sum(1 for (u,v) in edges if sol[u] == sol[v])\n\n    def node_conflicts(sol, i):\n        c = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == c)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    current = list(solution) if valid_rep(solution) else greedy_init()\n    current = compact_palette(current)\n    palette = sorted(set(current))\n\n    conflicts = count_conflicts(current)\n\n    if conflicts == 0:\n        # Attempt color elimination: try removing the rarest color\n        counts = {c:0 for c in palette}\n        for x in current:\n            counts[x] += 1\n        for c_remove in sorted(palette, key=lambda c: (counts[c], c)):\n            cls = [i for i,x in enumerate(current) if x == c_remove]\n            neighbor = list(current)\n            ok = True\n            for v in cls:\n                # choose color that causes no conflict if possible, else minimum local conflicts\n                best_c = None\n                best_conf = 10**9\n                for c in palette:\n                    if c == c_remove:\n                        continue\n                    local = sum(1 for u in adj[v] if neighbor[u] == c)\n                    if local < best_conf:\n                        best_conf = local\n                        best_c = c\n                        if best_conf == 0:\n                            break\n                if best_c is None:\n                    ok = False\n                    break\n                neighbor[v] = best_c\n                if any(neighbor[v] == neighbor[u] for u in adj[v]):\n                    ok = False\n                    break\n            if ok:\n                neighbor = compact_palette(neighbor)\n                return neighbor, {\"type\":\"color-elim\",\"removed\":int(c_remove)}\n        # Diversification via Kempe-chain swap on two random colors within one induced component\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            cand = [i for i,x in enumerate(current) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                allowed = {a, b}\n                comp = set([start])\n                stack = [start]\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and current[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                neighbor = list(current)\n                for x in comp:\n                    neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n                neighbor = compact_palette(neighbor)\n                return neighbor, {\"type\":\"kempe\",\"colors\":[int(a),int(b)],\"size\":len(comp)}\n        # Fallback: swap two color labels globally\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            neighbor = [b if x == a else (a if x == b else x) for x in current]\n            neighbor = compact_palette(neighbor)\n            return neighbor, {\"type\":\"swap-colors\",\"a\":int(a),\"b\":int(b)}\n        return current, {\"type\":\"noop\"}\n\n    # Conflicted state: repair by recoloring a high-conflict vertex with DSATUR tie-breaks\n    def saturation(sol, i):\n        return len({sol[j] for j in adj[i]})\n\n    conflict_nodes = [i for i in range(n) if node_conflicts(current, i) > 0]\n    if conflict_nodes:\n        target = max(conflict_nodes, key=lambda i: (node_conflicts(current, i), saturation(current, i), len(adj[i]), random.random()))\n    else:\n        target = random.randrange(n)\n\n    # Try recoloring target to existing palette minimizing local conflicts; break ties randomly\n    pal = sorted(set(current))\n    costs = []\n    for color in pal:\n        if color == current[target]:\n            continue\n        local = sum(1 for j in adj[target] if current[j] == color)\n        costs.append((local, color))\n    if costs:\n        min_local = min(c for c,_ in costs)\n        candidates = [c for l,c in costs if l == min_local]\n        best_color = random.choice(candidates)\n        neighbor = list(current)\n        neighbor[target] = best_color\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"recolor\",\"v\":int(target),\"new\":int(best_color)}\n\n    # If no alternative colors, attempt Kempe swap with a neighbor color of target\n    neigh_colors = list({current[j] for j in adj[target]})\n    if neigh_colors:\n        a = current[target]\n        b = random.choice(neigh_colors)\n        allowed = {a, b}\n        # build (a,b)-induced component containing target\n        comp = set([target])\n        stack = [target]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in comp and current[y] in allowed:\n                    comp.add(y)\n                    stack.append(y)\n        neighbor = list(current)\n        for x in comp:\n            neighbor[x] = a if current[x] == b else (b if current[x] == a else current[x])\n        neighbor = compact_palette(neighbor)\n        return neighbor, {\"type\":\"kempe-local\",\"a\":int(a),\"b\":int(b),\"size\":len(comp)}\n\n    # Last resort: no-op\n    return current, {\"type\":\"noop\"}\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Build adjacency (0-based)\n    n = 9\n    edges = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),(7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_rep(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def greedy_init():\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        colors = [0]*n\n        for i in order:\n            used = {colors[j] for j in adj[i] if colors[j] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[i] = c\n        return colors\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c:i+1 for i,c in enumerate(palette)}\n        return [remap[x] for x in sol]\n\n    state = list(solution) if valid_rep(solution) else greedy_init()\n    state = compact_palette(state)\n\n    pal = sorted(set(state))\n    rounds = random.randint(2, 4)\n    for _ in range(rounds):\n        pal = sorted(set(state))\n        if len(pal) >= 2:\n            a, b = random.sample(pal, 2)\n            # pick random start among vertices colored a or b\n            cand = [i for i,x in enumerate(state) if x in (a,b)]\n            if cand:\n                start = random.choice(cand)\n                allowed = {a, b}\n                comp = set([start])\n                stack = [start]\n                while stack:\n                    x = stack.pop()\n                    for y in adj[x]:\n                        if y not in comp and state[y] in allowed:\n                            comp.add(y)\n                            stack.append(y)\n                for x in comp:\n                    state[x] = a if state[x] == b else (b if state[x] == a else state[x])\n        # With small probability, swap two random color labels globally for diversification\n        if random.random() < 0.35 and len(pal) >= 2:\n            a, b = random.sample(pal, 2)\n            state = [b if x == a else (a if x == b else x) for x in state]\n    return compact_palette(state)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001562278}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_1..k_CONTIGUOUS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate and score coloring: lower is better; invalid solutions get large penalties\n    # Instance definition (embedded)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int):\n            return 10**6\n\n    # Compute k and domain checks\n    k = 0\n    for c in solution:\n        if c < 1:\n            return 10**6\n        if c > k:\n            k = c\n    if k == 0:\n        return 10**6\n\n    # Enforce contiguous labels 1..k (symmetry-breaking and consistency)\n    seen = [False]*(k+1)\n    for c in solution:\n        if c <= k:\n            seen[c] = True\n    for label in range(1, k+1):\n        if not seen[label]:\n            return 10**6  # missing a label in 1..k\n\n    # Adjacency constraints x_u != x_v\n    penalty = 0\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            penalty += 1\n    if penalty > 0:\n        return 10**6 + penalty\n\n    # Valid coloring: score equals k (minimize number of colors)\n    return k\n","Vecindad":"import random\nimport copy\n\n# Neighbor generator returns (new_solution, NB_Type, Movement_Type)\n# Signature line must match specification\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal copy to avoid mutating input\n    if not isinstance(solution, list) or len(solution) == 0:\n        return (solution, \"Identity\", \"InvalidInput\")\n    s = solution[:]\n\n    # Determine current k and available labels (allow introducing k+1 to escape local minima)\n    k = 0\n    for c in s:\n        if isinstance(c, int) and c > k:\n            k = c\n    if k <= 0:\n        k = 1\n\n    move_choice = random.random()\n\n    # Movement 1: single-vertex recolor to a different label in [1..max(k,3)+1]\n    if move_choice < 0.6:\n        idx = random.randrange(len(s))\n        # candidate labels include 1..max(k,3)+1 to explore adding\/removing colors\n        max_label = max(k, 3) + 1\n        new_label = s[idx]\n        # ensure a different label\n        attempts = 0\n        while new_label == s[idx] and attempts < 10:\n            new_label = random.randint(1, max_label)\n            attempts += 1\n        ns = s[:]\n        ns[idx] = new_label\n        return (ns, \"Recolor\", \"SingleVertex\")\n\n    # Movement 2: swap two color labels globally (palette swap)\n    elif move_choice < 0.85:\n        if k < 2:\n            # fallback to recolor if not enough labels\n            idx = random.randrange(len(s))\n            new_label = random.randint(1, max(2, k) + 1)\n            ns = s[:]\n            ns[idx] = new_label\n            return (ns, \"Recolor\", \"SingleVertexFallback\")\n        a = random.randint(1, k)\n        b = random.randint(1, k)\n        while b == a:\n            b = random.randint(1, k)\n        ns = [ (b if c==a else (a if c==b else c)) for c in s ]\n        return (ns, \"PaletteSwap\", \"GlobalSwap\")\n\n    # Movement 3: two-vertex transposition of labels\n    else:\n        i = random.randrange(len(s))\n        j = random.randrange(len(s))\n        while j == i:\n            j = random.randrange(len(s))\n        ns = s[:]\n        ns[i], ns[j] = ns[j], ns[i]\n        return (ns, \"Transposition\", \"TwoVertexSwap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolor of a subset and optional palette normalization\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n\n    s = solution[:]\n    n = len(s)\n\n    # Randomly recolor about 30%-50% vertices with labels from 1..max(k,3)\n    k = 0\n    for c in s:\n        if isinstance(c, int) and c > k:\n            k = c\n    base_max = max(k, 3)\n\n    m = max(1, int(0.4 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n    for idx in idxs:\n        s[idx] = random.randint(1, base_max)\n\n    # Optional relabel to make labels closer to contiguous 1..k (greedy compaction)\n    # Build mapping in order of first appearance\n    seen_map = {}\n    next_label = 1\n    for c in s:\n        if c not in seen_map:\n            seen_map[c] = next_label\n            next_label += 1\n    s = [seen_map[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000510306}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_1..k_CONTIGUOUS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate and score coloring: lower is better; invalid solutions get large penalties\n    # Instance definition (embedded)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int):\n            return 10**6\n\n    # Compute k and domain checks\n    k = 0\n    for c in solution:\n        if c < 1:\n            return 10**6\n        if c > k:\n            k = c\n    if k == 0:\n        return 10**6\n\n    # Enforce contiguous labels 1..k (symmetry-breaking and consistency)\n    seen = [False]*(k+1)\n    for c in solution:\n        if c <= k:\n            seen[c] = True\n    for label in range(1, k+1):\n        if not seen[label]:\n            return 10**6  # missing a label in 1..k\n\n    # Adjacency constraints x_u != x_v\n    penalty = 0\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            penalty += 1\n    if penalty > 0:\n        return 10**6 + penalty\n\n    # Valid coloring: score equals k (minimize number of colors)\n    return k\n","Vecindad":"import random\nimport copy\n\n# Neighbor generator returns (new_solution, NB_Type, Movement_Type)\n# Signature line must match specification\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal copy to avoid mutating input\n    if not isinstance(solution, list) or len(solution) == 0:\n        return (solution, \"Identity\", \"InvalidInput\")\n    s = solution[:]\n\n    # Determine current k and available labels (allow introducing k+1 to escape local minima)\n    k = 0\n    for c in s:\n        if isinstance(c, int) and c > k:\n            k = c\n    if k <= 0:\n        k = 1\n\n    move_choice = random.random()\n\n    # Movement 1: single-vertex recolor to a different label in [1..max(k,3)+1]\n    if move_choice < 0.6:\n        idx = random.randrange(len(s))\n        # candidate labels include 1..max(k,3)+1 to explore adding\/removing colors\n        max_label = max(k, 3) + 1\n        new_label = s[idx]\n        # ensure a different label\n        attempts = 0\n        while new_label == s[idx] and attempts < 10:\n            new_label = random.randint(1, max_label)\n            attempts += 1\n        ns = s[:]\n        ns[idx] = new_label\n        return (ns, \"Recolor\", \"SingleVertex\")\n\n    # Movement 2: swap two color labels globally (palette swap)\n    elif move_choice < 0.85:\n        if k < 2:\n            # fallback to recolor if not enough labels\n            idx = random.randrange(len(s))\n            new_label = random.randint(1, max(2, k) + 1)\n            ns = s[:]\n            ns[idx] = new_label\n            return (ns, \"Recolor\", \"SingleVertexFallback\")\n        a = random.randint(1, k)\n        b = random.randint(1, k)\n        while b == a:\n            b = random.randint(1, k)\n        ns = [ (b if c==a else (a if c==b else c)) for c in s ]\n        return (ns, \"PaletteSwap\", \"GlobalSwap\")\n\n    # Movement 3: two-vertex transposition of labels\n    else:\n        i = random.randrange(len(s))\n        j = random.randrange(len(s))\n        while j == i:\n            j = random.randrange(len(s))\n        ns = s[:]\n        ns[i], ns[j] = ns[j], ns[i]\n        return (ns, \"Transposition\", \"TwoVertexSwap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolor of a subset and optional palette normalization\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n\n    s = solution[:]\n    n = len(s)\n\n    # Randomly recolor about 30%-50% vertices with labels from 1..max(k,3)\n    k = 0\n    for c in s:\n        if isinstance(c, int) and c > k:\n            k = c\n    base_max = max(k, 3)\n\n    m = max(1, int(0.4 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n    for idx in idxs:\n        s[idx] = random.randint(1, base_max)\n\n    # Optional relabel to make labels closer to contiguous 1..k (greedy compaction)\n    # Build mapping in order of first appearance\n    seen_map = {}\n    next_label = 1\n    for c in s:\n        if c not in seen_map:\n            seen_map[c] = next_label\n            next_label += 1\n    s = [seen_map[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000549727}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_COLORS_1..k_CONTIGUOUS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate and score coloring: lower is better; invalid solutions get large penalties\n    # Instance definition (embedded)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int):\n            return 10**6\n\n    # Compute k and domain checks\n    k = 0\n    for c in solution:\n        if c < 1:\n            return 10**6\n        if c > k:\n            k = c\n    if k == 0:\n        return 10**6\n\n    # Enforce contiguous labels 1..k (symmetry-breaking and consistency)\n    seen = [False]*(k+1)\n    for c in solution:\n        if c <= k:\n            seen[c] = True\n    for label in range(1, k+1):\n        if not seen[label]:\n            return 10**6  # missing a label in 1..k\n\n    # Adjacency constraints x_u != x_v\n    penalty = 0\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            penalty += 1\n    if penalty > 0:\n        return 10**6 + penalty\n\n    # Valid coloring: score equals k (minimize number of colors)\n    return k\n","Vecindad":"import random\nimport copy\n\n# Neighbor generator returns (new_solution, NB_Type, Movement_Type)\n# Signature line must match specification\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal copy to avoid mutating input\n    if not isinstance(solution, list) or len(solution) == 0:\n        return (solution, \"Identity\", \"InvalidInput\")\n    s = solution[:]\n\n    # Determine current k and available labels (allow introducing k+1 to escape local minima)\n    k = 0\n    for c in s:\n        if isinstance(c, int) and c > k:\n            k = c\n    if k <= 0:\n        k = 1\n\n    move_choice = random.random()\n\n    # Movement 1: single-vertex recolor to a different label in [1..max(k,3)+1]\n    if move_choice < 0.6:\n        idx = random.randrange(len(s))\n        # candidate labels include 1..max(k,3)+1 to explore adding\/removing colors\n        max_label = max(k, 3) + 1\n        new_label = s[idx]\n        # ensure a different label\n        attempts = 0\n        while new_label == s[idx] and attempts < 10:\n            new_label = random.randint(1, max_label)\n            attempts += 1\n        ns = s[:]\n        ns[idx] = new_label\n        return (ns, \"Recolor\", \"SingleVertex\")\n\n    # Movement 2: swap two color labels globally (palette swap)\n    elif move_choice < 0.85:\n        if k < 2:\n            # fallback to recolor if not enough labels\n            idx = random.randrange(len(s))\n            new_label = random.randint(1, max(2, k) + 1)\n            ns = s[:]\n            ns[idx] = new_label\n            return (ns, \"Recolor\", \"SingleVertexFallback\")\n        a = random.randint(1, k)\n        b = random.randint(1, k)\n        while b == a:\n            b = random.randint(1, k)\n        ns = [ (b if c==a else (a if c==b else c)) for c in s ]\n        return (ns, \"PaletteSwap\", \"GlobalSwap\")\n\n    # Movement 3: two-vertex transposition of labels\n    else:\n        i = random.randrange(len(s))\n        j = random.randrange(len(s))\n        while j == i:\n            j = random.randrange(len(s))\n        ns = s[:]\n        ns[i], ns[j] = ns[j], ns[i]\n        return (ns, \"Transposition\", \"TwoVertexSwap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong perturbation: random recolor of a subset and optional palette normalization\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n\n    s = solution[:]\n    n = len(s)\n\n    # Randomly recolor about 30%-50% vertices with labels from 1..max(k,3)\n    k = 0\n    for c in s:\n        if isinstance(c, int) and c > k:\n            k = c\n    base_max = max(k, 3)\n\n    m = max(1, int(0.4 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n    for idx in idxs:\n        s[idx] = random.randint(1, base_max)\n\n    # Optional relabel to make labels closer to contiguous 1..k (greedy compaction)\n    # Build mapping in order of first appearance\n    seen_map = {}\n    next_label = 1\n    for c in s:\n        if c not in seen_map:\n            seen_map[c] = next_label\n            next_label += 1\n    s = [seen_map[c] for c in s]\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000530286}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_LABELS. Solution is a Python list of 9 positive integers [c1,...,c9], where labels are normalized to contiguous 1..k (k = max label).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Helper: neighbors list\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (primary)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        # Try labels in 1..max(k,3)+1; pick one minimizing local conflicts\n        max_label = max(k, 3) + 1\n        best_labels = []\n        best_score = None\n        for lbl in range(1, max_label+1):\n            if lbl == current:\n                continue\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        if not best_labels:\n            # deterministic fallback to different label\n            lbl = current % max_label + 1\n        else:\n            lbl = random.choice(best_labels)\n        ns = s[:]\n        ns[vtx] = lbl\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # No conflicts: attempt to reduce k by recoloring a vertex with highest label\n    max_label_vertices = [i for i,c in enumerate(s) if c == k]\n    random.shuffle(max_label_vertices)\n    reduced = False\n    ns = s[:]\n    for vtx in max_label_vertices:\n        # try to assign a lower label that doesn't create conflict\n        candidates = list(range(1, k))\n        random.shuffle(candidates)\n        for lbl in candidates:\n            ok = True\n            for nb in adj[vtx]:\n                if ns[nb] == lbl:\n                    ok = False\n                    break\n            if ok:\n                ns[vtx] = lbl\n                reduced = True\n                break\n        if reduced:\n            break\n    if reduced:\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ReduceK\"))\n\n    # Palette swap between two existing labels to diversify\n    labels = list(range(1, k+1))\n    if k >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        ns = [ (b if c==a else (a if c==b else c)) for c in s ]\n        ns = canonicalize(ns)\n        if ns != s:\n            return (ns, (\"PaletteSwap\", \"GlobalSwap\"))\n\n    # Fallback: random recolor of a random vertex to a different label\n    idx = random.randrange(n)\n    current = s[idx]\n    max_label = max(k, 3) + 1\n    lbl = current\n    for _ in range(10):\n        lbl = random.randint(1, max_label)\n        if lbl != current:\n            break\n    if lbl == current:\n        lbl = current % max_label + 1\n    ns = s[:]\n    ns[idx] = lbl\n    ns = canonicalize(ns)\n    return (ns, (\"Recolor\", \"RandomFallback\"))","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance (for adjacency and conflicts focus)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n    base_max = max(k, 3)\n\n    # Intensity: perturb ~40% of vertices, prioritizing conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    candidates = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(candidates)\n    sel = candidates[:m_cnt]\n\n    ps = s[:]\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(10):\n            t = random.randint(1, base_max)\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            new_lbl = (ps[idx] % base_max) + 1\n        ps[idx] = new_lbl\n\n    # One palette swap to diversify\n    labels = list(range(1, max(ps)+1))\n    if len(labels) >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        ps = [ (b if c==a else (a if c==b else c)) for c in ps ]\n\n    ps = canonicalize(ps)\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        ps[idx] = (ps[idx] % base_max) + 1\n        ps = canonicalize(ps)\n\n    return ps","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00087354}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_LABELS. Solution is a Python list of 9 positive integers [c1,...,c9], where labels are normalized to contiguous 1..k (k = max label).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Helper: neighbors list\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (primary)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        # Try labels in 1..max(k,3)+1; pick one minimizing local conflicts\n        max_label = max(k, 3) + 1\n        best_labels = []\n        best_score = None\n        for lbl in range(1, max_label+1):\n            if lbl == current:\n                continue\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        if not best_labels:\n            # deterministic fallback to different label\n            lbl = current % max_label + 1\n        else:\n            lbl = random.choice(best_labels)\n        ns = s[:]\n        ns[vtx] = lbl\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # No conflicts: attempt to reduce k by recoloring a vertex with highest label\n    max_label_vertices = [i for i,c in enumerate(s) if c == k]\n    random.shuffle(max_label_vertices)\n    reduced = False\n    ns = s[:]\n    for vtx in max_label_vertices:\n        # try to assign a lower label that doesn't create conflict\n        candidates = list(range(1, k))\n        random.shuffle(candidates)\n        for lbl in candidates:\n            ok = True\n            for nb in adj[vtx]:\n                if ns[nb] == lbl:\n                    ok = False\n                    break\n            if ok:\n                ns[vtx] = lbl\n                reduced = True\n                break\n        if reduced:\n            break\n    if reduced:\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ReduceK\"))\n\n    # Palette swap between two existing labels to diversify\n    labels = list(range(1, k+1))\n    if k >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        ns = [ (b if c==a else (a if c==b else c)) for c in s ]\n        ns = canonicalize(ns)\n        if ns != s:\n            return (ns, (\"PaletteSwap\", \"GlobalSwap\"))\n\n    # Fallback: random recolor of a random vertex to a different label\n    idx = random.randrange(n)\n    current = s[idx]\n    max_label = max(k, 3) + 1\n    lbl = current\n    for _ in range(10):\n        lbl = random.randint(1, max_label)\n        if lbl != current:\n            break\n    if lbl == current:\n        lbl = current % max_label + 1\n    ns = s[:]\n    ns[idx] = lbl\n    ns = canonicalize(ns)\n    return (ns, (\"Recolor\", \"RandomFallback\"))","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance (for adjacency and conflicts focus)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n    base_max = max(k, 3)\n\n    # Intensity: perturb ~40% of vertices, prioritizing conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    candidates = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(candidates)\n    sel = candidates[:m_cnt]\n\n    ps = s[:]\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(10):\n            t = random.randint(1, base_max)\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            new_lbl = (ps[idx] % base_max) + 1\n        ps[idx] = new_lbl\n\n    # One palette swap to diversify\n    labels = list(range(1, max(ps)+1))\n    if len(labels) >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        ps = [ (b if c==a else (a if c==b else c)) for c in ps ]\n\n    ps = canonicalize(ps)\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        ps[idx] = (ps[idx] % base_max) + 1\n        ps = canonicalize(ps)\n\n    return ps","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001123393}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_LABELS. Solution is a Python list of 9 positive integers [c1,...,c9], where labels are normalized to contiguous 1..k (k = max label).","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Helper: neighbors list\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (primary)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        # Try labels in 1..max(k,3)+1; pick one minimizing local conflicts\n        max_label = max(k, 3) + 1\n        best_labels = []\n        best_score = None\n        for lbl in range(1, max_label+1):\n            if lbl == current:\n                continue\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        if not best_labels:\n            # deterministic fallback to different label\n            lbl = current % max_label + 1\n        else:\n            lbl = random.choice(best_labels)\n        ns = s[:]\n        ns[vtx] = lbl\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # No conflicts: attempt to reduce k by recoloring a vertex with highest label\n    max_label_vertices = [i for i,c in enumerate(s) if c == k]\n    random.shuffle(max_label_vertices)\n    reduced = False\n    ns = s[:]\n    for vtx in max_label_vertices:\n        # try to assign a lower label that doesn't create conflict\n        candidates = list(range(1, k))\n        random.shuffle(candidates)\n        for lbl in candidates:\n            ok = True\n            for nb in adj[vtx]:\n                if ns[nb] == lbl:\n                    ok = False\n                    break\n            if ok:\n                ns[vtx] = lbl\n                reduced = True\n                break\n        if reduced:\n            break\n    if reduced:\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ReduceK\"))\n\n    # Palette swap between two existing labels to diversify\n    labels = list(range(1, k+1))\n    if k >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        ns = [ (b if c==a else (a if c==b else c)) for c in s ]\n        ns = canonicalize(ns)\n        if ns != s:\n            return (ns, (\"PaletteSwap\", \"GlobalSwap\"))\n\n    # Fallback: random recolor of a random vertex to a different label\n    idx = random.randrange(n)\n    current = s[idx]\n    max_label = max(k, 3) + 1\n    lbl = current\n    for _ in range(10):\n        lbl = random.randint(1, max_label)\n        if lbl != current:\n            break\n    if lbl == current:\n        lbl = current % max_label + 1\n    ns = s[:]\n    ns[idx] = lbl\n    ns = canonicalize(ns)\n    return (ns, (\"Recolor\", \"RandomFallback\"))","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance (for adjacency and conflicts focus)\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n    base_max = max(k, 3)\n\n    # Intensity: perturb ~40% of vertices, prioritizing conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    candidates = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(candidates)\n    sel = candidates[:m_cnt]\n\n    ps = s[:]\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(10):\n            t = random.randint(1, base_max)\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            new_lbl = (ps[idx] % base_max) + 1\n        ps[idx] = new_lbl\n\n    # One palette swap to diversify\n    labels = list(range(1, max(ps)+1))\n    if len(labels) >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        ps = [ (b if c==a else (a if c==b else c)) for c in ps ]\n\n    ps = canonicalize(ps)\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        ps[idx] = (ps[idx] % base_max) + 1\n        ps = canonicalize(ps)\n\n    return ps","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001051663}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_LABELS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (prefer existing palette; allow k+1 sparingly)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        best_labels = []\n        best_score = None\n        # Try labels 1..k first\n        labels_to_try = list(range(1, k+1))\n        if current in labels_to_try:\n            labels_to_try.remove(current)\n        # Occasionally consider k+1\n        if random.random() < 0.2:\n            labels_to_try.append(k+1)\n        for lbl in labels_to_try:\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        lbl = random.choice(best_labels) if best_labels else ((current % max(k,1)) + 1)\n        ns = s[:]\n        ns[vtx] = lbl\n        # If we introduced k+1, try immediate greedy reduce on that vertex\n        if lbl == k+1:\n            for try_lbl in range(1, k+1):\n                ok = True\n                for nb in adj[vtx]:\n                    if ns[nb] == try_lbl:\n                        ok = False\n                        break\n                if ok:\n                    ns[vtx] = try_lbl\n                    break\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # Move 2: ReduceK pass on highest label class\n    max_label_vertices = [i for i,c in enumerate(s) if c == k]\n    if max_label_vertices:\n        order = sorted(max_label_vertices, key=lambda i: -len(adj[i]))\n        ns = s[:]\n        reduced_any = False\n        for vtx in order:\n            for lbl in range(1, k):\n                ok = True\n                for nb in adj[vtx]:\n                    if ns[nb] == lbl:\n                        ok = False\n                        break\n                if ok:\n                    ns[vtx] = lbl\n                    reduced_any = True\n                    break\n        if reduced_any:\n            ns = canonicalize(ns)\n            return (ns, (\"Recolor\", \"ReduceKGreedy\"))\n\n    # Move 3: Kempe chain bi-color swap between two labels to escape plateaus\n    if k >= 2:\n        a = random.randint(1, k)\n        b = random.randint(1, k)\n        while b == a:\n            b = random.randint(1, k)\n        # pick a random start vertex of colors a or b\n        candidates = [i for i,c in enumerate(s) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a,b}\n            # BFS on subgraph induced by colors {a,b}\n            visited = set([start])\n            queue = [start]\n            while queue:\n                v = queue.pop(0)\n                for nb in adj[v]:\n                    if s[nb] in target_colors and nb not in visited:\n                        visited.add(nb)\n                        queue.append(nb)\n            ns = s[:]\n            # swap colors a<->b on visited set\n            for v in visited:\n                ns[v] = a if s[v] == b else (b if s[v] == a else s[v])\n            ns = canonicalize(ns)\n            if ns != s:\n                return (ns, (\"Kempe\", \"BiColorSwap\"))\n\n    # Fallback: random recolor of a random vertex\n    idx = random.randrange(n)\n    current = s[idx]\n    lbl = current\n    attempts = 0\n    while attempts < 10:\n        t = random.randint(1, max(k, 3))\n        if t != current:\n            lbl = t\n            break\n        attempts += 1\n    if lbl == current:\n        lbl = (current % max(k,3)) + 1\n    ns = s[:]\n    ns[idx] = lbl\n    ns = canonicalize(ns)\n    return (ns, (\"Recolor\", \"RandomFallback\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n    base_max = max(k, 3)\n\n    # Select ~40% of vertices with priority to conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    pool = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(pool)\n    sel = pool[:m_cnt]\n\n    ps = s[:]\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(8):\n            t = random.randint(1, base_max)\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            new_lbl = (ps[idx] % base_max) + 1\n        ps[idx] = new_lbl\n\n    # Apply one Kempe bi-color swap to diversify structure\n    labels = list(range(1, max(ps)+1))\n    if len(labels) >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        # pick random start of colors a\/b\n        candidates = [i for i,c in enumerate(ps) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target = {a,b}\n            visited = set([start])\n            queue = [start]\n            while queue:\n                v = queue.pop(0)\n                for nb in adj[v]:\n                    if ps[nb] in target and nb not in visited:\n                        visited.add(nb)\n                        queue.append(nb)\n            for v in visited:\n                ps[v] = a if ps[v] == b else (b if ps[v] == a else ps[v])\n\n    ps = canonicalize(ps)\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        ps[idx] = (ps[idx] % base_max) + 1\n        ps = canonicalize(ps)\n\n    return ps\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001013152}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_LABELS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (prefer existing palette; allow k+1 sparingly)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        best_labels = []\n        best_score = None\n        # Try labels 1..k first\n        labels_to_try = list(range(1, k+1))\n        if current in labels_to_try:\n            labels_to_try.remove(current)\n        # Occasionally consider k+1\n        if random.random() < 0.2:\n            labels_to_try.append(k+1)\n        for lbl in labels_to_try:\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        lbl = random.choice(best_labels) if best_labels else ((current % max(k,1)) + 1)\n        ns = s[:]\n        ns[vtx] = lbl\n        # If we introduced k+1, try immediate greedy reduce on that vertex\n        if lbl == k+1:\n            for try_lbl in range(1, k+1):\n                ok = True\n                for nb in adj[vtx]:\n                    if ns[nb] == try_lbl:\n                        ok = False\n                        break\n                if ok:\n                    ns[vtx] = try_lbl\n                    break\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # Move 2: ReduceK pass on highest label class\n    max_label_vertices = [i for i,c in enumerate(s) if c == k]\n    if max_label_vertices:\n        order = sorted(max_label_vertices, key=lambda i: -len(adj[i]))\n        ns = s[:]\n        reduced_any = False\n        for vtx in order:\n            for lbl in range(1, k):\n                ok = True\n                for nb in adj[vtx]:\n                    if ns[nb] == lbl:\n                        ok = False\n                        break\n                if ok:\n                    ns[vtx] = lbl\n                    reduced_any = True\n                    break\n        if reduced_any:\n            ns = canonicalize(ns)\n            return (ns, (\"Recolor\", \"ReduceKGreedy\"))\n\n    # Move 3: Kempe chain bi-color swap between two labels to escape plateaus\n    if k >= 2:\n        a = random.randint(1, k)\n        b = random.randint(1, k)\n        while b == a:\n            b = random.randint(1, k)\n        # pick a random start vertex of colors a or b\n        candidates = [i for i,c in enumerate(s) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a,b}\n            # BFS on subgraph induced by colors {a,b}\n            visited = set([start])\n            queue = [start]\n            while queue:\n                v = queue.pop(0)\n                for nb in adj[v]:\n                    if s[nb] in target_colors and nb not in visited:\n                        visited.add(nb)\n                        queue.append(nb)\n            ns = s[:]\n            # swap colors a<->b on visited set\n            for v in visited:\n                ns[v] = a if s[v] == b else (b if s[v] == a else s[v])\n            ns = canonicalize(ns)\n            if ns != s:\n                return (ns, (\"Kempe\", \"BiColorSwap\"))\n\n    # Fallback: random recolor of a random vertex\n    idx = random.randrange(n)\n    current = s[idx]\n    lbl = current\n    attempts = 0\n    while attempts < 10:\n        t = random.randint(1, max(k, 3))\n        if t != current:\n            lbl = t\n            break\n        attempts += 1\n    if lbl == current:\n        lbl = (current % max(k,3)) + 1\n    ns = s[:]\n    ns[idx] = lbl\n    ns = canonicalize(ns)\n    return (ns, (\"Recolor\", \"RandomFallback\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n    base_max = max(k, 3)\n\n    # Select ~40% of vertices with priority to conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    pool = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(pool)\n    sel = pool[:m_cnt]\n\n    ps = s[:]\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(8):\n            t = random.randint(1, base_max)\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            new_lbl = (ps[idx] % base_max) + 1\n        ps[idx] = new_lbl\n\n    # Apply one Kempe bi-color swap to diversify structure\n    labels = list(range(1, max(ps)+1))\n    if len(labels) >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        # pick random start of colors a\/b\n        candidates = [i for i,c in enumerate(ps) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target = {a,b}\n            visited = set([start])\n            queue = [start]\n            while queue:\n                v = queue.pop(0)\n                for nb in adj[v]:\n                    if ps[nb] in target and nb not in visited:\n                        visited.add(nb)\n                        queue.append(nb)\n            for v in visited:\n                ps[v] = a if ps[v] == b else (b if ps[v] == a else ps[v])\n\n    ps = canonicalize(ps)\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        ps[idx] = (ps[idx] % base_max) + 1\n        ps = canonicalize(ps)\n\n    return ps\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001310756}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_LABELS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (prefer existing palette; allow k+1 sparingly)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        best_labels = []\n        best_score = None\n        # Try labels 1..k first\n        labels_to_try = list(range(1, k+1))\n        if current in labels_to_try:\n            labels_to_try.remove(current)\n        # Occasionally consider k+1\n        if random.random() < 0.2:\n            labels_to_try.append(k+1)\n        for lbl in labels_to_try:\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        lbl = random.choice(best_labels) if best_labels else ((current % max(k,1)) + 1)\n        ns = s[:]\n        ns[vtx] = lbl\n        # If we introduced k+1, try immediate greedy reduce on that vertex\n        if lbl == k+1:\n            for try_lbl in range(1, k+1):\n                ok = True\n                for nb in adj[vtx]:\n                    if ns[nb] == try_lbl:\n                        ok = False\n                        break\n                if ok:\n                    ns[vtx] = try_lbl\n                    break\n        ns = canonicalize(ns)\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # Move 2: ReduceK pass on highest label class\n    max_label_vertices = [i for i,c in enumerate(s) if c == k]\n    if max_label_vertices:\n        order = sorted(max_label_vertices, key=lambda i: -len(adj[i]))\n        ns = s[:]\n        reduced_any = False\n        for vtx in order:\n            for lbl in range(1, k):\n                ok = True\n                for nb in adj[vtx]:\n                    if ns[nb] == lbl:\n                        ok = False\n                        break\n                if ok:\n                    ns[vtx] = lbl\n                    reduced_any = True\n                    break\n        if reduced_any:\n            ns = canonicalize(ns)\n            return (ns, (\"Recolor\", \"ReduceKGreedy\"))\n\n    # Move 3: Kempe chain bi-color swap between two labels to escape plateaus\n    if k >= 2:\n        a = random.randint(1, k)\n        b = random.randint(1, k)\n        while b == a:\n            b = random.randint(1, k)\n        # pick a random start vertex of colors a or b\n        candidates = [i for i,c in enumerate(s) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a,b}\n            # BFS on subgraph induced by colors {a,b}\n            visited = set([start])\n            queue = [start]\n            while queue:\n                v = queue.pop(0)\n                for nb in adj[v]:\n                    if s[nb] in target_colors and nb not in visited:\n                        visited.add(nb)\n                        queue.append(nb)\n            ns = s[:]\n            # swap colors a<->b on visited set\n            for v in visited:\n                ns[v] = a if s[v] == b else (b if s[v] == a else s[v])\n            ns = canonicalize(ns)\n            if ns != s:\n                return (ns, (\"Kempe\", \"BiColorSwap\"))\n\n    # Fallback: random recolor of a random vertex\n    idx = random.randrange(n)\n    current = s[idx]\n    lbl = current\n    attempts = 0\n    while attempts < 10:\n        t = random.randint(1, max(k, 3))\n        if t != current:\n            lbl = t\n            break\n        attempts += 1\n    if lbl == current:\n        lbl = (current % max(k,3)) + 1\n    ns = s[:]\n    ns[idx] = lbl\n    ns = canonicalize(ns)\n    return (ns, (\"Recolor\", \"RandomFallback\"))\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n\n    def canonicalize(s: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for c in s:\n            if c not in m:\n                m[c] = nxt\n                nxt += 1\n            out.append(m[c])\n        return out\n\n    s = canonicalize(solution)\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n    base_max = max(k, 3)\n\n    # Select ~40% of vertices with priority to conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    pool = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(pool)\n    sel = pool[:m_cnt]\n\n    ps = s[:]\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(8):\n            t = random.randint(1, base_max)\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            new_lbl = (ps[idx] % base_max) + 1\n        ps[idx] = new_lbl\n\n    # Apply one Kempe bi-color swap to diversify structure\n    labels = list(range(1, max(ps)+1))\n    if len(labels) >= 2:\n        a = random.choice(labels)\n        b = random.choice(labels)\n        while b == a:\n            b = random.choice(labels)\n        # pick random start of colors a\/b\n        candidates = [i for i,c in enumerate(ps) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target = {a,b}\n            visited = set([start])\n            queue = [start]\n            while queue:\n                v = queue.pop(0)\n                for nb in adj[v]:\n                    if ps[nb] in target and nb not in visited:\n                        visited.add(nb)\n                        queue.append(nb)\n            for v in visited:\n                ps[v] = a if ps[v] == b else (b if ps[v] == a else ps[v])\n\n    ps = canonicalize(ps)\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        ps[idx] = (ps[idx] % base_max) + 1\n        ps = canonicalize(ps)\n\n    return ps\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001242925}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"List[int] of length 9: solution[i-1] = color of vertex i in {1,2,...,k}. Labels need not be contiguous; evaluator canonicalizes to 1..m.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return (solution, (\"Identity\", \"InvalidInput\"))\n\n    s = solution[:]\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (restrict to existing palette 1..k)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        best_labels = []\n        best_score = None\n        labels_to_try = list(range(1, k+1))\n        if current in labels_to_try:\n            labels_to_try.remove(current)\n        random.shuffle(labels_to_try)\n        for lbl in labels_to_try:\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        lbl = random.choice(best_labels) if best_labels else ((current % max(k,1)) + 1)\n        ns = s[:]\n        ns[vtx] = lbl\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # Move 2: ReduceK pass on highest label class (attempt recolor to 1..k-1)\n    if k >= 2:\n        max_label_vertices = [i for i,c in enumerate(s) if c == k]\n        if max_label_vertices:\n            # Order by decreasing degree and random tie-break\n            order = sorted(max_label_vertices, key=lambda i: (-len(adj[i]), random.random()))\n            ns = s[:]\n            reduced_any = False\n            for vtx in order:\n                # Try labels in randomized order 1..k-1\n                labels = list(range(1, k))\n                random.shuffle(labels)\n                for lbl in labels:\n                    ok = True\n                    for nb in adj[vtx]:\n                        if ns[nb] == lbl:\n                            ok = False\n                            break\n                    if ok:\n                        ns[vtx] = lbl\n                        reduced_any = True\n                        break\n            if reduced_any:\n                return (ns, (\"Recolor\", \"ReduceKGreedy\"))\n\n    # Move 3: Kempe chain swap involving max label if possible\n    labels_present = sorted(set(s))\n    if len(labels_present) >= 2:\n        a = k if k in labels_present else random.choice(labels_present)\n        bs = [x for x in labels_present if x != a]\n        b = random.choice(bs)\n        # pick a random start vertex of colors a or b\n        candidates = [i for i,c in enumerate(s) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a,b}\n            visited = set([start])\n            q = deque([start])\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if s[nb] in target_colors and nb not in visited:\n                        visited.add(nb)\n                        q.append(nb)\n            ns = s[:]\n            for v in visited:\n                if s[v] == a:\n                    ns[v] = b\n                elif s[v] == b:\n                    ns[v] = a\n            if ns != s:\n                return (ns, (\"Kempe\", \"BiColorSwap\"))\n\n    # Fallback: random recolor within current palette\n    idx = random.randrange(n)\n    current = s[idx]\n    lbl = current\n    attempts = 0\n    while attempts < 10:\n        t = random.randint(1, max(1, k))\n        if t != current:\n            lbl = t\n            break\n        attempts += 1\n    if lbl == current:\n        lbl = (current % max(1, k)) + (1 if k >= 2 else 0)\n        if k < 2:\n            lbl = 1\n    ns = s[:]\n    ns[idx] = lbl\n    return (ns, (\"Recolor\", \"RandomFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n\n    s = solution[:]\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Select ~40% of vertices with priority to conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    pool = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(pool)\n    sel = pool[:m_cnt]\n\n    ps = s[:]\n    # Recolor selected vertices within current palette (avoid inflation)\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(8):\n            t = random.randint(1, max(1, k))\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            if k >= 2:\n                new_lbl = (ps[idx] % k) + 1\n            else:\n                new_lbl = 1\n        ps[idx] = new_lbl\n\n    # Apply one Kempe bi-color swap biased to include max label when present\n    labels = sorted(set(ps))\n    if len(labels) >= 2:\n        a = max(labels)\n        b = random.choice([x for x in labels if x != a])\n        candidates = [i for i,c in enumerate(ps) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target = {a,b}\n            visited = set([start])\n            q = deque([start])\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if ps[nb] in target and nb not in visited:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                if ps[v] == a:\n                    ps[v] = b\n                elif ps[v] == b:\n                    ps[v] = a\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        if k >= 2:\n            ps[idx] = (ps[idx] % k) + 1\n        else:\n            ps[idx] = 1\n\n    return ps\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000962968}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"List[int] of length 9: solution[i-1] = color of vertex i in {1,2,...,k}. Labels need not be contiguous; evaluator canonicalizes to 1..m.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return (solution, (\"Identity\", \"InvalidInput\"))\n\n    s = solution[:]\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (restrict to existing palette 1..k)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        best_labels = []\n        best_score = None\n        labels_to_try = list(range(1, k+1))\n        if current in labels_to_try:\n            labels_to_try.remove(current)\n        random.shuffle(labels_to_try)\n        for lbl in labels_to_try:\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        lbl = random.choice(best_labels) if best_labels else ((current % max(k,1)) + 1)\n        ns = s[:]\n        ns[vtx] = lbl\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # Move 2: ReduceK pass on highest label class (attempt recolor to 1..k-1)\n    if k >= 2:\n        max_label_vertices = [i for i,c in enumerate(s) if c == k]\n        if max_label_vertices:\n            # Order by decreasing degree and random tie-break\n            order = sorted(max_label_vertices, key=lambda i: (-len(adj[i]), random.random()))\n            ns = s[:]\n            reduced_any = False\n            for vtx in order:\n                # Try labels in randomized order 1..k-1\n                labels = list(range(1, k))\n                random.shuffle(labels)\n                for lbl in labels:\n                    ok = True\n                    for nb in adj[vtx]:\n                        if ns[nb] == lbl:\n                            ok = False\n                            break\n                    if ok:\n                        ns[vtx] = lbl\n                        reduced_any = True\n                        break\n            if reduced_any:\n                return (ns, (\"Recolor\", \"ReduceKGreedy\"))\n\n    # Move 3: Kempe chain swap involving max label if possible\n    labels_present = sorted(set(s))\n    if len(labels_present) >= 2:\n        a = k if k in labels_present else random.choice(labels_present)\n        bs = [x for x in labels_present if x != a]\n        b = random.choice(bs)\n        # pick a random start vertex of colors a or b\n        candidates = [i for i,c in enumerate(s) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a,b}\n            visited = set([start])\n            q = deque([start])\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if s[nb] in target_colors and nb not in visited:\n                        visited.add(nb)\n                        q.append(nb)\n            ns = s[:]\n            for v in visited:\n                if s[v] == a:\n                    ns[v] = b\n                elif s[v] == b:\n                    ns[v] = a\n            if ns != s:\n                return (ns, (\"Kempe\", \"BiColorSwap\"))\n\n    # Fallback: random recolor within current palette\n    idx = random.randrange(n)\n    current = s[idx]\n    lbl = current\n    attempts = 0\n    while attempts < 10:\n        t = random.randint(1, max(1, k))\n        if t != current:\n            lbl = t\n            break\n        attempts += 1\n    if lbl == current:\n        lbl = (current % max(1, k)) + (1 if k >= 2 else 0)\n        if k < 2:\n            lbl = 1\n    ns = s[:]\n    ns[idx] = lbl\n    return (ns, (\"Recolor\", \"RandomFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n\n    s = solution[:]\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Select ~40% of vertices with priority to conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    pool = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(pool)\n    sel = pool[:m_cnt]\n\n    ps = s[:]\n    # Recolor selected vertices within current palette (avoid inflation)\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(8):\n            t = random.randint(1, max(1, k))\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            if k >= 2:\n                new_lbl = (ps[idx] % k) + 1\n            else:\n                new_lbl = 1\n        ps[idx] = new_lbl\n\n    # Apply one Kempe bi-color swap biased to include max label when present\n    labels = sorted(set(ps))\n    if len(labels) >= 2:\n        a = max(labels)\n        b = random.choice([x for x in labels if x != a])\n        candidates = [i for i,c in enumerate(ps) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target = {a,b}\n            visited = set([start])\n            q = deque([start])\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if ps[nb] in target and nb not in visited:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                if ps[v] == a:\n                    ps[v] = b\n                elif ps[v] == b:\n                    ps[v] = a\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        if k >= 2:\n            ps[idx] = (ps[idx] % k) + 1\n        else:\n            ps[idx] = 1\n\n    return ps\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001284581}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_parties_with_exes_standard","Representacion":"List[int] of length 9: solution[i-1] = color of vertex i in {1,2,...,k}. Labels need not be contiguous; evaluator canonicalizes to 1..m.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return 10**6\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**6\n\n    # Canonicalize labels to contiguous 1..m by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = []\n    for c in solution:\n        if c not in label_map:\n            label_map[c] = next_label\n            next_label += 1\n        canon.append(label_map[c])\n\n    # Compute conflicts\n    conflicts = 0\n    for (u,v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then number of colors\n    k = max(canon)\n    score = conflicts * 1000 + k\n    return score\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, (NB_Type, Movement_Type))\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return (solution, (\"Identity\", \"InvalidInput\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return (solution, (\"Identity\", \"InvalidInput\"))\n\n    s = solution[:]\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Collect conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Move 1: Conflict-driven recolor (restrict to existing palette 1..k)\n    if conflicted:\n        vtx = random.choice(list(conflicted))\n        current = s[vtx]\n        best_labels = []\n        best_score = None\n        labels_to_try = list(range(1, k+1))\n        if current in labels_to_try:\n            labels_to_try.remove(current)\n        random.shuffle(labels_to_try)\n        for lbl in labels_to_try:\n            loc_conf = 0\n            for nb in adj[vtx]:\n                if s[nb] == lbl:\n                    loc_conf += 1\n            if best_score is None or loc_conf < best_score:\n                best_score = loc_conf\n                best_labels = [lbl]\n            elif loc_conf == best_score:\n                best_labels.append(lbl)\n        lbl = random.choice(best_labels) if best_labels else ((current % max(k,1)) + 1)\n        ns = s[:]\n        ns[vtx] = lbl\n        return (ns, (\"Recolor\", \"ConflictDriven\"))\n\n    # Move 2: ReduceK pass on highest label class (attempt recolor to 1..k-1)\n    if k >= 2:\n        max_label_vertices = [i for i,c in enumerate(s) if c == k]\n        if max_label_vertices:\n            # Order by decreasing degree and random tie-break\n            order = sorted(max_label_vertices, key=lambda i: (-len(adj[i]), random.random()))\n            ns = s[:]\n            reduced_any = False\n            for vtx in order:\n                # Try labels in randomized order 1..k-1\n                labels = list(range(1, k))\n                random.shuffle(labels)\n                for lbl in labels:\n                    ok = True\n                    for nb in adj[vtx]:\n                        if ns[nb] == lbl:\n                            ok = False\n                            break\n                    if ok:\n                        ns[vtx] = lbl\n                        reduced_any = True\n                        break\n            if reduced_any:\n                return (ns, (\"Recolor\", \"ReduceKGreedy\"))\n\n    # Move 3: Kempe chain swap involving max label if possible\n    labels_present = sorted(set(s))\n    if len(labels_present) >= 2:\n        a = k if k in labels_present else random.choice(labels_present)\n        bs = [x for x in labels_present if x != a]\n        b = random.choice(bs)\n        # pick a random start vertex of colors a or b\n        candidates = [i for i,c in enumerate(s) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a,b}\n            visited = set([start])\n            q = deque([start])\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if s[nb] in target_colors and nb not in visited:\n                        visited.add(nb)\n                        q.append(nb)\n            ns = s[:]\n            for v in visited:\n                if s[v] == a:\n                    ns[v] = b\n                elif s[v] == b:\n                    ns[v] = a\n            if ns != s:\n                return (ns, (\"Kempe\", \"BiColorSwap\"))\n\n    # Fallback: random recolor within current palette\n    idx = random.randrange(n)\n    current = s[idx]\n    lbl = current\n    attempts = 0\n    while attempts < 10:\n        t = random.randint(1, max(1, k))\n        if t != current:\n            lbl = t\n            break\n        attempts += 1\n    if lbl == current:\n        lbl = (current % max(1, k)) + (1 if k >= 2 else 0)\n        if k < 2:\n            lbl = 1\n    ns = s[:]\n    ns[idx] = lbl\n    return (ns, (\"Recolor\", \"RandomFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded instance\n    V = [1,2,3,4,5,6,7,8,9]\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, list) or len(solution) != len(V):\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return solution\n\n    s = solution[:]\n    n = len(s)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Identify conflict vertices\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    k = max(s)\n\n    # Select ~40% of vertices with priority to conflicted ones\n    m_cnt = max(1, int(0.4 * n))\n    pool = list(conflicted) if conflicted else list(range(n))\n    random.shuffle(pool)\n    sel = pool[:m_cnt]\n\n    ps = s[:]\n    # Recolor selected vertices within current palette (avoid inflation)\n    for idx in sel:\n        new_lbl = ps[idx]\n        for _ in range(8):\n            t = random.randint(1, max(1, k))\n            if t != ps[idx]:\n                new_lbl = t\n                break\n        if new_lbl == ps[idx]:\n            if k >= 2:\n                new_lbl = (ps[idx] % k) + 1\n            else:\n                new_lbl = 1\n        ps[idx] = new_lbl\n\n    # Apply one Kempe bi-color swap biased to include max label when present\n    labels = sorted(set(ps))\n    if len(labels) >= 2:\n        a = max(labels)\n        b = random.choice([x for x in labels if x != a])\n        candidates = [i for i,c in enumerate(ps) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target = {a,b}\n            visited = set([start])\n            q = deque([start])\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if ps[nb] in target and nb not in visited:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                if ps[v] == a:\n                    ps[v] = b\n                elif ps[v] == b:\n                    ps[v] = a\n\n    # Ensure non-identity\n    if ps == s:\n        idx = random.randrange(n)\n        if k >= 2:\n            ps[idx] = (ps[idx] % k) + 1\n        else:\n            ps[idx] = 1\n\n    return ps\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.00117713}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"LIST_INT_COLORS contiguous 1..K for vertices 1..9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Type\/length validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Canonicalize to contiguous labels 1..K (order of first occurrence)\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n\n    # Conflicts\n    conflicts = 0\n    for u, v in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    fitness = K\n    if conflicts > 0:\n        fitness += 1000 * conflicts\n    if K < LB:\n        fitness += 10**6\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    # Internal graph\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        # fallback: random valid-length coloring with 3 colors\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalize to contiguous colors 1..K\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n    sol = canon\n\n    # Helper: compute conflicts for a vertex color assignment\n    def count_conflicts(arr, idx, color):\n        cnt = 0\n        for (u, v) in E:\n            if u-1 == idx:\n                cnt += 1 if color == arr[v-1] else 0\n            elif v-1 == idx:\n                cnt += 1 if color == arr[u-1] else 0\n        return cnt\n\n    V_indices = list(range(V))\n    i = random.choice(V_indices)\n\n    current_colors = set(sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Candidate colors: existing colors plus optionally a new color with small probability\n    candidates = list(range(1, max_color+1))\n    if random.random() < 0.1:\n        candidates.append(max_color+1)\n\n    # Try greedy min-conflict recolor\n    best_color = sol[i]\n    best_conf = count_conflicts(sol, i, sol[i])\n    random.shuffle(candidates)\n    for c in candidates:\n        if c == sol[i]:\n            continue\n        conf = count_conflicts(sol, i, c)\n        if conf < best_conf or (conf == best_conf and random.random() < 0.5):\n            best_conf = conf\n            best_color = c\n\n    new_sol = list(sol)\n    new_sol[i] = best_color\n\n    # Re-canonicalize to keep colors contiguous\n    remap = {}\n    nxt = 1\n    canon2 = []\n    for c in new_sol:\n        if c not in remap:\n            remap[c] = nxt\n            nxt += 1\n        canon2.append(remap[c])\n\n    return canon2, (\"RECOLOR\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Random multi-vertex perturbation with occasional color merge\/split\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalize\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n    sol = canon\n\n    max_color = max(sol) if sol else 1\n\n    # Apply a number of random recolorings\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(V)\n        # pick from existing colors plus optional new color\n        candidates = list(range(1, max(sol)+1))\n        if random.random() < 0.2:\n            candidates.append(max(sol)+1)\n        sol[i] = random.choice(candidates)\n\n    # Occasionally merge two colors to reduce K\n    if max(sol) > 1 and random.random() < 0.5:\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            target = min(a, b)\n            source = max(a, b)\n            sol = [target if c == source else c for c in sol]\n\n    # Re-canonicalize\n    remap = {}\n    nxt = 1\n    canon2 = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nxt\n            nxt += 1\n        canon2.append(remap[c])\n\n    return canon2\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000663175}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"LIST_INT_COLORS contiguous 1..K for vertices 1..9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Type\/length validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Canonicalize to contiguous labels 1..K (order of first occurrence)\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n\n    # Conflicts\n    conflicts = 0\n    for u, v in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    fitness = K\n    if conflicts > 0:\n        fitness += 1000 * conflicts\n    if K < LB:\n        fitness += 10**6\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    # Internal graph\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        # fallback: random valid-length coloring with 3 colors\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalize to contiguous colors 1..K\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n    sol = canon\n\n    # Helper: compute conflicts for a vertex color assignment\n    def count_conflicts(arr, idx, color):\n        cnt = 0\n        for (u, v) in E:\n            if u-1 == idx:\n                cnt += 1 if color == arr[v-1] else 0\n            elif v-1 == idx:\n                cnt += 1 if color == arr[u-1] else 0\n        return cnt\n\n    V_indices = list(range(V))\n    i = random.choice(V_indices)\n\n    current_colors = set(sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Candidate colors: existing colors plus optionally a new color with small probability\n    candidates = list(range(1, max_color+1))\n    if random.random() < 0.1:\n        candidates.append(max_color+1)\n\n    # Try greedy min-conflict recolor\n    best_color = sol[i]\n    best_conf = count_conflicts(sol, i, sol[i])\n    random.shuffle(candidates)\n    for c in candidates:\n        if c == sol[i]:\n            continue\n        conf = count_conflicts(sol, i, c)\n        if conf < best_conf or (conf == best_conf and random.random() < 0.5):\n            best_conf = conf\n            best_color = c\n\n    new_sol = list(sol)\n    new_sol[i] = best_color\n\n    # Re-canonicalize to keep colors contiguous\n    remap = {}\n    nxt = 1\n    canon2 = []\n    for c in new_sol:\n        if c not in remap:\n            remap[c] = nxt\n            nxt += 1\n        canon2.append(remap[c])\n\n    return canon2, (\"RECOLOR\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Random multi-vertex perturbation with occasional color merge\/split\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalize\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n    sol = canon\n\n    max_color = max(sol) if sol else 1\n\n    # Apply a number of random recolorings\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(V)\n        # pick from existing colors plus optional new color\n        candidates = list(range(1, max(sol)+1))\n        if random.random() < 0.2:\n            candidates.append(max(sol)+1)\n        sol[i] = random.choice(candidates)\n\n    # Occasionally merge two colors to reduce K\n    if max(sol) > 1 and random.random() < 0.5:\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            target = min(a, b)\n            source = max(a, b)\n            sol = [target if c == source else c for c in sol]\n\n    # Re-canonicalize\n    remap = {}\n    nxt = 1\n    canon2 = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nxt\n            nxt += 1\n        canon2.append(remap[c])\n\n    return canon2\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000827498}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"LIST_INT_COLORS contiguous 1..K for vertices 1..9","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Type\/length validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Canonicalize to contiguous labels 1..K (order of first occurrence)\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n\n    # Conflicts\n    conflicts = 0\n    for u, v in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    fitness = K\n    if conflicts > 0:\n        fitness += 1000 * conflicts\n    if K < LB:\n        fitness += 10**6\n\n    return fitness\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution, (NB_Type, Movement_Type))\n    # Internal graph\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        # fallback: random valid-length coloring with 3 colors\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalize to contiguous colors 1..K\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n    sol = canon\n\n    # Helper: compute conflicts for a vertex color assignment\n    def count_conflicts(arr, idx, color):\n        cnt = 0\n        for (u, v) in E:\n            if u-1 == idx:\n                cnt += 1 if color == arr[v-1] else 0\n            elif v-1 == idx:\n                cnt += 1 if color == arr[u-1] else 0\n        return cnt\n\n    V_indices = list(range(V))\n    i = random.choice(V_indices)\n\n    current_colors = set(sol)\n    max_color = max(current_colors) if current_colors else 1\n    # Candidate colors: existing colors plus optionally a new color with small probability\n    candidates = list(range(1, max_color+1))\n    if random.random() < 0.1:\n        candidates.append(max_color+1)\n\n    # Try greedy min-conflict recolor\n    best_color = sol[i]\n    best_conf = count_conflicts(sol, i, sol[i])\n    random.shuffle(candidates)\n    for c in candidates:\n        if c == sol[i]:\n            continue\n        conf = count_conflicts(sol, i, c)\n        if conf < best_conf or (conf == best_conf and random.random() < 0.5):\n            best_conf = conf\n            best_color = c\n\n    new_sol = list(sol)\n    new_sol[i] = best_color\n\n    # Re-canonicalize to keep colors contiguous\n    remap = {}\n    nxt = 1\n    canon2 = []\n    for c in new_sol:\n        if c not in remap:\n            remap[c] = nxt\n            nxt += 1\n        canon2.append(remap[c])\n\n    return canon2, (\"RECOLOR\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Random multi-vertex perturbation with occasional color merge\/split\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalize\n    mapping = {}\n    next_c = 1\n    canon = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        canon.append(mapping[c])\n    sol = canon\n\n    max_color = max(sol) if sol else 1\n\n    # Apply a number of random recolorings\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(V)\n        # pick from existing colors plus optional new color\n        candidates = list(range(1, max(sol)+1))\n        if random.random() < 0.2:\n            candidates.append(max(sol)+1)\n        sol[i] = random.choice(candidates)\n\n    # Occasionally merge two colors to reduce K\n    if max(sol) > 1 and random.random() < 0.5:\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            target = min(a, b)\n            source = max(a, b)\n            sol = [target if c == source else c for c in sol]\n\n    # Re-canonicalize\n    remap = {}\n    nxt = 1\n    canon2 = []\n    for c in sol:\n        if c not in remap:\n            remap[c] = nxt\n            nxt += 1\n        canon2.append(remap[c])\n\n    return canon2\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000806307}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"LIST_INT_COLORS: length=9, colors are positive integers canonicalized to contiguous 1..K by increasing smallest vertex index per color; position i corresponds to vertex i in {1..9}.","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    # sort colors by their smallest vertex index\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Build adjacency list once\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts, secondary minimize K; enforce LB\n    score = conflicts * 1000 + K\n    if K < LB:\n        score += 10**6\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Fallback or copy\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n    sol = [remap0[c] for c in sol]\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Helper: conflicts at vertex i if colored with color 'color'\n    def vertex_conflicts(arr, i, color):\n        cnt = 0\n        for nb in adj[i]:\n            if color == arr[nb]:\n                cnt += 1\n        return cnt\n\n    # Compute current per-vertex conflicts and total conflicts\n    per_conf = [vertex_conflicts(sol, i, sol[i]) for i in range(V)]\n    total_conf_edges = sum(1 for (u, v) in E if sol[u-1] == sol[v-1])\n\n    # Select a vertex: prioritize conflict vertices\n    conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n    if conflict_vertices:\n        i = random.choice(conflict_vertices)\n    else:\n        i = random.randrange(V)\n\n    max_color = max(sol) if sol else 1\n    candidates = list(range(1, max_color + 1))\n\n    # Gate new-color introduction: only allow if there are conflicts and no improving color among existing ones\n    allow_new = False\n    if total_conf_edges > 0:\n        current_conf = vertex_conflicts(sol, i, sol[i])\n        best_same_palette = min(vertex_conflicts(sol, i, c) for c in candidates)\n        if best_same_palette >= current_conf:\n            allow_new = True\n    if allow_new:\n        candidates.append(max_color + 1)\n\n    # Min-conflict recolor with deterministic tie-breaking (by color id)\n    best_color = sol[i]\n    best_val = vertex_conflicts(sol, i, sol[i])\n    for c in candidates:\n        val = vertex_conflicts(sol, i, c)\n        if (val < best_val) or (val == best_val and c < best_color):\n            best_val = val\n            best_color = c\n\n    new_sol = list(sol)\n    new_sol[i] = best_color\n\n    # Maintain contiguous colors only if a color class became empty\n    present = set(new_sol)\n    if len(present) != (max(present) if present else 0):\n        # Re-canonicalize stably\n        color_to_min_idx2 = {}\n        for idx, c in enumerate(new_sol):\n            if c not in color_to_min_idx2 or idx < color_to_min_idx2[c]:\n                color_to_min_idx2[c] = idx\n        ordered_colors2 = [c for c, _ in sorted(color_to_min_idx2.items(), key=lambda kv: kv[1])]\n        remap2 = {c: i+1 for i, c in enumerate(ordered_colors2)}\n        new_sol = [remap2[c] for c in new_sol]\n\n    return new_sol, (\"RECOLOR\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization\n    color_to_min_idx = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n    sol = [remap0[c] for c in sol]\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Compute conflict set\n    conflicts = [i for i in range(V) if vertex_conflicts(sol, i) > 0]\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # Bias to conflict vertices when available\n        if conflicts:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(V)\n        max_color = max(sol) if sol else 1\n        candidates = list(range(1, max_color + 1))\n        # Occasionally allow a new color only if conflicts exist globally\n        if conflicts and random.random() < 0.15:\n            candidates.append(max_color + 1)\n        # Choose a random candidate different from current\n        if len(candidates) > 1:\n            choices = [c for c in candidates if c != sol[i]]\n            sol[i] = random.choice(choices)\n        else:\n            sol[i] = candidates[0]\n        # update conflict cache lazily\n        conflicts = [j for j in range(V) if vertex_conflicts(sol, j) > 0]\n\n    # If no conflicts, attempt color merge with small probability to reduce K\n    if not conflicts and (max(sol) > 1) and random.random() < 0.5:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            # merge the highest color into the best feasible among lower ones greedily per vertex\n            src = colors[-1]\n            for i in [idx for idx, c in enumerate(sol) if c == src]:\n                # try assign to any lower color minimizing conflicts\n                best_c = None\n                best_val = None\n                for c in colors[:-1]:\n                    val = sum(1 for nb in adj[i] if sol[nb] == c)\n                    if best_val is None or val < best_val:\n                        best_val = val\n                        best_c = c\n                sol[i] = best_c if best_c is not None else sol[i]\n\n    # Re-canonicalize stably\n    color_to_min_idx2 = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx2 or idx < color_to_min_idx2[c]:\n            color_to_min_idx2[c] = idx\n    ordered_colors2 = [c for c, _ in sorted(color_to_min_idx2.items(), key=lambda kv: kv[1])]\n    remap2 = {c: i+1 for i, c in enumerate(ordered_colors2)}\n    sol = [remap2[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000966989}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"LIST_INT_COLORS: length=9, colors are positive integers canonicalized to contiguous 1..K by increasing smallest vertex index per color; position i corresponds to vertex i in {1..9}.","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    # sort colors by their smallest vertex index\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Build adjacency list once\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts, secondary minimize K; enforce LB\n    score = conflicts * 1000 + K\n    if K < LB:\n        score += 10**6\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Fallback or copy\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n    sol = [remap0[c] for c in sol]\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Helper: conflicts at vertex i if colored with color 'color'\n    def vertex_conflicts(arr, i, color):\n        cnt = 0\n        for nb in adj[i]:\n            if color == arr[nb]:\n                cnt += 1\n        return cnt\n\n    # Compute current per-vertex conflicts and total conflicts\n    per_conf = [vertex_conflicts(sol, i, sol[i]) for i in range(V)]\n    total_conf_edges = sum(1 for (u, v) in E if sol[u-1] == sol[v-1])\n\n    # Select a vertex: prioritize conflict vertices\n    conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n    if conflict_vertices:\n        i = random.choice(conflict_vertices)\n    else:\n        i = random.randrange(V)\n\n    max_color = max(sol) if sol else 1\n    candidates = list(range(1, max_color + 1))\n\n    # Gate new-color introduction: only allow if there are conflicts and no improving color among existing ones\n    allow_new = False\n    if total_conf_edges > 0:\n        current_conf = vertex_conflicts(sol, i, sol[i])\n        best_same_palette = min(vertex_conflicts(sol, i, c) for c in candidates)\n        if best_same_palette >= current_conf:\n            allow_new = True\n    if allow_new:\n        candidates.append(max_color + 1)\n\n    # Min-conflict recolor with deterministic tie-breaking (by color id)\n    best_color = sol[i]\n    best_val = vertex_conflicts(sol, i, sol[i])\n    for c in candidates:\n        val = vertex_conflicts(sol, i, c)\n        if (val < best_val) or (val == best_val and c < best_color):\n            best_val = val\n            best_color = c\n\n    new_sol = list(sol)\n    new_sol[i] = best_color\n\n    # Maintain contiguous colors only if a color class became empty\n    present = set(new_sol)\n    if len(present) != (max(present) if present else 0):\n        # Re-canonicalize stably\n        color_to_min_idx2 = {}\n        for idx, c in enumerate(new_sol):\n            if c not in color_to_min_idx2 or idx < color_to_min_idx2[c]:\n                color_to_min_idx2[c] = idx\n        ordered_colors2 = [c for c, _ in sorted(color_to_min_idx2.items(), key=lambda kv: kv[1])]\n        remap2 = {c: i+1 for i, c in enumerate(ordered_colors2)}\n        new_sol = [remap2[c] for c in new_sol]\n\n    return new_sol, (\"RECOLOR\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization\n    color_to_min_idx = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n    sol = [remap0[c] for c in sol]\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Compute conflict set\n    conflicts = [i for i in range(V) if vertex_conflicts(sol, i) > 0]\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # Bias to conflict vertices when available\n        if conflicts:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(V)\n        max_color = max(sol) if sol else 1\n        candidates = list(range(1, max_color + 1))\n        # Occasionally allow a new color only if conflicts exist globally\n        if conflicts and random.random() < 0.15:\n            candidates.append(max_color + 1)\n        # Choose a random candidate different from current\n        if len(candidates) > 1:\n            choices = [c for c in candidates if c != sol[i]]\n            sol[i] = random.choice(choices)\n        else:\n            sol[i] = candidates[0]\n        # update conflict cache lazily\n        conflicts = [j for j in range(V) if vertex_conflicts(sol, j) > 0]\n\n    # If no conflicts, attempt color merge with small probability to reduce K\n    if not conflicts and (max(sol) > 1) and random.random() < 0.5:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            # merge the highest color into the best feasible among lower ones greedily per vertex\n            src = colors[-1]\n            for i in [idx for idx, c in enumerate(sol) if c == src]:\n                # try assign to any lower color minimizing conflicts\n                best_c = None\n                best_val = None\n                for c in colors[:-1]:\n                    val = sum(1 for nb in adj[i] if sol[nb] == c)\n                    if best_val is None or val < best_val:\n                        best_val = val\n                        best_c = c\n                sol[i] = best_c if best_c is not None else sol[i]\n\n    # Re-canonicalize stably\n    color_to_min_idx2 = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx2 or idx < color_to_min_idx2[c]:\n            color_to_min_idx2[c] = idx\n    ordered_colors2 = [c for c, _ in sorted(color_to_min_idx2.items(), key=lambda kv: kv[1])]\n    remap2 = {c: i+1 for i, c in enumerate(ordered_colors2)}\n    sol = [remap2[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001423394}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"LIST_INT_COLORS: length=9, colors are positive integers canonicalized to contiguous 1..K by increasing smallest vertex index per color; position i corresponds to vertex i in {1..9}.","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    # sort colors by their smallest vertex index\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Build adjacency list once\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts, secondary minimize K; enforce LB\n    score = conflicts * 1000 + K\n    if K < LB:\n        score += 10**6\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Fallback or copy\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n    sol = [remap0[c] for c in sol]\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Helper: conflicts at vertex i if colored with color 'color'\n    def vertex_conflicts(arr, i, color):\n        cnt = 0\n        for nb in adj[i]:\n            if color == arr[nb]:\n                cnt += 1\n        return cnt\n\n    # Compute current per-vertex conflicts and total conflicts\n    per_conf = [vertex_conflicts(sol, i, sol[i]) for i in range(V)]\n    total_conf_edges = sum(1 for (u, v) in E if sol[u-1] == sol[v-1])\n\n    # Select a vertex: prioritize conflict vertices\n    conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n    if conflict_vertices:\n        i = random.choice(conflict_vertices)\n    else:\n        i = random.randrange(V)\n\n    max_color = max(sol) if sol else 1\n    candidates = list(range(1, max_color + 1))\n\n    # Gate new-color introduction: only allow if there are conflicts and no improving color among existing ones\n    allow_new = False\n    if total_conf_edges > 0:\n        current_conf = vertex_conflicts(sol, i, sol[i])\n        best_same_palette = min(vertex_conflicts(sol, i, c) for c in candidates)\n        if best_same_palette >= current_conf:\n            allow_new = True\n    if allow_new:\n        candidates.append(max_color + 1)\n\n    # Min-conflict recolor with deterministic tie-breaking (by color id)\n    best_color = sol[i]\n    best_val = vertex_conflicts(sol, i, sol[i])\n    for c in candidates:\n        val = vertex_conflicts(sol, i, c)\n        if (val < best_val) or (val == best_val and c < best_color):\n            best_val = val\n            best_color = c\n\n    new_sol = list(sol)\n    new_sol[i] = best_color\n\n    # Maintain contiguous colors only if a color class became empty\n    present = set(new_sol)\n    if len(present) != (max(present) if present else 0):\n        # Re-canonicalize stably\n        color_to_min_idx2 = {}\n        for idx, c in enumerate(new_sol):\n            if c not in color_to_min_idx2 or idx < color_to_min_idx2[c]:\n                color_to_min_idx2[c] = idx\n        ordered_colors2 = [c for c, _ in sorted(color_to_min_idx2.items(), key=lambda kv: kv[1])]\n        remap2 = {c: i+1 for i, c in enumerate(ordered_colors2)}\n        new_sol = [remap2[c] for c in new_sol]\n\n    return new_sol, (\"RECOLOR\", \"SingleVertex\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization\n    color_to_min_idx = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n    sol = [remap0[c] for c in sol]\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Compute conflict set\n    conflicts = [i for i in range(V) if vertex_conflicts(sol, i) > 0]\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        # Bias to conflict vertices when available\n        if conflicts:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(V)\n        max_color = max(sol) if sol else 1\n        candidates = list(range(1, max_color + 1))\n        # Occasionally allow a new color only if conflicts exist globally\n        if conflicts and random.random() < 0.15:\n            candidates.append(max_color + 1)\n        # Choose a random candidate different from current\n        if len(candidates) > 1:\n            choices = [c for c in candidates if c != sol[i]]\n            sol[i] = random.choice(choices)\n        else:\n            sol[i] = candidates[0]\n        # update conflict cache lazily\n        conflicts = [j for j in range(V) if vertex_conflicts(sol, j) > 0]\n\n    # If no conflicts, attempt color merge with small probability to reduce K\n    if not conflicts and (max(sol) > 1) and random.random() < 0.5:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            # merge the highest color into the best feasible among lower ones greedily per vertex\n            src = colors[-1]\n            for i in [idx for idx, c in enumerate(sol) if c == src]:\n                # try assign to any lower color minimizing conflicts\n                best_c = None\n                best_val = None\n                for c in colors[:-1]:\n                    val = sum(1 for nb in adj[i] if sol[nb] == c)\n                    if best_val is None or val < best_val:\n                        best_val = val\n                        best_c = c\n                sol[i] = best_c if best_c is not None else sol[i]\n\n    # Re-canonicalize stably\n    color_to_min_idx2 = {}\n    for idx, c in enumerate(sol):\n        if c not in color_to_min_idx2 or idx < color_to_min_idx2[c]:\n            color_to_min_idx2[c] = idx\n    ordered_colors2 = [c for c, _ in sorted(color_to_min_idx2.items(), key=lambda kv: kv[1])]\n    remap2 = {c: i+1 for i, c in enumerate(ordered_colors2)}\n    sol = [remap2[c] for c in sol]\n\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001326562}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"List of 9 positive integers, index i (0-based) corresponds to vertex i+1. Colors are canonicalized to contiguous 1..K by ordering color classes by the smallest vertex index they occupy (stable canonicalization). Example: [1,2,2,3,3,2,1,1,3].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts (dominant), secondary minimize K; enforce LB\n    score = conflicts * 1_000_000 + K\n    if K < LB:\n        score += 1_000_000_000\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Copy and validate\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    sol = canonicalize(sol)\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    def total_conflicts(arr):\n        return sum(1 for (u, v) in E if arr[u-1] == arr[v-1])\n\n    def min_conflict_color(arr, i, allow_new_color):\n        max_color = max(arr) if arr else 1\n        candidates = list(range(1, max_color + 1))\n        if allow_new_color:\n            candidates.append(max_color + 1)\n        # Evaluate candidate conflicts\n        vals = []\n        for c in candidates:\n            val = sum(1 for nb in adj[i] if arr[nb] == c)\n            vals.append((val, c))\n        # Randomized tie-breaking biased to lower conflicts\n        best_val = min(v for v, _ in vals)\n        pool = [c for v, c in vals if v == best_val]\n        return random.choice(pool)\n\n    # Precompute conflicts\n    per_conf = [per_vertex_conflicts(sol, i) for i in range(V)]\n    tot_conf = sum(1 for (u, v) in E if sol[u-1] == sol[v-1])\n\n    # Choose a move type with bias: prioritize resolving conflicts\n    # Move types: single-vertex recolor, Kempe-chain swap, color-class swap\n    move_types = []\n    if tot_conf > 0:\n        move_types.extend([\"Recolor\", \"Kempe\", \"Recolor\", \"Kempe\", \"ClassSwap\"])  # bias to conflict-resolving moves\n    else:\n        move_types.extend([\"Recolor\", \"ClassSwap\", \"Kempe\"])  # diversification on plateaus\n    move = random.choice(move_types)\n\n    new_sol = list(sol)\n    nb_meta = (\"UNKNOWN\", \"UNKNOWN\")\n\n    if move == \"Recolor\":\n        # Select the max-conflict vertex; break ties by higher degree then random\n        max_c = max(per_conf)\n        candidates_v = [i for i, c in enumerate(per_conf) if c == max_c]\n        if len(candidates_v) > 1:\n            # tie-break by degree\n            degs = [len(adj[i]) for i in candidates_v]\n            max_deg = max(degs)\n            candidates_v = [i for i in candidates_v if len(adj[i]) == max_deg]\n        i = random.choice(candidates_v)\n        allow_new = tot_conf > 0  # forbid new colors on conflict-free plateaus\n        c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n        new_sol[i] = c_best\n        # Canonicalize if gaps appeared\n        if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n            new_sol = canonicalize(new_sol)\n        nb_meta = (\"RECOLOR\", \"SingleVertex\")\n\n    elif move == \"Kempe\":\n        # Pick a seed vertex; bias to conflict vertices\n        conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n        if conflict_vertices:\n            seed = random.choice(conflict_vertices)\n        else:\n            seed = random.randrange(V)\n        # Pick a partner color different from seed color\n        colors = sorted(set(new_sol))\n        a = new_sol[seed]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            # no partner color, fallback to recolor\n            i = seed\n            allow_new = tot_conf > 0\n            c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n            new_sol[i] = c_best\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback\")\n        else:\n            b = random.choice(b_choices)\n            # BFS over the subgraph induced by colors {a,b}\n            comp = set()\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                if v in comp:\n                    continue\n                if new_sol[v] in (a, b):\n                    comp.add(v)\n                    for nb in adj[v]:\n                        if new_sol[nb] in (a, b) and nb not in comp:\n                            stack.append(nb)\n            # Swap colors a<->b in the component\n            for v in comp:\n                new_sol[v] = a if new_sol[v] == b else b\n            # Canonicalize only if gaps\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"KEMPE_SWAP\", \"TwoColorComponent\")\n\n    else:  # ClassSwap\n        colors = sorted(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            for i in range(V):\n                if new_sol[i] == c1:\n                    new_sol[i] = c2\n                elif new_sol[i] == c2:\n                    new_sol[i] = c1\n            # Canonicalize to maintain stable labels\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"COLOR_CLASS_SWAP\", \"GlobalRelabel\")\n        else:\n            # fallback to recolor any vertex (no new color if conflict-free)\n            i = random.randrange(V)\n            allow_new = tot_conf > 0\n            c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n            new_sol[i] = c_best\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback2\")\n\n    return new_sol, nb_meta\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    sol = canonicalize(sol)\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Steps: randomized Kempe-chain swaps and occasional color-class shuffle\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        move = random.choices([\"Kempe\", \"Recolor\"], weights=[0.7, 0.3], k=1)[0]\n        if move == \"Kempe\":\n            seed_candidates = [i for i in range(V) if per_vertex_conflicts(sol, i) > 0]\n            if not seed_candidates:\n                seed_candidates = list(range(V))\n            seed = random.choice(seed_candidates)\n            colors = sorted(set(sol))\n            a = sol[seed]\n            b_choices = [c for c in colors if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            # Build component in the {a,b}-induced subgraph\n            comp = set([seed])\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                for nb in adj[v]:\n                    if sol[nb] in (a, b) and nb not in comp:\n                        comp.add(nb)\n                        stack.append(nb)\n            for v in comp:\n                sol[v] = a if sol[v] == b else b\n        else:  # Recolor random vertex with existing palette only\n            i = random.randrange(V)\n            palette = sorted(set(sol))\n            if len(palette) > 1:\n                choices = [c for c in palette if c != sol[i]]\n                sol[i] = random.choice(choices)\n\n    # With small probability, perform a color-class shuffle to diversify without changing K\n    if random.random() < 0.4:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[idx] for idx, c in enumerate(colors)}\n            sol = [mapping[c] for c in sol]\n\n    # Final canonicalization to contiguous stable labels\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001620686}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"List of 9 positive integers, index i (0-based) corresponds to vertex i+1. Colors are canonicalized to contiguous 1..K by ordering color classes by the smallest vertex index they occupy (stable canonicalization). Example: [1,2,2,3,3,2,1,1,3].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts (dominant), secondary minimize K; enforce LB\n    score = conflicts * 1_000_000 + K\n    if K < LB:\n        score += 1_000_000_000\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Copy and validate\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    sol = canonicalize(sol)\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    def total_conflicts(arr):\n        return sum(1 for (u, v) in E if arr[u-1] == arr[v-1])\n\n    def min_conflict_color(arr, i, allow_new_color):\n        max_color = max(arr) if arr else 1\n        candidates = list(range(1, max_color + 1))\n        if allow_new_color:\n            candidates.append(max_color + 1)\n        # Evaluate candidate conflicts\n        vals = []\n        for c in candidates:\n            val = sum(1 for nb in adj[i] if arr[nb] == c)\n            vals.append((val, c))\n        # Randomized tie-breaking biased to lower conflicts\n        best_val = min(v for v, _ in vals)\n        pool = [c for v, c in vals if v == best_val]\n        return random.choice(pool)\n\n    # Precompute conflicts\n    per_conf = [per_vertex_conflicts(sol, i) for i in range(V)]\n    tot_conf = sum(1 for (u, v) in E if sol[u-1] == sol[v-1])\n\n    # Choose a move type with bias: prioritize resolving conflicts\n    # Move types: single-vertex recolor, Kempe-chain swap, color-class swap\n    move_types = []\n    if tot_conf > 0:\n        move_types.extend([\"Recolor\", \"Kempe\", \"Recolor\", \"Kempe\", \"ClassSwap\"])  # bias to conflict-resolving moves\n    else:\n        move_types.extend([\"Recolor\", \"ClassSwap\", \"Kempe\"])  # diversification on plateaus\n    move = random.choice(move_types)\n\n    new_sol = list(sol)\n    nb_meta = (\"UNKNOWN\", \"UNKNOWN\")\n\n    if move == \"Recolor\":\n        # Select the max-conflict vertex; break ties by higher degree then random\n        max_c = max(per_conf)\n        candidates_v = [i for i, c in enumerate(per_conf) if c == max_c]\n        if len(candidates_v) > 1:\n            # tie-break by degree\n            degs = [len(adj[i]) for i in candidates_v]\n            max_deg = max(degs)\n            candidates_v = [i for i in candidates_v if len(adj[i]) == max_deg]\n        i = random.choice(candidates_v)\n        allow_new = tot_conf > 0  # forbid new colors on conflict-free plateaus\n        c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n        new_sol[i] = c_best\n        # Canonicalize if gaps appeared\n        if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n            new_sol = canonicalize(new_sol)\n        nb_meta = (\"RECOLOR\", \"SingleVertex\")\n\n    elif move == \"Kempe\":\n        # Pick a seed vertex; bias to conflict vertices\n        conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n        if conflict_vertices:\n            seed = random.choice(conflict_vertices)\n        else:\n            seed = random.randrange(V)\n        # Pick a partner color different from seed color\n        colors = sorted(set(new_sol))\n        a = new_sol[seed]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            # no partner color, fallback to recolor\n            i = seed\n            allow_new = tot_conf > 0\n            c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n            new_sol[i] = c_best\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback\")\n        else:\n            b = random.choice(b_choices)\n            # BFS over the subgraph induced by colors {a,b}\n            comp = set()\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                if v in comp:\n                    continue\n                if new_sol[v] in (a, b):\n                    comp.add(v)\n                    for nb in adj[v]:\n                        if new_sol[nb] in (a, b) and nb not in comp:\n                            stack.append(nb)\n            # Swap colors a<->b in the component\n            for v in comp:\n                new_sol[v] = a if new_sol[v] == b else b\n            # Canonicalize only if gaps\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"KEMPE_SWAP\", \"TwoColorComponent\")\n\n    else:  # ClassSwap\n        colors = sorted(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            for i in range(V):\n                if new_sol[i] == c1:\n                    new_sol[i] = c2\n                elif new_sol[i] == c2:\n                    new_sol[i] = c1\n            # Canonicalize to maintain stable labels\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"COLOR_CLASS_SWAP\", \"GlobalRelabel\")\n        else:\n            # fallback to recolor any vertex (no new color if conflict-free)\n            i = random.randrange(V)\n            allow_new = tot_conf > 0\n            c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n            new_sol[i] = c_best\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback2\")\n\n    return new_sol, nb_meta\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    sol = canonicalize(sol)\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Steps: randomized Kempe-chain swaps and occasional color-class shuffle\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        move = random.choices([\"Kempe\", \"Recolor\"], weights=[0.7, 0.3], k=1)[0]\n        if move == \"Kempe\":\n            seed_candidates = [i for i in range(V) if per_vertex_conflicts(sol, i) > 0]\n            if not seed_candidates:\n                seed_candidates = list(range(V))\n            seed = random.choice(seed_candidates)\n            colors = sorted(set(sol))\n            a = sol[seed]\n            b_choices = [c for c in colors if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            # Build component in the {a,b}-induced subgraph\n            comp = set([seed])\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                for nb in adj[v]:\n                    if sol[nb] in (a, b) and nb not in comp:\n                        comp.add(nb)\n                        stack.append(nb)\n            for v in comp:\n                sol[v] = a if sol[v] == b else b\n        else:  # Recolor random vertex with existing palette only\n            i = random.randrange(V)\n            palette = sorted(set(sol))\n            if len(palette) > 1:\n                choices = [c for c in palette if c != sol[i]]\n                sol[i] = random.choice(choices)\n\n    # With small probability, perform a color-class shuffle to diversify without changing K\n    if random.random() < 0.4:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[idx] for idx, c in enumerate(colors)}\n            sol = [mapping[c] for c in sol]\n\n    # Final canonicalization to contiguous stable labels\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001795058}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"List of 9 positive integers, index i (0-based) corresponds to vertex i+1. Colors are canonicalized to contiguous 1..K by ordering color classes by the smallest vertex index they occupy (stable canonicalization). Example: [1,2,2,3,3,2,1,1,3].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts (dominant), secondary minimize K; enforce LB\n    score = conflicts * 1_000_000 + K\n    if K < LB:\n        score += 1_000_000_000\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Copy and validate\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Stable canonicalization\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    sol = canonicalize(sol)\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    def total_conflicts(arr):\n        return sum(1 for (u, v) in E if arr[u-1] == arr[v-1])\n\n    def min_conflict_color(arr, i, allow_new_color):\n        max_color = max(arr) if arr else 1\n        candidates = list(range(1, max_color + 1))\n        if allow_new_color:\n            candidates.append(max_color + 1)\n        # Evaluate candidate conflicts\n        vals = []\n        for c in candidates:\n            val = sum(1 for nb in adj[i] if arr[nb] == c)\n            vals.append((val, c))\n        # Randomized tie-breaking biased to lower conflicts\n        best_val = min(v for v, _ in vals)\n        pool = [c for v, c in vals if v == best_val]\n        return random.choice(pool)\n\n    # Precompute conflicts\n    per_conf = [per_vertex_conflicts(sol, i) for i in range(V)]\n    tot_conf = sum(1 for (u, v) in E if sol[u-1] == sol[v-1])\n\n    # Choose a move type with bias: prioritize resolving conflicts\n    # Move types: single-vertex recolor, Kempe-chain swap, color-class swap\n    move_types = []\n    if tot_conf > 0:\n        move_types.extend([\"Recolor\", \"Kempe\", \"Recolor\", \"Kempe\", \"ClassSwap\"])  # bias to conflict-resolving moves\n    else:\n        move_types.extend([\"Recolor\", \"ClassSwap\", \"Kempe\"])  # diversification on plateaus\n    move = random.choice(move_types)\n\n    new_sol = list(sol)\n    nb_meta = (\"UNKNOWN\", \"UNKNOWN\")\n\n    if move == \"Recolor\":\n        # Select the max-conflict vertex; break ties by higher degree then random\n        max_c = max(per_conf)\n        candidates_v = [i for i, c in enumerate(per_conf) if c == max_c]\n        if len(candidates_v) > 1:\n            # tie-break by degree\n            degs = [len(adj[i]) for i in candidates_v]\n            max_deg = max(degs)\n            candidates_v = [i for i in candidates_v if len(adj[i]) == max_deg]\n        i = random.choice(candidates_v)\n        allow_new = tot_conf > 0  # forbid new colors on conflict-free plateaus\n        c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n        new_sol[i] = c_best\n        # Canonicalize if gaps appeared\n        if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n            new_sol = canonicalize(new_sol)\n        nb_meta = (\"RECOLOR\", \"SingleVertex\")\n\n    elif move == \"Kempe\":\n        # Pick a seed vertex; bias to conflict vertices\n        conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n        if conflict_vertices:\n            seed = random.choice(conflict_vertices)\n        else:\n            seed = random.randrange(V)\n        # Pick a partner color different from seed color\n        colors = sorted(set(new_sol))\n        a = new_sol[seed]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            # no partner color, fallback to recolor\n            i = seed\n            allow_new = tot_conf > 0\n            c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n            new_sol[i] = c_best\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback\")\n        else:\n            b = random.choice(b_choices)\n            # BFS over the subgraph induced by colors {a,b}\n            comp = set()\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                if v in comp:\n                    continue\n                if new_sol[v] in (a, b):\n                    comp.add(v)\n                    for nb in adj[v]:\n                        if new_sol[nb] in (a, b) and nb not in comp:\n                            stack.append(nb)\n            # Swap colors a<->b in the component\n            for v in comp:\n                new_sol[v] = a if new_sol[v] == b else b\n            # Canonicalize only if gaps\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"KEMPE_SWAP\", \"TwoColorComponent\")\n\n    else:  # ClassSwap\n        colors = sorted(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            for i in range(V):\n                if new_sol[i] == c1:\n                    new_sol[i] = c2\n                elif new_sol[i] == c2:\n                    new_sol[i] = c1\n            # Canonicalize to maintain stable labels\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"COLOR_CLASS_SWAP\", \"GlobalRelabel\")\n        else:\n            # fallback to recolor any vertex (no new color if conflict-free)\n            i = random.randrange(V)\n            allow_new = tot_conf > 0\n            c_best = min_conflict_color(new_sol, i, allow_new_color=allow_new)\n            new_sol[i] = c_best\n            if len(set(new_sol)) != (max(new_sol) if new_sol else 0):\n                new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback2\")\n\n    return new_sol, nb_meta\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    sol = canonicalize(sol)\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Steps: randomized Kempe-chain swaps and occasional color-class shuffle\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        move = random.choices([\"Kempe\", \"Recolor\"], weights=[0.7, 0.3], k=1)[0]\n        if move == \"Kempe\":\n            seed_candidates = [i for i in range(V) if per_vertex_conflicts(sol, i) > 0]\n            if not seed_candidates:\n                seed_candidates = list(range(V))\n            seed = random.choice(seed_candidates)\n            colors = sorted(set(sol))\n            a = sol[seed]\n            b_choices = [c for c in colors if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            # Build component in the {a,b}-induced subgraph\n            comp = set([seed])\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                for nb in adj[v]:\n                    if sol[nb] in (a, b) and nb not in comp:\n                        comp.add(nb)\n                        stack.append(nb)\n            for v in comp:\n                sol[v] = a if sol[v] == b else b\n        else:  # Recolor random vertex with existing palette only\n            i = random.randrange(V)\n            palette = sorted(set(sol))\n            if len(palette) > 1:\n                choices = [c for c in palette if c != sol[i]]\n                sol[i] = random.choice(choices)\n\n    # With small probability, perform a color-class shuffle to diversify without changing K\n    if random.random() < 0.4:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[idx] for idx, c in enumerate(colors)}\n            sol = [mapping[c] for c in sol]\n\n    # Final canonicalization to contiguous stable labels\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001684176}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"List of 9 positive integers. Index i (0-based) corresponds to vertex i+1. Each entry is a color label in {1,...,K}. Colors are canonicalized to contiguous 1..K by ordering color classes by the smallest vertex index they occupy (stable canonicalization). Example: [1,2,2,3,3,2,1,1,3].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Basic validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts (dominant), secondary minimize K; enforce LB\n    score = conflicts * 1_000_000 + K\n    if K < LB:\n        score += 1_000_000_000\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Validate \/ seed\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    def total_conflicts(arr):\n        return sum(1 for (u, v) in E if arr[u-1] == arr[v-1])\n\n    def best_existing_color(arr, i):\n        # Choose among existing colors only (no new color introduction here)\n        colors = sorted(set(arr))\n        # Evaluate conflicts per candidate\n        vals = []\n        for c in colors:\n            if c == arr[i]:\n                continue\n            val = sum(1 for nb in adj[i] if arr[nb] == c)\n            vals.append((val, c))\n        if not vals:\n            return arr[i]\n        best_val = min(v for v, _ in vals)\n        pool = [c for v, c in vals if v == best_val]\n        return random.choice(pool)\n\n    per_conf = [per_vertex_conflicts(sol, i) for i in range(V)]\n    tot_conf = total_conflicts(sol)\n\n    move_types = []\n    if tot_conf > 0:\n        move_types.extend([\"Recolor\", \"Kempe\", \"Recolor\", \"Kempe\"])  # biased to resolve conflicts\n    else:\n        move_types.extend([\"Recolor\", \"ClassSwap\"])  # diversify on plateau without increasing colors\n    move = random.choice(move_types)\n\n    new_sol = list(sol)\n    nb_meta = (\"UNKNOWN\", \"UNKNOWN\")\n\n    if move == \"Recolor\":\n        # Pick a conflicted vertex if any, else random\n        if tot_conf > 0:\n            candidates = [i for i in range(V) if per_conf[i] > 0]\n            if not candidates:\n                candidates = list(range(V))\n        else:\n            candidates = list(range(V))\n        i = random.choice(candidates)\n        c_best = best_existing_color(new_sol, i)\n        new_sol[i] = c_best\n        new_sol = canonicalize(new_sol)\n        nb_meta = (\"RECOLOR\", \"SingleVertex\")\n\n    elif move == \"Kempe\":\n        # Two-color Kempe-chain swap restricted to existing colors\n        colors = sorted(set(new_sol))\n        # seed biased to conflicted vertices when available\n        conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n        seed = random.choice(conflict_vertices) if conflict_vertices else random.randrange(V)\n        a = new_sol[seed]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            # Fallback recolor\n            c_best = best_existing_color(new_sol, seed)\n            new_sol[seed] = c_best\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback\")\n        else:\n            b = random.choice(b_choices)\n            comp = set()\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                if v in comp:\n                    continue\n                if new_sol[v] in (a, b):\n                    comp.add(v)\n                    for nb in adj[v]:\n                        if new_sol[nb] in (a, b) and nb not in comp:\n                            stack.append(nb)\n            for v in comp:\n                new_sol[v] = a if new_sol[v] == b else b\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"KEMPE_SWAP\", \"TwoColorComponent\")\n\n    else:  # ClassSwap\n        colors = sorted(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            for i in range(V):\n                if new_sol[i] == c1:\n                    new_sol[i] = c2\n                elif new_sol[i] == c2:\n                    new_sol[i] = c1\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"COLOR_CLASS_SWAP\", \"GlobalRelabel\")\n        else:\n            # Fallback recolor\n            i = random.randrange(V)\n            c_best = best_existing_color(new_sol, i)\n            new_sol[i] = c_best\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback2\")\n\n    # Return neighbor and metadata (for TS\/analytics), while signature annotation documents meta types\n    return (new_sol, nb_meta)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Seed and canonicalize\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Perform a small number of randomized moves without introducing new colors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        move = random.choices([\"Kempe\", \"Recolor\"], weights=[0.7, 0.3], k=1)[0]\n        if move == \"Kempe\":\n            colors = sorted(set(sol))\n            conflict_vertices = [i for i in range(V) if per_vertex_conflicts(sol, i) > 0]\n            seed = random.choice(conflict_vertices) if conflict_vertices else random.randrange(V)\n            a = sol[seed]\n            b_candidates = [c for c in colors if c != a]\n            if not b_candidates:\n                continue\n            b = random.choice(b_candidates)\n            comp = set([seed])\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                for nb in adj[v]:\n                    if sol[nb] in (a, b) and nb not in comp:\n                        comp.add(nb)\n                        stack.append(nb)\n            for v in comp:\n                sol[v] = a if sol[v] == b else b\n        else:\n            i = random.randrange(V)\n            palette = sorted(set(sol))\n            if len(palette) > 1:\n                choices = [c for c in palette if c != sol[i]]\n                if choices:\n                    sol[i] = random.choice(choices)\n\n    # Occasional color-class shuffle for diversification (does not change K)\n    if random.random() < 0.4:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[idx] for idx, c in enumerate(colors)}\n            sol = [mapping[c] for c in sol]\n\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001244803}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"List of 9 positive integers. Index i (0-based) corresponds to vertex i+1. Each entry is a color label in {1,...,K}. Colors are canonicalized to contiguous 1..K by ordering color classes by the smallest vertex index they occupy (stable canonicalization). Example: [1,2,2,3,3,2,1,1,3].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Basic validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts (dominant), secondary minimize K; enforce LB\n    score = conflicts * 1_000_000 + K\n    if K < LB:\n        score += 1_000_000_000\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Validate \/ seed\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    def total_conflicts(arr):\n        return sum(1 for (u, v) in E if arr[u-1] == arr[v-1])\n\n    def best_existing_color(arr, i):\n        # Choose among existing colors only (no new color introduction here)\n        colors = sorted(set(arr))\n        # Evaluate conflicts per candidate\n        vals = []\n        for c in colors:\n            if c == arr[i]:\n                continue\n            val = sum(1 for nb in adj[i] if arr[nb] == c)\n            vals.append((val, c))\n        if not vals:\n            return arr[i]\n        best_val = min(v for v, _ in vals)\n        pool = [c for v, c in vals if v == best_val]\n        return random.choice(pool)\n\n    per_conf = [per_vertex_conflicts(sol, i) for i in range(V)]\n    tot_conf = total_conflicts(sol)\n\n    move_types = []\n    if tot_conf > 0:\n        move_types.extend([\"Recolor\", \"Kempe\", \"Recolor\", \"Kempe\"])  # biased to resolve conflicts\n    else:\n        move_types.extend([\"Recolor\", \"ClassSwap\"])  # diversify on plateau without increasing colors\n    move = random.choice(move_types)\n\n    new_sol = list(sol)\n    nb_meta = (\"UNKNOWN\", \"UNKNOWN\")\n\n    if move == \"Recolor\":\n        # Pick a conflicted vertex if any, else random\n        if tot_conf > 0:\n            candidates = [i for i in range(V) if per_conf[i] > 0]\n            if not candidates:\n                candidates = list(range(V))\n        else:\n            candidates = list(range(V))\n        i = random.choice(candidates)\n        c_best = best_existing_color(new_sol, i)\n        new_sol[i] = c_best\n        new_sol = canonicalize(new_sol)\n        nb_meta = (\"RECOLOR\", \"SingleVertex\")\n\n    elif move == \"Kempe\":\n        # Two-color Kempe-chain swap restricted to existing colors\n        colors = sorted(set(new_sol))\n        # seed biased to conflicted vertices when available\n        conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n        seed = random.choice(conflict_vertices) if conflict_vertices else random.randrange(V)\n        a = new_sol[seed]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            # Fallback recolor\n            c_best = best_existing_color(new_sol, seed)\n            new_sol[seed] = c_best\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback\")\n        else:\n            b = random.choice(b_choices)\n            comp = set()\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                if v in comp:\n                    continue\n                if new_sol[v] in (a, b):\n                    comp.add(v)\n                    for nb in adj[v]:\n                        if new_sol[nb] in (a, b) and nb not in comp:\n                            stack.append(nb)\n            for v in comp:\n                new_sol[v] = a if new_sol[v] == b else b\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"KEMPE_SWAP\", \"TwoColorComponent\")\n\n    else:  # ClassSwap\n        colors = sorted(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            for i in range(V):\n                if new_sol[i] == c1:\n                    new_sol[i] = c2\n                elif new_sol[i] == c2:\n                    new_sol[i] = c1\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"COLOR_CLASS_SWAP\", \"GlobalRelabel\")\n        else:\n            # Fallback recolor\n            i = random.randrange(V)\n            c_best = best_existing_color(new_sol, i)\n            new_sol[i] = c_best\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback2\")\n\n    # Return neighbor and metadata (for TS\/analytics), while signature annotation documents meta types\n    return (new_sol, nb_meta)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Seed and canonicalize\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Perform a small number of randomized moves without introducing new colors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        move = random.choices([\"Kempe\", \"Recolor\"], weights=[0.7, 0.3], k=1)[0]\n        if move == \"Kempe\":\n            colors = sorted(set(sol))\n            conflict_vertices = [i for i in range(V) if per_vertex_conflicts(sol, i) > 0]\n            seed = random.choice(conflict_vertices) if conflict_vertices else random.randrange(V)\n            a = sol[seed]\n            b_candidates = [c for c in colors if c != a]\n            if not b_candidates:\n                continue\n            b = random.choice(b_candidates)\n            comp = set([seed])\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                for nb in adj[v]:\n                    if sol[nb] in (a, b) and nb not in comp:\n                        comp.add(nb)\n                        stack.append(nb)\n            for v in comp:\n                sol[v] = a if sol[v] == b else b\n        else:\n            i = random.randrange(V)\n            palette = sorted(set(sol))\n            if len(palette) > 1:\n                choices = [c for c in palette if c != sol[i]]\n                if choices:\n                    sol[i] = random.choice(choices)\n\n    # Occasional color-class shuffle for diversification (does not change K)\n    if random.random() < 0.4:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[idx] for idx, c in enumerate(colors)}\n            sol = [mapping[c] for c in sol]\n\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001546535}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_student_groups_standard","Representacion":"List of 9 positive integers. Index i (0-based) corresponds to vertex i+1. Each entry is a color label in {1,...,K}. Colors are canonicalized to contiguous 1..K by ordering color classes by the smallest vertex index they occupy (stable canonicalization). Example: [1,2,2,3,3,2,1,1,3].","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    LB = 3\n\n    # Basic validation\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        return 10**12\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**12\n\n    # Stable canonicalization by increasing smallest vertex index per color\n    color_to_min_idx = {}\n    for idx, c in enumerate(solution):\n        if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n            color_to_min_idx[c] = idx\n    ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n    remap = {c: i+1 for i, c in enumerate(ordered_colors)}\n    canon = [remap[c] for c in solution]\n\n    # Count conflicts over edges\n    conflicts = 0\n    for (u, v) in E:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n\n    K = max(canon) if canon else 0\n\n    # Scoring: primary minimize conflicts (dominant), secondary minimize K; enforce LB\n    score = conflicts * 1_000_000 + K\n    if K < LB:\n        score += 1_000_000_000\n    return score\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    # Build adjacency list\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Validate \/ seed\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    def total_conflicts(arr):\n        return sum(1 for (u, v) in E if arr[u-1] == arr[v-1])\n\n    def best_existing_color(arr, i):\n        # Choose among existing colors only (no new color introduction here)\n        colors = sorted(set(arr))\n        # Evaluate conflicts per candidate\n        vals = []\n        for c in colors:\n            if c == arr[i]:\n                continue\n            val = sum(1 for nb in adj[i] if arr[nb] == c)\n            vals.append((val, c))\n        if not vals:\n            return arr[i]\n        best_val = min(v for v, _ in vals)\n        pool = [c for v, c in vals if v == best_val]\n        return random.choice(pool)\n\n    per_conf = [per_vertex_conflicts(sol, i) for i in range(V)]\n    tot_conf = total_conflicts(sol)\n\n    move_types = []\n    if tot_conf > 0:\n        move_types.extend([\"Recolor\", \"Kempe\", \"Recolor\", \"Kempe\"])  # biased to resolve conflicts\n    else:\n        move_types.extend([\"Recolor\", \"ClassSwap\"])  # diversify on plateau without increasing colors\n    move = random.choice(move_types)\n\n    new_sol = list(sol)\n    nb_meta = (\"UNKNOWN\", \"UNKNOWN\")\n\n    if move == \"Recolor\":\n        # Pick a conflicted vertex if any, else random\n        if tot_conf > 0:\n            candidates = [i for i in range(V) if per_conf[i] > 0]\n            if not candidates:\n                candidates = list(range(V))\n        else:\n            candidates = list(range(V))\n        i = random.choice(candidates)\n        c_best = best_existing_color(new_sol, i)\n        new_sol[i] = c_best\n        new_sol = canonicalize(new_sol)\n        nb_meta = (\"RECOLOR\", \"SingleVertex\")\n\n    elif move == \"Kempe\":\n        # Two-color Kempe-chain swap restricted to existing colors\n        colors = sorted(set(new_sol))\n        # seed biased to conflicted vertices when available\n        conflict_vertices = [i for i in range(V) if per_conf[i] > 0]\n        seed = random.choice(conflict_vertices) if conflict_vertices else random.randrange(V)\n        a = new_sol[seed]\n        b_choices = [c for c in colors if c != a]\n        if not b_choices:\n            # Fallback recolor\n            c_best = best_existing_color(new_sol, seed)\n            new_sol[seed] = c_best\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback\")\n        else:\n            b = random.choice(b_choices)\n            comp = set()\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                if v in comp:\n                    continue\n                if new_sol[v] in (a, b):\n                    comp.add(v)\n                    for nb in adj[v]:\n                        if new_sol[nb] in (a, b) and nb not in comp:\n                            stack.append(nb)\n            for v in comp:\n                new_sol[v] = a if new_sol[v] == b else b\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"KEMPE_SWAP\", \"TwoColorComponent\")\n\n    else:  # ClassSwap\n        colors = sorted(set(new_sol))\n        if len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            for i in range(V):\n                if new_sol[i] == c1:\n                    new_sol[i] = c2\n                elif new_sol[i] == c2:\n                    new_sol[i] = c1\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"COLOR_CLASS_SWAP\", \"GlobalRelabel\")\n        else:\n            # Fallback recolor\n            i = random.randrange(V)\n            c_best = best_existing_color(new_sol, i)\n            new_sol[i] = c_best\n            new_sol = canonicalize(new_sol)\n            nb_meta = (\"RECOLOR\", \"SingleVertex-Fallback2\")\n\n    # Return neighbor and metadata (for TS\/analytics), while signature annotation documents meta types\n    return (new_sol, nb_meta)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded graph data\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Canonicalization helper\n    def canonicalize(arr):\n        color_to_min_idx = {}\n        for idx, c in enumerate(arr):\n            if c not in color_to_min_idx or idx < color_to_min_idx[c]:\n                color_to_min_idx[c] = idx\n        ordered_colors = [c for c, _ in sorted(color_to_min_idx.items(), key=lambda kv: kv[1])]\n        remap0 = {c: i+1 for i, c in enumerate(ordered_colors)}\n        return [remap0[c] for c in arr]\n\n    # Build adjacency\n    adj = [[] for _ in range(V)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Seed and canonicalize\n    if not isinstance(solution, (list, tuple)) or len(solution) != V:\n        sol = [random.randint(1, 3) for _ in range(V)]\n    else:\n        sol = list(solution)\n    sol = canonicalize(sol)\n\n    def per_vertex_conflicts(arr, i):\n        c = arr[i]\n        return sum(1 for nb in adj[i] if arr[nb] == c)\n\n    # Perform a small number of randomized moves without introducing new colors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        move = random.choices([\"Kempe\", \"Recolor\"], weights=[0.7, 0.3], k=1)[0]\n        if move == \"Kempe\":\n            colors = sorted(set(sol))\n            conflict_vertices = [i for i in range(V) if per_vertex_conflicts(sol, i) > 0]\n            seed = random.choice(conflict_vertices) if conflict_vertices else random.randrange(V)\n            a = sol[seed]\n            b_candidates = [c for c in colors if c != a]\n            if not b_candidates:\n                continue\n            b = random.choice(b_candidates)\n            comp = set([seed])\n            stack = [seed]\n            while stack:\n                v = stack.pop()\n                for nb in adj[v]:\n                    if sol[nb] in (a, b) and nb not in comp:\n                        comp.add(nb)\n                        stack.append(nb)\n            for v in comp:\n                sol[v] = a if sol[v] == b else b\n        else:\n            i = random.randrange(V)\n            palette = sorted(set(sol))\n            if len(palette) > 1:\n                choices = [c for c in palette if c != sol[i]]\n                if choices:\n                    sol[i] = random.choice(choices)\n\n    # Occasional color-class shuffle for diversification (does not change K)\n    if random.random() < 0.4:\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            perm = colors[:]\n            random.shuffle(perm)\n            mapping = {c: perm[idx] for idx, c in enumerate(colors)}\n            sol = [mapping[c] for c in sol]\n\n    sol = canonicalize(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001424515}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize type\/size issues, nonpositive labels, conflicts, gaps; then number of colors\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PEN_CONFLICT = 10**6\n    PEN_INVALID = 10**6\n    PEN_GAPS = 10**3\n    PEN_TYPE = 10**9\n    # Type\/len\n    if not isinstance(solution, list) or len(solution) != n:\n        return PEN_TYPE\n    # Int check and collect\n    invalid_type = 0\n    vals = []\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        else:\n            vals.append(x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n    # Nonpositive colors\n    nonpos = sum(1 for x in vals if x <= 0)\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if vals[u-1] == vals[v-1]:\n            conflicts += 1\n    # Gaps\/compactness and color count\n    pos_vals = [x for x in vals if x > 0]\n    if pos_vals:\n        distinct = sorted(set(pos_vals))\n        k_used = len(distinct)\n        max_c = max(pos_vals)\n        expected = set(range(1, max_c+1))\n        gaps = len(expected - set(pos_vals))\n        if 1 not in distinct:\n            gaps += 1\n    else:\n        k_used = 0\n        gaps = 1\n    fitness = (\n        PEN_INVALID * nonpos +\n        PEN_CONFLICT * conflicts +\n        PEN_GAPS * gaps +\n        k_used\n    )\n    return fitness\n","Vecindad":"import random\nimport copy\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type: 'Local'; Movement_Type: 'RecolorOne' or 'SwapKempeLike'\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    def adj_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compact_labels(sol):\n        # Relabel colors to 1..k in order of appearance for compactness deterministically\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    adj = adj_list(n, edges)\n    s = list(solution)\n\n    if not s or not all(isinstance(x, int) for x in s) or len(s) != n:\n        return (s, \"Local\", \"NoOp\")\n\n    move = random.random()\n\n    if move < 0.7:\n        # Recolor a single vertex to the smallest feasible color (attempt to reduce palette)\n        v = random.randint(1, n)\n        used = {s[u-1] for u in adj[v]}\n        # Try colors starting from 1\n        new_color = None\n        for c in range(1, max(used.union({0})) + 2):\n            if c not in used:\n                new_color = c\n                break\n        ns = s[:]\n        ns[v-1] = new_color if new_color is not None else s[v-1]\n        ns = compact_labels(ns)\n        return (ns, \"Local\", \"RecolorOne\")\n    else:\n        # Kempe-like swap between two colors on a connected component of the bi-colored subgraph\n        # Pick two distinct colors present\n        colors = list(set(s))\n        if len(colors) < 2:\n            return (s[:], \"Local\", \"NoOp\")\n        c1, c2 = random.sample(colors, 2)\n        # pick a random start vertex having color c1 or c2\n        cand = [i+1 for i,x in enumerate(s) if x == c1 or x == c2]\n        if not cand:\n            return (s[:], \"Local\", \"NoOp\")\n        start = random.choice(cand)\n        # BFS on subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([start])\n        visited = set([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and (s[w-1] == c1 or s[w-1] == c2):\n                    visited.add(w)\n                    q.append(w)\n        ns = s[:]\n        for u in visited:\n            ns[u-1] = c2 if s[u-1] == c1 else (c1 if s[u-1] == c2 else s[u-1])\n        ns = compact_labels(ns)\n        return (ns, \"Local\", \"SwapKempeLike\")\n","Perturbacion":"import random\nimport copy\n\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + occasional random relabel shuffle\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    def adj_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compact_labels(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    s = list(solution)\n    if not s or len(s) != n or not all(isinstance(x, int) for x in s):\n        return s\n\n    adj = adj_list(n, edges)\n\n    # Number of vertices to modify\n    t = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), t)\n\n    ns = s[:]\n    for i in idxs:\n        v = i + 1\n        used = {ns[u-1] for u in adj[v]}\n        # allow a broader random palette around current max to escape local minima\n        palette_upper = max(used.union(set(ns))) + 1\n        # Bias to smaller colors\n        candidates = [c for c in range(1, palette_upper+1) if c not in used]\n        if not candidates:\n            continue\n        if random.random() < 0.7:\n            new_c = min(candidates)\n        else:\n            new_c = random.choice(candidates)\n        ns[i] = new_c\n\n    # Occasional color label shuffle to alter landscape without changing feasibility\n    if random.random() < 0.5:\n        colors = sorted(set(ns))\n        perm = colors[:]\n        random.shuffle(perm)\n        relabel = {c: p for c, p in zip(colors, perm)}\n        ns = [relabel[x] for x in ns]\n\n    ns = compact_labels(ns)\n    return ns\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000848559}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize type\/size issues, nonpositive labels, conflicts, gaps; then number of colors\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PEN_CONFLICT = 10**6\n    PEN_INVALID = 10**6\n    PEN_GAPS = 10**3\n    PEN_TYPE = 10**9\n    # Type\/len\n    if not isinstance(solution, list) or len(solution) != n:\n        return PEN_TYPE\n    # Int check and collect\n    invalid_type = 0\n    vals = []\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        else:\n            vals.append(x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n    # Nonpositive colors\n    nonpos = sum(1 for x in vals if x <= 0)\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if vals[u-1] == vals[v-1]:\n            conflicts += 1\n    # Gaps\/compactness and color count\n    pos_vals = [x for x in vals if x > 0]\n    if pos_vals:\n        distinct = sorted(set(pos_vals))\n        k_used = len(distinct)\n        max_c = max(pos_vals)\n        expected = set(range(1, max_c+1))\n        gaps = len(expected - set(pos_vals))\n        if 1 not in distinct:\n            gaps += 1\n    else:\n        k_used = 0\n        gaps = 1\n    fitness = (\n        PEN_INVALID * nonpos +\n        PEN_CONFLICT * conflicts +\n        PEN_GAPS * gaps +\n        k_used\n    )\n    return fitness\n","Vecindad":"import random\nimport copy\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type: 'Local'; Movement_Type: 'RecolorOne' or 'SwapKempeLike'\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    def adj_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compact_labels(sol):\n        # Relabel colors to 1..k in order of appearance for compactness deterministically\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    adj = adj_list(n, edges)\n    s = list(solution)\n\n    if not s or not all(isinstance(x, int) for x in s) or len(s) != n:\n        return (s, \"Local\", \"NoOp\")\n\n    move = random.random()\n\n    if move < 0.7:\n        # Recolor a single vertex to the smallest feasible color (attempt to reduce palette)\n        v = random.randint(1, n)\n        used = {s[u-1] for u in adj[v]}\n        # Try colors starting from 1\n        new_color = None\n        for c in range(1, max(used.union({0})) + 2):\n            if c not in used:\n                new_color = c\n                break\n        ns = s[:]\n        ns[v-1] = new_color if new_color is not None else s[v-1]\n        ns = compact_labels(ns)\n        return (ns, \"Local\", \"RecolorOne\")\n    else:\n        # Kempe-like swap between two colors on a connected component of the bi-colored subgraph\n        # Pick two distinct colors present\n        colors = list(set(s))\n        if len(colors) < 2:\n            return (s[:], \"Local\", \"NoOp\")\n        c1, c2 = random.sample(colors, 2)\n        # pick a random start vertex having color c1 or c2\n        cand = [i+1 for i,x in enumerate(s) if x == c1 or x == c2]\n        if not cand:\n            return (s[:], \"Local\", \"NoOp\")\n        start = random.choice(cand)\n        # BFS on subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([start])\n        visited = set([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and (s[w-1] == c1 or s[w-1] == c2):\n                    visited.add(w)\n                    q.append(w)\n        ns = s[:]\n        for u in visited:\n            ns[u-1] = c2 if s[u-1] == c1 else (c1 if s[u-1] == c2 else s[u-1])\n        ns = compact_labels(ns)\n        return (ns, \"Local\", \"SwapKempeLike\")\n","Perturbacion":"import random\nimport copy\n\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + occasional random relabel shuffle\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    def adj_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compact_labels(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    s = list(solution)\n    if not s or len(s) != n or not all(isinstance(x, int) for x in s):\n        return s\n\n    adj = adj_list(n, edges)\n\n    # Number of vertices to modify\n    t = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), t)\n\n    ns = s[:]\n    for i in idxs:\n        v = i + 1\n        used = {ns[u-1] for u in adj[v]}\n        # allow a broader random palette around current max to escape local minima\n        palette_upper = max(used.union(set(ns))) + 1\n        # Bias to smaller colors\n        candidates = [c for c in range(1, palette_upper+1) if c not in used]\n        if not candidates:\n            continue\n        if random.random() < 0.7:\n            new_c = min(candidates)\n        else:\n            new_c = random.choice(candidates)\n        ns[i] = new_c\n\n    # Occasional color label shuffle to alter landscape without changing feasibility\n    if random.random() < 0.5:\n        colors = sorted(set(ns))\n        perm = colors[:]\n        random.shuffle(perm)\n        relabel = {c: p for c, p in zip(colors, perm)}\n        ns = [relabel[x] for x in ns]\n\n    ns = compact_labels(ns)\n    return ns\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001057221}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize type\/size issues, nonpositive labels, conflicts, gaps; then number of colors\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PEN_CONFLICT = 10**6\n    PEN_INVALID = 10**6\n    PEN_GAPS = 10**3\n    PEN_TYPE = 10**9\n    # Type\/len\n    if not isinstance(solution, list) or len(solution) != n:\n        return PEN_TYPE\n    # Int check and collect\n    invalid_type = 0\n    vals = []\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        else:\n            vals.append(x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n    # Nonpositive colors\n    nonpos = sum(1 for x in vals if x <= 0)\n    # Conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if vals[u-1] == vals[v-1]:\n            conflicts += 1\n    # Gaps\/compactness and color count\n    pos_vals = [x for x in vals if x > 0]\n    if pos_vals:\n        distinct = sorted(set(pos_vals))\n        k_used = len(distinct)\n        max_c = max(pos_vals)\n        expected = set(range(1, max_c+1))\n        gaps = len(expected - set(pos_vals))\n        if 1 not in distinct:\n            gaps += 1\n    else:\n        k_used = 0\n        gaps = 1\n    fitness = (\n        PEN_INVALID * nonpos +\n        PEN_CONFLICT * conflicts +\n        PEN_GAPS * gaps +\n        k_used\n    )\n    return fitness\n","Vecindad":"import random\nimport copy\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type: 'Local'; Movement_Type: 'RecolorOne' or 'SwapKempeLike'\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    def adj_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compact_labels(sol):\n        # Relabel colors to 1..k in order of appearance for compactness deterministically\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    adj = adj_list(n, edges)\n    s = list(solution)\n\n    if not s or not all(isinstance(x, int) for x in s) or len(s) != n:\n        return (s, \"Local\", \"NoOp\")\n\n    move = random.random()\n\n    if move < 0.7:\n        # Recolor a single vertex to the smallest feasible color (attempt to reduce palette)\n        v = random.randint(1, n)\n        used = {s[u-1] for u in adj[v]}\n        # Try colors starting from 1\n        new_color = None\n        for c in range(1, max(used.union({0})) + 2):\n            if c not in used:\n                new_color = c\n                break\n        ns = s[:]\n        ns[v-1] = new_color if new_color is not None else s[v-1]\n        ns = compact_labels(ns)\n        return (ns, \"Local\", \"RecolorOne\")\n    else:\n        # Kempe-like swap between two colors on a connected component of the bi-colored subgraph\n        # Pick two distinct colors present\n        colors = list(set(s))\n        if len(colors) < 2:\n            return (s[:], \"Local\", \"NoOp\")\n        c1, c2 = random.sample(colors, 2)\n        # pick a random start vertex having color c1 or c2\n        cand = [i+1 for i,x in enumerate(s) if x == c1 or x == c2]\n        if not cand:\n            return (s[:], \"Local\", \"NoOp\")\n        start = random.choice(cand)\n        # BFS on subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([start])\n        visited = set([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and (s[w-1] == c1 or s[w-1] == c2):\n                    visited.add(w)\n                    q.append(w)\n        ns = s[:]\n        for u in visited:\n            ns[u-1] = c2 if s[u-1] == c1 else (c1 if s[u-1] == c2 else s[u-1])\n        ns = compact_labels(ns)\n        return (ns, \"Local\", \"SwapKempeLike\")\n","Perturbacion":"import random\nimport copy\n\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + occasional random relabel shuffle\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    def adj_list(n, edges):\n        adj = {i: set() for i in range(1, n+1)}\n        for u,v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n\n    def compact_labels(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    s = list(solution)\n    if not s or len(s) != n or not all(isinstance(x, int) for x in s):\n        return s\n\n    adj = adj_list(n, edges)\n\n    # Number of vertices to modify\n    t = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), t)\n\n    ns = s[:]\n    for i in idxs:\n        v = i + 1\n        used = {ns[u-1] for u in adj[v]}\n        # allow a broader random palette around current max to escape local minima\n        palette_upper = max(used.union(set(ns))) + 1\n        # Bias to smaller colors\n        candidates = [c for c in range(1, palette_upper+1) if c not in used]\n        if not candidates:\n            continue\n        if random.random() < 0.7:\n            new_c = min(candidates)\n        else:\n            new_c = random.choice(candidates)\n        ns[i] = new_c\n\n    # Occasional color label shuffle to alter landscape without changing feasibility\n    if random.random() < 0.5:\n        colors = sorted(set(ns))\n        perm = colors[:]\n        random.shuffle(perm)\n        relabel = {c: p for c, p in zip(colors, perm)}\n        ns = [relabel[x] for x in ns]\n\n    ns = compact_labels(ns)\n    return ns\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001030201}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize invalids and conflicts heavily; compactness\/gaps only if conflict-free\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PEN_CONFLICT = 10**6\n    PEN_INVALID = 10**6\n    PEN_GAPS = 10**2  # reduced to avoid distracting search while infeasible\n    PEN_TYPE = 10**9\n\n    # Type\/len\n    if not isinstance(solution, list) or len(solution) != n:\n        return PEN_TYPE\n\n    # Int check and collect\n    invalid_type = 0\n    vals = []\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        else:\n            vals.append(x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Nonpositive colors\n    nonpos = sum(1 for x in vals if x <= 0)\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # Canonical relabel for evaluation (does not modify input)\n    def canonical_k_used(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in arr:\n            if x <= 0:\n                out.append(x)\n                continue\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return len(set(c for c in out if isinstance(c, int) and c > 0))\n\n    k_used = canonical_k_used(vals)\n\n    # Gap penalty only when conflict-free\n    gaps = 0\n    if conflicts == 0:\n        pos_vals = [x for x in vals if x > 0]\n        if pos_vals:\n            rel = {}\n            nxt = 1\n            canon = []\n            for x in pos_vals:\n                if x not in rel:\n                    rel[x] = nxt\n                    nxt += 1\n                canon.append(rel[x])\n            max_c = max(canon)\n            expected = set(range(1, max_c + 1))\n            gaps = len(expected - set(canon))\n        else:\n            gaps = 1\n\n    fitness = (\n        PEN_INVALID * nonpos +\n        PEN_CONFLICT * conflicts +\n        PEN_GAPS * gaps +\n        k_used\n    )\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, meta_dict) to be compatible with solvers unpacking 2 values\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency once per call\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Guard and clone\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) for x in solution):\n        # Simple repair: map nonpositive to 1\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in list(solution) if isinstance(solution, list)]\n        if len(s) != n:\n            s = [1]*n\n    else:\n        s = solution[:]\n\n    # Helper: compute conflict vertices\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    # Ensure colors remain positive\n    for i in range(n):\n        if s[i] <= 0:\n            s[i] = 1\n\n    meta = {'NB_Type': 'Local', 'Move': 'NoOp'}\n\n    # Choose move type with retries for diversity\n    move = random.random()\n\n    # Conflict-driven recolor (70%)\n    if move < 0.7:\n        cvs = conflict_vertices(s)\n        if cvs:\n            v = random.choice(cvs)\n        else:\n            v = random.randint(1, n)\n        forbidden = {s[u - 1] for u in adj[v]}\n        # Candidate palette: bias to small colors, add current max+1 for expansion\n        palette_upper = max(max(s), len(set(s))) + 1\n        candidates = [c for c in range(1, palette_upper + 1) if c not in forbidden]\n        if not candidates:\n            return (s[:], meta)\n        # Stochastic choice among top-k smallest candidates\n        k = min(3, len(candidates))\n        pick_from = candidates[:k]\n        new_c = random.choice(pick_from)\n        ns = s[:]\n        ns[v - 1] = new_c\n        # Keep labels stable; no global compaction here\n        meta['Move'] = 'RecolorOne'\n        return (ns, meta)\n\n    # Kempe-like swap with attempts (30%)\n    attempts = 5\n    colors = list(set(s))\n    for _ in range(attempts):\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        cand = [i + 1 for i, x in enumerate(s) if x == c1 or x == c2]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS on bi-colored component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and (s[w - 1] == c1 or s[w - 1] == c2):\n                    visited.add(w)\n                    q.append(w)\n        if visited:\n            ns = s[:]\n            for u in visited:\n                if s[u - 1] == c1:\n                    ns[u - 1] = c2\n                elif s[u - 1] == c2:\n                    ns[u - 1] = c1\n            meta['Move'] = 'SwapKempeLike'\n            return (ns, meta)\n    # Fallback no-op if all else fails\n    return (s[:], meta)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor a subset and optionally relabel colors\n    n_expected = 9\n    if not isinstance(solution, list) or len(solution) != n_expected or not all(isinstance(x, int) for x in solution):\n        return [1]*n_expected\n    s = solution[:]\n\n    # Ensure positivity\n    for i in range(len(s)):\n        if s[i] <= 0:\n            s[i] = 1\n\n    # Modify about n\/3 vertices\n    n = len(s)\n    t = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), t)\n\n    for i in idxs:\n        # Neighbor-forbidden colors are unknown here; just diversify within a range\n        # Use palette up to current max+1\n        palette_upper = max(max(s), len(set(s))) + 1\n        # Bias: 70% pick from small colors {1,2,3}, else from full feasible\n        small = [c for c in range(1, min(3, palette_upper) + 1)]\n        if random.random() < 0.7 and small:\n            s[i] = random.choice(small)\n        else:\n            s[i] = random.randint(1, palette_upper)\n\n    # 50% chance: random relabel (color permutation) to escape plateaus\n    if random.random() < 0.5:\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        relabel = {c: p for c, p in zip(colors, perm)}\n        s = [relabel[x] for x in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001037401}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize invalids and conflicts heavily; compactness\/gaps only if conflict-free\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PEN_CONFLICT = 10**6\n    PEN_INVALID = 10**6\n    PEN_GAPS = 10**2  # reduced to avoid distracting search while infeasible\n    PEN_TYPE = 10**9\n\n    # Type\/len\n    if not isinstance(solution, list) or len(solution) != n:\n        return PEN_TYPE\n\n    # Int check and collect\n    invalid_type = 0\n    vals = []\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        else:\n            vals.append(x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Nonpositive colors\n    nonpos = sum(1 for x in vals if x <= 0)\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # Canonical relabel for evaluation (does not modify input)\n    def canonical_k_used(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in arr:\n            if x <= 0:\n                out.append(x)\n                continue\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return len(set(c for c in out if isinstance(c, int) and c > 0))\n\n    k_used = canonical_k_used(vals)\n\n    # Gap penalty only when conflict-free\n    gaps = 0\n    if conflicts == 0:\n        pos_vals = [x for x in vals if x > 0]\n        if pos_vals:\n            rel = {}\n            nxt = 1\n            canon = []\n            for x in pos_vals:\n                if x not in rel:\n                    rel[x] = nxt\n                    nxt += 1\n                canon.append(rel[x])\n            max_c = max(canon)\n            expected = set(range(1, max_c + 1))\n            gaps = len(expected - set(canon))\n        else:\n            gaps = 1\n\n    fitness = (\n        PEN_INVALID * nonpos +\n        PEN_CONFLICT * conflicts +\n        PEN_GAPS * gaps +\n        k_used\n    )\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, meta_dict) to be compatible with solvers unpacking 2 values\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency once per call\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Guard and clone\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) for x in solution):\n        # Simple repair: map nonpositive to 1\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in list(solution) if isinstance(solution, list)]\n        if len(s) != n:\n            s = [1]*n\n    else:\n        s = solution[:]\n\n    # Helper: compute conflict vertices\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    # Ensure colors remain positive\n    for i in range(n):\n        if s[i] <= 0:\n            s[i] = 1\n\n    meta = {'NB_Type': 'Local', 'Move': 'NoOp'}\n\n    # Choose move type with retries for diversity\n    move = random.random()\n\n    # Conflict-driven recolor (70%)\n    if move < 0.7:\n        cvs = conflict_vertices(s)\n        if cvs:\n            v = random.choice(cvs)\n        else:\n            v = random.randint(1, n)\n        forbidden = {s[u - 1] for u in adj[v]}\n        # Candidate palette: bias to small colors, add current max+1 for expansion\n        palette_upper = max(max(s), len(set(s))) + 1\n        candidates = [c for c in range(1, palette_upper + 1) if c not in forbidden]\n        if not candidates:\n            return (s[:], meta)\n        # Stochastic choice among top-k smallest candidates\n        k = min(3, len(candidates))\n        pick_from = candidates[:k]\n        new_c = random.choice(pick_from)\n        ns = s[:]\n        ns[v - 1] = new_c\n        # Keep labels stable; no global compaction here\n        meta['Move'] = 'RecolorOne'\n        return (ns, meta)\n\n    # Kempe-like swap with attempts (30%)\n    attempts = 5\n    colors = list(set(s))\n    for _ in range(attempts):\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        cand = [i + 1 for i, x in enumerate(s) if x == c1 or x == c2]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS on bi-colored component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and (s[w - 1] == c1 or s[w - 1] == c2):\n                    visited.add(w)\n                    q.append(w)\n        if visited:\n            ns = s[:]\n            for u in visited:\n                if s[u - 1] == c1:\n                    ns[u - 1] = c2\n                elif s[u - 1] == c2:\n                    ns[u - 1] = c1\n            meta['Move'] = 'SwapKempeLike'\n            return (ns, meta)\n    # Fallback no-op if all else fails\n    return (s[:], meta)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor a subset and optionally relabel colors\n    n_expected = 9\n    if not isinstance(solution, list) or len(solution) != n_expected or not all(isinstance(x, int) for x in solution):\n        return [1]*n_expected\n    s = solution[:]\n\n    # Ensure positivity\n    for i in range(len(s)):\n        if s[i] <= 0:\n            s[i] = 1\n\n    # Modify about n\/3 vertices\n    n = len(s)\n    t = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), t)\n\n    for i in idxs:\n        # Neighbor-forbidden colors are unknown here; just diversify within a range\n        # Use palette up to current max+1\n        palette_upper = max(max(s), len(set(s))) + 1\n        # Bias: 70% pick from small colors {1,2,3}, else from full feasible\n        small = [c for c in range(1, min(3, palette_upper) + 1)]\n        if random.random() < 0.7 and small:\n            s[i] = random.choice(small)\n        else:\n            s[i] = random.randint(1, palette_upper)\n\n    # 50% chance: random relabel (color permutation) to escape plateaus\n    if random.random() < 0.5:\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        relabel = {c: p for c, p in zip(colors, perm)}\n        s = [relabel[x] for x in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001104062}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower is better. Penalize invalids and conflicts heavily; compactness\/gaps only if conflict-free\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PEN_CONFLICT = 10**6\n    PEN_INVALID = 10**6\n    PEN_GAPS = 10**2  # reduced to avoid distracting search while infeasible\n    PEN_TYPE = 10**9\n\n    # Type\/len\n    if not isinstance(solution, list) or len(solution) != n:\n        return PEN_TYPE\n\n    # Int check and collect\n    invalid_type = 0\n    vals = []\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n        else:\n            vals.append(x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Nonpositive colors\n    nonpos = sum(1 for x in vals if x <= 0)\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # Canonical relabel for evaluation (does not modify input)\n    def canonical_k_used(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in arr:\n            if x <= 0:\n                out.append(x)\n                continue\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return len(set(c for c in out if isinstance(c, int) and c > 0))\n\n    k_used = canonical_k_used(vals)\n\n    # Gap penalty only when conflict-free\n    gaps = 0\n    if conflicts == 0:\n        pos_vals = [x for x in vals if x > 0]\n        if pos_vals:\n            rel = {}\n            nxt = 1\n            canon = []\n            for x in pos_vals:\n                if x not in rel:\n                    rel[x] = nxt\n                    nxt += 1\n                canon.append(rel[x])\n            max_c = max(canon)\n            expected = set(range(1, max_c + 1))\n            gaps = len(expected - set(canon))\n        else:\n            gaps = 1\n\n    fitness = (\n        PEN_INVALID * nonpos +\n        PEN_CONFLICT * conflicts +\n        PEN_GAPS * gaps +\n        k_used\n    )\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, meta_dict) to be compatible with solvers unpacking 2 values\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency once per call\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Guard and clone\n    if not isinstance(solution, list) or len(solution) != n or not all(isinstance(x, int) for x in solution):\n        # Simple repair: map nonpositive to 1\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in list(solution) if isinstance(solution, list)]\n        if len(s) != n:\n            s = [1]*n\n    else:\n        s = solution[:]\n\n    # Helper: compute conflict vertices\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    # Ensure colors remain positive\n    for i in range(n):\n        if s[i] <= 0:\n            s[i] = 1\n\n    meta = {'NB_Type': 'Local', 'Move': 'NoOp'}\n\n    # Choose move type with retries for diversity\n    move = random.random()\n\n    # Conflict-driven recolor (70%)\n    if move < 0.7:\n        cvs = conflict_vertices(s)\n        if cvs:\n            v = random.choice(cvs)\n        else:\n            v = random.randint(1, n)\n        forbidden = {s[u - 1] for u in adj[v]}\n        # Candidate palette: bias to small colors, add current max+1 for expansion\n        palette_upper = max(max(s), len(set(s))) + 1\n        candidates = [c for c in range(1, palette_upper + 1) if c not in forbidden]\n        if not candidates:\n            return (s[:], meta)\n        # Stochastic choice among top-k smallest candidates\n        k = min(3, len(candidates))\n        pick_from = candidates[:k]\n        new_c = random.choice(pick_from)\n        ns = s[:]\n        ns[v - 1] = new_c\n        # Keep labels stable; no global compaction here\n        meta['Move'] = 'RecolorOne'\n        return (ns, meta)\n\n    # Kempe-like swap with attempts (30%)\n    attempts = 5\n    colors = list(set(s))\n    for _ in range(attempts):\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        cand = [i + 1 for i, x in enumerate(s) if x == c1 or x == c2]\n        if not cand:\n            continue\n        start = random.choice(cand)\n        # BFS on bi-colored component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and (s[w - 1] == c1 or s[w - 1] == c2):\n                    visited.add(w)\n                    q.append(w)\n        if visited:\n            ns = s[:]\n            for u in visited:\n                if s[u - 1] == c1:\n                    ns[u - 1] = c2\n                elif s[u - 1] == c2:\n                    ns[u - 1] = c1\n            meta['Move'] = 'SwapKempeLike'\n            return (ns, meta)\n    # Fallback no-op if all else fails\n    return (s[:], meta)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor a subset and optionally relabel colors\n    n_expected = 9\n    if not isinstance(solution, list) or len(solution) != n_expected or not all(isinstance(x, int) for x in solution):\n        return [1]*n_expected\n    s = solution[:]\n\n    # Ensure positivity\n    for i in range(len(s)):\n        if s[i] <= 0:\n            s[i] = 1\n\n    # Modify about n\/3 vertices\n    n = len(s)\n    t = max(1, n \/\/ 3)\n    idxs = random.sample(range(n), t)\n\n    for i in idxs:\n        # Neighbor-forbidden colors are unknown here; just diversify within a range\n        # Use palette up to current max+1\n        palette_upper = max(max(s), len(set(s))) + 1\n        # Bias: 70% pick from small colors {1,2,3}, else from full feasible\n        small = [c for c in range(1, min(3, palette_upper) + 1)]\n        if random.random() < 0.7 and small:\n            s[i] = random.choice(small)\n        else:\n            s[i] = random.randint(1, palette_upper)\n\n    # 50% chance: random relabel (color permutation) to escape plateaus\n    if random.random() < 0.5:\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        relabel = {c: p for c, p in zip(colors, perm)}\n        s = [relabel[x] for x in s]\n\n    return s\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001068731}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Problem constants\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Penalties and weights (lower is better)\n    PEN_TYPE = 10**9\n    PEN_LEN = 10**9\n    PEN_INVALID = 10**6\n    PEN_CONFLICT = 10**6\n    PEN_GAPS = 10**2\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    # Validate entries and coerce nonpositive to 1 to avoid double-penalization\n    vals = []\n    invalid_type = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n            vals.append(1)\n        else:\n            vals.append(1 if x <= 0 else x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # k used under canonical relabel (stable to gaps\/permutations)\n    def k_used_canonical(arr):\n        mapping = {}\n        nxt = 1\n        for x in arr:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n        return len(mapping)\n\n    k_used = k_used_canonical(vals)\n\n    # Gaps only if conflict-free: encourage compact 1..k when feasible\n    gaps = 0\n    if conflicts == 0:\n        # Canonical relabel sequence\n        mapping = {}\n        nxt = 1\n        canon = []\n        for x in vals:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            canon.append(mapping[x])\n        max_c = max(canon) if canon else 0\n        expected = set(range(1, max_c + 1))\n        gaps = len(expected - set(canon))\n\n    fitness = PEN_CONFLICT * conflicts + PEN_GAPS * gaps + k_used\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency (local, no globals)\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Guard and clone; repair to positive ints\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = []\n        for x in solution:\n            if isinstance(x, int) and x > 0:\n                s.append(x)\n            else:\n                s.append(1)\n\n    def conflicts_list(sol):\n        out = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                out.append((u, v))\n        return out\n\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    # Ensure palette bounds\n    if not s:\n        s = [1] * n\n    for i in range(n):\n        if s[i] <= 0:\n            s[i] = 1\n\n    # Move selection\n    move_rand = random.random()\n\n    # Strategy A: Conflict-driven recolor (priority)\n    if move_rand < 0.7:\n        cvs = conflict_vertices(s)\n        v = random.choice(cvs) if cvs else random.randint(1, n)\n        forbidden = {s[u - 1] for u in adj[v]}\n        current_max = max(s)\n        # Try to avoid palette bloat: expand only if no feasible color\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n        # Prefer smallest feasible color; slight randomness among up to top-3\n        k = min(3, len(candidates))\n        pick_from = candidates[:k]\n        new_c = random.choice(pick_from)\n        ns = s[:]\n        ns[v - 1] = new_c\n        return (ns, (\"Local\", \"RecolorOne\"))\n\n    # Strategy B: Kempe-like swap between two colors\n    colors = list(set(s))\n    attempts = 5\n    for _ in range(attempts):\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        # Prefer components touching conflicts if any\n        cvs = set(conflict_vertices(s))\n        cand_vertices = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n        if not cand_vertices:\n            continue\n        touch_conf = [v for v in cand_vertices if v in cvs]\n        start = random.choice(touch_conf if touch_conf else cand_vertices)\n        # BFS over bi-colored component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and s[w - 1] in (c1, c2):\n                    visited.add(w)\n                    q.append(w)\n        if not visited:\n            continue\n        ns = s[:]\n        for u in visited:\n            ns[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n        return (ns, (\"Local\", \"SwapKempeLike\"))\n\n    # Fallback: random vertex recolor to smallest feasible\n    v = random.randint(1, n)\n    forbidden = {s[u - 1] for u in adj[v]}\n    current_max = max(s)\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if not candidates:\n        candidates = [current_max + 1]\n    ns = s[:]\n    ns[v - 1] = min(candidates)\n    return (ns, (\"Local\", \"RecolorFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor a subset with DSATUR bias + optional Kempe flip\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Repair\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def dsatur_order(sol):\n        # Returns vertices sorted by saturation degree then degree\n        colors = {i + 1: sol[i] for i in range(n)}\n        sat = {}\n        for v in range(1, n + 1):\n            sat[v] = len({colors[u] for u in adj[v]})\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        return sorted(range(1, n + 1), key=lambda v: (-sat[v], -deg[v], v))\n\n    # Select t vertices biased towards high saturation or conflicts\n    t = max(2, n \/\/ 3)\n    # Conflicted vertices if any\n    conflicted = set()\n    for (u, v) in edges:\n        if s[u - 1] == s[v - 1]:\n            conflicted.add(u)\n            conflicted.add(v)\n    order = dsatur_order(s)\n    pool = list(conflicted) + [v for v in order if v not in conflicted]\n    pool = pool[:max(t * 2, t)] if pool else list(range(1, n + 1))\n    idxs = sorted(random.sample(pool, min(t, len(pool))))\n\n    current_max = max(s)\n    for v in idxs:\n        forbidden = {s[u - 1] for u in adj[v]}\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n            current_max = max(current_max, candidates[0])\n        # 70% choose smallest feasible, else random feasible to diversify\n        new_c = (min(candidates) if random.random() < 0.7 else random.choice(candidates))\n        s[v - 1] = new_c\n\n    # 50% chance: Kempe chain flip between two most frequent colors\n    if random.random() < 0.5:\n        freq = {}\n        for x in s:\n            freq[x] = freq.get(x, 0) + 1\n        if len(freq) >= 2:\n            colors_sorted = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))\n            c1 = colors_sorted[0][0]\n            c2 = colors_sorted[1][0]\n            # Start from a random vertex of c1 or c2\n            candidates = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                visited = set([start])\n                q = deque([start])\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if w not in visited and s[w - 1] in (c1, c2):\n                            visited.add(w)\n                            q.append(w)\n                # Flip colors on this component\n                for u in visited:\n                    s[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n\n    # Final compact relabel (stabilize k without affecting feasibility)\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        s[i] = mapping[c]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000980041}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Problem constants\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Penalties and weights (lower is better)\n    PEN_TYPE = 10**9\n    PEN_LEN = 10**9\n    PEN_INVALID = 10**6\n    PEN_CONFLICT = 10**6\n    PEN_GAPS = 10**2\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    # Validate entries and coerce nonpositive to 1 to avoid double-penalization\n    vals = []\n    invalid_type = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n            vals.append(1)\n        else:\n            vals.append(1 if x <= 0 else x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # k used under canonical relabel (stable to gaps\/permutations)\n    def k_used_canonical(arr):\n        mapping = {}\n        nxt = 1\n        for x in arr:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n        return len(mapping)\n\n    k_used = k_used_canonical(vals)\n\n    # Gaps only if conflict-free: encourage compact 1..k when feasible\n    gaps = 0\n    if conflicts == 0:\n        # Canonical relabel sequence\n        mapping = {}\n        nxt = 1\n        canon = []\n        for x in vals:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            canon.append(mapping[x])\n        max_c = max(canon) if canon else 0\n        expected = set(range(1, max_c + 1))\n        gaps = len(expected - set(canon))\n\n    fitness = PEN_CONFLICT * conflicts + PEN_GAPS * gaps + k_used\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency (local, no globals)\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Guard and clone; repair to positive ints\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = []\n        for x in solution:\n            if isinstance(x, int) and x > 0:\n                s.append(x)\n            else:\n                s.append(1)\n\n    def conflicts_list(sol):\n        out = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                out.append((u, v))\n        return out\n\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    # Ensure palette bounds\n    if not s:\n        s = [1] * n\n    for i in range(n):\n        if s[i] <= 0:\n            s[i] = 1\n\n    # Move selection\n    move_rand = random.random()\n\n    # Strategy A: Conflict-driven recolor (priority)\n    if move_rand < 0.7:\n        cvs = conflict_vertices(s)\n        v = random.choice(cvs) if cvs else random.randint(1, n)\n        forbidden = {s[u - 1] for u in adj[v]}\n        current_max = max(s)\n        # Try to avoid palette bloat: expand only if no feasible color\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n        # Prefer smallest feasible color; slight randomness among up to top-3\n        k = min(3, len(candidates))\n        pick_from = candidates[:k]\n        new_c = random.choice(pick_from)\n        ns = s[:]\n        ns[v - 1] = new_c\n        return (ns, (\"Local\", \"RecolorOne\"))\n\n    # Strategy B: Kempe-like swap between two colors\n    colors = list(set(s))\n    attempts = 5\n    for _ in range(attempts):\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        # Prefer components touching conflicts if any\n        cvs = set(conflict_vertices(s))\n        cand_vertices = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n        if not cand_vertices:\n            continue\n        touch_conf = [v for v in cand_vertices if v in cvs]\n        start = random.choice(touch_conf if touch_conf else cand_vertices)\n        # BFS over bi-colored component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and s[w - 1] in (c1, c2):\n                    visited.add(w)\n                    q.append(w)\n        if not visited:\n            continue\n        ns = s[:]\n        for u in visited:\n            ns[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n        return (ns, (\"Local\", \"SwapKempeLike\"))\n\n    # Fallback: random vertex recolor to smallest feasible\n    v = random.randint(1, n)\n    forbidden = {s[u - 1] for u in adj[v]}\n    current_max = max(s)\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if not candidates:\n        candidates = [current_max + 1]\n    ns = s[:]\n    ns[v - 1] = min(candidates)\n    return (ns, (\"Local\", \"RecolorFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor a subset with DSATUR bias + optional Kempe flip\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Repair\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def dsatur_order(sol):\n        # Returns vertices sorted by saturation degree then degree\n        colors = {i + 1: sol[i] for i in range(n)}\n        sat = {}\n        for v in range(1, n + 1):\n            sat[v] = len({colors[u] for u in adj[v]})\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        return sorted(range(1, n + 1), key=lambda v: (-sat[v], -deg[v], v))\n\n    # Select t vertices biased towards high saturation or conflicts\n    t = max(2, n \/\/ 3)\n    # Conflicted vertices if any\n    conflicted = set()\n    for (u, v) in edges:\n        if s[u - 1] == s[v - 1]:\n            conflicted.add(u)\n            conflicted.add(v)\n    order = dsatur_order(s)\n    pool = list(conflicted) + [v for v in order if v not in conflicted]\n    pool = pool[:max(t * 2, t)] if pool else list(range(1, n + 1))\n    idxs = sorted(random.sample(pool, min(t, len(pool))))\n\n    current_max = max(s)\n    for v in idxs:\n        forbidden = {s[u - 1] for u in adj[v]}\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n            current_max = max(current_max, candidates[0])\n        # 70% choose smallest feasible, else random feasible to diversify\n        new_c = (min(candidates) if random.random() < 0.7 else random.choice(candidates))\n        s[v - 1] = new_c\n\n    # 50% chance: Kempe chain flip between two most frequent colors\n    if random.random() < 0.5:\n        freq = {}\n        for x in s:\n            freq[x] = freq.get(x, 0) + 1\n        if len(freq) >= 2:\n            colors_sorted = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))\n            c1 = colors_sorted[0][0]\n            c2 = colors_sorted[1][0]\n            # Start from a random vertex of c1 or c2\n            candidates = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                visited = set([start])\n                q = deque([start])\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if w not in visited and s[w - 1] in (c1, c2):\n                            visited.add(w)\n                            q.append(w)\n                # Flip colors on this component\n                for u in visited:\n                    s[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n\n    # Final compact relabel (stabilize k without affecting feasibility)\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        s[i] = mapping[c]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001350194}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Problem constants\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Penalties and weights (lower is better)\n    PEN_TYPE = 10**9\n    PEN_LEN = 10**9\n    PEN_INVALID = 10**6\n    PEN_CONFLICT = 10**6\n    PEN_GAPS = 10**2\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    # Validate entries and coerce nonpositive to 1 to avoid double-penalization\n    vals = []\n    invalid_type = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n            vals.append(1)\n        else:\n            vals.append(1 if x <= 0 else x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # k used under canonical relabel (stable to gaps\/permutations)\n    def k_used_canonical(arr):\n        mapping = {}\n        nxt = 1\n        for x in arr:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n        return len(mapping)\n\n    k_used = k_used_canonical(vals)\n\n    # Gaps only if conflict-free: encourage compact 1..k when feasible\n    gaps = 0\n    if conflicts == 0:\n        # Canonical relabel sequence\n        mapping = {}\n        nxt = 1\n        canon = []\n        for x in vals:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            canon.append(mapping[x])\n        max_c = max(canon) if canon else 0\n        expected = set(range(1, max_c + 1))\n        gaps = len(expected - set(canon))\n\n    fitness = PEN_CONFLICT * conflicts + PEN_GAPS * gaps + k_used\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency (local, no globals)\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Guard and clone; repair to positive ints\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = []\n        for x in solution:\n            if isinstance(x, int) and x > 0:\n                s.append(x)\n            else:\n                s.append(1)\n\n    def conflicts_list(sol):\n        out = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                out.append((u, v))\n        return out\n\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    # Ensure palette bounds\n    if not s:\n        s = [1] * n\n    for i in range(n):\n        if s[i] <= 0:\n            s[i] = 1\n\n    # Move selection\n    move_rand = random.random()\n\n    # Strategy A: Conflict-driven recolor (priority)\n    if move_rand < 0.7:\n        cvs = conflict_vertices(s)\n        v = random.choice(cvs) if cvs else random.randint(1, n)\n        forbidden = {s[u - 1] for u in adj[v]}\n        current_max = max(s)\n        # Try to avoid palette bloat: expand only if no feasible color\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n        # Prefer smallest feasible color; slight randomness among up to top-3\n        k = min(3, len(candidates))\n        pick_from = candidates[:k]\n        new_c = random.choice(pick_from)\n        ns = s[:]\n        ns[v - 1] = new_c\n        return (ns, (\"Local\", \"RecolorOne\"))\n\n    # Strategy B: Kempe-like swap between two colors\n    colors = list(set(s))\n    attempts = 5\n    for _ in range(attempts):\n        if len(colors) < 2:\n            break\n        c1, c2 = random.sample(colors, 2)\n        # Prefer components touching conflicts if any\n        cvs = set(conflict_vertices(s))\n        cand_vertices = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n        if not cand_vertices:\n            continue\n        touch_conf = [v for v in cand_vertices if v in cvs]\n        start = random.choice(touch_conf if touch_conf else cand_vertices)\n        # BFS over bi-colored component\n        visited = set([start])\n        q = deque([start])\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if w not in visited and s[w - 1] in (c1, c2):\n                    visited.add(w)\n                    q.append(w)\n        if not visited:\n            continue\n        ns = s[:]\n        for u in visited:\n            ns[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n        return (ns, (\"Local\", \"SwapKempeLike\"))\n\n    # Fallback: random vertex recolor to smallest feasible\n    v = random.randint(1, n)\n    forbidden = {s[u - 1] for u in adj[v]}\n    current_max = max(s)\n    candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n    if not candidates:\n        candidates = [current_max + 1]\n    ns = s[:]\n    ns[v - 1] = min(candidates)\n    return (ns, (\"Local\", \"RecolorFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor a subset with DSATUR bias + optional Kempe flip\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Repair\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def dsatur_order(sol):\n        # Returns vertices sorted by saturation degree then degree\n        colors = {i + 1: sol[i] for i in range(n)}\n        sat = {}\n        for v in range(1, n + 1):\n            sat[v] = len({colors[u] for u in adj[v]})\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        return sorted(range(1, n + 1), key=lambda v: (-sat[v], -deg[v], v))\n\n    # Select t vertices biased towards high saturation or conflicts\n    t = max(2, n \/\/ 3)\n    # Conflicted vertices if any\n    conflicted = set()\n    for (u, v) in edges:\n        if s[u - 1] == s[v - 1]:\n            conflicted.add(u)\n            conflicted.add(v)\n    order = dsatur_order(s)\n    pool = list(conflicted) + [v for v in order if v not in conflicted]\n    pool = pool[:max(t * 2, t)] if pool else list(range(1, n + 1))\n    idxs = sorted(random.sample(pool, min(t, len(pool))))\n\n    current_max = max(s)\n    for v in idxs:\n        forbidden = {s[u - 1] for u in adj[v]}\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n            current_max = max(current_max, candidates[0])\n        # 70% choose smallest feasible, else random feasible to diversify\n        new_c = (min(candidates) if random.random() < 0.7 else random.choice(candidates))\n        s[v - 1] = new_c\n\n    # 50% chance: Kempe chain flip between two most frequent colors\n    if random.random() < 0.5:\n        freq = {}\n        for x in s:\n            freq[x] = freq.get(x, 0) + 1\n        if len(freq) >= 2:\n            colors_sorted = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))\n            c1 = colors_sorted[0][0]\n            c2 = colors_sorted[1][0]\n            # Start from a random vertex of c1 or c2\n            candidates = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                visited = set([start])\n                q = deque([start])\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if w not in visited and s[w - 1] in (c1, c2):\n                            visited.add(w)\n                            q.append(w)\n                # Flip colors on this component\n                for u in visited:\n                    s[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n\n    # Final compact relabel (stabilize k without affecting feasibility)\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        s[i] = mapping[c]\n\n    return s\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001274614}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Problem constants (embedded, no globals)\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Penalties and weights (lower is better)\n    PEN_TYPE = 10**9\n    PEN_LEN = 10**9\n    PEN_INVALID = 10**6\n    PEN_CONFLICT = 10**6\n    PEN_GAPS = 1  # keep tiny; objective dominated by conflicts and k_used\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    # Validate entries and coerce nonpositive to 1 to avoid cascading errors\n    vals = []\n    invalid_type = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n            vals.append(1)\n        else:\n            vals.append(1 if x <= 0 else x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # Canonical relabel to compute k_used and optional gaps\n    mapping = {}\n    nxt = 1\n    canon = []\n    for x in vals:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        canon.append(mapping[x])\n    k_used = len(mapping)\n\n    gaps = 0\n    if conflicts == 0:\n        max_c = max(canon) if canon else 0\n        expected = set(range(1, max_c + 1))\n        gaps = len(expected - set(canon))\n\n    fitness = PEN_CONFLICT * conflicts + PEN_GAPS * gaps + k_used\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency locally\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Repair\/clone input\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    def conflicts_list(sol):\n        out = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                out.append((u, v))\n        return out\n\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    def smallest_feasible_color(v, sol):\n        forbidden = {sol[u - 1] for u in adj[v]}\n        max_c = max(sol) if sol else 1\n        for c in range(1, max_c + 1):\n            if c not in forbidden:\n                return c\n        return max_c + 1\n\n    cvs = conflict_vertices(s)\n\n    # If conflicts exist: conflict-driven recolor of a high-pressure vertex\n    if cvs:\n        # Score vertices by (# conflicting edges, degree)\n        conf_count = {v: 0 for v in range(1, n + 1)}\n        for (u, v) in conflicts_list(s):\n            conf_count[u] += 1\n            conf_count[v] += 1\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        cand = sorted(set(cvs), key=lambda v: (-conf_count[v], -deg[v], v))\n        v = random.choice(cand[:min(3, len(cand))])\n        # Try smallest feasible color first; if that equals current color, try an alternative\n        current = s[v - 1]\n        forbidden = {s[u - 1] for u in adj[v]}\n        max_c = max(s)\n        candidates = [c for c in range(1, max_c + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [max_c + 1]\n        # Prefer smallest  but randomize among top few\n        pick_pool = candidates[:min(3, len(candidates))]\n        new_c = random.choice(pick_pool)\n        ns = s[:]\n        ns[v - 1] = new_c\n        return (ns, (\"Local\", \"RecolorConflict\"))\n\n    # No conflicts: attempt targeted color elimination\n    color_freq = {}\n    for x in s:\n        color_freq[x] = color_freq.get(x, 0) + 1\n    colors_sorted = sorted(color_freq.items(), key=lambda kv: (kv[0]))\n    used_colors = sorted(color_freq.keys())\n\n    # Try to eliminate the highest color index to promote compactness\n    target_color = max(used_colors)\n    vertices_tc = [i + 1 for i, x in enumerate(s) if x == target_color]\n\n    def can_assign(v, c, sol):\n        for u in adj[v]:\n            if sol[u - 1] == c:\n                return False\n        return True\n\n    ns = s[:]\n    success = True\n    for v in vertices_tc:\n        # Try to recolor this vertex to the smallest feasible color < target_color\n        feasible = [c for c in range(1, target_color) if can_assign(v, c, ns)]\n        if not feasible:\n            success = False\n            break\n        ns[v - 1] = min(feasible)\n    if success:\n        # Compact relabel (optional stability)\n        mapping = {}\n        nxt = 1\n        for i in range(n):\n            c = ns[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            ns[i] = mapping[c]\n        return (ns, (\"ColorReduction\", \"EliminateHighest\"))\n\n    # Kempe-like swap targeted between target_color and a candidate color\n    if len(used_colors) >= 2:\n        other_colors = [c for c in used_colors if c != target_color]\n        random.shuffle(other_colors)\n        for c2 in other_colors[:2]:\n            # pick a seed vertex with color in {target_color, c2}\n            cand_vertices = [i + 1 for i, x in enumerate(s) if x in (target_color, c2)]\n            if not cand_vertices:\n                continue\n            start = random.choice(cand_vertices)\n            visited = set([start])\n            q = deque([start])\n            while q:\n                u = q.popleft()\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in (target_color, c2):\n                        visited.add(w)\n                        q.append(w)\n            ns2 = s[:]\n            for u in visited:\n                ns2[u - 1] = c2 if s[u - 1] == target_color else (target_color if s[u - 1] == c2 else s[u - 1])\n            # After swap, try elimination again greedily\n            ns3 = ns2[:]\n            ok = True\n            for v in [i + 1 for i, x in enumerate(ns3) if x == target_color]:\n                feas = [c for c in range(1, target_color) if can_assign(v, c, ns3)]\n                if not feas:\n                    ok = False\n                    break\n                ns3[v - 1] = min(feas)\n            if ok:\n                mapping = {}\n                nxt = 1\n                for i in range(n):\n                    c = ns3[i]\n                    if c not in mapping:\n                        mapping[c] = nxt\n                        nxt += 1\n                    ns3[i] = mapping[c]\n                return (ns3, (\"ColorReduction\", \"KempeTargeted\"))\n\n    # Fallback: recolor a random vertex to smallest feasible color\n    v = random.randint(1, n)\n    new_c = smallest_feasible_color(v, s)\n    ns = s[:]\n    ns[v - 1] = new_c\n    return (ns, (\"Local\", \"RecolorFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Medium-strength diversification: DSATUR-biased recolor + optional Kempe flip\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Repair\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def dsatur_order(sol):\n        colors = {i + 1: sol[i] for i in range(n)}\n        sat = {}\n        for v in range(1, n + 1):\n            sat[v] = len({colors[u] for u in adj[v]})\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        return sorted(range(1, n + 1), key=lambda v: (-sat[v], -deg[v], v))\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in edges:\n        if s[u - 1] == s[v - 1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    order = dsatur_order(s)\n    pool = list(conflicted) + [v for v in order if v not in conflicted]\n    if not pool:\n        pool = list(range(1, n + 1))\n\n    t = max(2, n \/\/ 3)\n    idxs = sorted(random.sample(pool[:min(len(pool), max(t * 2, t + 2))], min(t, len(pool))))\n\n    current_max = max(s)\n    for v in idxs:\n        forbidden = {s[u - 1] for u in adj[v]}\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n            current_max = max(current_max, candidates[0])\n        new_c = (min(candidates) if random.random() < 0.7 else random.choice(candidates))\n        s[v - 1] = new_c\n\n    # Optional Kempe flip between two frequent colors\n    if random.random() < 0.5:\n        freq = {}\n        for x in s:\n            freq[x] = freq.get(x, 0) + 1\n        if len(freq) >= 2:\n            colors_sorted = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))\n            c1 = colors_sorted[0][0]\n            c2 = colors_sorted[1][0]\n            candidates = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                visited = set([start])\n                q = deque([start])\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if w not in visited and s[w - 1] in (c1, c2):\n                            visited.add(w)\n                            q.append(w)\n                for u in visited:\n                    s[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n\n    # Final compact relabeling for stability\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        s[i] = mapping[c]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001710689}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Problem constants (embedded, no globals)\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Penalties and weights (lower is better)\n    PEN_TYPE = 10**9\n    PEN_LEN = 10**9\n    PEN_INVALID = 10**6\n    PEN_CONFLICT = 10**6\n    PEN_GAPS = 1  # keep tiny; objective dominated by conflicts and k_used\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    # Validate entries and coerce nonpositive to 1 to avoid cascading errors\n    vals = []\n    invalid_type = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n            vals.append(1)\n        else:\n            vals.append(1 if x <= 0 else x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # Canonical relabel to compute k_used and optional gaps\n    mapping = {}\n    nxt = 1\n    canon = []\n    for x in vals:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        canon.append(mapping[x])\n    k_used = len(mapping)\n\n    gaps = 0\n    if conflicts == 0:\n        max_c = max(canon) if canon else 0\n        expected = set(range(1, max_c + 1))\n        gaps = len(expected - set(canon))\n\n    fitness = PEN_CONFLICT * conflicts + PEN_GAPS * gaps + k_used\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency locally\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Repair\/clone input\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    def conflicts_list(sol):\n        out = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                out.append((u, v))\n        return out\n\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    def smallest_feasible_color(v, sol):\n        forbidden = {sol[u - 1] for u in adj[v]}\n        max_c = max(sol) if sol else 1\n        for c in range(1, max_c + 1):\n            if c not in forbidden:\n                return c\n        return max_c + 1\n\n    cvs = conflict_vertices(s)\n\n    # If conflicts exist: conflict-driven recolor of a high-pressure vertex\n    if cvs:\n        # Score vertices by (# conflicting edges, degree)\n        conf_count = {v: 0 for v in range(1, n + 1)}\n        for (u, v) in conflicts_list(s):\n            conf_count[u] += 1\n            conf_count[v] += 1\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        cand = sorted(set(cvs), key=lambda v: (-conf_count[v], -deg[v], v))\n        v = random.choice(cand[:min(3, len(cand))])\n        # Try smallest feasible color first; if that equals current color, try an alternative\n        current = s[v - 1]\n        forbidden = {s[u - 1] for u in adj[v]}\n        max_c = max(s)\n        candidates = [c for c in range(1, max_c + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [max_c + 1]\n        # Prefer smallest  but randomize among top few\n        pick_pool = candidates[:min(3, len(candidates))]\n        new_c = random.choice(pick_pool)\n        ns = s[:]\n        ns[v - 1] = new_c\n        return (ns, (\"Local\", \"RecolorConflict\"))\n\n    # No conflicts: attempt targeted color elimination\n    color_freq = {}\n    for x in s:\n        color_freq[x] = color_freq.get(x, 0) + 1\n    colors_sorted = sorted(color_freq.items(), key=lambda kv: (kv[0]))\n    used_colors = sorted(color_freq.keys())\n\n    # Try to eliminate the highest color index to promote compactness\n    target_color = max(used_colors)\n    vertices_tc = [i + 1 for i, x in enumerate(s) if x == target_color]\n\n    def can_assign(v, c, sol):\n        for u in adj[v]:\n            if sol[u - 1] == c:\n                return False\n        return True\n\n    ns = s[:]\n    success = True\n    for v in vertices_tc:\n        # Try to recolor this vertex to the smallest feasible color < target_color\n        feasible = [c for c in range(1, target_color) if can_assign(v, c, ns)]\n        if not feasible:\n            success = False\n            break\n        ns[v - 1] = min(feasible)\n    if success:\n        # Compact relabel (optional stability)\n        mapping = {}\n        nxt = 1\n        for i in range(n):\n            c = ns[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            ns[i] = mapping[c]\n        return (ns, (\"ColorReduction\", \"EliminateHighest\"))\n\n    # Kempe-like swap targeted between target_color and a candidate color\n    if len(used_colors) >= 2:\n        other_colors = [c for c in used_colors if c != target_color]\n        random.shuffle(other_colors)\n        for c2 in other_colors[:2]:\n            # pick a seed vertex with color in {target_color, c2}\n            cand_vertices = [i + 1 for i, x in enumerate(s) if x in (target_color, c2)]\n            if not cand_vertices:\n                continue\n            start = random.choice(cand_vertices)\n            visited = set([start])\n            q = deque([start])\n            while q:\n                u = q.popleft()\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in (target_color, c2):\n                        visited.add(w)\n                        q.append(w)\n            ns2 = s[:]\n            for u in visited:\n                ns2[u - 1] = c2 if s[u - 1] == target_color else (target_color if s[u - 1] == c2 else s[u - 1])\n            # After swap, try elimination again greedily\n            ns3 = ns2[:]\n            ok = True\n            for v in [i + 1 for i, x in enumerate(ns3) if x == target_color]:\n                feas = [c for c in range(1, target_color) if can_assign(v, c, ns3)]\n                if not feas:\n                    ok = False\n                    break\n                ns3[v - 1] = min(feas)\n            if ok:\n                mapping = {}\n                nxt = 1\n                for i in range(n):\n                    c = ns3[i]\n                    if c not in mapping:\n                        mapping[c] = nxt\n                        nxt += 1\n                    ns3[i] = mapping[c]\n                return (ns3, (\"ColorReduction\", \"KempeTargeted\"))\n\n    # Fallback: recolor a random vertex to smallest feasible color\n    v = random.randint(1, n)\n    new_c = smallest_feasible_color(v, s)\n    ns = s[:]\n    ns[v - 1] = new_c\n    return (ns, (\"Local\", \"RecolorFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Medium-strength diversification: DSATUR-biased recolor + optional Kempe flip\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Repair\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def dsatur_order(sol):\n        colors = {i + 1: sol[i] for i in range(n)}\n        sat = {}\n        for v in range(1, n + 1):\n            sat[v] = len({colors[u] for u in adj[v]})\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        return sorted(range(1, n + 1), key=lambda v: (-sat[v], -deg[v], v))\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in edges:\n        if s[u - 1] == s[v - 1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    order = dsatur_order(s)\n    pool = list(conflicted) + [v for v in order if v not in conflicted]\n    if not pool:\n        pool = list(range(1, n + 1))\n\n    t = max(2, n \/\/ 3)\n    idxs = sorted(random.sample(pool[:min(len(pool), max(t * 2, t + 2))], min(t, len(pool))))\n\n    current_max = max(s)\n    for v in idxs:\n        forbidden = {s[u - 1] for u in adj[v]}\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n            current_max = max(current_max, candidates[0])\n        new_c = (min(candidates) if random.random() < 0.7 else random.choice(candidates))\n        s[v - 1] = new_c\n\n    # Optional Kempe flip between two frequent colors\n    if random.random() < 0.5:\n        freq = {}\n        for x in s:\n            freq[x] = freq.get(x, 0) + 1\n        if len(freq) >= 2:\n            colors_sorted = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))\n            c1 = colors_sorted[0][0]\n            c2 = colors_sorted[1][0]\n            candidates = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                visited = set([start])\n                q = deque([start])\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if w not in visited and s[w - 1] in (c1, c2):\n                            visited.add(w)\n                            q.append(w)\n                for u in visited:\n                    s[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n\n    # Final compact relabeling for stability\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        s[i] = mapping[c]\n\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001726908}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_taekwondo_tournament_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Problem constants (embedded, no globals)\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Penalties and weights (lower is better)\n    PEN_TYPE = 10**9\n    PEN_LEN = 10**9\n    PEN_INVALID = 10**6\n    PEN_CONFLICT = 10**6\n    PEN_GAPS = 1  # keep tiny; objective dominated by conflicts and k_used\n\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return PEN_TYPE\n    if len(solution) != n:\n        return PEN_LEN + abs(len(solution) - n)\n\n    # Validate entries and coerce nonpositive to 1 to avoid cascading errors\n    vals = []\n    invalid_type = 0\n    for x in solution:\n        if not isinstance(x, int):\n            invalid_type += 1\n            vals.append(1)\n        else:\n            vals.append(1 if x <= 0 else x)\n    if invalid_type > 0:\n        return PEN_TYPE + PEN_INVALID * invalid_type\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if vals[u - 1] == vals[v - 1]:\n            conflicts += 1\n\n    # Canonical relabel to compute k_used and optional gaps\n    mapping = {}\n    nxt = 1\n    canon = []\n    for x in vals:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        canon.append(mapping[x])\n    k_used = len(mapping)\n\n    gaps = 0\n    if conflicts == 0:\n        max_c = max(canon) if canon else 0\n        expected = set(range(1, max_c + 1))\n        gaps = len(expected - set(canon))\n\n    fitness = PEN_CONFLICT * conflicts + PEN_GAPS * gaps + k_used\n    return fitness\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Build adjacency locally\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Repair\/clone input\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    def conflicts_list(sol):\n        out = []\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                out.append((u, v))\n        return out\n\n    def conflict_vertices(sol):\n        cv = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                cv.add(u)\n                cv.add(v)\n        return list(cv)\n\n    def smallest_feasible_color(v, sol):\n        forbidden = {sol[u - 1] for u in adj[v]}\n        max_c = max(sol) if sol else 1\n        for c in range(1, max_c + 1):\n            if c not in forbidden:\n                return c\n        return max_c + 1\n\n    cvs = conflict_vertices(s)\n\n    # If conflicts exist: conflict-driven recolor of a high-pressure vertex\n    if cvs:\n        # Score vertices by (# conflicting edges, degree)\n        conf_count = {v: 0 for v in range(1, n + 1)}\n        for (u, v) in conflicts_list(s):\n            conf_count[u] += 1\n            conf_count[v] += 1\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        cand = sorted(set(cvs), key=lambda v: (-conf_count[v], -deg[v], v))\n        v = random.choice(cand[:min(3, len(cand))])\n        # Try smallest feasible color first; if that equals current color, try an alternative\n        current = s[v - 1]\n        forbidden = {s[u - 1] for u in adj[v]}\n        max_c = max(s)\n        candidates = [c for c in range(1, max_c + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [max_c + 1]\n        # Prefer smallest  but randomize among top few\n        pick_pool = candidates[:min(3, len(candidates))]\n        new_c = random.choice(pick_pool)\n        ns = s[:]\n        ns[v - 1] = new_c\n        return (ns, (\"Local\", \"RecolorConflict\"))\n\n    # No conflicts: attempt targeted color elimination\n    color_freq = {}\n    for x in s:\n        color_freq[x] = color_freq.get(x, 0) + 1\n    colors_sorted = sorted(color_freq.items(), key=lambda kv: (kv[0]))\n    used_colors = sorted(color_freq.keys())\n\n    # Try to eliminate the highest color index to promote compactness\n    target_color = max(used_colors)\n    vertices_tc = [i + 1 for i, x in enumerate(s) if x == target_color]\n\n    def can_assign(v, c, sol):\n        for u in adj[v]:\n            if sol[u - 1] == c:\n                return False\n        return True\n\n    ns = s[:]\n    success = True\n    for v in vertices_tc:\n        # Try to recolor this vertex to the smallest feasible color < target_color\n        feasible = [c for c in range(1, target_color) if can_assign(v, c, ns)]\n        if not feasible:\n            success = False\n            break\n        ns[v - 1] = min(feasible)\n    if success:\n        # Compact relabel (optional stability)\n        mapping = {}\n        nxt = 1\n        for i in range(n):\n            c = ns[i]\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            ns[i] = mapping[c]\n        return (ns, (\"ColorReduction\", \"EliminateHighest\"))\n\n    # Kempe-like swap targeted between target_color and a candidate color\n    if len(used_colors) >= 2:\n        other_colors = [c for c in used_colors if c != target_color]\n        random.shuffle(other_colors)\n        for c2 in other_colors[:2]:\n            # pick a seed vertex with color in {target_color, c2}\n            cand_vertices = [i + 1 for i, x in enumerate(s) if x in (target_color, c2)]\n            if not cand_vertices:\n                continue\n            start = random.choice(cand_vertices)\n            visited = set([start])\n            q = deque([start])\n            while q:\n                u = q.popleft()\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in (target_color, c2):\n                        visited.add(w)\n                        q.append(w)\n            ns2 = s[:]\n            for u in visited:\n                ns2[u - 1] = c2 if s[u - 1] == target_color else (target_color if s[u - 1] == c2 else s[u - 1])\n            # After swap, try elimination again greedily\n            ns3 = ns2[:]\n            ok = True\n            for v in [i + 1 for i, x in enumerate(ns3) if x == target_color]:\n                feas = [c for c in range(1, target_color) if can_assign(v, c, ns3)]\n                if not feas:\n                    ok = False\n                    break\n                ns3[v - 1] = min(feas)\n            if ok:\n                mapping = {}\n                nxt = 1\n                for i in range(n):\n                    c = ns3[i]\n                    if c not in mapping:\n                        mapping[c] = nxt\n                        nxt += 1\n                    ns3[i] = mapping[c]\n                return (ns3, (\"ColorReduction\", \"KempeTargeted\"))\n\n    # Fallback: recolor a random vertex to smallest feasible color\n    v = random.randint(1, n)\n    new_c = smallest_feasible_color(v, s)\n    ns = s[:]\n    ns[v - 1] = new_c\n    return (ns, (\"Local\", \"RecolorFallback\"))\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Medium-strength diversification: DSATUR-biased recolor + optional Kempe flip\n    n = 9\n    edges = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n\n    # Repair\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        s = [1] * n\n    else:\n        s = [x if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def dsatur_order(sol):\n        colors = {i + 1: sol[i] for i in range(n)}\n        sat = {}\n        for v in range(1, n + 1):\n            sat[v] = len({colors[u] for u in adj[v]})\n        deg = {v: len(adj[v]) for v in range(1, n + 1)}\n        return sorted(range(1, n + 1), key=lambda v: (-sat[v], -deg[v], v))\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in edges:\n        if s[u - 1] == s[v - 1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    order = dsatur_order(s)\n    pool = list(conflicted) + [v for v in order if v not in conflicted]\n    if not pool:\n        pool = list(range(1, n + 1))\n\n    t = max(2, n \/\/ 3)\n    idxs = sorted(random.sample(pool[:min(len(pool), max(t * 2, t + 2))], min(t, len(pool))))\n\n    current_max = max(s)\n    for v in idxs:\n        forbidden = {s[u - 1] for u in adj[v]}\n        candidates = [c for c in range(1, current_max + 1) if c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n            current_max = max(current_max, candidates[0])\n        new_c = (min(candidates) if random.random() < 0.7 else random.choice(candidates))\n        s[v - 1] = new_c\n\n    # Optional Kempe flip between two frequent colors\n    if random.random() < 0.5:\n        freq = {}\n        for x in s:\n            freq[x] = freq.get(x, 0) + 1\n        if len(freq) >= 2:\n            colors_sorted = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))\n            c1 = colors_sorted[0][0]\n            c2 = colors_sorted[1][0]\n            candidates = [i + 1 for i, x in enumerate(s) if x in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                visited = set([start])\n                q = deque([start])\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if w not in visited and s[w - 1] in (c1, c2):\n                            visited.add(w)\n                            q.append(w)\n                for u in visited:\n                    s[u - 1] = c2 if s[u - 1] == c1 else (c1 if s[u - 1] == c2 else s[u - 1])\n\n    # Final compact relabeling for stability\n    mapping = {}\n    nxt = 1\n    for i in range(n):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        s[i] = mapping[c]\n\n    return s\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001669569}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS: A solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-based vertices). Objective minimizes k = max(ci).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        return PENALTY_BASE + violations * 1000 + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a tuple (new_solution, movement_type).\n    Movement: recolor_one - change the color of a single randomly chosen vertex\n    to a different color chosen from 1..max(current_k+1, 3).\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return (solution, \"noop_invalid_input\")\n    new_sol = solution[:]  # shallow copy sufficient (list of ints)\n    n = len(new_sol)\n    idx = random.randrange(n)\n    current_k = max(1, max(x for x in new_sol if isinstance(x, int) and x > 0))\n    palette_max = max(3, current_k + 1)\n    current_color = new_sol[idx] if isinstance(new_sol[idx], int) and new_sol[idx] > 0 else 1\n    # Build candidate colors excluding current color\n    candidates = [c for c in range(1, palette_max + 1) if c != current_color]\n    if not candidates:\n        return (new_sol, \"noop_no_candidates\")\n    new_color = random.choice(candidates)\n    new_sol[idx] = new_color\n    return (new_sol, \"recolor_one\")\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger random move intended to escape local minima.\n    - Randomly recolor r vertices (r in {2,3,4}) with colors from 1..max(k+1,3)\n    - With small probability, relabel existing colors via a random permutation on 1..k.\n    Returns the perturbed solution (list of ints) or the input if malformed.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n    sol = solution[:]\n    n = len(sol)\n    # Determine current k robustly\n    valid_pos = [x for x in sol if isinstance(x, int) and x > 0]\n    current_k = max(valid_pos) if valid_pos else 1\n    palette_max = max(3, current_k + 1)\n    # Recolor r random distinct positions\n    r = random.choice([2, 3, 4])\n    positions = list(range(n))\n    random.shuffle(positions)\n    positions = positions[:min(r, n)]\n    for idx in positions:\n        cur = sol[idx] if isinstance(sol[idx], int) and sol[idx] > 0 else 1\n        candidates = [c for c in range(1, palette_max + 1) if c != cur]\n        if candidates:\n            sol[idx] = random.choice(candidates)\n    # With probability 0.3, relabel colors 1..current_k by a random permutation\n    if current_k >= 2 and random.random() < 0.3:\n        perm = list(range(1, current_k + 1))\n        random.shuffle(perm)\n        relabel = {old: new for old, new in zip(range(1, current_k + 1), perm)}\n        sol = [relabel.get(x, x) if isinstance(x, int) and x > 0 else x for x in sol]\n    return sol\n","Resultados":["[3,2,2,1,1,2,3,3,1]",1100000,"[3,2,2,1,1,2,3,3,1]",1100000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000668718}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS: A solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-based vertices). Objective minimizes k = max(ci).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        return PENALTY_BASE + violations * 1000 + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a tuple (new_solution, movement_type).\n    Movement: recolor_one - change the color of a single randomly chosen vertex\n    to a different color chosen from 1..max(current_k+1, 3).\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return (solution, \"noop_invalid_input\")\n    new_sol = solution[:]  # shallow copy sufficient (list of ints)\n    n = len(new_sol)\n    idx = random.randrange(n)\n    current_k = max(1, max(x for x in new_sol if isinstance(x, int) and x > 0))\n    palette_max = max(3, current_k + 1)\n    current_color = new_sol[idx] if isinstance(new_sol[idx], int) and new_sol[idx] > 0 else 1\n    # Build candidate colors excluding current color\n    candidates = [c for c in range(1, palette_max + 1) if c != current_color]\n    if not candidates:\n        return (new_sol, \"noop_no_candidates\")\n    new_color = random.choice(candidates)\n    new_sol[idx] = new_color\n    return (new_sol, \"recolor_one\")\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger random move intended to escape local minima.\n    - Randomly recolor r vertices (r in {2,3,4}) with colors from 1..max(k+1,3)\n    - With small probability, relabel existing colors via a random permutation on 1..k.\n    Returns the perturbed solution (list of ints) or the input if malformed.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n    sol = solution[:]\n    n = len(sol)\n    # Determine current k robustly\n    valid_pos = [x for x in sol if isinstance(x, int) and x > 0]\n    current_k = max(valid_pos) if valid_pos else 1\n    palette_max = max(3, current_k + 1)\n    # Recolor r random distinct positions\n    r = random.choice([2, 3, 4])\n    positions = list(range(n))\n    random.shuffle(positions)\n    positions = positions[:min(r, n)]\n    for idx in positions:\n        cur = sol[idx] if isinstance(sol[idx], int) and sol[idx] > 0 else 1\n        candidates = [c for c in range(1, palette_max + 1) if c != cur]\n        if candidates:\n            sol[idx] = random.choice(candidates)\n    # With probability 0.3, relabel colors 1..current_k by a random permutation\n    if current_k >= 2 and random.random() < 0.3:\n        perm = list(range(1, current_k + 1))\n        random.shuffle(perm)\n        relabel = {old: new for old, new in zip(range(1, current_k + 1), perm)}\n        sol = [relabel.get(x, x) if isinstance(x, int) and x > 0 else x for x in sol]\n    return sol\n","Resultados":["[3,2,2,1,1,2,3,3,1]",1100000,"[3,2,2,1,1,2,3,3,1]",1100000],"Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000653957}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS: A solution is a list of 9 positive integers [c1,...,c9], where ci is the color of vertex i (1-based vertices). Objective minimizes k = max(ci).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        return PENALTY_BASE + violations * 1000 + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a tuple (new_solution, movement_type).\n    Movement: recolor_one - change the color of a single randomly chosen vertex\n    to a different color chosen from 1..max(current_k+1, 3).\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return (solution, \"noop_invalid_input\")\n    new_sol = solution[:]  # shallow copy sufficient (list of ints)\n    n = len(new_sol)\n    idx = random.randrange(n)\n    current_k = max(1, max(x for x in new_sol if isinstance(x, int) and x > 0))\n    palette_max = max(3, current_k + 1)\n    current_color = new_sol[idx] if isinstance(new_sol[idx], int) and new_sol[idx] > 0 else 1\n    # Build candidate colors excluding current color\n    candidates = [c for c in range(1, palette_max + 1) if c != current_color]\n    if not candidates:\n        return (new_sol, \"noop_no_candidates\")\n    new_color = random.choice(candidates)\n    new_sol[idx] = new_color\n    return (new_sol, \"recolor_one\")\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger random move intended to escape local minima.\n    - Randomly recolor r vertices (r in {2,3,4}) with colors from 1..max(k+1,3)\n    - With small probability, relabel existing colors via a random permutation on 1..k.\n    Returns the perturbed solution (list of ints) or the input if malformed.\n    \"\"\"\n    if not isinstance(solution, list) or len(solution) == 0:\n        return solution\n    sol = solution[:]\n    n = len(sol)\n    # Determine current k robustly\n    valid_pos = [x for x in sol if isinstance(x, int) and x > 0]\n    current_k = max(valid_pos) if valid_pos else 1\n    palette_max = max(3, current_k + 1)\n    # Recolor r random distinct positions\n    r = random.choice([2, 3, 4])\n    positions = list(range(n))\n    random.shuffle(positions)\n    positions = positions[:min(r, n)]\n    for idx in positions:\n        cur = sol[idx] if isinstance(sol[idx], int) and sol[idx] > 0 else 1\n        candidates = [c for c in range(1, palette_max + 1) if c != cur]\n        if candidates:\n            sol[idx] = random.choice(candidates)\n    # With probability 0.3, relabel colors 1..current_k by a random permutation\n    if current_k >= 2 and random.random() < 0.3:\n        perm = list(range(1, current_k + 1))\n        random.shuffle(perm)\n        relabel = {old: new for old, new in zip(range(1, current_k + 1), perm)}\n        sol = [relabel.get(x, x) if isinstance(x, int) and x > 0 else x for x in sol]\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000577006}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS: A solution is a Python list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (i in {1..9}). Objective is to minimize k = max(ci) subject to c(u) != c(v) for every edge (u,v) in E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty with conflict count shaping.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Guide search: fewer violations is better; tie-break by smaller k\n        return PENALTY_BASE + violations * 1000 + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type).\n    - Prefer recoloring a conflicting vertex to an admissible color.\n    - If no conflicts, recolor a random vertex to another existing color or k+1 with small probability.\n    - After move, normalize colors to 1..k (color compression) to prevent palette drift.\n    \"\"\"\n    # Internal graph definition\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop_invalid_input\")\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        # Map colors to a compact range 1..k preserving relative classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n    k = max(new_sol)\n    # Build adjacency list\n    adj = [[] for _ in range(V+1)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicting vertices\n    conflicts = []\n    for (u,v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts.append(u)\n            conflicts.append(v)\n    move = \"recolor_one\"\n    if conflicts:\n        idx = random.choice(conflicts) - 1\n        forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n        # Prefer admissible colors within 1..k, allow k+1 as escape if needed\n        palette = list(range(1, max(3, k) + 1))\n        admissible = [c for c in palette if c != new_sol[idx] and c not in forbidden]\n        if admissible:\n            new_sol[idx] = random.choice(admissible)\n            move = \"conflict_directed_recolor\"\n        else:\n            # No admissible within 1..k; try k+1\n            new_color = k + 1 if new_sol[idx] != k + 1 else max(1, (new_sol[idx] % (k+1)) + 1)\n            new_sol[idx] = new_color\n            move = \"escape_raise_palette\"\n    else:\n        # No conflicts: diversify slightly by recoloring a random vertex to a different existing color\n        idx = random.randrange(V)\n        palette = list(range(1, max(3, k) + 1))\n        candidates = [c for c in palette if c != new_sol[idx]]\n        if candidates:\n            new_sol[idx] = random.choice(candidates)\n            move = \"feasible_diversify_recolor\"\n        else:\n            move = \"noop_no_candidates\"\n    new_sol = normalize_colors(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Combines three mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices with colors from 1..max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and color a!=color(i); swap colors along the (a, color(i)) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_colors(solx: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in solx:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2,3,4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        # Build adjacency list\n        adj = [[] for _ in range(V)]\n        for (u,v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        v0 = random.randrange(V)\n        color_v0 = sol[v0]\n        palette = list(range(1, max(3, k) + 1))\n        alt_colors = [c for c in palette if c != color_v0]\n        if alt_colors:\n            a = color_v0\n            b = random.choice(alt_colors)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*V\n            if sol[v0] in (a,b):\n                queue = deque([v0])\n                visited[v0] = True\n                component = [v0]\n                while queue:\n                    u = queue.popleft()\n                    for w in adj[u]:\n                        if not visited[w] and sol[w] in (a,b):\n                            visited[w] = True\n                            queue.append(w)\n                            component.append(w)\n                # Swap colors a<->b on this component\n                for u in component:\n                    sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n    sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000677438}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS: A solution is a Python list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (i in {1..9}). Objective is to minimize k = max(ci) subject to c(u) != c(v) for every edge (u,v) in E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty with conflict count shaping.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Guide search: fewer violations is better; tie-break by smaller k\n        return PENALTY_BASE + violations * 1000 + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type).\n    - Prefer recoloring a conflicting vertex to an admissible color.\n    - If no conflicts, recolor a random vertex to another existing color or k+1 with small probability.\n    - After move, normalize colors to 1..k (color compression) to prevent palette drift.\n    \"\"\"\n    # Internal graph definition\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop_invalid_input\")\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        # Map colors to a compact range 1..k preserving relative classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n    k = max(new_sol)\n    # Build adjacency list\n    adj = [[] for _ in range(V+1)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicting vertices\n    conflicts = []\n    for (u,v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts.append(u)\n            conflicts.append(v)\n    move = \"recolor_one\"\n    if conflicts:\n        idx = random.choice(conflicts) - 1\n        forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n        # Prefer admissible colors within 1..k, allow k+1 as escape if needed\n        palette = list(range(1, max(3, k) + 1))\n        admissible = [c for c in palette if c != new_sol[idx] and c not in forbidden]\n        if admissible:\n            new_sol[idx] = random.choice(admissible)\n            move = \"conflict_directed_recolor\"\n        else:\n            # No admissible within 1..k; try k+1\n            new_color = k + 1 if new_sol[idx] != k + 1 else max(1, (new_sol[idx] % (k+1)) + 1)\n            new_sol[idx] = new_color\n            move = \"escape_raise_palette\"\n    else:\n        # No conflicts: diversify slightly by recoloring a random vertex to a different existing color\n        idx = random.randrange(V)\n        palette = list(range(1, max(3, k) + 1))\n        candidates = [c for c in palette if c != new_sol[idx]]\n        if candidates:\n            new_sol[idx] = random.choice(candidates)\n            move = \"feasible_diversify_recolor\"\n        else:\n            move = \"noop_no_candidates\"\n    new_sol = normalize_colors(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Combines three mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices with colors from 1..max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and color a!=color(i); swap colors along the (a, color(i)) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_colors(solx: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in solx:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2,3,4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        # Build adjacency list\n        adj = [[] for _ in range(V)]\n        for (u,v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        v0 = random.randrange(V)\n        color_v0 = sol[v0]\n        palette = list(range(1, max(3, k) + 1))\n        alt_colors = [c for c in palette if c != color_v0]\n        if alt_colors:\n            a = color_v0\n            b = random.choice(alt_colors)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*V\n            if sol[v0] in (a,b):\n                queue = deque([v0])\n                visited[v0] = True\n                component = [v0]\n                while queue:\n                    u = queue.popleft()\n                    for w in adj[u]:\n                        if not visited[w] and sol[w] in (a,b):\n                            visited[w] = True\n                            queue.append(w)\n                            component.append(w)\n                # Swap colors a<->b on this component\n                for u in component:\n                    sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n    sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000997911}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS: A solution is a Python list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (i in {1..9}). Objective is to minimize k = max(ci) subject to c(u) != c(v) for every edge (u,v) in E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty with conflict count shaping.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Guide search: fewer violations is better; tie-break by smaller k\n        return PENALTY_BASE + violations * 1000 + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type).\n    - Prefer recoloring a conflicting vertex to an admissible color.\n    - If no conflicts, recolor a random vertex to another existing color or k+1 with small probability.\n    - After move, normalize colors to 1..k (color compression) to prevent palette drift.\n    \"\"\"\n    # Internal graph definition\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop_invalid_input\")\n\n    def normalize_colors(sol: List[int]) -> List[int]:\n        # Map colors to a compact range 1..k preserving relative classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n    k = max(new_sol)\n    # Build adjacency list\n    adj = [[] for _ in range(V+1)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicting vertices\n    conflicts = []\n    for (u,v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts.append(u)\n            conflicts.append(v)\n    move = \"recolor_one\"\n    if conflicts:\n        idx = random.choice(conflicts) - 1\n        forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n        # Prefer admissible colors within 1..k, allow k+1 as escape if needed\n        palette = list(range(1, max(3, k) + 1))\n        admissible = [c for c in palette if c != new_sol[idx] and c not in forbidden]\n        if admissible:\n            new_sol[idx] = random.choice(admissible)\n            move = \"conflict_directed_recolor\"\n        else:\n            # No admissible within 1..k; try k+1\n            new_color = k + 1 if new_sol[idx] != k + 1 else max(1, (new_sol[idx] % (k+1)) + 1)\n            new_sol[idx] = new_color\n            move = \"escape_raise_palette\"\n    else:\n        # No conflicts: diversify slightly by recoloring a random vertex to a different existing color\n        idx = random.randrange(V)\n        palette = list(range(1, max(3, k) + 1))\n        candidates = [c for c in palette if c != new_sol[idx]]\n        if candidates:\n            new_sol[idx] = random.choice(candidates)\n            move = \"feasible_diversify_recolor\"\n        else:\n            move = \"noop_no_candidates\"\n    new_sol = normalize_colors(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Combines three mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices with colors from 1..max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and color a!=color(i); swap colors along the (a, color(i)) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_colors(solx: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in solx:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2,3,4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        # Build adjacency list\n        adj = [[] for _ in range(V)]\n        for (u,v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        v0 = random.randrange(V)\n        color_v0 = sol[v0]\n        palette = list(range(1, max(3, k) + 1))\n        alt_colors = [c for c in palette if c != color_v0]\n        if alt_colors:\n            a = color_v0\n            b = random.choice(alt_colors)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*V\n            if sol[v0] in (a,b):\n                queue = deque([v0])\n                visited[v0] = True\n                component = [v0]\n                while queue:\n                    u = queue.popleft()\n                    for w in adj[u]:\n                        if not visited[w] and sol[w] in (a,b):\n                            visited[w] = True\n                            queue.append(w)\n                            component.append(w)\n                # Swap colors a<->b on this component\n                for u in component:\n                    sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n    sol = normalize_colors(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000959841}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty with conflict count shaping.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    VIOLATION_WEIGHT = 10_000\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Guide search: fewer violations is better; tie-break by smaller k\n        return PENALTY_BASE + violations * VIOLATION_WEIGHT + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type:str).\n    - If conflicts exist, recolor a high-conflict vertex to the smallest feasible color within current palette; allow k+1 only if no feasible color exists.\n    - If feasible, attempt to reduce k by recoloring a vertex of color k to a lower color; otherwise diversify by swapping two color labels.\n    - After move, run a light greedy repair on conflicted vertices and normalize colors by sorted unique labels to stabilize.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop_invalid_input\")\n\n    def normalize_sorted(sol: List[int]) -> List[int]:\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol]\n\n    # Build adjacency list (1-indexed for clarity with E)\n    adj = [[] for _ in range(V+1)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = solution[:]\n    k = max(new_sol)\n\n    # Identify conflicts and count per vertex\n    conflict_vertices = set()\n    conflict_degree = [0]*(V+1)\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n            conflict_degree[u] += 1\n            conflict_degree[v] += 1\n\n    move = \"noop\"\n\n    if conflict_vertices:\n        # Choose a vertex with highest conflict degree\n        idx = max(conflict_vertices, key=lambda x: conflict_degree[x]) - 1\n        forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n        # Try smallest feasible color within 1..k\n        chosen = None\n        for c in range(1, k+1):\n            if c != new_sol[idx] and c not in forbidden:\n                chosen = c\n                break\n        if chosen is not None:\n            old = new_sol[idx]\n            new_sol[idx] = chosen\n            move = f\"conflict_recolor_v{idx+1}_{old}->{chosen}\"\n        else:\n            # Allow k+1 as last resort\n            new_color = k + 1\n            old = new_sol[idx]\n            new_sol[idx] = new_color\n            move = f\"raise_palette_v{idx+1}_{old}->{new_color}\"\n    else:\n        # Feasible: try to reduce k by recoloring a vertex with color k\n        top_color_vertices = [i for i,c in enumerate(new_sol) if c == k]\n        reduced = False\n        random.shuffle(top_color_vertices)\n        for idx in top_color_vertices:\n            forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n            for c in range(1, k):\n                if c not in forbidden:\n                    old = new_sol[idx]\n                    new_sol[idx] = c\n                    move = f\"reduce_k_recolor_v{idx+1}_{old}->{c}\"\n                    reduced = True\n                    break\n            if reduced:\n                break\n        if not reduced:\n            # Diversify via color-class swap within existing palette\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                new_sol = [b if c == a else (a if c == b else c) for c in new_sol]\n                move = f\"swap_colors_{a}<->{b}\"\n            else:\n                move = \"noop_feasible\"\n\n    # Light greedy repair: fix any remaining conflicts without increasing k\n    # Iterate a few times to settle\n    for _ in range(2):\n        repaired_any = False\n        for vtx in range(1, V+1):\n            # If vtx is in conflict, try to assign smallest feasible <= current max color\n            has_conflict = any(new_sol[vtx-1] == new_sol[nbr-1] for nbr in adj[vtx])\n            if has_conflict:\n                forbidden = {new_sol[nbr-1] for nbr in adj[vtx]}\n                for c in range(1, max(new_sol)+1):\n                    if c not in forbidden:\n                        if new_sol[vtx-1] != c:\n                            new_sol[vtx-1] = c\n                            repaired_any = True\n                        break\n        if not repaired_any:\n            break\n\n    new_sol = normalize_sorted(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices with colors from 1..max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and color b != color(i); swap colors along the (a,b) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k (sorted unique).\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_sorted(solx: List[int]) -> List[int]:\n        uniq = sorted(set(solx))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in solx]\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2,3,4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        # Build adjacency list (0-indexed)\n        adj = [[] for _ in range(V)]\n        for (u, v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        v0 = random.randrange(V)\n        a = sol[v0]\n        palette = [c for c in range(1, max(3, k) + 1)]\n        alt_colors = [c for c in palette if c != a]\n        if alt_colors:\n            b = random.choice(alt_colors)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*V\n            queue = deque([v0])\n            visited[v0] = True\n            component = [v0]\n            while queue:\n                u = queue.popleft()\n                for w in adj[u]:\n                    if not visited[w] and sol[w] in (a, b):\n                        visited[w] = True\n                        queue.append(w)\n                        component.append(w)\n            # Swap colors a<->b on this component\n            for u in component:\n                sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    sol = normalize_sorted(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.0008936501}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty with conflict count shaping.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    VIOLATION_WEIGHT = 10_000\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Guide search: fewer violations is better; tie-break by smaller k\n        return PENALTY_BASE + violations * VIOLATION_WEIGHT + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type:str).\n    - If conflicts exist, recolor a high-conflict vertex to the smallest feasible color within current palette; allow k+1 only if no feasible color exists.\n    - If feasible, attempt to reduce k by recoloring a vertex of color k to a lower color; otherwise diversify by swapping two color labels.\n    - After move, run a light greedy repair on conflicted vertices and normalize colors by sorted unique labels to stabilize.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop_invalid_input\")\n\n    def normalize_sorted(sol: List[int]) -> List[int]:\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol]\n\n    # Build adjacency list (1-indexed for clarity with E)\n    adj = [[] for _ in range(V+1)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = solution[:]\n    k = max(new_sol)\n\n    # Identify conflicts and count per vertex\n    conflict_vertices = set()\n    conflict_degree = [0]*(V+1)\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n            conflict_degree[u] += 1\n            conflict_degree[v] += 1\n\n    move = \"noop\"\n\n    if conflict_vertices:\n        # Choose a vertex with highest conflict degree\n        idx = max(conflict_vertices, key=lambda x: conflict_degree[x]) - 1\n        forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n        # Try smallest feasible color within 1..k\n        chosen = None\n        for c in range(1, k+1):\n            if c != new_sol[idx] and c not in forbidden:\n                chosen = c\n                break\n        if chosen is not None:\n            old = new_sol[idx]\n            new_sol[idx] = chosen\n            move = f\"conflict_recolor_v{idx+1}_{old}->{chosen}\"\n        else:\n            # Allow k+1 as last resort\n            new_color = k + 1\n            old = new_sol[idx]\n            new_sol[idx] = new_color\n            move = f\"raise_palette_v{idx+1}_{old}->{new_color}\"\n    else:\n        # Feasible: try to reduce k by recoloring a vertex with color k\n        top_color_vertices = [i for i,c in enumerate(new_sol) if c == k]\n        reduced = False\n        random.shuffle(top_color_vertices)\n        for idx in top_color_vertices:\n            forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n            for c in range(1, k):\n                if c not in forbidden:\n                    old = new_sol[idx]\n                    new_sol[idx] = c\n                    move = f\"reduce_k_recolor_v{idx+1}_{old}->{c}\"\n                    reduced = True\n                    break\n            if reduced:\n                break\n        if not reduced:\n            # Diversify via color-class swap within existing palette\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                new_sol = [b if c == a else (a if c == b else c) for c in new_sol]\n                move = f\"swap_colors_{a}<->{b}\"\n            else:\n                move = \"noop_feasible\"\n\n    # Light greedy repair: fix any remaining conflicts without increasing k\n    # Iterate a few times to settle\n    for _ in range(2):\n        repaired_any = False\n        for vtx in range(1, V+1):\n            # If vtx is in conflict, try to assign smallest feasible <= current max color\n            has_conflict = any(new_sol[vtx-1] == new_sol[nbr-1] for nbr in adj[vtx])\n            if has_conflict:\n                forbidden = {new_sol[nbr-1] for nbr in adj[vtx]}\n                for c in range(1, max(new_sol)+1):\n                    if c not in forbidden:\n                        if new_sol[vtx-1] != c:\n                            new_sol[vtx-1] = c\n                            repaired_any = True\n                        break\n        if not repaired_any:\n            break\n\n    new_sol = normalize_sorted(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices with colors from 1..max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and color b != color(i); swap colors along the (a,b) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k (sorted unique).\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_sorted(solx: List[int]) -> List[int]:\n        uniq = sorted(set(solx))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in solx]\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2,3,4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        # Build adjacency list (0-indexed)\n        adj = [[] for _ in range(V)]\n        for (u, v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        v0 = random.randrange(V)\n        a = sol[v0]\n        palette = [c for c in range(1, max(3, k) + 1)]\n        alt_colors = [c for c in palette if c != a]\n        if alt_colors:\n            b = random.choice(alt_colors)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*V\n            queue = deque([v0])\n            visited[v0] = True\n            component = [v0]\n            while queue:\n                u = queue.popleft()\n                for w in adj[u]:\n                    if not visited[w] and sol[w] in (a, b):\n                        visited[w] = True\n                        queue.append(w)\n                        component.append(w)\n            # Swap colors a<->b on this component\n            for u in component:\n                sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    sol = normalize_sorted(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001240774}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better.\n    - Feasible: returns k = number of colors used (max color index).\n    - Infeasible or malformed: returns large penalty with conflict count shaping.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 10**6\n    VIOLATION_WEIGHT = 10_000\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Guide search: fewer violations is better; tie-break by smaller k\n        return PENALTY_BASE + violations * VIOLATION_WEIGHT + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type:str).\n    - If conflicts exist, recolor a high-conflict vertex to the smallest feasible color within current palette; allow k+1 only if no feasible color exists.\n    - If feasible, attempt to reduce k by recoloring a vertex of color k to a lower color; otherwise diversify by swapping two color labels.\n    - After move, run a light greedy repair on conflicted vertices and normalize colors by sorted unique labels to stabilize.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop_invalid_input\")\n\n    def normalize_sorted(sol: List[int]) -> List[int]:\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol]\n\n    # Build adjacency list (1-indexed for clarity with E)\n    adj = [[] for _ in range(V+1)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = solution[:]\n    k = max(new_sol)\n\n    # Identify conflicts and count per vertex\n    conflict_vertices = set()\n    conflict_degree = [0]*(V+1)\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n            conflict_degree[u] += 1\n            conflict_degree[v] += 1\n\n    move = \"noop\"\n\n    if conflict_vertices:\n        # Choose a vertex with highest conflict degree\n        idx = max(conflict_vertices, key=lambda x: conflict_degree[x]) - 1\n        forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n        # Try smallest feasible color within 1..k\n        chosen = None\n        for c in range(1, k+1):\n            if c != new_sol[idx] and c not in forbidden:\n                chosen = c\n                break\n        if chosen is not None:\n            old = new_sol[idx]\n            new_sol[idx] = chosen\n            move = f\"conflict_recolor_v{idx+1}_{old}->{chosen}\"\n        else:\n            # Allow k+1 as last resort\n            new_color = k + 1\n            old = new_sol[idx]\n            new_sol[idx] = new_color\n            move = f\"raise_palette_v{idx+1}_{old}->{new_color}\"\n    else:\n        # Feasible: try to reduce k by recoloring a vertex with color k\n        top_color_vertices = [i for i,c in enumerate(new_sol) if c == k]\n        reduced = False\n        random.shuffle(top_color_vertices)\n        for idx in top_color_vertices:\n            forbidden = {new_sol[nbr-1] for nbr in adj[idx+1]}\n            for c in range(1, k):\n                if c not in forbidden:\n                    old = new_sol[idx]\n                    new_sol[idx] = c\n                    move = f\"reduce_k_recolor_v{idx+1}_{old}->{c}\"\n                    reduced = True\n                    break\n            if reduced:\n                break\n        if not reduced:\n            # Diversify via color-class swap within existing palette\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                new_sol = [b if c == a else (a if c == b else c) for c in new_sol]\n                move = f\"swap_colors_{a}<->{b}\"\n            else:\n                move = \"noop_feasible\"\n\n    # Light greedy repair: fix any remaining conflicts without increasing k\n    # Iterate a few times to settle\n    for _ in range(2):\n        repaired_any = False\n        for vtx in range(1, V+1):\n            # If vtx is in conflict, try to assign smallest feasible <= current max color\n            has_conflict = any(new_sol[vtx-1] == new_sol[nbr-1] for nbr in adj[vtx])\n            if has_conflict:\n                forbidden = {new_sol[nbr-1] for nbr in adj[vtx]}\n                for c in range(1, max(new_sol)+1):\n                    if c not in forbidden:\n                        if new_sol[vtx-1] != c:\n                            new_sol[vtx-1] = c\n                            repaired_any = True\n                        break\n        if not repaired_any:\n            break\n\n    new_sol = normalize_sorted(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices with colors from 1..max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and color b != color(i); swap colors along the (a,b) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k (sorted unique).\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_sorted(solx: List[int]) -> List[int]:\n        uniq = sorted(set(solx))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in solx]\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2,3,4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        # Build adjacency list (0-indexed)\n        adj = [[] for _ in range(V)]\n        for (u, v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        v0 = random.randrange(V)\n        a = sol[v0]\n        palette = [c for c in range(1, max(3, k) + 1)]\n        alt_colors = [c for c in palette if c != a]\n        if alt_colors:\n            b = random.choice(alt_colors)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*V\n            queue = deque([v0])\n            visited[v0] = True\n            component = [v0]\n            while queue:\n                u = queue.popleft()\n                for w in adj[u]:\n                    if not visited[w] and sol[w] in (a, b):\n                        visited[w] = True\n                        queue.append(w)\n                        component.append(w)\n            # Swap colors a<->b on this component\n            for u in component:\n                sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    sol = normalize_sorted(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001471826}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness (lower is better):\n    - Feasible: returns k = max color used.\n    - Infeasible or malformed: returns large penalty with conflict count priority.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 1_000_000  # ensures any diff in violations dominates k\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Strictly prioritize fewer violations; tie-break by smaller k\n        return PENALTY_BASE * violations + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type:str with schema 'type|vertex|old|new').\n    - If conflicts exist, recolor a high-conflict vertex to smallest feasible color; if none, allow k+1.\n    - If feasible, try to reduce k by recoloring a vertex currently using color k.\n    - Light repair to resolve residual conflicts without increasing palette.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop|0|0|0\")\n\n    def normalize_sorted(sol: List[int]) -> List[int]:\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol]\n\n    # Build adjacency (1-indexed)\n    adj = [[] for _ in range(V + 1)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = solution[:]\n    k = max(new_sol)\n\n    # Identify conflicts and count per vertex\n    conflict_vertices = set()\n    conflict_degree = [0] * (V + 1)\n    for (u, v) in E:\n        if new_sol[u - 1] == new_sol[v - 1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n            conflict_degree[u] += 1\n            conflict_degree[v] += 1\n\n    move = \"noop|0|0|0\"\n\n    if conflict_vertices:\n        # Choose a vertex with highest conflict degree (break ties randomly)\n        max_cd = max(conflict_degree[v] for v in conflict_vertices)\n        candidates = [v for v in conflict_vertices if conflict_degree[v] == max_cd]\n        vtx = random.choice(candidates)\n        idx = vtx - 1\n        forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n        chosen = None\n        for c in range(1, k + 1):\n            if c != new_sol[idx] and c not in forbidden:\n                chosen = c\n                break\n        if chosen is not None:\n            old = new_sol[idx]\n            new_sol[idx] = chosen\n            move = f\"recolor_conflict|{vtx}|{old}|{chosen}\"\n        else:\n            # Allow k+1 only as last resort\n            old = new_sol[idx]\n            new_sol[idx] = k + 1\n            move = f\"raise_palette|{vtx}|{old}|{k + 1}\"\n    else:\n        # Feasible: try to reduce k by recoloring a vertex with color k\n        top_color_vertices = [i for i, c in enumerate(new_sol) if c == k]\n        random.shuffle(top_color_vertices)\n        reduced = False\n        for idx in top_color_vertices:\n            vtx = idx + 1\n            forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n            for c in range(1, k):\n                if c not in forbidden:\n                    old = new_sol[idx]\n                    new_sol[idx] = c\n                    move = f\"reduce_k|{vtx}|{old}|{c}\"\n                    reduced = True\n                    break\n            if reduced:\n                break\n        if not reduced:\n            # Minor diversification: swap two color labels if possible\n            if k >= 2:\n                a, b = random.sample(range(1, k + 1), 2)\n                new_sol = [b if c == a else (a if c == b else c) for c in new_sol]\n                move = f\"swap_labels|0|{a}|{b}\"\n            else:\n                move = \"noop|0|0|0\"\n\n    # Light greedy repair capped by V iterations\n    for _ in range(V):\n        repaired_any = False\n        for vtx in range(1, V + 1):\n            # If vtx is in conflict, try to assign smallest feasible color within current palette\n            if any(new_sol[vtx - 1] == new_sol[nbr - 1] for nbr in adj[vtx]):\n                forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n                for c in range(1, max(new_sol) + 1):\n                    if c not in forbidden:\n                        if new_sol[vtx - 1] != c:\n                            new_sol[vtx - 1] = c\n                            repaired_any = True\n                        break\n        if not repaired_any:\n            break\n\n    new_sol = normalize_sorted(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices using palette up to max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and alt color b; swap colors along (a,b) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k (sorted unique).\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_sorted(solx: List[int]) -> List[int]:\n        uniq = sorted(set(solx))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in solx]\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2, 3, 4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        adj = [[] for _ in range(V)]\n        for (u, v) in E:\n            adj[u - 1].append(v - 1)\n            adj[v - 1].append(u - 1)\n        v0 = random.randrange(V)\n        a = sol[v0]\n        palette = [c for c in range(1, max(3, k) + 1)]\n        alt_colors = [c for c in palette if c != a]\n        if alt_colors:\n            b = random.choice(alt_colors)\n            visited = [False] * V\n            queue = deque([v0])\n            visited[v0] = True\n            component = [v0]\n            while queue:\n                u = queue.popleft()\n                for w in adj[u]:\n                    if not visited[w] and sol[w] in (a, b):\n                        visited[w] = True\n                        queue.append(w)\n                        component.append(w)\n            # Swap colors a<->b on this component\n            for u in component:\n                sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    sol = normalize_sorted(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00087418}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness (lower is better):\n    - Feasible: returns k = max color used.\n    - Infeasible or malformed: returns large penalty with conflict count priority.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 1_000_000  # ensures any diff in violations dominates k\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Strictly prioritize fewer violations; tie-break by smaller k\n        return PENALTY_BASE * violations + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type:str with schema 'type|vertex|old|new').\n    - If conflicts exist, recolor a high-conflict vertex to smallest feasible color; if none, allow k+1.\n    - If feasible, try to reduce k by recoloring a vertex currently using color k.\n    - Light repair to resolve residual conflicts without increasing palette.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop|0|0|0\")\n\n    def normalize_sorted(sol: List[int]) -> List[int]:\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol]\n\n    # Build adjacency (1-indexed)\n    adj = [[] for _ in range(V + 1)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = solution[:]\n    k = max(new_sol)\n\n    # Identify conflicts and count per vertex\n    conflict_vertices = set()\n    conflict_degree = [0] * (V + 1)\n    for (u, v) in E:\n        if new_sol[u - 1] == new_sol[v - 1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n            conflict_degree[u] += 1\n            conflict_degree[v] += 1\n\n    move = \"noop|0|0|0\"\n\n    if conflict_vertices:\n        # Choose a vertex with highest conflict degree (break ties randomly)\n        max_cd = max(conflict_degree[v] for v in conflict_vertices)\n        candidates = [v for v in conflict_vertices if conflict_degree[v] == max_cd]\n        vtx = random.choice(candidates)\n        idx = vtx - 1\n        forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n        chosen = None\n        for c in range(1, k + 1):\n            if c != new_sol[idx] and c not in forbidden:\n                chosen = c\n                break\n        if chosen is not None:\n            old = new_sol[idx]\n            new_sol[idx] = chosen\n            move = f\"recolor_conflict|{vtx}|{old}|{chosen}\"\n        else:\n            # Allow k+1 only as last resort\n            old = new_sol[idx]\n            new_sol[idx] = k + 1\n            move = f\"raise_palette|{vtx}|{old}|{k + 1}\"\n    else:\n        # Feasible: try to reduce k by recoloring a vertex with color k\n        top_color_vertices = [i for i, c in enumerate(new_sol) if c == k]\n        random.shuffle(top_color_vertices)\n        reduced = False\n        for idx in top_color_vertices:\n            vtx = idx + 1\n            forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n            for c in range(1, k):\n                if c not in forbidden:\n                    old = new_sol[idx]\n                    new_sol[idx] = c\n                    move = f\"reduce_k|{vtx}|{old}|{c}\"\n                    reduced = True\n                    break\n            if reduced:\n                break\n        if not reduced:\n            # Minor diversification: swap two color labels if possible\n            if k >= 2:\n                a, b = random.sample(range(1, k + 1), 2)\n                new_sol = [b if c == a else (a if c == b else c) for c in new_sol]\n                move = f\"swap_labels|0|{a}|{b}\"\n            else:\n                move = \"noop|0|0|0\"\n\n    # Light greedy repair capped by V iterations\n    for _ in range(V):\n        repaired_any = False\n        for vtx in range(1, V + 1):\n            # If vtx is in conflict, try to assign smallest feasible color within current palette\n            if any(new_sol[vtx - 1] == new_sol[nbr - 1] for nbr in adj[vtx]):\n                forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n                for c in range(1, max(new_sol) + 1):\n                    if c not in forbidden:\n                        if new_sol[vtx - 1] != c:\n                            new_sol[vtx - 1] = c\n                            repaired_any = True\n                        break\n        if not repaired_any:\n            break\n\n    new_sol = normalize_sorted(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices using palette up to max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and alt color b; swap colors along (a,b) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k (sorted unique).\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_sorted(solx: List[int]) -> List[int]:\n        uniq = sorted(set(solx))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in solx]\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2, 3, 4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        adj = [[] for _ in range(V)]\n        for (u, v) in E:\n            adj[u - 1].append(v - 1)\n            adj[v - 1].append(u - 1)\n        v0 = random.randrange(V)\n        a = sol[v0]\n        palette = [c for c in range(1, max(3, k) + 1)]\n        alt_colors = [c for c in palette if c != a]\n        if alt_colors:\n            b = random.choice(alt_colors)\n            visited = [False] * V\n            queue = deque([v0])\n            visited[v0] = True\n            component = [v0]\n            while queue:\n                u = queue.popleft()\n                for w in adj[u]:\n                    if not visited[w] and sol[w] in (a, b):\n                        visited[w] = True\n                        queue.append(w)\n                        component.append(w)\n            # Swap colors a<->b on this component\n            for u in component:\n                sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    sol = normalize_sorted(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001199904}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_14_textbook_standard","Representacion":"LIST9_POS_INT_COLORS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness (lower is better):\n    - Feasible: returns k = max color used.\n    - Infeasible or malformed: returns large penalty with conflict count priority.\n    Graph (undirected): V={1..9}\n    E={(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)}\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    PENALTY_BASE = 1_000_000  # ensures any diff in violations dominates k\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 100_000\n    if len(solution) != V:\n        return PENALTY_BASE + 50_000 + abs(len(solution) - V)\n    # Validate entries and compute k\n    k = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE + 40_000\n        if x <= 0:\n            return PENALTY_BASE + 30_000\n        if x > k:\n            k = x\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    if violations > 0:\n        # Strictly prioritize fewer violations; tie-break by smaller k\n        return PENALTY_BASE * violations + k\n    # Feasible: fitness equals number of colors used (minimize)\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Conflict-directed neighbor generator.\n    Returns (new_solution, movement_type:str with schema 'type|vertex|old|new').\n    - If conflicts exist, recolor a high-conflict vertex to smallest feasible color; if none, allow k+1.\n    - If feasible, try to reduce k by recoloring a vertex currently using color k.\n    - Light repair to resolve residual conflicts without increasing palette.\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return (solution, \"noop|0|0|0\")\n\n    def normalize_sorted(sol: List[int]) -> List[int]:\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in sol]\n\n    # Build adjacency (1-indexed)\n    adj = [[] for _ in range(V + 1)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    new_sol = solution[:]\n    k = max(new_sol)\n\n    # Identify conflicts and count per vertex\n    conflict_vertices = set()\n    conflict_degree = [0] * (V + 1)\n    for (u, v) in E:\n        if new_sol[u - 1] == new_sol[v - 1]:\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n            conflict_degree[u] += 1\n            conflict_degree[v] += 1\n\n    move = \"noop|0|0|0\"\n\n    if conflict_vertices:\n        # Choose a vertex with highest conflict degree (break ties randomly)\n        max_cd = max(conflict_degree[v] for v in conflict_vertices)\n        candidates = [v for v in conflict_vertices if conflict_degree[v] == max_cd]\n        vtx = random.choice(candidates)\n        idx = vtx - 1\n        forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n        chosen = None\n        for c in range(1, k + 1):\n            if c != new_sol[idx] and c not in forbidden:\n                chosen = c\n                break\n        if chosen is not None:\n            old = new_sol[idx]\n            new_sol[idx] = chosen\n            move = f\"recolor_conflict|{vtx}|{old}|{chosen}\"\n        else:\n            # Allow k+1 only as last resort\n            old = new_sol[idx]\n            new_sol[idx] = k + 1\n            move = f\"raise_palette|{vtx}|{old}|{k + 1}\"\n    else:\n        # Feasible: try to reduce k by recoloring a vertex with color k\n        top_color_vertices = [i for i, c in enumerate(new_sol) if c == k]\n        random.shuffle(top_color_vertices)\n        reduced = False\n        for idx in top_color_vertices:\n            vtx = idx + 1\n            forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n            for c in range(1, k):\n                if c not in forbidden:\n                    old = new_sol[idx]\n                    new_sol[idx] = c\n                    move = f\"reduce_k|{vtx}|{old}|{c}\"\n                    reduced = True\n                    break\n            if reduced:\n                break\n        if not reduced:\n            # Minor diversification: swap two color labels if possible\n            if k >= 2:\n                a, b = random.sample(range(1, k + 1), 2)\n                new_sol = [b if c == a else (a if c == b else c) for c in new_sol]\n                move = f\"swap_labels|0|{a}|{b}\"\n            else:\n                move = \"noop|0|0|0\"\n\n    # Light greedy repair capped by V iterations\n    for _ in range(V):\n        repaired_any = False\n        for vtx in range(1, V + 1):\n            # If vtx is in conflict, try to assign smallest feasible color within current palette\n            if any(new_sol[vtx - 1] == new_sol[nbr - 1] for nbr in adj[vtx]):\n                forbidden = {new_sol[nbr - 1] for nbr in adj[vtx]}\n                for c in range(1, max(new_sol) + 1):\n                    if c not in forbidden:\n                        if new_sol[vtx - 1] != c:\n                            new_sol[vtx - 1] = c\n                            repaired_any = True\n                        break\n        if not repaired_any:\n            break\n\n    new_sol = normalize_sorted(new_sol)\n    return (new_sol, move)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation to escape local minima. Returns a new solution list.\n    Mechanisms chosen at random:\n    - Multi-recolor: recolor r in {2,3,4} random vertices using palette up to max(k+1,3).\n    - Color-swap: pick two color labels and swap them.\n    - Kempe-chain swap: pick vertex i and alt color b; swap colors along (a,b) Kempe chain containing i.\n    After perturbation, normalize colors to 1..k (sorted unique).\n    \"\"\"\n    V = 9\n    E = [(1,2),(1,4),(1,6),(2,5),(2,7),(3,5),(3,9),(4,6),(4,8),(5,6),(5,7),(5,8),(6,7),(6,8),(8,9)]\n    if not isinstance(solution, list) or len(solution) != V:\n        return solution\n    sol = solution[:]\n\n    def normalize_sorted(solx: List[int]) -> List[int]:\n        uniq = sorted(set(solx))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[c] for c in solx]\n\n    k = max(sol)\n    choice = random.random()\n    if choice < 0.4:\n        # Multi-recolor\n        r = random.choice([2, 3, 4])\n        idxs = list(range(V))\n        random.shuffle(idxs)\n        idxs = idxs[:r]\n        palette_max = max(3, k + 1)\n        for idx in idxs:\n            current = sol[idx]\n            candidates = [c for c in range(1, palette_max + 1) if c != current]\n            if candidates:\n                sol[idx] = random.choice(candidates)\n    elif choice < 0.7:\n        # Color-swap between two labels\n        if k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [b if c == a else (a if c == b else c) for c in sol]\n    else:\n        # Kempe-chain swap on colors (a,b)\n        adj = [[] for _ in range(V)]\n        for (u, v) in E:\n            adj[u - 1].append(v - 1)\n            adj[v - 1].append(u - 1)\n        v0 = random.randrange(V)\n        a = sol[v0]\n        palette = [c for c in range(1, max(3, k) + 1)]\n        alt_colors = [c for c in palette if c != a]\n        if alt_colors:\n            b = random.choice(alt_colors)\n            visited = [False] * V\n            queue = deque([v0])\n            visited[v0] = True\n            component = [v0]\n            while queue:\n                u = queue.popleft()\n                for w in adj[u]:\n                    if not visited[w] and sol[w] in (a, b):\n                        visited[w] = True\n                        queue.append(w)\n                        component.append(w)\n            # Swap colors a<->b on this component\n            for u in component:\n                sol[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n\n    sol = normalize_sorted(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001191973}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Contiguity\/domain check\n    k = max(solution)\n    for x in solution:\n        if x > k:\n            return 10**9\n    # Graph edges (1-based vertices)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return 10**9 + violations\n    # Valid coloring: minimize number of colors used\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    # If invalid input, initialize randomly\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return (normalize(sol), \"ColorChange\", \"InitRandom\")\n    sol = list(solution)\n    r = random.random()\n    if r < 0.7:\n        # Recolor a single vertex to a random color in [1..k+1]\n        idx = random.randrange(9)\n        k = max(1, max(sol))\n        sol[idx] = random.randint(1, k + 1)\n        sol = normalize(sol)\n        return (sol, \"Local\", \"RecolorSingle\")\n    else:\n        # Swap two existing color labels\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            swap = {a: b, b: a}\n            sol = [swap.get(x, x) for x in sol]\n            sol = normalize(sol)\n            return (sol, \"Label\", \"SwapColors\")\n        # Fallback: recolor single\n        idx = random.randrange(9)\n        k = max(1, max(sol))\n        sol[idx] = random.randint(1, k + 1)\n        sol = normalize(sol)\n        return (sol, \"Local\", \"RecolorSingle\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    # If invalid input, initialize randomly\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return normalize(sol)\n    sol = list(solution)\n    k = max(1, max(sol))\n    m = max(2, int(0.3 * len(sol)))\n    idxs = random.sample(range(9), m)\n    for idx in idxs:\n        sol[idx] = random.randint(1, k + 1)\n    # Occasionally introduce a new color to escape local minima\n    if random.random() < 0.3:\n        sol[random.randrange(9)] = max(1, max(sol)) + 1\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000528376}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Contiguity\/domain check\n    k = max(solution)\n    for x in solution:\n        if x > k:\n            return 10**9\n    # Graph edges (1-based vertices)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return 10**9 + violations\n    # Valid coloring: minimize number of colors used\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    # If invalid input, initialize randomly\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return (normalize(sol), \"ColorChange\", \"InitRandom\")\n    sol = list(solution)\n    r = random.random()\n    if r < 0.7:\n        # Recolor a single vertex to a random color in [1..k+1]\n        idx = random.randrange(9)\n        k = max(1, max(sol))\n        sol[idx] = random.randint(1, k + 1)\n        sol = normalize(sol)\n        return (sol, \"Local\", \"RecolorSingle\")\n    else:\n        # Swap two existing color labels\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            swap = {a: b, b: a}\n            sol = [swap.get(x, x) for x in sol]\n            sol = normalize(sol)\n            return (sol, \"Label\", \"SwapColors\")\n        # Fallback: recolor single\n        idx = random.randrange(9)\n        k = max(1, max(sol))\n        sol[idx] = random.randint(1, k + 1)\n        sol = normalize(sol)\n        return (sol, \"Local\", \"RecolorSingle\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    # If invalid input, initialize randomly\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return normalize(sol)\n    sol = list(solution)\n    k = max(1, max(sol))\n    m = max(2, int(0.3 * len(sol)))\n    idxs = random.sample(range(9), m)\n    for idx in idxs:\n        sol[idx] = random.randint(1, k + 1)\n    # Occasionally introduce a new color to escape local minima\n    if random.random() < 0.3:\n        sol[random.randrange(9)] = max(1, max(sol)) + 1\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000588336}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    # Validate entries are positive integers\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Contiguity\/domain check\n    k = max(solution)\n    for x in solution:\n        if x > k:\n            return 10**9\n    # Graph edges (1-based vertices)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    if violations > 0:\n        return 10**9 + violations\n    # Valid coloring: minimize number of colors used\n    return len(set(solution))\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    # If invalid input, initialize randomly\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return (normalize(sol), \"ColorChange\", \"InitRandom\")\n    sol = list(solution)\n    r = random.random()\n    if r < 0.7:\n        # Recolor a single vertex to a random color in [1..k+1]\n        idx = random.randrange(9)\n        k = max(1, max(sol))\n        sol[idx] = random.randint(1, k + 1)\n        sol = normalize(sol)\n        return (sol, \"Local\", \"RecolorSingle\")\n    else:\n        # Swap two existing color labels\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            swap = {a: b, b: a}\n            sol = [swap.get(x, x) for x in sol]\n            sol = normalize(sol)\n            return (sol, \"Label\", \"SwapColors\")\n        # Fallback: recolor single\n        idx = random.randrange(9)\n        k = max(1, max(sol))\n        sol[idx] = random.randint(1, k + 1)\n        sol = normalize(sol)\n        return (sol, \"Local\", \"RecolorSingle\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    # If invalid input, initialize randomly\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return normalize(sol)\n    sol = list(solution)\n    k = max(1, max(sol))\n    m = max(2, int(0.3 * len(sol)))\n    idxs = random.sample(range(9), m)\n    for idx in idxs:\n        sol[idx] = random.randint(1, k + 1)\n    # Occasionally introduce a new color to escape local minima\n    if random.random() < 0.3:\n        sol[random.randrange(9)] = max(1, max(sol)) + 1\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000574297}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000  # invalid structure penalty\n    # Integer and positivity checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic objective: minimize violations first, then number of colors\n    if violations > 0:\n        alpha = 100\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def conflicts(sol: List[int]) -> List[Tuple[int,int]]:\n        bad = []\n        for u, v in edges():\n            if sol[u-1] == sol[v-1]:\n                bad.append((u-1, v-1))\n        return bad\n    def kempe_chain_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        a = random.randrange(n)\n        c1 = sol[a]\n        # pick a different existing color or create if none\n        palette = list(set(sol))\n        if len(palette) == 1:\n            c2 = c1 + 1\n        else:\n            others = [c for c in palette if c != c1]\n            c2 = random.choice(others)\n        # Build chain on colors c1,c2 respecting adjacency\n        E = edges()\n        adj = [[] for _ in range(n)]\n        for u,v in E:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        chain = set()\n        stack = [a]\n        while stack:\n            u = stack.pop()\n            if u in chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n    # Ensure a base solution\n    sol_ok = isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not sol_ok:\n        # Greedy-by-degree init\n        E = edges()\n        deg = [0]*9\n        for u,v in E:\n            deg[u-1]+=1; deg[v-1]+=1\n        order = sorted(range(9), key=lambda i: -deg[i])\n        sol = [0]*9\n        for v in order:\n            used = {sol[u-1] for (u,w) in E if w==v+1 and sol[u-1]>0}\n            used |= {sol[w-1] for (u,w) in E if u==v+1 and sol[w-1]>0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[v] = c\n        return normalize(sol)\n    sol = list(solution)\n    # Decide move type: conflict-directed recolor (60%), kempe (25%), label swap (15%)\n    r = random.random()\n    bad = conflicts(sol)\n    if r < 0.60 and bad:\n        # Pick a conflicting vertex and recolor to best existing color\n        u, v = random.choice(bad)\n        target = random.choice([u, v])\n        palette = list(set(sol))\n        E = edges()\n        neigh = set()\n        for x,y in E:\n            x-=1; y-=1\n            if x == target:\n                neigh.add(y)\n            elif y == target:\n                neigh.add(x)\n        best_c = sol[target]\n        best_score = None\n        # Prefer existing colors; occasionally allow new color\n        allow_new = random.random() < 0.05\n        candidates = palette[:]\n        if allow_new:\n            candidates.append(max(palette)+1)\n        for c in candidates:\n            if c == sol[target]:\n                continue\n            tsol = sol[:]\n            tsol[target] = c\n            # score: number of new conflicts at target\n            new_conf = 0\n            for w in neigh:\n                if tsol[w] == c:\n                    new_conf += 1\n            score = (new_conf, len(set(tsol)))\n            if best_score is None or score < best_score:\n                best_score = score\n                best_c = c\n        sol[target] = best_c\n        # Non-bijective change: normalize\n        return normalize(sol)\n    elif r < 0.85:\n        # Kempe-chain swap between two colors\n        out = kempe_chain_swap(sol)\n        # Kempe swap is bijective on two colors involved; no need to normalize\n        return out\n    else:\n        # Swap two color labels (pure relabeling)\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            swap = {a: b, b: a}\n            out = [swap.get(x, x) for x in sol]\n            return out\n        # Fallback: recolor a random vertex to existing color\n        i = random.randrange(9)\n        return normalize(sol[:i] + [sol[i]] + sol[i+1:])\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def edges() -> List[tuple]:\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    # Validate base\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # Light random valid-ish init\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return normalize(sol)\n    sol = list(solution)\n    n = len(sol)\n    # Multi-kick: recolor a small subset and perform 1 Kempe swap\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(range(n), m)\n    palette = list(set(sol))\n    for idx in idxs:\n        # 80% existing colors, 20% possibly introduce new\n        if random.random() < 0.8:\n            sol[idx] = random.choice(palette)\n        else:\n            sol[idx] = max(palette) + 1\n            palette = list(set(sol))\n    # One Kempe-chain interchange\n    def kempe(sol_in: List[int]) -> List[int]:\n        sol2 = sol_in[:]\n        a = random.randrange(n)\n        c1 = sol2[a]\n        palette2 = list(set(sol2))\n        if len(palette2) == 1:\n            c2 = c1 + 1\n        else:\n            c2 = random.choice([c for c in palette2 if c != c1])\n        # Build adjacency\n        E = edges()\n        adj = [[] for _ in range(n)]\n        for u,v in E:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        chain = set([a])\n        stack = [a]\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if sol2[w] in (c1, c2) and w not in chain:\n                    chain.add(w)\n                    stack.append(w)\n        for u in chain:\n            sol2[u] = c2 if sol2[u] == c1 else c1\n        return sol2\n    sol = kempe(sol)\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001138413}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000  # invalid structure penalty\n    # Integer and positivity checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic objective: minimize violations first, then number of colors\n    if violations > 0:\n        alpha = 100\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def conflicts(sol: List[int]) -> List[Tuple[int,int]]:\n        bad = []\n        for u, v in edges():\n            if sol[u-1] == sol[v-1]:\n                bad.append((u-1, v-1))\n        return bad\n    def kempe_chain_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        a = random.randrange(n)\n        c1 = sol[a]\n        # pick a different existing color or create if none\n        palette = list(set(sol))\n        if len(palette) == 1:\n            c2 = c1 + 1\n        else:\n            others = [c for c in palette if c != c1]\n            c2 = random.choice(others)\n        # Build chain on colors c1,c2 respecting adjacency\n        E = edges()\n        adj = [[] for _ in range(n)]\n        for u,v in E:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        chain = set()\n        stack = [a]\n        while stack:\n            u = stack.pop()\n            if u in chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n    # Ensure a base solution\n    sol_ok = isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not sol_ok:\n        # Greedy-by-degree init\n        E = edges()\n        deg = [0]*9\n        for u,v in E:\n            deg[u-1]+=1; deg[v-1]+=1\n        order = sorted(range(9), key=lambda i: -deg[i])\n        sol = [0]*9\n        for v in order:\n            used = {sol[u-1] for (u,w) in E if w==v+1 and sol[u-1]>0}\n            used |= {sol[w-1] for (u,w) in E if u==v+1 and sol[w-1]>0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[v] = c\n        return normalize(sol)\n    sol = list(solution)\n    # Decide move type: conflict-directed recolor (60%), kempe (25%), label swap (15%)\n    r = random.random()\n    bad = conflicts(sol)\n    if r < 0.60 and bad:\n        # Pick a conflicting vertex and recolor to best existing color\n        u, v = random.choice(bad)\n        target = random.choice([u, v])\n        palette = list(set(sol))\n        E = edges()\n        neigh = set()\n        for x,y in E:\n            x-=1; y-=1\n            if x == target:\n                neigh.add(y)\n            elif y == target:\n                neigh.add(x)\n        best_c = sol[target]\n        best_score = None\n        # Prefer existing colors; occasionally allow new color\n        allow_new = random.random() < 0.05\n        candidates = palette[:]\n        if allow_new:\n            candidates.append(max(palette)+1)\n        for c in candidates:\n            if c == sol[target]:\n                continue\n            tsol = sol[:]\n            tsol[target] = c\n            # score: number of new conflicts at target\n            new_conf = 0\n            for w in neigh:\n                if tsol[w] == c:\n                    new_conf += 1\n            score = (new_conf, len(set(tsol)))\n            if best_score is None or score < best_score:\n                best_score = score\n                best_c = c\n        sol[target] = best_c\n        # Non-bijective change: normalize\n        return normalize(sol)\n    elif r < 0.85:\n        # Kempe-chain swap between two colors\n        out = kempe_chain_swap(sol)\n        # Kempe swap is bijective on two colors involved; no need to normalize\n        return out\n    else:\n        # Swap two color labels (pure relabeling)\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            swap = {a: b, b: a}\n            out = [swap.get(x, x) for x in sol]\n            return out\n        # Fallback: recolor a random vertex to existing color\n        i = random.randrange(9)\n        return normalize(sol[:i] + [sol[i]] + sol[i+1:])\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def edges() -> List[tuple]:\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    # Validate base\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # Light random valid-ish init\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return normalize(sol)\n    sol = list(solution)\n    n = len(sol)\n    # Multi-kick: recolor a small subset and perform 1 Kempe swap\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(range(n), m)\n    palette = list(set(sol))\n    for idx in idxs:\n        # 80% existing colors, 20% possibly introduce new\n        if random.random() < 0.8:\n            sol[idx] = random.choice(palette)\n        else:\n            sol[idx] = max(palette) + 1\n            palette = list(set(sol))\n    # One Kempe-chain interchange\n    def kempe(sol_in: List[int]) -> List[int]:\n        sol2 = sol_in[:]\n        a = random.randrange(n)\n        c1 = sol2[a]\n        palette2 = list(set(sol2))\n        if len(palette2) == 1:\n            c2 = c1 + 1\n        else:\n            c2 = random.choice([c for c in palette2 if c != c1])\n        # Build adjacency\n        E = edges()\n        adj = [[] for _ in range(n)]\n        for u,v in E:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        chain = set([a])\n        stack = [a]\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if sol2[w] in (c1, c2) and w not in chain:\n                    chain.add(w)\n                    stack.append(w)\n        for u in chain:\n            sol2[u] = c2 if sol2[u] == c1 else c1\n        return sol2\n    sol = kempe(sol)\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001386626}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Type and length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000  # invalid structure penalty\n    # Integer and positivity checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic objective: minimize violations first, then number of colors\n    if violations > 0:\n        alpha = 100\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def edges() -> List[Tuple[int,int]]:\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def conflicts(sol: List[int]) -> List[Tuple[int,int]]:\n        bad = []\n        for u, v in edges():\n            if sol[u-1] == sol[v-1]:\n                bad.append((u-1, v-1))\n        return bad\n    def kempe_chain_swap(sol: List[int]) -> List[int]:\n        n = len(sol)\n        if n == 0:\n            return sol\n        a = random.randrange(n)\n        c1 = sol[a]\n        # pick a different existing color or create if none\n        palette = list(set(sol))\n        if len(palette) == 1:\n            c2 = c1 + 1\n        else:\n            others = [c for c in palette if c != c1]\n            c2 = random.choice(others)\n        # Build chain on colors c1,c2 respecting adjacency\n        E = edges()\n        adj = [[] for _ in range(n)]\n        for u,v in E:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        chain = set()\n        stack = [a]\n        while stack:\n            u = stack.pop()\n            if u in chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n    # Ensure a base solution\n    sol_ok = isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)\n    if not sol_ok:\n        # Greedy-by-degree init\n        E = edges()\n        deg = [0]*9\n        for u,v in E:\n            deg[u-1]+=1; deg[v-1]+=1\n        order = sorted(range(9), key=lambda i: -deg[i])\n        sol = [0]*9\n        for v in order:\n            used = {sol[u-1] for (u,w) in E if w==v+1 and sol[u-1]>0}\n            used |= {sol[w-1] for (u,w) in E if u==v+1 and sol[w-1]>0}\n            c = 1\n            while c in used:\n                c += 1\n            sol[v] = c\n        return normalize(sol)\n    sol = list(solution)\n    # Decide move type: conflict-directed recolor (60%), kempe (25%), label swap (15%)\n    r = random.random()\n    bad = conflicts(sol)\n    if r < 0.60 and bad:\n        # Pick a conflicting vertex and recolor to best existing color\n        u, v = random.choice(bad)\n        target = random.choice([u, v])\n        palette = list(set(sol))\n        E = edges()\n        neigh = set()\n        for x,y in E:\n            x-=1; y-=1\n            if x == target:\n                neigh.add(y)\n            elif y == target:\n                neigh.add(x)\n        best_c = sol[target]\n        best_score = None\n        # Prefer existing colors; occasionally allow new color\n        allow_new = random.random() < 0.05\n        candidates = palette[:]\n        if allow_new:\n            candidates.append(max(palette)+1)\n        for c in candidates:\n            if c == sol[target]:\n                continue\n            tsol = sol[:]\n            tsol[target] = c\n            # score: number of new conflicts at target\n            new_conf = 0\n            for w in neigh:\n                if tsol[w] == c:\n                    new_conf += 1\n            score = (new_conf, len(set(tsol)))\n            if best_score is None or score < best_score:\n                best_score = score\n                best_c = c\n        sol[target] = best_c\n        # Non-bijective change: normalize\n        return normalize(sol)\n    elif r < 0.85:\n        # Kempe-chain swap between two colors\n        out = kempe_chain_swap(sol)\n        # Kempe swap is bijective on two colors involved; no need to normalize\n        return out\n    else:\n        # Swap two color labels (pure relabeling)\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            swap = {a: b, b: a}\n            out = [swap.get(x, x) for x in sol]\n            return out\n        # Fallback: recolor a random vertex to existing color\n        i = random.randrange(9)\n        return normalize(sol[:i] + [sol[i]] + sol[i+1:])\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    def normalize(sol: List[int]) -> List[int]:\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def edges() -> List[tuple]:\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    # Validate base\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        # Light random valid-ish init\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return normalize(sol)\n    sol = list(solution)\n    n = len(sol)\n    # Multi-kick: recolor a small subset and perform 1 Kempe swap\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(range(n), m)\n    palette = list(set(sol))\n    for idx in idxs:\n        # 80% existing colors, 20% possibly introduce new\n        if random.random() < 0.8:\n            sol[idx] = random.choice(palette)\n        else:\n            sol[idx] = max(palette) + 1\n            palette = list(set(sol))\n    # One Kempe-chain interchange\n    def kempe(sol_in: List[int]) -> List[int]:\n        sol2 = sol_in[:]\n        a = random.randrange(n)\n        c1 = sol2[a]\n        palette2 = list(set(sol2))\n        if len(palette2) == 1:\n            c2 = c1 + 1\n        else:\n            c2 = random.choice([c for c in palette2 if c != c1])\n        # Build adjacency\n        E = edges()\n        adj = [[] for _ in range(n)]\n        for u,v in E:\n            u-=1; v-=1\n            adj[u].append(v)\n            adj[v].append(u)\n        chain = set([a])\n        stack = [a]\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if sol2[w] in (c1, c2) and w not in chain:\n                    chain.add(w)\n                    stack.append(w)\n        for u in chain:\n            sol2[u] = c2 if sol2[u] == c1 else c1\n        return sol2\n    sol = kempe(sol)\n    return normalize(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001288664}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING contiguous colors starting at 1: solution is a list of 9 positive integers [c1,...,c9] where max color k equals number of distinct labels and labels are exactly {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Objective: minimize violations first, then colors\n    if violations > 0:\n        alpha = 1000  # must dominate k\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Problem constants (1-based edge list)\n_EDGES: List[Tuple[int,int]] = [\n    (1,4),(1,5),(1,8),\n    (2,3),(2,5),(2,9),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (6,7),(6,8),(7,8)\n]\n\n# Precomputed adjacency (0-based)\n_ADJ: List[List[int]] = [[] for _ in range(9)]\nfor u, v in _EDGES:\n    u -= 1; v -= 1\n    _ADJ[u].append(v)\n    _ADJ[v].append(u)\n\n_DEF_COLORS = [1, 2, 3]\n\ndef _is_valid_struct(sol: List[int]) -> bool:\n    return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) and x >= 1 for x in sol)\n\ndef _normalize_labels(sol: List[int]) -> List[int]:\n    # Map first occurrence order to 1..k\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _dsatur_init() -> List[int]:\n    n = 9\n    colors = [0] * n\n    sat = [set() for _ in range(n)]\n    degrees = [len(_ADJ[i]) for i in range(n)]\n    colored = set()\n    while len(colored) < n:\n        # pick vertex with max saturation, break ties by degree\n        cand = [i for i in range(n) if i not in colored]\n        v = max(cand, key=lambda i: (len(sat[i]), degrees[i]))\n        # choose smallest available color\n        used = {colors[u] for u in _ADJ[v] if colors[u] > 0}\n        c = 1\n        while c in used:\n            c += 1\n        colors[v] = c\n        colored.add(v)\n        for u in _ADJ[v]:\n            if colors[v] > 0:\n                sat[u].add(colors[v])\n    return _normalize_labels(colors)\n\ndef _violations(sol: List[int]) -> int:\n    cnt = 0\n    for u, v in _EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            cnt += 1\n    return cnt\n\ndef _class_sizes(sol: List[int]) -> dict:\n    d = {}\n    for x in sol:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef _recolor_delta(sol: List[int], v: int, c_new: int) -> int:\n    # Returns change in total violations when recoloring v to c_new\n    c_old = sol[v]\n    if c_new == c_old:\n        return 0\n    delta = 0\n    for w in _ADJ[v]:\n        if sol[w] == c_old:\n            delta -= 1\n        if sol[w] == c_new:\n            delta += 1\n    return delta\n\ndef _kempe_swap(sol: List[int], seed_v: int, c1: int, c2: int) -> List[int]:\n    n = len(sol)\n    stack = [seed_v]\n    in_chain = set()\n    while stack:\n        u = stack.pop()\n        if u in in_chain:\n            continue\n        if sol[u] not in (c1, c2):\n            continue\n        in_chain.add(u)\n        for w in _ADJ[u]:\n            if sol[w] in (c1, c2) and w not in in_chain:\n                stack.append(w)\n    out = sol[:]\n    for u in in_chain:\n        out[u] = c2 if sol[u] == c1 else c1\n    return out\n\ndef _attempt_color_elimination(sol: List[int]) -> List[int] or None:\n    # Try to remove the smallest color class by greedy recoloring into others without adding conflicts\n    sizes = _class_sizes(sol)\n    if not sizes:\n        return None\n    target_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n    vertices = [i for i, c in enumerate(sol) if c == target_color]\n    palette = sorted(set(sol))\n    others = [c for c in palette if c != target_color]\n    out = sol[:]\n    for v in vertices:\n        # choose best color that does not conflict at v\n        feasible = []\n        for c in others:\n            ok = True\n            for w in _ADJ[v]:\n                if out[w] == c:\n                    ok = False\n                    break\n            if ok:\n                # tie-breaker by class size desc to avoid fragmentation\n                feasible.append(( -_class_sizes(out).get(c,0), c))\n        if not feasible:\n            return None\n        feasible.sort()\n        chosen = feasible[0][1]\n        out[v] = chosen\n    # shift labels > target_color down by 1 to keep contiguous\n    for i in range(len(out)):\n        if out[i] > target_color:\n            out[i] -= 1\n    return _normalize_labels(out)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # If invalid input, start from DSatur\n    if not _is_valid_struct(solution):\n        init_sol = _dsatur_init()\n        return init_sol, \"init-dsatur\"\n    sol = list(solution)\n    palette = sorted(set(sol))\n    # Compute conflicts\n    conflict_edges = []\n    for (u, v) in _EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u - 1, v - 1))\n    if conflict_edges:\n        # Conflict-directed min-conflicts recolor (no new colors)\n        u, v = random.choice(conflict_edges)\n        target = random.choice([u, v])\n        current_vios = _violations(sol)\n        sizes = _class_sizes(sol)\n        best = (10**9, 10**9, -sizes.get(sol[target], 0), sol)\n        best_sol = sol\n        best_color = sol[target]\n        for c in palette:\n            if c == sol[target]:\n                continue\n            delta = _recolor_delta(sol, target, c)\n            new_vios = current_vios + delta\n            # tie-breakers: lower vios, then lower palette size, then larger class size of new color\n            score = (new_vios, len(palette), -sizes.get(c, 0))\n            if score < best:\n                best = score\n                best_color = c\n        out = sol[:]\n        out[target] = best_color\n        return out, \"recolor-minconf\"\n    else:\n        # Feasible: attempt color elimination first\n        eliminated = _attempt_color_elimination(sol)\n        if eliminated is not None:\n            return eliminated, \"class-elim\"\n        # Else perform a targeted Kempe swap between two colors to reshuffle\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            seed = random.randrange(9)\n            c1 = sol[seed]\n            c2 = random.choice([c for c in colors if c != c1])\n            out = _kempe_swap(sol, seed, c1, c2)\n            out = _normalize_labels(out)\n            return out, \"kempe\"\n        # Fallback: unchanged\n        return sol[:], \"noop\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\n_EDGES_P: List[Tuple[int,int]] = [\n    (1,4),(1,5),(1,8),\n    (2,3),(2,5),(2,9),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (6,7),(6,8),(7,8)\n]\n_ADJ_P: List[List[int]] = [[] for _ in range(9)]\nfor u, v in _EDGES_P:\n    u -= 1; v -= 1\n    _ADJ_P[u].append(v)\n    _ADJ_P[v].append(u)\n\ndef _normalize_labels_p(sol: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _kempe_p(sol: List[int], seed_v: int, c1: int, c2: int) -> List[int]:\n    stack = [seed_v]\n    chain = set()\n    while stack:\n        u = stack.pop()\n        if u in chain:\n            continue\n        if sol[u] not in (c1, c2):\n            continue\n        chain.add(u)\n        for w in _ADJ_P[u]:\n            if sol[w] in (c1, c2) and w not in chain:\n                stack.append(w)\n    out = sol[:]\n    for u in chain:\n        out[u] = c2 if sol[u] == c1 else c1\n    return out\n\ndef perturb_solution(solution):\n    # Ensure a base solution; if invalid, start from a light random assignment then normalize\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return _normalize_labels_p(sol)\n    sol = list(solution)\n    n = 9\n    colors = sorted(set(sol))\n    # Kick 1: recolor a subset of vertices to existing colors (no new colors here)\n    m = max(3, min(5, n \/\/ 2))\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.choice(colors)\n    # Kick 2: perform multiple Kempe swaps across random color pairs\n    t = 2 if len(colors) < 3 else 3\n    for _ in range(t):\n        seed = random.randrange(n)\n        c1 = sol[seed]\n        c2 = random.choice([c for c in colors if c != c1]) if len(colors) > 1 else c1 + 1\n        sol = _kempe_p(sol, seed, c1, c2)\n        colors = sorted(set(sol))\n    # Optional palette diversification: introduce a new color with small probability to escape deep traps\n    if random.random() < 0.15:\n        new_c = (max(colors) + 1) if colors else 1\n        for i in random.sample(range(n), 1):\n            sol[i] = new_c\n    return _normalize_labels_p(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001380656}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING contiguous colors starting at 1: solution is a list of 9 positive integers [c1,...,c9] where max color k equals number of distinct labels and labels are exactly {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Objective: minimize violations first, then colors\n    if violations > 0:\n        alpha = 1000  # must dominate k\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Problem constants (1-based edge list)\n_EDGES: List[Tuple[int,int]] = [\n    (1,4),(1,5),(1,8),\n    (2,3),(2,5),(2,9),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (6,7),(6,8),(7,8)\n]\n\n# Precomputed adjacency (0-based)\n_ADJ: List[List[int]] = [[] for _ in range(9)]\nfor u, v in _EDGES:\n    u -= 1; v -= 1\n    _ADJ[u].append(v)\n    _ADJ[v].append(u)\n\n_DEF_COLORS = [1, 2, 3]\n\ndef _is_valid_struct(sol: List[int]) -> bool:\n    return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) and x >= 1 for x in sol)\n\ndef _normalize_labels(sol: List[int]) -> List[int]:\n    # Map first occurrence order to 1..k\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _dsatur_init() -> List[int]:\n    n = 9\n    colors = [0] * n\n    sat = [set() for _ in range(n)]\n    degrees = [len(_ADJ[i]) for i in range(n)]\n    colored = set()\n    while len(colored) < n:\n        # pick vertex with max saturation, break ties by degree\n        cand = [i for i in range(n) if i not in colored]\n        v = max(cand, key=lambda i: (len(sat[i]), degrees[i]))\n        # choose smallest available color\n        used = {colors[u] for u in _ADJ[v] if colors[u] > 0}\n        c = 1\n        while c in used:\n            c += 1\n        colors[v] = c\n        colored.add(v)\n        for u in _ADJ[v]:\n            if colors[v] > 0:\n                sat[u].add(colors[v])\n    return _normalize_labels(colors)\n\ndef _violations(sol: List[int]) -> int:\n    cnt = 0\n    for u, v in _EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            cnt += 1\n    return cnt\n\ndef _class_sizes(sol: List[int]) -> dict:\n    d = {}\n    for x in sol:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef _recolor_delta(sol: List[int], v: int, c_new: int) -> int:\n    # Returns change in total violations when recoloring v to c_new\n    c_old = sol[v]\n    if c_new == c_old:\n        return 0\n    delta = 0\n    for w in _ADJ[v]:\n        if sol[w] == c_old:\n            delta -= 1\n        if sol[w] == c_new:\n            delta += 1\n    return delta\n\ndef _kempe_swap(sol: List[int], seed_v: int, c1: int, c2: int) -> List[int]:\n    n = len(sol)\n    stack = [seed_v]\n    in_chain = set()\n    while stack:\n        u = stack.pop()\n        if u in in_chain:\n            continue\n        if sol[u] not in (c1, c2):\n            continue\n        in_chain.add(u)\n        for w in _ADJ[u]:\n            if sol[w] in (c1, c2) and w not in in_chain:\n                stack.append(w)\n    out = sol[:]\n    for u in in_chain:\n        out[u] = c2 if sol[u] == c1 else c1\n    return out\n\ndef _attempt_color_elimination(sol: List[int]) -> List[int] or None:\n    # Try to remove the smallest color class by greedy recoloring into others without adding conflicts\n    sizes = _class_sizes(sol)\n    if not sizes:\n        return None\n    target_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n    vertices = [i for i, c in enumerate(sol) if c == target_color]\n    palette = sorted(set(sol))\n    others = [c for c in palette if c != target_color]\n    out = sol[:]\n    for v in vertices:\n        # choose best color that does not conflict at v\n        feasible = []\n        for c in others:\n            ok = True\n            for w in _ADJ[v]:\n                if out[w] == c:\n                    ok = False\n                    break\n            if ok:\n                # tie-breaker by class size desc to avoid fragmentation\n                feasible.append(( -_class_sizes(out).get(c,0), c))\n        if not feasible:\n            return None\n        feasible.sort()\n        chosen = feasible[0][1]\n        out[v] = chosen\n    # shift labels > target_color down by 1 to keep contiguous\n    for i in range(len(out)):\n        if out[i] > target_color:\n            out[i] -= 1\n    return _normalize_labels(out)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # If invalid input, start from DSatur\n    if not _is_valid_struct(solution):\n        init_sol = _dsatur_init()\n        return init_sol, \"init-dsatur\"\n    sol = list(solution)\n    palette = sorted(set(sol))\n    # Compute conflicts\n    conflict_edges = []\n    for (u, v) in _EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u - 1, v - 1))\n    if conflict_edges:\n        # Conflict-directed min-conflicts recolor (no new colors)\n        u, v = random.choice(conflict_edges)\n        target = random.choice([u, v])\n        current_vios = _violations(sol)\n        sizes = _class_sizes(sol)\n        best = (10**9, 10**9, -sizes.get(sol[target], 0), sol)\n        best_sol = sol\n        best_color = sol[target]\n        for c in palette:\n            if c == sol[target]:\n                continue\n            delta = _recolor_delta(sol, target, c)\n            new_vios = current_vios + delta\n            # tie-breakers: lower vios, then lower palette size, then larger class size of new color\n            score = (new_vios, len(palette), -sizes.get(c, 0))\n            if score < best:\n                best = score\n                best_color = c\n        out = sol[:]\n        out[target] = best_color\n        return out, \"recolor-minconf\"\n    else:\n        # Feasible: attempt color elimination first\n        eliminated = _attempt_color_elimination(sol)\n        if eliminated is not None:\n            return eliminated, \"class-elim\"\n        # Else perform a targeted Kempe swap between two colors to reshuffle\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            seed = random.randrange(9)\n            c1 = sol[seed]\n            c2 = random.choice([c for c in colors if c != c1])\n            out = _kempe_swap(sol, seed, c1, c2)\n            out = _normalize_labels(out)\n            return out, \"kempe\"\n        # Fallback: unchanged\n        return sol[:], \"noop\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\n_EDGES_P: List[Tuple[int,int]] = [\n    (1,4),(1,5),(1,8),\n    (2,3),(2,5),(2,9),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (6,7),(6,8),(7,8)\n]\n_ADJ_P: List[List[int]] = [[] for _ in range(9)]\nfor u, v in _EDGES_P:\n    u -= 1; v -= 1\n    _ADJ_P[u].append(v)\n    _ADJ_P[v].append(u)\n\ndef _normalize_labels_p(sol: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _kempe_p(sol: List[int], seed_v: int, c1: int, c2: int) -> List[int]:\n    stack = [seed_v]\n    chain = set()\n    while stack:\n        u = stack.pop()\n        if u in chain:\n            continue\n        if sol[u] not in (c1, c2):\n            continue\n        chain.add(u)\n        for w in _ADJ_P[u]:\n            if sol[w] in (c1, c2) and w not in chain:\n                stack.append(w)\n    out = sol[:]\n    for u in chain:\n        out[u] = c2 if sol[u] == c1 else c1\n    return out\n\ndef perturb_solution(solution):\n    # Ensure a base solution; if invalid, start from a light random assignment then normalize\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return _normalize_labels_p(sol)\n    sol = list(solution)\n    n = 9\n    colors = sorted(set(sol))\n    # Kick 1: recolor a subset of vertices to existing colors (no new colors here)\n    m = max(3, min(5, n \/\/ 2))\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.choice(colors)\n    # Kick 2: perform multiple Kempe swaps across random color pairs\n    t = 2 if len(colors) < 3 else 3\n    for _ in range(t):\n        seed = random.randrange(n)\n        c1 = sol[seed]\n        c2 = random.choice([c for c in colors if c != c1]) if len(colors) > 1 else c1 + 1\n        sol = _kempe_p(sol, seed, c1, c2)\n        colors = sorted(set(sol))\n    # Optional palette diversification: introduce a new color with small probability to escape deep traps\n    if random.random() < 0.15:\n        new_c = (max(colors) + 1) if colors else 1\n        for i in random.sample(range(n), 1):\n            sol[i] = new_c\n    return _normalize_labels_p(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001625168}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING contiguous colors starting at 1: solution is a list of 9 positive integers [c1,...,c9] where max color k equals number of distinct labels and labels are exactly {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Objective: minimize violations first, then colors\n    if violations > 0:\n        alpha = 1000  # must dominate k\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Problem constants (1-based edge list)\n_EDGES: List[Tuple[int,int]] = [\n    (1,4),(1,5),(1,8),\n    (2,3),(2,5),(2,9),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (6,7),(6,8),(7,8)\n]\n\n# Precomputed adjacency (0-based)\n_ADJ: List[List[int]] = [[] for _ in range(9)]\nfor u, v in _EDGES:\n    u -= 1; v -= 1\n    _ADJ[u].append(v)\n    _ADJ[v].append(u)\n\n_DEF_COLORS = [1, 2, 3]\n\ndef _is_valid_struct(sol: List[int]) -> bool:\n    return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) and x >= 1 for x in sol)\n\ndef _normalize_labels(sol: List[int]) -> List[int]:\n    # Map first occurrence order to 1..k\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _dsatur_init() -> List[int]:\n    n = 9\n    colors = [0] * n\n    sat = [set() for _ in range(n)]\n    degrees = [len(_ADJ[i]) for i in range(n)]\n    colored = set()\n    while len(colored) < n:\n        # pick vertex with max saturation, break ties by degree\n        cand = [i for i in range(n) if i not in colored]\n        v = max(cand, key=lambda i: (len(sat[i]), degrees[i]))\n        # choose smallest available color\n        used = {colors[u] for u in _ADJ[v] if colors[u] > 0}\n        c = 1\n        while c in used:\n            c += 1\n        colors[v] = c\n        colored.add(v)\n        for u in _ADJ[v]:\n            if colors[v] > 0:\n                sat[u].add(colors[v])\n    return _normalize_labels(colors)\n\ndef _violations(sol: List[int]) -> int:\n    cnt = 0\n    for u, v in _EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            cnt += 1\n    return cnt\n\ndef _class_sizes(sol: List[int]) -> dict:\n    d = {}\n    for x in sol:\n        d[x] = d.get(x, 0) + 1\n    return d\n\ndef _recolor_delta(sol: List[int], v: int, c_new: int) -> int:\n    # Returns change in total violations when recoloring v to c_new\n    c_old = sol[v]\n    if c_new == c_old:\n        return 0\n    delta = 0\n    for w in _ADJ[v]:\n        if sol[w] == c_old:\n            delta -= 1\n        if sol[w] == c_new:\n            delta += 1\n    return delta\n\ndef _kempe_swap(sol: List[int], seed_v: int, c1: int, c2: int) -> List[int]:\n    n = len(sol)\n    stack = [seed_v]\n    in_chain = set()\n    while stack:\n        u = stack.pop()\n        if u in in_chain:\n            continue\n        if sol[u] not in (c1, c2):\n            continue\n        in_chain.add(u)\n        for w in _ADJ[u]:\n            if sol[w] in (c1, c2) and w not in in_chain:\n                stack.append(w)\n    out = sol[:]\n    for u in in_chain:\n        out[u] = c2 if sol[u] == c1 else c1\n    return out\n\ndef _attempt_color_elimination(sol: List[int]) -> List[int] or None:\n    # Try to remove the smallest color class by greedy recoloring into others without adding conflicts\n    sizes = _class_sizes(sol)\n    if not sizes:\n        return None\n    target_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n    vertices = [i for i, c in enumerate(sol) if c == target_color]\n    palette = sorted(set(sol))\n    others = [c for c in palette if c != target_color]\n    out = sol[:]\n    for v in vertices:\n        # choose best color that does not conflict at v\n        feasible = []\n        for c in others:\n            ok = True\n            for w in _ADJ[v]:\n                if out[w] == c:\n                    ok = False\n                    break\n            if ok:\n                # tie-breaker by class size desc to avoid fragmentation\n                feasible.append(( -_class_sizes(out).get(c,0), c))\n        if not feasible:\n            return None\n        feasible.sort()\n        chosen = feasible[0][1]\n        out[v] = chosen\n    # shift labels > target_color down by 1 to keep contiguous\n    for i in range(len(out)):\n        if out[i] > target_color:\n            out[i] -= 1\n    return _normalize_labels(out)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # If invalid input, start from DSatur\n    if not _is_valid_struct(solution):\n        init_sol = _dsatur_init()\n        return init_sol, \"init-dsatur\"\n    sol = list(solution)\n    palette = sorted(set(sol))\n    # Compute conflicts\n    conflict_edges = []\n    for (u, v) in _EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u - 1, v - 1))\n    if conflict_edges:\n        # Conflict-directed min-conflicts recolor (no new colors)\n        u, v = random.choice(conflict_edges)\n        target = random.choice([u, v])\n        current_vios = _violations(sol)\n        sizes = _class_sizes(sol)\n        best = (10**9, 10**9, -sizes.get(sol[target], 0), sol)\n        best_sol = sol\n        best_color = sol[target]\n        for c in palette:\n            if c == sol[target]:\n                continue\n            delta = _recolor_delta(sol, target, c)\n            new_vios = current_vios + delta\n            # tie-breakers: lower vios, then lower palette size, then larger class size of new color\n            score = (new_vios, len(palette), -sizes.get(c, 0))\n            if score < best:\n                best = score\n                best_color = c\n        out = sol[:]\n        out[target] = best_color\n        return out, \"recolor-minconf\"\n    else:\n        # Feasible: attempt color elimination first\n        eliminated = _attempt_color_elimination(sol)\n        if eliminated is not None:\n            return eliminated, \"class-elim\"\n        # Else perform a targeted Kempe swap between two colors to reshuffle\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            seed = random.randrange(9)\n            c1 = sol[seed]\n            c2 = random.choice([c for c in colors if c != c1])\n            out = _kempe_swap(sol, seed, c1, c2)\n            out = _normalize_labels(out)\n            return out, \"kempe\"\n        # Fallback: unchanged\n        return sol[:], \"noop\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\n_EDGES_P: List[Tuple[int,int]] = [\n    (1,4),(1,5),(1,8),\n    (2,3),(2,5),(2,9),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (6,7),(6,8),(7,8)\n]\n_ADJ_P: List[List[int]] = [[] for _ in range(9)]\nfor u, v in _EDGES_P:\n    u -= 1; v -= 1\n    _ADJ_P[u].append(v)\n    _ADJ_P[v].append(u)\n\ndef _normalize_labels_p(sol: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _kempe_p(sol: List[int], seed_v: int, c1: int, c2: int) -> List[int]:\n    stack = [seed_v]\n    chain = set()\n    while stack:\n        u = stack.pop()\n        if u in chain:\n            continue\n        if sol[u] not in (c1, c2):\n            continue\n        chain.add(u)\n        for w in _ADJ_P[u]:\n            if sol[w] in (c1, c2) and w not in chain:\n                stack.append(w)\n    out = sol[:]\n    for u in chain:\n        out[u] = c2 if sol[u] == c1 else c1\n    return out\n\ndef perturb_solution(solution):\n    # Ensure a base solution; if invalid, start from a light random assignment then normalize\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return _normalize_labels_p(sol)\n    sol = list(solution)\n    n = 9\n    colors = sorted(set(sol))\n    # Kick 1: recolor a subset of vertices to existing colors (no new colors here)\n    m = max(3, min(5, n \/\/ 2))\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.choice(colors)\n    # Kick 2: perform multiple Kempe swaps across random color pairs\n    t = 2 if len(colors) < 3 else 3\n    for _ in range(t):\n        seed = random.randrange(n)\n        c1 = sol[seed]\n        c2 = random.choice([c for c in colors if c != c1]) if len(colors) > 1 else c1 + 1\n        sol = _kempe_p(sol, seed, c1, c2)\n        colors = sorted(set(sol))\n    # Optional palette diversification: introduce a new color with small probability to escape deep traps\n    if random.random() < 0.15:\n        new_c = (max(colors) + 1) if colors else 1\n        for i in random.sample(range(n), 1):\n            sol[i] = new_c\n    return _normalize_labels_p(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001542957}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING contiguous colors starting at 1: solution is a list of 9 positive integers [c1,...,c9] where max color k equals number of distinct labels and labels are exactly {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Objective: minimize violations first, then colors\n    if violations > 0:\n        alpha = 1000  # must dominate k\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # All problem data and helpers enclosed to avoid globals\n    def _edges():\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def _adj():\n        adj = [[] for _ in range(9)]\n        for u, v in _edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _is_valid_struct(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) and x >= 1 for x in sol)\n    def _normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def _violations(sol: List[int]) -> int:\n        cnt = 0\n        for u, v in _edges():\n            if sol[u - 1] == sol[v - 1]:\n                cnt += 1\n        return cnt\n    def _class_sizes(sol: List[int]):\n        d = {}\n        for x in sol:\n            d[x] = d.get(x, 0) + 1\n        return d\n    def _recolor_delta(sol: List[int], v: int, c_new: int, adj):\n        c_old = sol[v]\n        if c_new == c_old:\n            return 0\n        delta = 0\n        for w in adj[v]:\n            if sol[w] == c_old:\n                delta -= 1\n            if sol[w] == c_new:\n                delta += 1\n        return delta\n    def _kempe_swap(sol: List[int], seed_v: int, c1: int, c2: int, adj):\n        stack = [seed_v]\n        in_chain = set()\n        while stack:\n            u = stack.pop()\n            if u in in_chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            in_chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in in_chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in in_chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n    def _attempt_color_elimination(sol: List[int], adj):\n        sizes = _class_sizes(sol)\n        if not sizes:\n            return None\n        # pick smallest color class (then smallest color id)\n        target_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        vertices = [i for i, c in enumerate(sol) if c == target_color]\n        palette = sorted(set(sol))\n        others = [c for c in palette if c != target_color]\n        out = sol[:]\n        sizes_work = dict(sizes)\n        for v in vertices:\n            feasible = []\n            for c in others:\n                ok = True\n                for w in adj[v]:\n                    if out[w] == c:\n                        ok = False\n                        break\n                if ok:\n                    # prefer larger classes to reduce fragmentation\n                    feasible.append((-sizes_work.get(c, 0), c))\n            if not feasible:\n                return None\n            feasible.sort()\n            chosen = feasible[0][1]\n            out[v] = chosen\n            sizes_work[chosen] = sizes_work.get(chosen, 0) + 1\n            sizes_work[target_color] -= 1\n        # Relabel to keep contiguity\n        out = _normalize_labels(out)\n        return out\n    def _dsatur_init(adj):\n        n = 9\n        colors = [0] * n\n        sat = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        colored = set()\n        while len(colored) < n:\n            cand = [i for i in range(n) if i not in colored]\n            v = max(cand, key=lambda i: (len(sat[i]), degrees[i]))\n            used = {colors[u] for u in adj[v] if colors[u] > 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            colored.add(v)\n            for u in adj[v]:\n                if colors[v] > 0:\n                    sat[u].add(colors[v])\n        return _normalize_labels(colors)\n\n    adj = _adj()\n    if not _is_valid_struct(solution):\n        init_sol = _dsatur_init(adj)\n        return init_sol, \"init-dsatur\"\n\n    sol = list(solution)\n    palette = sorted(set(sol))\n\n    # Build conflict edge list\n    conflict_edges = []\n    for (u, v) in _edges():\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u - 1, v - 1))\n\n    if conflict_edges:\n        # Conflict-directed move: recolor a conflicting vertex.\n        u, v = random.choice(conflict_edges)\n        target = random.choice([u, v])\n        current_vios = _violations(sol)\n        sizes = _class_sizes(sol)\n        best_tuple = (10**9, 10**9, 10**9)\n        best_color = sol[target]\n        grew_palette = False\n        # Try existing colors first\n        for c in palette:\n            if c == sol[target]:\n                continue\n            delta = _recolor_delta(sol, target, c, adj)\n            new_vios = current_vios + delta\n            score = (new_vios, len(palette), -sizes.get(c, 0))\n            if score < best_tuple:\n                best_tuple = score\n                best_color = c\n                grew_palette = False\n        # Optionally consider introducing a temporary new color if it strictly reduces violations\n        new_cand = max(palette) + 1\n        delta_new = _recolor_delta(sol, target, new_cand, adj)\n        new_vios_newc = current_vios + delta_new\n        if new_vios_newc < best_tuple[0]:  # must strictly reduce violations\n            best_tuple = (new_vios_newc, len(palette) + 1, 0)\n            best_color = new_cand\n            grew_palette = True\n        out = sol[:]\n        out[target] = best_color\n        # If palette grew, immediately attempt color elimination to restore contiguity and reduce k\n        if grew_palette:\n            elim = _attempt_color_elimination(out, adj)\n            if elim is not None:\n                out = elim\n            else:\n                out = _normalize_labels(out)\n        else:\n            out = _normalize_labels(out)\n        return out, \"recolor-minconf\"\n    else:\n        # Feasible: prioritize color elimination\n        eliminated = _attempt_color_elimination(sol, adj)\n        if eliminated is not None:\n            return eliminated, \"class-elim\"\n        # Kempe swap between two colors, seeded at vertex touching smallest class if possible\n        sizes = _class_sizes(sol)\n        smallest_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        cand_vertices = [i for i, c in enumerate(sol) if c == smallest_color]\n        seed = random.choice(cand_vertices) if cand_vertices else random.randrange(9)\n        c1 = sol[seed]\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            c2 = random.choice([c for c in colors if c != c1])\n            out = _kempe_swap(sol, seed, c1, c2, adj)\n            out = _normalize_labels(out)\n            return out, \"kempe\"\n        return sol[:], \"noop\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Enclose problem data\n    def _edges():\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def _adj():\n        adj = [[] for _ in range(9)]\n        for u, v in _edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def _kempe(sol: List[int], seed_v: int, c1: int, c2: int, adj):\n        stack = [seed_v]\n        chain = set()\n        while stack:\n            u = stack.pop()\n            if u in chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n\n    adj = _adj()\n    # Ensure a base solution; if invalid, create a light random assignment then normalize\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return _normalize_labels(sol)\n\n    sol = list(solution)\n    n = 9\n    colors = sorted(set(sol))\n\n    # Kick 1: random recolor of a subset (biased to conflicting\/prone vertices via degree)\n    m = max(3, min(5, n \/\/ 2))\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.choice(colors)\n\n    # Kick 2: multiple Kempe swaps across random color pairs\n    t = 3 if len(colors) >= 3 else 2\n    for _ in range(t):\n        seed = random.randrange(n)\n        c1 = sol[seed]\n        # ensure distinct colors; if only one color present, synthesize a temporary second\n        c2_pool = [c for c in colors if c != c1]\n        c2 = random.choice(c2_pool) if c2_pool else c1 + 1\n        sol = _kempe(sol, seed, c1, c2, adj)\n        colors = sorted(set(sol))\n\n    # Optional palette diversification: with small probability introduce a new color on one vertex\n    if random.random() < 0.15:\n        new_c = (max(colors) + 1) if colors else 1\n        pos = random.randrange(n)\n        sol[pos] = new_c\n\n    return _normalize_labels(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001509906}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING contiguous colors starting at 1: solution is a list of 9 positive integers [c1,...,c9] where max color k equals number of distinct labels and labels are exactly {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Objective: minimize violations first, then colors\n    if violations > 0:\n        alpha = 1000  # must dominate k\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # All problem data and helpers enclosed to avoid globals\n    def _edges():\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def _adj():\n        adj = [[] for _ in range(9)]\n        for u, v in _edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _is_valid_struct(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) and x >= 1 for x in sol)\n    def _normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def _violations(sol: List[int]) -> int:\n        cnt = 0\n        for u, v in _edges():\n            if sol[u - 1] == sol[v - 1]:\n                cnt += 1\n        return cnt\n    def _class_sizes(sol: List[int]):\n        d = {}\n        for x in sol:\n            d[x] = d.get(x, 0) + 1\n        return d\n    def _recolor_delta(sol: List[int], v: int, c_new: int, adj):\n        c_old = sol[v]\n        if c_new == c_old:\n            return 0\n        delta = 0\n        for w in adj[v]:\n            if sol[w] == c_old:\n                delta -= 1\n            if sol[w] == c_new:\n                delta += 1\n        return delta\n    def _kempe_swap(sol: List[int], seed_v: int, c1: int, c2: int, adj):\n        stack = [seed_v]\n        in_chain = set()\n        while stack:\n            u = stack.pop()\n            if u in in_chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            in_chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in in_chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in in_chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n    def _attempt_color_elimination(sol: List[int], adj):\n        sizes = _class_sizes(sol)\n        if not sizes:\n            return None\n        # pick smallest color class (then smallest color id)\n        target_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        vertices = [i for i, c in enumerate(sol) if c == target_color]\n        palette = sorted(set(sol))\n        others = [c for c in palette if c != target_color]\n        out = sol[:]\n        sizes_work = dict(sizes)\n        for v in vertices:\n            feasible = []\n            for c in others:\n                ok = True\n                for w in adj[v]:\n                    if out[w] == c:\n                        ok = False\n                        break\n                if ok:\n                    # prefer larger classes to reduce fragmentation\n                    feasible.append((-sizes_work.get(c, 0), c))\n            if not feasible:\n                return None\n            feasible.sort()\n            chosen = feasible[0][1]\n            out[v] = chosen\n            sizes_work[chosen] = sizes_work.get(chosen, 0) + 1\n            sizes_work[target_color] -= 1\n        # Relabel to keep contiguity\n        out = _normalize_labels(out)\n        return out\n    def _dsatur_init(adj):\n        n = 9\n        colors = [0] * n\n        sat = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        colored = set()\n        while len(colored) < n:\n            cand = [i for i in range(n) if i not in colored]\n            v = max(cand, key=lambda i: (len(sat[i]), degrees[i]))\n            used = {colors[u] for u in adj[v] if colors[u] > 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            colored.add(v)\n            for u in adj[v]:\n                if colors[v] > 0:\n                    sat[u].add(colors[v])\n        return _normalize_labels(colors)\n\n    adj = _adj()\n    if not _is_valid_struct(solution):\n        init_sol = _dsatur_init(adj)\n        return init_sol, \"init-dsatur\"\n\n    sol = list(solution)\n    palette = sorted(set(sol))\n\n    # Build conflict edge list\n    conflict_edges = []\n    for (u, v) in _edges():\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u - 1, v - 1))\n\n    if conflict_edges:\n        # Conflict-directed move: recolor a conflicting vertex.\n        u, v = random.choice(conflict_edges)\n        target = random.choice([u, v])\n        current_vios = _violations(sol)\n        sizes = _class_sizes(sol)\n        best_tuple = (10**9, 10**9, 10**9)\n        best_color = sol[target]\n        grew_palette = False\n        # Try existing colors first\n        for c in palette:\n            if c == sol[target]:\n                continue\n            delta = _recolor_delta(sol, target, c, adj)\n            new_vios = current_vios + delta\n            score = (new_vios, len(palette), -sizes.get(c, 0))\n            if score < best_tuple:\n                best_tuple = score\n                best_color = c\n                grew_palette = False\n        # Optionally consider introducing a temporary new color if it strictly reduces violations\n        new_cand = max(palette) + 1\n        delta_new = _recolor_delta(sol, target, new_cand, adj)\n        new_vios_newc = current_vios + delta_new\n        if new_vios_newc < best_tuple[0]:  # must strictly reduce violations\n            best_tuple = (new_vios_newc, len(palette) + 1, 0)\n            best_color = new_cand\n            grew_palette = True\n        out = sol[:]\n        out[target] = best_color\n        # If palette grew, immediately attempt color elimination to restore contiguity and reduce k\n        if grew_palette:\n            elim = _attempt_color_elimination(out, adj)\n            if elim is not None:\n                out = elim\n            else:\n                out = _normalize_labels(out)\n        else:\n            out = _normalize_labels(out)\n        return out, \"recolor-minconf\"\n    else:\n        # Feasible: prioritize color elimination\n        eliminated = _attempt_color_elimination(sol, adj)\n        if eliminated is not None:\n            return eliminated, \"class-elim\"\n        # Kempe swap between two colors, seeded at vertex touching smallest class if possible\n        sizes = _class_sizes(sol)\n        smallest_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        cand_vertices = [i for i, c in enumerate(sol) if c == smallest_color]\n        seed = random.choice(cand_vertices) if cand_vertices else random.randrange(9)\n        c1 = sol[seed]\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            c2 = random.choice([c for c in colors if c != c1])\n            out = _kempe_swap(sol, seed, c1, c2, adj)\n            out = _normalize_labels(out)\n            return out, \"kempe\"\n        return sol[:], \"noop\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Enclose problem data\n    def _edges():\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def _adj():\n        adj = [[] for _ in range(9)]\n        for u, v in _edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def _kempe(sol: List[int], seed_v: int, c1: int, c2: int, adj):\n        stack = [seed_v]\n        chain = set()\n        while stack:\n            u = stack.pop()\n            if u in chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n\n    adj = _adj()\n    # Ensure a base solution; if invalid, create a light random assignment then normalize\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return _normalize_labels(sol)\n\n    sol = list(solution)\n    n = 9\n    colors = sorted(set(sol))\n\n    # Kick 1: random recolor of a subset (biased to conflicting\/prone vertices via degree)\n    m = max(3, min(5, n \/\/ 2))\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.choice(colors)\n\n    # Kick 2: multiple Kempe swaps across random color pairs\n    t = 3 if len(colors) >= 3 else 2\n    for _ in range(t):\n        seed = random.randrange(n)\n        c1 = sol[seed]\n        # ensure distinct colors; if only one color present, synthesize a temporary second\n        c2_pool = [c for c in colors if c != c1]\n        c2 = random.choice(c2_pool) if c2_pool else c1 + 1\n        sol = _kempe(sol, seed, c1, c2, adj)\n        colors = sorted(set(sol))\n\n    # Optional palette diversification: with small probability introduce a new color on one vertex\n    if random.random() < 0.15:\n        new_c = (max(colors) + 1) if colors else 1\n        pos = random.randrange(n)\n        sol[pos] = new_c\n\n    return _normalize_labels(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.0017407}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORING contiguous colors starting at 1: solution is a list of 9 positive integers [c1,...,c9] where max color k equals number of distinct labels and labels are exactly {1,...,k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**6 + 1_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**6 + 2_000\n    k = max(solution)\n    # Fast bounds check\n    if not all(1 <= x <= k for x in solution):\n        return 10**6 + 3_000\n    # Contiguity check\n    if set(solution) != set(range(1, k + 1)):\n        return 10**6 + 4_000\n    # Graph definition (1-based)\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),(7,8)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Objective: minimize violations first, then colors\n    if violations > 0:\n        alpha = 1000  # must dominate k\n        return alpha * violations + k\n    return k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # All problem data and helpers enclosed to avoid globals\n    def _edges():\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def _adj():\n        adj = [[] for _ in range(9)]\n        for u, v in _edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _is_valid_struct(sol: List[int]) -> bool:\n        return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) and x >= 1 for x in sol)\n    def _normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def _violations(sol: List[int]) -> int:\n        cnt = 0\n        for u, v in _edges():\n            if sol[u - 1] == sol[v - 1]:\n                cnt += 1\n        return cnt\n    def _class_sizes(sol: List[int]):\n        d = {}\n        for x in sol:\n            d[x] = d.get(x, 0) + 1\n        return d\n    def _recolor_delta(sol: List[int], v: int, c_new: int, adj):\n        c_old = sol[v]\n        if c_new == c_old:\n            return 0\n        delta = 0\n        for w in adj[v]:\n            if sol[w] == c_old:\n                delta -= 1\n            if sol[w] == c_new:\n                delta += 1\n        return delta\n    def _kempe_swap(sol: List[int], seed_v: int, c1: int, c2: int, adj):\n        stack = [seed_v]\n        in_chain = set()\n        while stack:\n            u = stack.pop()\n            if u in in_chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            in_chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in in_chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in in_chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n    def _attempt_color_elimination(sol: List[int], adj):\n        sizes = _class_sizes(sol)\n        if not sizes:\n            return None\n        # pick smallest color class (then smallest color id)\n        target_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        vertices = [i for i, c in enumerate(sol) if c == target_color]\n        palette = sorted(set(sol))\n        others = [c for c in palette if c != target_color]\n        out = sol[:]\n        sizes_work = dict(sizes)\n        for v in vertices:\n            feasible = []\n            for c in others:\n                ok = True\n                for w in adj[v]:\n                    if out[w] == c:\n                        ok = False\n                        break\n                if ok:\n                    # prefer larger classes to reduce fragmentation\n                    feasible.append((-sizes_work.get(c, 0), c))\n            if not feasible:\n                return None\n            feasible.sort()\n            chosen = feasible[0][1]\n            out[v] = chosen\n            sizes_work[chosen] = sizes_work.get(chosen, 0) + 1\n            sizes_work[target_color] -= 1\n        # Relabel to keep contiguity\n        out = _normalize_labels(out)\n        return out\n    def _dsatur_init(adj):\n        n = 9\n        colors = [0] * n\n        sat = [set() for _ in range(n)]\n        degrees = [len(adj[i]) for i in range(n)]\n        colored = set()\n        while len(colored) < n:\n            cand = [i for i in range(n) if i not in colored]\n            v = max(cand, key=lambda i: (len(sat[i]), degrees[i]))\n            used = {colors[u] for u in adj[v] if colors[u] > 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            colored.add(v)\n            for u in adj[v]:\n                if colors[v] > 0:\n                    sat[u].add(colors[v])\n        return _normalize_labels(colors)\n\n    adj = _adj()\n    if not _is_valid_struct(solution):\n        init_sol = _dsatur_init(adj)\n        return init_sol, \"init-dsatur\"\n\n    sol = list(solution)\n    palette = sorted(set(sol))\n\n    # Build conflict edge list\n    conflict_edges = []\n    for (u, v) in _edges():\n        if sol[u - 1] == sol[v - 1]:\n            conflict_edges.append((u - 1, v - 1))\n\n    if conflict_edges:\n        # Conflict-directed move: recolor a conflicting vertex.\n        u, v = random.choice(conflict_edges)\n        target = random.choice([u, v])\n        current_vios = _violations(sol)\n        sizes = _class_sizes(sol)\n        best_tuple = (10**9, 10**9, 10**9)\n        best_color = sol[target]\n        grew_palette = False\n        # Try existing colors first\n        for c in palette:\n            if c == sol[target]:\n                continue\n            delta = _recolor_delta(sol, target, c, adj)\n            new_vios = current_vios + delta\n            score = (new_vios, len(palette), -sizes.get(c, 0))\n            if score < best_tuple:\n                best_tuple = score\n                best_color = c\n                grew_palette = False\n        # Optionally consider introducing a temporary new color if it strictly reduces violations\n        new_cand = max(palette) + 1\n        delta_new = _recolor_delta(sol, target, new_cand, adj)\n        new_vios_newc = current_vios + delta_new\n        if new_vios_newc < best_tuple[0]:  # must strictly reduce violations\n            best_tuple = (new_vios_newc, len(palette) + 1, 0)\n            best_color = new_cand\n            grew_palette = True\n        out = sol[:]\n        out[target] = best_color\n        # If palette grew, immediately attempt color elimination to restore contiguity and reduce k\n        if grew_palette:\n            elim = _attempt_color_elimination(out, adj)\n            if elim is not None:\n                out = elim\n            else:\n                out = _normalize_labels(out)\n        else:\n            out = _normalize_labels(out)\n        return out, \"recolor-minconf\"\n    else:\n        # Feasible: prioritize color elimination\n        eliminated = _attempt_color_elimination(sol, adj)\n        if eliminated is not None:\n            return eliminated, \"class-elim\"\n        # Kempe swap between two colors, seeded at vertex touching smallest class if possible\n        sizes = _class_sizes(sol)\n        smallest_color = min(sizes.items(), key=lambda kv: (kv[1], kv[0]))[0]\n        cand_vertices = [i for i, c in enumerate(sol) if c == smallest_color]\n        seed = random.choice(cand_vertices) if cand_vertices else random.randrange(9)\n        c1 = sol[seed]\n        colors = sorted(set(sol))\n        if len(colors) >= 2:\n            c2 = random.choice([c for c in colors if c != c1])\n            out = _kempe_swap(sol, seed, c1, c2, adj)\n            out = _normalize_labels(out)\n            return out, \"kempe\"\n        return sol[:], \"noop\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Enclose problem data\n    def _edges():\n        return [\n            (1,4),(1,5),(1,8),\n            (2,3),(2,5),(2,9),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (6,7),(6,8),(7,8)\n        ]\n    def _adj():\n        adj = [[] for _ in range(9)]\n        for u, v in _edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n    def _normalize_labels(sol: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def _kempe(sol: List[int], seed_v: int, c1: int, c2: int, adj):\n        stack = [seed_v]\n        chain = set()\n        while stack:\n            u = stack.pop()\n            if u in chain:\n                continue\n            if sol[u] not in (c1, c2):\n                continue\n            chain.add(u)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in chain:\n                    stack.append(w)\n        out = sol[:]\n        for u in chain:\n            out[u] = c2 if sol[u] == c1 else c1\n        return out\n\n    adj = _adj()\n    # Ensure a base solution; if invalid, create a light random assignment then normalize\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n        return _normalize_labels(sol)\n\n    sol = list(solution)\n    n = 9\n    colors = sorted(set(sol))\n\n    # Kick 1: random recolor of a subset (biased to conflicting\/prone vertices via degree)\n    m = max(3, min(5, n \/\/ 2))\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.choice(colors)\n\n    # Kick 2: multiple Kempe swaps across random color pairs\n    t = 3 if len(colors) >= 3 else 2\n    for _ in range(t):\n        seed = random.randrange(n)\n        c1 = sol[seed]\n        # ensure distinct colors; if only one color present, synthesize a temporary second\n        c2_pool = [c for c in colors if c != c1]\n        c2 = random.choice(c2_pool) if c2_pool else c1 + 1\n        sol = _kempe(sol, seed, c1, c2, adj)\n        colors = sorted(set(sol))\n\n    # Optional palette diversification: with small probability introduce a new color on one vertex\n    if random.random() < 0.15:\n        new_c = (max(colors) + 1) if colors else 1\n        pos = random.randrange(n)\n        sol[pos] = new_c\n\n    return _normalize_labels(sol)\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001787719}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color of vertex i. Colors are canonicalized by order of first appearance during evaluation; objective is to minimize the number of distinct colors after canonicalization. Feasibility requires adjacent vertices in E to have different colors.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns number of colors if feasible; otherwise large penalty + violations.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Type\/length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Labels must be positive integers\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Conflict count\n    violations = 0\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            violations += 1\n    if violations > 0:\n        return 10**6 + violations\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nimport math\n\n\ndef _canonicalize(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    if not isinstance(solution, (list, tuple)):\n        return (list(solution), \"InvalidInput\") if isinstance(solution, (list, tuple)) else ([1]*9, \"InvalidInput\")\n    sol = list(solution)\n    n = len(sol)\n    if n != 9:\n        # Force into expected size if corrupted\n        sol = (sol + [1]*9)[:9]\n    # Recolor one random vertex to either an existing color or a new color (at most n colors)\n    idx = random.randrange(9)\n    current_colors = sorted(set(sol))\n    # Candidate colors: existing colors +\/- possibly one new color\n    candidates = set(current_colors)\n    if len(current_colors) < 9:\n        candidates.add(max(current_colors) + 1 if current_colors else 1)\n    # Ensure change occurs\n    candidates.discard(sol[idx])\n    if not candidates:\n        candidates = {((sol[idx] % 9) + 1)}\n    new_color = random.choice(list(candidates))\n    neighbor = sol[:]\n    neighbor[idx] = new_color\n    neighbor = _canonicalize(neighbor)\n    return (neighbor, \"SingleVertexRecolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + optional relabel shuffle.\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(9)]\n    else:\n        base = list(solution)\n        if len(base) != 9:\n            base = (base + [1]*9)[:9]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        i = random.randrange(9)\n        current_colors = sorted(set(base))\n        cand = set(current_colors)\n        if len(current_colors) < 9:\n            cand.add(max(current_colors) + 1 if current_colors else 1)\n        # avoid no-op\n        if base[i] in cand and len(cand) > 1:\n            cand.remove(base[i])\n        base[i] = random.choice(list(cand))\n    # Optional relabel permutation to change landscape while preserving feasibility structure\n    # Build canonical mapping then randomly permute labels 1..k\n    def canon(sol):\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    base = canon(base)\n    k = len(set(base))\n    if k > 1 and random.random() < 0.5:\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n    return base\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000489555}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color of vertex i. Colors are canonicalized by order of first appearance during evaluation; objective is to minimize the number of distinct colors after canonicalization. Feasibility requires adjacent vertices in E to have different colors.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns number of colors if feasible; otherwise large penalty + violations.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Type\/length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Labels must be positive integers\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Conflict count\n    violations = 0\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            violations += 1\n    if violations > 0:\n        return 10**6 + violations\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nimport math\n\n\ndef _canonicalize(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    if not isinstance(solution, (list, tuple)):\n        return (list(solution), \"InvalidInput\") if isinstance(solution, (list, tuple)) else ([1]*9, \"InvalidInput\")\n    sol = list(solution)\n    n = len(sol)\n    if n != 9:\n        # Force into expected size if corrupted\n        sol = (sol + [1]*9)[:9]\n    # Recolor one random vertex to either an existing color or a new color (at most n colors)\n    idx = random.randrange(9)\n    current_colors = sorted(set(sol))\n    # Candidate colors: existing colors +\/- possibly one new color\n    candidates = set(current_colors)\n    if len(current_colors) < 9:\n        candidates.add(max(current_colors) + 1 if current_colors else 1)\n    # Ensure change occurs\n    candidates.discard(sol[idx])\n    if not candidates:\n        candidates = {((sol[idx] % 9) + 1)}\n    new_color = random.choice(list(candidates))\n    neighbor = sol[:]\n    neighbor[idx] = new_color\n    neighbor = _canonicalize(neighbor)\n    return (neighbor, \"SingleVertexRecolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + optional relabel shuffle.\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(9)]\n    else:\n        base = list(solution)\n        if len(base) != 9:\n            base = (base + [1]*9)[:9]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        i = random.randrange(9)\n        current_colors = sorted(set(base))\n        cand = set(current_colors)\n        if len(current_colors) < 9:\n            cand.add(max(current_colors) + 1 if current_colors else 1)\n        # avoid no-op\n        if base[i] in cand and len(cand) > 1:\n            cand.remove(base[i])\n        base[i] = random.choice(list(cand))\n    # Optional relabel permutation to change landscape while preserving feasibility structure\n    # Build canonical mapping then randomly permute labels 1..k\n    def canon(sol):\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    base = canon(base)\n    k = len(set(base))\n    if k > 1 and random.random() < 0.5:\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n    return base\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000668998}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color of vertex i. Colors are canonicalized by order of first appearance during evaluation; objective is to minimize the number of distinct colors after canonicalization. Feasibility requires adjacent vertices in E to have different colors.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Returns number of colors if feasible; otherwise large penalty + violations.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Type\/length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Labels must be positive integers\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Conflict count\n    violations = 0\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            violations += 1\n    if violations > 0:\n        return 10**6 + violations\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nimport math\n\n\ndef _canonicalize(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        out.append(mapping[x])\n    return out\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    if not isinstance(solution, (list, tuple)):\n        return (list(solution), \"InvalidInput\") if isinstance(solution, (list, tuple)) else ([1]*9, \"InvalidInput\")\n    sol = list(solution)\n    n = len(sol)\n    if n != 9:\n        # Force into expected size if corrupted\n        sol = (sol + [1]*9)[:9]\n    # Recolor one random vertex to either an existing color or a new color (at most n colors)\n    idx = random.randrange(9)\n    current_colors = sorted(set(sol))\n    # Candidate colors: existing colors +\/- possibly one new color\n    candidates = set(current_colors)\n    if len(current_colors) < 9:\n        candidates.add(max(current_colors) + 1 if current_colors else 1)\n    # Ensure change occurs\n    candidates.discard(sol[idx])\n    if not candidates:\n        candidates = {((sol[idx] % 9) + 1)}\n    new_color = random.choice(list(candidates))\n    neighbor = sol[:]\n    neighbor[idx] = new_color\n    neighbor = _canonicalize(neighbor)\n    return (neighbor, \"SingleVertexRecolor\")\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + optional relabel shuffle.\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(9)]\n    else:\n        base = list(solution)\n        if len(base) != 9:\n            base = (base + [1]*9)[:9]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        i = random.randrange(9)\n        current_colors = sorted(set(base))\n        cand = set(current_colors)\n        if len(current_colors) < 9:\n            cand.add(max(current_colors) + 1 if current_colors else 1)\n        # avoid no-op\n        if base[i] in cand and len(cand) > 1:\n            cand.remove(base[i])\n        base[i] = random.choice(list(cand))\n    # Optional relabel permutation to change landscape while preserving feasibility structure\n    # Build canonical mapping then randomly permute labels 1..k\n    def canon(sol):\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    base = canon(base)\n    k = len(set(base))\n    if k > 1 and random.random() < 0.5:\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n    return base\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.0006572171}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9 canonical colors. A solution is a list of 9 positive integers [c1,...,c9], index i corresponds to vertex i. Labels are canonicalized by order of first appearance during evaluation.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost (lower is better). Feasible -> number of colors (k).\n    # Infeasible -> PENALTY_BASE * (#conflicting_vertices) + (total_conflicts).\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Count conflicts\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Movement types: SingleVertexRecolor, ConflictRecolor, KempeSwap, ColorSwap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        return ([1]*n, \"InvalidInput\")\n    sol = list(solution)\n    if len(sol) != n:\n        sol = (sol + [1]*n)[:n]\n    for i, x in enumerate(sol):\n        if not isinstance(x, int) or x <= 0:\n            sol[i] = 1\n    sol = canonicalize(sol)\n\n    # Helper structures\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = set(sol)\n\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n\n    def feasible_colors_for_vertex(csol: List[int], v: int) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        # Pick a vertex and a partner color and swap along the Kempe chain\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        # BFS on subgraph induced by colors {a,b} starting at v\n        queue = [v]\n        seen = {v}\n        while queue:\n            x = queue.pop(0)\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n\n    # Strategy selection\n    r = random.random()\n    if num_conflicting_vertices > 0:\n        # Prefer conflict-driven moves\n        if r < 0.7:\n            # Conflict-driven recolor: pick a conflicting vertex and recolor to an existing feasible color if possible\n            candidates = [i+1 for i, x in enumerate(bad) if x > 0]\n            v = random.choice(candidates)\n            feasible = feasible_colors_for_vertex(sol, v)\n            # Restrict to existing colors; avoid no-op\n            if sol[v-1] in feasible and len(feasible) > 1:\n                feasible = [c for c in feasible if c != sol[v-1]]\n            if feasible:\n                new_color = random.choice(feasible)\n            else:\n                # No feasible color among existing ones, pick a different existing color to shake\n                pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                new_color = random.choice(pool)\n            nbr = sol[:]\n            nbr[v-1] = new_color\n            nbr = canonicalize(nbr)\n            assert len(nbr) == n and all(isinstance(x, int) and x > 0 for x in nbr)\n            return (nbr, \"ConflictRecolor\")\n        else:\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            assert len(nbr) == n and all(isinstance(x, int) and x > 0 for x in nbr)\n            return (nbr, m)\n    else:\n        # Feasible: explore symmetry\/merge-improving moves without introducing new colors\n        if r < 0.5:\n            # Try to recolor a vertex from a minority color to reduce k if possible\n            counts = {}\n            for c in sol:\n                counts[c] = counts.get(c, 0) + 1\n            # pick a color with smallest support > 0\n            minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n            indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n            random.shuffle(indices)\n            for v in indices:\n                feasible = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                if feasible:\n                    nbr = sol[:]\n                    nbr[v-1] = random.choice(feasible)\n                    nbr = canonicalize(nbr)\n                    return (nbr, \"SingleVertexRecolor\")\n            # fall back to Kempe if no feasible recolor found\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            return (nbr, m)\n        elif r < 0.8:\n            # Kempe swap to escape plateaus\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            return (nbr, m)\n        else:\n            # Color label swap (symmetry breaking)\n            k = len(colors)\n            if k >= 2:\n                a, b = random.sample(list(colors), 2)\n                mp = {a: b, b: a}\n                nbr = [mp.get(x, x) for x in sol]\n                nbr = canonicalize(nbr)\n                return (nbr, \"ColorSwap\")\n            else:\n                # No-op fallback\n                return (sol[:], \"NoOp\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using existing colors only; includes Kempe swaps and recolors.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    colors = set(base)\n    # Perform several random edits\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Recolor random vertex to a different existing feasible color if available\n            v = random.randint(1, n)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                # pick a different existing color to shake even if creates conflicts\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            # Kempe swap on random vertex and random partner color\n            v = random.randint(1, n)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            # BFS on subgraph induced by {a,b}\n            queue = [v]\n            seen = {v}\n            while queue:\n                x = queue.pop(0)\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        queue.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n\n    # Optional color relabel shuffle to escape symmetry\n    if random.random() < 0.5:\n        k = len(colors)\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n        base = canonicalize(base)\n\n    assert len(base) == n and all(isinstance(x, int) and x > 0 for x in base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001220224}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9 canonical colors. A solution is a list of 9 positive integers [c1,...,c9], index i corresponds to vertex i. Labels are canonicalized by order of first appearance during evaluation.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost (lower is better). Feasible -> number of colors (k).\n    # Infeasible -> PENALTY_BASE * (#conflicting_vertices) + (total_conflicts).\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Count conflicts\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Movement types: SingleVertexRecolor, ConflictRecolor, KempeSwap, ColorSwap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        return ([1]*n, \"InvalidInput\")\n    sol = list(solution)\n    if len(sol) != n:\n        sol = (sol + [1]*n)[:n]\n    for i, x in enumerate(sol):\n        if not isinstance(x, int) or x <= 0:\n            sol[i] = 1\n    sol = canonicalize(sol)\n\n    # Helper structures\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = set(sol)\n\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n\n    def feasible_colors_for_vertex(csol: List[int], v: int) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        # Pick a vertex and a partner color and swap along the Kempe chain\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        # BFS on subgraph induced by colors {a,b} starting at v\n        queue = [v]\n        seen = {v}\n        while queue:\n            x = queue.pop(0)\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n\n    # Strategy selection\n    r = random.random()\n    if num_conflicting_vertices > 0:\n        # Prefer conflict-driven moves\n        if r < 0.7:\n            # Conflict-driven recolor: pick a conflicting vertex and recolor to an existing feasible color if possible\n            candidates = [i+1 for i, x in enumerate(bad) if x > 0]\n            v = random.choice(candidates)\n            feasible = feasible_colors_for_vertex(sol, v)\n            # Restrict to existing colors; avoid no-op\n            if sol[v-1] in feasible and len(feasible) > 1:\n                feasible = [c for c in feasible if c != sol[v-1]]\n            if feasible:\n                new_color = random.choice(feasible)\n            else:\n                # No feasible color among existing ones, pick a different existing color to shake\n                pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                new_color = random.choice(pool)\n            nbr = sol[:]\n            nbr[v-1] = new_color\n            nbr = canonicalize(nbr)\n            assert len(nbr) == n and all(isinstance(x, int) and x > 0 for x in nbr)\n            return (nbr, \"ConflictRecolor\")\n        else:\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            assert len(nbr) == n and all(isinstance(x, int) and x > 0 for x in nbr)\n            return (nbr, m)\n    else:\n        # Feasible: explore symmetry\/merge-improving moves without introducing new colors\n        if r < 0.5:\n            # Try to recolor a vertex from a minority color to reduce k if possible\n            counts = {}\n            for c in sol:\n                counts[c] = counts.get(c, 0) + 1\n            # pick a color with smallest support > 0\n            minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n            indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n            random.shuffle(indices)\n            for v in indices:\n                feasible = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                if feasible:\n                    nbr = sol[:]\n                    nbr[v-1] = random.choice(feasible)\n                    nbr = canonicalize(nbr)\n                    return (nbr, \"SingleVertexRecolor\")\n            # fall back to Kempe if no feasible recolor found\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            return (nbr, m)\n        elif r < 0.8:\n            # Kempe swap to escape plateaus\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            return (nbr, m)\n        else:\n            # Color label swap (symmetry breaking)\n            k = len(colors)\n            if k >= 2:\n                a, b = random.sample(list(colors), 2)\n                mp = {a: b, b: a}\n                nbr = [mp.get(x, x) for x in sol]\n                nbr = canonicalize(nbr)\n                return (nbr, \"ColorSwap\")\n            else:\n                # No-op fallback\n                return (sol[:], \"NoOp\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using existing colors only; includes Kempe swaps and recolors.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    colors = set(base)\n    # Perform several random edits\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Recolor random vertex to a different existing feasible color if available\n            v = random.randint(1, n)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                # pick a different existing color to shake even if creates conflicts\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            # Kempe swap on random vertex and random partner color\n            v = random.randint(1, n)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            # BFS on subgraph induced by {a,b}\n            queue = [v]\n            seen = {v}\n            while queue:\n                x = queue.pop(0)\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        queue.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n\n    # Optional color relabel shuffle to escape symmetry\n    if random.random() < 0.5:\n        k = len(colors)\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n        base = canonicalize(base)\n\n    assert len(base) == n and all(isinstance(x, int) and x > 0 for x in base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001629648}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9 canonical colors. A solution is a list of 9 positive integers [c1,...,c9], index i corresponds to vertex i. Labels are canonicalized by order of first appearance during evaluation.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost (lower is better). Feasible -> number of colors (k).\n    # Infeasible -> PENALTY_BASE * (#conflicting_vertices) + (total_conflicts).\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Count conflicts\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Movement types: SingleVertexRecolor, ConflictRecolor, KempeSwap, ColorSwap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        return ([1]*n, \"InvalidInput\")\n    sol = list(solution)\n    if len(sol) != n:\n        sol = (sol + [1]*n)[:n]\n    for i, x in enumerate(sol):\n        if not isinstance(x, int) or x <= 0:\n            sol[i] = 1\n    sol = canonicalize(sol)\n\n    # Helper structures\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = set(sol)\n\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n\n    def feasible_colors_for_vertex(csol: List[int], v: int) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        # Pick a vertex and a partner color and swap along the Kempe chain\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        # BFS on subgraph induced by colors {a,b} starting at v\n        queue = [v]\n        seen = {v}\n        while queue:\n            x = queue.pop(0)\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n\n    # Strategy selection\n    r = random.random()\n    if num_conflicting_vertices > 0:\n        # Prefer conflict-driven moves\n        if r < 0.7:\n            # Conflict-driven recolor: pick a conflicting vertex and recolor to an existing feasible color if possible\n            candidates = [i+1 for i, x in enumerate(bad) if x > 0]\n            v = random.choice(candidates)\n            feasible = feasible_colors_for_vertex(sol, v)\n            # Restrict to existing colors; avoid no-op\n            if sol[v-1] in feasible and len(feasible) > 1:\n                feasible = [c for c in feasible if c != sol[v-1]]\n            if feasible:\n                new_color = random.choice(feasible)\n            else:\n                # No feasible color among existing ones, pick a different existing color to shake\n                pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                new_color = random.choice(pool)\n            nbr = sol[:]\n            nbr[v-1] = new_color\n            nbr = canonicalize(nbr)\n            assert len(nbr) == n and all(isinstance(x, int) and x > 0 for x in nbr)\n            return (nbr, \"ConflictRecolor\")\n        else:\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            assert len(nbr) == n and all(isinstance(x, int) and x > 0 for x in nbr)\n            return (nbr, m)\n    else:\n        # Feasible: explore symmetry\/merge-improving moves without introducing new colors\n        if r < 0.5:\n            # Try to recolor a vertex from a minority color to reduce k if possible\n            counts = {}\n            for c in sol:\n                counts[c] = counts.get(c, 0) + 1\n            # pick a color with smallest support > 0\n            minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n            indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n            random.shuffle(indices)\n            for v in indices:\n                feasible = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                if feasible:\n                    nbr = sol[:]\n                    nbr[v-1] = random.choice(feasible)\n                    nbr = canonicalize(nbr)\n                    return (nbr, \"SingleVertexRecolor\")\n            # fall back to Kempe if no feasible recolor found\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            return (nbr, m)\n        elif r < 0.8:\n            # Kempe swap to escape plateaus\n            nbr, m = kempe_swap(sol)\n            nbr = canonicalize(nbr)\n            return (nbr, m)\n        else:\n            # Color label swap (symmetry breaking)\n            k = len(colors)\n            if k >= 2:\n                a, b = random.sample(list(colors), 2)\n                mp = {a: b, b: a}\n                nbr = [mp.get(x, x) for x in sol]\n                nbr = canonicalize(nbr)\n                return (nbr, \"ColorSwap\")\n            else:\n                # No-op fallback\n                return (sol[:], \"NoOp\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using existing colors only; includes Kempe swaps and recolors.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    colors = set(base)\n    # Perform several random edits\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Recolor random vertex to a different existing feasible color if available\n            v = random.randint(1, n)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                # pick a different existing color to shake even if creates conflicts\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            # Kempe swap on random vertex and random partner color\n            v = random.randint(1, n)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            # BFS on subgraph induced by {a,b}\n            queue = [v]\n            seen = {v}\n            while queue:\n                x = queue.pop(0)\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        queue.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n\n    # Optional color relabel shuffle to escape symmetry\n    if random.random() < 0.5:\n        k = len(colors)\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n        base = canonicalize(base)\n\n    assert len(base) == n and all(isinstance(x, int) and x > 0 for x in base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001469976}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9: solution is a list of 9 positive integers [c1..c9], index i corresponds to vertex i. Colors are canonicalized by order of first appearance into labels 1..k.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost (lower is better). Feasible -> number of colors (k).\n    # Infeasible -> PENALTY_BASE * (#conflicting_vertices) + (total_conflicts).\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Count conflicts\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Movement types: SingleVertexRecolor, ConflictRecolor, KempeSwap, ColorSwap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        sol = [1]*n\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i, x in enumerate(sol):\n            if not isinstance(x, int) or x <= 0:\n                sol[i] = 1\n    sol = canonicalize(sol)\n\n    # Helper structures\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def recompute_colors(csol: List[int]):\n        return set(csol)\n\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n\n    def feasible_colors_for_vertex(csol: List[int], v: int) -> List[int]:\n        colors = recompute_colors(csol)\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        colors = recompute_colors(csol)\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        # BFS on subgraph induced by colors {a,b} starting at v\n        dq = deque([v])\n        seen = {v}\n        while dq:\n            x = dq.popleft()\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    dq.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n\n    # Attempt to generate a non-identical neighbor; fall back to Kempe if needed\n    for _ in range(10):\n        r = random.random()\n        if num_conflicting_vertices > 0:\n            # Prefer conflict-driven moves; bias to highest-conflict vertices\n            if r < 0.75:\n                weights = [(i+1, bad[i]) for i in range(n) if bad[i] > 0]\n                # Weighted choice by conflict count\n                total = sum(w for _, w in weights)\n                t = random.uniform(0, total)\n                acc = 0.0\n                v = weights[0][0]\n                for node, w in weights:\n                    acc += w\n                    if acc >= t:\n                        v = node\n                        break\n                feas = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                if feas:\n                    new_color = random.choice(feas)\n                else:\n                    colors = recompute_colors(sol)\n                    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                    new_color = random.choice(pool)\n                nbr = sol[:]\n                nbr[v-1] = new_color\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, \"ConflictRecolor\")\n            else:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n        else:\n            # Feasible: try to reduce k or explore symmetries\n            colors = recompute_colors(sol)\n            if r < 0.5:\n                # Try moving a vertex from a minority color\n                counts = {}\n                for c in sol:\n                    counts[c] = counts.get(c, 0) + 1\n                minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n                indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n                random.shuffle(indices)\n                moved = False\n                for v in indices:\n                    feas = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                    if feas:\n                        nbr = sol[:]\n                        nbr[v-1] = random.choice(feas)\n                        nbr = canonicalize(nbr)\n                        if nbr != sol:\n                            return (nbr, \"SingleVertexRecolor\")\n                        moved = True\n                if not moved:\n                    nbr, m = kempe_swap(sol)\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, m)\n            elif r < 0.8:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            else:\n                colors = recompute_colors(sol)\n                k = len(colors)\n                if k >= 2:\n                    a, b = random.sample(list(colors), 2)\n                    mp = {a: b, b: a}\n                    nbr = [mp.get(x, x) for x in sol]\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, \"ColorSwap\")\n    # Fallback: single Kempe attempt or return a trivial shake ensuring change if possible\n    nbr, m = kempe_swap(sol)\n    nbr = canonicalize(nbr)\n    if nbr != sol:\n        return (nbr, m)\n    # Last resort: flip color of a random vertex to another existing color (may create conflict)\n    colors = set(sol)\n    if len(colors) >= 1:\n        v = random.randint(1, n)\n        pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n        new_color = pool[0]\n        nbr = sol[:]\n        nbr[v-1] = new_color\n        nbr = canonicalize(nbr)\n        return (nbr, \"ForcedRecolor\")\n    return (sol[:], \"NoOp\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using existing colors only; includes Kempe swaps and recolors.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    colors = set(base)\n    # Perform several random edits\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.55:\n            # Recolor random vertex to a different existing feasible color if available\n            v = random.randint(1, n)\n            colors = set(base)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            # Kempe swap on random vertex and random partner color\n            v = random.randint(1, n)\n            colors = set(base)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            dq = deque([v])\n            seen = {v}\n            while dq:\n                x = dq.popleft()\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        dq.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n\n    # Optional color relabel shuffle to escape symmetry\n    if random.random() < 0.5:\n        k = len(set(base))\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n        base = canonicalize(base)\n\n    assert len(base) == n and all(isinstance(x, int) and x > 0 for x in base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001404186}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9: solution is a list of 9 positive integers [c1..c9], index i corresponds to vertex i. Colors are canonicalized by order of first appearance into labels 1..k.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost (lower is better). Feasible -> number of colors (k).\n    # Infeasible -> PENALTY_BASE * (#conflicting_vertices) + (total_conflicts).\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Count conflicts\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Movement types: SingleVertexRecolor, ConflictRecolor, KempeSwap, ColorSwap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        sol = [1]*n\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i, x in enumerate(sol):\n            if not isinstance(x, int) or x <= 0:\n                sol[i] = 1\n    sol = canonicalize(sol)\n\n    # Helper structures\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def recompute_colors(csol: List[int]):\n        return set(csol)\n\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n\n    def feasible_colors_for_vertex(csol: List[int], v: int) -> List[int]:\n        colors = recompute_colors(csol)\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        colors = recompute_colors(csol)\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        # BFS on subgraph induced by colors {a,b} starting at v\n        dq = deque([v])\n        seen = {v}\n        while dq:\n            x = dq.popleft()\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    dq.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n\n    # Attempt to generate a non-identical neighbor; fall back to Kempe if needed\n    for _ in range(10):\n        r = random.random()\n        if num_conflicting_vertices > 0:\n            # Prefer conflict-driven moves; bias to highest-conflict vertices\n            if r < 0.75:\n                weights = [(i+1, bad[i]) for i in range(n) if bad[i] > 0]\n                # Weighted choice by conflict count\n                total = sum(w for _, w in weights)\n                t = random.uniform(0, total)\n                acc = 0.0\n                v = weights[0][0]\n                for node, w in weights:\n                    acc += w\n                    if acc >= t:\n                        v = node\n                        break\n                feas = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                if feas:\n                    new_color = random.choice(feas)\n                else:\n                    colors = recompute_colors(sol)\n                    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                    new_color = random.choice(pool)\n                nbr = sol[:]\n                nbr[v-1] = new_color\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, \"ConflictRecolor\")\n            else:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n        else:\n            # Feasible: try to reduce k or explore symmetries\n            colors = recompute_colors(sol)\n            if r < 0.5:\n                # Try moving a vertex from a minority color\n                counts = {}\n                for c in sol:\n                    counts[c] = counts.get(c, 0) + 1\n                minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n                indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n                random.shuffle(indices)\n                moved = False\n                for v in indices:\n                    feas = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                    if feas:\n                        nbr = sol[:]\n                        nbr[v-1] = random.choice(feas)\n                        nbr = canonicalize(nbr)\n                        if nbr != sol:\n                            return (nbr, \"SingleVertexRecolor\")\n                        moved = True\n                if not moved:\n                    nbr, m = kempe_swap(sol)\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, m)\n            elif r < 0.8:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            else:\n                colors = recompute_colors(sol)\n                k = len(colors)\n                if k >= 2:\n                    a, b = random.sample(list(colors), 2)\n                    mp = {a: b, b: a}\n                    nbr = [mp.get(x, x) for x in sol]\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, \"ColorSwap\")\n    # Fallback: single Kempe attempt or return a trivial shake ensuring change if possible\n    nbr, m = kempe_swap(sol)\n    nbr = canonicalize(nbr)\n    if nbr != sol:\n        return (nbr, m)\n    # Last resort: flip color of a random vertex to another existing color (may create conflict)\n    colors = set(sol)\n    if len(colors) >= 1:\n        v = random.randint(1, n)\n        pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n        new_color = pool[0]\n        nbr = sol[:]\n        nbr[v-1] = new_color\n        nbr = canonicalize(nbr)\n        return (nbr, \"ForcedRecolor\")\n    return (sol[:], \"NoOp\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using existing colors only; includes Kempe swaps and recolors.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    colors = set(base)\n    # Perform several random edits\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.55:\n            # Recolor random vertex to a different existing feasible color if available\n            v = random.randint(1, n)\n            colors = set(base)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            # Kempe swap on random vertex and random partner color\n            v = random.randint(1, n)\n            colors = set(base)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            dq = deque([v])\n            seen = {v}\n            while dq:\n                x = dq.popleft()\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        dq.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n\n    # Optional color relabel shuffle to escape symmetry\n    if random.random() < 0.5:\n        k = len(set(base))\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n        base = canonicalize(base)\n\n    assert len(base) == n and all(isinstance(x, int) and x > 0 for x in base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00184169}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9: solution is a list of 9 positive integers [c1..c9], index i corresponds to vertex i. Colors are canonicalized by order of first appearance into labels 1..k.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost (lower is better). Feasible -> number of colors (k).\n    # Infeasible -> PENALTY_BASE * (#conflicting_vertices) + (total_conflicts).\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Basic checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    # Canonical relabeling by order of first appearance\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    # Count conflicts\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    # Feasible: objective is number of colors k\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Movement types: SingleVertexRecolor, ConflictRecolor, KempeSwap, ColorSwap\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        sol = [1]*n\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i, x in enumerate(sol):\n            if not isinstance(x, int) or x <= 0:\n                sol[i] = 1\n    sol = canonicalize(sol)\n\n    # Helper structures\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def recompute_colors(csol: List[int]):\n        return set(csol)\n\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n\n    def feasible_colors_for_vertex(csol: List[int], v: int) -> List[int]:\n        colors = recompute_colors(csol)\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        colors = recompute_colors(csol)\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        # BFS on subgraph induced by colors {a,b} starting at v\n        dq = deque([v])\n        seen = {v}\n        while dq:\n            x = dq.popleft()\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    dq.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n\n    # Attempt to generate a non-identical neighbor; fall back to Kempe if needed\n    for _ in range(10):\n        r = random.random()\n        if num_conflicting_vertices > 0:\n            # Prefer conflict-driven moves; bias to highest-conflict vertices\n            if r < 0.75:\n                weights = [(i+1, bad[i]) for i in range(n) if bad[i] > 0]\n                # Weighted choice by conflict count\n                total = sum(w for _, w in weights)\n                t = random.uniform(0, total)\n                acc = 0.0\n                v = weights[0][0]\n                for node, w in weights:\n                    acc += w\n                    if acc >= t:\n                        v = node\n                        break\n                feas = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                if feas:\n                    new_color = random.choice(feas)\n                else:\n                    colors = recompute_colors(sol)\n                    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                    new_color = random.choice(pool)\n                nbr = sol[:]\n                nbr[v-1] = new_color\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, \"ConflictRecolor\")\n            else:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n        else:\n            # Feasible: try to reduce k or explore symmetries\n            colors = recompute_colors(sol)\n            if r < 0.5:\n                # Try moving a vertex from a minority color\n                counts = {}\n                for c in sol:\n                    counts[c] = counts.get(c, 0) + 1\n                minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n                indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n                random.shuffle(indices)\n                moved = False\n                for v in indices:\n                    feas = [c for c in feasible_colors_for_vertex(sol, v) if c != sol[v-1]]\n                    if feas:\n                        nbr = sol[:]\n                        nbr[v-1] = random.choice(feas)\n                        nbr = canonicalize(nbr)\n                        if nbr != sol:\n                            return (nbr, \"SingleVertexRecolor\")\n                        moved = True\n                if not moved:\n                    nbr, m = kempe_swap(sol)\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, m)\n            elif r < 0.8:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            else:\n                colors = recompute_colors(sol)\n                k = len(colors)\n                if k >= 2:\n                    a, b = random.sample(list(colors), 2)\n                    mp = {a: b, b: a}\n                    nbr = [mp.get(x, x) for x in sol]\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, \"ColorSwap\")\n    # Fallback: single Kempe attempt or return a trivial shake ensuring change if possible\n    nbr, m = kempe_swap(sol)\n    nbr = canonicalize(nbr)\n    if nbr != sol:\n        return (nbr, m)\n    # Last resort: flip color of a random vertex to another existing color (may create conflict)\n    colors = set(sol)\n    if len(colors) >= 1:\n        v = random.randint(1, n)\n        pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n        new_color = pool[0]\n        nbr = sol[:]\n        nbr[v-1] = new_color\n        nbr = canonicalize(nbr)\n        return (nbr, \"ForcedRecolor\")\n    return (sol[:], \"NoOp\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex shake using existing colors only; includes Kempe swaps and recolors.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n\n    # Validate\/repair input\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n\n    colors = set(base)\n    # Perform several random edits\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.55:\n            # Recolor random vertex to a different existing feasible color if available\n            v = random.randint(1, n)\n            colors = set(base)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            # Kempe swap on random vertex and random partner color\n            v = random.randint(1, n)\n            colors = set(base)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            dq = deque([v])\n            seen = {v}\n            while dq:\n                x = dq.popleft()\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        dq.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n\n    # Optional color relabel shuffle to escape symmetry\n    if random.random() < 0.5:\n        k = len(set(base))\n        perm = list(range(1, k+1))\n        random.shuffle(perm)\n        mp = {i+1: perm[i] for i in range(k)}\n        base = [mp[x] for x in base]\n        base = canonicalize(base)\n\n    assert len(base) == n and all(isinstance(x, int) and x > 0 for x in base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001617089}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    if not isinstance(solution, (list, tuple)):\n        sol = [1]*n\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i, x in enumerate(sol):\n            if not isinstance(x, int) or x <= 0:\n                sol[i] = 1\n    sol = canonicalize(sol)\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        colors = set(csol)\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        dq = deque([v])\n        seen = {v}\n        while dq:\n            x = dq.popleft()\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    dq.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n    for _ in range(10):\n        r = random.random()\n        if num_conflicting_vertices > 0:\n            if r < 0.75:\n                weights = [(i+1, bad[i]) for i in range(n) if bad[i] > 0]\n                if not weights:\n                    nbr, m = kempe_swap(sol)\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, m)\n                total = sum(w for _, w in weights)\n                t = random.uniform(0, total)\n                acc = 0.0\n                v = weights[0][0]\n                for node, w in weights:\n                    acc += w\n                    if acc >= t:\n                        v = node\n                        break\n                colors = set(sol)\n                feas = [c for c in feasible_colors_for_vertex(sol, v, colors) if c != sol[v-1]]\n                if feas:\n                    new_color = random.choice(feas)\n                else:\n                    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                    new_color = random.choice(pool)\n                nbr = sol[:]\n                nbr[v-1] = new_color\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, \"ConflictRecolor\")\n            else:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n        else:\n            colors = set(sol)\n            if r < 0.5:\n                counts = {}\n                for c in sol:\n                    counts[c] = counts.get(c, 0) + 1\n                minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n                indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n                random.shuffle(indices)\n                for v in indices:\n                    feas = [c for c in feasible_colors_for_vertex(sol, v, colors) if c != sol[v-1]]\n                    if feas:\n                        nbr = sol[:]\n                        nbr[v-1] = random.choice(feas)\n                        nbr = canonicalize(nbr)\n                        if nbr != sol:\n                            return (nbr, \"SingleVertexRecolor\")\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            elif r < 0.8:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            else:\n                colors = set(sol)\n                k = len(colors)\n                if k >= 2:\n                    a, b = random.sample(list(colors), 2)\n                    mp = {a: b, b: a}\n                    nbr = [mp.get(x, x) for x in sol]\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, \"ColorSwap\")\n    nbr, m = kempe_swap(sol)\n    nbr = canonicalize(nbr)\n    if nbr != sol:\n        return (nbr, m)\n    colors = set(sol)\n    v = random.randint(1, n)\n    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n    new_color = pool[0]\n    nbr = sol[:]\n    nbr[v-1] = new_color\n    nbr = canonicalize(nbr)\n    return (nbr, \"ForcedRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n    colors = set(base)\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.6:\n            v = random.randint(1, n)\n            colors = set(base)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            v = random.randint(1, n)\n            colors = set(base)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            dq = deque([v])\n            seen = {v}\n            while dq:\n                x = dq.popleft()\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        dq.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n    if random.random() < 0.5:\n        k = len(set(base))\n        if k >= 2:\n            perm = list(range(1, k+1))\n            random.shuffle(perm)\n            mp = {i+1: perm[i] for i in range(k)}\n            base = [mp[x] for x in base]\n            base = canonicalize(base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001273394}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    if not isinstance(solution, (list, tuple)):\n        sol = [1]*n\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i, x in enumerate(sol):\n            if not isinstance(x, int) or x <= 0:\n                sol[i] = 1\n    sol = canonicalize(sol)\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        colors = set(csol)\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        dq = deque([v])\n        seen = {v}\n        while dq:\n            x = dq.popleft()\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    dq.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n    for _ in range(10):\n        r = random.random()\n        if num_conflicting_vertices > 0:\n            if r < 0.75:\n                weights = [(i+1, bad[i]) for i in range(n) if bad[i] > 0]\n                if not weights:\n                    nbr, m = kempe_swap(sol)\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, m)\n                total = sum(w for _, w in weights)\n                t = random.uniform(0, total)\n                acc = 0.0\n                v = weights[0][0]\n                for node, w in weights:\n                    acc += w\n                    if acc >= t:\n                        v = node\n                        break\n                colors = set(sol)\n                feas = [c for c in feasible_colors_for_vertex(sol, v, colors) if c != sol[v-1]]\n                if feas:\n                    new_color = random.choice(feas)\n                else:\n                    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                    new_color = random.choice(pool)\n                nbr = sol[:]\n                nbr[v-1] = new_color\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, \"ConflictRecolor\")\n            else:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n        else:\n            colors = set(sol)\n            if r < 0.5:\n                counts = {}\n                for c in sol:\n                    counts[c] = counts.get(c, 0) + 1\n                minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n                indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n                random.shuffle(indices)\n                for v in indices:\n                    feas = [c for c in feasible_colors_for_vertex(sol, v, colors) if c != sol[v-1]]\n                    if feas:\n                        nbr = sol[:]\n                        nbr[v-1] = random.choice(feas)\n                        nbr = canonicalize(nbr)\n                        if nbr != sol:\n                            return (nbr, \"SingleVertexRecolor\")\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            elif r < 0.8:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            else:\n                colors = set(sol)\n                k = len(colors)\n                if k >= 2:\n                    a, b = random.sample(list(colors), 2)\n                    mp = {a: b, b: a}\n                    nbr = [mp.get(x, x) for x in sol]\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, \"ColorSwap\")\n    nbr, m = kempe_swap(sol)\n    nbr = canonicalize(nbr)\n    if nbr != sol:\n        return (nbr, m)\n    colors = set(sol)\n    v = random.randint(1, n)\n    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n    new_color = pool[0]\n    nbr = sol[:]\n    nbr[v-1] = new_color\n    nbr = canonicalize(nbr)\n    return (nbr, \"ForcedRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n    colors = set(base)\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.6:\n            v = random.randint(1, n)\n            colors = set(base)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            v = random.randint(1, n)\n            colors = set(base)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            dq = deque([v])\n            seen = {v}\n            while dq:\n                x = dq.popleft()\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        dq.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n    if random.random() < 0.5:\n        k = len(set(base))\n        if k >= 2:\n            perm = list(range(1, k+1))\n            random.shuffle(perm)\n            mp = {i+1: perm[i] for i in range(k)}\n            base = [mp[x] for x in base]\n            base = canonicalize(base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001630788}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_student_groups_standard","Representacion":"LIST_INT_9","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 10**6\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return 10**9\n    mapping = {}\n    next_label = 1\n    canon = []\n    for x in solution:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        canon.append(mapping[x])\n    total_conflicts = 0\n    conflict_vertices = set()\n    for (u, v) in edges:\n        if canon[u-1] == canon[v-1]:\n            total_conflicts += 1\n            conflict_vertices.add(u)\n            conflict_vertices.add(v)\n    if total_conflicts > 0:\n        return PENALTY_BASE * len(conflict_vertices) + total_conflicts\n    k = len(set(canon))\n    return k\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    if not isinstance(solution, (list, tuple)):\n        sol = [1]*n\n    else:\n        sol = list(solution)\n        if len(sol) != n:\n            sol = (sol + [1]*n)[:n]\n        for i, x in enumerate(sol):\n            if not isinstance(x, int) or x <= 0:\n                sol[i] = 1\n    sol = canonicalize(sol)\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def vertex_conflicts(csol: List[int]) -> List[int]:\n        bad = [0]*n\n        for (u, v) in edges:\n            if csol[u-1] == csol[v-1]:\n                bad[u-1] += 1\n                bad[v-1] += 1\n        return bad\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n    def kempe_swap(csol: List[int]) -> Tuple[List[int], str]:\n        colors = set(csol)\n        v = random.randint(1, n)\n        a = csol[v-1]\n        other_colors = list(colors - {a})\n        if not other_colors:\n            return csol[:], \"KempeSwapNoOp\"\n        b = random.choice(other_colors)\n        dq = deque([v])\n        seen = {v}\n        while dq:\n            x = dq.popleft()\n            for y in adj[x]:\n                if csol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    dq.append(y)\n        out = csol[:]\n        for x in seen:\n            out[x-1] = b if csol[x-1] == a else a\n        return out, \"KempeSwap\"\n    bad = vertex_conflicts(sol)\n    num_conflicting_vertices = sum(1 for x in bad if x > 0)\n    for _ in range(10):\n        r = random.random()\n        if num_conflicting_vertices > 0:\n            if r < 0.75:\n                weights = [(i+1, bad[i]) for i in range(n) if bad[i] > 0]\n                if not weights:\n                    nbr, m = kempe_swap(sol)\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, m)\n                total = sum(w for _, w in weights)\n                t = random.uniform(0, total)\n                acc = 0.0\n                v = weights[0][0]\n                for node, w in weights:\n                    acc += w\n                    if acc >= t:\n                        v = node\n                        break\n                colors = set(sol)\n                feas = [c for c in feasible_colors_for_vertex(sol, v, colors) if c != sol[v-1]]\n                if feas:\n                    new_color = random.choice(feas)\n                else:\n                    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n                    new_color = random.choice(pool)\n                nbr = sol[:]\n                nbr[v-1] = new_color\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, \"ConflictRecolor\")\n            else:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n        else:\n            colors = set(sol)\n            if r < 0.5:\n                counts = {}\n                for c in sol:\n                    counts[c] = counts.get(c, 0) + 1\n                minority_color = min(counts.items(), key=lambda kv: kv[1])[0]\n                indices = [i+1 for i, c in enumerate(sol) if c == minority_color]\n                random.shuffle(indices)\n                for v in indices:\n                    feas = [c for c in feasible_colors_for_vertex(sol, v, colors) if c != sol[v-1]]\n                    if feas:\n                        nbr = sol[:]\n                        nbr[v-1] = random.choice(feas)\n                        nbr = canonicalize(nbr)\n                        if nbr != sol:\n                            return (nbr, \"SingleVertexRecolor\")\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            elif r < 0.8:\n                nbr, m = kempe_swap(sol)\n                nbr = canonicalize(nbr)\n                if nbr != sol:\n                    return (nbr, m)\n            else:\n                colors = set(sol)\n                k = len(colors)\n                if k >= 2:\n                    a, b = random.sample(list(colors), 2)\n                    mp = {a: b, b: a}\n                    nbr = [mp.get(x, x) for x in sol]\n                    nbr = canonicalize(nbr)\n                    if nbr != sol:\n                        return (nbr, \"ColorSwap\")\n    nbr, m = kempe_swap(sol)\n    nbr = canonicalize(nbr)\n    if nbr != sol:\n        return (nbr, m)\n    colors = set(sol)\n    v = random.randint(1, n)\n    pool = list(colors - {sol[v-1]}) or [sol[v-1]]\n    new_color = pool[0]\n    nbr = sol[:]\n    nbr[v-1] = new_color\n    nbr = canonicalize(nbr)\n    return (nbr, \"ForcedRecolor\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    def canonicalize(sol: List[int]) -> List[int]:\n        m = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in m:\n                m[x] = nxt\n                nxt += 1\n            out.append(m[x])\n        return out\n    if not isinstance(solution, (list, tuple)):\n        base = [random.randint(1, 3) for _ in range(n)]\n    else:\n        base = list(solution)\n        if len(base) != n:\n            base = (base + [1]*n)[:n]\n        for i, x in enumerate(base):\n            if not isinstance(x, int) or x <= 0:\n                base[i] = 1\n    base = canonicalize(base)\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    def feasible_colors_for_vertex(csol: List[int], v: int, colors: set) -> List[int]:\n        forbidden = {csol[u-1] for u in adj[v]}\n        return [c for c in colors if c not in forbidden]\n    colors = set(base)\n    n_changes = random.randint(2, 4)\n    for _ in range(n_changes):\n        move_type = random.random()\n        if move_type < 0.6:\n            v = random.randint(1, n)\n            colors = set(base)\n            feas = [c for c in feasible_colors_for_vertex(base, v, colors) if c != base[v-1]]\n            if feas:\n                base[v-1] = random.choice(feas)\n            else:\n                pool = list(colors - {base[v-1]}) or [base[v-1]]\n                base[v-1] = random.choice(pool)\n        else:\n            v = random.randint(1, n)\n            colors = set(base)\n            a = base[v-1]\n            others = list(colors - {a})\n            if not others:\n                continue\n            b = random.choice(others)\n            dq = deque([v])\n            seen = {v}\n            while dq:\n                x = dq.popleft()\n                for y in adj[x]:\n                    if base[y-1] in (a, b) and y not in seen:\n                        seen.add(y)\n                        dq.append(y)\n            for x in seen:\n                base[x-1] = b if base[x-1] == a else a\n        base = canonicalize(base)\n        colors = set(base)\n    if random.random() < 0.5:\n        k = len(set(base))\n        if k >= 2:\n            perm = list(range(1, k+1))\n            random.shuffle(perm)\n            mp = {i+1: perm[i] for i in range(k)}\n            base = [mp[x] for x in base]\n            base = canonicalize(base)\n    return base\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001554578}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Hard penalties\n    PEN_BAD_TYPE_LEN = 10**9\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k, penalize conflicts and invalid values\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Helper to compute feasible colors for a vertex given current assignment\n    def feasible_colors(i: int, k_now: int) -> List[int]:\n        forbidden = set()\n        for (u,v) in E:\n            if u == i:\n                forbidden.add(nsol[v-1])\n            elif v == i:\n                forbidden.add(nsol[u-1])\n        # allow colors in 1..k_now and optionally k_now+1 to encourage exploration\n        feas = [c for c in range(1, k_now+1) if c not in forbidden]\n        # Small probability to allow k+1 even if other feasible exist (diversification)\n        if len(feas) == 0:\n            feas = []\n        return feas\n\n    k = max(nsol) if len(nsol) > 0 and all(isinstance(x,int) for x in nsol) else 1\n\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if nsol[u-1] == nsol[v-1]:\n            conflicts.append((u,v))\n\n    # Movement strategy\n    if conflicts:\n        # Pick a random conflicted vertex and recolor to the smallest feasible color or introduce k+1 if needed\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        feas = feasible_colors(i, k)\n        if feas:\n            new_color = min(feas)\n            move_type = \"ConflictRecolor-FeasibleMin\"\n        else:\n            new_color = k + 1\n            move_type = \"ConflictRecolor-IntroduceNewColor\"\n        nsol[i-1] = new_color\n        return (nsol, \"SingleVertexRecolor\", move_type)\n    else:\n        # No conflicts: try color compaction by attempting to recolor a vertex from max color downwards\n        max_color = k\n        candidates = [i+1 for i,c in enumerate(nsol) if c == max_color]\n        if candidates:\n            i = random.choice(candidates)\n            # try to recolor to any lower feasible color; prefer smallest\n            lower_feas = []\n            # compute forbidden\n            forbidden = set()\n            for (u,v) in E:\n                if u == i:\n                    forbidden.add(nsol[v-1])\n                elif v == i:\n                    forbidden.add(nsol[u-1])\n            for c in range(1, max_color):\n                if c not in forbidden:\n                    lower_feas.append(c)\n            if lower_feas:\n                nsol[i-1] = min(lower_feas)\n                return (nsol, \"ColorCompaction\", \"RecolorMaxToLower\")\n        # Fallback: random vertex recolor to a different color (including possibly k+1)\n        i = random.randint(1, n)\n        # compute forbidden\n        forbidden = set()\n        for (u,v) in E:\n            if u == i:\n                forbidden.add(nsol[v-1])\n            elif v == i:\n                forbidden.add(nsol[u-1])\n        palette = list(range(1, k+1))\n        # ensure a different color choice; if none, allow k+1\n        choices = [c for c in palette if c != nsol[i-1] and c not in forbidden]\n        if not choices:\n            new_color = k + 1 if random.random() < 0.5 else nsol[i-1]\n            move_type = \"RandomRecolor-WithKPlus1\"\n        else:\n            new_color = random.choice(choices)\n            move_type = \"RandomRecolor-FeasibleDifferent\"\n        nsol[i-1] = new_color\n        return (nsol, \"Randomized\", move_type)\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: randomly select a subset of vertices and reassign colors,\n    # possibly introducing up to two new colors to escape local minima.\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    k = max(nsol) if len(nsol) > 0 and all(isinstance(x,int) for x in nsol) else 1\n\n    # choose m vertices to perturb\n    m = max(2, int(0.33 * n))\n    idxs = random.sample(range(n), m)\n\n    # Build adjacency list for quick checks\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # With some probability, allow new colors up to k+2\n    allow_new = random.random() < 0.7\n    max_new_k = k + (2 if allow_new else 0)\n\n    for idx in idxs:\n        i = idx + 1\n        forbidden = { nsol[j-1] for j in adj[i] }\n        palette = list(range(1, max_new_k+1))\n        choices = [c for c in palette if c not in forbidden]\n        if not choices:\n            # if no feasible, assign a random color possibly conflicting to shake hard\n            nsol[i-1] = random.randint(1, max_new_k)\n        else:\n            # bias toward lower colors for compaction while perturbing\n            nsol[i-1] = choices[0]\n\n    return nsol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.00081944}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Hard penalties\n    PEN_BAD_TYPE_LEN = 10**9\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k, penalize conflicts and invalid values\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Helper to compute feasible colors for a vertex given current assignment\n    def feasible_colors(i: int, k_now: int) -> List[int]:\n        forbidden = set()\n        for (u,v) in E:\n            if u == i:\n                forbidden.add(nsol[v-1])\n            elif v == i:\n                forbidden.add(nsol[u-1])\n        # allow colors in 1..k_now and optionally k_now+1 to encourage exploration\n        feas = [c for c in range(1, k_now+1) if c not in forbidden]\n        # Small probability to allow k+1 even if other feasible exist (diversification)\n        if len(feas) == 0:\n            feas = []\n        return feas\n\n    k = max(nsol) if len(nsol) > 0 and all(isinstance(x,int) for x in nsol) else 1\n\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if nsol[u-1] == nsol[v-1]:\n            conflicts.append((u,v))\n\n    # Movement strategy\n    if conflicts:\n        # Pick a random conflicted vertex and recolor to the smallest feasible color or introduce k+1 if needed\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        feas = feasible_colors(i, k)\n        if feas:\n            new_color = min(feas)\n            move_type = \"ConflictRecolor-FeasibleMin\"\n        else:\n            new_color = k + 1\n            move_type = \"ConflictRecolor-IntroduceNewColor\"\n        nsol[i-1] = new_color\n        return (nsol, \"SingleVertexRecolor\", move_type)\n    else:\n        # No conflicts: try color compaction by attempting to recolor a vertex from max color downwards\n        max_color = k\n        candidates = [i+1 for i,c in enumerate(nsol) if c == max_color]\n        if candidates:\n            i = random.choice(candidates)\n            # try to recolor to any lower feasible color; prefer smallest\n            lower_feas = []\n            # compute forbidden\n            forbidden = set()\n            for (u,v) in E:\n                if u == i:\n                    forbidden.add(nsol[v-1])\n                elif v == i:\n                    forbidden.add(nsol[u-1])\n            for c in range(1, max_color):\n                if c not in forbidden:\n                    lower_feas.append(c)\n            if lower_feas:\n                nsol[i-1] = min(lower_feas)\n                return (nsol, \"ColorCompaction\", \"RecolorMaxToLower\")\n        # Fallback: random vertex recolor to a different color (including possibly k+1)\n        i = random.randint(1, n)\n        # compute forbidden\n        forbidden = set()\n        for (u,v) in E:\n            if u == i:\n                forbidden.add(nsol[v-1])\n            elif v == i:\n                forbidden.add(nsol[u-1])\n        palette = list(range(1, k+1))\n        # ensure a different color choice; if none, allow k+1\n        choices = [c for c in palette if c != nsol[i-1] and c not in forbidden]\n        if not choices:\n            new_color = k + 1 if random.random() < 0.5 else nsol[i-1]\n            move_type = \"RandomRecolor-WithKPlus1\"\n        else:\n            new_color = random.choice(choices)\n            move_type = \"RandomRecolor-FeasibleDifferent\"\n        nsol[i-1] = new_color\n        return (nsol, \"Randomized\", move_type)\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: randomly select a subset of vertices and reassign colors,\n    # possibly introducing up to two new colors to escape local minima.\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    k = max(nsol) if len(nsol) > 0 and all(isinstance(x,int) for x in nsol) else 1\n\n    # choose m vertices to perturb\n    m = max(2, int(0.33 * n))\n    idxs = random.sample(range(n), m)\n\n    # Build adjacency list for quick checks\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # With some probability, allow new colors up to k+2\n    allow_new = random.random() < 0.7\n    max_new_k = k + (2 if allow_new else 0)\n\n    for idx in idxs:\n        i = idx + 1\n        forbidden = { nsol[j-1] for j in adj[i] }\n        palette = list(range(1, max_new_k+1))\n        choices = [c for c in palette if c not in forbidden]\n        if not choices:\n            # if no feasible, assign a random color possibly conflicting to shake hard\n            nsol[i-1] = random.randint(1, max_new_k)\n        else:\n            # bias toward lower colors for compaction while perturbing\n            nsol[i-1] = choices[0]\n\n    return nsol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.00094391}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Hard penalties\n    PEN_BAD_TYPE_LEN = 10**9\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k, penalize conflicts and invalid values\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    # Helper to compute feasible colors for a vertex given current assignment\n    def feasible_colors(i: int, k_now: int) -> List[int]:\n        forbidden = set()\n        for (u,v) in E:\n            if u == i:\n                forbidden.add(nsol[v-1])\n            elif v == i:\n                forbidden.add(nsol[u-1])\n        # allow colors in 1..k_now and optionally k_now+1 to encourage exploration\n        feas = [c for c in range(1, k_now+1) if c not in forbidden]\n        # Small probability to allow k+1 even if other feasible exist (diversification)\n        if len(feas) == 0:\n            feas = []\n        return feas\n\n    k = max(nsol) if len(nsol) > 0 and all(isinstance(x,int) for x in nsol) else 1\n\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if nsol[u-1] == nsol[v-1]:\n            conflicts.append((u,v))\n\n    # Movement strategy\n    if conflicts:\n        # Pick a random conflicted vertex and recolor to the smallest feasible color or introduce k+1 if needed\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        feas = feasible_colors(i, k)\n        if feas:\n            new_color = min(feas)\n            move_type = \"ConflictRecolor-FeasibleMin\"\n        else:\n            new_color = k + 1\n            move_type = \"ConflictRecolor-IntroduceNewColor\"\n        nsol[i-1] = new_color\n        return (nsol, \"SingleVertexRecolor\", move_type)\n    else:\n        # No conflicts: try color compaction by attempting to recolor a vertex from max color downwards\n        max_color = k\n        candidates = [i+1 for i,c in enumerate(nsol) if c == max_color]\n        if candidates:\n            i = random.choice(candidates)\n            # try to recolor to any lower feasible color; prefer smallest\n            lower_feas = []\n            # compute forbidden\n            forbidden = set()\n            for (u,v) in E:\n                if u == i:\n                    forbidden.add(nsol[v-1])\n                elif v == i:\n                    forbidden.add(nsol[u-1])\n            for c in range(1, max_color):\n                if c not in forbidden:\n                    lower_feas.append(c)\n            if lower_feas:\n                nsol[i-1] = min(lower_feas)\n                return (nsol, \"ColorCompaction\", \"RecolorMaxToLower\")\n        # Fallback: random vertex recolor to a different color (including possibly k+1)\n        i = random.randint(1, n)\n        # compute forbidden\n        forbidden = set()\n        for (u,v) in E:\n            if u == i:\n                forbidden.add(nsol[v-1])\n            elif v == i:\n                forbidden.add(nsol[u-1])\n        palette = list(range(1, k+1))\n        # ensure a different color choice; if none, allow k+1\n        choices = [c for c in palette if c != nsol[i-1] and c not in forbidden]\n        if not choices:\n            new_color = k + 1 if random.random() < 0.5 else nsol[i-1]\n            move_type = \"RandomRecolor-WithKPlus1\"\n        else:\n            new_color = random.choice(choices)\n            move_type = \"RandomRecolor-FeasibleDifferent\"\n        nsol[i-1] = new_color\n        return (nsol, \"Randomized\", move_type)\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: randomly select a subset of vertices and reassign colors,\n    # possibly introducing up to two new colors to escape local minima.\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    k = max(nsol) if len(nsol) > 0 and all(isinstance(x,int) for x in nsol) else 1\n\n    # choose m vertices to perturb\n    m = max(2, int(0.33 * n))\n    idxs = random.sample(range(n), m)\n\n    # Build adjacency list for quick checks\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # With some probability, allow new colors up to k+2\n    allow_new = random.random() < 0.7\n    max_new_k = k + (2 if allow_new else 0)\n\n    for idx in idxs:\n        i = idx + 1\n        forbidden = { nsol[j-1] for j in adj[i] }\n        palette = list(range(1, max_new_k+1))\n        choices = [c for c in palette if c not in forbidden]\n        if not choices:\n            # if no feasible, assign a random color possibly conflicting to shake hard\n            nsol[i-1] = random.randint(1, max_new_k)\n        else:\n            # bias toward lower colors for compaction while perturbing\n            nsol[i-1] = choices[0]\n\n    return nsol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.000929821}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Hard penalties\n    PEN_BAD_TYPE_LEN = 10**9\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k, penalize conflicts and invalid values\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def current_k(colors):\n        try:\n            return max(colors)\n        except ValueError:\n            return 1\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def dsatur_value(vertex, colors):\n        # Number of distinct neighbor colors among lower-than-k colors\n        neigh_colors = { colors[j-1] for j in adj[vertex] if isinstance(colors[j-1], int) }\n        return len(neigh_colors)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        # BFS on subgraph induced by colors {a,b} through alternating edges\n        visited = set()\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if colors[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if colors[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        # swap colors a<->b on visited\n        for v in visited:\n            colors[v-1] = a if colors[v-1] == b else b\n        return colors\n\n    k = current_k(nsol)\n\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if nsol[u-1] == nsol[v-1]:\n            conflicts.append((u,v))\n\n    if conflicts:\n        # Conflict repair first: recolor a conflicted vertex to feasible smallest color;\n        # if none feasible in 1..k, allow k+1 (diversification only under conflict)\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        feas = feasible_colors(i, k, nsol)\n        if feas:\n            nsol[i-1] = min(feas)\n            return (nsol, \"SingleVertexRecolor\", \"ConflictRepair-FeasibleMin\")\n        else:\n            nsol[i-1] = k + 1\n            return (nsol, \"SingleVertexRecolor\", \"ConflictRepair-IntroduceKPlus1\")\n\n    # No conflicts: attempt color compaction by removing max color via DSATUR ordering\n    max_color = k\n    max_vertices = [i+1 for i,c in enumerate(nsol) if c == max_color]\n    if max_vertices:\n        # Sort by DSATUR (higher first), then by degree (higher first)\n        max_vertices.sort(key=lambda v: (dsatur_value(v, nsol), len(adj[v])), reverse=True)\n        for i in max_vertices:\n            lower_feas = [c for c in feasible_colors(i, max_color-1, nsol) if 1 <= c <= max_color-1]\n            if lower_feas:\n                nsol[i-1] = min(lower_feas)\n                return (nsol, \"ColorCompaction\", \"RecolorMaxToLower-DSATUR\")\n        # If we couldn't recolor any max-color vertex directly, try Kempe swap to free a lower color\n        i = random.choice(max_vertices)\n        # pick a lower color candidate; prioritize smallest available that conflicts on neighbors\n        neighbor_colors = { nsol[j-1] for j in adj[i] }\n        candidates = [c for c in range(1, max_color) if c in neighbor_colors]\n        if candidates:\n            a = min(candidates)\n            b = nsol[i-1]\n            trial = list(nsol)\n            kempe_chain_swap(trial, i, a, b)\n            # After swap, try recolor i to color a if feasible\n            forb = { trial[j-1] for j in adj[i] }\n            if a not in forb:\n                trial[i-1] = a\n                return (trial, \"KempeChain\", \"KempeSwapThenRecolorMax\")\n        # If Kempe on max failed, fall through to general Kempe swap for diversification\n\n    # Diversification: Kempe-chain swap between two colors a!=b on a random vertex\n    v0 = random.randint(1, n)\n    a = nsol[v0-1]\n    # choose b different from a; if only one color used, make b = a+1 (still safe as swap no-ops)\n    palette = sorted({c for c in nsol})\n    b_choices = [c for c in palette if c != a]\n    if not b_choices:\n        # nothing to swap; try random recolor within current palette if feasible\n        forb = { nsol[j-1] for j in adj[v0] }\n        choices = [c for c in palette if c != a and c not in forb]\n        if choices:\n            nsol[v0-1] = random.choice(choices)\n            return (nsol, \"Randomized\", \"RandomRecolor-FeasibleDifferent\")\n        else:\n            return (nsol, \"NoOp\", \"StableState\")\n    b = random.choice(b_choices)\n    trial = list(nsol)\n    kempe_chain_swap(trial, v0, a, b)\n    return (trial, \"KempeChain\", \"KempeSwapDiversify\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        visited = set()\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if colors[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if colors[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            colors[v-1] = a if colors[v-1] == b else b\n        return colors\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    k = max(nsol) if nsol else 1\n\n    # Number of Kempe swaps and recolors based on size\n    num_swaps = 2\n    num_recolors = 2\n\n    # Perform Kempe swaps\n    palette = sorted({c for c in nsol})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = nsol[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        nsol = kempe_chain_swap(nsol, v0, a, b)\n\n    # Selective recolors possibly allowing a single new color to shake out of traps\n    allow_new = True\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        forb = { nsol[j-1] for j in adj[i] }\n        k_now = max(nsol)\n        palette2 = list(range(1, k_now + (1 if allow_new else 0) + 1))\n        choices = [c for c in palette2 if c not in forb]\n        if choices:\n            # bias to lower colors to aid compaction post-perturb\n            nsol[i-1] = min(choices)\n        else:\n            # if no feasible choice, assign a random existing color to avoid explosion\n            nsol[i-1] = random.randint(1, k_now)\n    return nsol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001167443}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Hard penalties\n    PEN_BAD_TYPE_LEN = 10**9\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k, penalize conflicts and invalid values\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def current_k(colors):\n        try:\n            return max(colors)\n        except ValueError:\n            return 1\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def dsatur_value(vertex, colors):\n        # Number of distinct neighbor colors among lower-than-k colors\n        neigh_colors = { colors[j-1] for j in adj[vertex] if isinstance(colors[j-1], int) }\n        return len(neigh_colors)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        # BFS on subgraph induced by colors {a,b} through alternating edges\n        visited = set()\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if colors[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if colors[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        # swap colors a<->b on visited\n        for v in visited:\n            colors[v-1] = a if colors[v-1] == b else b\n        return colors\n\n    k = current_k(nsol)\n\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if nsol[u-1] == nsol[v-1]:\n            conflicts.append((u,v))\n\n    if conflicts:\n        # Conflict repair first: recolor a conflicted vertex to feasible smallest color;\n        # if none feasible in 1..k, allow k+1 (diversification only under conflict)\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        feas = feasible_colors(i, k, nsol)\n        if feas:\n            nsol[i-1] = min(feas)\n            return (nsol, \"SingleVertexRecolor\", \"ConflictRepair-FeasibleMin\")\n        else:\n            nsol[i-1] = k + 1\n            return (nsol, \"SingleVertexRecolor\", \"ConflictRepair-IntroduceKPlus1\")\n\n    # No conflicts: attempt color compaction by removing max color via DSATUR ordering\n    max_color = k\n    max_vertices = [i+1 for i,c in enumerate(nsol) if c == max_color]\n    if max_vertices:\n        # Sort by DSATUR (higher first), then by degree (higher first)\n        max_vertices.sort(key=lambda v: (dsatur_value(v, nsol), len(adj[v])), reverse=True)\n        for i in max_vertices:\n            lower_feas = [c for c in feasible_colors(i, max_color-1, nsol) if 1 <= c <= max_color-1]\n            if lower_feas:\n                nsol[i-1] = min(lower_feas)\n                return (nsol, \"ColorCompaction\", \"RecolorMaxToLower-DSATUR\")\n        # If we couldn't recolor any max-color vertex directly, try Kempe swap to free a lower color\n        i = random.choice(max_vertices)\n        # pick a lower color candidate; prioritize smallest available that conflicts on neighbors\n        neighbor_colors = { nsol[j-1] for j in adj[i] }\n        candidates = [c for c in range(1, max_color) if c in neighbor_colors]\n        if candidates:\n            a = min(candidates)\n            b = nsol[i-1]\n            trial = list(nsol)\n            kempe_chain_swap(trial, i, a, b)\n            # After swap, try recolor i to color a if feasible\n            forb = { trial[j-1] for j in adj[i] }\n            if a not in forb:\n                trial[i-1] = a\n                return (trial, \"KempeChain\", \"KempeSwapThenRecolorMax\")\n        # If Kempe on max failed, fall through to general Kempe swap for diversification\n\n    # Diversification: Kempe-chain swap between two colors a!=b on a random vertex\n    v0 = random.randint(1, n)\n    a = nsol[v0-1]\n    # choose b different from a; if only one color used, make b = a+1 (still safe as swap no-ops)\n    palette = sorted({c for c in nsol})\n    b_choices = [c for c in palette if c != a]\n    if not b_choices:\n        # nothing to swap; try random recolor within current palette if feasible\n        forb = { nsol[j-1] for j in adj[v0] }\n        choices = [c for c in palette if c != a and c not in forb]\n        if choices:\n            nsol[v0-1] = random.choice(choices)\n            return (nsol, \"Randomized\", \"RandomRecolor-FeasibleDifferent\")\n        else:\n            return (nsol, \"NoOp\", \"StableState\")\n    b = random.choice(b_choices)\n    trial = list(nsol)\n    kempe_chain_swap(trial, v0, a, b)\n    return (trial, \"KempeChain\", \"KempeSwapDiversify\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        visited = set()\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if colors[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if colors[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            colors[v-1] = a if colors[v-1] == b else b\n        return colors\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    k = max(nsol) if nsol else 1\n\n    # Number of Kempe swaps and recolors based on size\n    num_swaps = 2\n    num_recolors = 2\n\n    # Perform Kempe swaps\n    palette = sorted({c for c in nsol})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = nsol[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        nsol = kempe_chain_swap(nsol, v0, a, b)\n\n    # Selective recolors possibly allowing a single new color to shake out of traps\n    allow_new = True\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        forb = { nsol[j-1] for j in adj[i] }\n        k_now = max(nsol)\n        palette2 = list(range(1, k_now + (1 if allow_new else 0) + 1))\n        choices = [c for c in palette2 if c not in forb]\n        if choices:\n            # bias to lower colors to aid compaction post-perturb\n            nsol[i-1] = min(choices)\n        else:\n            # if no feasible choice, assign a random existing color to avoid explosion\n            nsol[i-1] = random.randint(1, k_now)\n    return nsol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001400616}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Hard penalties\n    PEN_BAD_TYPE_LEN = 10**9\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k, penalize conflicts and invalid values\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def current_k(colors):\n        try:\n            return max(colors)\n        except ValueError:\n            return 1\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def dsatur_value(vertex, colors):\n        # Number of distinct neighbor colors among lower-than-k colors\n        neigh_colors = { colors[j-1] for j in adj[vertex] if isinstance(colors[j-1], int) }\n        return len(neigh_colors)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        # BFS on subgraph induced by colors {a,b} through alternating edges\n        visited = set()\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if colors[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if colors[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        # swap colors a<->b on visited\n        for v in visited:\n            colors[v-1] = a if colors[v-1] == b else b\n        return colors\n\n    k = current_k(nsol)\n\n    # Identify conflicts\n    conflicts = []\n    for (u,v) in E:\n        if nsol[u-1] == nsol[v-1]:\n            conflicts.append((u,v))\n\n    if conflicts:\n        # Conflict repair first: recolor a conflicted vertex to feasible smallest color;\n        # if none feasible in 1..k, allow k+1 (diversification only under conflict)\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        feas = feasible_colors(i, k, nsol)\n        if feas:\n            nsol[i-1] = min(feas)\n            return (nsol, \"SingleVertexRecolor\", \"ConflictRepair-FeasibleMin\")\n        else:\n            nsol[i-1] = k + 1\n            return (nsol, \"SingleVertexRecolor\", \"ConflictRepair-IntroduceKPlus1\")\n\n    # No conflicts: attempt color compaction by removing max color via DSATUR ordering\n    max_color = k\n    max_vertices = [i+1 for i,c in enumerate(nsol) if c == max_color]\n    if max_vertices:\n        # Sort by DSATUR (higher first), then by degree (higher first)\n        max_vertices.sort(key=lambda v: (dsatur_value(v, nsol), len(adj[v])), reverse=True)\n        for i in max_vertices:\n            lower_feas = [c for c in feasible_colors(i, max_color-1, nsol) if 1 <= c <= max_color-1]\n            if lower_feas:\n                nsol[i-1] = min(lower_feas)\n                return (nsol, \"ColorCompaction\", \"RecolorMaxToLower-DSATUR\")\n        # If we couldn't recolor any max-color vertex directly, try Kempe swap to free a lower color\n        i = random.choice(max_vertices)\n        # pick a lower color candidate; prioritize smallest available that conflicts on neighbors\n        neighbor_colors = { nsol[j-1] for j in adj[i] }\n        candidates = [c for c in range(1, max_color) if c in neighbor_colors]\n        if candidates:\n            a = min(candidates)\n            b = nsol[i-1]\n            trial = list(nsol)\n            kempe_chain_swap(trial, i, a, b)\n            # After swap, try recolor i to color a if feasible\n            forb = { trial[j-1] for j in adj[i] }\n            if a not in forb:\n                trial[i-1] = a\n                return (trial, \"KempeChain\", \"KempeSwapThenRecolorMax\")\n        # If Kempe on max failed, fall through to general Kempe swap for diversification\n\n    # Diversification: Kempe-chain swap between two colors a!=b on a random vertex\n    v0 = random.randint(1, n)\n    a = nsol[v0-1]\n    # choose b different from a; if only one color used, make b = a+1 (still safe as swap no-ops)\n    palette = sorted({c for c in nsol})\n    b_choices = [c for c in palette if c != a]\n    if not b_choices:\n        # nothing to swap; try random recolor within current palette if feasible\n        forb = { nsol[j-1] for j in adj[v0] }\n        choices = [c for c in palette if c != a and c not in forb]\n        if choices:\n            nsol[v0-1] = random.choice(choices)\n            return (nsol, \"Randomized\", \"RandomRecolor-FeasibleDifferent\")\n        else:\n            return (nsol, \"NoOp\", \"StableState\")\n    b = random.choice(b_choices)\n    trial = list(nsol)\n    kempe_chain_swap(trial, v0, a, b)\n    return (trial, \"KempeChain\", \"KempeSwapDiversify\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors\n    nsol = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        visited = set()\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if colors[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if colors[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            colors[v-1] = a if colors[v-1] == b else b\n        return colors\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    k = max(nsol) if nsol else 1\n\n    # Number of Kempe swaps and recolors based on size\n    num_swaps = 2\n    num_recolors = 2\n\n    # Perform Kempe swaps\n    palette = sorted({c for c in nsol})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = nsol[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        nsol = kempe_chain_swap(nsol, v0, a, b)\n\n    # Selective recolors possibly allowing a single new color to shake out of traps\n    allow_new = True\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        forb = { nsol[j-1] for j in adj[i] }\n        k_now = max(nsol)\n        palette2 = list(range(1, k_now + (1 if allow_new else 0) + 1))\n        choices = [c for c in palette2 if c not in forb]\n        if choices:\n            # bias to lower colors to aid compaction post-perturb\n            nsol[i-1] = min(choices)\n        else:\n            # if no feasible choice, assign a random existing color to avoid explosion\n            nsol[i-1] = random.randint(1, k_now)\n    return nsol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001248164}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Penalties\n    PEN_BAD_TYPE_LEN = 10**8\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized; plus invalidity penalties\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def dsatur_value(vertex, colors):\n        return len({ colors[j-1] for j in adj[vertex] })\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    k = max(cur) if cur else 1\n\n    # Identify conflicts\n    conflicts = [(u,v) for (u,v) in E if cur[u-1] == cur[v-1]]\n\n    if conflicts:\n        # Conflict repair: pick a conflicted vertex; try min-conflicts recolor within 1..k\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        # Evaluate candidate colors by resulting local conflicts\n        candidates = list(range(1, k+1))\n        best_c = None\n        best_score = None\n        for c in candidates:\n            if c == cur[i-1]:\n                continue\n            trial = list(cur)\n            trial[i-1] = c\n            # local conflict count around i\n            loc = 0\n            for nb in adj[i]:\n                if trial[nb-1] == trial[i-1]:\n                    loc += 1\n            score = (loc, -dsatur_value(i, trial), c)\n            if (best_score is None) or (score < best_score):\n                best_score = score\n                best_c = c\n        if best_c is not None:\n            out = list(cur)\n            out[i-1] = best_c\n            if out != cur:\n                return (out, \"ConflictRepair\")\n        # fallback: kempe swap between two colors seen around i\n        palette = sorted({c for c in cur})\n        a = cur[i-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            b = random.choice(b_choices)\n            out = kempe_chain_swap(cur, i, a, b)\n            if out != cur:\n                return (out, \"Kempe\")\n        # last resort: rotate palette to change state\n        out = [((c % k) + 1) for c in cur]\n        return (out, \"Diversify\")\n\n    # No conflicts: attempt compaction (move from max color down)\n    max_vertices = [i+1 for i,c in enumerate(cur) if c == k]\n    if max_vertices:\n        # Try DSATUR-ordered recolor to lower colors\n        max_vertices.sort(key=lambda v: (dsatur_value(v, cur), len(adj[v])), reverse=True)\n        for i in max_vertices:\n            lower_feas = [c for c in feasible_colors(i, k-1, cur) if 1 <= c <= k-1]\n            if lower_feas:\n                out = list(cur)\n                out[i-1] = min(lower_feas)\n                if out != cur:\n                    return (out, \"Compaction\")\n        # Try Kempe swap with a lower color then recolor one vertex from max color\n        i = random.choice(max_vertices)\n        neighbor_colors = sorted({ cur[j-1] for j in adj[i] })\n        candidates = [c for c in neighbor_colors if 1 <= c <= k-1]\n        if candidates:\n            a = min(candidates)\n            b = cur[i-1]\n            trial = kempe_chain_swap(cur, i, a, b)\n            # After swap, see if some max-color vertex can move down\n            for j in [t+1 for t,x in enumerate(trial) if x == k]:\n                feas = [c for c in feasible_colors(j, k-1, trial) if 1 <= c <= k-1]\n                if feas:\n                    trial2 = list(trial)\n                    trial2[j-1] = min(feas)\n                    if trial2 != cur:\n                        return (trial2, \"Compaction\")\n        # Color-class swap between k and a random lower color\n        lower_colors = [c for c in range(1, k) if c in cur]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            out = [ (k if x==c2 else (c2 if x==k else x)) for x in cur ]\n            if out != cur:\n                return (out, \"Diversify\")\n\n    # Diversification on feasible state: Kempe swap between two random colors\n    palette = sorted({c for c in cur})\n    if len(palette) >= 2:\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b = random.choice([c for c in palette if c != a])\n        out = kempe_chain_swap(cur, v0, a, b)\n        if out != cur:\n            return (out, \"Kempe\")\n    # Final fallback: rotate colors to guarantee a change\n    k = max(cur) if cur else 1\n    out = [((c % k) + 1) for c in cur]\n    return (out, \"Diversify\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors (within current k)\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    if not cur:\n        return cur\n    k = max(cur)\n\n    # Parameters\n    num_swaps = 2\n    num_recolors = 3\n\n    # Perform Kempe swaps among random vertices\/colors\n    palette = sorted({c for c in cur})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        cur = kempe_chain_swap(cur, v0, a, b)\n\n    # Selective recolors, restricted to current palette (avoid k drift)\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        feas = feasible_colors(i, k, cur)\n        if feas:\n            # bias to lower colors\n            target = min(feas)\n            if cur[i-1] != target:\n                cur[i-1] = target\n        else:\n            # choose a random existing color different from current to shake structure\n            choices = [c for c in range(1, k+1) if c != cur[i-1]]\n            if choices:\n                cur[i-1] = random.choice(choices)\n\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001326895}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Penalties\n    PEN_BAD_TYPE_LEN = 10**8\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized; plus invalidity penalties\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def dsatur_value(vertex, colors):\n        return len({ colors[j-1] for j in adj[vertex] })\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    k = max(cur) if cur else 1\n\n    # Identify conflicts\n    conflicts = [(u,v) for (u,v) in E if cur[u-1] == cur[v-1]]\n\n    if conflicts:\n        # Conflict repair: pick a conflicted vertex; try min-conflicts recolor within 1..k\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        # Evaluate candidate colors by resulting local conflicts\n        candidates = list(range(1, k+1))\n        best_c = None\n        best_score = None\n        for c in candidates:\n            if c == cur[i-1]:\n                continue\n            trial = list(cur)\n            trial[i-1] = c\n            # local conflict count around i\n            loc = 0\n            for nb in adj[i]:\n                if trial[nb-1] == trial[i-1]:\n                    loc += 1\n            score = (loc, -dsatur_value(i, trial), c)\n            if (best_score is None) or (score < best_score):\n                best_score = score\n                best_c = c\n        if best_c is not None:\n            out = list(cur)\n            out[i-1] = best_c\n            if out != cur:\n                return (out, \"ConflictRepair\")\n        # fallback: kempe swap between two colors seen around i\n        palette = sorted({c for c in cur})\n        a = cur[i-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            b = random.choice(b_choices)\n            out = kempe_chain_swap(cur, i, a, b)\n            if out != cur:\n                return (out, \"Kempe\")\n        # last resort: rotate palette to change state\n        out = [((c % k) + 1) for c in cur]\n        return (out, \"Diversify\")\n\n    # No conflicts: attempt compaction (move from max color down)\n    max_vertices = [i+1 for i,c in enumerate(cur) if c == k]\n    if max_vertices:\n        # Try DSATUR-ordered recolor to lower colors\n        max_vertices.sort(key=lambda v: (dsatur_value(v, cur), len(adj[v])), reverse=True)\n        for i in max_vertices:\n            lower_feas = [c for c in feasible_colors(i, k-1, cur) if 1 <= c <= k-1]\n            if lower_feas:\n                out = list(cur)\n                out[i-1] = min(lower_feas)\n                if out != cur:\n                    return (out, \"Compaction\")\n        # Try Kempe swap with a lower color then recolor one vertex from max color\n        i = random.choice(max_vertices)\n        neighbor_colors = sorted({ cur[j-1] for j in adj[i] })\n        candidates = [c for c in neighbor_colors if 1 <= c <= k-1]\n        if candidates:\n            a = min(candidates)\n            b = cur[i-1]\n            trial = kempe_chain_swap(cur, i, a, b)\n            # After swap, see if some max-color vertex can move down\n            for j in [t+1 for t,x in enumerate(trial) if x == k]:\n                feas = [c for c in feasible_colors(j, k-1, trial) if 1 <= c <= k-1]\n                if feas:\n                    trial2 = list(trial)\n                    trial2[j-1] = min(feas)\n                    if trial2 != cur:\n                        return (trial2, \"Compaction\")\n        # Color-class swap between k and a random lower color\n        lower_colors = [c for c in range(1, k) if c in cur]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            out = [ (k if x==c2 else (c2 if x==k else x)) for x in cur ]\n            if out != cur:\n                return (out, \"Diversify\")\n\n    # Diversification on feasible state: Kempe swap between two random colors\n    palette = sorted({c for c in cur})\n    if len(palette) >= 2:\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b = random.choice([c for c in palette if c != a])\n        out = kempe_chain_swap(cur, v0, a, b)\n        if out != cur:\n            return (out, \"Kempe\")\n    # Final fallback: rotate colors to guarantee a change\n    k = max(cur) if cur else 1\n    out = [((c % k) + 1) for c in cur]\n    return (out, \"Diversify\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors (within current k)\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    if not cur:\n        return cur\n    k = max(cur)\n\n    # Parameters\n    num_swaps = 2\n    num_recolors = 3\n\n    # Perform Kempe swaps among random vertices\/colors\n    palette = sorted({c for c in cur})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        cur = kempe_chain_swap(cur, v0, a, b)\n\n    # Selective recolors, restricted to current palette (avoid k drift)\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        feas = feasible_colors(i, k, cur)\n        if feas:\n            # bias to lower colors\n            target = min(feas)\n            if cur[i-1] != target:\n                cur[i-1] = target\n        else:\n            # choose a random existing color different from current to shake structure\n            choices = [c for c in range(1, k+1) if c != cur[i-1]]\n            if choices:\n                cur[i-1] = random.choice(choices)\n\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001530577}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Penalties\n    PEN_BAD_TYPE_LEN = 10**8\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized; plus invalidity penalties\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def dsatur_value(vertex, colors):\n        return len({ colors[j-1] for j in adj[vertex] })\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    k = max(cur) if cur else 1\n\n    # Identify conflicts\n    conflicts = [(u,v) for (u,v) in E if cur[u-1] == cur[v-1]]\n\n    if conflicts:\n        # Conflict repair: pick a conflicted vertex; try min-conflicts recolor within 1..k\n        (u,v) = random.choice(conflicts)\n        i = random.choice([u,v])\n        # Evaluate candidate colors by resulting local conflicts\n        candidates = list(range(1, k+1))\n        best_c = None\n        best_score = None\n        for c in candidates:\n            if c == cur[i-1]:\n                continue\n            trial = list(cur)\n            trial[i-1] = c\n            # local conflict count around i\n            loc = 0\n            for nb in adj[i]:\n                if trial[nb-1] == trial[i-1]:\n                    loc += 1\n            score = (loc, -dsatur_value(i, trial), c)\n            if (best_score is None) or (score < best_score):\n                best_score = score\n                best_c = c\n        if best_c is not None:\n            out = list(cur)\n            out[i-1] = best_c\n            if out != cur:\n                return (out, \"ConflictRepair\")\n        # fallback: kempe swap between two colors seen around i\n        palette = sorted({c for c in cur})\n        a = cur[i-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            b = random.choice(b_choices)\n            out = kempe_chain_swap(cur, i, a, b)\n            if out != cur:\n                return (out, \"Kempe\")\n        # last resort: rotate palette to change state\n        out = [((c % k) + 1) for c in cur]\n        return (out, \"Diversify\")\n\n    # No conflicts: attempt compaction (move from max color down)\n    max_vertices = [i+1 for i,c in enumerate(cur) if c == k]\n    if max_vertices:\n        # Try DSATUR-ordered recolor to lower colors\n        max_vertices.sort(key=lambda v: (dsatur_value(v, cur), len(adj[v])), reverse=True)\n        for i in max_vertices:\n            lower_feas = [c for c in feasible_colors(i, k-1, cur) if 1 <= c <= k-1]\n            if lower_feas:\n                out = list(cur)\n                out[i-1] = min(lower_feas)\n                if out != cur:\n                    return (out, \"Compaction\")\n        # Try Kempe swap with a lower color then recolor one vertex from max color\n        i = random.choice(max_vertices)\n        neighbor_colors = sorted({ cur[j-1] for j in adj[i] })\n        candidates = [c for c in neighbor_colors if 1 <= c <= k-1]\n        if candidates:\n            a = min(candidates)\n            b = cur[i-1]\n            trial = kempe_chain_swap(cur, i, a, b)\n            # After swap, see if some max-color vertex can move down\n            for j in [t+1 for t,x in enumerate(trial) if x == k]:\n                feas = [c for c in feasible_colors(j, k-1, trial) if 1 <= c <= k-1]\n                if feas:\n                    trial2 = list(trial)\n                    trial2[j-1] = min(feas)\n                    if trial2 != cur:\n                        return (trial2, \"Compaction\")\n        # Color-class swap between k and a random lower color\n        lower_colors = [c for c in range(1, k) if c in cur]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            out = [ (k if x==c2 else (c2 if x==k else x)) for x in cur ]\n            if out != cur:\n                return (out, \"Diversify\")\n\n    # Diversification on feasible state: Kempe swap between two random colors\n    palette = sorted({c for c in cur})\n    if len(palette) >= 2:\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b = random.choice([c for c in palette if c != a])\n        out = kempe_chain_swap(cur, v0, a, b)\n        if out != cur:\n            return (out, \"Kempe\")\n    # Final fallback: rotate colors to guarantee a change\n    k = max(cur) if cur else 1\n    out = [((c % k) + 1) for c in cur]\n    return (out, \"Diversify\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors (within current k)\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    if not cur:\n        return cur\n    k = max(cur)\n\n    # Parameters\n    num_swaps = 2\n    num_recolors = 3\n\n    # Perform Kempe swaps among random vertices\/colors\n    palette = sorted({c for c in cur})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        b = random.choice(b_choices)\n        cur = kempe_chain_swap(cur, v0, a, b)\n\n    # Selective recolors, restricted to current palette (avoid k drift)\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        feas = feasible_colors(i, k, cur)\n        if feas:\n            # bias to lower colors\n            target = min(feas)\n            if cur[i-1] != target:\n                cur[i-1] = target\n        else:\n            # choose a random existing color different from current to shake structure\n            choices = [c for c in range(1, k+1) if c != cur[i-1]]\n            if choices:\n                cur[i-1] = random.choice(choices)\n\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001421486}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Penalties\n    PEN_BAD_TYPE_LEN = 10**8\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized; plus invalidity penalties\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def degree(v):\n        return len(adj[v])\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    if not cur:\n        return (cur, \"NoOp\")\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = [(u,v) for (u,v) in E if cur[u-1] == cur[v-1]]\n\n    if conflicts:\n        # Conflict repair: choose conflict endpoint with higher degree\n        (u,v) = random.choice(conflicts)\n        i = u if degree(u) >= degree(v) else v\n        # Evaluate recolors within 1..k using least-constraining heuristic\n        best_sol = None\n        best_score = None\n        current_k = k\n        for c in range(1, current_k+1):\n            if c == cur[i-1]:\n                continue\n            trial = list(cur)\n            trial[i-1] = c\n            # local conflicts and k-after (avoid palette growth)\n            loc_conf = 0\n            for nb in adj[i]:\n                if trial[nb-1] == trial[i-1]:\n                    loc_conf += 1\n            # estimate future pressure: sum of available colors for neighbors (higher is better)\n            pressure = 0\n            for nb in adj[i]:\n                forb = { trial[j-1] for j in adj[nb] }\n                avail = 0\n                for cc in range(1, current_k+1):\n                    if cc not in forb:\n                        avail += 1\n                pressure += avail\n            score = (loc_conf, current_k, -degree(i), -pressure)\n            if (best_score is None) or (score < best_score):\n                best_score = score\n                best_sol = trial\n        if best_sol is not None and best_sol != cur:\n            return (best_sol, \"ConflictRepair-Recolor\")\n        # Pairwise endpoint swap (try swapping colors of u and v)\n        trial = list(cur)\n        trial[u-1], trial[v-1] = trial[v-1], trial[u-1]\n        if count_conflicts(trial) <= len(conflicts)-1:\n            return (trial, \"ConflictRepair-Swap\")\n        # Kempe swap biased to neighbor color with most edges into the chain\n        palette = sorted({c for c in cur})\n        a = cur[i-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            # choose b that appears most among neighbors of i\n            freq = {b:0 for b in b_choices}\n            for nb in adj[i]:\n                cb = cur[nb-1]\n                if cb in freq:\n                    freq[cb] += 1\n            b = max(b_choices, key=lambda x: freq.get(x,0))\n            out = kempe_chain_swap(cur, i, a, b)\n            if out != cur:\n                return (out, \"ConflictRepair-Kempe\")\n        # Fallback diversify: rotate palette\n        out = [((c % k) + 1) for c in cur]\n        return (out, \"Diversify-Rotate\")\n\n    # No conflicts: attempt palette compaction\n    # 1) Color-class elimination for color k\n    max_class_vertices = [i+1 for i,c in enumerate(cur) if c == k]\n    if max_class_vertices:\n        # Try to reassign all k-colored vertices using DSATUR-like order\n        order = sorted(max_class_vertices, key=lambda v: (degree(v)), reverse=True)\n        trial = list(cur)\n        feasible_all = True\n        for v in order:\n            feas = [c for c in feasible_colors(v, k-1, trial)]\n            if not feas:\n                feasible_all = False\n                break\n            # choose least-constraining color\n            best_c = None\n            best_pressure = None\n            for ccol in feas:\n                temp = list(trial)\n                temp[v-1] = ccol\n                pressure = 0\n                for nb in adj[v]:\n                    forb = { temp[j-1] for j in adj[nb] }\n                    avail = 0\n                    for cc in range(1, k):\n                        if cc not in forb:\n                            avail += 1\n                    pressure += avail\n                if best_pressure is None or pressure > best_pressure:\n                    best_pressure = pressure\n                    best_c = ccol\n            trial[v-1] = best_c\n        if feasible_all:\n            # Lower palette by 1\n            new = [min(x, k-1) for x in trial]\n            return (new, \"Compaction-EliminateClass\")\n        # 2) Single-vertex lowering from color k\n        for v in sorted(max_class_vertices, key=lambda v: degree(v), reverse=True):\n            feas = [c for c in feasible_colors(v, k-1, cur)]\n            if feas:\n                # least constraining\n                best_c = None\n                best_pressure = None\n                for ccol in feas:\n                    temp = list(cur)\n                    temp[v-1] = ccol\n                    pressure = 0\n                    for nb in adj[v]:\n                        forb = { temp[j-1] for j in adj[nb] }\n                        avail = 0\n                        for cc in range(1, k):\n                            if cc not in forb:\n                                avail += 1\n                        pressure += avail\n                    if best_pressure is None or pressure > best_pressure:\n                        best_pressure = pressure\n                        best_c = ccol\n                out = list(cur)\n                out[v-1] = best_c\n                if out != cur:\n                    return (out, \"Compaction-LowerOne\")\n        # 3) Kempe swap between k and a lower color\n        lower_colors = [c for c in range(1, k) if c in cur]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            # attempt class swap to shake structure\n            out = [ (k if x==c2 else (c2 if x==k else x)) for x in cur ]\n            if out != cur:\n                return (out, \"Diversify-ClassSwap\")\n\n    # Diversification on feasible state: random Kempe swap\n    palette = sorted({c for c in cur})\n    if len(palette) >= 2:\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b = random.choice([c for c in palette if c != a])\n        out = kempe_chain_swap(cur, v0, a, b)\n        if out != cur:\n            return (out, \"Kempe-Diverse\")\n\n    # Final fallback: rotate colors to guarantee a change\n    k = max(cur) if cur else 1\n    out = [((c % k) + 1) for c in cur]\n    return (out, \"Diversify-Rotate\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors within current palette\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    if not cur:\n        return cur\n    k = max(cur)\n\n    # Parameters\n    num_swaps = 3\n    num_recolors = 4\n\n    # Perform Kempe swaps among random vertices\/colors\n    palette = sorted({c for c in cur})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        # bias: choose the color most frequent around v0\n        freq = {b:0 for b in b_choices}\n        for nb in adj[v0]:\n            cb = cur[nb-1]\n            if cb in freq:\n                freq[cb] += 1\n        b = max(b_choices, key=lambda x: freq.get(x,0))\n        cur = kempe_chain_swap(cur, v0, a, b)\n\n    # Selective recolors within current palette (avoid increasing k)\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        feas = feasible_colors(i, k, cur)\n        if feas:\n            # choose least-constraining among feasible\n            best_c = None\n            best_pressure = None\n            for ccol in feas:\n                temp = list(cur)\n                temp[i-1] = ccol\n                pressure = 0\n                for nb in adj[i]:\n                    forb = { temp[j-1] for j in adj[nb] }\n                    avail = 0\n                    for cc in range(1, k+1):\n                        if cc not in forb:\n                            avail += 1\n                    pressure += avail\n                if best_pressure is None or pressure > best_pressure:\n                    best_pressure = pressure\n                    best_c = ccol\n            if best_c is not None and cur[i-1] != best_c:\n                cur[i-1] = best_c\n        else:\n            # shake within palette (keep 1..k)\n            choices = [c for c in range(1, k+1) if c != cur[i-1]]\n            if choices:\n                cur[i-1] = random.choice(choices)\n\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001464496}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Penalties\n    PEN_BAD_TYPE_LEN = 10**8\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized; plus invalidity penalties\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def degree(v):\n        return len(adj[v])\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    if not cur:\n        return (cur, \"NoOp\")\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = [(u,v) for (u,v) in E if cur[u-1] == cur[v-1]]\n\n    if conflicts:\n        # Conflict repair: choose conflict endpoint with higher degree\n        (u,v) = random.choice(conflicts)\n        i = u if degree(u) >= degree(v) else v\n        # Evaluate recolors within 1..k using least-constraining heuristic\n        best_sol = None\n        best_score = None\n        current_k = k\n        for c in range(1, current_k+1):\n            if c == cur[i-1]:\n                continue\n            trial = list(cur)\n            trial[i-1] = c\n            # local conflicts and k-after (avoid palette growth)\n            loc_conf = 0\n            for nb in adj[i]:\n                if trial[nb-1] == trial[i-1]:\n                    loc_conf += 1\n            # estimate future pressure: sum of available colors for neighbors (higher is better)\n            pressure = 0\n            for nb in adj[i]:\n                forb = { trial[j-1] for j in adj[nb] }\n                avail = 0\n                for cc in range(1, current_k+1):\n                    if cc not in forb:\n                        avail += 1\n                pressure += avail\n            score = (loc_conf, current_k, -degree(i), -pressure)\n            if (best_score is None) or (score < best_score):\n                best_score = score\n                best_sol = trial\n        if best_sol is not None and best_sol != cur:\n            return (best_sol, \"ConflictRepair-Recolor\")\n        # Pairwise endpoint swap (try swapping colors of u and v)\n        trial = list(cur)\n        trial[u-1], trial[v-1] = trial[v-1], trial[u-1]\n        if count_conflicts(trial) <= len(conflicts)-1:\n            return (trial, \"ConflictRepair-Swap\")\n        # Kempe swap biased to neighbor color with most edges into the chain\n        palette = sorted({c for c in cur})\n        a = cur[i-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            # choose b that appears most among neighbors of i\n            freq = {b:0 for b in b_choices}\n            for nb in adj[i]:\n                cb = cur[nb-1]\n                if cb in freq:\n                    freq[cb] += 1\n            b = max(b_choices, key=lambda x: freq.get(x,0))\n            out = kempe_chain_swap(cur, i, a, b)\n            if out != cur:\n                return (out, \"ConflictRepair-Kempe\")\n        # Fallback diversify: rotate palette\n        out = [((c % k) + 1) for c in cur]\n        return (out, \"Diversify-Rotate\")\n\n    # No conflicts: attempt palette compaction\n    # 1) Color-class elimination for color k\n    max_class_vertices = [i+1 for i,c in enumerate(cur) if c == k]\n    if max_class_vertices:\n        # Try to reassign all k-colored vertices using DSATUR-like order\n        order = sorted(max_class_vertices, key=lambda v: (degree(v)), reverse=True)\n        trial = list(cur)\n        feasible_all = True\n        for v in order:\n            feas = [c for c in feasible_colors(v, k-1, trial)]\n            if not feas:\n                feasible_all = False\n                break\n            # choose least-constraining color\n            best_c = None\n            best_pressure = None\n            for ccol in feas:\n                temp = list(trial)\n                temp[v-1] = ccol\n                pressure = 0\n                for nb in adj[v]:\n                    forb = { temp[j-1] for j in adj[nb] }\n                    avail = 0\n                    for cc in range(1, k):\n                        if cc not in forb:\n                            avail += 1\n                    pressure += avail\n                if best_pressure is None or pressure > best_pressure:\n                    best_pressure = pressure\n                    best_c = ccol\n            trial[v-1] = best_c\n        if feasible_all:\n            # Lower palette by 1\n            new = [min(x, k-1) for x in trial]\n            return (new, \"Compaction-EliminateClass\")\n        # 2) Single-vertex lowering from color k\n        for v in sorted(max_class_vertices, key=lambda v: degree(v), reverse=True):\n            feas = [c for c in feasible_colors(v, k-1, cur)]\n            if feas:\n                # least constraining\n                best_c = None\n                best_pressure = None\n                for ccol in feas:\n                    temp = list(cur)\n                    temp[v-1] = ccol\n                    pressure = 0\n                    for nb in adj[v]:\n                        forb = { temp[j-1] for j in adj[nb] }\n                        avail = 0\n                        for cc in range(1, k):\n                            if cc not in forb:\n                                avail += 1\n                        pressure += avail\n                    if best_pressure is None or pressure > best_pressure:\n                        best_pressure = pressure\n                        best_c = ccol\n                out = list(cur)\n                out[v-1] = best_c\n                if out != cur:\n                    return (out, \"Compaction-LowerOne\")\n        # 3) Kempe swap between k and a lower color\n        lower_colors = [c for c in range(1, k) if c in cur]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            # attempt class swap to shake structure\n            out = [ (k if x==c2 else (c2 if x==k else x)) for x in cur ]\n            if out != cur:\n                return (out, \"Diversify-ClassSwap\")\n\n    # Diversification on feasible state: random Kempe swap\n    palette = sorted({c for c in cur})\n    if len(palette) >= 2:\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b = random.choice([c for c in palette if c != a])\n        out = kempe_chain_swap(cur, v0, a, b)\n        if out != cur:\n            return (out, \"Kempe-Diverse\")\n\n    # Final fallback: rotate colors to guarantee a change\n    k = max(cur) if cur else 1\n    out = [((c % k) + 1) for c in cur]\n    return (out, \"Diversify-Rotate\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors within current palette\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    if not cur:\n        return cur\n    k = max(cur)\n\n    # Parameters\n    num_swaps = 3\n    num_recolors = 4\n\n    # Perform Kempe swaps among random vertices\/colors\n    palette = sorted({c for c in cur})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        # bias: choose the color most frequent around v0\n        freq = {b:0 for b in b_choices}\n        for nb in adj[v0]:\n            cb = cur[nb-1]\n            if cb in freq:\n                freq[cb] += 1\n        b = max(b_choices, key=lambda x: freq.get(x,0))\n        cur = kempe_chain_swap(cur, v0, a, b)\n\n    # Selective recolors within current palette (avoid increasing k)\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        feas = feasible_colors(i, k, cur)\n        if feas:\n            # choose least-constraining among feasible\n            best_c = None\n            best_pressure = None\n            for ccol in feas:\n                temp = list(cur)\n                temp[i-1] = ccol\n                pressure = 0\n                for nb in adj[i]:\n                    forb = { temp[j-1] for j in adj[nb] }\n                    avail = 0\n                    for cc in range(1, k+1):\n                        if cc not in forb:\n                            avail += 1\n                    pressure += avail\n                if best_pressure is None or pressure > best_pressure:\n                    best_pressure = pressure\n                    best_c = ccol\n            if best_c is not None and cur[i-1] != best_c:\n                cur[i-1] = best_c\n        else:\n            # shake within palette (keep 1..k)\n            choices = [c for c in range(1, k+1) if c != cur[i-1]]\n            if choices:\n                cur[i-1] = random.choice(choices)\n\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001676969}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_taekwondo_tournament_standard","Representacion":"LIST_INT_9_COLORS_INDEXED_FROM_1_TO_k","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Graph definition (undirected edges with u<v)\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    # Penalties\n    PEN_BAD_TYPE_LEN = 10**8\n    PEN_INVALID_VALUE = 10**7\n    PEN_RANGE = 10**6\n    PEN_CONFLICT = 10**5\n\n    # Validate container and length\n    if not isinstance(solution, list) or len(solution) != n:\n        bad_len = 0 if not isinstance(solution, list) else abs(len(solution) - n)\n        return PEN_BAD_TYPE_LEN + bad_len * PEN_INVALID_VALUE\n\n    # Validate element types\n    penalty = 0\n    for v in solution:\n        if not isinstance(v, int):\n            penalty += PEN_INVALID_VALUE\n    if penalty:\n        return PEN_BAD_TYPE_LEN + penalty\n\n    # Compute k and validate\n    if len(solution) == 0:\n        return PEN_BAD_TYPE_LEN\n    k = max(solution)\n    if k <= 0:\n        return PEN_BAD_TYPE_LEN\n\n    for v in solution:\n        if v < 1 or v > k:\n            penalty += PEN_RANGE\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized; plus invalidity penalties\n    return k + conflicts * PEN_CONFLICT + penalty\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(colors):\n        c = 0\n        for (u,v) in E:\n            if colors[u-1] == colors[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    def degree(v):\n        return len(adj[v])\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    if not cur:\n        return (cur, \"NoOp\")\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = [(u,v) for (u,v) in E if cur[u-1] == cur[v-1]]\n\n    if conflicts:\n        # Conflict repair: choose conflict endpoint with higher degree\n        (u,v) = random.choice(conflicts)\n        i = u if degree(u) >= degree(v) else v\n        # Evaluate recolors within 1..k using least-constraining heuristic\n        best_sol = None\n        best_score = None\n        current_k = k\n        for c in range(1, current_k+1):\n            if c == cur[i-1]:\n                continue\n            trial = list(cur)\n            trial[i-1] = c\n            # local conflicts and k-after (avoid palette growth)\n            loc_conf = 0\n            for nb in adj[i]:\n                if trial[nb-1] == trial[i-1]:\n                    loc_conf += 1\n            # estimate future pressure: sum of available colors for neighbors (higher is better)\n            pressure = 0\n            for nb in adj[i]:\n                forb = { trial[j-1] for j in adj[nb] }\n                avail = 0\n                for cc in range(1, current_k+1):\n                    if cc not in forb:\n                        avail += 1\n                pressure += avail\n            score = (loc_conf, current_k, -degree(i), -pressure)\n            if (best_score is None) or (score < best_score):\n                best_score = score\n                best_sol = trial\n        if best_sol is not None and best_sol != cur:\n            return (best_sol, \"ConflictRepair-Recolor\")\n        # Pairwise endpoint swap (try swapping colors of u and v)\n        trial = list(cur)\n        trial[u-1], trial[v-1] = trial[v-1], trial[u-1]\n        if count_conflicts(trial) <= len(conflicts)-1:\n            return (trial, \"ConflictRepair-Swap\")\n        # Kempe swap biased to neighbor color with most edges into the chain\n        palette = sorted({c for c in cur})\n        a = cur[i-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            # choose b that appears most among neighbors of i\n            freq = {b:0 for b in b_choices}\n            for nb in adj[i]:\n                cb = cur[nb-1]\n                if cb in freq:\n                    freq[cb] += 1\n            b = max(b_choices, key=lambda x: freq.get(x,0))\n            out = kempe_chain_swap(cur, i, a, b)\n            if out != cur:\n                return (out, \"ConflictRepair-Kempe\")\n        # Fallback diversify: rotate palette\n        out = [((c % k) + 1) for c in cur]\n        return (out, \"Diversify-Rotate\")\n\n    # No conflicts: attempt palette compaction\n    # 1) Color-class elimination for color k\n    max_class_vertices = [i+1 for i,c in enumerate(cur) if c == k]\n    if max_class_vertices:\n        # Try to reassign all k-colored vertices using DSATUR-like order\n        order = sorted(max_class_vertices, key=lambda v: (degree(v)), reverse=True)\n        trial = list(cur)\n        feasible_all = True\n        for v in order:\n            feas = [c for c in feasible_colors(v, k-1, trial)]\n            if not feas:\n                feasible_all = False\n                break\n            # choose least-constraining color\n            best_c = None\n            best_pressure = None\n            for ccol in feas:\n                temp = list(trial)\n                temp[v-1] = ccol\n                pressure = 0\n                for nb in adj[v]:\n                    forb = { temp[j-1] for j in adj[nb] }\n                    avail = 0\n                    for cc in range(1, k):\n                        if cc not in forb:\n                            avail += 1\n                    pressure += avail\n                if best_pressure is None or pressure > best_pressure:\n                    best_pressure = pressure\n                    best_c = ccol\n            trial[v-1] = best_c\n        if feasible_all:\n            # Lower palette by 1\n            new = [min(x, k-1) for x in trial]\n            return (new, \"Compaction-EliminateClass\")\n        # 2) Single-vertex lowering from color k\n        for v in sorted(max_class_vertices, key=lambda v: degree(v), reverse=True):\n            feas = [c for c in feasible_colors(v, k-1, cur)]\n            if feas:\n                # least constraining\n                best_c = None\n                best_pressure = None\n                for ccol in feas:\n                    temp = list(cur)\n                    temp[v-1] = ccol\n                    pressure = 0\n                    for nb in adj[v]:\n                        forb = { temp[j-1] for j in adj[nb] }\n                        avail = 0\n                        for cc in range(1, k):\n                            if cc not in forb:\n                                avail += 1\n                        pressure += avail\n                    if best_pressure is None or pressure > best_pressure:\n                        best_pressure = pressure\n                        best_c = ccol\n                out = list(cur)\n                out[v-1] = best_c\n                if out != cur:\n                    return (out, \"Compaction-LowerOne\")\n        # 3) Kempe swap between k and a lower color\n        lower_colors = [c for c in range(1, k) if c in cur]\n        if lower_colors:\n            c2 = random.choice(lower_colors)\n            # attempt class swap to shake structure\n            out = [ (k if x==c2 else (c2 if x==k else x)) for x in cur ]\n            if out != cur:\n                return (out, \"Diversify-ClassSwap\")\n\n    # Diversification on feasible state: random Kempe swap\n    palette = sorted({c for c in cur})\n    if len(palette) >= 2:\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b = random.choice([c for c in palette if c != a])\n        out = kempe_chain_swap(cur, v0, a, b)\n        if out != cur:\n            return (out, \"Kempe-Diverse\")\n\n    # Final fallback: rotate colors to guarantee a change\n    k = max(cur) if cur else 1\n    out = [((c % k) + 1) for c in cur]\n    return (out, \"Diversify-Rotate\")\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but safe perturbation using multiple Kempe-chain swaps and selective recolors within current palette\n    cur = list(solution)\n    n = 9\n    E = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    adj = {i+1: [] for i in range(n)}\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(colors, start_v, a, b):\n        out = list(colors)\n        stack = [start_v]\n        visited = set()\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if out[v-1] not in (a, b):\n                continue\n            visited.add(v)\n            for w in adj[v]:\n                if out[w-1] in (a, b) and w not in visited:\n                    stack.append(w)\n        for v in visited:\n            out[v-1] = a if out[v-1] == b else b\n        return out\n\n    def feasible_colors(vertex, k_now, colors):\n        forb = { colors[j-1] for j in adj[vertex] }\n        return [c for c in range(1, k_now+1) if c not in forb]\n\n    if not cur:\n        return cur\n    k = max(cur)\n\n    # Parameters\n    num_swaps = 3\n    num_recolors = 4\n\n    # Perform Kempe swaps among random vertices\/colors\n    palette = sorted({c for c in cur})\n    for _ in range(num_swaps):\n        v0 = random.randint(1, n)\n        a = cur[v0-1]\n        b_choices = [c for c in palette if c != a]\n        if not b_choices:\n            continue\n        # bias: choose the color most frequent around v0\n        freq = {b:0 for b in b_choices}\n        for nb in adj[v0]:\n            cb = cur[nb-1]\n            if cb in freq:\n                freq[cb] += 1\n        b = max(b_choices, key=lambda x: freq.get(x,0))\n        cur = kempe_chain_swap(cur, v0, a, b)\n\n    # Selective recolors within current palette (avoid increasing k)\n    for _ in range(num_recolors):\n        i = random.randint(1, n)\n        feas = feasible_colors(i, k, cur)\n        if feas:\n            # choose least-constraining among feasible\n            best_c = None\n            best_pressure = None\n            for ccol in feas:\n                temp = list(cur)\n                temp[i-1] = ccol\n                pressure = 0\n                for nb in adj[i]:\n                    forb = { temp[j-1] for j in adj[nb] }\n                    avail = 0\n                    for cc in range(1, k+1):\n                        if cc not in forb:\n                            avail += 1\n                    pressure += avail\n                if best_pressure is None or pressure > best_pressure:\n                    best_pressure = pressure\n                    best_c = ccol\n            if best_c is not None and cur[i-1] != best_c:\n                cur[i-1] = best_c\n        else:\n            # shake within palette (keep 1..k)\n            choices = [c for c in range(1, k+1) if c != cur[i-1]]\n            if choices:\n                cur[i-1] = random.choice(choices)\n\n    return cur\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001563658}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLORS. Solution is a list of 9 positive integers [c1..c9] with colors exactly {1..k} contiguous, where ci is color of vertex i (1-indexed).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (undirected) embedded\n    edges = [(1,4),(1,5),(1,8),\n             (2,3),(2,5),(2,9),\n             (3,6),(3,8),(3,9),\n             (4,7),(4,8),(4,9),\n             (6,7),(6,8),\n             (7,8)]\n    n = 9\n    HARD_PENALTY = 10**9\n    CONFLICT_PENALTY = 10**3\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n    # Validate and compute k\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n    if any(x < 1 for x in colors):\n        return HARD_PENALTY\n    k = max(colors) if colors else HARD_PENALTY\n    # Contiguity check: colors must be exactly {1..k}\n    used = set(colors)\n    if used != set(range(1, k + 1)):\n        # Penalize non-contiguous or missing labels but keep guidance via conflicts\n        conflicts = 0\n        for (u, v) in edges:\n            if colors[u - 1] == colors[v - 1]:\n                conflicts += 1\n        gap_pen = k * CONFLICT_PENALTY\n        return HARD_PENALTY + gap_pen + conflicts * CONFLICT_PENALTY + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n    if conflicts == 0:\n        # Feasible: objective is number of colors (minimize)\n        return k\n    # Infeasible: penalize conflicts + tie-break by k\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous(colors: List[int]) -> List[int]:\n    # Map existing labels to 1..m in order of first appearance\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        return list(solution), \"Invalid\", \"NoOp\"\n    sol = [int(max(1, x)) for x in solution]\n    n = len(sol)\n    k = max(sol)\n    i = random.randrange(n)\n    # Pick a new color in {1..k+1} different from current\n    new_color_choices = list(range(1, k + 2))\n    if sol[i] in new_color_choices:\n        new_color_choices.remove(sol[i])\n    if not new_color_choices:\n        return sol[:], \"Recolor\", \"SingleVertex\"\n    sol[i] = random.choice(new_color_choices)\n    sol = _relabel_contiguous(sol)\n    return sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + possible merge\/split + label shuffle\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        return list(solution)\n    sol = [int(max(1, x)) for x in solution]\n    n = len(sol)\n    k = max(sol)\n    steps = max(2, n \/\/ 3)\n    # Multiple random recolors\n    for _ in range(steps):\n        i = random.randrange(n)\n        new_color = random.randint(1, max(2, k + 1))\n        sol[i] = new_color\n    # With probability, merge two random color labels (if k>=2)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b into a\n        sol = [a if c == b else c for c in sol]\n    # With probability, split a color into a new label\n    k = max(sol)\n    if random.random() < 0.5:\n        chosen = random.randint(1, k)\n        indices = [i for i, c in enumerate(sol) if c == chosen]\n        if len(indices) >= 2:\n            subset = set(random.sample(indices, len(indices) \/\/ 2))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n    # Randomly shuffle labels (renaming) to diversify\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n    # Finally, relabel to ensure contiguity\n    sol = _relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000569367}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLORS. Solution is a list of 9 positive integers [c1..c9] with colors exactly {1..k} contiguous, where ci is color of vertex i (1-indexed).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (undirected) embedded\n    edges = [(1,4),(1,5),(1,8),\n             (2,3),(2,5),(2,9),\n             (3,6),(3,8),(3,9),\n             (4,7),(4,8),(4,9),\n             (6,7),(6,8),\n             (7,8)]\n    n = 9\n    HARD_PENALTY = 10**9\n    CONFLICT_PENALTY = 10**3\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n    # Validate and compute k\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n    if any(x < 1 for x in colors):\n        return HARD_PENALTY\n    k = max(colors) if colors else HARD_PENALTY\n    # Contiguity check: colors must be exactly {1..k}\n    used = set(colors)\n    if used != set(range(1, k + 1)):\n        # Penalize non-contiguous or missing labels but keep guidance via conflicts\n        conflicts = 0\n        for (u, v) in edges:\n            if colors[u - 1] == colors[v - 1]:\n                conflicts += 1\n        gap_pen = k * CONFLICT_PENALTY\n        return HARD_PENALTY + gap_pen + conflicts * CONFLICT_PENALTY + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n    if conflicts == 0:\n        # Feasible: objective is number of colors (minimize)\n        return k\n    # Infeasible: penalize conflicts + tie-break by k\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous(colors: List[int]) -> List[int]:\n    # Map existing labels to 1..m in order of first appearance\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        return list(solution), \"Invalid\", \"NoOp\"\n    sol = [int(max(1, x)) for x in solution]\n    n = len(sol)\n    k = max(sol)\n    i = random.randrange(n)\n    # Pick a new color in {1..k+1} different from current\n    new_color_choices = list(range(1, k + 2))\n    if sol[i] in new_color_choices:\n        new_color_choices.remove(sol[i])\n    if not new_color_choices:\n        return sol[:], \"Recolor\", \"SingleVertex\"\n    sol[i] = random.choice(new_color_choices)\n    sol = _relabel_contiguous(sol)\n    return sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + possible merge\/split + label shuffle\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        return list(solution)\n    sol = [int(max(1, x)) for x in solution]\n    n = len(sol)\n    k = max(sol)\n    steps = max(2, n \/\/ 3)\n    # Multiple random recolors\n    for _ in range(steps):\n        i = random.randrange(n)\n        new_color = random.randint(1, max(2, k + 1))\n        sol[i] = new_color\n    # With probability, merge two random color labels (if k>=2)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b into a\n        sol = [a if c == b else c for c in sol]\n    # With probability, split a color into a new label\n    k = max(sol)\n    if random.random() < 0.5:\n        chosen = random.randint(1, k)\n        indices = [i for i, c in enumerate(sol) if c == chosen]\n        if len(indices) >= 2:\n            subset = set(random.sample(indices, len(indices) \/\/ 2))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n    # Randomly shuffle labels (renaming) to diversify\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n    # Finally, relabel to ensure contiguity\n    sol = _relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.000768889}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN_9_CONTIGUOUS_COLORS. Solution is a list of 9 positive integers [c1..c9] with colors exactly {1..k} contiguous, where ci is color of vertex i (1-indexed).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (undirected) embedded\n    edges = [(1,4),(1,5),(1,8),\n             (2,3),(2,5),(2,9),\n             (3,6),(3,8),(3,9),\n             (4,7),(4,8),(4,9),\n             (6,7),(6,8),\n             (7,8)]\n    n = 9\n    HARD_PENALTY = 10**9\n    CONFLICT_PENALTY = 10**3\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n    # Validate and compute k\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n    if any(x < 1 for x in colors):\n        return HARD_PENALTY\n    k = max(colors) if colors else HARD_PENALTY\n    # Contiguity check: colors must be exactly {1..k}\n    used = set(colors)\n    if used != set(range(1, k + 1)):\n        # Penalize non-contiguous or missing labels but keep guidance via conflicts\n        conflicts = 0\n        for (u, v) in edges:\n            if colors[u - 1] == colors[v - 1]:\n                conflicts += 1\n        gap_pen = k * CONFLICT_PENALTY\n        return HARD_PENALTY + gap_pen + conflicts * CONFLICT_PENALTY + k\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n    if conflicts == 0:\n        # Feasible: objective is number of colors (minimize)\n        return k\n    # Infeasible: penalize conflicts + tie-break by k\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + k\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous(colors: List[int]) -> List[int]:\n    # Map existing labels to 1..m in order of first appearance\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        return list(solution), \"Invalid\", \"NoOp\"\n    sol = [int(max(1, x)) for x in solution]\n    n = len(sol)\n    k = max(sol)\n    i = random.randrange(n)\n    # Pick a new color in {1..k+1} different from current\n    new_color_choices = list(range(1, k + 2))\n    if sol[i] in new_color_choices:\n        new_color_choices.remove(sol[i])\n    if not new_color_choices:\n        return sol[:], \"Recolor\", \"SingleVertex\"\n    sol[i] = random.choice(new_color_choices)\n    sol = _relabel_contiguous(sol)\n    return sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple recolors + possible merge\/split + label shuffle\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        return list(solution)\n    sol = [int(max(1, x)) for x in solution]\n    n = len(sol)\n    k = max(sol)\n    steps = max(2, n \/\/ 3)\n    # Multiple random recolors\n    for _ in range(steps):\n        i = random.randrange(n)\n        new_color = random.randint(1, max(2, k + 1))\n        sol[i] = new_color\n    # With probability, merge two random color labels (if k>=2)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b into a\n        sol = [a if c == b else c for c in sol]\n    # With probability, split a color into a new label\n    k = max(sol)\n    if random.random() < 0.5:\n        chosen = random.randint(1, k)\n        indices = [i for i, c in enumerate(sol) if c == chosen]\n        if len(indices) >= 2:\n            subset = set(random.sample(indices, len(indices) \/\/ 2))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n    # Randomly shuffle labels (renaming) to diversify\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n    # Finally, relabel to ensure contiguity\n    sol = _relabel_contiguous(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.0007495779}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"List[int] of length 9 where index i-1 stores color of vertex i. Colors are positive integers relabeled to be exactly {1..k} contiguous.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Graph definition (undirected) embedded\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    HARD_PENALTY = 10**9\n    CONFLICT_PENALTY = 10**3\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    # Normalize and validate\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n    # Ensure positivity then relabel to contiguous {1..k}\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        # Feasible: objective is number of colors (minimize)\n        return k\n\n    # Infeasible: lexicographic penalty (conflicts first, then k)\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _conflicted_vertices(solution: List[int]) -> List[int]:\n    # Embedded graph\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = len(solution)\n    conflicts = [0]*n\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n    return [i for i,c in enumerate(conflicts) if c > 0]\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Always return (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            base = list(solution)\n        except Exception:\n            base = []\n        return base, \"Invalid\", \"NoOp\"\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_nb(sol)\n    n = len(sol)\n    k = max(sol)\n\n    conflicted = _conflicted_vertices(sol)\n\n    # Pick vertex: prioritize conflicts, else random\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        i = random.randrange(n)\n\n    # Candidate colors: prefer existing colors first, then optionally k+1\n    candidate_colors = list(range(1, k+1))\n    if random.random() < 0.25:\n        candidate_colors.append(k+1)\n    if sol[i] in candidate_colors:\n        candidate_colors.remove(sol[i])\n    if not candidate_colors:\n        return sol[:], \"Recolor\", \"SingleVertex\"\n\n    # Try a color that reduces local conflicts if possible\n    # Compute local conflicts per color\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    neighbors = []\n    vi = i+1\n    for (u,v) in edges:\n        if u == vi:\n            neighbors.append(v-1)\n        elif v == vi:\n            neighbors.append(u-1)\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in neighbors:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    if best_colors:\n        new_color = random.choice(best_colors)\n    else:\n        new_color = random.choice(candidate_colors)\n\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n\n    # Occasionally perform a small Kempe-like swap between two colors in the neighborhood\n    if random.random() < 0.1 and k >= 2:\n        colors_present = sorted(set(new_sol))\n        if len(colors_present) >= 2:\n            a, b = random.sample(colors_present, 2)\n            # Swap a and b on a small random subset around i\n            scope = set([i])\n            # include immediate neighbors\n            for j in neighbors:\n                scope.add(j)\n            # apply swap on scope only\n            for idx in scope:\n                if new_sol[idx] == a:\n                    new_sol[idx] = b\n                elif new_sol[idx] == b:\n                    new_sol[idx] = a\n            new_sol = _relabel_contiguous_nb(new_sol)\n\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            return list(solution)\n        except Exception:\n            return []\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_pert(sol)\n\n    n = len(sol)\n    k = max(sol)\n\n    steps = max(2, n \/\/ 3)\n    # Multiple random recolors across the solution\n    for _ in range(steps):\n        i = random.randrange(n)\n        # choose among existing colors and occasionally a new color k+1\n        choices = list(range(1, max(2, k + 1)))\n        if random.random() < 0.4:\n            choices.append(k + 1)\n        if sol[i] in choices and len(choices) > 1:\n            choices.remove(sol[i])\n        sol[i] = random.choice(choices)\n\n    # Random merge of two color classes\n    k = max(sol)\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n\n    # Random split of a color class\n    k = max(sol)\n    if random.random() < 0.6:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n\n    # Random label permutation to escape symmetry\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.000939871}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"List[int] of length 9 where index i-1 stores color of vertex i. Colors are positive integers relabeled to be exactly {1..k} contiguous.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Graph definition (undirected) embedded\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    HARD_PENALTY = 10**9\n    CONFLICT_PENALTY = 10**3\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    # Normalize and validate\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n    # Ensure positivity then relabel to contiguous {1..k}\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        # Feasible: objective is number of colors (minimize)\n        return k\n\n    # Infeasible: lexicographic penalty (conflicts first, then k)\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _conflicted_vertices(solution: List[int]) -> List[int]:\n    # Embedded graph\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = len(solution)\n    conflicts = [0]*n\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n    return [i for i,c in enumerate(conflicts) if c > 0]\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Always return (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            base = list(solution)\n        except Exception:\n            base = []\n        return base, \"Invalid\", \"NoOp\"\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_nb(sol)\n    n = len(sol)\n    k = max(sol)\n\n    conflicted = _conflicted_vertices(sol)\n\n    # Pick vertex: prioritize conflicts, else random\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        i = random.randrange(n)\n\n    # Candidate colors: prefer existing colors first, then optionally k+1\n    candidate_colors = list(range(1, k+1))\n    if random.random() < 0.25:\n        candidate_colors.append(k+1)\n    if sol[i] in candidate_colors:\n        candidate_colors.remove(sol[i])\n    if not candidate_colors:\n        return sol[:], \"Recolor\", \"SingleVertex\"\n\n    # Try a color that reduces local conflicts if possible\n    # Compute local conflicts per color\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    neighbors = []\n    vi = i+1\n    for (u,v) in edges:\n        if u == vi:\n            neighbors.append(v-1)\n        elif v == vi:\n            neighbors.append(u-1)\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in neighbors:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    if best_colors:\n        new_color = random.choice(best_colors)\n    else:\n        new_color = random.choice(candidate_colors)\n\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n\n    # Occasionally perform a small Kempe-like swap between two colors in the neighborhood\n    if random.random() < 0.1 and k >= 2:\n        colors_present = sorted(set(new_sol))\n        if len(colors_present) >= 2:\n            a, b = random.sample(colors_present, 2)\n            # Swap a and b on a small random subset around i\n            scope = set([i])\n            # include immediate neighbors\n            for j in neighbors:\n                scope.add(j)\n            # apply swap on scope only\n            for idx in scope:\n                if new_sol[idx] == a:\n                    new_sol[idx] = b\n                elif new_sol[idx] == b:\n                    new_sol[idx] = a\n            new_sol = _relabel_contiguous_nb(new_sol)\n\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            return list(solution)\n        except Exception:\n            return []\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_pert(sol)\n\n    n = len(sol)\n    k = max(sol)\n\n    steps = max(2, n \/\/ 3)\n    # Multiple random recolors across the solution\n    for _ in range(steps):\n        i = random.randrange(n)\n        # choose among existing colors and occasionally a new color k+1\n        choices = list(range(1, max(2, k + 1)))\n        if random.random() < 0.4:\n            choices.append(k + 1)\n        if sol[i] in choices and len(choices) > 1:\n            choices.remove(sol[i])\n        sol[i] = random.choice(choices)\n\n    # Random merge of two color classes\n    k = max(sol)\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n\n    # Random split of a color class\n    k = max(sol)\n    if random.random() < 0.6:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n\n    # Random label permutation to escape symmetry\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001166153}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"List[int] of length 9 where index i-1 stores color of vertex i. Colors are positive integers relabeled to be exactly {1..k} contiguous.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Graph definition (undirected) embedded\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = 9\n    HARD_PENALTY = 10**9\n    CONFLICT_PENALTY = 10**3\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    # Normalize and validate\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n    # Ensure positivity then relabel to contiguous {1..k}\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        # Feasible: objective is number of colors (minimize)\n        return k\n\n    # Infeasible: lexicographic penalty (conflicts first, then k)\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _conflicted_vertices(solution: List[int]) -> List[int]:\n    # Embedded graph\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    n = len(solution)\n    conflicts = [0]*n\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n    return [i for i,c in enumerate(conflicts) if c > 0]\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Always return (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            base = list(solution)\n        except Exception:\n            base = []\n        return base, \"Invalid\", \"NoOp\"\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_nb(sol)\n    n = len(sol)\n    k = max(sol)\n\n    conflicted = _conflicted_vertices(sol)\n\n    # Pick vertex: prioritize conflicts, else random\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        i = random.randrange(n)\n\n    # Candidate colors: prefer existing colors first, then optionally k+1\n    candidate_colors = list(range(1, k+1))\n    if random.random() < 0.25:\n        candidate_colors.append(k+1)\n    if sol[i] in candidate_colors:\n        candidate_colors.remove(sol[i])\n    if not candidate_colors:\n        return sol[:], \"Recolor\", \"SingleVertex\"\n\n    # Try a color that reduces local conflicts if possible\n    # Compute local conflicts per color\n    edges = [\n        (1,4),(1,5),(1,8),\n        (2,3),(2,5),(2,9),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (7,8)\n    ]\n    neighbors = []\n    vi = i+1\n    for (u,v) in edges:\n        if u == vi:\n            neighbors.append(v-1)\n        elif v == vi:\n            neighbors.append(u-1)\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in neighbors:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    if best_colors:\n        new_color = random.choice(best_colors)\n    else:\n        new_color = random.choice(candidate_colors)\n\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n\n    # Occasionally perform a small Kempe-like swap between two colors in the neighborhood\n    if random.random() < 0.1 and k >= 2:\n        colors_present = sorted(set(new_sol))\n        if len(colors_present) >= 2:\n            a, b = random.sample(colors_present, 2)\n            # Swap a and b on a small random subset around i\n            scope = set([i])\n            # include immediate neighbors\n            for j in neighbors:\n                scope.add(j)\n            # apply swap on scope only\n            for idx in scope:\n                if new_sol[idx] == a:\n                    new_sol[idx] = b\n                elif new_sol[idx] == b:\n                    new_sol[idx] = a\n            new_sol = _relabel_contiguous_nb(new_sol)\n\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            return list(solution)\n        except Exception:\n            return []\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_pert(sol)\n\n    n = len(sol)\n    k = max(sol)\n\n    steps = max(2, n \/\/ 3)\n    # Multiple random recolors across the solution\n    for _ in range(steps):\n        i = random.randrange(n)\n        # choose among existing colors and occasionally a new color k+1\n        choices = list(range(1, max(2, k + 1)))\n        if random.random() < 0.4:\n            choices.append(k + 1)\n        if sol[i] in choices and len(choices) > 1:\n            choices.remove(sol[i])\n        sol[i] = random.choice(choices)\n\n    # Random merge of two color classes\n    k = max(sol)\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n\n    # Random split of a color class\n    k = max(sol)\n    if random.random() < 0.6:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n\n    # Random label permutation to escape symmetry\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001119383}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Embedded undirected graph\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n    HARD_PENALTY = 10 ** 9\n    CONFLICT_PENALTY = 10 ** 3\n\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return k\n\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _build_adj(n: int, edges: List[Tuple[int, int]]):\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflict_info(sol: List[int], edges: List[Tuple[int, int]], adj: List[List[int]]):\n    n = len(sol)\n    conflict_deg = [0] * n\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_deg[u - 1] += 1\n            conflict_deg[v - 1] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_deg) if c > 0]\n    # Saturation degree: number of distinct neighbor colors\n    sat = []\n    for i in range(n):\n        nb_colors = set(sol[j] for j in adj[i])\n        sat.append(len(nb_colors))\n    return conflicted_vertices, conflict_deg, sat\n\n\ndef _kempe_chain_flip(sol: List[int], adj: List[List[int]], start_idx: int, color_a: int, color_b: int) -> List[int]:\n    # BFS on subgraph induced by colors {a,b} from start_idx, then swap a<->b on that component\n    n = len(sol)\n    seen = [False] * n\n    stack = [start_idx]\n    seen[start_idx] = True\n    component = []\n    allowed = {color_a, color_b}\n    while stack:\n        i = stack.pop()\n        if sol[i] not in allowed:\n            continue\n        component.append(i)\n        for j in adj[i]:\n            if not seen[j] and sol[j] in allowed:\n                seen[j] = True\n                stack.append(j)\n    new_sol = sol[:]\n    for i in component:\n        if new_sol[i] == color_a:\n            new_sol[i] = color_b\n        elif new_sol[i] == color_b:\n            new_sol[i] = color_a\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            base = list(solution)\n        except Exception:\n            base = []\n        return base, \"Invalid\", \"NoOp\"\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_nb(sol)\n    n = len(sol)\n    k = max(sol)\n\n    adj = _build_adj(n, edges)\n    conflicted, conflict_deg, sat = _conflict_info(sol, edges, adj)\n\n    if conflicted:\n        # Pick most conflicted; tie-break by higher saturation then degree\n        candidates = conflicted\n        best = None\n        best_key = None\n        for i in candidates:\n            key = (conflict_deg[i], sat[i], len(adj[i]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n    else:\n        # No conflicts: choose a vertex with highest saturation to try reducing k\n        best = None\n        best_key = None\n        for i in range(n):\n            key = (sat[i], len(adj[i]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n\n    # With small probability perform a Kempe-chain flip between two colors\n    if k >= 2 and random.random() < 0.15:\n        colors_present = sorted(set(sol))\n        a, b = random.sample(colors_present, 2)\n        new_sol = _kempe_chain_flip(sol, adj, i, a, b)\n        new_sol = _relabel_contiguous_nb(new_sol)\n        return new_sol, \"KempeSwap\", \"TwoColorComponent\"\n\n    # Recolor single vertex i\n    # Prefer existing colors; occasionally allow k+1 to escape\n    candidate_colors = list(range(1, k + 1))\n    if random.random() < 0.2:\n        candidate_colors.append(k + 1)\n    cur = sol[i]\n    if cur in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(cur)\n\n    # Evaluate local conflicts per candidate\n    nb = adj[i]\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in nb:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    if best_colors:\n        new_color = random.choice(best_colors)\n    else:\n        new_color = random.choice(candidate_colors)\n\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            return list(solution)\n        except Exception:\n            return []\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_pert(sol)\n    n = len(sol)\n\n    # Embedded graph and adjacency\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    k = max(sol)\n\n    # Stage 1: multi-vertex random recolor with occasional new color\n    steps = max(2, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        choices = list(range(1, max(2, k + 1)))\n        if random.random() < 0.5:\n            choices.append(k + 1)\n        cur = sol[i]\n        if cur in choices and len(choices) > 1:\n            choices.remove(cur)\n        sol[i] = random.choice(choices)\n\n    # Stage 2: random merge of two color classes\n    k = max(sol)\n    if k >= 2 and random.random() < 0.6:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n\n    # Stage 3: random Kempe-chain flip around a random vertex\n    k = max(sol)\n    if k >= 2 and random.random() < 0.7:\n        i = random.randrange(n)\n        colors_present = sorted(set(sol))\n        a, b = random.sample(colors_present, 2)\n        # BFS on {a,b} component containing i\n        allowed = {a, b}\n        seen = [False] * n\n        stack = [i]\n        seen[i] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            if sol[u] not in allowed:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in allowed:\n                    seen[v] = True\n                    stack.append(v)\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    # Stage 4: split a color class\n    k = max(sol)\n    if random.random() < 0.7:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n\n    # Stage 5: random permutation of labels (symmetry breaking)\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001198624}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Embedded undirected graph\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n    HARD_PENALTY = 10 ** 9\n    CONFLICT_PENALTY = 10 ** 3\n\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return k\n\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _build_adj(n: int, edges: List[Tuple[int, int]]):\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflict_info(sol: List[int], edges: List[Tuple[int, int]], adj: List[List[int]]):\n    n = len(sol)\n    conflict_deg = [0] * n\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_deg[u - 1] += 1\n            conflict_deg[v - 1] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_deg) if c > 0]\n    # Saturation degree: number of distinct neighbor colors\n    sat = []\n    for i in range(n):\n        nb_colors = set(sol[j] for j in adj[i])\n        sat.append(len(nb_colors))\n    return conflicted_vertices, conflict_deg, sat\n\n\ndef _kempe_chain_flip(sol: List[int], adj: List[List[int]], start_idx: int, color_a: int, color_b: int) -> List[int]:\n    # BFS on subgraph induced by colors {a,b} from start_idx, then swap a<->b on that component\n    n = len(sol)\n    seen = [False] * n\n    stack = [start_idx]\n    seen[start_idx] = True\n    component = []\n    allowed = {color_a, color_b}\n    while stack:\n        i = stack.pop()\n        if sol[i] not in allowed:\n            continue\n        component.append(i)\n        for j in adj[i]:\n            if not seen[j] and sol[j] in allowed:\n                seen[j] = True\n                stack.append(j)\n    new_sol = sol[:]\n    for i in component:\n        if new_sol[i] == color_a:\n            new_sol[i] = color_b\n        elif new_sol[i] == color_b:\n            new_sol[i] = color_a\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            base = list(solution)\n        except Exception:\n            base = []\n        return base, \"Invalid\", \"NoOp\"\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_nb(sol)\n    n = len(sol)\n    k = max(sol)\n\n    adj = _build_adj(n, edges)\n    conflicted, conflict_deg, sat = _conflict_info(sol, edges, adj)\n\n    if conflicted:\n        # Pick most conflicted; tie-break by higher saturation then degree\n        candidates = conflicted\n        best = None\n        best_key = None\n        for i in candidates:\n            key = (conflict_deg[i], sat[i], len(adj[i]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n    else:\n        # No conflicts: choose a vertex with highest saturation to try reducing k\n        best = None\n        best_key = None\n        for i in range(n):\n            key = (sat[i], len(adj[i]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n\n    # With small probability perform a Kempe-chain flip between two colors\n    if k >= 2 and random.random() < 0.15:\n        colors_present = sorted(set(sol))\n        a, b = random.sample(colors_present, 2)\n        new_sol = _kempe_chain_flip(sol, adj, i, a, b)\n        new_sol = _relabel_contiguous_nb(new_sol)\n        return new_sol, \"KempeSwap\", \"TwoColorComponent\"\n\n    # Recolor single vertex i\n    # Prefer existing colors; occasionally allow k+1 to escape\n    candidate_colors = list(range(1, k + 1))\n    if random.random() < 0.2:\n        candidate_colors.append(k + 1)\n    cur = sol[i]\n    if cur in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(cur)\n\n    # Evaluate local conflicts per candidate\n    nb = adj[i]\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in nb:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    if best_colors:\n        new_color = random.choice(best_colors)\n    else:\n        new_color = random.choice(candidate_colors)\n\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            return list(solution)\n        except Exception:\n            return []\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_pert(sol)\n    n = len(sol)\n\n    # Embedded graph and adjacency\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    k = max(sol)\n\n    # Stage 1: multi-vertex random recolor with occasional new color\n    steps = max(2, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        choices = list(range(1, max(2, k + 1)))\n        if random.random() < 0.5:\n            choices.append(k + 1)\n        cur = sol[i]\n        if cur in choices and len(choices) > 1:\n            choices.remove(cur)\n        sol[i] = random.choice(choices)\n\n    # Stage 2: random merge of two color classes\n    k = max(sol)\n    if k >= 2 and random.random() < 0.6:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n\n    # Stage 3: random Kempe-chain flip around a random vertex\n    k = max(sol)\n    if k >= 2 and random.random() < 0.7:\n        i = random.randrange(n)\n        colors_present = sorted(set(sol))\n        a, b = random.sample(colors_present, 2)\n        # BFS on {a,b} component containing i\n        allowed = {a, b}\n        seen = [False] * n\n        stack = [i]\n        seen[i] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            if sol[u] not in allowed:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in allowed:\n                    seen[v] = True\n                    stack.append(v)\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    # Stage 4: split a color class\n    k = max(sol)\n    if random.random() < 0.7:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n\n    # Stage 5: random permutation of labels (symmetry breaking)\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.001573338}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_1_TO_K","Evaluacion":"import math\nfrom typing import List\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Embedded undirected graph\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n    HARD_PENALTY = 10 ** 9\n    CONFLICT_PENALTY = 10 ** 3\n\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return k\n\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _build_adj(n: int, edges: List[Tuple[int, int]]):\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflict_info(sol: List[int], edges: List[Tuple[int, int]], adj: List[List[int]]):\n    n = len(sol)\n    conflict_deg = [0] * n\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_deg[u - 1] += 1\n            conflict_deg[v - 1] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_deg) if c > 0]\n    # Saturation degree: number of distinct neighbor colors\n    sat = []\n    for i in range(n):\n        nb_colors = set(sol[j] for j in adj[i])\n        sat.append(len(nb_colors))\n    return conflicted_vertices, conflict_deg, sat\n\n\ndef _kempe_chain_flip(sol: List[int], adj: List[List[int]], start_idx: int, color_a: int, color_b: int) -> List[int]:\n    # BFS on subgraph induced by colors {a,b} from start_idx, then swap a<->b on that component\n    n = len(sol)\n    seen = [False] * n\n    stack = [start_idx]\n    seen[start_idx] = True\n    component = []\n    allowed = {color_a, color_b}\n    while stack:\n        i = stack.pop()\n        if sol[i] not in allowed:\n            continue\n        component.append(i)\n        for j in adj[i]:\n            if not seen[j] and sol[j] in allowed:\n                seen[j] = True\n                stack.append(j)\n    new_sol = sol[:]\n    for i in component:\n        if new_sol[i] == color_a:\n            new_sol[i] = color_b\n        elif new_sol[i] == color_b:\n            new_sol[i] = color_a\n    return new_sol\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            base = list(solution)\n        except Exception:\n            base = []\n        return base, \"Invalid\", \"NoOp\"\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_nb(sol)\n    n = len(sol)\n    k = max(sol)\n\n    adj = _build_adj(n, edges)\n    conflicted, conflict_deg, sat = _conflict_info(sol, edges, adj)\n\n    if conflicted:\n        # Pick most conflicted; tie-break by higher saturation then degree\n        candidates = conflicted\n        best = None\n        best_key = None\n        for i in candidates:\n            key = (conflict_deg[i], sat[i], len(adj[i]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n    else:\n        # No conflicts: choose a vertex with highest saturation to try reducing k\n        best = None\n        best_key = None\n        for i in range(n):\n            key = (sat[i], len(adj[i]), random.random())\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n\n    # With small probability perform a Kempe-chain flip between two colors\n    if k >= 2 and random.random() < 0.15:\n        colors_present = sorted(set(sol))\n        a, b = random.sample(colors_present, 2)\n        new_sol = _kempe_chain_flip(sol, adj, i, a, b)\n        new_sol = _relabel_contiguous_nb(new_sol)\n        return new_sol, \"KempeSwap\", \"TwoColorComponent\"\n\n    # Recolor single vertex i\n    # Prefer existing colors; occasionally allow k+1 to escape\n    candidate_colors = list(range(1, k + 1))\n    if random.random() < 0.2:\n        candidate_colors.append(k + 1)\n    cur = sol[i]\n    if cur in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(cur)\n\n    # Evaluate local conflicts per candidate\n    nb = adj[i]\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in nb:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    if best_colors:\n        new_color = random.choice(best_colors)\n    else:\n        new_color = random.choice(candidate_colors)\n\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)) or len(solution) == 0:\n        try:\n            return list(solution)\n        except Exception:\n            return []\n\n    sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    sol = _relabel_contiguous_pert(sol)\n    n = len(sol)\n\n    # Embedded graph and adjacency\n    edges = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    k = max(sol)\n\n    # Stage 1: multi-vertex random recolor with occasional new color\n    steps = max(2, n \/\/ 2)\n    for _ in range(steps):\n        i = random.randrange(n)\n        choices = list(range(1, max(2, k + 1)))\n        if random.random() < 0.5:\n            choices.append(k + 1)\n        cur = sol[i]\n        if cur in choices and len(choices) > 1:\n            choices.remove(cur)\n        sol[i] = random.choice(choices)\n\n    # Stage 2: random merge of two color classes\n    k = max(sol)\n    if k >= 2 and random.random() < 0.6:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n\n    # Stage 3: random Kempe-chain flip around a random vertex\n    k = max(sol)\n    if k >= 2 and random.random() < 0.7:\n        i = random.randrange(n)\n        colors_present = sorted(set(sol))\n        a, b = random.sample(colors_present, 2)\n        # BFS on {a,b} component containing i\n        allowed = {a, b}\n        seen = [False] * n\n        stack = [i]\n        seen[i] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            if sol[u] not in allowed:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in allowed:\n                    seen[v] = True\n                    stack.append(v)\n        for u in comp:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    # Stage 4: split a color class\n    k = max(sol)\n    if random.random() < 0.7:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n\n    # Stage 5: random permutation of labels (symmetry breaking)\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001469296}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_1_TO_K","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Embedded undirected graph (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n    HARD_PENALTY = 10 ** 9\n    CONFLICT_PENALTY = 10 ** 3\n\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return k\n\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _build_adj(n: int, edges: List[Tuple[int, int]]):\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflict_stats(sol: List[int], edges: List[Tuple[int, int]], adj: List[List[int]]):\n    n = len(sol)\n    conflict_deg = [0] * n\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_deg[u - 1] += 1\n            conflict_deg[v - 1] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_deg) if c > 0]\n    sat = []\n    for i in range(n):\n        nb_colors = set(sol[j] for j in adj[i])\n        sat.append(len(nb_colors))\n    return conflicted_vertices, conflict_deg, sat\n\n\ndef _kempe_chain_flip(sol: List[int], adj: List[List[int]], start_idx: int, color_a: int, color_b: int) -> List[int]:\n    n = len(sol)\n    seen = [False] * n\n    stack = [start_idx]\n    seen[start_idx] = True\n    component = []\n    allowed = {color_a, color_b}\n    while stack:\n        i = stack.pop()\n        if sol[i] not in allowed:\n            continue\n        component.append(i)\n        for j in adj[i]:\n            if not seen[j] and sol[j] in allowed:\n                seen[j] = True\n                stack.append(j)\n    new_sol = sol[:]\n    for i in component:\n        if new_sol[i] == color_a:\n            new_sol[i] = color_b\n        elif new_sol[i] == color_b:\n            new_sol[i] = color_a\n    return new_sol\n\n\ndef _repair_init(n: int, edges: List[Tuple[int, int]]) -> List[int]:\n    # Simple DSATUR-like greedy to build a valid coloring\n    adj = _build_adj(n, edges)\n    order = list(range(n))\n    # Degree ordering as a start\n    order.sort(key=lambda i: len(adj[i]), reverse=True)\n    colors = [0] * n\n    used = set()\n    for i in order:\n        forbidden = {colors[j] for j in adj[i] if colors[j] > 0}\n        c = 1\n        while c in forbidden:\n            c += 1\n        colors[i] = c\n        used.add(c)\n    return _relabel_contiguous_nb(colors)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        new_sol = _repair_init(n, edges)\n        return new_sol, \"InitRepair\", \"GreedyDSATUR\"\n\n    try:\n        sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    except Exception:\n        new_sol = _repair_init(n, edges)\n        return new_sol, \"InitRepair\", \"GreedyDSATUR\"\n\n    sol = _relabel_contiguous_nb(sol)\n    k = max(sol)\n\n    adj = _build_adj(n, edges)\n    conflicted, conflict_deg, sat = _conflict_stats(sol, edges, adj)\n\n    # Choose pivot vertex\n    if conflicted:\n        # Highest conflict degree; tie-break by saturation then degree then random\n        best = None\n        best_key = None\n        for i in conflicted:\n            key = (conflict_deg[i], sat[i], len(adj[i]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n        conflict_phase = True\n    else:\n        # No conflicts: try reducing k; pick vertex in highest color class with highest saturation\n        max_color = k\n        candidates = [idx for idx, c in enumerate(sol) if c == max_color]\n        if not candidates:\n            candidates = list(range(n))\n        best = None\n        best_key = None\n        for j in candidates:\n            key = (sat[j], len(adj[j]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best = j\n        i = best\n        conflict_phase = False\n\n    # Attempt Kempe-chain swap with elevated probability during conflict phase\n    kempe_prob = 0.5 if conflict_phase else 0.25\n    if k >= 2 and random.random() < kempe_prob:\n        # Choose colors: current color and most frequent neighbor color if any\n        cur_c = sol[i]\n        nb = adj[i]\n        freq = {}\n        for j in nb:\n            cj = sol[j]\n            freq[cj] = freq.get(cj, 0) + 1\n        if freq:\n            target = max(freq.items(), key=lambda x: (x[1], x[0]))[0]\n        else:\n            # fallback to a different existing color\n            cand = [c for c in set(sol) if c != cur_c]\n            target = random.choice(cand) if cand else cur_c\n        if target != cur_c:\n            new_sol = _kempe_chain_flip(sol, adj, i, cur_c, target)\n            new_sol = _relabel_contiguous_nb(new_sol)\n            return new_sol, \"KempeSwap\", \"TwoColorComponent\"\n\n    # Single-vertex recolor\n    nb = adj[i]\n    candidate_colors = list(range(1, k + 1))\n    if conflict_phase and random.random() < 0.15:\n        candidate_colors.append(k + 1)\n    cur = sol[i]\n    if cur in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(cur)\n\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in nb:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors) if best_colors else (cur if candidate_colors == [] else random.choice(candidate_colors))\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    # Returns a diversified solution (list of 9 ints)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n\n    # Basic input guard and relabel\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        # Create a simple random start then relabel\/repair\n        base = [random.randint(1, 3) for _ in range(n)]\n        sol = _relabel_contiguous_pert(base)\n    else:\n        try:\n            sol = [int(x) if int(x) > 0 else 1 for x in solution]\n        except Exception:\n            sol = [random.randint(1, 3) for _ in range(n)]\n        sol = _relabel_contiguous_pert(sol)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: conflict degree\n    def conflict_degree(s: List[int]) -> List[int]:\n        deg = [0] * n\n        for (u, v) in edges:\n            if s[u - 1] == s[v - 1]:\n                deg[u - 1] += 1\n                deg[v - 1] += 1\n        return deg\n\n    # Stage 1: targeted recolors on most conflicted vertices\n    deg = conflict_degree(sol)\n    order = list(range(n))\n    order.sort(key=lambda i: deg[i], reverse=True)\n    steps = max(3, n \/\/ 3)\n    for t in range(steps):\n        i = order[t % n]\n        nb = adj[i]\n        # Choose color minimizing local conflicts; allow k+1 with small prob\n        k = max(sol)\n        candidates = list(range(1, k + 1))\n        if random.random() < 0.3:\n            candidates.append(k + 1)\n        cur = sol[i]\n        if cur in candidates and len(candidates) > 1:\n            candidates.remove(cur)\n        best = []\n        best_conf = None\n        for c in candidates:\n            lc = 0\n            for j in nb:\n                if sol[j] == c:\n                    lc += 1\n            if best_conf is None or lc < best_conf:\n                best_conf = lc\n                best = [c]\n            elif lc == best_conf:\n                best.append(c)\n        if best:\n            sol[i] = random.choice(best)\n\n    sol = _relabel_contiguous_pert(sol)\n\n    # Stage 2: Kempe-chain flips around a few vertices\n    flips = 2\n    for _ in range(flips):\n        k = max(sol)\n        if k < 2:\n            break\n        i = random.randrange(n)\n        cur_c = sol[i]\n        # Pick neighbor color with highest frequency among neighbors\n        freq = {}\n        for j in adj[i]:\n            cj = sol[j]\n            freq[cj] = freq.get(cj, 0) + 1\n        if not freq:\n            continue\n        target = max(freq.items(), key=lambda x: (x[1], x[0]))[0]\n        if target == cur_c:\n            continue\n        allowed = {cur_c, target}\n        seen = [False] * n\n        stack = [i]\n        seen[i] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            if sol[u] not in allowed:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in allowed:\n                    seen[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == cur_c:\n                sol[u] = target\n            elif sol[u] == target:\n                sol[u] = cur_c\n\n    sol = _relabel_contiguous_pert(sol)\n\n    # Stage 3: optional split\/merge of color classes to diversify\n    k = max(sol)\n    # Merge two classes\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n        sol = _relabel_contiguous_pert(sol)\n    # Split a populous class\n    k = max(sol)\n    if random.random() < 0.6:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n            sol = _relabel_contiguous_pert(sol)\n\n    # Final symmetry breaking via label permutation\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"SA","Tiempo":0.001410076}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_1_TO_K","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Embedded undirected graph (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n    HARD_PENALTY = 10 ** 9\n    CONFLICT_PENALTY = 10 ** 3\n\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return k\n\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _build_adj(n: int, edges: List[Tuple[int, int]]):\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflict_stats(sol: List[int], edges: List[Tuple[int, int]], adj: List[List[int]]):\n    n = len(sol)\n    conflict_deg = [0] * n\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_deg[u - 1] += 1\n            conflict_deg[v - 1] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_deg) if c > 0]\n    sat = []\n    for i in range(n):\n        nb_colors = set(sol[j] for j in adj[i])\n        sat.append(len(nb_colors))\n    return conflicted_vertices, conflict_deg, sat\n\n\ndef _kempe_chain_flip(sol: List[int], adj: List[List[int]], start_idx: int, color_a: int, color_b: int) -> List[int]:\n    n = len(sol)\n    seen = [False] * n\n    stack = [start_idx]\n    seen[start_idx] = True\n    component = []\n    allowed = {color_a, color_b}\n    while stack:\n        i = stack.pop()\n        if sol[i] not in allowed:\n            continue\n        component.append(i)\n        for j in adj[i]:\n            if not seen[j] and sol[j] in allowed:\n                seen[j] = True\n                stack.append(j)\n    new_sol = sol[:]\n    for i in component:\n        if new_sol[i] == color_a:\n            new_sol[i] = color_b\n        elif new_sol[i] == color_b:\n            new_sol[i] = color_a\n    return new_sol\n\n\ndef _repair_init(n: int, edges: List[Tuple[int, int]]) -> List[int]:\n    # Simple DSATUR-like greedy to build a valid coloring\n    adj = _build_adj(n, edges)\n    order = list(range(n))\n    # Degree ordering as a start\n    order.sort(key=lambda i: len(adj[i]), reverse=True)\n    colors = [0] * n\n    used = set()\n    for i in order:\n        forbidden = {colors[j] for j in adj[i] if colors[j] > 0}\n        c = 1\n        while c in forbidden:\n            c += 1\n        colors[i] = c\n        used.add(c)\n    return _relabel_contiguous_nb(colors)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        new_sol = _repair_init(n, edges)\n        return new_sol, \"InitRepair\", \"GreedyDSATUR\"\n\n    try:\n        sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    except Exception:\n        new_sol = _repair_init(n, edges)\n        return new_sol, \"InitRepair\", \"GreedyDSATUR\"\n\n    sol = _relabel_contiguous_nb(sol)\n    k = max(sol)\n\n    adj = _build_adj(n, edges)\n    conflicted, conflict_deg, sat = _conflict_stats(sol, edges, adj)\n\n    # Choose pivot vertex\n    if conflicted:\n        # Highest conflict degree; tie-break by saturation then degree then random\n        best = None\n        best_key = None\n        for i in conflicted:\n            key = (conflict_deg[i], sat[i], len(adj[i]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n        conflict_phase = True\n    else:\n        # No conflicts: try reducing k; pick vertex in highest color class with highest saturation\n        max_color = k\n        candidates = [idx for idx, c in enumerate(sol) if c == max_color]\n        if not candidates:\n            candidates = list(range(n))\n        best = None\n        best_key = None\n        for j in candidates:\n            key = (sat[j], len(adj[j]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best = j\n        i = best\n        conflict_phase = False\n\n    # Attempt Kempe-chain swap with elevated probability during conflict phase\n    kempe_prob = 0.5 if conflict_phase else 0.25\n    if k >= 2 and random.random() < kempe_prob:\n        # Choose colors: current color and most frequent neighbor color if any\n        cur_c = sol[i]\n        nb = adj[i]\n        freq = {}\n        for j in nb:\n            cj = sol[j]\n            freq[cj] = freq.get(cj, 0) + 1\n        if freq:\n            target = max(freq.items(), key=lambda x: (x[1], x[0]))[0]\n        else:\n            # fallback to a different existing color\n            cand = [c for c in set(sol) if c != cur_c]\n            target = random.choice(cand) if cand else cur_c\n        if target != cur_c:\n            new_sol = _kempe_chain_flip(sol, adj, i, cur_c, target)\n            new_sol = _relabel_contiguous_nb(new_sol)\n            return new_sol, \"KempeSwap\", \"TwoColorComponent\"\n\n    # Single-vertex recolor\n    nb = adj[i]\n    candidate_colors = list(range(1, k + 1))\n    if conflict_phase and random.random() < 0.15:\n        candidate_colors.append(k + 1)\n    cur = sol[i]\n    if cur in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(cur)\n\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in nb:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors) if best_colors else (cur if candidate_colors == [] else random.choice(candidate_colors))\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    # Returns a diversified solution (list of 9 ints)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n\n    # Basic input guard and relabel\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        # Create a simple random start then relabel\/repair\n        base = [random.randint(1, 3) for _ in range(n)]\n        sol = _relabel_contiguous_pert(base)\n    else:\n        try:\n            sol = [int(x) if int(x) > 0 else 1 for x in solution]\n        except Exception:\n            sol = [random.randint(1, 3) for _ in range(n)]\n        sol = _relabel_contiguous_pert(sol)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: conflict degree\n    def conflict_degree(s: List[int]) -> List[int]:\n        deg = [0] * n\n        for (u, v) in edges:\n            if s[u - 1] == s[v - 1]:\n                deg[u - 1] += 1\n                deg[v - 1] += 1\n        return deg\n\n    # Stage 1: targeted recolors on most conflicted vertices\n    deg = conflict_degree(sol)\n    order = list(range(n))\n    order.sort(key=lambda i: deg[i], reverse=True)\n    steps = max(3, n \/\/ 3)\n    for t in range(steps):\n        i = order[t % n]\n        nb = adj[i]\n        # Choose color minimizing local conflicts; allow k+1 with small prob\n        k = max(sol)\n        candidates = list(range(1, k + 1))\n        if random.random() < 0.3:\n            candidates.append(k + 1)\n        cur = sol[i]\n        if cur in candidates and len(candidates) > 1:\n            candidates.remove(cur)\n        best = []\n        best_conf = None\n        for c in candidates:\n            lc = 0\n            for j in nb:\n                if sol[j] == c:\n                    lc += 1\n            if best_conf is None or lc < best_conf:\n                best_conf = lc\n                best = [c]\n            elif lc == best_conf:\n                best.append(c)\n        if best:\n            sol[i] = random.choice(best)\n\n    sol = _relabel_contiguous_pert(sol)\n\n    # Stage 2: Kempe-chain flips around a few vertices\n    flips = 2\n    for _ in range(flips):\n        k = max(sol)\n        if k < 2:\n            break\n        i = random.randrange(n)\n        cur_c = sol[i]\n        # Pick neighbor color with highest frequency among neighbors\n        freq = {}\n        for j in adj[i]:\n            cj = sol[j]\n            freq[cj] = freq.get(cj, 0) + 1\n        if not freq:\n            continue\n        target = max(freq.items(), key=lambda x: (x[1], x[0]))[0]\n        if target == cur_c:\n            continue\n        allowed = {cur_c, target}\n        seen = [False] * n\n        stack = [i]\n        seen[i] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            if sol[u] not in allowed:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in allowed:\n                    seen[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == cur_c:\n                sol[u] = target\n            elif sol[u] == target:\n                sol[u] = cur_c\n\n    sol = _relabel_contiguous_pert(sol)\n\n    # Stage 3: optional split\/merge of color classes to diversify\n    k = max(sol)\n    # Merge two classes\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n        sol = _relabel_contiguous_pert(sol)\n    # Split a populous class\n    k = max(sol)\n    if random.random() < 0.6:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n            sol = _relabel_contiguous_pert(sol)\n\n    # Final symmetry breaking via label permutation\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"ILS","Tiempo":0.002048643}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_15_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_CONTIGUOUS_1_TO_K","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_eval(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef evaluate_solution(solution):\n    # Embedded undirected graph (1-indexed)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n    HARD_PENALTY = 10 ** 9\n    CONFLICT_PENALTY = 10 ** 3\n\n    if not isinstance(solution, (list, tuple)):\n        return HARD_PENALTY\n    if len(solution) != n:\n        return HARD_PENALTY + abs(len(solution) - n) * CONFLICT_PENALTY\n\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return HARD_PENALTY\n\n    colors = [x if x >= 1 else 1 for x in colors]\n    colors = _relabel_contiguous_eval(colors)\n\n    k = max(colors) if colors else HARD_PENALTY\n\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return k\n\n    return HARD_PENALTY + conflicts * CONFLICT_PENALTY + min(k, n)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_nb(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef _build_adj(n: int, edges: List[Tuple[int, int]]):\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflict_stats(sol: List[int], edges: List[Tuple[int, int]], adj: List[List[int]]):\n    n = len(sol)\n    conflict_deg = [0] * n\n    for (u, v) in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflict_deg[u - 1] += 1\n            conflict_deg[v - 1] += 1\n    conflicted_vertices = [i for i, c in enumerate(conflict_deg) if c > 0]\n    sat = []\n    for i in range(n):\n        nb_colors = set(sol[j] for j in adj[i])\n        sat.append(len(nb_colors))\n    return conflicted_vertices, conflict_deg, sat\n\n\ndef _kempe_chain_flip(sol: List[int], adj: List[List[int]], start_idx: int, color_a: int, color_b: int) -> List[int]:\n    n = len(sol)\n    seen = [False] * n\n    stack = [start_idx]\n    seen[start_idx] = True\n    component = []\n    allowed = {color_a, color_b}\n    while stack:\n        i = stack.pop()\n        if sol[i] not in allowed:\n            continue\n        component.append(i)\n        for j in adj[i]:\n            if not seen[j] and sol[j] in allowed:\n                seen[j] = True\n                stack.append(j)\n    new_sol = sol[:]\n    for i in component:\n        if new_sol[i] == color_a:\n            new_sol[i] = color_b\n        elif new_sol[i] == color_b:\n            new_sol[i] = color_a\n    return new_sol\n\n\ndef _repair_init(n: int, edges: List[Tuple[int, int]]) -> List[int]:\n    # Simple DSATUR-like greedy to build a valid coloring\n    adj = _build_adj(n, edges)\n    order = list(range(n))\n    # Degree ordering as a start\n    order.sort(key=lambda i: len(adj[i]), reverse=True)\n    colors = [0] * n\n    used = set()\n    for i in order:\n        forbidden = {colors[j] for j in adj[i] if colors[j] > 0}\n        c = 1\n        while c in forbidden:\n            c += 1\n        colors[i] = c\n        used.add(c)\n    return _relabel_contiguous_nb(colors)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        new_sol = _repair_init(n, edges)\n        return new_sol, \"InitRepair\", \"GreedyDSATUR\"\n\n    try:\n        sol = [int(x) if int(x) > 0 else 1 for x in solution]\n    except Exception:\n        new_sol = _repair_init(n, edges)\n        return new_sol, \"InitRepair\", \"GreedyDSATUR\"\n\n    sol = _relabel_contiguous_nb(sol)\n    k = max(sol)\n\n    adj = _build_adj(n, edges)\n    conflicted, conflict_deg, sat = _conflict_stats(sol, edges, adj)\n\n    # Choose pivot vertex\n    if conflicted:\n        # Highest conflict degree; tie-break by saturation then degree then random\n        best = None\n        best_key = None\n        for i in conflicted:\n            key = (conflict_deg[i], sat[i], len(adj[i]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best = i\n        i = best\n        conflict_phase = True\n    else:\n        # No conflicts: try reducing k; pick vertex in highest color class with highest saturation\n        max_color = k\n        candidates = [idx for idx, c in enumerate(sol) if c == max_color]\n        if not candidates:\n            candidates = list(range(n))\n        best = None\n        best_key = None\n        for j in candidates:\n            key = (sat[j], len(adj[j]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best = j\n        i = best\n        conflict_phase = False\n\n    # Attempt Kempe-chain swap with elevated probability during conflict phase\n    kempe_prob = 0.5 if conflict_phase else 0.25\n    if k >= 2 and random.random() < kempe_prob:\n        # Choose colors: current color and most frequent neighbor color if any\n        cur_c = sol[i]\n        nb = adj[i]\n        freq = {}\n        for j in nb:\n            cj = sol[j]\n            freq[cj] = freq.get(cj, 0) + 1\n        if freq:\n            target = max(freq.items(), key=lambda x: (x[1], x[0]))[0]\n        else:\n            # fallback to a different existing color\n            cand = [c for c in set(sol) if c != cur_c]\n            target = random.choice(cand) if cand else cur_c\n        if target != cur_c:\n            new_sol = _kempe_chain_flip(sol, adj, i, cur_c, target)\n            new_sol = _relabel_contiguous_nb(new_sol)\n            return new_sol, \"KempeSwap\", \"TwoColorComponent\"\n\n    # Single-vertex recolor\n    nb = adj[i]\n    candidate_colors = list(range(1, k + 1))\n    if conflict_phase and random.random() < 0.15:\n        candidate_colors.append(k + 1)\n    cur = sol[i]\n    if cur in candidate_colors and len(candidate_colors) > 1:\n        candidate_colors.remove(cur)\n\n    best_colors = []\n    best_conf = None\n    for c in candidate_colors:\n        lc = 0\n        for j in nb:\n            if sol[j] == c:\n                lc += 1\n        if best_conf is None or lc < best_conf:\n            best_conf = lc\n            best_colors = [c]\n        elif lc == best_conf:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors) if best_colors else (cur if candidate_colors == [] else random.choice(candidate_colors))\n    new_sol = sol[:]\n    new_sol[i] = new_color\n    new_sol = _relabel_contiguous_nb(new_sol)\n    return new_sol, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef _relabel_contiguous_pert(colors: List[int]) -> List[int]:\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in colors:\n        c = int(c)\n        if c < 1:\n            c = 1\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    # Returns a diversified solution (list of 9 ints)\n    edges: List[Tuple[int, int]] = [\n        (1, 4), (1, 5), (1, 8),\n        (2, 3), (2, 5), (2, 9),\n        (3, 6), (3, 8), (3, 9),\n        (4, 7), (4, 8), (4, 9),\n        (6, 7), (6, 8),\n        (7, 8),\n    ]\n    n = 9\n\n    # Basic input guard and relabel\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        # Create a simple random start then relabel\/repair\n        base = [random.randint(1, 3) for _ in range(n)]\n        sol = _relabel_contiguous_pert(base)\n    else:\n        try:\n            sol = [int(x) if int(x) > 0 else 1 for x in solution]\n        except Exception:\n            sol = [random.randint(1, 3) for _ in range(n)]\n        sol = _relabel_contiguous_pert(sol)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: conflict degree\n    def conflict_degree(s: List[int]) -> List[int]:\n        deg = [0] * n\n        for (u, v) in edges:\n            if s[u - 1] == s[v - 1]:\n                deg[u - 1] += 1\n                deg[v - 1] += 1\n        return deg\n\n    # Stage 1: targeted recolors on most conflicted vertices\n    deg = conflict_degree(sol)\n    order = list(range(n))\n    order.sort(key=lambda i: deg[i], reverse=True)\n    steps = max(3, n \/\/ 3)\n    for t in range(steps):\n        i = order[t % n]\n        nb = adj[i]\n        # Choose color minimizing local conflicts; allow k+1 with small prob\n        k = max(sol)\n        candidates = list(range(1, k + 1))\n        if random.random() < 0.3:\n            candidates.append(k + 1)\n        cur = sol[i]\n        if cur in candidates and len(candidates) > 1:\n            candidates.remove(cur)\n        best = []\n        best_conf = None\n        for c in candidates:\n            lc = 0\n            for j in nb:\n                if sol[j] == c:\n                    lc += 1\n            if best_conf is None or lc < best_conf:\n                best_conf = lc\n                best = [c]\n            elif lc == best_conf:\n                best.append(c)\n        if best:\n            sol[i] = random.choice(best)\n\n    sol = _relabel_contiguous_pert(sol)\n\n    # Stage 2: Kempe-chain flips around a few vertices\n    flips = 2\n    for _ in range(flips):\n        k = max(sol)\n        if k < 2:\n            break\n        i = random.randrange(n)\n        cur_c = sol[i]\n        # Pick neighbor color with highest frequency among neighbors\n        freq = {}\n        for j in adj[i]:\n            cj = sol[j]\n            freq[cj] = freq.get(cj, 0) + 1\n        if not freq:\n            continue\n        target = max(freq.items(), key=lambda x: (x[1], x[0]))[0]\n        if target == cur_c:\n            continue\n        allowed = {cur_c, target}\n        seen = [False] * n\n        stack = [i]\n        seen[i] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            if sol[u] not in allowed:\n                continue\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in allowed:\n                    seen[v] = True\n                    stack.append(v)\n        for u in comp:\n            if sol[u] == cur_c:\n                sol[u] = target\n            elif sol[u] == target:\n                sol[u] = cur_c\n\n    sol = _relabel_contiguous_pert(sol)\n\n    # Stage 3: optional split\/merge of color classes to diversify\n    k = max(sol)\n    # Merge two classes\n    if k >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if c == b else c for c in sol]\n        sol = _relabel_contiguous_pert(sol)\n    # Split a populous class\n    k = max(sol)\n    if random.random() < 0.6:\n        chosen = random.randint(1, k)\n        idxs = [i for i, c in enumerate(sol) if c == chosen]\n        if len(idxs) >= 2:\n            subset_size = max(1, len(idxs) \/\/ 2)\n            subset = set(random.sample(idxs, subset_size))\n            new_label = k + 1\n            for i in subset:\n                sol[i] = new_label\n            sol = _relabel_contiguous_pert(sol)\n\n    # Final symmetry breaking via label permutation\n    k = max(sol)\n    labels = list(range(1, k + 1))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {old: new for old, new in zip(labels, perm)}\n    sol = [mapping[c] for c in sol]\n\n    sol = _relabel_contiguous_pert(sol)\n    return sol\n","Resultados":"Failed to run target heuristic: Type List cannot be instantiated; use list() instead.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":"NA","Valor Optimo":"NA","Metaheuristica":"TS","Tiempo":0.001858911}
