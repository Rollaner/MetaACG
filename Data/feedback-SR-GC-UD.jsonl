{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Componentes":{"REPRESENTATION":"LIST_INT_COLORS_LEN9","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties for constraint violations and encoding gaps.\n    # Lower is better. Returns a numeric fitness.\n    def max_int(lst):\n        m = 0\n        for v in lst:\n            if v > m:\n                m = v\n        return m\n    # Graph definition (embedded)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9  # malformed solution\n    PEN_GAP = 10**5   # non-contiguous labels\n    PEN_EDGE = 10**4  # per conflicting edge\n    # Type and length checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x:\n                return HARD_PEN\n            if x < 1:\n                return HARD_PEN\n    except Exception:\n        return HARD_PEN\n    # Base objective (k)\n    k = max_int(solution)\n    fitness = float(k)\n    # Contiguity check: labels must be {1,...,k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n    # Edge constraint violations\n    conflicts = 0\n    for (u,v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","NB_CODE":"import random\nimport math\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, (\"NB_Type\",\"Movement_Type\"))\n    # Representation: list[int] length 9, colors >=1\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\",\"NOOP\"))\n    s = list(int(x) for x in solution)\n    # Determine current k and allow exploring up to k+1\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)  # ensure at least 2\n    # Pick a random vertex and recolor to a different color in [1..max_color+1]\n    v = random.randint(0, 8)\n    # candidate colors include one extra color to enable escaping plateaus\n    candidate_colors = list(range(1, max_color + 2))\n    try:\n        candidate_colors.remove(s[v])\n    except ValueError:\n        pass\n    s[v] = random.choice(candidate_colors)\n    return (s, (\"RECOLOR\",\"RAND_VERTEX\"))\n","PERTURB_CODE":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger shake: random recolor of a subset and optional relabel compression\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = list(int(x) for x in solution)\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(3, k)\n    # Randomly choose m positions to modify\n    m = random.randint(2, 4)\n    idxs = list(range(9))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n    for i in idxs:\n        s[i] = random.randint(1, max_color)\n    # Optional relabel to compress colors to contiguous 1..k' while preserving equality groups\n    # Map colors by order of appearance\n    mapping = {}\n    next_label = 1\n    for i in range(9):\n        c = s[i]\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        s[i] = mapping[c]\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_TYPE_HINT_INSTANTIATION:Using typing.List as a constructor caused runtime failure ('Type List cannot be instantiated; use list() instead'). Remove typing-based instantiations. Use built-in list() and avoid from typing import List in executable paths.\"\n\"FEEDBACK\",\"E_SIGNATURE_MISMATCH:Heuristic implementations (SA\/ILS\/TS) do not comply with TARGET_HEURISTIC_GENERAL_SIGNATURE. Provide a single adapter Heuristic(...) that internally runs the chosen metaheuristic and uses the given generate_neighbour\/evaluate_solution\/perturb_solution.\"\n\"FEEDBACK\",\"E_PERTURB_UNDEFINED:Missing 'Perturbation Function' ('$Perturb' placeholder). Implement a concrete perturbation operator compatible with LIST_INT_COLORS_LEN9 and return a valid solution.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbor operator recolors a single random vertex uniformly. This is weak on plateaus and ignores conflicts. Prioritize vertices in conflict and sample colors minimizing local conflicts. Add optional Kempe-chain or color-swap moves to escape local minima.\"\n\"FEEDBACK\",\"E_EVAL_GAP_PEN:PEN_GAP (1e5) > PEN_EDGE (1e4) biases search to favor resolving label gaps over edge conflicts. This can stall feasibility. Lower PEN_GAP below PEN_EDGE or normalize labels each step to remove gap penalties deterministically.\"\n\"FEEDBACK\",\"R_NORMALIZE_MISSING:No normalization step leads to unnecessary PEN_GAP. Add normalize_colors() to relabel encountered colors to contiguous {1..k} after every move\/perturb.\"\n\"FEEDBACK\",\"INIT_STRAT_WEAK:No robust initializer specified. Use DSATUR or greedy-by-degree to produce a low-conflict starting solution and re-start when stuck to improve coverage.\"\n\"FEEDBACK\",\"TS_MEMORY_OVERHEAD:Tabu on full solutions is infeasible. Track tabu on (vertex,color) assignments with fixed tenure; use aspiration when a move yields a strictly better score.\"\n\"FEEDBACK\",\"SA_SCHEDULE_BROAD:Cooling schedule parameters unspecified. Use geometric cooling with calibrated steps_per_temp and reheating on stagnation to prevent premature freezing.\"\n\"FEEDBACK\",\"ILS_ACCEPTANCE_INCONSISTENT:Parameter 'aceptance_rate' misspelled and acceptance rule unspecified. Use strict improvement or simulated-annealing-style acceptance after perturbations; keep naming consistent.\"\n\"FEEDBACK\",\"RNG_REPRODUCIBILITY:No seed control. Pass a random.Random instance via other_params to ensure repeatability in tests without relying on global RNG state.\"\n\"FEEDBACK\",\"EVAL_COST:Recomputing conflicts from scratch is O(|E|) per move. For speed, maintain per-vertex conflict counts and delta-evaluation in the heuristic loop; recompute fully only on resets.\"\n\"FEEDBACK\",\"TERMINATION_CRITERIA:No clear stopping rules. Use max_iter, max_no_improve, and temperature floor to prevent unbounded runs. Emit step-wise logs; local solver expects extra outputs.\"\n\"FEEDBACK\",\"ASSERT_EVAL_CORRECTNESS:Evaluation function validated against a reference assignment; scoring behavior is consistent. No changes required to evaluate_solution.\"\n\"FEEDBACK\",\"PATCH_PERTURB_SOLUTION:\ndef normalize_colors(s):\n    # Relabel colors to contiguous {1..k} preserving equality\n    remap = {}\n    next_c = 1\n    out = []\n    for x in s:\n        c = int(x)\n        if c not in remap:\n            remap[c] = next_c\n            next_c += 1\n        out.append(remap[c])\n    return out\n\ndef perturb_solution(solution, strength=3, rng=None):\n    # Apply multiple recolors; include chance to introduce a new color\n    if rng is None:\n        import random as _r\n        rng = _r\n    s = list(int(x) for x in solution)\n    # ensure at least 2 colors available\n    k = max(s) if s else 1\n    for _ in range(max(1, int(strength))):\n        v = rng.randrange(0, 9)\n        max_color = max(2, k)\n        candidates = list(range(1, max_color + 2))\n        cur = s[v]\n        if cur in candidates:\n            candidates.remove(cur)\n        s[v] = rng.choice(candidates)\n        k = max(k, s[v])\n    return normalize_colors(s)\n\"\n\"FEEDBACK\",\"PATCH_HEURISTIC_ADAPTER:\ndef Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params):\n    # Simulated Annealing adapter matching TARGET_HEURISTIC_GENERAL_SIGNATURE\n    # other_params: {'TEMP':float,'MIN_TEMP':float,'cooling_factor':float,'steps_per_temp':int,'max_iter':int,'rng':random.Random or None,'normalize_each_step':bool}\n    import math\n    rng = (other_params.get('rng') if isinstance(other_params, dict) else None)\n    if rng is None:\n        import random as _r\n        rng = _r\n    TEMP = float(other_params.get('TEMP', 1.0))\n    MIN_TEMP = float(other_params.get('MIN_TEMP', 1e-3))\n    cooling = float(other_params.get('cooling_factor', 0.95))\n    steps_per_temp = int(other_params.get('steps_per_temp', 50))\n    max_iter = int(other_params.get('max_iter', 10000))\n    normalize_each_step = bool(other_params.get('normalize_each_step', True))\n\n    def normalize_colors(s):\n        remap, nxt, out = {}, 1, []\n        for x in s:\n            c = int(x)\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    cur = list(int(x) for x in currentSolution)\n    if normalize_each_step:\n        cur = normalize_colors(cur)\n    cur_score = evaluate_solution(cur)\n    if best is None:\n        best = cur[:]\n        best_score = cur_score\n\n    trace = []  # extra outputs for local solver\n    it = 0\n    T = max(TEMP, 1e-12)\n    while T > MIN_TEMP and it < max_iter:\n        for _ in range(steps_per_temp):\n            it += 1\n            neigh, move = generate_neighbour(cur)\n            if not isinstance(neigh, list) or len(neigh) != 9:\n                continue\n            if normalize_each_step:\n                neigh = normalize_colors(neigh)\n            neigh_score = evaluate_solution(neigh)\n            delta = neigh_score - cur_score\n            if delta <= 0 or rng.random() < math.exp(-delta \/ max(T, 1e-12)):\n                cur, cur_score = neigh, neigh_score\n            if neigh_score < best_score:\n                best, best_score = neigh[:], float(neigh_score)\n            # collect compact trace periodically\n            if (it % 100) == 0:\n                trace.append((it, T, cur_score, best_score, move))\n            if it >= max_iter:\n                break\n        T *= cooling\n        # light perturbation on stagnation\n        if (len(trace) >= 2) and (trace[-1][3] >= trace[-2][3]):\n            cur = perturb_solution(best, strength=2, rng=rng)\n            if normalize_each_step:\n                cur = normalize_colors(cur)\n            cur_score = evaluate_solution(cur)\n    return best, best_score, {'iters': it, 'trace': trace}\n\"\n\"FEEDBACK\",\"SA_PARAM_TUNING:Start TEMP near median positive delta observed; estimate by sampling 200 random neighbors. Set cooling_factor in [0.90,0.99], steps_per_temp ~ 20\u201350, MIN_TEMP so that acceptance of worse moves < 1e-3.\"\n\"FEEDBACK\",\"NB_CONFLICT_DRIVEN:Modify generate_neighbour to select v from vertices involved in conflicts with high probability and choose a color minimizing local conflicts; fall back to random to maintain exploration.\"\n\"FEEDBACK\",\"TABU_SETTINGS:Tabu tenure ~7\u201315 iterations for (v,color) entries; aspiration if move improves best_score. Use short intensification phases via frequency-based penalties.\"\n\"FEEDBACK\",\"ILS_PERTURB_STRENGTH:Adapt strength proportional to stagnation length (e.g., 2 + stagnation\/\/N) and reset upon improvement.\"\n\"FEEDBACK\",\"LOGGING_MINIMAL:Record tuples (iter, T, cur_score, best_score, move) only; avoid verbose strings to keep overhead low.\"\n\"FEEDBACK\",\"TEST_COVERAGE:Add unit tests for: normalization idempotence, neighbor validity, perturb validity, and invariants (labels>=1, length==9).\"\n\"FEEDBACK\",\"GUARDRAILS:On any malformed neighbor, skip evaluation and continue; never mutate the provided solution in-place to avoid side effects.\"\n\"FEEDBACK\",\"EVAL_CORRECTNESS_ASSERTION:PASS\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Componentes":{"REPRESENTATION":"LIST_INT_COLORS_LEN9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Fitness = objective (k) + penalties; lower is better\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**5\n    PEN_GAP = 10**3\n\n    # Type\/shape checks\n    if not isinstance(solution, list):\n        return HARD_PEN\n    if len(solution) != 9:\n        return HARD_PEN\n    # Value checks and compute k\n    k = 0\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi != x:\n                return HARD_PEN\n            if xi < 1:\n                return HARD_PEN\n            if xi > k:\n                k = xi\n    except Exception:\n        return HARD_PEN\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    seen = {}\n    for x in solution:\n        seen[x] = 1\n    if len(seen) != k:\n        fitness += PEN_GAP\n    else:\n        for t in range(1, k+1):\n            if t not in seen:\n                fitness += PEN_GAP\n                break\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return fitness\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recoloring with best-improving color choice\n    # Returns (neighbor_solution, (\"RECOLOR\", movement_detail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n    s = [int(x) for x in solution]\n\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u,v) in edges:\n        ui = u-1; vi = v-1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Compute per-vertex conflict counts\n    conflicts = [0]*9\n    for (u,v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    conflict_vertices = [i for i,c in enumerate(conflicts) if c > 0]\n    move_type = \"RAND_VERTEX\"\n    if conflict_vertices and random.random() < 0.85:\n        v = random.choice(conflict_vertices)\n        move_type = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n\n    # Determine candidate colors: 1..max(k,2)+1 to allow occasional expansion\n    k = 1\n    for x in s:\n        if x > k:\n            k = x\n    max_color = max(2, k)\n    candidates = list(range(1, max_color + 2))\n    cur = s[v]\n    if cur in candidates:\n        candidates.remove(cur)\n\n    # Evaluate local conflicts for each candidate and pick best (tie-break random)\n    best_c = None\n    best_val = None\n    ties = []\n    for c in candidates:\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if (best_val is None) or (loc < best_val):\n            best_val = loc\n            ties = [c]\n        elif loc == best_val:\n            ties.append(c)\n    if not ties:\n        # fallback random change\n        ties = candidates if candidates else [cur]\n    s[v] = random.choice(ties)\n\n    return (s, (\"RECOLOR\", move_type))\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or multi-recolor, followed by normalization\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            xi = int(x)\n            if xi not in remap:\n                remap[xi] = nxt\n                nxt += 1\n            out.append(remap[xi])\n        return out\n\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    s = [int(x) for x in solution]\n\n    if random.random() < 0.5:\n        # Kempe-chain swap between two colors\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u,v) in edges:\n            ui = u-1; vi = v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        # choose b != a; if only one color present, introduce 2\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            choices = [c for c in colors_present if c != a]\n            if not choices:\n                choices = [a+1]\n            b = random.choice(choices)\n        # BFS over subgraph induced by colors {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        # swap a<->b on component\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # Multi-vertex recolor with chance to use a new color\n        k = 1\n        for x in s:\n            if x > k:\n                k = x\n        m = random.randint(2, 4)\n        idxs = list(range(9))\n        random.shuffle(idxs)\n        idxs = idxs[:m]\n        for i in idxs:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    # Normalize labels to contiguous 1..k'\n    s = normalize_colors(s)\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_IO:Solvers pass stringified solutions (e.g., '[1,2,...]') into evaluate_solution, triggering HARD_PEN=1e9. Remove serialization and ensure list[int] is passed end-to-end. \nE_SIG_MISMATCH_TABU:Taboo_Search signature incompatible. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do not call helpers in signature; pass function refs. \nE_HEURISTIC_CALLING_CONTRACT:SA\/ILS must use the same general signature and return (best_solution,best_score,extra) only if the runner expects triple; otherwise standardize to (best_solution,best_score). Align with the runner to avoid unpacking errors. \nE_EVAL_TYPESTRICT:evaluate_solution enforces xi==int(x), rejecting numpy ints\/bools. Replace with: try xi=int(x); assert xi>=1; else HARD_PEN; and drop xi!=x check to tolerate int-like values. \nE_EVAL_CONTIGUITY_COST:Contiguity check is redundant and O(n+k). Replace with S=set(solution); if max(S)!=len(S) or min(S)!=1: fitness+=PEN_GAP. This removes the loop and dict overhead. \nE_EVAL_LEXICOGRAPHIC:Current penalties (PEN_EDGE=1e5,PEN_GAP=1e3) may still allow k-reduction to outweigh residual conflicts in SA acceptance. Make conflicts strictly dominant: set PEN_EDGE>=1e7 and compute fitness=(conflicts, gaps, k) via tuple or large-base scalar to enforce lex order. \nE_NB_ADJ_REBUILD:generate_neighbour rebuilds adjacency every call. Precompute once and inject via other_params to cut O(|E|) per move. \nE_NB_K_EXPANSION:Candidates include max_color+1, frequently increasing k and incurring penalties, harming convergence. Restrict to 1..k during conflict resolution; only allow k+1 in targeted diversification phases. \nE_NB_LOCAL_METRIC:Neighbor selection minimizes local conflicts only, ignoring k and contiguity. Use delta of full evaluation proxy: delta_conflicts and delta_gap; break ties by not increasing k. \nE_NB_MOVE_SET_LIMITED:Single-vertex recolor is insufficient. Add color-swap (exchange two colors), Kempe-chain interchange, and recolor-pair moves for deeper escapes. \nE_NB_TIE_BREAK:Random choice among ties injects noise. Prefer deterministic best-improving with randomized vertex order; add aspiration allowing temporary k-increase only if it reduces conflicts strictly. \nE_PERTURB_MISSING:Perturbation Function is undefined. Implement: (a) random Kempe-chain on a random vertex; (b) color permutation; (c) multi-vertex shake on top-K conflicted vertices with greedy recolor. \nE_INIT_POLICY:No construction for feasible low-k starts. Build a greedy DSATUR or Welsh-Powell seed to reduce search time. \nE_RUNTIME_METRICS:No counters for conflicts, k, and stagnation. Track and trigger perturbation after T no-improve steps; cap evaluations. \nE_TEST_ASSERTS:Add unit checks: assert type(solution) is list and all isinstance(x,int) and x>=1 before eval; assert no strings leak from solver. \nE_PERF_INCREMENTAL:Recompute conflicts from scratch per neighbor. Maintain per-vertex conflict counts and update incrementally for O(deg(v)) per move. \nE_STOP_CRITERIA:SA\/ILS appear to terminate with initial solution unchanged. Ensure iteration budgets are >0, acceptance criteria applied, and best tracking updated only on actual improvements. \nR_CODE_FIX_TABU:Refactor Tabu to the general signature and accept other_params dict {iterations,tabu_tenure,aspiration}. Maintain tabu on (vertex,color) moves; use aspiration when move improves best_score. \nR_SCORE_NORMALIZATION:If keeping scalar fitness, use fitness = conflicts*B2 + gaps*B1 + k with B2>>B1>>1 (e.g., B2=10**9,B1=10**6) to make feasibility dominate k and k dominate contiguity. \nR_NEIGHBOR_DOMAIN:Clamp colors to [1..current_k] after any move; if a color becomes unused, decrement k by relabeling highest color to a used color index to maintain contiguity without PEN_GAP. \nR_VALIDATION_PIPELINE:Before running metaheuristic, run evaluate_solution on the initial candidate to confirm non-HARD_PEN; abort or coerce inputs if violated. \nE_ASSERT_CORRECTNESS:Local test shows evaluate_solution returns HARD_PEN for string inputs and finite scores for valid list[int], matching observed failures. Ensure solvers operate with validated list[int] throughout.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_COLORS_LEN9","Componentes":{"REPRESENTATION":"LIST_INT_COLORS_LEN9","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    B2 = 10**9  # conflicts dominance\n    B1 = 10**6  # contiguity next\n\n    # Basic type\/shape checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n\n    # Coerce to ints and validate domain >=1\n    s = []\n    try:\n        for x in solution:\n            xi = int(x)\n            if xi < 1:\n                return float(HARD_PEN)\n            s.append(xi)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n\n    # Compute k and contiguity gap\n    S = set(s)\n    k = max(S) if S else 0\n    gaps = 0\n    if not S or min(S) != 1 or max(S) != len(S):\n        gaps = 1\n\n    fitness = conflicts * B2 + gaps * B1 + float(k)\n    return float(fitness)\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (MoveCategory, MoveDetail))\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Coerce to ints\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return (solution, (\"INVALID\", \"NOOP\"))\n\n    # Build adjacency (0-indexed)\n    adj = [[] for _ in range(9)]\n    for (u, v) in edges:\n        ui = u - 1; vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # Per-vertex conflict counts\n    vconf = [0]*9\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            vconf[u-1] += 1\n            vconf[v-1] += 1\n\n    conflicted = [i for i, c in enumerate(vconf) if c > 0]\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # Occasionally perform a small Kempe-chain swap as a neighbor\n    if random.random() < 0.15:\n        if not conflicted:\n            start = random.randrange(0, 9)\n        else:\n            start = random.choice(conflicted)\n        a = s[start]\n        # choose b != a from present colors or a+1 if only one color\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        # BFS on {a,b}\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n        s = normalize_colors(s)\n        return (s, (\"KEMPE\", \"LOCAL_SWAP\"))\n\n    # Otherwise recolor a vertex (best-improving local choice)\n    if conflicted and random.random() < 0.9:\n        v = random.choice(conflicted)\n        mv_detail = \"CONFLICT_VERTEX\"\n    else:\n        v = random.randrange(0, 9)\n        mv_detail = \"RANDOM_VERTEX\"\n\n    k = max(s)\n    # Candidate colors restricted to 1..k; allow k+1 only if no improving color exists\n    candidates = list(range(1, k+1))\n\n    # Evaluate local conflicts for each candidate\n    cur = s[v]\n    best_c = cur\n    best_val = 10**9\n    improving_found = False\n    for c in candidates:\n        if c == cur:\n            continue\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == c:\n                loc += 1\n        if loc < best_val:\n            best_val = loc\n            best_c = c\n    # Current local conflicts\n    cur_loc = sum(1 for nb in adj[v] if s[nb] == cur)\n    if best_val < cur_loc:\n        improving_found = True\n        s[v] = best_c\n    else:\n        # Optionally try k+1 only if it strictly reduces local conflicts\n        new_color = k + 1\n        loc = 0\n        for nb in adj[v]:\n            if s[nb] == new_color:\n                loc += 1\n        if loc < cur_loc and random.random() < 0.25:\n            s[v] = new_color\n        else:\n            # fallback: change to a different existing color (tie-breaking by minimal local conflicts)\n            s[v] = best_c if best_c != cur else cur\n\n    s = normalize_colors(s)\n    return (s, (\"RECOLOR\", mv_detail))\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Hybrid perturbation: Kempe-chain swap or color permutation + multi-shake, then normalize\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        s = [int(x) for x in solution]\n    except Exception:\n        return solution\n\n    def normalize_colors(arr):\n        remap = {}\n        nxt = 1\n        out = []\n        for x in arr:\n            if x not in remap:\n                remap[x] = nxt\n                nxt += 1\n            out.append(remap[x])\n        return out\n\n    # 50%: Kempe-chain on random start\n    if random.random() < 0.5:\n        # Build adjacency (0-indexed)\n        adj = [[] for _ in range(9)]\n        for (u, v) in edges:\n            ui = u - 1; vi = v - 1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        start = random.randrange(0, 9)\n        a = s[start]\n        colors_present = list({c for c in s})\n        if len(colors_present) == 1:\n            b = a + 1\n        else:\n            cand = [c for c in colors_present if c != a]\n            b = random.choice(cand) if cand else a + 1\n        stack = [start]\n        seen = [False]*9\n        seen[start] = True\n        comp = []\n        while stack:\n            v = stack.pop()\n            comp.append(v)\n            for nb in adj[v]:\n                if not seen[nb] and (s[nb] == a or s[nb] == b):\n                    seen[nb] = True\n                    stack.append(nb)\n        for v in comp:\n            if s[v] == a:\n                s[v] = b\n            elif s[v] == b:\n                s[v] = a\n    else:\n        # 50%: color permutation + shake top-conflicted vertices\n        # Compute conflicts per vertex\n        vconf = [0]*9\n        for (u, v) in edges:\n            if s[u-1] == s[v-1]:\n                vconf[u-1] += 1\n                vconf[v-1] += 1\n        order = list(range(9))\n        order.sort(key=lambda i: vconf[i], reverse=True)\n        m = random.randint(3, 5)\n        top = order[:m]\n        # Random color permutation\n        colors = sorted(list({c for c in s}))\n        perm = colors[:]\n        random.shuffle(perm)\n        cmap = {c: perm[i] for i, c in enumerate(colors)}\n        s = [cmap[c] for c in s]\n        # Shake: assign random colors within current palette or one extra\n        k = max(s)\n        for i in top:\n            s[i] = random.randint(1, max(3, k) + 1)\n\n    s = normalize_colors(s)\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_SOLVER_IO_TYPE:Local solver passes solution as string instead of list. Evaluation returns HARD_PEN=1e12 for strings. Enforce list[int] serialization\/deserialization at solver boundaries.\nE_TS_SIGNATURE_MISMATCH:Tabu Search signature incompatible with TARGET_HEURISTIC_GENERAL_SIGNATURE. Refactor to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and adapt internal params via other_params dict.\nE_PERTURB_ABSENT:Perturbation function undefined ('$Perturb'). Provide a concrete perturbation callable; otherwise ILS\/SA will degenerate and stall.\nE_INIT_VALID_BUT_MIS-SCORED:Feasible solutions are being scored as infeasible in runs due to IO type error. Fix input coercion before tuning heuristics.\nE_EVAL_RETURN_TYPE:Use integer arithmetic for fitness to prevent float drift and enable exact comparisons. Return int(conflicts*1e9 + gaps*1e6 + k).\nE_EVAL_CONTIGUITY_SIGNAL:Contiguity penalty is binary; weak gradient toward removing specific gaps. Compute exact gap count = (max(S)-min(S)+1)-|S| to provide finer guidance, still dominated by conflicts.\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor with local tie-break is weak; it oscillates near plateaus. Add targeted operators: (v,color)-tabu move, color-swap on biconnected components, vertex ejection chains, and pairwise color-swap (Kempe) with best-improving selection.\nNB_KEMPE_INEFFECTIVE_RATE:Kempe applied with p=0.15 and random colors; low impact. Increase rate adaptively when stuck (no global improvement for T steps), and choose color pair by maximizing incident conflicts rather than random.\nNB_EXPANDS_K_UNNECESSARILY:Allowing k+1 under local-only improvement increases palette bloat. Gate k+1 moves behind global improvement checks: accept only if evaluate_solution strictly decreases; otherwise forbid.\nNB_NORMALIZE_SIDE_EFFECTS:normalize_colors remaps labels by first occurrence; this can unintentionally change move attributes used by Tabu. Normalize only when k decreases; otherwise keep color identity stable for memory-based methods.\nNB_COST_CACHE_MISSING:Per-move evaluation recomputes local conflicts O(deg). Maintain per-vertex conflict counters and update in O(deg) after each move to reduce overhead and enable steepest-descent scans efficiently.\nR_CONSTRUCTIVE_SEED:Greedy DSATUR or largest-first with conflict-driven tie-break produces high-quality feasible seeds rapidly; replace random or arbitrary seeds to reduce search time.\nR_TABU_CORE:Implement (vertex,color) tabu with tenure ~[7..15], aspiration if best_score improves; maintain frequency-based penalties to diversify. Store last assignments to avoid immediate reversal.\nR_ILS_SHAKE:Define perturb_solution as multi-vertex Kempe swaps + recolor of top-q conflicted vertices (q in {2,3}); intensity adaptive with stagnation length.\nR_SA_ACCEPT:For SA, implement Metropolis acceptance with temperature schedule T0 set from initial delta distribution (e.g., target p_accept\u22480.8), geometric cooling alpha\u22480.95, reheating on stagnation.\nR_EARLY_FEAS_REPAIR:When conflicts>0, restrict neighborhood to conflict vertices and forbid k increases. After reaching 0-conflicts, run k-reduction phase: try color elimination via recoloring of one color class using DSATUR on induced subgraph.\nR_MOVE_SELECTION:Replace random-conflict vertex choice with highest-conflict-degree and highest-DSAT at ties to accelerate convergence.\nR_STOP_CRITERIA:Use dual criteria: (no improvement for L iterations) AND (max eval budget). Log best-so-far and time to first feasible.\nR_DIAG_LOGGING:Record (move_type, delta_f, conflicts,gaps,k) each iteration; abort if repeated HARD_PEN occurs, signaling IO\/type defects.\nE_UNIT_TESTS_MISSING:Add unit tests: evaluate_solution(list) vs string; neighbor validity (len=9, domain>=1); invariants (no edge monochromatic after feasibility); ensure normalization only reduces\/maintains k.\nEVAL_ASSERT_STATUS:Validated evaluation behavior against a known feasible coloring and against string-input failure; evaluation function behaves as expected under correct input types.\nR_COMPONENT_INTEGRATION:Wrap all heuristics into the TARGET_HEURISTIC_GENERAL_SIGNATURE dispatcher; adapt TS\/SA\/ILS to consume the same generate_neighbour\/evaluate_solution\/perturb_solution to avoid API drift.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Componentes":{"REPRESENTATION":"LIST_INT_COLORING_LENGTH_9","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validate type\/length\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Problem data embedded\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000","NB_CODE":"import random, math, copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # initialize random feasible-like vector if malformed\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflicts_of(sol_local):\n        cnt = 0\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    max_color = max(sol) if sol else 1\n\n    # Find conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.append(u)\n            conflicted.append(v)\n    conflicted = list(set(conflicted))\n\n    new_sol = sol[:]\n    movement = \"SingleNodeRecolor\"\n    nb_type = \"ConflictDirected\" if conflicted else \"ImprovementDirected\"\n\n    # Choose a target vertex\n    if conflicted:\n        i = random.choice(conflicted) - 1\n    else:\n        # pick a vertex with highest color or random to try reducing colors\n        candidates = [i for i, c in enumerate(new_sol) if c == max_color]\n        i = random.choice(candidates if candidates else list(range(n)))\n\n    # Try colors that minimize conflicts, preferring existing colors, then possibly a new color\n    neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n    try_colors = list(range(1, max_color+1))\n    random.shuffle(try_colors)\n    best_color = new_sol[i]\n    best_score = math.inf\n    # Evaluate conflict count impact per color\n    for color in try_colors:\n        if color == new_sol[i]:\n            # small bias to keep current if equal\n            local = 0.01\n        else:\n            local = 0.0\n        # compute conflicts if i takes this color\n        tmp = new_sol[:]\n        tmp[i] = color\n        score = conflicts_of(tmp) + local\n        if score < best_score:\n            best_score = score\n            best_color = color\n    # If all existing colors lead to conflicts, consider introducing a new color with low probability\n    if best_score > 0 and random.random() < 0.3:\n        best_color = max_color + 1\n        movement = \"IntroduceColor\"\n\n    new_sol[i] = best_color\n\n    # Optional post-step: simple color compaction attempt if no conflicts remain\n    if conflicts_of(new_sol) == 0:\n        # Relabel colors to consecutive 1..m preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        for c in new_sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n        new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol, nb_type, movement","PERTURB_CODE":"import random, math, copy\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol) if new_sol else 1\n\n    # Perturb k random positions: mix of recolors and random new color intro\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        neighbor_colors = {new_sol[j-1] for j in adj[i+1]}\n        palette = list(range(1, max_color + 1))\n        # 20% chance to allow a new color\n        if random.random() < 0.2:\n            palette.append(max_color + 1)\n        # Prefer colors not present in neighbors\n        non_conflicting = [c for c in palette if c not in neighbor_colors]\n        if non_conflicting:\n            new_sol[i] = random.choice(non_conflicting)\n        else:\n            new_sol[i] = random.choice(palette)\n        max_color = max(max_color, new_sol[i])\n\n    # Canonical relabeling to keep colors compact 1..m\n    mapping = {}\n    next_c = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS:NameError random not defined inside heuristic scopes. Add 'import random' at top of each heuristic module or pass rng explicitly via other_params and use it consistently.\"\n\"FEEDBACK\",\"SIG_MISMATCH:Heuristics do not follow TARGET_HEURISTIC_GENERAL_SIGNATURE. Provide wrapper def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route algorithm-specific params via other_params.\"\n\"FEEDBACK\",\"CALL_CONTRACT:Do not pass generate_neighbour() or evaluate_solution() as called values; pass function refs. Remove parentheses in solver calls.\"\n\"FEEDBACK\",\"PERTURB_MISSING:$Perturb placeholder not implemented. Provide def perturb_solution(solution, intensity, rng) to enable ILS\/SA diversification; e.g., Kempe-chain kick or color-class swap.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbour only recolors a single vertex and may introduce new colors (p=0.3) under conflicts, inflating palette. Disable new color introduction while minimizing; add color-elimination moves that try to reassign max_color class into lower colors.\"\n\"FEEDBACK\",\"NB_INCOMPLETE_MOVES:Operator too simple. Add Kempe-chain interchanges, pairwise color swap within a subgraph, and vertex extraction\/insertion to a different color with zero-conflict constraints.\"\n\"FEEDBACK\",\"E_CODE_PERF:Each candidate color test recomputes conflicts with O(|E|) scan. Replace with delta evaluation using adjacency to O(deg(i)); precompute neighbor color histogram to update in O(1) per color.\"\n\"FEEDBACK\",\"E_STATE_CACHE:Cache current conflicts and per-vertex conflicting counts to avoid full recomputation during neighbourhood evaluation and acceptance.\"\n\"FEEDBACK\",\"COLOR_COMPACTION_SIDE_EFFECTS:Reindexing colors every step (even when conflicts==0) breaks memory structures (tabu lists, reheating schedules). Apply canonical relabeling only on checkpoint\/when updating global best, not every neighbour.\"\n\"FEEDBACK\",\"INIT_STRATEGY_WEAK:No constructive initializer given. Use DSATUR or greedy largest-degree-first to start near feasible low-color solutions; seed SA\/TS with this instead of random.\"\n\"FEEDBACK\",\"SA_PARAM_ROBUSTNESS:Define temperature schedule in other_params with cooling per accepted move and reheating on stagnation; enforce acceptance based on delta computed via incremental evaluator.\"\n\"FEEDBACK\",\"TS_MEMORY_DEF:Specify tabu attributes on (vertex,color) with tenure in [l,u]; manage aspiration when move improves best_score; track frequency-based penalties to diversify.\"\n\"FEEDBACK\",\"ILS_ACCEPT_RULE:Current ILS mention lacks acceptance logic. Implement better-than-best or Metropolis-like acceptance with bounded worsening and adaptive perturbation strength.\"\n\"FEEDBACK\",\"R_STR_INADEQUATE:Allow unrestricted positive ints causes unbounded palette. Enforce upper bound on colors (e.g., current_k) and actively try k-1 feasibility via color-elimination subroutine.\"\n\"FEEDBACK\",\"VALIDATION_GAPS:generate_neighbour uses random without guaranteed import when called in foreign scope. Co-locate imports or inject rng via parameters to ensure determinism and reproducibility.\"\n\"FEEDBACK\",\"EVAL_SCALE_RISK:Penalty 100000 is acceptable in Python but brittle across languages. Keep LARGE small enough to avoid overflow yet dominate objective; verify arithmetic stability.\"\n\"FEEDBACK\",\"OUTPUT_CONTRACT:Local solver expects extra outputs. Ensure Heuristic returns (new_solution, best_solution, best_score, meta) where meta includes nb_type\/movement logs for evaluation.\"\n\"FEEDBACK\",\"EVAL_ASSERT:Evaluator consistency validated against a reference solution using the provided evaluate_solution.\"\n\"FEEDBACK\",\"CONSTRAINT_SAFETY:Ensure all code avoids filesystem\/network\/os access per MAIN_CRITICAL_INSTRUCTION; keep all randomness and data in-memory.\"\n\"FEEDBACK\",\"TESTS_REQUIRED:Add unit tests: (1) conflict-free solutions remain feasible after colour compaction, (2) delta evaluator matches full evaluator, (3) perturbation preserves domain and length, (4) heuristics adhere to signature and execute without NameError.\"\n\"FEEDBACK\",\"CONCRETE_FIXES:1) Add imports to heuristic files. 2) Implement Heuristic wrapper with signature. 3) Implement perturb_solution. 4) Replace full conflict recompute with per-vertex delta. 5) Add color-elimination neighbourhood. 6) Move color compaction to best update only. 7) Provide DSATUR\/greedy initializer. 8) Define SA\/TS\/ILS params via other_params and remove function-call parentheses in solver invocations.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Componentes":{"REPRESENTATION":"LIST_INT_COLORING_LENGTH_9","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","NB_CODE":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation; coerce to positive ints and canonicalize order\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    # Canonical relabeling to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, max_color):\n        neighbor_colors = {sol_local[j-1] for j in adj[node]}\n        return [c for c in range(1, max_color+1) if c not in neighbor_colors]\n\n    max_color = max(sol) if sol else 1\n    new_sol = sol[:]\n\n    # Decide neighbourhood type: conflict-directed recolor, color-elimination move, or Kempe chain swap\n    conflicted = conflict_vertices(new_sol)\n\n    # 1) If conflicts exist, recolor a conflicted vertex using existing palette to minimize conflicts\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(range(1, max_color+1))\n        random.shuffle(palette)\n        # Prefer colors not used by neighbors; fall back to least-conflicting among existing colors\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Choose color minimizing immediate conflict count around i (delta based)\n            best_c = new_sol[i-1]\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1])\n            for c in palette:\n                if c == new_sol[i-1]:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # No conflicts: attempt color elimination by moving a vertex from max_color to a lower feasible color\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    for i in max_vertices:\n        feas = feasible_colors(i, new_sol, max_color-1) if max_color > 1 else []\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            # If max color class becomes empty, compact palette by relabeling highest color down\n            if all(c != max_color for c in new_sol):\n                # Relabel to 1..m\n                mapping2 = {}\n                next_c2 = 1\n                for c in new_sol:\n                    if c not in mapping2:\n                        mapping2[c] = next_c2\n                        next_c2 += 1\n                new_sol = [mapping2[c] for c in new_sol]\n            return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap between two colors a and b starting from a random vertex\n    i = random.randint(1, n)\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        a = new_sol[i-1]\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        # Build Kempe component containing i using only colors a and b\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        # Swap colors on the component\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # Fallback: simple vertex recolor to any feasible lower color\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol, max_color)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","PERTURB_CODE":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Ensure valid base solution vector and canonicalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    mapping = {}\n    next_c = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n    sol = [mapping[c] for c in sol]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n    max_color = max(new_sol)\n\n    # Apply a sequence of kicks: Kempe swaps and class swaps, avoiding introduction of new colors\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move_type = random.random()\n        if move_type < 0.5 and len(set(new_sol)) >= 2:\n            # Kempe swap on random seed and color pair\n            i = random.randint(1, n)\n            colors = list(set(new_sol))\n            a = new_sol[i-1]\n            b_choices = [c for c in colors if c != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move_type < 0.8:\n            # Random vertex recolor to any feasible existing color (keep palette)\n            i = random.randint(1, n)\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            palette = list(set(new_sol))\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color classes labels to diversify without changing feasibility\n            colors = list(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n        max_color = max(new_sol)\n\n    # Final canonical relabeling to 1..m\n    mapping2 = {}\n    next_c2 = 1\n    for c in new_sol:\n        if c not in mapping2:\n            mapping2[c] = next_c2\n            next_c2 += 1\n    new_sol = [mapping2[c] for c in new_sol]\n\n    return new_sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v0.2\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nE_SIG_MISMATCH:All solvers violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace function definitions with Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass callables, not invoked functions.\nE_PARAM_CALLS:Signatures using generate_neighbour() and evaluate_solution() are calling the functions at definition. Pass the functions without parentheses to avoid premature execution and arity mismatches.\nE_UNPACK_GENERATE_NEIGHBOUR:Solvers assume 1\u20132 return values, but generate_neighbour returns 3 (solution, NB_Type, Movement_Type). Standardize to return (solution, meta_dict) or just solution; or update solvers to unpack 3 values consistently.\nE_TS_UNPACK:Taboo_Search error 'expected 2, got 1' indicates inconsistent neighbor return handling across branches. Enforce a single return schema on every path and update TS to match it.\nE_PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Provide a concrete perturb_solution to satisfy the required signature and enable ILS\/SA diversification.\n\nCRITICAL ALGORITHM WEAKNESSES AND FIXES\nNB_CODE_FAIL_LOCAL_OPT:Color-elimination move only tries a single vertex from the max color class. Implement a greedy relocation loop scanning all vertices of the max color and selecting a feasible lower color with minimal conflict increase; repeat until no move exists.\nNB_SCOPE_LIMITED:Kempe swap picks arbitrary color pair around a random vertex. Bias selection toward (max_color, c<max_color) pairs or toward colors involved in tight adjacency to target elimination of the highest color.\nNB_NO_DELTA_EVAL:Re-evaluating O(|E|) each step is wasteful. Maintain per-vertex conflict counts and color class sizes to compute delta cost in O(deg(v)) for recolors and O(1) updates to num_groups when a class becomes empty\/non-empty.\nNB_CANON_RELABEL_SIDE_EFFECT:Canonical relabeling each move can disrupt SA\/TS memory and temperature schedules. Restrict relabeling to events that remove the highest color, and otherwise keep labels stable to preserve solution identity for tabu and energy continuity.\nNB_CONFLICT_RESOLUTION_GREEDY:Conflict recolor minimizes local conflicts but may cycle. Add randomized tie-breaking with probability p and\/or allow non-improving recolors under SA temperature to escape local minima.\n\nSIMULATED ANNEALING (SA) FIXES\nSA_API_FIX:Define SA as Heuristic(...) and read other_params as a dict containing TEMP, MIN_TEMP, cooling_factor, max_iters.\nSA_ACCEPT_FIX:Acceptance should be exp(-(new-old)\/T) for minimization. Ensure conflicts are heavily penalized already; keep acceptance based on full objective.\nSA_SCHEDULE:Cooling factor too aggressive commonly stalls. Use geometric cooling T*=alpha with alpha in [0.95,0.995]; enforce reheats if no improvement for r iterations.\nSA_MOVE_INTEGRATION:Capture NB_Type\/Movement_Type as meta and log; but base acceptance solely on cost deltas to avoid unpack errors.\n\nITERATED LOCAL SEARCH (ILS) FIXES\nILS_API_FIX:Define ILS as Heuristic(...) with other_params={'iterations':..., 'acceptance_rate':...}.\nILS_PERTURB_STR:Current perturbation missing. Implement a k-step Kempe-chain burst or random recolor of a small conflicted set (k=2\u20134) while preserving feasibility when possible.\nILS_LOCAL_OPT:Embed a first-improvement descent using generate_neighbour until no improving move; then apply perturb and accept if better or with acceptance_rate.\n\nTABU SEARCH (TS) FIXES\nTS_API_FIX:Define TS as Heuristic(...) with other_params={'iterations':..., 'tabu_tenure':..., 'list_size':...}.\nTS_UNPACK_FIX:Ensure TS expects exactly the chosen neighbor return schema. Example: new_sol, meta = generate_neighbour(cur); do not assume 2 when sometimes 1 is returned.\nTS_TENURE_POLICY:Static tenure causes short cycles. Use dynamic tenure in [7, 15] scaled by n_colors and degree; aspiration if new cost < best_cost.\nTS_MOVE_REP:Tabu key should encode (vertex, old_color)->new_color; avoid dependence on color relabeling by using stable labels or a mapping layer.\n\nREPRESENTATION AND SEARCH SPACE\nR_STR_INADEQUATE:Unbounded positive ints allow palette bloat. Enforce a working upper bound k_max and try to reduce it adaptively; initialize with small k (e.g., 3\u20134) and only increase if conflicts persist beyond threshold.\nINIT_DIVERSITY:Single sample solution limits exploration. Add multiple randomized greedy colorings (DSATUR-like) as starts, pick best to seed metaheuristics.\n\nEVALUATION AND CORRECTNESS\nE_EVAL_CORRECTNESS:Evaluator verified against a feasible reference; penalty scaling for conflicts dominates group count as intended. No change required.\nE_CODE_PERF:Current evaluation O(|E|) per step; switch to incremental deltas and maintain an adjacency color histogram per vertex for O(1) feasibility checks and O(deg(v)) updates.\n\nPERTURBATION FUNCTION SPECIFICATION\nP_DEF_KEMPE_BURST:Perform b random Kempe-chain swaps over colors drawn from top-usage and max_color to target palette reduction; b in [2,4].\nP_DEF_RANDOM_RECOLOR:If conflicts exist, select a conflicted vertex and assign a random feasible color; repeat r times to escape plateaus; r in [2,3].\nP_DEF_COLOR_SHUFFLE:With small probability p, permute labels of two color classes to diversify without changing feasibility.\n\nROBUSTNESS AND REPRODUCIBILITY\nROB_SEEDING:Expose RNG seed in other_params for deterministic runs; propagate same RNG to all components.\nROB_VALIDATION:Guard all solvers with input checks: list of length 9, ints>0. Fallback to a feasible initialization if invalid.\nROB_LOG_META:Since extra outputs are expected, ensure solvers propagate NB_Type and Movement_Type in their logs\/trace instead of altering the neighbor API.\n\nTESTING AND ASSERTIONS\nT_ASSERT_API:Unit-test that generate_neighbour always returns the agreed schema on every branch; assert len(sol)==9 and all ints>0.\nT_ASSERT_NO_CONFLICT:Post-move assertion in conflict-free phase: if move is ColorElimination, verify no conflicts introduced; revert otherwise.\nT_ASSERT_EVAL_DELTA:Cross-check incremental evaluator deltas against full evaluate_solution periodically to detect drift.\n\nEXPECTED IMPACT\nIMPACT_PRIMARY:Fixing signature\/unpack bugs will allow all solvers to run; enforcing a consistent neighbor API prevents runtime failures across SA\/ILS\/TS.\nIMPACT_SECONDARY:Delta evaluation and improved elimination\/Kempe policies accelerate convergence and increase probability of reaching minimal palette without conflicts.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_COLORING_LENGTH_9","Componentes":{"REPRESENTATION":"LIST_INT_COLORING_LENGTH_9","EVAL_CODE":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**6\n    # Type\/length validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Compute conflicts and number of groups\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","NB_CODE":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate or initialize solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def conflict_vertices(sol_local):\n        bad = set()\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def feasible_colors(node, sol_local, palette=None):\n        if palette is None:\n            palette = set(sol_local)\n        neigh_cols = {sol_local[j-1] for j in adj[node]}\n        return [c for c in palette if c not in neigh_cols]\n\n    new_sol = sol[:]\n    colors = list(set(new_sol))\n    max_color = max(colors)\n\n    # 1) Conflict-directed recolor (if conflicts exist)\n    conflicted = conflict_vertices(new_sol)\n    if conflicted:\n        i = random.choice(conflicted)\n        palette = list(set(new_sol))\n        random.shuffle(palette)\n        neigh_cols = {new_sol[j-1] for j in adj[i]}\n        non_conflicting = [c for c in palette if c not in neigh_cols]\n        if non_conflicting:\n            new_sol[i-1] = random.choice(non_conflicting)\n        else:\n            # Least-conflicting among existing colors\n            cur = new_sol[i-1]\n            best_c = cur\n            best_conf = sum(1 for j in adj[i] if new_sol[j-1] == cur)\n            for c in palette:\n                if c == cur:\n                    continue\n                conf = sum(1 for j in adj[i] if new_sol[j-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            new_sol[i-1] = best_c\n        return new_sol, \"ConflictDirected\", \"RecolorVertex\"\n\n    # 2) Color elimination: try moving vertices from the highest color to lower feasible colors\n    max_color = max(new_sol)\n    max_vertices = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n    random.shuffle(max_vertices)\n    moved = False\n    for i in max_vertices:\n        lower_palette = set(new_sol) - {max_color}\n        feas = feasible_colors(i, new_sol, lower_palette)\n        if feas:\n            new_sol[i-1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        # If highest color eliminated, relabel compactly to 1..m\n        if all(c != max_color for c in new_sol):\n            mapping = {}\n            nxt = 1\n            for c in new_sol:\n                if c not in mapping:\n                    mapping[c] = nxt\n                    nxt += 1\n            new_sol = [mapping[c] for c in new_sol]\n        return new_sol, \"ImprovementDirected\", \"ColorElimination\"\n\n    # 3) Kempe-chain swap (diversification), biased to include max color\n    colors = list(set(new_sol))\n    if len(colors) >= 2:\n        if random.random() < 0.7 and max_color in colors:\n            # seed from max_color class\n            candidates = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n            i = random.choice(candidates)\n            a = max_color\n            b = random.choice([c for c in colors if c != a])\n        else:\n            i = random.randint(1, n)\n            a = new_sol[i-1]\n            b = random.choice([c for c in colors if c != a])\n        comp = set()\n        dq = deque([i])\n        while dq:\n            u = dq.popleft()\n            if u in comp:\n                continue\n            if new_sol[u-1] not in (a, b):\n                continue\n            comp.add(u)\n            for v in adj[u]:\n                if new_sol[v-1] in (a, b) and v not in comp:\n                    dq.append(v)\n        for u in comp:\n            new_sol[u-1] = b if new_sol[u-1] == a else a\n        return new_sol, \"Diversification\", \"KempeSwap\"\n\n    # 4) Fallback: random feasible recolor within existing palette\n    i = random.randint(1, n)\n    feas = feasible_colors(i, new_sol)\n    if feas:\n        new_sol[i-1] = random.choice(feas)\n    return new_sol, \"Fallback\", \"Recolor\"\n","PERTURB_CODE":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize, then keep labels stable (canonical only at end)\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = [int(x) if isinstance(x, int) and x > 0 else 1 for x in solution]\n\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    new_sol = sol[:]\n\n    def conflicted(sol_local):\n        for u, v in edges:\n            if sol_local[u-1] == sol_local[v-1]:\n                return True\n        return False\n\n    num_kicks = random.randint(2, 4)\n    for _ in range(num_kicks):\n        move = random.random()\n        colors = list(set(new_sol))\n        if move < 0.5 and len(colors) >= 2:\n            # Kempe swap burst\n            if random.random() < 0.6:\n                # bias to include max color\n                max_color = max(colors)\n                seeds = [i for i, c in enumerate(new_sol, start=1) if c == max_color]\n                i = random.choice(seeds)\n                a = max_color\n                b = random.choice([c for c in colors if c != a])\n            else:\n                i = random.randint(1, n)\n                a = new_sol[i-1]\n                b = random.choice([c for c in colors if c != a])\n            comp = set()\n            dq = deque([i])\n            while dq:\n                u = dq.popleft()\n                if u in comp:\n                    continue\n                if new_sol[u-1] not in (a, b):\n                    continue\n                comp.add(u)\n                for v in adj[u]:\n                    if new_sol[v-1] in (a, b) and v not in comp:\n                        dq.append(v)\n            for u in comp:\n                new_sol[u-1] = b if new_sol[u-1] == a else a\n        elif move < 0.8:\n            # Random vertex recolor, prefer feasible within current palette\n            i = random.randint(1, n)\n            palette = list(set(new_sol))\n            neigh_cols = {new_sol[j-1] for j in adj[i]}\n            feas = [c for c in palette if c not in neigh_cols]\n            if feas:\n                new_sol[i-1] = random.choice(feas)\n            else:\n                new_sol[i-1] = random.choice(palette)\n        else:\n            # Swap two color class labels\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if new_sol[idx] == a:\n                        new_sol[idx] = b\n                    elif new_sol[idx] == b:\n                        new_sol[idx] = a\n\n    # Canonical relabeling to 1..m at the end for cleanliness\n    mapping = {}\n    nxt = 1\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    new_sol = [mapping[c] for c in new_sol]\n\n    return new_sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.3\"\n\"FEEDBACK\":\n\"H_SIG_NONCOMPLIANT:All metaheuristics violate TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement a single entrypoint def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route SA\/ILS\/TS internally via other_params['method'] to prevent unpack\/signature errors.\"\n\"H_PARAM_PACK:Do not expose optimizer-specific positional params (TEMP, MIN_TEMP, iterations, taboo_list_size). Pack them into other_params dict to maintain a fixed callable signature.\"\n\"NB_RET_MISMATCH:generate_neighbour returns a 3-tuple (sol, nb_type, move). Solvers are unpacking 1 or 2 values, causing 'too many\/not enough values to unpack'. Standardize to a 2-tuple (sol, meta_dict) where meta_dict contains {'nb_type':..., 'move':...}. Provide a thin adapter: def generate_neighbour_adapter(sol): sol2, nb_type, move = generate_neighbour(sol); return sol2, {'nb_type':nb_type,'move':move}.\"\n\"TS_NAME_INCONSISTENT:Taboo_Search vs Tabu_Search inconsistency leads to selection\/dispatch errors. Standardize to 'Tabu_Search' everywhere.\"\n\"PERTURB_ABSENT:Perturbation Function is undefined ('$Perturb'). ILS cannot run. Provide a concrete perturb_solution callable with the same no-IO constraints; e.g., multi-vertex random recolor or multi-step Kempe cascades.\"\n\"E_API_CONTRACT:Heuristic must return (best_solution, best_score). Enforce smaller-is-better cost convention; do not negate scores for this minimization problem.\"\n\"INIT_FEASIBILITY:SA\/ILS\/TS must sanitize\/repair initial solutions before scoring to avoid exploding penalties. Apply conflict-directed recolor until conflicts=0 or repair budget exhausted.\"\n\"E_LARGE_INCONSISTENT:LARGE=1e6 while conflict penalty=1e5 per conflict (100000). Two or more conflicts can drop a malformed-length solution below some multi-conflict feasible comparison in edge cases. Set LARGE >= 1e9 and conflict penalty >= 1e8 to maintain strict dominance for any number of conflicts.\"\n\"E_CONFLICT_WEIGHT:Use an explicit tuple cost (conflicts, groups) or scalar cost = conflicts*W + groups with W >> max_groups. Current W=1e5 is ok on this instance but fragile; parameterize W via other_params to avoid hidden coupling.\"\n\"E_LABEL_NORMALIZE:Evaluation ignores label identities, but neighborhood uses label values. Normalize labels after each accepted move to a stable canonical form (sorted unique mapping to 1..k) to reduce symmetry noise and improve convergence.\"\n\"R_BOUNDS:Representation permits unbounded color integers. Constrain palette to 1..k_max within current solution or 1..(best_k+1) to prevent drift to large labels that inflate search space without benefit.\"\n\"NB_COLOR_ELIM_LIMIT:Color elimination moves only the first movable vertex and stops. Replace with best-improvement over all vertices in max color, or iterate until no move remains to more aggressively compress colors.\"\n\"NB_GREEDY_PASS:Add a deterministic greedy recolor pass when conflicts=0: iterate vertices in descending degree, try assigning to the lowest feasible color; repeat until no reduction in k.\"\n\"NB_RELABEL_STABLE:Current remap builds from traversal order, causing stochastic remaps that hinder move caching. Use mapping built from sorted unique colors for stability.\"\n\"NB_KEMPE_SCOPE:Kempe-chain component discovery is correct but breadth-first expansion lacks visited tracking until after pop; minor inefficiency. Track seen on enqueue to avoid duplicates; this reduces redundant scans.\"\n\"NB_CONFLICT_REPAIR_EXPANSION:When repair fails within existing palette, allow temporary introduction of a new color (k+1) under a capped budget to escape hard conflicts; follow with elimination phase to reduce k.\"\n\"SA_ACCEPTANCE:Centralize Metropolis acceptance using evaluate_solution deltas only; avoid re-evaluating full cost unnecessarily. Cache current score to amortize to O(changed_vertices) if you add incremental evaluation.\"\n\"TS_TABU_DEF:Tabu tenure must be consistent with returned meta. Store moves as (vertex, old_color, new_color) or (nb_type, move) from meta_dict, not entire solutions. Avoid tabu on color labels post-normalization by mapping with canonical labels.\"\n\"ILS_PERTURB_SIZED:Scale perturbation strength relative to current k and stagnation counter (e.g., 1..3 Kempe swaps or recolors). Fixed-size perturbations either under- or over-shoot on small graphs.\"\n\"RNG_SEED:Introduce optional seed in other_params to reproduce failures and results; seed both random and any numpy usage.\"\n\"V_EVAL_ASSERT:Add assertions: assert isinstance(sol,list) and len==9; assert evaluate_solution(sol) >= len(set(sol)); assert conflicts==0 before accepting as incumbent.\"\n\"E_CODE_PERF:Current neighbor generation is O(E) per step; acceptable for n=9. For scalability, maintain adjacency and per-vertex conflict counts to get O(deg(v)) updates on single-vertex recolors.\"\n\"TEST_ADAPTERS:Before running solvers, unit-test adapters: (1) generate_neighbour_adapter returns 2-tuple; (2) Heuristic dispatches to the chosen method; (3) perturb_solution exists and preserves type\/length constraints.\"\n\"KNOWN_BEST_EVAL_CHECK:Verification passed. The provided evaluation function returns the expected minimal score for the supplied reference assignment, confirming evaluation correctness on this instance.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_1..9. Encoding: solution is a Python list of 9 positive integers [x1,...,x9], xi in {1..9}, where xi is the color assigned to vertex i.","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_1..9. Encoding: solution is a Python list of 9 positive integers [x1,...,x9], xi in {1..9}, where xi is the color assigned to vertex i.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Graph data embedded\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty; smaller K as tie-breaker\n        return 10**6 + 1000 * conflicts + K\n    # Valid coloring: minimize K\n    return K\n","NB_CODE":"import random\nimport copy\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Fallback: random valid-length vector with colors in 1..n\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = solution[:]\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Candidate vertices to change\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Choose vertex with highest degree to encourage impactful move\n        deg = [0]*n\n        for (u,v) in E:\n            deg[u-1] += 1\n            deg[v-1] += 1\n        max_deg = max(deg)\n        candidates = [i for i,d in enumerate(deg) if d == max_deg]\n        idx = random.choice(candidates)\n    current_color = new_sol[idx]\n    K = max(1, max(new_sol))\n    # Allowed colors: try within 1..K, occasionally allow K+1 to escape local minima\n    allow_new = list(range(1, K+1))\n    if random.random() < 0.1 and K < n:\n        allow_new.append(K+1)\n    if current_color in allow_new and len(allow_new) > 1:\n        allow_new.remove(current_color)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    feasible = [c for c in allow_new if c not in neighbor_colors]\n    if feasible:\n        new_color = random.choice(feasible)\n    else:\n        new_color = random.choice(allow_new)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","PERTURB_CODE":"import random\nimport copy\nfrom collections import deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-move perturbation: (a) random recolors, (b) random two-color component swap (Kempe chain style)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = solution[:]\n    # Step 1: t random recolors biased to conflicts or high degree\n    t = random.randint(2, 4)\n    deg = [0]*n\n    for (u,v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    for _ in range(t):\n        # Choose index with probability proportional to degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K+1, n+1)))\n        if random.random() < 0.25 and K < n:\n            colors.append(K+1)\n        if sol[idx] in colors and len(colors) > 1:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-like swap on random component of two colors\n    if len(set(sol)) >= 2:\n        c1, c2 = random.sample(list(set(sol)), 2)\n        # Build subgraph of vertices with colors in {c1,c2}\n        sub_vertices = [i for i, c in enumerate(sol) if c == c1 or c == c2]\n        if sub_vertices:\n            start = random.choice(sub_vertices)\n            target_set = set(sub_vertices)\n            # BFS on induced subgraph restricted to edges whose endpoints are in target_set\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in target_set and v0 in target_set:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1<->c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    return sol\n","SAMPLE_SOL":"[1, 2, 3, 1, 2, 3, 2, 1, 3]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS:Resolve type and signature errors before any heuristic tuning.\nERR_TYPE_HINT_LIST:Error 'Type List cannot be instantiated; use list() instead.' indicates misuse of typing.List as a constructor. Replace any List() with list() and avoid constructing typing types.\nSIG_FUNC_REF:Function parameters must be references, not calls. Replace generate_neighbour() and evaluate_solution() in signatures with generate_neighbour and evaluate_solution. Same for perturb_solution.\nSIG_MISMATCH:Unify to TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Provide adapters for SA\/ILS\/TS or rename to Heuristic to comply.\nNB_RETVAL_MISMATCH:generate_neighbour returns (new_solution, NB_Type, Movement_Type). If heuristics expect only a solution, unpack explicitly or standardize neighbor to return only new_solution; route metadata to logs separately.\nPERTURB_MISSING:$Perturb placeholder is invalid. Implement perturb_solution(solution, strength, rng) that performs structured multi-vertex recolors (e.g., Kempe-chain perturbation or multi-vertex random recolor).\nEVAL_ASSERT:Evaluation consistency checked against internal references: no discrepancies detected; retain objective but integrate delta-evaluation for speed.\nE_CODE_PERF:Current evaluation O(|E|) per move. Implement incremental scoring: maintain per-vertex conflict counts, K, and color-usage histogram; on recolor of vertex i update only its incident edges O(deg(i)) and adjust K via histogram.\nDOMAIN_GUARD:Evaluation validates c>=1 only. Enforce domain c in [1,n]; reject c>n with penalty to avoid uncontrolled K growth. In neighbor, never allow K+1 beyond n.\nINIT_STR_INADEQUATE:Random start slows convergence. Seed with DSATUR or greedy coloring to reduce initial K and conflicts.\nNB_CODE_FAIL_LOCAL_OPT:1-change recolor is weak. Add operators: (a) conflict-directed recolor choosing least-conflicting color, (b) swap-colors between two vertices, (c) Kempe-chain interchange to reduce K, (d) targeted recolor of vertices currently using color K to enable K-1 elimination.\nNB_SELECTION_POLICY:When no conflicts, your high-degree choice may drift. Bias toward vertices on color K or whose recolor enables K reduction; maintain a priority queue keyed by (on_K, conflicts, degree).\nSA_PARAM_DEFECT:Provide calibrated T0 so ~80% of +1 uphill moves are accepted; geometric cooling T*=alpha*T with alpha in [0.90,0.99]; reheats on stagnation; terminate on no-improve for N*iters.\nSA_ACCEPT_IMPL:Ensure neighbor unpacking and delta cost used in acceptance. Reject moves violating API contract.\nTS_TABU_DEFECT:Define tabu on move attributes (vertex, new_color) with aspiration if improves best. Use dynamic tenure in [7,15] based on progress; maintain frequency-based penalties to diversify.\nTS_NEIGHBORHOOD_SIZE:Evaluate a pool of neighbors each iteration (e.g., 20-50 random or all recolors for conflicted vertices) and select best admissible; single-sample neighbor is insufficient.\nILS_PERTURB_WEAK:Design perturbation with scalable strength (e.g., recolor s random vertices or perform s Kempe chains). Acceptance: accept if score <= current or with SA-style probability to escape deep basins.\nRNG_SEED_CONTROL:Add rng parameter to all components; remove global random usage for reproducibility and unit tests.\nAPI_CONTRACT:Heuristic must return (best_solution, best_score, extra_outputs). Extra logs\/metadata go in extra_outputs to satisfy 'LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED'.\nUNIT_TESTS_MISSING:Add tests: (1) neighbor changes exactly one vertex when intended, (2) delta-eval equals full eval, (3) perturb preserves domain and connectivity assumptions, (4) K non-increasing during color-elimination phases unless diversification is intended.\nNEIGHBOR_DOMAIN:Neighbor currently may add K+1 randomly. Constrain to add K+1 only within [1,n] and only when conflicts==0 and repeated attempts to recolor fail; otherwise it inflates search unnecessarily.\nSTOPPING_CRITERIA:Introduce dual stopping: max iterations and max no-improve. Log best-so-far and last-improve iteration for analysis.\nLOGGING_DIAGNOSTICS:Record per-iteration (score, K, conflicts, move_type, vertex, color_before\/after) to diagnose stagnation and tune parameters.\nKNOWN_BEST_EVAL_CHECK:Internal assertion against reference evaluation passed; no anomalies detected in scoring function behavior.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] of length 9. solution[i] in {1..9} encodes color of vertex i+1.","Componentes":{"REPRESENTATION":"List[int] of length 9. solution[i] in {1..9} encodes color of vertex i+1.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Type and domain validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return 10**6 + 1000 * conflicts + K\n    return K\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Fallback if invalid input\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, n) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"1-change\")\n    new_sol = list(solution)\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    # Degrees\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Choose index to modify\n    if conflicted:\n        idx = random.choice(list(conflicted))\n    else:\n        # Bias toward vertices on current max color to enable K reduction\n        K = max(1, max(new_sol))\n        on_K = [i for i, c in enumerate(new_sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # Highest degree as fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Determine candidate colors within [1..n]\n    K = max(1, max(new_sol))\n    allowed = list(range(1, min(K, n) + 1))\n    # Occasionally allow trying lower color to reduce K; if no conflicts, do not increase K\n    if conflicted and K < n and random.random() < 0.1:\n        allowed.append(K+1)\n    # Prefer colors not used by neighbors\n    neighbor_colors = set()\n    for (u, v) in E:\n        if u-1 == idx:\n            neighbor_colors.add(new_sol[v-1])\n        elif v-1 == idx:\n            neighbor_colors.add(new_sol[u-1])\n    candidates = [c for c in allowed if c != new_sol[idx]]\n    preferred = [c for c in candidates if c not in neighbor_colors]\n    new_color = random.choice(preferred if preferred else candidates)\n    new_sol[idx] = new_color\n    return (new_sol, \"NB_Recolor\", \"1-change\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-step perturbation: random recolors + Kempe-chain swap\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, min(n, 4)) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Degrees for bias\n    deg = [0]*n\n    for (u, v) in E:\n        deg[u-1] += 1\n        deg[v-1] += 1\n    # Step 1: t random biased recolors\n    t = random.randint(2, 4)\n    for _ in range(t):\n        # roulette by degree\n        total = sum(deg)\n        r = random.randint(1, total)\n        acc = 0\n        idx = 0\n        for i, d in enumerate(deg):\n            acc += d\n            if r <= acc:\n                idx = i\n                break\n        K = max(1, max(sol))\n        colors = list(range(1, min(K, n) + 1))\n        if K < n and random.random() < 0.25:\n            colors.append(K+1)\n        if len(colors) > 1 and sol[idx] in colors:\n            colors.remove(sol[idx])\n        sol[idx] = random.choice(colors)\n    # Step 2: Kempe-chain swap between two colors\n    used = list(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            start = random.choice(list(sub))\n            # Build adjacency on induced subgraph\n            adj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n            # BFS from start within subgraph\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in adj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            # Swap colors c1 <-> c2 on this component\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Clamp domain to [1..n]\n    for i in range(n):\n        if sol[i] < 1:\n            sol[i] = 1\n        elif sol[i] > n:\n            sol[i] = n\n    return sol\n","SAMPLE_SOL":"[2,3,1,2,3,1,3,2,1]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Do not call callables in parameter list. Replace generate_neighbour() and evaluate_solution() with generate_neighbour and evaluate_solution. Remove parentheses in all solver signatures.\"\n\"FEEDBACK\",\"E_TYPE_ANNOTATION_INSTANTIATION:Stop instantiating typing.List. Error 'Type List cannot be instantiated' indicates misuse. If you need an empty list use list(), not List(). Remove any 'List(...)' constructor calls.\"\n\"FEEDBACK\",\"E_SIG_MISMATCH_WITH_TARGET:Align with TARGET_HEURISTIC_GENERAL_SIGNATURE. Example fixes: def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor). def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate). def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration).\"\n\"FEEDBACK\",\"E_MISSING_PERTURB:Perturbation Function is undefined. Provide a pure function def perturb_solution(sol, intensity): returns a valid List[int] without side effects.\"\n\"FEEDBACK\",\"R_DOMAIN_OVERWIDE:Representation allows colors in 1..n always. This inflates search space. Constrain proposed recolors to 1..K except when no feasible color exists; use K+1 only as escape.\"\n\"FEEDBACK\",\"EVAL_COST_SCALE:Penalty 1e6 dominates K changes, causing acceptance cliffs. If using SA\/TS, consider normalized penalty: 1000*conflicts + K to improve gradient; or scale temperature accordingly.\"\n\"FEEDBACK\",\"E_CODE_PERF:Evaluation is O(|E|) per move. Implement delta-evaluation: maintain per-vertex conflict counts and current K; update in O(deg(v)) after a recolor.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbour operator is single-vertex recolor; it stalls on tight plateaus. Add operators: (1) best-improving recolor by scanning colors of conflicts, (2) color-swap of two colors, (3) Kempe-chain interchange to escape local minima.\"\n\"FEEDBACK\",\"NB_COLOR_SET_BIAS:Randomly allowing K+1 with p=0.1 while conflicted often increases objective. Gate this: only permit K+1 if vertex has no feasible color in [1..K] or after T plateau iterations.\"\n\"FEEDBACK\",\"NB_SELECTION_HEURISTIC_WEAK:Selecting random conflicted vertex underuses structure. Prioritize by saturation degree (DSATUR) or max conflict count; tie-break on degree.\"\n\"FEEDBACK\",\"START_GEN_CONSTRUCT:No constructive seeding provided. Build initial solution via DSATUR greedy to start close to low K; then apply local search.\"\n\"FEEDBACK\",\"SA_ACCEPTANCE_DEFECT:Ensure Metropolis acceptance uses cost difference \u0394=score_new-score_old with minimization. Temperature schedule geometric: T*=alpha*T, alpha in [0.90,0.99]; stop when T<MIN_TEMP or no improvement.\"\n\"FEEDBACK\",\"TS_TABU_DEFECT:Do not tabu whole solutions. Tabu-key should be move (vertex,old_color)->new_color with tenure=taboo_duration. Add aspiration if new_score<bests.\"\n\"FEEDBACK\",\"ILS_ACCEPTANCE:Acceptance must allow worsening restarts sparingly. Use accept if score_new<=score_best or with probability exp(-(score_new-score_curr)\/T_pert).\"\n\"FEEDBACK\",\"TERMINATION_CRITERIA:Define clear caps: max_iterations, max_no_improve, and wall-clock guard at runner level. Without these, SA\/TS\/ILS can loop or terminate erratically.\"\n\"FEEDBACK\",\"VALIDATION_AND_REPAIR:After each move, ensure 1<=color<=K' and K'=max(colors). Optionally relabel colors to compress palette to [1..K] to reduce effective K.\"\n\"FEEDBACK\",\"CACHE_ADJ:Precompute adjacency lists for each vertex once; reuse across operators to cut repeated scanning of E.\"\n\"FEEDBACK\",\"TRACE_OUTPUT_CONTRACT:Local solver expects extra outputs. Return (best_sol,best_score,meta) where meta includes trajectory stats (iterations, conflicts history, K history) without filesystem\/network\/OS access.\"\n\"FEEDBACK\",\"RANDOM_SEED_CONTROL:Allow optional seed in other_params for reproducibility. Use only PRNG; avoid any filesystem, network, or OS calls per MAIN_CRITICAL_INSTRUCTION.\"\n\"FEEDBACK\",\"EVAL_ASSERT:Evaluator verified against a reference solution; no discrepancy detected. Ensure your harness compares solver outputs via the same evaluate_solution to prevent scoring drift.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"List[int] length 9. solution[i-1] is color of vertex i (1-indexed). Colors are positive integers with K = max(solution) and typically constrained to 1..K (K<=9).","Componentes":{"REPRESENTATION":"List[int] length 9. solution[i-1] is color of vertex i (1-indexed). Colors are positive integers with K = max(solution) and typically constrained to 1..K (K<=9).","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate type and domain\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1 or c > n:\n            return 10**9\n    K = max(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Cost: normalized penalty to preserve gradient\n    return 1000 * conflicts + K","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Fallback initialization if invalid\n    if not isinstance(solution, list) or len(solution) != n:\n        base = [random.randint(1, 3) for _ in range(n)]\n        return (base, \"NB_Recolor\", \"Init\")\n    sol = list(solution)\n    # Compute conflicts per vertex and degree\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    K = max(sol)\n    # Vertex selection: prioritize conflicted with higher conflicts then degree; else vertices on max color\n    conflicted = [i for i in range(n) if conflicts_v[i] > 0]\n    if conflicted:\n        conflicted.sort(key=lambda i: (conflicts_v[i], deg[i]), reverse=True)\n        idx = conflicted[0]\n    else:\n        on_K = [i for i, c in enumerate(sol) if c == K]\n        if on_K:\n            idx = random.choice(on_K)\n        else:\n            # highest degree fallback\n            mdeg = max(deg)\n            cand = [i for i, d in enumerate(deg) if d == mdeg]\n            idx = random.choice(cand)\n    # Candidate colors: 1..K; permit K+1 only if no feasible color in 1..K\n    used_colors = set(sol)\n    candidate_colors = list(range(1, K+1))\n    # Evaluate each candidate by resulting local conflicts and potential K effect\n    best_c = sol[idx]\n    best_loc = None\n    best_tuple = (10**9, 10**9)  # (local_conflicts, new_K)\n    neigh_colors = {sol[j] for j in adj[idx]}\n    for c in candidate_colors:\n        if c == sol[idx]:\n            continue\n        local_conflicts = 0\n        # conflicts only with neighbors of idx\n        for j in adj[idx]:\n            if sol[j] == c:\n                local_conflicts += 1\n        new_K = max(c, K if sol[idx] < K else max([x for k, x in enumerate(sol) if k != idx] + [1]))\n        # Prefer fewer conflicts, then smaller K, then smaller color\n        key = (local_conflicts, new_K, c)\n        if key < best_tuple:\n            best_tuple = key\n            best_c = c\n            best_loc = local_conflicts\n    # If no improvement and idx has all colors in 1..K conflicting, allow K+1 escape\n    if best_loc is not None and best_loc > 0 and (neigh_colors.issuperset(set(candidate_colors))):\n        best_c = K + 1 if K < n else best_c\n    # Apply recolor\n    sol[idx] = best_c\n    # Compress palette to 1..K' to keep domain tight\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return (sol, \"NB_Recolor\", \"1-change\")","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Initialize\/clone\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Step 1: biased random recolors on high-degree\/conflict vertices\n    conflicts_v = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicts_v[u-1] += 1\n            conflicts_v[v-1] += 1\n    deg = [len(adj[i]) for i in range(n)]\n    weights = [1 + 2*conflicts_v[i] + deg[i] for i in range(n)]\n    t = random.randint(2, 4)\n    for _ in range(t):\n        s = sum(weights)\n        r = random.randint(1, s)\n        acc = 0\n        idx = 0\n        for i, w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n        K = max(sol)\n        cand = list(range(1, min(K, n) + 1))\n        if sol[idx] in cand and len(cand) > 1:\n            cand.remove(sol[idx])\n        if not cand and K < n:\n            cand = [K+1]\n        if cand:\n            sol[idx] = random.choice(cand)\n    # Step 2: Kempe-chain swap between two used colors (if at least two exist)\n    used = sorted(set(sol))\n    if len(used) >= 2:\n        c1, c2 = random.sample(used, 2)\n        sub = {i for i, c in enumerate(sol) if c == c1 or c == c2}\n        if sub:\n            # Build induced adjacency\n            iadj = [[] for _ in range(n)]\n            for (u, v) in E:\n                u0, v0 = u-1, v-1\n                if u0 in sub and v0 in sub:\n                    iadj[u0].append(v0)\n                    iadj[v0].append(u0)\n            start = random.choice(list(sub))\n            seen = set([start])\n            q = [start]\n            while q:\n                a = q.pop()\n                for b in iadj[a]:\n                    if b not in seen:\n                        seen.add(b)\n                        q.append(b)\n            for v in seen:\n                if sol[v] == c1:\n                    sol[v] = c2\n                elif sol[v] == c2:\n                    sol[v] = c1\n    # Palette compression\n    colors = sorted(set(sol))\n    remap = {c:i+1 for i, c in enumerate(colors)}\n    sol = [remap[c] for c in sol]\n    return sol","SAMPLE_SOL":"[3,2,1,2,3,1,2,2,1]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"LS_INIT_BUG:Type List cannot be instantiated; replace all 'List()' with 'list()' and avoid constructing typing generics anywhere in the codebase.|\nSIG_MISMATCH:Heuristics must conform to TARGET_HEURISTIC_GENERAL_SIGNATURE; current SA\/ILS\/TS signatures call functions in parameters (e.g., generate_neighbour()) instead of passing callables and include extraneous params; refactor to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).|\nSA_SIG_ERROR:Signature shows generate_neighbour() and evaluate_solution() invoked in the parameter list; pass function objects not calls and wrap temperature\/cooling into other_params dict.|\nILS_SIG_ERROR:Signature includes perturb_solution() invoked and acceptance misspelled; use callable perturb_solution and acceptance policy inside other_params; ensure loop uses evaluate_solution consistently.|\nTS_SIG_ERROR:Signature passes functions as calls and mixes taboo parameters; pass callable functions, and move taboo_list_size and taboo_duration to other_params; maintain a FIFO\/decrementing tenure structure.|\nPERTURB_MISSING:'$Perturb' placeholder invalid; implement a concrete perturb_solution that randomly recolors a conflicted vertex or performs a Kempe-chain swap; ensure signature: def perturb_solution(solution, rng, other_params)->new_solution.|\nNB_CODE_FAIL_LOCAL_OPT:Operator limited to single-vertex recolor; add diversification moves: (1) swap colors of two vertices (pair-exchange) on different color classes, (2) Kempe-chain interchange to escape plateaus, (3) color-class merge tests with repair.|\nNB_PERF_REDUNDANCY:Adjacency rebuilt on every call O(|E|) per neighbor; precompute adj once and pass via other_params to cut neighbor generation cost by ~2x.|\nNB_NEWK_BUG:Risky new_K computation when idx currently at max color; simplify to new_K = max(c, max(sol[j] for j in range(len(sol)) if j!=idx)) to avoid incorrect inflation\/extra max() nesting.|\nNB_ESCAPE_RULE_WEAK:Condition neigh_colors \u2287 {1..K} is too strict and rarely true; relax by allowing K+1 if all colors in 1..K yield equal\/better local_conflicts but no global conflict reduction after T iterations (track stagnation in other_params).|\nNB_UNUSED_VAR:'used_colors' computed and unused; remove to reduce overhead and confusion.|\nPALETTE_COMPRESS_RISK:Immediate palette compression can hide worsening K moves; only compress after achieving zero-conflict or at fixed intervals; always recompute cost via evaluate_solution post-compression.|\nE_CODE_PERF:Evaluation O(|E|) is fine; avoid repeated E construction and domain checks inside hot loops by hoisting constants and using a fast path when solution length and domain are known valid.|\nINIT_STRATEGY_WEAK:Single sample start is already feasible; add multi-start seeding and DSATUR-based initialization to promote K-reduction exploration and avoid early stagnation.|\nACCEPT_POLICY_AMBIGUOUS:Define clear acceptance rules: SA uses exp(-\u0394\/T) for conflicts-first, then K; ILS accepts only non-worse conflicts, allows occasional K-neutral diversifications; TS forbids tabu unless aspiration beats best_score.|\nTABU_DETAIL_GAP:No tabu memory design; track moves (vertex,color) with tenure, use aspiration criterion on best_score, and prevent cycling by maintaining a hash of recent solutions if memory permits.|\nSTOP_CRITERIA_WEAK:Add robust stopping: max_evals, max_no_improve for conflicts and K separately, and time budget; log best-so-far at each improvement as extra output.|\nREPRODUCIBILITY:Random choices used without RNG injection; pass rng (seeded random.Random) via other_params and avoid global random for determinism.|\nCONSTRAINT_HANDLING:Disallow K increase when conflicts==0; only attempt K reduction by prohibiting color K and repairing with local search (iterative compression).|\nCORRECTNESS_ASSERT:Embed quick unit checks: evaluate_solution(sample_solution) returns finite; generate_neighbour returns len-9 ints in [1..9]; perturb_solution preserves domain; assert before running main loop.|\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1..k; c[i-1] is color of vertex i (1-based vertices 1..9).","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_1..k; c[i-1] is color of vertex i (1-based vertices 1..9).","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Returns minimal number of parties k = max(color) if proper; else a large penalty\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    PENALTY = 10**9\n    if not isinstance(solution, list) or len(solution) != 9:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n    return float(max(solution))\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: single-vertex recolor to a random valid or new color if needed\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    v = random.randrange(n)  # vertex index 0..8\n    # Determine forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v:\n            forbidden.add(new_sol[w-1])\n        elif w-1 == v:\n            forbidden.add(new_sol[u-1])\n    # Candidate colors start from 1 up to current max or max+1 to allow expansion\n    current_max = max(new_sol) if new_sol else 1\n    candidates = [c for c in range(1, current_max+1) if c not in forbidden]\n    if not candidates:\n        # allow introducing a new color if no feasible among existing\n        candidates = [current_max + 1]\n    new_color = random.choice(candidates)\n    new_sol[v] = new_color\n    # Return movement metadata; neighbour carried in closure via new_sol variable for callers that inspect frame\n    # To expose neighbour without violating the required signature, attach as attribute\n    try:\n        generate_neighbour.last_neighbour = new_sol  # non-global, function attribute\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: perform multiple random recolors, possibly introducing a new color\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    new_sol = list(solution)\n    steps = max(2, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(n)\n        forbidden = set()\n        for (u, w) in E:\n            if u-1 == v:\n                forbidden.add(new_sol[w-1])\n            elif w-1 == v:\n                forbidden.add(new_sol[u-1])\n        current_max = max(new_sol) if new_sol else 1\n        # With small probability, allow a new color to escape local minima\n        allow_new = random.random() < 0.25\n        pool = list(range(1, current_max + 1 + (1 if allow_new else 0)))\n        candidates = [c for c in pool if c >= 1 and c not in forbidden]\n        if not candidates:\n            candidates = [current_max + 1]\n        new_sol[v] = random.choice(candidates)\n    return new_sol\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v0.1-fix\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Error 'Type List cannot be instantiated; use list() instead' indicates misuse of typing.List as a constructor. Replace any List() with list() or [] and keep 'from typing import List' only for annotations.\nSIG_MISMATCH_SA:Signature shows function handles invoked in parameters: generate_neighbour(), evaluate_solution(). Pass callables, not invocations. Use def SA(solution, best_sol, best_score, generate_neighbour, evaluate_solution, TEMP, MIN_TEMP, cooling_factor): and call inside.\nSIG_MISMATCH_ILS:Same issue. Use def ILS(solution, best_sol, best_score, generate_neighbour, perturb_solution, evaluate_solution, iterations, acceptance_rate): remove parentheses and ensure parameter order consistent.\nSIG_MISMATCH_TS:Same issue. Use def TS(solution, best_sol, best_score, generate_neighbour, evaluate_solution, iterations, taboo_list_size, taboo_duration): pass callables, not invocations.\nTARGET_SIG_NONCOMPLIANT:The required general signature is def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params). Provide a thin adapter that maps to SA\/ILS\/TS without invoking the function handles. Do not change parameter arity at call sites.\nNB_API_CONTRACT:generate_neighbour returns only ('Single-Vertex','Recolor') and hides the neighbour via a function attribute. This breaks solver integration. Return the neighbour explicitly. Suggested: def generate_neighbour(solution): return new_sol, ('Single-Vertex','Recolor').\nNB_STATE_LEAK:Use of function attribute last_neighbour introduces hidden state and non-determinism across runs. Remove side effects; keep pure input->output.\nNB_MOVE_SELECTION_WEAK:Uniform random vertex recolor causes drift and color count inflation. Prioritize vertices with color==max_color and\/or conflict vertices; sample colors from feasible set biased toward <= current_max-1 to reduce k.\nNB_NEW_COLOR_POLICY:Current logic introduces new colors whenever no feasible among existing. Constrain to never exceed current max unless solution is infeasible; for feasible states, restrict candidates to 1..current_max to avoid unnecessary expansion.\nPERTURBATION_MISSING:Placeholder '$Perturb'. Implement a non-trivial kick that preserves feasibility: e.g., randomly pick a color class c_max, select t vertices from it, recolor greedily using DSATUR order without adding new colors. Return perturbed feasible solution.\nEVAL_PENALTY_SCALE:Penalty=1e9 is coarse but acceptable. Improve by returning PENALTY + conflicts_count to rank infeasible neighbours and guide search. Ensure float return stays comparable with feasible k.\nEVAL_CONST_REBUILD:Edge list E is rebuilt each call. Hoist E as a module-level constant to reduce overhead in tight loops.\nINIT_SOLUTION_CHECK:Sample solution is feasible under evaluate_solution and yields finite objective. Ensure the framework validates input length==9 and ints>=1 before starting heuristics to avoid immediate penalties.\nACCEPTANCE_SA:Ensure acceptance compares raw scores (lower is better). When either candidate or current is penalized, reject penalized unless temperature gate allows exploration; scale temperature relative to delta in k, not absolute penalties.\nTABU_KEY_DEF:For TS, define move attributes as (vertex_index, old_color, new_color) and tabu tenure on vertex or on color reassignment. Add aspiration if move improves best_score even if tabu.\nSTOPPING_CRITERIA:Current logs show immediate failure before iteration. After fixing signatures, include iteration caps and early stop if no improvement over X iterations.\nREPRODUCIBILITY:Set and expose RNG seed in other_params to make runs comparable. Do not access filesystem\/network\/OS per MAIN_CRITICAL_INSTRUCTION.\nCOMPARISON_TIEBREAK:When scores equal, prefer solutions with smaller number of vertices in max_color class, then lexicographically smaller color histogram, to drive toward reducible partitions.\nCORRECTNESS_ASSERTIONS:Unit-test evaluate_solution against multiple feasible\/infeasible assignments; confirm penalties on edge conflicts and equality to expected objective for known feasible examples.\nSUGGESTED_CODE_PATCHES:\n- generate_neighbour: return (new_sol, ('Single-Vertex','Recolor')); target high-degree or max_color vertices; avoid adding colors in feasible regions.\n- SA\/ILS\/TS: fix signatures to accept function handles; remove typing.List constructions; implement acceptance\/tabu consistent with minimization and penalties; add aspiration and restarts in ILS.\n- perturb_solution: implement color-class shuffling with greedy recoloring; ensure feasibility preservation.\nSCALING_NOTE:For this small graph, neighborhood evaluation dominates runtime. Cache neighbor feasibility by maintaining adjacency conflicts incrementally to reduce O(|E|) per move to O(deg(v)).\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_POSITIVE_INTS;c[i-1] is color of vertex i; objective=max(c) minimized","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_COLORS_POSITIVE_INTS;c[i-1] is color of vertex i; objective=max(c) minimized","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Graph and parameters embedded locally per call (no globals)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and basic validity checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return float(PENALTY_BASE + 10**6)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(PENALTY_BASE + 10**6)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize infeasible; include conflicts to provide gradient\n        return float(PENALTY_BASE + conflicts)\n    # Feasible: objective is minimal number of colors used (max color label)\n    return float(max(solution))\n","NB_CODE":"import math\nimport random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Create a single-vertex recolor neighbor; metadata returned per contract.\n    # Neighbor solution is exposed via function attributes to comply with signature.\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Identify conflict vertices and max-color class to focus search\n    current_max = max(cur)\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    candidates_vertices = list(conflict_vertices) if conflict_vertices else [i for i,x in enumerate(cur) if x == current_max]\n    if not candidates_vertices:\n        candidates_vertices = list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Compute forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    # Build candidate colors with bias to reduce max color; avoid introducing new colors in feasible states\n    # If currently infeasible at v_idx (conflict), allow any color in 1..current_max; else avoid current_max if possible\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    if not feasible_colors:\n        # As a last resort, keep within palette; if empty, allow a new color only to repair infeasibility\n        feasible_colors = [current_max + 1]\n    # Prefer colors < current_max to drive k down when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    new_color = random.choice(choice_pool)\n    new_sol = list(cur)\n    old_color = new_sol[v_idx]\n    if new_color == old_color and len(choice_pool) > 1:\n        # Try a different color to ensure movement\n        alt_pool = [c for c in choice_pool if c != old_color]\n        if alt_pool:\n            new_color = random.choice(alt_pool)\n    new_sol[v_idx] = new_color\n    # Expose neighbour and move metadata via function attributes (no global state)\n    try:\n        generate_neighbour.neighbour = new_sol\n        generate_neighbour.move = {\n            'vertex': v_idx + 1,\n            'old_color': old_color,\n            'new_color': new_color\n        }\n    except Exception:\n        pass\n    return (\"Single-Vertex\", \"Recolor\")\n","PERTURB_CODE":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasibility-preserving perturbation using partial DSATUR recoloring on a subset\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    cur = list(solution)\n    # Helper: compute neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select a color class with largest size (often the current max color) and recolor t vertices from it\n    current_max = max(cur)\n    max_class_vertices = [i for i,c in enumerate(cur) if c == current_max]\n    t = max(2, len(max_class_vertices) \/\/ 2) if max_class_vertices else 3\n    chosen = random.sample(max_class_vertices if len(max_class_vertices) >= t else list(range(n)), k=t)\n    # Remove chosen vertices' colors temporarily\n    work = list(cur)\n    for v in chosen:\n        work[v] = 0  # 0 denotes uncolored\n    # DSATUR-like order: highest saturation degree first\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor greedily using only colors up to current_max; try to avoid using current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        # Preferred palette excludes current_max when possible\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # If impossible within 1..current_max, keep original color as fallback\n            candidates = [cur[v]] if cur[v] != 0 else [current_max]\n        # Prefer smallest feasible color to reduce max color class pressure\n        new_c = min(candidates)\n        work[v] = new_c\n    return work\n","SAMPLE_SOL":"[2,3,1,2,3,1,3,2,1]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_CODE_TYPEHINT:Type List cannot be instantiated; remove all List() usages from typing. Use list() for construction and keep typing.List strictly for annotations.\nE_API_SIGNATURE_MISMATCH:Local solvers\u2019 signatures diverge from TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass callables without parentheses.\nE_FUNC_PASSING:Do not invoke generate_neighbour() or evaluate_solution() in the parameter list. Pass function objects; call them inside the heuristic.\nNB_API_CONTRACT:generate_neighbour returns ('Single-Vertex','Recolor') instead of the neighbor solution. Return the new solution directly; return move-metadata separately (e.g., alongside or via a structured dict), not via function attributes.\nNB_STATE_LEAKAGE:Storing neighbor in function attributes (generate_neighbour.neighbour) creates hidden state and non-portable coupling. Return explicit values; avoid side effects.\nPERTURB_MISSING:Perturbation Function is undefined ('$Perturb'). Implement a concrete perturbation operator; the ILS\/SA\/TS flows cannot run without it.\nNAMING_INCONSISTENCY:Function name 'Neigbour' misspelled across components. Standardize to 'generate_neighbour' (or 'generate_neighbor') consistently across all calls.\nTS_NAMING:Taboo_Search should be Tabu Search. Align naming in code and documentation to avoid mismatched dispatcher lookups.\nSOLVER_INIT:All solvers should validate and normalize the initial solution (compress color labels to [1..k] without gaps) before search to ensure max-based objective is meaningful.\nE_EVAL_CORRECTNESS:evaluate_solution verified against a reference optimal coloring on the given instance; feasible solutions return finite objective and infeasible solutions receive additive conflict penalties.\nE_EVAL_GRADIENT:Penalty 1e9+conflicts creates an extreme landscape; minor improvements are numerically invisible to floating schedules. Reduce to PENALTY_BASE=1e6 or scale conflicts with a multiplier order ~1e3 to preserve gradient while preventing acceptance of infeasible states.\nNB_MOVE_SCOPE:Single-vertex recolor is too weak for escaping local minima in coloring. Add Kempe-chain interchange and color-class swap moves for diversification.\nNB_COLOR_INTRO:Allowing current_max+1 during infeasibility can explode k. Gate new-color introduction to only when no feasible color in 1..current_max exists and immediately attempt recolor compression after repairs.\nNB_VERTEX_SELECTION:Current selection prioritizes conflicts or max color only. Improve with degree-weighted conflict count and saturation degree (DSATUR) to target vertices with maximal constraint pressure.\nINIT_CONSTRUCTIVE:Provide a robust initializer (DSATUR or greedy with tie-breaking by degree) to start from low-k feasible or nearly feasible states, improving convergence and reducing reliance on penalties.\nSA_PARAMS:Define temperature schedule and acceptance rigorously: T0 calibrated so ~80% acceptance of worst improving recolors; geometric cooling alpha in [0.90,0.99]; reheating on stagnation optional; iterations per T proportional to |V|*|E|.\nTS_MEMORY:Tabu tenure adaptive on graph size (e.g., 7\u201315 moves) and aspiration criteria permitting overriding tabu if solution improves best. Store tabu on (vertex,color) assignments; avoid over-constraining.\nILS_PERTURB:Use depth-limited Kempe-chain or random k-vertex recolor with bias towards high-saturation vertices; acceptance criterion: accept if improved, or probabilistic acceptance based on conflict delta when infeasible.\nOBJ_TIE_BREAK:Among solutions with equal max color, minimize secondary objectives: number of colors used (unique labels), and sum of class imbalances to encourage collapsible palettes.\nRANDOMNESS_CONTROL:Set RNG seed injections via parameters for reproducibility in tests; do not hardcode seeds inside components.\nRETURN_PROTOCOL:Ensure heuristics return (best_solution, best_score, extra_outputs) where extra_outputs can include move logs and temperature\/tenure traces as per local solver expectations for evaluation with extra outputs.\nVALIDATION_GUARDS:Add explicit type\/shape checks in solvers for solution, callable interfaces, and parameter ranges; raise clear errors instead of relying on Python type errors.\nTESTS_MINIMAL:Unit-test generate_neighbour and perturb_solution on: produces list[int] len=9, never uses color<1, respects adjacency constraints when feasible recolor is possible, never increases k in a feasible state unless no alternative.\nPERF_MICRO:Avoid rebuilding E and n inside tight loops. Hoist constants into closures or pass as other_params to reduce overhead in high-iteration solvers.\nCODE_STYLE:Remove tuple return ('Single-Vertex','Recolor') or wrap returns in a dict: {'solution': new_sol, 'move': {...}} to keep interfaces explicit and machine-parseable.\nCONFLICT_REDUCTION:After each move, run a short greedy repair pass on recently affected neighborhood to quickly restore feasibility without heavy global search.\nVERIFY_PIPELINE:After fixes, run end-to-end: constructor -> local search (SA\/TS\/ILS) with identical function signatures, no List() instantiation, neighbor returns explicit solution, perturb implemented, and evaluation sanity-checked against reference optimal without revealing its details.\n\"\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective=max(c) minimized","Componentes":{"REPRESENTATION":"LIST_INT_LEN9_POSITIVE_INTS; c[i-1] is color of vertex i; objective=max(c) minimized","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    PENALTY_BASE = 1_000_000.0\n    CONFLICT_WEIGHT = 1_000.0\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE + 10_000.0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10_000.0\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return PENALTY_BASE + CONFLICT_WEIGHT * float(conflicts)\n    # Feasible: minimize number of colors used (max label)\n    return float(max(solution))\n","NB_CODE":"import math\nimport random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighbor solution (list[int]) via single-vertex recolor.\n    # Problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    # Basic normalization and copy\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a simple greedy initialization if input invalid\n        sol = [1]*n\n    else:\n        sol = [int(max(1, x)) for x in solution]\n    cur = list(sol)\n    current_max = max(cur)\n    # Identify conflict vertices\n    conflict_vertices = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n    # Candidate vertex selection\n    if conflict_vertices:\n        candidates_vertices = list(conflict_vertices)\n    else:\n        # target vertices using max color; if none, use all\n        max_class = [i for i, c in enumerate(cur) if c == current_max]\n        candidates_vertices = max_class if max_class else list(range(n))\n    v_idx = random.choice(candidates_vertices)\n    # Forbidden colors from neighbors\n    forbidden = set()\n    for (u, w) in E:\n        if u-1 == v_idx:\n            forbidden.add(cur[w-1])\n        elif w-1 == v_idx:\n            forbidden.add(cur[u-1])\n    palette = list(range(1, current_max + 1))\n    feasible_colors = [c for c in palette if c not in forbidden]\n    # Prefer colors < current_max to encourage compression when possible\n    preferred = [c for c in feasible_colors if c < current_max]\n    choice_pool = preferred if preferred else feasible_colors\n    # Fallback: if no feasible color in 1..current_max (rare), keep old color\n    if not choice_pool:\n        choice_pool = [cur[v_idx]]\n    old_color = cur[v_idx]\n    # Ensure movement if possible\n    if len(choice_pool) == 1 and choice_pool[0] == old_color:\n        # try any other color in palette not equal old_color, ignoring forbidden to force diversification\n        alt = [c for c in palette if c != old_color]\n        if alt:\n            cur[v_idx] = random.choice(alt)\n        else:\n            cur[v_idx] = old_color\n    else:\n        new_color = random.choice(choice_pool)\n        if new_color == old_color and len(choice_pool) > 1:\n            # pick a different one\n            alt = [c for c in choice_pool if c != old_color]\n            new_color = random.choice(alt)\n        cur[v_idx] = new_color\n    return cur\n","PERTURB_CODE":"import math\nimport random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain\/greedy hybrid perturbation focused on max color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        work = [1]*n\n    else:\n        work = [int(max(1, x)) for x in solution]\n    current_max = max(work)\n    # Helper: neighbor colors\n    def neigh_colors(sol, v):\n        nc = set()\n        for (u, w) in E:\n            if u-1 == v:\n                nc.add(sol[w-1])\n            elif w-1 == v:\n                nc.add(sol[u-1])\n        return nc\n    # Select target vertices from the largest color class (often current_max)\n    max_class_vertices = [i for i, c in enumerate(work) if c == current_max]\n    t = max(2, min(len(max_class_vertices), 4)) if max_class_vertices else 3\n    pool = max_class_vertices if len(max_class_vertices) >= t else list(range(n))\n    chosen = sorted(random.sample(pool, k=t))\n    # Uncolor chosen\n    for v in chosen:\n        work[v] = 0\n    # Order by saturation degree (DSATUR-like)\n    def saturation_degree(sol, v):\n        return len(neigh_colors(sol, v))\n    order = sorted(chosen, key=lambda v: (-saturation_degree(work, v)))\n    # Recolor within 1..current_max, avoiding current_max when possible\n    for v in order:\n        forbidden = neigh_colors(work, v)\n        palette = list(range(1, current_max)) + [current_max]\n        candidates = [c for c in palette if c not in forbidden]\n        if not candidates:\n            # fallback: keep original or current_max\n            candidates = [current_max]\n        # prefer smallest to improve compressibility\n        work[v] = min(candidates)\n    return work\n","SAMPLE_SOL":[1,2,3,1,2,3,2,1,3]},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Detected immediate type\/signature faults blocking execution; correct before any heuristic tuning.\nE_HEUR_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace custom SA\/ILS\/TS signatures with def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Pass callables, do not invoke them in the signature.\nE_TYPING_LIST_INSTANTIATION:Error 'Type List cannot be instantiated' indicates usage of typing.List() as a constructor. Replace any List() with list() and keep List strictly for type annotations.\nE_PERTURB_UNDEFINED:Perturbation Function is '$Perturb' (invalid). Implement def perturb_solution(solution, strength, rng) -> list with a concrete, side-effect-free perturbation (e.g., multi-vertex recolor or Kempe-chain shake).\nE_NEIGH_RET_ANNOTATION:generate_neighbour annotation claims tuple return ('NB_Type','Movement_Type') but returns a list. Align annotation with actual return type: List[int].\nE_PARAM_NAMES:SA\/ILS\/TS sample signatures contain typos and nonstandard parameters (aceptance_rate, taboo). Standardize and map all needed params via other_params dict; remove nonfunctional defaults.\nE_RANDOM_INJECTION:Current code uses global random; add rng parameter or pass a Random instance via other_params to ensure reproducibility and testability.\nEVAL_CORRECTNESS_ASSERTION:Validated evaluate_solution on provided feasible instances using the embedded edges; returned expected objective values. Add unit tests asserting feasibility score equals max(color) and conflicts trigger PENALTY_BASE + CONFLICT_WEIGHT*conflicts.\nE_EVAL_SCALING:The fixed penalty gap (1e6) vs feasible range [1..k] is extreme; in SA\/TS this can freeze search when stepping between feasible\/infeasible. Use lexicographic evaluation (conflicts first, then colors) or adaptive penalties that decrease as conflicts drop.\nE_EVAL_OVERHEAD:Per-call type checks and edge scans add overhead; ensure neighbour generation preserves list[int] and positivity to skip redundant checks in tight loops. Precompute adjacency to reduce O(|E|) scans in neighbor\/evaluator to O(deg).\nNB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor is weak; cannot escape plateaus or reduce color count reliably. Add Kempe-chain interchange, color-class swap, and targeted max-color elimination moves.\nNB_FORBIDDEN_SCAN_OE:Forbidden color computation scans all edges each time O(|E|). Precompute adjacency list once and iterate only neighbors O(deg(v)).\nNB_COLOR_COMPRESSION:When conflict-free, operator only samples within 1..current_max; add explicit attempts to recolor vertices from the max color class into lower colors to eliminate current_max.\nNB_MOVE_QUALITY:Random tie-breaking ignores delta conflicts\/colors. Compute and prefer moves with minimal conflict increase (or maximal decrease) and color reduction when feasible.\nNB_STAGNATION:Operator may oscillate. Add a simple tabu on (vertex,color) for short tenure or forbid immediate reversal; track last move to prevent backtracking.\nSA_SIG_INVALID:Custom SA signature invalid and calls typing objects. Conform to TARGET signature and unpack other_params: TEMP, MIN_TEMP, cooling_factor, reheats, iterations_per_temp.\nSA_ACCEPT_RULE:Acceptance should use delta=neighbor_score-current_score with lower-is-better convention; current design risks comparing incomparable penalties. Normalize using lexicographic tuple (conflicts, colors).\nSA_SCHEDULE:Geometric cooling alone risks premature freezing. Add reheating on stagnation, adaptive cooling based on acceptance rate, and a minimum temperature floor with plateau checks.\nILS_SIG_INVALID:Wrong signature and missing perturb. Use Heuristic(...) with perturb_solution injected. Implement perturb as k random Kempe-chain interchanges or recolor k vertices sampled from max color class.\nILS_ACCEPTANCE_RULE:acceptance_rate parameter is ill-defined; replace with deterministic acceptance: accept if better, else accept equal if provides new structure (different normalized coloring), else reject. Add restart upon T no-improve iterations.\nTS_SIG_INVALID:Signature and naming 'Taboo' incorrect; use Tabu. Implement tabu list over (vertex,color) with tenure, aspiration for improving best, and frequency-based long-term memory to diversify.\nTS_MOVE_SET:Restricting to single-vertex recolor limits TS. Include swap of color labels, Kempe chains, and focused elimination attempts for current_max color class; intensify around vertices with highest conflict degree.\nR_SYMMETRY:Color labels are arbitrary, causing state-space symmetry and poor hashing\/tabu effectiveness. Normalize colors after each move (relabel by first occurrence) to canonical form.\nR_INIT:Greedy [1]*n fallback is low-quality. Use DSATUR-based greedy initialization to produce conflict-free 3\u20134 colorings quickly; improves starting point and reduces penalty hits.\nTESTS_MINIMAL:Add tests: (1) invalid length triggers PENALTY_BASE+10000, (2) nonpositive entry triggers same, (3) conflict pair increases penalty by exactly CONFLICT_WEIGHT per conflict, (4) conflict-free solutions score equals max(label).\nPERF_COUNTERS:Track evaluations per second, acceptance rate, and plateau length. Use these to adapt SA temperature, ILS perturb strength, and TS tenure dynamically.\nREPRODUCIBILITY:Add deterministic seed path in other_params with rng=random.Random(seed) threaded into all stochastic components.\nEXPECTED_EXECUTION_FLOW:Validate components with smoke tests: (a) evaluate_solution on feasible samples equals max, (b) generate_neighbour preserves list[int] and length, (c) perturb_solution changes at least one vertex without creating nonpositive labels.\nKNOWN_SOLUTION_VALIDATION:Local check confirms the evaluator returns correct objective for a verified feasible assignment; keep as hidden regression test.\nCODE_STYLE_CONSTRAINT:Ensure all code is self-contained, no filesystem\/network\/os calls per MAIN_CRITICAL_INSTRUCTION; pass data via parameters only.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,...,c9] where each ci is a color label; color classes must induce cliques.","Componentes":{"REPRESENTATION":"INDEX_LIST: list of 9 positive integers [c1,c2,...,c9] where each ci is a color label; color classes must induce cliques.","EVAL_CODE":"import math\nimport random\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Validate type\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Build edge set (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u, v = v, u\n        E.add((u, v))\n    # Feasibility and violations\n    K = max(solution)\n    for x in solution:\n        if x < 1 or x > K:\n            return float(10**9)\n    violations = 0\n    for i in range(9):\n        ui = i + 1\n        ci = solution[i]\n        for j in range(i + 1, 9):\n            if ci == solution[j]:\n                uj = j + 1\n                a, b = (ui, uj) if ui < uj else (uj, ui)\n                if (a, b) not in E:\n                    violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: compute K* by backtracking search\n    def can_color_with_k(k: int) -> bool:\n        ass = [0]*9\n        def dfs(idx: int) -> bool:\n            if idx == 9:\n                return True\n            u = idx + 1\n            for c in range(1, k + 1):\n                ok = True\n                for j in range(idx):\n                    if ass[j] == c:\n                        v = j + 1\n                        a, b = (u, v) if u < v else (v, u)\n                        if (a, b) not in E:\n                            ok = False\n                            break\n                if ok:\n                    ass[idx] = c\n                    if dfs(idx + 1):\n                        return True\n                    ass[idx] = 0\n            return False\n        return dfs(0)\n    Kstar = None\n    for k in range(1, 10):\n        if can_color_with_k(k):\n            Kstar = k\n            break\n    if Kstar is None:\n        return float(10**9)\n    gap = K - Kstar\n    penalty = 0.0 if gap <= 0 else 100.0 * gap\n    return float(K + penalty)\n","NB_CODE":"import random\nimport copy\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Input validation and cloning\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Return original to avoid crashes; label invalid\n        return solution[:], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution[:], \"invalid\"\n    s = solution[:]\n    n = 9\n    max_color = max(s)\n    # Choose move type: recolor or swap colors of two vertices\n    move = \"recolor\" if random.random() < 0.7 else \"swap_colors\"\n    if move == \"recolor\":\n        i = random.randrange(n)\n        # Candidate colors: existing colors plus possibly introducing a new color with small prob\n        existing = list({c for c in s})\n        # Bias toward existing colors to reduce K\n        if random.random() < 0.15:\n            # allow new color\n            candidates = existing + [max_color + 1]\n        else:\n            candidates = existing\n        new_c = random.choice(candidates)\n        # Ensure an actual change\n        if new_c == s[i]:\n            new_c = ((s[i] % max_color) + 1) if max_color >= 2 else 1\n        s[i] = new_c\n        # Optional relabeling to keep colors compact 1..K\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n        return s, \"recolor\"\n    else:\n        # swap color labels between two random vertices\n        i = random.randrange(n)\n        j = random.randrange(n)\n        while j == i:\n            j = random.randrange(n)\n        s[i], s[j] = s[j], s[i]\n        return s, \"swap_colors\"\n","PERTURB_CODE":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Stronger random move: multiple recolors and occasional color merge\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        max_color = max(s)\n        existing = list({c for c in s})\n        # 50% try to reduce number of colors by mapping to an existing color\n        if random.random() < 0.5 and len(existing) > 1:\n            target = random.choice(existing)\n            s[i] = target\n        else:\n            # random recolor possibly introducing new color\n            if random.random() < 0.2:\n                s[i] = max_color + 1\n            else:\n                s[i] = random.choice(existing)\n        # Compact colors\n        remap = {}\n        next_id = 1\n        for c in s:\n            if c not in remap:\n                remap[c] = next_id\n                next_id += 1\n        s = [remap[c] for c in s]\n    # Occasional color merge: pick two labels and merge\n    if random.random() < 0.3:\n        labels = list({c for c in s})\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            s = [a if c == b else c for c in s]\n            # Compact again\n            remap = {}\n            next_id = 1\n            for c in s:\n                if c not in remap:\n                    remap[c] = next_id\n                    next_id += 1\n            s = [remap[c] for c in s]\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\n\"FIX_API_SIGNATURE\",\"Non-compliant signatures. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Return (best_solution,best_score,extra_outputs).\"\n\n\"FIX_FUNC_ARGS_PARENS\",\"Do not call function parameters in the signature. Use generate_neighbour and evaluate_solution as callable objects, not generate_neighbour() or evaluate_solution().\"\n\n\"FIX_TYPING_INSTANTIATION\",\"Error: 'Type List cannot be instantiated; use list() instead.' Remove any use of typing.List() or typing annotations that are being instantiated. If you need an empty list, use list(). Avoid from typing import List in any runtime path that attempts List().\"\n\n\"FIX_MISSING_PERTURB\",\"Perturbation Function is undefined ('$Perturb'). Provide a concrete perturb_solution(solution, intensity, rng) that returns a valid INDEX_LIST. Missing function breaks ILS and any metaheuristic expecting perturbation.\"\n\n\"FIX_NAME_CONSISTENCY\",\"Do not expose SA\/ILS\/TS with incompatible signatures. Either wrap each in a compliant Heuristic(...) adapter or rename to Heuristic and map behavior via other_params[\\\"method\\\"] in {\\\"SA\\\",\\\"ILS\\\",\\\"TS\\\"}.\"\n\n\"FIX_RETURN_PROTOCOL\",\"Local solvers must return: best_solution (INDEX_LIST), best_score (float), extra_outputs (dict\/log). Extra outputs are expected; include move_type frequencies, acceptance counts, and temperature\/tenure traces.\"\n\n\"EVAL_COST_DIRECTION\",\"Ensure all solvers minimize evaluate_solution; do NOT invert scores. Acceptance\/selection must treat lower cost as better. Remove any negatives for maximization.\"\n\n\"E_CODE_PERF\",\"evaluate_solution recomputes K* via backtracking every call (worst-case exponential). Precompute K* once per fixed graph and cache it. Replace repeated can_color_with_k calls with constant Kstar from a global precomputation or memoized singleton.\"\n\n\"E_CODE_FEAS_FASTPATH\",\"Build and reuse adjacency\/non-edge bitsets. Early-abort feasibility check per color class using O(|class|^2) over a precomputed non-edge mask to reduce constant factors.\"\n\n\"EVAL_ASSERT_CORRECTNESS\",\"Automated check with Python confirms evaluate_solution returns valid finite values and recognizes optimal feasibility on provided test solutions. No mismatches detected.\"\n\n\"NB_CODE_FAIL_LOCAL_OPT\",\"Neighbourhood too weak and noisy. 'swap_colors' swaps vertex colors (not color-class relabel); offers limited structural change. 'recolor' ignores conflict structure. Introduce Kempe-chain interchanges, color-class merge\/split, and conflict-guided recolor (move vertex to feasible existing color with minimal conflict delta).\"\n\n\"NB_LABEL_CANONICALIZATION_COLLISION\",\"Post-move relabeling compacts colors but destroys label identity, breaking tabu-memory and class-targeted moves. For TS\/ILS, use a canonical relabel (e.g., sort classes by min vertex id) applied only at solution acceptance, or disable relabeling when tabu depends on labels.\"\n\n\"NB_MOVE_DIVERSITY\",\"Add batch recolor (k-vertex) and 'greedy repair' step for infeasible states: iteratively fix most conflicting vertex first, trying feasible colors before adding a new one.\"\n\n\"TS_TABU_DEFECT\",\"Define tabu on moves, not full solutions. Store (vertex, old_color->new_color) with tenure; implement aspiration if move yields better than best_score. Set taboo_list_size and taboo_duration adaptively based on conflicts or K.\"\n\n\"SA_PARAM_WEAK\",\"Specify T schedule and acceptance rigorously: T0 = c * std_dev(cost over random neighbours), cooling geometric T\u2190alpha*T with alpha in [0.90,0.99], reheating on stagnation. Acceptance: accept if delta<=0 or exp(-delta\/T)>rand().\"\n\n\"ILS_ACCEPTANCE_CLARITY\",\"Acceptance must be explicit: accept perturbed local optimum if score <= current or with probability p for diversification. Replace vague 'aceptance_rate' with well-defined probability function of delta and iteration.\"\n\n\"PERTURB_SPECIFIC\",\"Implement perturb_solution with intensity proportional to stagnation: perform m random Kempe-chain moves or reassign m high-conflict vertices; ensure return is feasible or include a quick repair.\"\n\n\"INIT_STRATEGY_WEAK\",\"Provide constructive initializer minimizing K: greedy clique-coloring using vertex ordering by degree; then local descent. Avoid random-only starts.\"\n\n\"RANDOM_SEED_CONTROL\",\"Expose rng seed in other_params for reproducibility. Use a local Random instance, do not use global random to avoid cross-run variability.\"\n\n\"LOCAL_FEAS_ENFORCEMENT\",\"During neighbour generation, optionally bias to colours that keep feasibility or reduce violations; discard moves that increase violations drastically to stabilize search.\"\n\n\"LOGGING_METRICS\",\"Record per-iteration: cost, violations (if any), K, move_type, accept\/reject, and temperature\/tenure. Enables diagnosing stagnation and tuning parameters.\"\n\n\"CONSTRAINT_SAFETY\",\"Ensure no component accesses filesystem, network, or OS. All computations must be in-memory per MAIN_CRITICAL_INSTRUCTION.\"\n\n\"TEST_PROTOCOL\",\"Add unit tests: validate evaluate_solution on boundary cases (invalid lengths\/types, out-of-range labels), invariant checks after neighbour and perturb (length=9, positive ints), and acceptance logic for delta=0, delta<0, delta>0.\"\n\n\"SOLUTION_REP_IMPROVEMENT\",\"INDEX_LIST is fine but exploration suffers when K grows. Introduce color-compaction operator that removes empty colors and tries to recolor a class into existing ones before accepting a higher K.\"\n\n\"TERMINATION_CRITERIA\",\"Define clear stopping: max_iters, max_no_improve, wall-clock budget. Prefer adaptive termination on no-improvement plateau length.\"\n\n\"PARAM_TUNING\",\"Automate calibration via brief offline sweep for alpha (SA), tenure (TS), perturb intensity (ILS). Use percentile-based initialization from short pilot runs.\"\n\n\"INTEGRATION_FIX_ORDER\",\"Apply corrections in order: (1) fix signatures and typing instantiation, (2) implement perturb_solution, (3) ensure return protocol and logging, (4) add advanced neighbourhoods, (5) optimize evaluation via caching, (6) tune parameters.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST: list of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci is the color label of vertex i. Each color class must induce a clique (if two vertices share a color, they must be adjacent in E).","Componentes":{"REPRESENTATION":"INDEX_LIST: list of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci is the color label of vertex i. Each color class must induce a clique (if two vertices share a color, they must be adjacent in E).","EVAL_CODE":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (a, b) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: penalize larger K above K*\n    K = max(solution)\n    # Precomputed optimal K* for this fixed graph (minimum clique cover number)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)","NB_CODE":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Helper: conflicts per vertex (non-edges within same color)\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    conf += 1\n        return conf\n    # Helper: feasible to move vertex i to color c?\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    # Choose move type based on current conflict state\n    conf_counts = [conflicts_of_vertex(i, s) for i in range(n)]\n    total_conf = sum(conf_counts)\n    move = None\n    if total_conf > 0 and random.random() < 0.7:\n        move = \"conflict_recolor\"\n    else:\n        move = \"class_move\"\n    if move == \"conflict_recolor\":\n        # Pick most conflicting vertex, move to best existing color\n        i = max(range(n), key=lambda t: conf_counts[t])\n        cur_c = s[i]\n        labels = list({c for c in s})\n        # Evaluate delta conflicts for each candidate color\n        best_c = cur_c\n        best_delta = 0\n        # Try existing colors first\n        for c in labels:\n            if c == cur_c:\n                continue\n            if feasible_in_color(i, c, s):\n                best_c = c\n                best_delta = -1  # strict improvement by resolving conflicts for this vertex\n                break\n        if best_delta == 0:\n            # As fallback, possibly introduce a new color with small probability\n            if random.random() < 0.2:\n                best_c = max(labels) + 1\n            else:\n                # move to a random existing different color\n                cand = [c for c in labels if c != cur_c]\n                if cand:\n                    best_c = random.choice(cand)\n        s[i] = best_c\n        return s, \"conflict_recolor\"\n    else:\n        # class_move: pick a vertex and move to a randomly chosen existing color if feasible; else random recolor\n        i = random.randrange(n)\n        labels = list({c for c in s})\n        random.shuffle(labels)\n        moved = False\n        for c in labels:\n            if c == s[i]:\n                continue\n            if feasible_in_color(i, c, s):\n                s[i] = c\n                moved = True\n                break\n        if not moved:\n            # random recolor possibly introducing a new color (diversification)\n            if random.random() < 0.15:\n                s[i] = max(labels) + 1\n            else:\n                s[i] = random.choice(labels)\n        return s, \"class_move\"","PERTURB_CODE":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    # Graph\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                a,b = (u,v) if u < v else (v,u)\n                if (a,b) not in E:\n                    return False\n        return True\n    def most_conflicting_vertex(arr):\n        worst_i = 0\n        worst = -1\n        for i in range(n):\n            u = i + 1\n            cu = arr[i]\n            conf = 0\n            for j in range(n):\n                if j == i:\n                    continue\n                if arr[j] == cu:\n                    v = j + 1\n                    a,b = (u,v) if u < v else (v,u)\n                    if (a,b) not in E:\n                        conf += 1\n            if conf > worst:\n                worst = conf\n                worst_i = i\n        return worst_i, worst\n    # Perform multiple strong moves\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i, worst = most_conflicting_vertex(s)\n        labels = list({c for c in s})\n        if worst > 0:\n            # try to move to a feasible existing color\n            random.shuffle(labels)\n            moved = False\n            for c in labels:\n                if c == s[i]:\n                    continue\n                if feasible_in_color(i, c, s):\n                    s[i] = c\n                    moved = True\n                    break\n            if not moved:\n                # introduce new color to break conflicts\n                s[i] = max(labels) + 1\n        else:\n            # No conflicts: attempt color merge by moving a vertex into another color if feasible\n            if len(labels) >= 2:\n                src = random.choice(labels)\n                dsts = [c for c in labels if c != src]\n                if dsts:\n                    dst = random.choice(dsts)\n                    # move a random vertex of src into dst if feasible, else random recolor\n                    idxs = [k for k in range(n) if s[k] == src]\n                    if idxs:\n                        k = random.choice(idxs)\n                        if feasible_in_color(k, dst, s):\n                            s[k] = dst\n                        else:\n                            # random recolor for diversification\n                            if random.random() < 0.3:\n                                s[k] = max(labels) + 1\n                            else:\n                                s[k] = random.choice(labels)\n            else:\n                # single color: diversify by splitting\n                k = random.randrange(n)\n                s[k] = max(labels) + 1\n    return s","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERROR:combinations() called without r. Replace all combinations(X) with combinations(X,2) wherever pair generation is intended; if not generating pairs, remove the call entirely.\nFIX_SOLVER_SIGNATURE:Heuristics must implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Unify SA\/ILS\/TS to this signature or provide thin adapters. Current custom signatures violate TARGET_HEURISTIC_GENERAL_SIGNATURE.\nFIX_FUNC_ARG_PASSING:Do not call generate_neighbour() or evaluate_solution() in the argument list. Pass function objects, not their return values.\nFIX_PERTURB_MISSING:Perturbation Function is undefined ($Perturb). Implement perturb_solution(solution, intensity) returning a valid INDEX_LIST; wire it into ILS and as diversification for SA\/TS.\nEVAL_CONSISTENCY:Objective is minimization; ensure solvers compare new_cost < best_score. Remove any maximizing logic (e.g., negatives) in acceptance rules.\nEVAL_VALIDATION:Evaluation returns 1e6+violations for infeasible. Ensure solvers never accept infeasible unless explicitly in a repair phase; otherwise they will get stuck due to huge plateaus.\nNB_CODE_FAIL_LOCAL_OPT:conflict_recolor stops at first feasible color. Instead, evaluate all existing colors and pick the one minimizing resulting conflicts and K; break ties by smallest K then smallest color label.\nNB_MOVE_SET_INCOMPLETE:Add Kempe-chain style recolor, pair-swap between color classes, and color-merge\/split moves to escape local minima and reduce K systematically.\nNB_K_CONTROL:Random introduction of a new color increases K and is heavily penalized; restrict new-color creation to when no feasible recolor exists and immediately schedule a color-elimination phase.\nNB_CONFLICT_METRIC:conflicts_of_vertex double-counts pair violations in total_conf; use violations = sum(1 for a<b same_color and non-edge) to guide moves; prioritize vertices in largest violating cliques.\nNB_COMPLEXITY:Current neighbor generation is O(n^2) per step. Precompute adjacency matrix (9x9 bool) once; maintain per-color adjacency feasibility sets to reduce checks to O(deg) per move.\nTABU_SETTINGS:Define explicit tabu attributes (vertex,color) with aspiration if new best. Ensure taboo_list_size and taboo_duration are consistent integers; clear expired entries each iteration.\nSA_PARAMETERS:Cooling must be monotone T*=T*cooling_factor with 0.8<=factor<1 and stop at MIN_TEMP. Acceptance p=exp(-(new-old)\/T) for worse moves; clamp probabilities to [0,1].\nILS_ACCEPTANCE:Use accept if new_cost<=incumbent or with probability depending on improvement stagnation; set perturb intensity proportional to iterations without improvement.\nREPR_SYMMETRY:Color labels are arbitrary; normalize labels after each move to a canonical mapping to reduce search redundancy and improve tabu hashing.\nFEASIBILITY_REPAIR:On infeasible states, run a greedy repair: for each conflicting vertex, move to the lowest-index feasible color; if none, open a new color temporarily, then immediately try color elimination.\nCOLOR_ELIMINATION:Periodically attempt to remove a color by reassigning its vertices to other feasible colors; if successful, relabel to close gaps.\nTEST_MINIMAL_CASES:Add unit checks: evaluate_solution returns finite for feasible, large for infeasible; generate_neighbour returns a tuple (solution,move_type) with valid INDEX_LIST and move_type in {conflict_recolor,class_move,...}.\nASSERT_CORRECTNESS:Cross-validate evaluate_solution on multiple feasible and infeasible samples to ensure penalties and feasibility checks behave as expected (assert monotonicity with K).\nRETURN_PROTOCOL:Heuristics should return (best_solution,best_score,extra_outputs) where extra_outputs include move_type frequencies, iterations, and last temperature; do not print-only.\nCODE_STYLE_SAFETY:Avoid global randomness without seeds in tests; inject rng as other_params['rng'] for reproducibility.\nPARAM_TUNING:Start with SA: TEMP=5.0, MIN_TEMP=1e-3, cooling_factor=0.95; TS: iterations=200, tabu_tenure=5; ILS: iterations=200, acceptance_rate parameter is unused\u2014replace with acceptance policy function.\nLOCAL_SOLVER_COMPAT:Ensure names match exactly: generate_neighbour, evaluate_solution, perturb_solution; avoid shadowing names like combinations or random in local scopes to prevent runtime errors.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"INDEX_LIST of length 9: list[int] where index i in 0..8 encodes color of vertex i+1. Example: [1,2,3,1,2,3,2,1,3].","Componentes":{"REPRESENTATION":"INDEX_LIST of length 9: list[int] where index i in 0..8 encodes color of vertex i+1. Example: [1,2,3,1,2,3,2,1,3].","EVAL_CODE":"import math\nimport random\nfrom itertools import combinations\n\ndef evaluate_solution(solution):\n    # Validate type and size\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(10**9)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n    # Graph definition (undirected)\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    # Feasibility check: each color class induces a clique\n    color_to_vertices = {}\n    for i, c in enumerate(solution, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    violations = 0\n    for verts in color_to_vertices.values():\n        if len(verts) <= 1:\n            continue\n        for a, b in combinations(sorted(verts), 2):\n            if (min(a,b), max(a,b)) not in E:\n                violations += 1\n    if violations > 0:\n        return float(10**6 + violations)\n    # Feasible: objective is minimize K; add soft penalty if above known optimum K*\n    K = max(solution)\n    Kstar = 3\n    penalty = 100.0 * (K - Kstar) if K > Kstar else 0.0\n    return float(K + penalty)\n","NB_CODE":"import random\nfrom itertools import combinations\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive clone and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3], \"invalid\"\n    s = solution[:]\n    n = 9\n    # Graph data\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def total_violations(arr):\n        # Count unordered pairs violating clique condition\n        viol = 0\n        color_to_vertices = {}\n        for i, c in enumerate(arr, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        for verts in color_to_vertices.values():\n            if len(verts) <= 1:\n                continue\n            for a, b in combinations(sorted(verts), 2):\n                if not is_edge(a,b):\n                    viol += 1\n        return viol\n    def conflicts_of_vertex(idx, arr):\n        u = idx + 1\n        cu = arr[idx]\n        conf = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if arr[j] == cu:\n                v = j + 1\n                if not is_edge(u,v):\n                    conf += 1\n        return conf\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    # Current state\n    cur_viol = total_violations(s)\n    labels = sorted(set(s))\n    # If conflicts exist: best conflict-resolving recolor\n    if cur_viol > 0:\n        # choose vertex with highest conflicts (tie-break by random)\n        confs = [(conflicts_of_vertex(i, s), i) for i in range(n)]\n        max_conf = max(confs)[0]\n        cand_vertices = [i for c,i in confs if c == max_conf]\n        i = random.choice(cand_vertices)\n        cur_c = s[i]\n        best_arr = None\n        best_key = None  # (violations, K, color_label)\n        # Try recolor to all existing colors and possibly a new color\n        try_colors = list(labels)\n        if (max_conf == 0) and (len(labels) == 1):\n            try_colors.append(max(labels)+1)\n        else:\n            try_colors.append(max(labels)+1)\n        for c in try_colors:\n            if c == cur_c:\n                continue\n            t = s[:]\n            t[i] = c\n            # If recolor makes it infeasible w.r.t clique, it's still evaluated by violations metric\n            viol = total_violations(t)\n            key = (viol, max(t), c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_arr = t\n        if best_arr is None:\n            # fallback random recolor\n            t = s[:]\n            other = [c for c in labels if c != s[i]]\n            if other:\n                t[i] = random.choice(other)\n            best_arr = t\n        return normalize_colors(best_arr), \"conflict_recolor\"\n    # Feasible: attempt color elimination\/merge first\n    # Try to eliminate a color by moving its vertices to other colors\n    labels = sorted(set(s))\n    if len(labels) >= 2:\n        # pick a source color (smallest class first)\n        sizes = {c: s.count(c) for c in labels}\n        src = min(labels, key=lambda c: (sizes[c], c))\n        verts = [i for i in range(n) if s[i] == src]\n        target_labels = [c for c in labels if c != src]\n        # Greedy pack into feasible targets\n        t = s[:]\n        possible = True\n        for i in verts:\n            placed = False\n            # try targets in increasing size order to balance\n            target_labels.sort(key=lambda c: (t.count(c), c))\n            for c in target_labels:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    placed = True\n                    break\n            if not placed:\n                possible = False\n                break\n        if possible:\n            return normalize_colors(t), \"color_eliminate\"\n    # If elimination failed, try a feasible pair swap to diversify\n    trials = 20\n    for _ in range(trials):\n        i = random.randrange(n)\n        j = random.randrange(n)\n        if i == j or s[i] == s[j]:\n            continue\n        t = s[:]\n        ci, cj = t[i], t[j]\n        # swap colors if both remain feasible\n        t[i], t[j] = cj, ci\n        if feasible_in_color(i, t[i], t) and feasible_in_color(j, t[j], t):\n            return normalize_colors(t), \"pair_swap\"\n    # Fallback: simple feasible recolor of a random vertex\n    i = random.randrange(n)\n    other = [c for c in labels if c != s[i]]\n    random.shuffle(other)\n    for c in other:\n        if feasible_in_color(i, c, s):\n            t = s[:]\n            t[i] = c\n            return normalize_colors(t), \"class_move\"\n    # As last resort, introduce a new color to diversify (will be penalized but may escape)\n    t = s[:]\n    t[i] = max(labels) + 1\n    return normalize_colors(t), \"new_color\"\n","PERTURB_CODE":"import random\nfrom itertools import combinations\n\ndef perturb_solution(solution):\n    # Validate and clone\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [1,2,3,1,2,3,2,1,3]\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    n = 9\n    edges_list = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in edges_list:\n        if u > v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(a,b):\n        if a > b:\n            a,b = b,a\n        return (a,b) in E\n    def feasible_in_color(i, c, arr):\n        u = i + 1\n        for j in range(n):\n            if j == i:\n                continue\n            if arr[j] == c:\n                v = j + 1\n                if not is_edge(u,v):\n                    return False\n        return True\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    # Determine intensity based on conflicts: stronger if stagnated (simulated by random here)\n    steps = random.randint(4, 7)\n    t = s[:]\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = sorted(set(t))\n        # With probability, attempt move within existing colors; else possibly introduce a new color\n        if random.random() < 0.8:\n            # try to move to a random feasible existing color different from current\n            choices = [c for c in labels if c != t[i]]\n            random.shuffle(choices)\n            moved = False\n            for c in choices:\n                if feasible_in_color(i, c, t):\n                    t[i] = c\n                    moved = True\n                    break\n            if not moved and choices:\n                t[i] = random.choice(choices)\n        else:\n            t[i] = max(labels) + 1\n        # occasional color elimination attempt inside perturbation\n        if random.random() < 0.3 and len(set(t)) > 1:\n            labels = sorted(set(t))\n            # choose a source color and try to relocate one of its vertices\n            src = random.choice(labels)\n            dsts = [c for c in labels if c != src]\n            idxs = [k for k in range(n) if t[k] == src]\n            if idxs and dsts:\n                k = random.choice(idxs)\n                random.shuffle(dsts)\n                for c in dsts:\n                    if feasible_in_color(k, c, t):\n                        t[k] = c\n                        break\n        t = normalize_colors(t)\n    return t\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_LOCAL_SOLVER_SIGNATURE:Heuristic implementations use function calls in parameter positions (e.g., generate_neighbour()) causing premature execution and type mismatches. Conform exactly to TARGET_HEURISTIC_GENERAL_SIGNATURE and pass callable objects, not their results.\nE_COMBINATIONS_ARG:Error combinations() missing required argument 'r' indicates at least one invocation without specifying r=2 in local solver code. Audit all occurrences and enforce combinations(iterable, 2) consistently.\nE_PERTURB_MISSING:$Perturb placeholder is undefined, breaking ILS and any diversification logic. Implement a perturb_solution that preserves INDEX_LIST validity, controls intensity, and remains clique-feasibility-aware (e.g., targeted recolor of a small class plus normalization).\nE_NEIGHBOR_API_MISUSE:generate_neighbour returns (neighbor_solution, move_tag); heuristics must unpack and evaluate the first element only. Do not pass the tuple to evaluate_solution; evaluate only the solution component.\nE_ACCEPTANCE_ORDERING:Current evaluation returns 1e6+violations for infeasible states. Ensure SA\/ILS\/TS always prioritize feasibility before numerical improvements; otherwise temperature-based acceptance may accept worse infeasible states. Implement lexicographic acceptance (feasible-first, then score).\nE_STATE_NORMALIZATION:Neighbor normalizes color labels. Ensure heuristics compare by evaluate_solution only and do not derive K via raw max(solution) from pre-normalized states, avoiding artificial K inflation due to label gaps.\nE_SA_PARAMS:Cooling schedule likely too aggressive or undefined. Specify TEMP>0, MIN_TEMP<<TEMP, cooling_factor in (0.90,0.99), and iterations per temperature sufficient to explore (e.g., >=20 moves\/vertex). Ensure delta=score_new-score_cur; accept if delta<=0 else accept with exp(-delta\/T) guarded against overflow.\nE_TS_TABU_SCHEME:Tabu list must store move attributes compatible with generate_neighbour\u2019s move_tag and involved indices\/colors. Use aspiration when candidate beats best_score. Set taboo_list_size and taboo_duration proportional to problem size (n=9), e.g., size 7\u201315, duration 5\u201310.\nE_ILS_PERTURB_INTENSITY:Lack of calibrated perturb intensity risks cycling. Scale perturb strength with stagnation (e.g., 1\u20133 recolors), and always re-apply a focused local search using generate_neighbour until no improvement.\nE_RANDOM_SEEDING:Results are non-reproducible. Inject a dedicated RNG seeded via parameter in all heuristics and pass it to generate_neighbour\/perturb_solution to avoid global random state interference.\nE_STOP_CRITERIA:Missing\/weak termination conditions. Define max_iterations, max_no_improve, and time\/temperature thresholds to avoid infinite loops and ensure fair comparison across methods.\nE_EXTRA_OUTPUT_PROTOCOL:Local solver expects extra outputs; ensure heuristics log move_tag, current_score, best_score, iteration, and acceptance decisions per step to aid debugging without altering return types.\nE_EVAL_SOFT_PENALTY_RISK:The evaluation\u2019s soft penalty above K* biases search. Heuristics must not infer K*; treat score as opaque. When comparing neighbors at equal feasibility, rely solely on evaluate_solution rather than manual K-based tie-breakers.\nE_VALIDATION_GATE:Before main loop, validate inputs: solution is list[int] length 9 with all >0. On invalid, reset to a feasible seed (e.g., the provided sample) to prevent immediate crashes.\nE_CORRECTNESS_ASSERTION:Cross-validated evaluate_solution consistency on the provided reference versus a feasible baseline; no discrepancy detected. Keep this check in your unit tests to guard against regressions.\nS_IMMEDIATE_FIX_ORDER:1) Remove parentheses from heuristic signatures and parameter passing. 2) Define perturb_solution. 3) Audit all combinations() to include r=2. 4) Unpack generate_neighbour properly. 5) Implement feasibility-first acceptance in SA\/ILS\/TS. 6) Add reproducible RNG and robust stopping criteria.\nS_NEIGHBOR_DIVERSITY:Augment neighbor generation in heuristics with controlled color-elimination attempts followed by pair swaps and recolors as already provided; ensure heuristics invoke generate_neighbour multiple times per iteration to escape shallow basins.\nS_TABU_FEATURES:Encode tabu attributes as (vertex_index, old_color, new_color) to directly block immediate reversals; maintain aspiration when new_score<best_score.\nS_ILS_LOCAL_SEARCH:After perturbation, run steepest-descent using generate_neighbour until no improvement for X consecutive trials to exploit local structure efficiently.\nS_METRICS_REPORT:Track and report violations_count (derived from whether score>=1e6), K=max(solution), and move acceptance ratio per phase; this targets fast diagnosis of feasibility traps and parameter miscalibration.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_1..k_CONSECUTIVE","Componentes":{"REPRESENTATION":"LIST_LEN9_INT_LABELS_1..k_CONSECUTIVE","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    # All labels must be positive integers\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    # Labels must be exactly {1,..,k}\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build undirected adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","NB_CODE":"import random\nimport copy\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'relabel', 'swap', 'split', 'merge'\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        # fallback to a simple valid seed\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        # Map existing labels to 1..m in order of first appearance\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    move = random.random()\n    if move < 0.35:\n        # Relabel a single vertex to an existing or new label (at most +1 new)\n        i = random.randrange(9)\n        current_k = max(s)\n        choices = list(range(1, current_k+2))  # allow k+1 to enable exploration\n        choices.remove(s[i])\n        s[i] = random.choice(choices)\n        s = canonicalize(s)\n        return s, 'relabel'\n    elif move < 0.7:\n        # Swap labels of two vertices\n        i, j = random.sample(range(9), 2)\n        s[i], s[j] = s[j], s[i]\n        s = canonicalize(s)\n        return s, 'swap'\n    elif move < 0.85:\n        # Merge two random labels (if possible)\n        current_k = max(s)\n        if current_k >= 2:\n            a, b = random.sample(range(1, current_k+1), 2)\n            target = min(a, b)\n            source = max(a, b)\n            s = [target if x == source else x for x in s]\n            s = canonicalize(s)\n            return s, 'merge'\n        else:\n            # fallback to relabel\n            i = random.randrange(9)\n            s[i] = 1\n            s = canonicalize(s)\n            return s, 'relabel'\n    else:\n        # Split: pick a label with size >=2 and move one vertex to new label k+1\n        current_k = max(s)\n        # build groups\n        groups = {}\n        for idx, lab in enumerate(s):\n            groups.setdefault(lab, []).append(idx)\n        candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(groups[lab])\n            s[idx] = current_k + 1\n            s = canonicalize(s)\n            return s, 'split'\n        else:\n            # fallback to swap\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n            s = canonicalize(s)\n            return s, 'swap'\n","PERTURB_CODE":"import random\n\n# Strong perturbation to escape local minima\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        solution = [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        current_k = max(s)\n        if move < 0.4:\n            i = random.randrange(9)\n            choices = list(range(1, current_k+2))\n            if s[i] in choices:\n                choices.remove(s[i])\n            s[i] = random.choice(choices)\n        elif move < 0.7:\n            i, j = random.sample(range(9), 2)\n            s[i], s[j] = s[j], s[i]\n        else:\n            # random merge or split\n            if current_k >= 2 and random.random() < 0.5:\n                a, b = random.sample(range(1, current_k+1), 2)\n                target = min(a, b)\n                source = max(a, b)\n                s = [target if x == source else x for x in s]\n            else:\n                # split\n                groups = {}\n                for idx, lab in enumerate(s):\n                    groups.setdefault(lab, []).append(idx)\n                candidates = [lab for lab, idxs in groups.items() if len(idxs) >= 2]\n                if candidates:\n                    lab = random.choice(candidates)\n                    idx = random.choice(groups[lab])\n                    s[idx] = current_k + 1\n        s = canonicalize(s)\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_RANDOM_IMPORT:Runtime failure 'name random is not defined' in SA\/ILS\/TS. Add 'import random' at top-level of each heuristic module or inject an RNG via other_params to remove implicit global dependency.\nSIG_MISMATCH:Heuristics do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace per-heuristic signatures with 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' and pass params through internally. Do not use parentheses in parameters (e.g., 'generate_neighbour()') which passes call results instead of callables.\nPERTURB_MISSING:Placeholder '$Perturb' leaves perturbation undefined, causing ILS to fail. Implement 'perturb_solution(solution, strength, rng)' that performs a short sequence of merge\/split\/relabel moves; expose 'strength' in other_params.\nFUNC_NAME_INCONSISTENCY:Framework expects a single entrypoint Heuristic, but solver defines SA\/ILS\/TS separately. Provide a dispatcher Heuristic selecting the desired metaheuristic via other_params['method'] to maintain interface compliance.\nACCEPT_PARAM_TYPO:ILS uses 'aceptance_rate' which is misspelled; standardize to 'acceptance_rate' and document expected [0,1] range.\nTABU_IMPL_GAP:TS lacks explicit tabu attributes by signature confusion. Ensure parameters are in other_params: {'iterations','tabu_list_size','tabu_tenure','aspiration'} and that tabu tenure updates per move type.\nNEIGH_OP_REDUNDANCY:'swap' only permutes labels then canonicalization collapses label symmetry, often yielding no effective change. Replace with 'move' operator: pick vertex i and assign to an existing label j\u2260s[i] or new k+1; keep 'merge'\/'split' for k-adjustments. Retain canonicalization post-move.\nFEASIBILITY_MYOPIA:Random relabel frequently creates infeasible groups incurring 1e9 penalty, destroying gradient. Add feasibility-aware moves: when moving vertex v to label L, require v adjacent to all vertices in L; else skip or repair. Alternatively allow soft-constraint penalties with repair phase every t steps.\nEVAL_ASSERT:Evaluator correctness verified against a reference optimal assignment; returns expected minimal score. No change required to objective semantics.\nEVAL_PERF:Adjacency rebuilt each call. Precompute a 10x10 boolean matrix once in closure and use O(1) membership checks; clique validation cost becomes sum over groups of m_i*(m_i-1)\/2 boolean reads.\nCANON_FUNC_SCOPE:canonicalize inside neighbor is correct; expose same canonicalization utility in heuristics after any batch of edits to ensure label compactness before evaluation.\nINIT_STRAT:Sample seed is arbitrary and often infeasible. Construct a feasible initializer via greedy covering of complement graph with maximal cliques or sequentially assign each node to the first label forming a clique; fallback to new label if none fits.\nSA_PARAM_DRIFT:SA signature uses temp\/cooling but absent here. In unified Heuristic, accept other_params={'init_temp','min_temp','cooling','iters_per_temp'}; reject moves with standard Metropolis P=exp(-(delta)\/T) only when both solutions are feasible; else always reject invalid unless using soft penalties.\nILS_STRUCTURE:Define local_search as first-improvement hill-climbing constrained to feasible neighbors; perturb via 'strength' proportional to k and recent stagnation; accept if score improves or with probability p=acceptance_rate when equal.\nTS_MOVE_CODING:Tabu attribute should encode (vertex,label) assignment not whole solution; track tenure per attribute; aspiration permits tabu override if strictly better than best_score.\nEXPLOIT_COMPLEMENT:This is a clique cover; operate on complement graph as graph coloring. Use DSATUR or greedy coloring on complement to build strong initial upper bounds and intensify via Kempe-chain style recolor moves.\nREPAIR_OPERATOR:Add 'repair(solution)' that for any infeasible label L removes violating vertex with highest conflict degree to either a feasible existing label or a new label; loop until feasible.\nPENALTY_SCALE:1e9 penalty dwarfs all temperature\/acceptance tuning. When using soft constraints, scale penalties to O(n)\u2013O(n^2) conflicts to allow comparative evaluation; else enforce strict feasibility and prune invalid neighbors.\nTESTS_MIN:Set deterministic unit tests with fixed RNG seed to ensure: (1) evaluate_solution returns k for known feasible cases; (2) invalid label sets get PENALTY; (3) move operators preserve or repair feasibility; (4) canonicalization yields consecutive labels starting at 1.\nTERMINATION:Stop criteria should combine max_evals, max_time, and stagnation_iters; return best found and its score; log last move type to aid debugging.\nLOGGING_MIN:Local solver expects extra outputs; record tuple (iter,score,k,move_type,accept_reason,temperature_or_tabu_state) at low frequency for analysis; keep disabled by default via other_params['log']=False.\nVALIDATION_BEFORE_EVAL:Short-circuit evaluate_solution with quick checks: type\/len, label set consecutiveness, group sizes; only then perform clique checks to save time on clearly invalid candidates.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; solution is a list of 9 positive ints; labels must be exactly {1,..,k} without gaps","Componentes":{"REPRESENTATION":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; solution is a list of 9 positive ints; labels must be exactly {1,..,k} without gaps","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","NB_CODE":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    move = random.random()\n    current_k = max(s)\n\n    if move < 0.5:\n        # move: assign a vertex to an existing feasible label or new label\n        tries = 0\n        while tries < 20:\n            i0 = random.randrange(9)  # 0-based index\n            v = i0 + 1\n            k = max(s)\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    s = canonicalize(s)\n                    return s, 'move'\n            tries += 1\n        # fallback: trivial relabel to new group\n        s[random.randrange(9)] = max(s)+1\n        s = canonicalize(s)\n        return s, 'move'\n    elif move < 0.75:\n        # merge two labels if merged set stays a clique\n        k = max(s)\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            # check feasibility of merged group\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            feasible = True\n            for i in range(len(merged)):\n                u = merged[i]\n                for j in range(i+1, len(merged)):\n                    v = merged[j]\n                    if v not in adj[u]:\n                        feasible = False\n                        break\n                if not feasible:\n                    break\n            if feasible:\n                s = [target if x == source else x for x in s]\n                s = canonicalize(s)\n                return s, 'merge'\n        # fallback to move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        k = max(s)\n        candidates = list(range(1, k+1)) + [k+1]\n        if s[i0] in candidates:\n            candidates.remove(s[i0])\n        random.shuffle(candidates)\n        for L in candidates:\n            if L == k+1 or can_join_group(v, L, s):\n                s[i0] = L\n                s = canonicalize(s)\n                return s, 'move'\n        s = canonicalize(s)\n        return s, 'move'\n    else:\n        # split: choose a label with size>=2 and move one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1  # convert to 0-based\n            s[idx] = max(s) + 1\n            s = canonicalize(s)\n            return s, 'split'\n        # fallback to move\n        i0 = random.randrange(9)\n        s[i0] = max(s) + 1\n        s = canonicalize(s)\n        return s, 'move'\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Ensure a valid working copy\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [2,1,3,1,2,3,1,1,3]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    steps = random.randint(5, 12)\n    for _ in range(steps):\n        move = random.random()\n        k = max(s)\n        if move < 0.5:\n            # feasibility-aware move\n            i0 = random.randrange(9)\n            v = i0 + 1\n            candidates = list(range(1, k+1)) + [k+1]\n            if s[i0] in candidates:\n                candidates.remove(s[i0])\n            random.shuffle(candidates)\n            done = False\n            for L in candidates:\n                if L == k+1 or can_join_group(v, L, s):\n                    s[i0] = L\n                    done = True\n                    break\n            if not done:\n                # force new label\n                s[i0] = k + 1\n        elif move < 0.75:\n            # merge if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                feasible = True\n                for i in range(len(merged)):\n                    u = merged[i]\n                    for j in range(i+1, len(merged)):\n                        v = merged[j]\n                        if v not in adj[u]:\n                            feasible = False\n                            break\n                    if not feasible:\n                        break\n                if feasible:\n                    s = [target if x == source else x for x in s]\n        else:\n            # split a group of size>=2\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","SAMPLE_SOL":"[2,1,3,1,2,3,1,1,3]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST: All three solvers crash due to missing RNG import. Add 'import random' at the module\/function scope for SA\/ILS\/TS and ensure no hidden dependency on global state.\nSIG_MISMATCH_HEURISTIC: Solvers do not conform to TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement a single wrapper 'Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' and route to SA\/ILS\/TS internally via 'other_params[\\\"mode\\\"] in {\\\"SA\\\",\\\"ILS\\\",\\\"TS\\\"}'.\nSA_BAD_SIGNATURE: Current SA signature shows called objects in parameters (e.g., generate_neighbour()). Replace with callables without parentheses and pass via parameters. Ensure deterministic defaults for reproducibility (optional seed in 'other_params').\nILS_BAD_SIGNATURE: Same as SA; also parameter 'aceptance_rate' misspelled. Use 'acceptance_rate' and define a clear acceptance rule (e.g., accept if delta<=0 or rand<acceptance_rate).\nTS_BAD_SIGNATURE: Same as SA; rename 'taboo' to 'tabu' consistently and type parameters as ints. Maintain tabu list over explicit move attributes (e.g., (vertex, old_label, new_label)) with tenure 'tabu_duration'.\nNB_RANDOM_SCOPE: Neighbour relies on 'random' imported locally; solvers also use random but lack import. Standardize RNG by injecting 'rng' via 'other_params' or importing 'random' in each solver. Avoid reliance on globals.\nEVAL_ASSERTION: Evaluation function validated against a verified optimal assignment and multiple feasible assignments using the provided code; returns finite objective and rejects infeasible partitions with 1e9 penalty.\nEVAL_EDGE_CHECK: Clique validation O(sum |C|^2). For speed, precompute adjacency bitsets and use bitwise AND to validate cliques; alternatively cache induced clique checks per group.\nREP_CANONICALIZE_COST: Canonicalization called frequently; it is O(n). Reduce calls by only canonicalizing after label merges\/splits or when k decreases; avoid in inner loops.\nNB_CODE_FAIL_LOCAL_OPT: Neighborhood lacks pairwise relabel\/swap (Kempe-chain style) moves; current 'move\/merge\/split' may stall. Add two-vertex swap and 'move-with-repair' that reassigns conflicting vertices greedily to maintain feasibility.\nNB_MERGE_WEAK: Merge feasibility rechecks all pairs every time. Maintain group clique status incrementally or short-circuit using adjacency degrees within group.\nNB_JOIN_COST: 'can_join_group' rebuilds groups each call. Pass precomputed groups\/members or maintain inverse index label->members to avoid O(n) rebuild per probe.\nNB_FALLBACK_RISK: Fallback 'move to new label' can bloat k. Add cap on k growth and a subsequent consolidation phase (try merges then local repair) before accepting the move.\nSEARCH_BALANCE: SA\/ILS lack explicit restart\/perturbation coupling with feasibility repair. Implement 'perturb_solution' as label-shuffle within 2-3 vertices plus immediate clique-repair to avoid invalid states and excessive penalties.\nSA_SCHEDULE_WEAK: Define explicit cooling schedule: T <- T*alpha with 0.90<=alpha<=0.99; stop at MIN_TEMP or no-improve for N iters. Scale acceptance by delta = new_cost - old_cost; reject if new_cost>=1e9 to avoid wasting steps on penalized states.\nILS_CRITERIA: Use fixed budget of iterations and accept only if new_cost<best_score or with low probability if within small margin; track stagnation and trigger stronger perturbation when no improvement for K iterations.\nTS_TENURE_TUNING: Set tabu_duration ~ sqrt(num_moves) and aspiration criterion: allow tabu move if yields strictly better than best_score. Avoid prohibiting label canonicalization artifacts by tabu-ing normalized moves.\nINIT_STRATEGY: Provide a constructive greedy clique cover initializer to reduce starting k and improve convergence; e.g., iteratively extract maximal cliques and assign labels.\nCORRECTNESS_REGRESSION: Add unit tests: (1) label set consecutiveness, (2) group clique property, (3) objective monotonicity under feasible merges. Validate neighbour always returns valid, canonical labels.\nPERF_INSTRUMENT: Log objective, k changes, and move types; abort early if stuck producing only splits to new labels > X times consecutively; adapt move-type probabilities accordingly.\nRESULTS_VALIDATION: Use the provided evaluation to verify any reported solution; reject and retry if evaluate_solution returns >=1e9 before recording progress.\nOUTPUT_DISCIPLINE: Ensure solvers return exactly a list of 9 positive ints with consecutive labels and that 'best_score' equals evaluate_solution(best). Do not emit auxiliary data outside the specified return channel.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; labels in {1..k}; exactly 9 ints; groups form cliques; labels canonicalized","Componentes":{"REPRESENTATION":"LIST_LEN9_INT_LABELS_CONSECUTIVE_1_TO_k; labels in {1..k}; exactly 9 ints; groups form cliques; labels canonicalized","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Basic type\/length checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float(PENALTY)\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return float(PENALTY)\n    k = max(solution)\n    if set(solution) != set(range(1, k+1)):\n        return float(PENALTY)\n    # Build adjacency\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        if u == v:\n            return float(PENALTY)\n        adj[u].add(v)\n        adj[v].add(u)\n    # Group nodes by label\n    groups = {}\n    for i,label in enumerate(solution, start=1):\n        groups.setdefault(label, []).append(i)\n    # Validate clique property in each group\n    for nodes in groups.values():\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return float(PENALTY)\n    return float(k)\n","NB_CODE":"import random\n\n# Neighbour generator: returns (new_solution, movement_type)\n# Movement types: 'move', 'merge', 'split', 'swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    # Problem data\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_join_group(vertex, label, labels):\n        g = groups_of(labels)\n        members = g.get(label, [])\n        for u in members:\n            if vertex not in adj[u]:\n                return False\n        return True\n\n    def is_clique(nodes):\n        m = len(nodes)\n        for i in range(m):\n            u = nodes[i]\n            for j in range(i+1, m):\n                v = nodes[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    move_r = random.random()\n    k = max(s)\n\n    if move_r < 0.45:\n        # move: assign a vertex to an existing feasible label or new label\n        i0 = random.randrange(9)  # 0-based\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        # optionally create a new label only if no feasible join exists\n        s[i0] = k + 1\n        return canonicalize(s), 'move'\n\n    if move_r < 0.70:\n        # merge two labels if merged set stays a clique\n        if k >= 2:\n            labs = list(range(1, k+1))\n            a, b = random.sample(labs, 2)\n            target, source = min(a,b), max(a,b)\n            g = groups_of(s)\n            merged = g.get(target, []) + g.get(source, [])\n            if is_clique(merged):\n                s = [target if x == source else x for x in s]\n                return canonicalize(s), 'merge'\n        # fallback small move\n        i0 = random.randrange(9)\n        v = i0 + 1\n        candidates = list(range(1, k+1))\n        random.shuffle(candidates)\n        for L in candidates:\n            if L != s[i0] and can_join_group(v, L, s):\n                s[i0] = L\n                return canonicalize(s), 'move'\n        return canonicalize(s), 'move'\n\n    if move_r < 0.85:\n        # split: take a group of size>=2 and peel one vertex to new label\n        g = groups_of(s)\n        candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n        if candidates:\n            lab = random.choice(candidates)\n            idx = random.choice(g[lab]) - 1\n            s[idx] = k + 1\n            return canonicalize(s), 'split'\n        return canonicalize(s), 'split'\n\n    # swap: try swapping labels of two vertices to keep feasibility\n    i, j = random.sample(range(9), 2)\n    if s[i] != s[j]:\n        si, sj = s[i], s[j]\n        v_i, v_j = i+1, j+1\n        s[i], s[j] = sj, si\n        # verify both affected groups remain cliques\n        g = groups_of(s)\n        ok = True\n        for lab in set([si, sj]):\n            if not is_clique(g.get(lab, [])):\n                ok = False\n                break\n        if ok:\n            return canonicalize(s), 'swap'\n        # revert\n        s[i], s[j] = si, sj\n    # final fallback: no-op canonicalize\n    return canonicalize(s), 'move'\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Ensure a working copy and fallback\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [3,1,2,1,3,2,1,1,2]\n    else:\n        s = list(solution)\n\n    edges = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),(3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    adj = {i:set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def canonicalize(labels):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def groups_of(labels):\n        g = {}\n        for idx, lab in enumerate(labels, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def group_is_clique(members):\n        m = len(members)\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if v not in adj[u]:\n                    return False\n        return True\n\n    steps = random.randint(6, 12)\n    for _ in range(steps):\n        k = max(s)\n        op = random.random()\n        if op < 0.5:\n            # shuffle label of a random vertex, try feasible join else new\n            i0 = random.randrange(9)\n            v = i0 + 1\n            labels = list(range(1, k+1))\n            random.shuffle(labels)\n            moved = False\n            for L in labels:\n                if L == s[i0]:\n                    continue\n                # tentative move\n                old = s[i0]\n                s[i0] = L\n                g = groups_of(s)\n                if group_is_clique(g.get(L, [])) and group_is_clique(g.get(old, [])):\n                    moved = True\n                    break\n                s[i0] = old\n            if not moved:\n                s[i0] = k + 1\n        elif op < 0.75:\n            # merge two labels if feasible\n            if k >= 2:\n                labs = list(range(1, k+1))\n                a, b = random.sample(labs, 2)\n                target, source = min(a,b), max(a,b)\n                g = groups_of(s)\n                merged = g.get(target, []) + g.get(source, [])\n                if group_is_clique(merged):\n                    s = [target if x == source else x for x in s]\n        else:\n            # split: move one vertex of a multi-vertex group to a fresh label\n            g = groups_of(s)\n            candidates = [lab for lab, idxs in g.items() if len(idxs) >= 2]\n            if candidates:\n                lab = random.choice(candidates)\n                idx = random.choice(g[lab]) - 1\n                s[idx] = k + 1\n        s = canonicalize(s)\n    return s\n","SAMPLE_SOL":"[3,1,2,1,3,2,1,1,2]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"L_IMPORT_RANDOM_MISSING:Heuristics and neighbour rely on random but do not import it. Add 'import random' inside each heuristic module scope to prevent NameError.\nL_FUNC_SIGNATURE_MISMATCH:Provided heuristics do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement a single wrapper 'Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' that calls SA\/ILS\/TS internally, or refactor SA\/ILS\/TS to conform.\nL_PASSING_CALLABLES_ERROR:Heuristic callers appear to pass generate_neighbour() and evaluate_solution() (invoked) instead of function objects. Pass references without parentheses to avoid NoneType\/function-result errors.\nL_PERTURB_UNDEFINED:ILS requires 'perturb_solution' but 'Perturbation Function' is a placeholder. Implement a concrete 'perturb_solution(solution)' that performs controlled multi-move kicks and preserves feasibility.\nL_TABU_NAMING_INCONSISTENT:Mixed 'Taboo_Search' naming and parameters 'taboo_list_size\/taboo_duration'. Standardize to 'Tabu_Search' with 'tabu_list_size\/tabu_tenure' and ensure consistent usage across code.\nL_SEED_CONTROL_ABSENT:No reproducibility controls. Add optional 'seed' in other_params and apply 'random.seed(seed)' at the start of Heuristic for deterministic runs.\nE_EVAL_KNOWN_OK:evaluate_solution returns a finite cost for the provided test solution; evaluation contract appears correct for feasible inputs.\nE_EVAL_PENALTY_SCALE:Uniform 1e9 penalty collapses annealing\/acceptance dynamics. Replace with tiered penalties (e.g., 1e6 for non-consecutive labels, 1e5 for type errors, 1e4 for non-clique violations) to preserve gradient while enforcing feasibility.\nE_EVAL_REDUNDANT_CHECK:Self-loop guard on fixed edge list is unnecessary overhead. Remove 'if u==v' check or lift PENALTY early only when input edges contain self-loops (they do not).\nNB_ADJ_REBUILD_OVERHEAD:Adjacency recomputed on every neighbour call. Hoist 'adj' construction outside into closure or other_params to reduce O(|E|) per step.\nNB_CANONICALIZE_COST:canonicalize called on nearly all branches; cost is O(n) each step. Cache mapping when only a single merge\/split occurs, or defer until acceptance to reduce overhead.\nNB_OPERATOR_IMBALANCE:Move probability 0.45 dominates; split 0.15, swap 0.15. This biases towards increasing k and local moves. Rebalance or adapt operator rates based on recent improvements; increase merge probability when k grows.\nNB_MERGE_GUARD_EDGE:Merge samples two labels uniformly, often infeasible. Use clique potential scoring to prefilter merges: compute intersection-of-neighborhood heuristic to prioritize promising label pairs.\nNB_SWAP_LOCAL_VALIDATION:Swap validates only impacted labels (correct) but does not validate singletons created by earlier steps interacting with swap. Add fast incremental validation using membership deltas to guarantee feasibility post-swap.\nNB_NO_USE_OF_MOVE_TYPES:Returned movement_type is unused by heuristics. Exploit it for adaptive operator selection and temperature\/tenure adjustments.\nR_REP_INIT_STRATEGY_WEAK:No robust initializer provided if input is invalid. Implement greedy maximal clique packing initializer to start from a small k instead of arbitrary labels.\nH_SA_PARAMS_POORLY_SPECIFIED:Temperature schedule unspecified; default risks premature freezing. Use T0 scaled to stddev of first 100 accepted deltas; geometric cooling alpha in [0.90,0.99]; reheats on stagnation.\nH_ILS_ACCEPTANCE_UNCLEAR:Acceptance rate parameter unused\/undefined. Implement Metropolis-style acceptance for worse solutions during local search or use Late Acceptance threshold to escape local minima.\nH_TABU_TENURE_TUNING:tabu tenure not set relative to n. Use tenure in [n\/2, n] with aspiration based on best_score improvements; maintain tabu on labels moves instead of full solutions to reduce memory.\nAPI_RESULT_EXTRA_OUTPUTS:Local solver expects extra outputs. Ensure Heuristic returns (best_solution, best_score, meta) where meta contains logs including move counts and operator stats.\nCORRECTNESS_ASSERTION:Integrate an automated post-run assert: evaluate_solution(best_solution) < PENALTY and returns finite cost; cross-check against a verified solver only in tests, not at runtime.\nIMPROVEMENT_PERTURB_SPEC:Implement perturb_solution as: select r in [2,4], perform r random 'split' then 'merge' attempts guided by clique feasibility; ensure canonicalize at end.\nIMPROVEMENT_CACHE:Precompute for each vertex the list of clique-feasible labels under current grouping using bitsets to cut can_join_group checks from O(deg) to O(1) bitwise ops.\nIMPROVEMENT_LOCAL_OPT:Augment neighbour with 2-opt-style group refinement: for any pair of vertices in different labels, attempt reassignment if both target groups remain cliques; iterate until no improvement.\nIMPROVEMENT_UPPER_LOWER_BOUNDS:Maintain current k and track best_k; introduce immediate merge attempts when any pair of labels form a clique to greedily decrease k before stochastic moves.\nTESTS_MINIMAL:Add unit tests: (1) invalid length, (2) non-consecutive labels, (3) non-clique group, (4) valid small instances. Verify penalties and canonicalization behavior.\nRUNTIME_LOGGING:Track acceptance ratio per operator and adjust probabilities online via softmax bandit on recent gains to improve convergence speed.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Componentes":{"REPRESENTATION":"LIST_INT_ROOMS_LEN9","EVAL_CODE":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        if u==v or not (1 <= u <= n and 1 <= v <= n):\n            return 10**12\n        adj[u].add(v)\n        adj[v].add(u)\n    # Feasibility check: if same room then edge must exist in G\n    violations = 0\n    for i in range(1, n+1):\n        if solution[i-1] <= 0:\n            return 10**12\n        for j in range(i+1, n+1):\n            if solution[i-1] == solution[j-1]:\n                if j not in adj[i]:\n                    violations += 1\n    if violations > 0:\n        return 10**10 + violations\n    # Objective: number of distinct rooms used\n    k = len(set(solution))\n    return k\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for G\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i:set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def is_room_feasible(assign: List[int], room_label: int) -> bool:\n        members = [i+1 for i,r in enumerate(assign) if r == room_label]\n        for i in range(len(members)):\n            for j in range(i+1, len(members)):\n                if members[j] not in adj[members[i]]:\n                    return False\n        return True\n\n    def feasible_rooms_for_vertex(assign: List[int], v_idx: int):\n        rooms = sorted(set(assign))\n        res = []\n        for rl in rooms:\n            # Test if v can be placed in room rl\n            ok = True\n            for u in range(1, n+1):\n                if u == v_idx:\n                    continue\n                if assign[u-1] == rl:\n                    if u not in adj[v_idx]:\n                        ok = False\n                        break\n            if ok:\n                res.append(rl)\n        return res\n\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    move_type = None\n    r = random.random()\n\n    if r < 0.5:\n        # Single-vertex reassignment prioritizing feasible rooms\n        v = random.randint(1, n)\n        current_room = x[v-1]\n        feas = feasible_rooms_for_vertex(x, v)\n        # Allow moving to an existing feasible room different from current, else maybe open a new room\n        candidates = [rl for rl in feas if rl != current_room]\n        if not candidates and random.random() < 0.3:\n            # open a new room label\n            new_label = max(rooms) + 1\n            x[v-1] = new_label\n            move_type = \"open_room\"\n        elif candidates:\n            x[v-1] = random.choice(candidates)\n            move_type = \"move_to_feasible_room\"\n        else:\n            # fallback: move to a random existing room (may be infeasible)\n            x[v-1] = random.choice(rooms)\n            move_type = \"move_random_room\"\n    elif r < 0.8:\n        # Merge attempt between two rooms (feasible-preferred)\n        if len(rooms) >= 2:\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            y = list(x)\n            for i in range(n):\n                if y[i] == source:\n                    y[i] = target\n            # check feasibility; if infeasible, accept with small probability\n            if is_room_feasible(y, target):\n                x = y\n                move_type = \"merge_rooms_feasible\"\n            else:\n                if random.random() < 0.2:\n                    x = y\n                    move_type = \"merge_rooms_forced\"\n                else:\n                    # try different pair by doing a random swap instead\n                    i,j = random.sample(range(n), 2)\n                    x[i], x[j] = x[j], x[i]\n                    move_type = \"swap_vertices_rooms\"\n        else:\n            # not enough rooms to merge; do a swap\n            i,j = random.sample(range(n), 2)\n            x[i], x[j] = x[j], x[i]\n            move_type = \"swap_vertices_rooms\"\n    else:\n        # Relabel compression + local tweak\n        mapping = {old:new for new, old in enumerate(sorted(rooms), start=1)}\n        x = [mapping[r] for r in x]\n        rooms = sorted(set(x))\n        v = random.randint(1, n)\n        feas = feasible_rooms_for_vertex(x, v)\n        if feas:\n            x[v-1] = random.choice(feas)\n            move_type = \"relabel_and_move_feasible\"\n        else:\n            # random reassignment among existing labels\n            x[v-1] = random.choice(rooms)\n            move_type = \"relabel_and_move_random\"\n\n    return x, move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong perturbation: multiple randomized moves including opening new rooms and reassignments\n    n = 9\n    x = list(solution)\n    rooms = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n\n    for _ in range(num_moves):\n        act = random.random()\n        if act < 0.4:\n            # Random vertex to random room (existing or new with small prob)\n            v = random.randint(1, n)\n            if random.random() < 0.2:\n                new_label = max(rooms) + 1\n                x[v-1] = new_label\n                rooms = sorted(set(x))\n            else:\n                x[v-1] = random.choice(rooms)\n        elif act < 0.7 and len(rooms) >= 2:\n            # Random merge (may be infeasible; evaluation penalizes)\n            a, b = random.sample(rooms, 2)\n            target, source = min(a,b), max(a,b)\n            for i in range(n):\n                if x[i] == source:\n                    x[i] = target\n            rooms = sorted(set(x))\n        else:\n            # Shuffle labels of a random subset to disrupt structure\n            subset_size = random.randint(2, 4)\n            idxs = random.sample(range(n), subset_size)\n            labels = [x[i] for i in idxs]\n            random.shuffle(labels)\n            for i, lbl in zip(idxs, labels):\n                x[i] = lbl\n            rooms = sorted(set(x))\n\n    return x\n","SAMPLE_SOL":[1,2,3,1,2,3,2,1,3]},"Version":0,"Feedback":"\"COMPONENT_VERSION\": \"v1\"\n\"FEEDBACK\": \"FIX_LOCAL_SOLVER:Provided solver interfaces are incorrect. Do not use parentheses in parameter names. Expected callable parameters, not calls. Replace 'generate_neighbour()' with 'generate_neighbour' and similarly for 'evaluate_solution' and 'perturb_solution'.;FIX_TYPE_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead' indicates runtime attempts to instantiate typing aliases. Remove any List() or Tuple() usage in runtime code; use list() and tuple() only. Keep typing.List solely in annotations.;HEURISTIC_SIGNATURE_MISMATCH:Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)'. Provide a single wrapper that internally dispatches SA\/ILS\/TS if needed.;MISSING_COMPONENT:Perturbation Function is undefined ('$Perturb'). Implement perturb_solution with k-move randomized changes (e.g., Kempe-chain perturb, room split\/merge, random reassignment of 1\u20133 vertices) to escape local minima.;NB_CODE_FAIL_LOCAL_OPT:Neighbour generation allows forced infeasible merges ('merge_rooms_forced') and random infeasible moves, causing large penalty jumps (1e10+) that stall SA and bias TS tabu memory. Prefer repairs-first: only accept infeasible moves if they immediately reduce conflicts or enable a deterministic repair step.;E_PENALTY_SCALE:Static penalty 1e10 dwarfs objective differences and breaks temperature scaling and aspiration criteria. Use adaptive penalties: score = (rooms_used) + lambda*(conflicts), with lambda increased when conflicts persist and decreased after feasible streaks, or use lexicographic objective with staged acceptance.;E_CODE_PERF:Feasibility checks are O(n^2) per move via pairwise scans. Maintain per-room membership lists and a conflict counter per room to allow O(deg) updates on moves and O(1) feasibility tests for cliques by tracking min required edges m*(m-1)\/2 vs. present edges.;NB_ROOM_OPENING:Opening new labels without compression inflates label space and harms move efficiency. Always compress labels after any move that changes room counts; disallow opening a new room when it duplicates an existing singleton unnecessarily.;NB_MOVE_SET_WEAK:Operator set lacks targeted repairs. Add: (a) swap two vertices across rooms if both resulting rooms remain cliques; (b) move vertex to any feasible room chosen by maximum compatibility (largest clique completion); (c) Kempe-chain recoloring between two labels to resolve conflicts while preserving feasibility.;INIT_HEURISTIC:Start from stronger construction (DSATUR or greedy-by-degree with clique-check) to reduce initial k and repair cost, rather than arbitrary\/random initializations.;TS_PARAMETERS:Define tabu tenure on moves (vertex,old_room)->(vertex,new_room) with aspiration when k decreases. Maintain short-term tabu on room merges to prevent immediate undo. Avoid tabuing repairs that reduce conflicts.;SA_SCHEDULE:Cooling must consider typical delta magnitudes after removing 1e10 penalties. Calibrate TEMP so that move of +1 room has acceptance near exp(-1\/TEMP_base)\u22480.2 initially. Reheat on stagnation and reset to best-so-far configuration.;ILS_ACCEPTANCE:Use better acceptance criteria than raw score with penalties. Accept perturbed solution only if it reduces (k,conflicts) lexicographically; otherwise apply a bounded number of local improvements before comparison.;EVAL_CORRECTNESS_ASSERTION:evaluate_solution validated against the provided reference using the python tool; outputs match expected, confirming evaluator consistency.;EVAL_EDGE_CASES:Evaluator returns 1e12 for non-positive labels and length!=9. Ensure all generators always produce positive integers in [1..R] and keep length fixed to prevent hard rejections that poison search.;MOVE_FEAS_CHECK:Current is_room_feasible rechecks all pairs O(m^2). Replace with adjacency intersection: for candidate room with members S, check that S \u2286 N(v) in O(|S|) using bitsets or boolean array of size n.;ROOM_MERGE_POLICY:Before merging rooms a and b, verify clique feasibility via intersection N(u) for all u in a\u222ab or precomputed clique-test; if infeasible, skip rather than forcing. Alternatively, attempt partial merge by moving only vertices from b that are compatible with a.;REPRODUCIBILITY:Set and expose RNG seed control to reproduce runs and facilitate debugging of neighborhood\/operator efficacy.;DIAGNOSTICS:Log tuple (k,conflicts,move_type,delta,rooms_hist) to identify operators that frequently induce infeasibility or no-gain moves; prune or retune probabilities accordingly.;STOP_CRITERIA:Use dual criteria: max iterations without k improvement and time cap. When no feasibility found quickly, switch to repair-only mode until feasible.;SCORING_TIEBREAK:Within same k, minimize sum over rooms of (room_size choose 2) - present_edges to favor near-cliques, easing subsequent merges.;CONSTRAINT_SAFETY:Ensure no component accesses filesystem\/network\/OS. Keep all code pure, using only in-memory operations in compliance with MAIN_CRITICAL_INSTRUCTION.;UNIT_TESTS:Add tests: invalid types, zero\/negative labels, duplicate non-edges in same room, correct k counting after relabel compression, neighborhood idempotence on already-feasible moves.;\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Componentes":{"REPRESENTATION":"LIST_INT_ROOMS_LEN9","EVAL_CODE":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Moderate penalty to allow SA\/ILS scaling while prioritizing feasibility\n        return rooms_used + 1000 * conflicts\n    return rooms_used\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = max(rooms_list) + 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (choose best by largest compatible room)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge of compatible vertices\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            # test full merge b -> a\n            # apply tentative merge\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                # partial merge: move only vertices from b that are fully compatible with a\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong but feasibility-preserving perturbation using multiple safe operations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = max(rooms_list) + 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique; otherwise skip\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swaps between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                # Check both rooms remain cliques\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.1\"\n\n\"FEEDBACK\",\"E_RUNTIME_TYPING_LIST_INSTANTIATION:Do not instantiate typing.List. Replace all occurrences of List() with list() or [].\r\nE_SIGNATURE_MISMATCH:Algorithms do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement wrapper def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) that internally calls the chosen method; pass function handles without invoking them (generate_neighbour not generate_neighbour()).\r\nE_FUNC_PARAM_ORDER:Ensure all internal calls use the exact parameter order in TARGET_HEURISTIC_GENERAL_SIGNATURE; remove custom SA\/ILS\/TS signatures or adapt them behind the single Heuristic entrypoint.\r\nE_MISSING_COMPONENT:Perturbation Function is undefined ('$Perturb'). Implement def perturb_solution(solution): purely in-memory random but structured perturbation (e.g., 1-2 Kempe-chain swaps or k random vertex recolors) complying with 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.\r\nE_NEIGH_RET_UNPACK:generate_neighbour returns (new_solution, move_type). Update SA\/ILS\/TS loops to unpack both; use new_solution for evaluation and optionally log move_type. Failing to unpack leads to type errors and broken acceptance logic.\r\nE_NAME_TYPO:Taboo_Search\/aceptance_rate typos. Standardize to Tabu and acceptance_rate to avoid mismatched kwargs and loader errors.\r\nE_STATE_NORMALIZATION:Always compress labels after any move\/perturb (you already have compress_labels). Enforce at the end of each iteration to avoid label bloat and symmetry traps.\r\nE_EVAL_PENALTY_SCALING:Penalty 1000 per conflict may distort SA temperature\/TS aspiration. Calibrate by ensuring conflicts dominate room count but still allow feasible descent: e.g., penalty = 100*n (here 900) or dynamically scale by current rooms_used*100.\r\nE_CODE_PERF:Evaluation is O(sum_room m^2). Implement delta evaluation in heuristics to compute move cost in O(deg(v)) for single-vertex moves and O(m) for swaps; cache members_by_room and conflict checks to reduce recomputation.\r\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood lacks powerful recolor moves for plateaus. Add Kempe-chain interchange between two colors, and 'move-to-largest-feasible-clique' with tie-break on future compatibility (intersection degrees).\r\nNB_DIVERSIFICATION:Current merge logic may stall if no full clique union. Add stochastic partial merge with acceptance if delta < \u03c4 (adaptive), and periodic color relabeling to escape symmetry.\r\nR_INIT_INADEQUATE:Relying on arbitrary sample solution harms convergence. Add DSATUR\/greedy clique-based constructor to produce low-color feasible starts; optionally seed with maximum clique room then assign remaining by descending saturation.\r\nSA_PARAM_INIT:Define TEMP via target acceptance p0 for typical uphill \u0394 (estimate via sampling 100 random feasible moves): TEMP0 = -mean\u0394\/ln(p0); use geometric cooling with factor \u03b1 in [0.90,0.99], stop at MIN_TEMP where uphill acceptance < 0.01.\r\nSA_ACCEPTANCE_FUNC:Use Metropolis only on infeasible \u2192 feasible transitions force-accept if conflicts decrease regardless of rooms_used; otherwise apply standard exp(-\u0394\/T).\r\nTS_MOVE_ATTR:Define tabu attributes on (vertex,old_room\u2192new_room) with tenure in [7,15]; aspiration if move yields strictly better score than best_score. Maintain tabu list size and decrement counters each iteration.\r\nILS_STRUCTURE:Local search = best-improvement loop using feasible-preserving moves; perturb = 1\u20132 Kempe chains or reassign a random vertex to a new color; acceptance = better or equal if different structure (rooms changed) to promote exploration.\r\nPOSTPROCESSING:After termination, run greedy merge attempts over color pairs and try single-vertex relocations to reduce rooms_used; iterate until no improvement.\r\nRANDOM_CONTROL:Inject RNG via other_params['seed'] to ensure reproducibility; avoid global seeding inside components.\r\nE_RETURN_PROTOCOL:Heuristic must return (best_solution, best_score, extra_outputs_dict). Include counters for iterations, accepted_moves, infeasible_repairs, and last_move_type to satisfy 'LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED'.\r\nEVAL_CORRECTNESS_CHECK:PASS (evaluate_solution behavior consistent with feasibility and objective; internal assertion validated).\r\nACTIONABLE_FIX_ORDER:1) Replace List() with list(); 2) Implement perturb_solution; 3) Add Heuristic wrapper matching TARGET_HEURISTIC_GENERAL_SIGNATURE and adapt SA\/ILS\/TS internally; 4) Fix neighbor return unpacking; 5) Add DSATUR initializer; 6) Add Kempe-chain and improved acceptance\/aspiration; 7) Add delta evaluation and postprocessing; 8) Parameterize SA\/TS\/ILS via other_params without I\/O.\r\nTEST_PROTOCOL:Unit-test evaluate_solution on random feasible\/infeasible assignments; verify that a single conflicting pair adds exactly one conflict and triggers heavy penalty; regression-test Heuristic to ensure no filesystem\/network\/os usage and stable outputs across seeds.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"LIST_INT_ROOMS_LEN9","Componentes":{"REPRESENTATION":"LIST_INT_ROOMS_LEN9","EVAL_CODE":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]):\n    # Validate type and basic structure\n    if not isinstance(solution, list):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12\n    for v in solution:\n        if not isinstance(v, int):\n            return 10**12\n        if v <= 0:\n            return 10**12\n    # Build adjacency for G (opponents graph)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n    # Count conflicts: pairs in the same room that are NOT edges in G\n    conflicts = 0\n    # group members per room\n    members_by_room = {}\n    for i, r in enumerate(solution, start=1):\n        members_by_room.setdefault(r, []).append(i)\n    for room, members in members_by_room.items():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if (min(ui,vj), max(ui,vj)) not in E:\n                    conflicts += 1\n    rooms_used = len(members_by_room)\n    if conflicts > 0:\n        # Penalty dominates room count while allowing search dynamics\n        return rooms_used + 900 * conflicts\n    return rooms_used\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal graph data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def members_by_room(assign: List[int]):\n        rooms = {}\n        for i, r in enumerate(assign, start=1):\n            rooms.setdefault(r, []).append(i)\n        return rooms\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def pick_conflict(assign: List[int]):\n        # Return one conflicting pair (i,j) within some room, or None if none\n        rooms = members_by_room(assign)\n        for room, mem in rooms.items():\n            m = len(mem)\n            if m <= 1:\n                continue\n            for a in range(m):\n                u = mem[a]\n                for b in range(a+1, m):\n                    v = mem[b]\n                    if (min(u,v), max(u,v)) not in E:\n                        return (u, v, room)\n        return None\n\n    x = list(solution)\n    x = compress_labels(x)\n    rooms_list = sorted(set(x))\n\n    # If infeasible, perform a repair-first move deterministically\n    conflict = pick_conflict(x)\n    if conflict is not None:\n        i, j, room = conflict\n        v = random.choice([i, j])\n        # try to move v to a feasible existing room\n        feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n        if feasible_targets:\n            x[v-1] = random.choice(feasible_targets)\n            x = compress_labels(x)\n            return x, \"repair_move_to_feasible_room\"\n        # else, open a new room for v\n        new_label = (max(rooms_list) + 1) if rooms_list else 1\n        x[v-1] = new_label\n        x = compress_labels(x)\n        return x, \"repair_open_new_room\"\n\n    # Feasible-preserving neighborhood moves\n    move_type = \"noop\"\n    r = random.random()\n\n    if r < 0.45:\n        # Move single vertex to another feasible existing room (prefer largest)\n        v = random.randint(1, n)\n        current = x[v-1]\n        targets = []\n        for rl in rooms_list:\n            if rl == current:\n                continue\n            if is_feasible_room_for_v(x, v, rl):\n                size = sum(1 for u in x if u == rl)\n                targets.append((size, rl))\n        if targets:\n            targets.sort(reverse=True)\n            x[v-1] = targets[0][1]\n            x = compress_labels(x)\n            move_type = \"move_to_best_feasible_room\"\n        else:\n            # optionally open a new singleton room with small probability\n            if random.random() < 0.2:\n                x[v-1] = max(rooms_list) + 1\n                x = compress_labels(x)\n                move_type = \"open_new_room_singleton\"\n            else:\n                move_type = \"no_change\"\n    elif r < 0.75:\n        # Swap two vertices across rooms if both resulting rooms remain cliques\n        tries = 0\n        changed = False\n        while tries < 10 and not changed:\n            i, j = random.sample(range(1, n+1), 2)\n            if x[i-1] == x[j-1]:\n                tries += 1\n                continue\n            ri, rj = x[i-1], x[j-1]\n            xi = list(x)\n            xi[i-1], xi[j-1] = xi[j-1], xi[i-1]\n            if room_is_clique(xi, ri) and room_is_clique(xi, rj):\n                x = compress_labels(xi)\n                move_type = \"swap_vertices_feasible\"\n                changed = True\n            tries += 1\n        if not changed:\n            move_type = \"no_change\"\n    else:\n        # Merge two rooms if their union is a clique, else attempt partial merge\n        if len(rooms_list) >= 2:\n            a, b = random.sample(rooms_list, 2)\n            if a > b:\n                a, b = b, a\n            y = list(x)\n            for idx in range(n):\n                if y[idx] == b:\n                    y[idx] = a\n            if room_is_clique(y, a):\n                x = compress_labels(y)\n                move_type = \"merge_rooms_full\"\n            else:\n                members_b = [i for i, r in enumerate(x, start=1) if r == b]\n                moved = False\n                for v in members_b:\n                    if is_feasible_room_for_v(x, v, a):\n                        x[v-1] = a\n                        moved = True\n                x = compress_labels(x)\n                move_type = \"merge_rooms_partial\" if moved else \"merge_rooms_skip\"\n        else:\n            move_type = \"no_change\"\n\n    return x, move_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Strong feasibility-preserving perturbation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def compress_labels(assign: List[int]) -> List[int]:\n        mapping = {old: new for new, old in enumerate(sorted(set(assign)), start=1)}\n        return [mapping[r] for r in assign]\n\n    def is_feasible_room_for_v(assign: List[int], v_idx: int, room_label: int) -> bool:\n        for u in range(1, n+1):\n            if u == v_idx:\n                continue\n            if assign[u-1] == room_label:\n                if (min(u, v_idx), max(u, v_idx)) not in E:\n                    return False\n        return True\n\n    def room_is_clique(assign: List[int], room_label: int) -> bool:\n        mem = [i for i, r in enumerate(assign, start=1) if r == room_label]\n        m = len(mem)\n        if m <= 1:\n            return True\n        for a in range(m):\n            u = mem[a]\n            for b in range(a+1, m):\n                v = mem[b]\n                if (min(u,v), max(u,v)) not in E:\n                    return False\n        return True\n\n    x = compress_labels(list(solution))\n    rooms_list = sorted(set(x))\n\n    num_moves = random.randint(3, 6)\n    for _ in range(num_moves):\n        r = random.random()\n        if r < 0.4:\n            # Move a random vertex to a random feasible room; if none, open new singleton\n            v = random.randint(1, n)\n            feasible_targets = [rl for rl in rooms_list if rl != x[v-1] and is_feasible_room_for_v(x, v, rl)]\n            if feasible_targets:\n                x[v-1] = random.choice(feasible_targets)\n            else:\n                x[v-1] = (max(rooms_list) + 1) if rooms_list else 1\n            x = compress_labels(x)\n            rooms_list = sorted(set(x))\n        elif r < 0.7:\n            # Attempt merge of two rooms if union is clique\n            if len(rooms_list) >= 2:\n                a, b = random.sample(rooms_list, 2)\n                if a > b:\n                    a, b = b, a\n                y = list(x)\n                for i in range(n):\n                    if y[i] == b:\n                        y[i] = a\n                if room_is_clique(y, a):\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n        else:\n            # Random feasible swap between rooms\n            tries = 0\n            while tries < 8:\n                i, j = random.sample(range(1, n+1), 2)\n                if x[i-1] == x[j-1]:\n                    tries += 1\n                    continue\n                ri, rj = x[i-1], x[j-1]\n                y = list(x)\n                y[i-1], y[j-1] = y[j-1], y[i-1]\n                ok_i = room_is_clique(y, ri)\n                ok_j = room_is_clique(y, rj)\n                if ok_i and ok_j:\n                    x = compress_labels(y)\n                    rooms_list = sorted(set(x))\n                    break\n                tries += 1\n\n    return x\n","SAMPLE_SOL":"[3,1,2,1,3,2,1,1,2]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_SIG:Implement single entry def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route SA\/ILS\/TS logic inside; remove mismatched solver-specific signatures.\nFIX_TYPE_HINTS:Error 'Type List cannot be instantiated' indicates misuse of typing.List; replace any List() with list(), and avoid instantiating typing generics at runtime.\nFIX_PASS_FUNCS:Pass function objects (generate_neighbour, evaluate_solution, perturb_solution) without calling them; remove parentheses in call sites to prevent None\/function return misuse.\nFIX_PERTURB_MISSING:Define perturb_solution(solution) returning a valid neighbouring solution; suggest Kempe-chain perturbation or multi-vertex ejection to escape local minima.\nFIX_LOCAL_SOLVER_IO:Ensure Heuristic returns (new_solution,new_best,new_best_score,meta) consistently; include movement_type and acceptance_reason in meta for evaluation tracing.\nE_CODE_PERF:evaluate_solution rebuilds E and recomputes room pairs O(n^2) per call; precompute E as adjacency bitsets and maintain per-room incompatibility counters for O(deg) delta updates.\nE_OBJ_SCALING:Static penalty 900 may misguide search; implement adaptive penalty lambda with increase on infeasible acceptance and decrease when feasible regions are found, or use strict lexicographic (conflicts, rooms).\nE_CORRECTNESS_ASSERT:Evaluation matches expected feasibility on reference assignment; assertion passed locally, keep this as a regression test.\nINIT_CONSTRUCTIVE:Add DSATUR\/greedy clique-based initializer to reduce starting conflicts and rooms, improving convergence and reducing repair load.\nNB_CODE_FAIL_LOCAL_OPT:Repair picks first conflict deterministically; select pair with maximum violation or sample among top-K conflicting vertices to target the worst offenders.\nNB_MOVE_SCOPE:Add Kempe-chain swaps across two room labels, guided vertex ejection with best-insertion, and clique-growing\/room-splitting moves to explore tighter neighborhoods.\nNB_SWAP_LIMIT:Random 10-try swap is weak; precompute candidate cross-room pairs where both rooms remain cliques, or iterate deterministically over small-degree vertices first.\nNB_COMPRESS_LABELS:Frequent label compression breaks memory-based methods (tabu\/annealing state); keep stable labels during runs and compress only on checkpoints\/restarts.\nNB_FEASIBILITY_CHECK_COST:room_is_clique and is_feasible_room_for_v are O(s^2); maintain per-room non-edge counts per vertex for O(1)\/O(deg) feasibility checks.\nNB_MERGE_STRATEGY:Full merge then partial greedy merge can introduce silent regressions; evaluate union feasibility via incremental counters first, otherwise attempt targeted insertion with best-gain order.\nOBJ_DRIFT_CONTROL:When infeasible, prioritize zeroing conflicts before minimizing rooms (two-phase or hierarchical objective) to prevent cycling.\nSA_SCHEDULE:Use geometric cooling with reheats and monotone floor; accept with exp(-\u0394\/T) only when feasible or scaled by conflicts; track temperature restarts in meta.\nILS_ACCEPT:For ILS, implement strict better-or-equal on feasible, and late acceptance or threshold acceptance only when conflicts decrease; tune perturb strength adaptively.\nTS_MEMORY:If using tabu, store moves on (vertex,room) with tenure proportional to room count; aspiration if yields best_score; forbid label renumbering during tabu horizon.\nR_STR_INADEQUATE:Room labels as arbitrary ints hinder move caching; map rooms to compact indices once per epoch and maintain stable mapping to enable caching.\nTEST_SUITE:Add unit tests: (1) known feasible assignment returns minimal feasible conflicts, (2) single-room all participants yields >0 conflicts, (3) permutation invariance of labels after compression.\nLOGGING_EXTRA:Record (iteration,score,conflicts,rooms_used,move_type,T or tenure) each step; required by local evaluator expecting extra outputs.\nAPI_COMPAT:Remove any filesystem\/network\/os calls from all components to satisfy MAIN_CRITICAL_INSTRUCTION.\nKNOWN_BEST_CHECK:Local verification against the provided evaluator completed; do not expose target values in logs to avoid leakage.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is party label (int >=1) for vertex i. Labels need not be contiguous, but feasibility requires: for any i<j with solution[i-1]==solution[j-1], edge {i,j} must be in E.","Componentes":{"REPRESENTATION":"INDEX_LIST length=9. solution[i-1] is party label (int >=1) for vertex i. Labels need not be contiguous, but feasibility requires: for any i<j with solution[i-1]==solution[j-1], edge {i,j} must be in E.","EVAL_CODE":"import random\nimport itertools\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        # Feasible: objective is number of parties used\n        return len(parties)\n    # Infeasible: penalize heavily, but differentiate by number of violations and parties used\n    return 10**9 + 1000*len(parties) + violations\n","NB_CODE":"import random\nimport itertools\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor: single-vertex reassign or swap between two vertices\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    move_type = None\n    if random.random() < 0.6:\n        # Reassign one vertex to an existing or new label\n        i = random.randrange(n)\n        current_label = s[i]\n        labels = set(s)\n        # Candidate labels: existing labels excluding current, plus possibly a new label\n        candidates = list(labels - {current_label})\n        # Allow introducing a new label with small probability\n        if random.random() < 0.2:\n            candidates.append(max(labels) + 1)\n        if not candidates:\n            # Force some change: move to label 1 if not same\n            target = 1 if current_label != 1 else 2\n        else:\n            target = random.choice(candidates)\n        s[i] = target\n        move_type = \"reassign\"\n        # Optional clean-up: if a label becomes empty, relabel to keep labels compact is NOT required by representation\n    else:\n        # Swap labels of two distinct vertices\n        i, j = random.sample(range(n), 2)\n        s[i], s[j] = s[j], s[i]\n        move_type = \"swap\"\n    return (s, move_type)\n","PERTURB_CODE":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple reassignments and potential label merging\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n    s = solution[:]\n    labels = sorted(set(s))\n    # With some probability, merge two labels\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        # Merge label b into a\n        s = [a if lab == b else lab for lab in s]\n    # Apply several random reassigns\n    m = random.randint(2, 4)\n    for _ in range(m):\n        i = random.randrange(n)\n        labels = set(s)\n        current_label = s[i]\n        candidates = list(labels - {current_label})\n        # Occasionally introduce a new label to escape local minima\n        if random.random() < 0.15:\n            candidates.append(max(labels) + 1)\n        if candidates:\n            s[i] = random.choice(candidates)\n    return s\n","SAMPLE_SOL":"[1,2,3,1,2,3,2,1,3]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG:Heuristics use nonconforming signatures (SA\/ILS\/TS). Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do not pass called functions; pass callables.\nE_ARG_MISUSE:generate_neighbour received invalid type. Ensure heuristics pass only the solution list into generate_neighbour and correctly unpack (new_solution, move_type). Never feed the (solution,move_type) tuple back as solution.\nE_PERTURB_MISSING:Perturbation Function undefined ($Perturb). Implement a callable perturb_solution(solution, strength) returning a valid solution; wire it into the Heuristic signature.\nE_EVALUATOR_COMPAT:Evaluation returns large penalties for infeasible and |parties| for feasible. Heuristics must treat smaller is better and avoid mixing maximization logic. Remove any negation of scores.\nNB_CODE_FAIL_LOCAL_OPT:Move-set too generic and often infeasible; no repair applied. Add feasibility-preserving moves: (1) vertex move to a party only if it remains a clique, (2) party merge if the union remains a clique, (3) split a violating party by ejecting minimally conflicting vertices.\nR_STR_INADEQUATE:Unbounded label growth via new-label introduction increases search space and harms convergence. Normalize labels after each move (relabel to 1..m in party-id order) and cap introduction frequency; add explicit merge operator to reduce k.\nINIT_SOL_WEAK:No constructive seed exploiting structure. Build initial using clique-first or DSATUR on complement graph (clique cover == chromatic(complement)) to start near feasibility with small k.\nE_REPAIR_MISSING:No repair mechanism for infeasible neighbors. Add fast repair: for any violating pair inside a party, move one endpoint to an existing compatible party or a new party; iterate until feasible or budget exhausted.\nE_DELTA_EVAL:Full O(n^2) recheck per evaluation is wasteful. Precompute adjacency matrix and maintain party membership maps; implement delta evaluation for single-vertex moves\/swaps: O(party_size) to update violations and party count.\nE_MOVE_DIVERSITY_LOW:Swap is label swap, not vertex exchange across parties; limited exploration. Add: (a) vertex-exchange between two parties if both remain cliques, (b) Kempe-chain-style recoloring on complement to escape plateaus.\nE_ANNEALING_PARAMS:Cooling and acceptance poorly specified. Use geometric cooling T<-alpha*T with calibrated alpha~0.90\u20130.99, reheating on stagnation, and accept infeasible only with decreasing probability bounded by violation increase.\nILS_ACCEPTANCE:Ambiguous aceptance_rate and misspelled parameter. Define clear acceptance: accept new if fewer violations; tie-break by fewer parties; otherwise accept with prob exp(-(\u0394viol,\u0394k)\/T) or when improvement after perturbation.\nTS_TABU_CONF:Tabu tenure and list size unspecified and misnamed. Use tabu on (vertex,label) assignments; tenure ~ [5,15]; aspiration if produces fewer violations or fewer parties than best. Avoid storing full solutions.\nNB_RANDOM_BIAS:Random introduction of new labels at 0.2 is high. Reduce to <=0.05 and condition on repeated failure to find feasible reassignment.\nSTOP_CRITERIA:Define deterministic termination (max iters without improvement, wall-clock budget). Add early stop when no violations and no improving merge exists.\nTEST_COVERAGE:Add unit checks: (a) type\/length invalid returns >1e9, (b) feasible small-example returns small integer, (c) infeasible single-party-all assigns >1e9. Verify neighbor always returns list-of-ints length=9.\nREPRODUCIBILITY:Set RNG seed control in Heuristic(other_params) and propagate to generate_neighbour\/perturb to ensure repeatability for debugging and benchmarking.\nCOMPLEMENT_STRATEGY:Add dedicated complement-graph operators: recolor moves, DSATUR-based local repair, and clique-expansion for party merge decisions to leverage equivalence to graph coloring.\nPERF_INSTRUMENT:Log (violations, |parties|, move_type) per iteration; reject any move not improving lex-order (violations first) unless diversification is active; cap evaluation calls per second.\nVALIDATION_ASSERT:Before runs, assert evaluate_solution(currentSolution) < 1e9 to avoid starting from invalid state; after each move, assert type\/length\/integer labels; on infeasible, ensure penalties strictly increase with violations to guide search.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9; solution[i-1] is party label (positive int) for vertex i. Labels need not be contiguous; normalization maps labels to 1..m in first-occurrence order after each move.","Componentes":{"REPRESENTATION":"INDEX_LIST length=9; solution[i-1] is party label (positive int) for vertex i. Labels need not be contiguous; normalization maps labels to 1..m in first-occurrence order after each move.","EVAL_CODE":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    # Type and size checks\n    n = 9\n    if not isinstance(solution, list):\n        return 10**9 + 10**6\n    if len(solution) != n:\n        return 10**9 + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9 + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    return 10**9 + 1000*len(parties) + violations\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    # Graph data\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"reassign\"\n\n    if r < 0.6:\n        # Move one vertex to another existing label if target remains clique; or to new singleton label\n        i = random.randrange(n)  # 0-based index of vertex\n        v = i+1\n        cur = s[i]\n        candidates = [lab for lab in labels if lab != cur]\n        random.shuffle(candidates)\n        moved = False\n        for tgt in candidates:\n            # Check target clique condition with v added\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                moved = True\n                move_type = \"vertex->party\"\n                break\n        if not moved:\n            # New singleton label (always feasible)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"vertex->new\"\n    elif r < 0.85:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # Fallback to safe singleton move\n                i = random.randrange(n)\n                new_lab = max(labels) + 1\n                s[i] = new_lab\n                move_type = \"fallback-new\"\n        else:\n            i = random.randrange(n)\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"fallback-new\"\n    else:\n        # Exchange two vertices between two labels if both parties remain cliques\n        i,j = random.sample(range(n), 2)\n        if s[i] != s[j]:\n            li, lj = s[i], s[j]\n            vi, vj = i+1, j+1\n            memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n            memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n            if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                s[i], s[j] = s[j], s[i]\n                move_type = \"exchange\"\n            else:\n                # Try simple reassignment of one endpoint to maintain clique\n                moved = False\n                for tgt in [lj, li]:\n                    # try move vi->lj or vj->li\n                    if tgt == lj:\n                        if all(is_edge(vi,u) for u in memb_j):\n                            s[i] = lj\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                    else:\n                        if all(is_edge(vj,u) for u in memb_i):\n                            s[j] = li\n                            move_type = \"vertex->party\"\n                            moved = True\n                            break\n                if not moved:\n                    # No-op fallback to keep signature contract: force a benign singleton move\n                    k = random.choice([i,j])\n                    new_lab = max(labels) + 1\n                    s[k] = new_lab\n                    move_type = \"fallback-new\"\n        else:\n            # Same label: move one to singleton to diversify\n            new_lab = max(labels) + 1\n            s[i] = new_lab\n            move_type = \"singleton-diversify\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Feasible stronger shake: sequence of safe operations with normalization\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.4:\n            # Random reassign to compatible party or new singleton\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            candidates = [lab for lab in labels if lab != cur]\n            random.shuffle(candidates)\n            moved = False\n            for tgt in candidates:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved:\n                s[i] = max(labels) + 1\n        elif op < 0.7:\n            # Attempt merge of two labels when union is a clique\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # Exchange between two labels if feasible\n            i,j = random.sample(range(n), 2)\n            if s[i] != s[j]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                else:\n                    # As fallback, move one to singleton to keep feasibility\n                    k = random.choice([i,j])\n                    s[k] = max(labels) + 1 if (labels:=list(members_by_label(s).keys())) else 1\n        s = normalize_labels(s)\n    return s\n","SAMPLE_SOL":"[2,1,3,1,2,3,1,1,3]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"2025-11-21\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Three solvers fail before search starts. Correct signatures and typing to unblock execution.\n\nE_SIG_MISMATCH:Heuristic signatures use generate_neighbour() \/ evaluate_solution() calls in the parameter list. Pass function references, not calls. Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\n\nE_TYPE_TUPLE_INSTANTIATION:Framework error 'Type Tuple cannot be instantiated' indicates misuse of typing.Tuple or runtime-instantiated annotations. Remove runtime tuple literals in annotations and avoid typing.Tuple construction. If annotating, use -> Tuple[List[int], str] (from typing) without calling, or drop the return annotation entirely to avoid framework reflection pitfalls.\n\nE_PERTURB_MISSING:Perturbation Function unresolved ('$Perturb'). Provide a concrete perturb_solution callable; otherwise ILS and any metaheuristic needing diversification will fail.\n\nE_EVAL_ASSERTION:evaluate_solution correctly rejects infeasible by large penalty and returns party count for feasible. Verified against benchmark via Python; consistency holds. Keep minimization semantics.\n\nNB_CODE_FAIL_LOCAL_OPT:Neighbour generator enforces feasibility only; search can stall in local minima on k. Add a second operator class that allows bounded feasibility violations (guided by penalty) to improve escape, especially for SA\/TS.\n\nNB_OP_PORTFOLIO_GAPS:Current moves: single reassignment, merge, exchange. Missing split operator (breaks a non-clique party) and k-decreasing targeted moves (move vertex from singleton to compatible party first). Add split and greedy k-reduction reassignment.\n\nNB_PERF_REDUNDANCY:Repeated O(n) scans to build groups and members per move; normalization every step is O(n). Maintain incremental structures (label->members dict and degrees) and defer normalization to logging\/checkpoints to cut per-move time from O(n) to O(1)+O(deg).\n\nNB_CLIQUE_CHECK_COST:party_is_clique is O(m^2). Precompute adjacency bitsets for V; clique-add checks reduce to O(1) bit operations per member or O(m\/word_size).\n\nNB_RANDOM_FALLBACK_BIAS:Fallbacks frequently create new labels ('fallback-new', 'vertex->new'), inflating k and harming a minimization objective. Constrain fallbacks: attempt reassignment to best-compatible party first; only create new label if no feasible host exists.\n\nNB_LABEL_DRIFT:Continuous new labels then normalize each step causes label churn. Defer normalization to epochs or upon improvement acceptance to reduce noise and cost.\n\nSA_ACCEPTANCE_ERROR:Ensure acceptance uses \u0394 = new_cost - cur_cost with minimization (lower is better). T = TEMP schedule with cooling_factor in (0,1). Use exp(-\u0394\/T) for uphill moves only (\u0394>0). Pass function refs (generate_neighbour, evaluate_solution). Remove parentheses in signature and parameters.\n\nSA_PARAM_STABILITY:Set initial TEMP via cost variance of random neighbours; MIN_TEMP to halt when acceptance ~0. Add reheating or restarts if stagnation detected. Ensure deterministic seeding for reproducibility in tests.\n\nILS_INCOMPLETE:Provide perturb_solution that applies L-steps of disruptive moves (e.g., split largest party, random k-exchange) while preserving or lightly violating feasibility. Use acceptance by better-or-equal cost; optionally accept worse with probability or based on improvement history.\n\nTS_TABU_SCOPE:Define attribute-based tabu (e.g., (vertex,from_label->to_label)) with duration; aspiration allows overriding when new best. Maintain short-term memory to avoid cycling. Ensure candidate list includes non-tabu or aspirational moves; avoid creating new labels unless no candidate improves or preserves k.\n\nR_STR_INADEQUATE:Current label representation allows many symmetric encodings. Add canonical relabeling on evaluation only, and\/or use sorted party tuples to detect duplicates; or switch to set-of-cliques representation for local moves to reduce symmetry.\n\nE_MEMORY_CONSTS:Recompute E from raw_edges each call. Hoist E and adjacency to module-level constants to avoid repeated allocations.\n\nE_TESTING_LACK:Add unit checks: (1) neighbour returns normalized labels, (2) feasibility preserved for feasibility-only operators, (3) evaluate_solution monotone with added violations. Include seed-fixed regression tests.\n\nE_LOGGING_MINIMAL:Record move_type frequencies, acceptance rates, and best-so-far trace. Use these stats to tune operator probabilities (e.g., adaptive operator selection).\n\nE_STOPPING_CRITERIA:Currently undefined. Add time\/iteration caps, no-improvement window, and early stopping on k hitting theoretical lower bound if known offline.\n\nE_CODE_PERF:O(n) normalization and O(n^2) clique checks per move. Implement adjacency bitsets + incremental groups to achieve amortized O(1)-O(deg) per move.\n\nKNOWN_BEST_EVAL_CHECK:Using the provided evaluate_solution, the benchmark solution evaluates to the minimal feasible objective found in testing. Local solver correctness confirmed against the evaluator; ensure solvers compare using strict '<' for improvements and '<=' for acceptance when ties diversify.\n\nACTION_ITEMS:\n- Update all heuristic signatures to accept function refs; remove parentheses.\n- Remove\/adjust problematic type annotations causing instantiation; avoid typing.Tuple construction at runtime.\n- Implement perturb_solution with disruptive but bounded moves; wire into ILS and optionally SA restarts.\n- Add feasibility-violating neighbour family plus penalty-awareness in SA\/TS.\n- Precompute adjacency bitsets; maintain incremental party membership; defer normalization.\n- Reduce fallback-new frequency; prioritize greedy k-reduction reassignments and split operator.\n- Add deterministic seeds and unit tests for neighbour validity and evaluator conformity.\n- Instrument acceptance\/move stats; apply adaptive operator probabilities.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"INDEX_LIST length=9. solution[i-1] is positive int party label for vertex i. Labels may be non-contiguous; internal operations normalize to 1..m in first-occurrence order.","Componentes":{"REPRESENTATION":"INDEX_LIST length=9. solution[i-1] is positive int party label for vertex i. Labels may be non-contiguous; internal operations normalize to 1..m in first-occurrence order.","EVAL_CODE":"import itertools\nimport math\nimport random\n\ndef evaluate_solution(solution):\n    n = 9\n    PENALTY_BASE = 10**9\n    # Type and size checks\n    if not isinstance(solution, list):\n        return PENALTY_BASE + 10**6\n    if len(solution) != n:\n        return PENALTY_BASE + 10**6 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE + 10**6 + 1\n    # Graph definition (undirected)\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n    # Build party -> members\n    parties = {}\n    for idx,lab in enumerate(solution, start=1):\n        parties.setdefault(lab, []).append(idx)\n    # Count violations (pairs in same party must be edges)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                a,b = (ui,vj) if ui < vj else (vj,ui)\n                if (a,b) not in E:\n                    violations += 1\n    if violations == 0:\n        return len(parties)\n    # Penalize infeasible strongly with slight dependence on k and number of violations\n    return PENALTY_BASE + 1000*len(parties) + violations\n","NB_CODE":"import random\nfrom typing import List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor with label normalization and richer operators\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    groups = members_by_label(s)\n    labels = list(groups.keys())\n\n    r = random.random()\n    move_type = \"noop\"\n\n    if r < 0.45:\n        # Greedy reassignment: try to place a vertex into the smallest compatible party, else keep label\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        candidates = []\n        for lab in labels:\n            if lab == cur:\n                continue\n            tgt_members = [u for u,lab2 in enumerate(s, start=1) if lab2 == lab]\n            if all(is_edge(v,u) for u in tgt_members):\n                candidates.append((len(tgt_members), lab))\n        if candidates:\n            candidates.sort()\n            s[i] = candidates[0][1]\n            move_type = \"vertex->best_party\"\n        else:\n            # attempt swap-based improvement with another vertex\n            j = random.randrange(n)\n            if j != i and s[j] != s[i]:\n                li, lj = s[i], s[j]\n                vi, vj = i+1, j+1\n                memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                    s[i], s[j] = s[j], s[i]\n                    move_type = \"exchange\"\n                else:\n                    move_type = \"noop\"\n            else:\n                move_type = \"noop\"\n    elif r < 0.7:\n        # Merge two labels if union is a clique\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n            memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n            union = memb_a + memb_b\n            if party_is_clique(union):\n                for idx,lab in enumerate(s):\n                    if lab == b:\n                        s[idx] = a\n                move_type = \"merge\"\n            else:\n                # split a non-clique label if exists\n                non_clique_labels = []\n                for L, mem in members_by_label(s).items():\n                    if not party_is_clique(mem):\n                        non_clique_labels.append((L, mem))\n                if non_clique_labels:\n                    L, mem = random.choice(non_clique_labels)\n                    # move a violating vertex to a new singleton\n                    picked = None\n                    for u in mem:\n                        if any((min(u,v), max(u,v)) not in E for v in mem if v!=u):\n                            picked = u\n                            break\n                    if picked is None:\n                        picked = random.choice(mem)\n                    new_lab = max(labels) + 1\n                    s[picked-1] = new_lab\n                    move_type = \"split_violation\"\n                else:\n                    move_type = \"noop\"\n        else:\n            move_type = \"noop\"\n    else:\n        # Reassign to compatible existing party if any; avoid creating new labels\n        i = random.randrange(n)\n        v = i+1\n        cur = s[i]\n        cand = [lab for lab in labels if lab != cur]\n        random.shuffle(cand)\n        moved = False\n        for tgt in cand:\n            tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n            if all(is_edge(v,u) for u in tgt_members):\n                s[i] = tgt\n                move_type = \"vertex->party\"\n                moved = True\n                break\n        if not moved:\n            move_type = \"noop\"\n\n    s = normalize_labels(s)\n    return (s, move_type)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong but feasible shake: multiple clique-preserving moves plus merges\/splits\n    if not isinstance(solution, list):\n        raise ValueError(\"solution must be a list of ints\")\n    n = 9\n    if len(solution) != n:\n        raise ValueError(\"solution length must be 9\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"all labels must be positive integers\")\n\n    raw_edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    E = set()\n    for u,v in raw_edges:\n        a,b = (u,v) if u < v else (v,u)\n        E.add((a,b))\n\n    def is_edge(i:int,j:int)->bool:\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in E\n\n    def normalize_labels(s:List[int])->List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for lab in s:\n            if lab not in mapping:\n                mapping[lab] = nxt\n                nxt += 1\n            out.append(mapping[lab])\n        return out\n\n    def members_by_label(s:List[int]):\n        groups = {}\n        for idx,lab in enumerate(s, start=1):\n            groups.setdefault(lab, []).append(idx)\n        return groups\n\n    def party_is_clique(group):\n        m = len(group)\n        for i in range(m):\n            u = group[i]\n            for j in range(i+1, m):\n                v = group[j]\n                if not is_edge(u,v):\n                    return False\n        return True\n\n    s = solution[:]\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        groups = members_by_label(s)\n        labels = list(groups.keys())\n        op = random.random()\n        if op < 0.35:\n            # random reassignment to any compatible party\n            i = random.randrange(n)\n            v = i+1\n            cur = s[i]\n            cands = [lab for lab in labels if lab != cur]\n            random.shuffle(cands)\n            moved = False\n            for tgt in cands:\n                tgt_members = [u for u,lab in enumerate(s, start=1) if lab == tgt]\n                if all(is_edge(v,u) for u in tgt_members):\n                    s[i] = tgt\n                    moved = True\n                    break\n            if not moved and len(labels) >= 2:\n                # try exchange\n                j = random.randrange(n)\n                if j != i and s[j] != s[i]:\n                    li, lj = s[i], s[j]\n                    vi, vj = i+1, j+1\n                    memb_i = [u for u,lab in enumerate(s, start=1) if lab == li and u != vi]\n                    memb_j = [u for u,lab in enumerate(s, start=1) if lab == lj and u != vj]\n                    if all(is_edge(vi,u) for u in memb_j) and all(is_edge(vj,u) for u in memb_i):\n                        s[i], s[j] = s[j], s[i]\n        elif op < 0.65:\n            # merge if possible\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                memb_a = [u for u,lab in enumerate(s, start=1) if lab == a]\n                memb_b = [u for u,lab in enumerate(s, start=1) if lab == b]\n                union = memb_a + memb_b\n                if party_is_clique(union):\n                    for idx,lab in enumerate(s):\n                        if lab == b:\n                            s[idx] = a\n        else:\n            # split a non-clique party or diversify by moving a member to new label\n            labels_now = list(members_by_label(s).keys())\n            target_label = None\n            for L, mem in members_by_label(s).items():\n                if len(mem) >= 2 and not party_is_clique(mem):\n                    target_label = L\n                    break\n            if target_label is None and labels_now:\n                target_label = random.choice(labels_now)\n            if target_label is not None:\n                mem = [u for u,lab in enumerate(s, start=1) if lab == target_label]\n                pick = random.choice(mem)\n                new_lab = max(labels_now) + 1 if labels_now else 1\n                s[pick-1] = new_lab\n        s = normalize_labels(s)\n    return s\n","SAMPLE_SOL":"[1,3,2,1,3,2,3,1,2]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\",\n\"FEEDBACK\":\"E_LOCAL_SOLVER_TYPEHINT:Using typing.List as a constructor triggers 'Type List cannot be instantiated'; replace any List() with list() and import typing only for annotations, not instantiation.\nE_SIG_MISMATCH:Heuristics do not match TARGET_HEURISTIC_GENERAL_SIGNATURE; implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass callables without parentheses.\nE_FUNC_PARAMS_PARENS:Function parameters written as generate_neighbour() \/ evaluate_solution() in signatures are invalid; remove parentheses to accept callables and avoid immediate invocation.\nE_PERTURB_MISSING:Perturbation Function is undefined ('$Perturb'); implement def perturb_solution(solution, intensity, rng) returning a normalized feasible solution to unblock ILS and SA.\nE_NAMING_INCONSISTENCY:Local solver expects SA\/ILS\/TS specific signatures; consolidate to single Heuristic(...) or create thin adapters mapping to the general signature to avoid dispatcher errors.\nE_TABU_CONFIG:Taboo_Search signature uses 'taboo' not 'tabu'; unify naming and ensure tabu list stores hashable move descriptors (e.g., tuples (op,i,j,new_label)) to prevent unhashable-type errors.\nE_ACCEPTANCE_ILS:Parameter 'aceptance_rate' misspelled; standardize to acceptance_rate and implement explicit acceptance rule (accept if score <= best_score or random() < acceptance_rate).\nE_COOLING_POLICY:SA lacks well-defined schedule; use geometric cooling T*=T*alpha with alpha in [0.90,0.99], stop at MIN_TEMP, and set initial T via score variance over 100 random neighbors to calibrate acceptance ~0.8 initially.\nE_MOVE_RETURN:Neighbour returns (s, move_type) only; ensure heuristics consistently unpack and re-evaluate s, and never rely on move_type for feasibility assumptions.\nE_LABEL_NORMALIZE:Normalize labels after every modification in generate_neighbour and perturb_solution to maintain canonical representation and consistent tabu hashing.\nNB_CODE_FAIL_LOCAL_OPT:High probability of 'noop' stalls; add retry loop up to R tries per iteration or deterministic fallback (best-improving reassignment) to ensure progress.\nNB_OPERATOR_GAPS:Merge operator only if full union clique; add partial merge by moving only vertices fully compatible with target party to increase constructive moves.\nNB_CLIQUE_TEST_COST:Repeated clique checks reconstruct membership each time; precompute adjacency matrix and maintain party member lists to reduce per-move checks from O(n^2) to O(deg) incremental.\nNB_SWAP_LIMITED:Exchange considers only random pair; implement best-improving pair-swap and vertex relocation neighborhoods to escape shallow basins.\nR_REPRESENTATION_CONFLICT:Non-contiguous labels tolerated but increase branching; keep labels contiguous via first-occurrence remap after every move to reduce search space and tabu state size.\nE_EVAL_CONSISTENCY:Evaluator penalizes infeasibility with large constant; ensure all heuristics operate on feasible neighbors to avoid plateauing at PENALTY_BASE scales and masking improvements.\nE_TIME_COMPLEXITY:Current neighbor evaluation O(sum over parties of m^2); cache party cliques and update incrementally on vertex moves to amortize to O(deg(v)).\nTS_TABU_TENURE:Undefined tenure policy; recommend tenure in [5,10] relative to move class and aspiration criterion if score improves best.\nILS_PERTURB_SCOPE:Perturbation should perform k random feasible reassignments with k in [2,4] and avoid creating new labels unless necessary to maintain feasibility; then apply local descent for intensification.\nE_RANDOM_SEED:Heuristics lack RNG injection; pass rng in other_params to ensure reproducibility for evaluation and debugging.\nE_STOPPING:Define iteration\/temperature\/plateau stopping conditions to prevent premature termination or infinite loops; log step-wise best_score to verify convergence.\nE_PARAM_PASSING:Ensure the local solver passes callables as generate_neighbour and evaluate_solution without invoking; verify by smoke test calling Heuristic with a trivial solution and single neighbor step.\nE_TEST_VALIDATION:Cross-validate evaluate_solution correctness by checking random feasible partitions against edge constraints and ensuring no negative scores; assert that feasible k is returned without penalty.\nE_ERROR_HANDLING:Replace ValueError throws inside neighbors with in-function repairs or noops to avoid solver termination; return the input and 'noop' to continue.\nSUGGESTED_FIXES_MINIMAL:1) Implement perturb_solution. 2) Replace SA\/ILS\/TS with a single Heuristic wrapper adhering to general signature, internally dispatching to method via a mode flag. 3) Remove parentheses in callable parameters. 4) Replace any List() with list(). 5) Add label normalization and retry loop in neighbor. 6) Add acceptance\/tenure policies as specified.\nE_CODE_PERF:Avoid recomputing party members via list comprehensions in tight loops; maintain an index dict label->list and update incrementally on moves for O(1) label queries.\nE_LOGGING_MINIMAL:Return extra outputs (move_type, temperature\/tabu_tenure, acceptance) via a trace object in other_params to satisfy 'LOCAL_SOLVER_DESIGNED_FOR_EVALUATION_EXTRA_OUTPUTS_ARE_EXPECTED' without printing to stdout.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INTS","EVAL_CODE":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","NB_CODE":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize to list copy\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        return (curr, (\"InvalidSize\", \"NoMove\"))\n    # Ensure positivity fallback for safety\n    for i, x in enumerate(curr):\n        if not isinstance(x, int) or x < 1:\n            curr[i] = 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Detect conflicts\n    conflicts = []\n    for u, v in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n\n    max_col = max(curr) if curr else 1\n\n    def recolor_vertex(i: int) -> None:\n        nonlocal curr, max_col\n        forbidden = {curr[j] for j in adj[i]}\n        # Try smallest feasible color among existing ones\n        for c in range(1, max_col + 1):\n            if c not in forbidden:\n                curr[i] = c\n                return\n        # If none feasible in existing palette, open a new color\n        curr[i] = max_col + 1\n        max_col = max_col + 1\n\n    if conflicts:\n        # Conflict-driven move: pick a random endpoint of a random conflicting edge\n        u, v = random.choice(conflicts)\n        i = random.choice([u, v])\n        recolor_vertex(i)\n        return (curr, (\"1-Change\", \"Conflict-Driven-Recolor\"))\n    else:\n        # No conflicts: attempt color reduction by recoloring a vertex using smallest available color\n        # Prefer vertices using the highest color to encourage palette shrinkage\n        highest = [i for i, c in enumerate(curr) if c == max_col]\n        i = random.choice(highest if highest else list(range(n)))\n        old = curr[i]\n        recolor_vertex(i)\n        # If color count increased unnecessarily, revert with some probability\n        if max(curr) > max_col:\n            curr[i] = old\n        return (curr, (\"1-Change\", \"Greedy-Recolor\"))\n","PERTURB_CODE":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        # Resize by truncating\/padding with 1s for robustness\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Simple helper to check if reassigning vertex i to color c is feasible\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        ci = color\n        if ci < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    max_col = max(curr) if curr else 1\n\n    # Apply a burst of random recolors\n    t = random.randint(2, 5)\n    for _ in range(t):\n        i = random.randrange(n)\n        # Try random existing color first\n        palette = list(range(1, max_col + 1))\n        random.shuffle(palette)\n        placed = False\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # Open a new color as last resort\n            curr[i] = max_col + 1\n            max_col += 1\n\n    # Palette compaction attempt: try to merge a random color into a lower one\n    colors = sorted(set(curr))\n    if len(colors) >= 2:\n        src = random.choice(colors)\n        tgt_candidates = [c for c in colors if c < src]\n        if tgt_candidates:\n            tgt = random.choice(tgt_candidates)\n            # Tentatively map src -> tgt if feasible per-vertex\n            changed_idxs = [i for i, c in enumerate(curr) if c == src]\n            ok = True\n            for i in changed_idxs:\n                if not feasible_color(i, tgt, curr):\n                    ok = False\n                    break\n            if ok:\n                for i in changed_idxs:\n                    curr[i] = tgt\n                # Optional renumbering to keep colors compact 1..K\n                remap = {c: idx+1 for idx, c in enumerate(sorted(set(curr)))}\n                curr = [remap[c] for c in curr]\n\n    return curr\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Local solver crashes due to typing misuse and wrong callable parameters; correct these before any heuristic tuning.\nSIG_MISMATCH:Your solvers ignore TARGET_HEURISTIC_GENERAL_SIGNATURE; adapt all solver entry points to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass functions as objects (no parentheses).\nTYPE_HINT_MISUSE:Using typing.List as a constructor triggers 'Type List cannot be instantiated'; replace all List(...) with list(...) and ensure typing imports are used only for annotations.\nCALLABLE_PARAM_BUG:Signatures like generate_neighbour() and evaluate_solution() in parameters call the functions at definition-time; remove parentheses and pass the function references.\nMISSING_PERTURB_FN:Placeholder '$Perturb' causes ILS\/Heuristic failures; implement a concrete perturb_solution callable and thread it through all solvers.\nNAMING_INCONSISTENCY:Taboo_Search\/aceptance_rate typos propagate errors; standardize names (Tabu_Search, acceptance_rate) and keep consistent across invocation sites.\nRETURN_CONTRACT:All solvers must return (best_solution, best_score, extra_outputs); enforce and validate types to avoid downstream parsing issues.\n\nNB_CODE_FAIL_LOCAL_OPT:Neighbor move is a single-vertex recolor that often stalls; add stronger moves: (1) Kempe-chain interchanges on two colors, (2) color-class swap, (3) vertex move guided by highest saturation (DSATUR), (4) pairwise color merge attempts with conflict repair.\nNB_PALETTE_REGRESSION:In 'Greedy-Recolor', revert logic is dead: max_col is updated inside recolor_vertex, so condition if max(curr) > max_col never fires; store old_max=max_col before recolor, then revert if new_max>old_max and no k reduction.\nNB_CONFLICT_BIAS:Picking random endpoint of a random conflict yields high variance; prioritize vertices by conflict degree (number of conflicting edges) or by penalty impact to accelerate feasibility.\nNB_UNBOUNDED_COLORS:Recolor may introduce new colors unnecessarily; cap colors to current max and use repair if no feasible color exists instead of opening new color too early.\nNB_MOVE_DIVERSITY_LOW:Add occasional multi-vertex 'color elimination' phase: pick the highest color class and try relocating all its vertices into 1..(k-1) using best-fit order; if fails, rollback entirely.\n\nE_CODE_PERF:Current evaluate_solution is O(|E|) per call plus O(n) set building; cache adjacency and maintain (violations, color_counts) incrementally to enable O(\u0394) delta-evaluation per 1-change neighbor, drastically reducing runtime.\nE_ALLOC_PRESSURE:k_used computed via set() each call allocates; maintain an array of counts per color and track distinct colors to avoid repeated hashing.\nE_PENALTY_SCALING:Violation penalty 1e5 dwarfs color count; good for feasibility, but once feasible, k_used\u2019s influence is tiny; add lexicographic evaluation (violations, k, tie-breaker: color class balance) to guide search more deterministically.\n\nREP_INADEQUATE:Representation allows gaps and exploding color labels; canonicalize colors after each move (remap to 1..k in order of appearance) to stabilize neighborhood and improve tabu hashing.\nINIT_QUALITY:Sample solution is feasible but unconstrained about optimality guarantees; seed with DSATUR or greedy sequential coloring to start near low-k regions systematically.\n\nSA_CONFIG_FLAWS:Temperature parameters unspecified; use acceptance p=exp(-\u0394\/T) with an initial T that yields ~0.8 acceptance for uphill moves, geometric cooling T<-alpha*T (alpha\u22480.95\u20130.99), reheating on stagnation, and reheating bounds to prevent freeze.\nILS_PERTURB_WEAK:Design perturbation to escape color plateaus: (a) apply 1\u20132 Kempe-chain swaps on randomly chosen color pairs, (b) relabel colors with a random permutation, (c) random-removal of a small vertex subset followed by greedy reinsertion.\nTS_MOVE_DEFICIT:Define tabu attributes on (vertex,color) assignments with tenure\u2248[7..15], aspiration by best-known score, and prohibit reusing eliminated colors for a short horizon to force exploration.\n\nTABU_MEMORY_HASH:Without color canonicalization, tabu keys collide poorly; key on canonical (vertex,color) and optionally include conflict signature (sorted list of conflicting vertices) for stronger memory.\nDIVERSIFICATION:Introduce strategic oscillation between feasibility-first (minimize violations) and k-reduction phases; toggle when violation count hits 0 or stagnates.\n\nLOGGING_INADEQUATE:Record and return move metadata (\"NB_Type\",\"Movement_Type\"), current k, violations, and temperature\/tenure per iteration to diagnose stalls; enforce consistent extra_outputs structure for all solvers.\n\nEVAL_ASSERTION:Evaluation function validated against both a feasible sample and an independently verified reference; no discrepancies detected in constraint handling during checks.\n\nTERMINATION_CRITERIA:Add time\/iteration and no-improvement windows; for SA\/ILS, use restart budgets; for TS, include aspiration-triggered resets when tabu dominates.\n\nRISK_OF_RANDOMNESS:Fix RNG seeding for reproducibility in tests while allowing controlled unseeded runs in production; expose seed via other_params.\n\nACTIONABLE_FIXES_ORDER:\n1) Fix signatures, remove typing.List instantiations, implement perturb_solution, standardize names\/returns.\n2) Canonicalize colors after every move; implement conflict-degree prioritization.\n3) Add Kempe-chain and color-elimination neighborhoods; enable delta-evaluation.\n4) Tune SA\/ILS\/TS parameters with staged feasibility-first then k-reduction search.\n5) Add structured logging and reproducible seeding for consistent benchmarking.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INTS","EVAL_CODE":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: first minimize violations, then k, then slight balance tie-breaker\n    # Tie-breaker: variance-like penalty on class sizes to encourage compaction stability\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Build color counts for tie-breaker\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","NB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors to 1..k by order of appearance\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        ci = color\n        for j in adj[i]:\n            if state[j] == ci:\n                return False\n        return True\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        color_r = state[r]\n        if color_r not in (a, b):\n            return state[:]\n        target = a if color_r == b else b\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # Move 1: Conflict-driven recolor with smallest feasible color\n    if conflicts:\n        # pick vertex with maximum conflict degree\n        max_cd = max(conflict_deg)\n        cand = [i for i, d in enumerate(conflict_deg) if d == max_cd]\n        i = random.choice(cand)\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        palette = list(range(1, max_col+1))\n        placed = False\n        for c in palette:\n            if c != curr[i] and feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                move = (\"1-Change\", \"Conflict-Driven-Recolor\")\n                break\n        if not placed:\n            # pick a color from neighbor colors to attempt Kempe swap\n            neigh_colors = list({curr[j] for j in adj[i]})\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n                a = curr[i]\n                new_state = kempe_swap(curr, a, b, i)\n                curr = canonicalize(new_state)\n                move = (\"Kempe-Chain\", \"Conflict-Driven-Swap\")\n            else:\n                # fallback: keep as is\n                move = (\"NoMove\", \"Stall\")\n        return (curr, move)\n\n    # No conflicts: try color elimination of highest color\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n\n    # Attempt to relocate all vertices of the highest color into lower colors greedily (DSATUR-like order)\n    hv = color_vertices.get(highest, [])\n    if hv:\n        # order by saturation (distinct neighbor colors) descending\n        def sat_deg(i: int, state: List[int]) -> int:\n            return len({state[j] for j in adj[i]})\n        order = sorted(hv, key=lambda i: sat_deg(i, curr), reverse=True)\n        trial = curr[:]\n        success = True\n        for v in order:\n            # try colors 1..highest-1, best-fit (fewest conflicts) which is feasibility here\n            placed_local = False\n            for c in range(1, highest):\n                if feasible_color(v, c, trial):\n                    trial[v] = c\n                    placed_local = True\n                    break\n            if not placed_local:\n                success = False\n                break\n        if success:\n            # remove empty highest color and canonicalize\n            curr = canonicalize(trial)\n            return (curr, (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # If elimination failed, do a gentle greedy recolor of a highest-color vertex to a lower color if possible\n    if hv:\n        v = random.choice(hv)\n        for c in range(1, highest):\n            if feasible_color(v, c, curr):\n                curr[v] = c\n                curr = canonicalize(curr)\n                return (curr, (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap between two random colors\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a, b = random.sample(colors, 2)\n        # choose a vertex of color a to start\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            curr = canonicalize(kempe_swap(curr, a, b, r))\n            return (curr, (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: random safe recolor attempt\n    i = random.randrange(n)\n    for c in colors:\n        if c != curr[i] and feasible_color(i, c, curr):\n            curr[i] = c\n            curr = canonicalize(curr)\n            return (curr, (\"1-Change\", \"Fallback-Recolor\"))\n\n    return (curr, (\"NoMove\", \"NoChange\"))\n","PERTURB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n\n    # Canonicalize colors 1..k\n    def canonicalize(state: List[int]) -> List[int]:\n        seen = {}\n        nextc = 1\n        out = []\n        for x in state:\n            if x not in seen:\n                seen[x] = nextc\n                nextc += 1\n            out.append(seen[x])\n        return out\n\n    curr = canonicalize(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        from collections import deque as _dq\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = _dq([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            new_state[u] = a if state[u] == b else (b if state[u] == a else state[u])\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across random color pairs\n    k = len(set(curr)) if curr else 1\n    t_swaps = 1 if k <= 3 else 2\n    for _ in range(t_swaps):\n        colors = sorted(set(curr))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize(curr)\n\n    # 3) Random removal and greedy reinsertion for a small subset\n    k = len(set(curr))\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    removed = {i: curr[i] for i in idxs}\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n    # Reinsertion by highest saturation first\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n    order = sorted(idxs, key=lambda i: sat_deg(i, curr), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k) + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            curr[i] = max([x for x in curr if isinstance(x, int)]) + 1\n            k = len(set([x for x in curr if x > 0]))\n    curr = canonicalize(curr)\n\n    return curr\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Type List cannot be instantiated; use list(). Root cause: using typing.List as a callable or shadowing built-in list. Replace all List() with list() and ensure no variable is named 'List'.\nSIG_MISMATCH:Heuristic implementations do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Unify to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nCALLABLE_ARGS_ERROR:Do not pass generate_neighbour() or evaluate_solution() with parentheses in signatures or calls; pass function objects generate_neighbour and evaluate_solution.\nMISSING_PERTURB:$Perturb placeholder unresolved. Define a valid perturb_solution(state,rng,params) that performs non-destructive multi-vertex moves (e.g., random Kempe-chain swap, random recolor of t vertices).\nILS_API_INCOMPAT:ILS signature shown differs from target. Wrap ILS under the unified Heuristic interface and internally manage iterations and acceptance; do not expose separate parameters in signature.\nSA_API_INCOMPAT:SA function signature shown differs from target. Conform to unified Heuristic interface and take annealing parameters via other_params dict. Avoid typing.* in runtime paths.\nTS_API_INCOMPAT:TS signature shown differs from target. Conform to unified Heuristic interface and take taboo_list_size, taboo_duration via other_params dict. Ensure tabu list stores (vertex,color) tuples, not full solutions.\nEVAL_SCALE_MISMATCH:EXPECTED_SCORE_FROM_KNOWN_SOLUTION reports 4 but evaluator returns scores scaled by 1e3 when feasible. Normalize reporting or divide feasible k by 1e3 when displaying human-readable results; do not change evaluate_solution.\nEVAL_TIE_BREAKER_NOISE:Balance penalty min(balance,999) introduces minor non-lexicographic noise across equal k. If deterministic behavior is required for acceptance checks, set this cap to 0 in a comparator wrapper (not in evaluate_solution).\nNB_CANONICALIZE_HASH_BREAK:In-neighbour canonicalize() changes color IDs every move, invalidating tabu hashing and frequency memory. Move canonicalization to acceptance layer or maintain a stable color mapping; for TS store canonical forms or stable labels.\nNB_CONFLICT_SELECTION_WEAK:Selecting a random vertex among max conflict-degree ties increases variance. Use deterministic secondary key: higher degree or higher saturation degree to reduce drift.\nNB_LOCAL_OPT:Only single-vertex recolor and Kempe-chain; lacks strong intensification. Add color class merge trials with recursive backtracking for small |V|; add exchange of two vertices across color classes when both remain feasible.\nNB_REDUCTION_INCOMPLETE:Color-elimination attempts greedy placement without backtracking; fails on near-feasible cases. Add limited-depth backtracking (depth<=2) for remaining vertices of highest color before giving up.\nNB_DIVERSIFICATION_SCOPE:Random color pair Kempe-swap without assessment may increase conflicts drastically. Constrain to pairs involving the highest color or colors with largest class sizes; reject swaps that increase violations above a threshold.\nPERTURBATION_WEAK:No perturbation exists. Implement a parameterized k-shake: select t vertices from largest color classes and recolor to random feasible lower colors; if none feasible, temporarily allow one conflict then repair with DSATUR.\nREP_STABILITY:Canonicalization by encounter order depends on vertex iteration order, causing non-reproducible color IDs. Canonicalize by sorting colors by smallest vertex index to stabilize IDs.\nLOCAL_ACCEPTANCE_RULE:Not defined. For SA, accept if \u0394<0 or exp(-\u0394\/T)>U; for ILS, accept only improvements; for TS, accept best admissible (aspiration if improves best). Ensure these decisions strictly use evaluate_solution outputs.\nPARAM_SCHEDULES:No temperature\/cooling or tabu tenure tuning. Recommended defaults: T0=1e4, Tmin=1e-3, alpha=0.95 per outer iteration; tabu_tenure in [5,10]; iterations set per budget via other_params.\nE_CODE_PERF:Repeated full evaluation per neighbor is O(|E|). Implement incremental delta evaluation: maintain color counts and conflict count; when recoloring vertex i from a to b, \u0394violations equals (#neighbors color b) - (#neighbors color a).\nE_ASSERT_CORRECTNESS:Evaluation verified via python tool; reference feasible solution returns the same scaled cost as another feasible provided solution, confirming evaluator consistency on feasibility and k. Integrate an automated unit test asserting equal scores for any two feasible k-equal colorings.\nR_STR_CONSTRAINTS:INDEX_LIST_LEN_9_POSITIVE_INTS enforced only in evaluator. Add input sanitizer in Heuristic to clamp length to 9 and remap non-positive to valid colors before search.\nLOG_EXTRA_OUTPUTS:Local solver expects extra outputs. Include per-iteration logs: iter, score, violations, k_used, move_type, acceptance_flag, temperature\/tenure. Emit final best, its score, and move histogram.\nTABU_MEMORY_TYPE:Store tabu on (vertex,color) with dynamic tenure; add aspiration criterion if candidate improves best_score. Maintain frequency memory to bias selection away from overused colors.\nMOVE_HEURISTIC_ORDER:When conflicts exist, prioritize recolor of vertex with highest saturation among conflicted; when feasible, try colors not present in neighborhood with least global frequency.\nREPAIR_OPERATOR:Integrate DSATUR-based repair step after perturbation: order uncolored\/conflicted vertices by saturation, assign smallest feasible color, open new color only if needed and record opening events.\nTEST_SEED_CONTROL:Randomness without seed control harms reproducibility. Add rng in other_params and consistently use it for all random choices; avoid global random.\nACCEPTANCE_GUARD:Reject any neighbor increasing violations by more than v_threshold (e.g., +2) unless temperature permits; prevents destructive wandering.\nUNIT_TESTS:Add tests: (1) evaluator penalties for wrong length\/non-int\/non-pos, (2) equal scores for any permutation of color labels, (3) canonicalization stability, (4) neighbor always returns valid length and positive ints.\nIMPLEMENTATION_NOTE:Ensure 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS is respected; avoid any OS\/file\/network calls in heuristics and operators.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTS","Componentes":{"REPRESENTATION":"INDEX_LIST_LEN_9_POSITIVE_INTS","EVAL_CODE":"import math\nimport random\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[List[int], Tuple[int, ...]]) -> int:\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Validation and normalization penalties\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Ensure all entries are ints >= 1; penalize otherwise\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n    if non_int or non_pos:\n        base = 5 * 10**8\n        return base + non_int * 10**7 + non_pos * 10**6\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Stable tie-breaker on color class sizes\n    counts = {}\n    for x in solution:\n        counts[x] = counts.get(x, 0) + 1\n    sizes = list(counts.values())\n    mean = sum(sizes) \/ len(sizes)\n    balance = int(sum((s - mean) * (s - mean) for s in sizes))\n\n    score = violations * 10**6 + k_used * 10**3 + min(balance, 999)\n    return int(score)\n","NB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Normalize input\n    if not isinstance(solution, (list, tuple)):\n        return (solution, (\"InvalidInput\", \"NoMove\"))\n    curr = list(solution)\n    if len(curr) != n:\n        # Robust resize\n        curr = (curr[:n] + [1]*n)[:n]\n    # Sanitize entries\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization: relabel colors by sorting colors by smallest vertex index they appear on\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def k_used(state: List[int]) -> int:\n        return len(set(state))\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i]})\n\n    # Conflict analysis\n    conflicts = []\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if curr[u] == curr[v]:\n            conflicts.append((u, v))\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    max_col = max(curr) if curr else 1\n\n    # Kempe-chain swap between colors a and b starting at root r\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([r])\n        visited[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not visited[w] and state[w] in comp_colors:\n                    visited[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # Helper: count conflicts quickly\n    def conflict_count(state: List[int]) -> int:\n        cnt = 0\n        for (u, v) in edges0:\n            if state[u] == state[v]:\n                cnt += 1\n        return cnt\n\n    # Move 1: Conflict-driven recolor with deterministic tie-breaking\n    if conflicts:\n        # vertices involved in a conflict\n        involved = sorted({u for uv in conflicts for u in uv})\n        # choose vertex with max conflict degree, then higher saturation, then higher static degree, then lower index\n        deg = [len(adj[i]) for i in range(n)]\n        best_i = max(involved, key=lambda i: (conflict_deg[i], sat_deg(i, curr), deg[i], -i))\n        i = best_i\n        # try recolor to smallest feasible within 1..max_col (avoid opening new color)\n        for c in range(1, max_col+1):\n            if c != curr[i] and feasible_color(i, c, curr):\n                new_state = curr[:]\n                new_state[i] = c\n                return (canonicalize_stable(new_state), (\"1-Change\", \"Conflict-Driven-Recolor\"))\n        # try Kempe swap with a neighbor color that reduces same-color neighbors\n        neigh_colors = sorted({curr[j] for j in adj[i]})\n        base_same = sum(1 for j in adj[i] if curr[j] == curr[i])\n        for b in neigh_colors:\n            a = curr[i]\n            trial = kempe_swap(curr, a, b, i)\n            # accept if it reduces or keeps local same-color count, and does not explode conflicts\n            new_same = sum(1 for j in adj[i] if trial[j] == trial[i])\n            if new_same <= base_same and conflict_count(trial) <= conflict_count(curr) + 1:\n                return (canonicalize_stable(trial), (\"Kempe-Chain\", \"Conflict-Driven-Swap\"))\n        # fallback: no change\n        return (curr, (\"NoMove\", \"Stall\"))\n\n    # No conflicts: try color elimination of highest color with limited backtracking\n    k = k_used(curr)\n    highest = k\n    color_vertices = {c: [i for i, x in enumerate(curr) if x == c] for c in range(1, k+1)}\n    hv = color_vertices.get(highest, [])\n    if hv:\n        order = sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n        trial = curr[:]\n        palette = list(range(1, highest))\n\n        def backtrack(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            for c in palette:\n                if feasible_color(v, c, trial):\n                    old = trial[v]\n                    trial[v] = c\n                    if backtrack(idx+1):\n                        return True\n                    trial[v] = old\n            return False\n\n        if backtrack(0):\n            trial2 = [x if x != highest else highest for x in trial]\n            # remove empty class via canonicalization\n            return (canonicalize_stable(trial2), (\"Multi-Vertex\", \"Color-Elimination\"))\n\n    # Gentle greedy reduction: move one vertex from highest color to a lower color\n    if hv:\n        for v in sorted(hv, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True):\n            for c in range(1, highest):\n                if feasible_color(v, c, curr):\n                    new_state = curr[:]\n                    new_state[v] = c\n                    return (canonicalize_stable(new_state), (\"1-Change\", \"Greedy-Reduction\"))\n\n    # Diversification: Kempe-chain swap involving highest and another color (feasibility preserved)\n    colors = list(range(1, k+1))\n    if k >= 2:\n        a = highest\n        b = random.choice([c for c in colors if c != a])\n        cand_a = [i for i, x in enumerate(curr) if x == a]\n        if cand_a:\n            r = random.choice(cand_a)\n            return (canonicalize_stable(kempe_swap(curr, a, b, r)), (\"Kempe-Chain\", \"Diversification\"))\n\n    # Fallback: return unchanged\n    return (curr, (\"NoMove\", \"NoChange\"))\n","PERTURB_CODE":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[List[int], Tuple[int, ...]]):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return solution\n    curr = list(solution)\n    if len(curr) != n:\n        curr = (curr[:n] + [1]*n)[:n]\n    curr = [int(x) if isinstance(x, int) and x >= 1 else 1 for x in curr]\n\n    # Stable canonicalization\n    def canonicalize_stable(state: List[int]) -> List[int]:\n        pos = {}\n        for i, c in enumerate(state):\n            if c not in pos:\n                pos[c] = i\n        order = sorted(pos.items(), key=lambda t: t[1])\n        remap = {c: idx+1 for idx, (c, _) in enumerate(order)}\n        return [remap[c] for c in state]\n\n    curr = canonicalize_stable(curr)\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def feasible_color(i: int, color: int, state: List[int]) -> bool:\n        if color < 1:\n            return False\n        for j in adj[i]:\n            if state[j] == color:\n                return False\n        return True\n\n    # Kempe-chain utility\n    def kempe_swap(state: List[int], a: int, b: int, r: int) -> List[int]:\n        if state[r] not in (a, b):\n            return state[:]\n        comp_colors = {a, b}\n        vis = [False]*n\n        q = deque([r])\n        vis[r] = True\n        comp = [r]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if not vis[w] and state[w] in comp_colors:\n                    vis[w] = True\n                    q.append(w)\n                    comp.append(w)\n        new_state = state[:]\n        for u in comp:\n            if new_state[u] == a:\n                new_state[u] = b\n            elif new_state[u] == b:\n                new_state[u] = a\n        return new_state\n\n    # 1) Apply 1-2 Kempe-chain swaps across pairs involving the largest color class\n    colors = sorted(set(curr))\n    class_sizes = {c: sum(1 for x in curr if x == c) for c in colors}\n    largest = max(colors, key=lambda c: class_sizes[c]) if colors else 1\n    t_swaps = 1 if len(colors) <= 3 else 2\n    for _ in range(t_swaps):\n        colors_now = sorted(set(curr))\n        if len(colors_now) >= 2:\n            a = largest if largest in colors_now else colors_now[-1]\n            b = random.choice([c for c in colors_now if c != a])\n            cand = [i for i, c in enumerate(curr) if c in (a, b)]\n            if cand:\n                r = random.choice(cand)\n                curr = canonicalize_stable(kempe_swap(curr, a, b, r))\n\n    # 2) Random permutation of color labels (diversify, then stabilize)\n    colors = sorted(set(curr))\n    perm = colors[:]\n    random.shuffle(perm)\n    remap = {c: perm[idx] for idx, c in enumerate(colors)}\n    curr = [remap[c] for c in curr]\n    curr = canonicalize_stable(curr)\n\n    # 3) Random removal and greedy reinsertion for a subset (shake-and-repair)\n    k = len(set(curr)) if curr else 1\n    m = max(2, min(4, n \/\/ 3))\n    idxs = random.sample(list(range(n)), m)\n    for i in idxs:\n        curr[i] = 0  # mark uncolored\n\n    def sat_deg(i: int, state: List[int]) -> int:\n        return len({state[j] for j in adj[i] if state[j] > 0})\n\n    order = sorted(idxs, key=lambda i: (sat_deg(i, curr), len(adj[i]), -i), reverse=True)\n    for i in order:\n        placed = False\n        palette = list(range(1, max(1, k))) if k > 1 else [1]\n        random.shuffle(palette)\n        for c in palette:\n            if feasible_color(i, c, curr):\n                curr[i] = c\n                placed = True\n                break\n        if not placed:\n            # open a new color as last resort\n            new_c = (max([x for x in curr if isinstance(x, int)], default=0) + 1)\n            curr[i] = new_c\n            k = len(set([x for x in curr if isinstance(x, int) and x > 0]))\n\n    curr = [1 if x == 0 else x for x in curr]\n    curr = canonicalize_stable(curr)\n\n    return curr\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"F_LOCAL_SOLVER_ERROR_SIG\",\"Type instantiation bug: 'List()' is invalid (typing.List is not constructible). Replace all 'List()' with 'list()' and avoid using typing classes as constructors.\"\n\"F_LOCAL_SOLVER_ERROR_API\",\"Signature mismatch: solvers expose SA\/ILS\/TS custom signatures instead of TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement a single entry-point 'Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)'.\"\n\"F_PERTURB_MISSING\",\"Perturbation function undefined ('$Perturb' placeholder). Any call to it will fail. Provide a concrete 'perturb_solution' implementation.\"\n\"F_NEIGH_MOVE_STALL\",\"Neighbour sometimes returns ('NoMove','Stall') without fallback diversification when conflicts exist. This creates stagnation and violates progress pressure.\"\n\"F_NEIGH_SCOPE_LIMITED\",\"Operators are limited to single-vertex recolor, Kempe chain, and greedy reduction. No explicit color-class merge\/split, pairwise vertex swap, or ejection chains. This restricts escape from plateaus.\"\n\"F_NEIGH_ACCEPTANCE_WEAK\",\"Kempe swap acceptance only checks local same-color count and permits +1 conflict globally. This can allow neutral but cyclic moves; suggest conflict delta and k_used-aware acceptance.\"\n\"F_CANONICALIZATION_INCONSISTENT\",\"Canonicalization applied in neighbour only; evaluation and outer loop may treat semantically identical colorings as distinct. This harms tabu hashing\/restart detection.\"\n\"F_RANDOMNESS_REPRO\",\"Randomness seeded implicitly via global RNG. Lack of seeded RNG in 'other_params' limits reproducibility and testability.\"\n\"F_EVAL_TIEBREAK\",\"Balance term truncated at 999. This can induce excessive ties at fixed k, weakening gradient for intra-k balancing. Consider proportional penalty or lexicographic objective handling externally.\"\n\"F_EVAL_PENALTY_SCALE\",\"Penalty scales 1e6 >> 1e3 create near-lexicographic ordering but can distort SA temperature schedules; document or normalize for annealing.\"\n\"F_PARAM_UNUSED\",\"'other_params' not used to control temps\/iterations\/tabu sizes; hyperparameters hard-coded or absent.\"\n\"F_LOGGING_INADEQUATE\",\"Local solver expects extra outputs. Current operator returns only move tags; no trace of scores, k_used, conflicts, or acceptance stats, limiting diagnosis.\"\n\"F_COMPLEXITY\",\"Each neighbour evaluation is O(|E|) due to recolor feasibility checks and conflict_count calls; repeated recomputation without caching wastes cycles.\"\n\"F_CONSTRAINT_ENFORCEMENT\",\"Representation normalization silently coerces invalid entries to 1. This masks upstream bugs; better to reject and penalize or repair with feasibility-aware mapping.\"\n\"R_STR_INADEQUATE\",\"Index-list without domain restriction on max color allows unbounded color inflation. Enforce upper bound k_max in operators to avoid drift.\"\n\"NB_CODE_FAIL_LOCAL_OPT\",\"Conflict-driven recolor uses only smallest feasible color; add saturation-degree-based multi-try and min-conflict heuristic with lookahead for stronger local descent.\"\n\"NB_DIVERSIFICATION_WEAK\",\"Diversification picks random Kempe chain for highest color only. Add random vertex ejection to random feasible color and occasional class relabel shuffle.\"\n\"TS_MEMORY_WEAK\",\"No tabu attributes; if implementing TS, tabu on (vertex,color) with aspiration by best improves cycling resistance.\"\n\"E_CORRECTNESS_CHECK\",\"Evaluation tested against provided reference instance via independent run; results consistent. No discrepancies detected.\"\n\"SUG_SIG_FIX\",\"Implement unified API wrapper converting legacy SA\/ILS\/TS into the TARGET_HEURISTIC_GENERAL_SIGNATURE to conform with the orchestrator.\"\n\"PATCH_CODE_HEURISTIC\",\"def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params):\\n    # Parameters\\n    iters = int(other_params.get('iters', 1000))\\n    max_no_improve = int(other_params.get('max_no_improve', 200))\\n    use_sa = bool(other_params.get('use_sa', True))\\n    T = float(other_params.get('temp', 1.0))\\n    Tmin = float(other_params.get('min_temp', 1e-3))\\n    alpha = float(other_params.get('cooling', 0.995))\\n    rng = other_params.get('rng', None)\\n    if rng is None:\\n        import random\\n        rng = random\\n    # Normalize inputs\\n    curr = list(currentSolution)\\n    curr_score = evaluate_solution(curr)\\n    if best is None:\\n        best = list(curr)\\n        best_score = curr_score\\n    no_improve = 0\\n    logs = []\\n    def k_used(sol):\\n        return len(set(sol))\\n    for t in range(iters):\\n        neigh, move = generate_neighbour(curr)\\n        neigh_score = evaluate_solution(neigh)\\n        delta = neigh_score - curr_score\\n        accept = False\\n        if use_sa:\\n            if delta <= 0:\\n                accept = True\\n            else:\\n                if T > 0.0:\\n                    import math\\n                    p = math.exp(-delta \/ max(T, 1e-12))\\n                    if rng.random() < p:\\n                        accept = True\\n        else:\\n            accept = delta <= 0\\n        if accept:\\n            curr, curr_score = neigh, neigh_score\\n        else:\\n            # occasional perturbation on stall\\n            if no_improve > 0 and (no_improve % 25 == 0):\\n                curr = perturb_solution(curr, rng)\\n                curr_score = evaluate_solution(curr)\\n        # best update\\n        if curr_score < best_score:\\n            best, best_score = list(curr), curr_score\\n            no_improve = 0\\n        else:\\n            no_improve += 1\\n        # temperature schedule\\n        if use_sa and T > Tmin:\\n            T = max(Tmin, T * alpha)\\n        # adaptive perturbation if stagnating\\n        if no_improve >= max_no_improve:\\n            curr = perturb_solution(best, rng)\\n            curr_score = evaluate_solution(curr)\\n            no_improve = 0\\n        # minimal extra outputs expected\\n        logs.append((t, curr_score, best_score, k_used(curr), move))\\n    return curr, best, best_score, {'logs': logs, 'final_temp': T}\\n\"\n\"PATCH_CODE_PERTURB\",\"def perturb_solution(solution, rng=None):\\n    # Safe, file\/network\/OS-free\\n    if rng is None:\\n        import random\\n        rng = random\\n    n = len(solution)\\n    if n == 0:\\n        return list(solution)\\n    sol = list(solution)\\n    colors = sorted(set(sol))\\n    if not colors:\\n        return sol\\n    # Strategy: apply m random Kempe-chain-like swaps by relabeling a random subset\\n    m = max(1, n \/\/ 3)\\n    for _ in range(m):\\n        i = rng.randrange(n)\\n        ci = sol[i]\\n        # pick another existing color or create a temporary new color with small prob\\n        if rng.random() < 0.2:\\n            cj = max(colors) + 1\\n        else:\\n            cj = rng.choice([c for c in colors if c != ci]) if len(colors) > 1 else ci\\n        if cj == ci:\\n            continue\\n        # relabel a small random connected-like neighborhood approximation: same-color neighbors by index proximity\\n        radius = rng.randint(1, 2)\\n        for j in range(max(0, i - radius), min(n, i + radius + 1)):\\n            if sol[j] == ci or sol[j] == cj:\\n                sol[j] = cj if sol[j] == ci else ci\\n        # occasionally recolor a random vertex to an existing color to reduce colors\\n        if rng.random() < 0.3 and len(colors) > 1:\\n            v = rng.randrange(n)\\n            sol[v] = rng.choice(colors)\\n        colors = sorted(set(sol))\\n    return sol\\n\"\n\"PATCH_CODE_TABU_WRAPPER\",\"def TabuWrapper(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params):\\n    # Minimal TS compliant with constraints (no FS\/OS\/network)\\n    tenure = int(other_params.get('tabu_tenure', 7))\\n    iters = int(other_params.get('iters', 1000))\\n    aspirate = True\\n    from collections import deque\\n    curr = list(currentSolution)\\n    curr_score = evaluate_solution(curr)\\n    if best is None:\\n        best, best_score = list(curr), curr_score\\n    tabu = {}\\n    trail = deque()\\n    logs = []\\n    def move_key(old, new):\\n        # key on (vertex,color)\\n        diffs = [(i, new[i]) for i in range(len(old)) if old[i] != new[i]]\\n        return tuple(diffs)\\n    for t in range(iters):\\n        candidate, info = generate_neighbour(curr)\\n        cand_score = evaluate_solution(candidate)\\n        key = move_key(curr, candidate)\\n        is_tabu = key in tabu\\n        accept = False\\n        if not is_tabu:\\n            accept = True\\n        else:\\n            if aspirate and cand_score < best_score:\\n                accept = True\\n        if accept:\\n            curr, curr_score = candidate, cand_score\\n            tabu[key] = t + tenure\\n            trail.append(key)\\n        if curr_score < best_score:\\n            best, best_score = list(curr), curr_score\\n        # expire tabu\\n        while trail and tabu.get(trail[0], -1) <= t:\\n            oldk = trail.popleft()\\n            tabu.pop(oldk, None)\\n        logs.append((t, curr_score, best_score, info))\\n        if t % 50 == 49:\\n            curr = perturb_solution(best)\\n            curr_score = evaluate_solution(curr)\\n    return curr, best, best_score, {'logs': logs, 'tabu_size': len(tabu)}\\n\"\n\"SUG_NEIGH_IMPROVE\",\"Add operators: (a) vertex pair swap across two colors; (b) color-class merge with guided reassign; (c) ejection chains moving a path of vertices; (d) multi-vertex recolor via bounded DFS on a conflicted subgraph.\"\n\"SUG_ACCEPTANCE\",\"Evaluate and accept neighbours by primary key (violations, k_used) lexicographically to avoid misleading balance ties; or compute score deltas with separate weights and temperature per component.\"\n\"SUG_CACHE\",\"Cache per-vertex color conflicts and adjacency color sets; update incrementally on single-vertex changes to reduce O(|E|) recomputation to O(deg(v)).\"\n\"SUG_SEEDING\",\"Expose 'seed' in other_params and initialize a local rng to ensure reproducibility.\"\n\"SUG_CANONICALIZE_GLOBAL\",\"Apply the same canonicalization after every accepted move before hashing\/logging to stabilize state identity for tabu\/restart logic.\"\n\"SUG_PARAM\",\"Expose and tune hyperparameters: iters, cooling, temp schedule, max_no_improve, perturbation strength, tabu_tenure; read from 'other_params'.\"\n\"SUG_DIAG_EXTRAS\",\"Log at each iteration: (iter, curr_score, best_score, k_used, move_type). Provide aggregate stats over runs for automated regression tests.\"\n\"SUG_EVAL_GUARD\",\"On invalid solutions, prefer immediate repair using feasible recolor attempts before returning heavy penalties to keep search on-manifold.\"\n\"SUG_K_PRUNING\",\"When conflict-free, enforce explicit highest-color elimination with iterative deepening on the smallest color class before random diversification.\"\n\"VERIFY_EVAL_AGAINST_REF\",\"Passed. Internal check confirms evaluation consistency with reference instance; proceed with heuristic integration.\"\n\"END\",\"\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS. Example: \"1,2,3,4,1,2,3,4,1\". Each position i in [1..9] is color c_i in {1,2,...,k}.","Componentes":{"REPRESENTATION":"COMMA_SEPARATED_9_INTS. Example: \"1,2,3,4,1,2,3,4,1\". Each position i in [1..9] is color c_i in {1,2,...,k}.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            return [int(p) for p in parts]\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"E_RUNTIME_RANDOM_UNDEFINED:Local solvers raise NameError 'random' not defined. Add 'import random' at module scope or inject a rng object into all solver functions.\nE_SIGNATURE_MISMATCH:Solver signatures (SA\/ILS\/TS) do not match TARGET_HEURISTIC_GENERAL_SIGNATURE and incorrectly pass generate_neighbour()\/evaluate_solution() as calls instead of function references. Align to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and pass callables, not results.\nE_PERTURB_ABSENT:Perturbation Function is '$Perturb' placeholder. Define a concrete perturb_solution avoiding filesystem\/network\/OS access per MAIN_CRITICAL_INSTRUCTION.\nE_SOLVER_API_CONSISTENCY:Current SA\/ILS\/TS names, parameters, and return types are inconsistent. Standardize all to consume\/return (solution_as_string, score) and to accept (generate_neighbour, evaluate_solution, perturb_solution).\nE_STATEFUL_RANDOMNESS:No seed control or RNG encapsulation. Add seed parameter or rng object for reproducibility and debugging.\nE_TS_TABU_KEY:Tabu list unspecified\/mis-scoped. Use move-attribute tabu (vertex,color) with dynamic tenure; add aspiration if best-improving.\nE_ILS_ACCEPTANCE:Acceptance rule undefined\/underspecified. Implement explicit acceptance (e.g., accept if score <= incumbent or with probability exp(-(\u0394)\/T)) and restart schedule.\nE_SA_SCHEDULE:Cooling params TEMP\/MIN_TEMP\/cooling_factor unchecked and may stall. Use geometric cooling T*=alpha (alpha in [0.90,0.99]), reheats on stagnation, and stop when no improvement over X iterations.\nE_NEIGHBOR_SCOPE_LIMITED:Only single-vertex recolor. Add Kempe-chain interchanges, color-class swaps, and targeted max-color elimination moves to escape plateaus.\nE_PALETTE_LOCK:palette_max = max(2,k_hat) prevents deliberate k reduction. Add dedicated 'reduce-k' phase that attempts to recolor highest color into [1..k_hat-1] using Kempe chains or backtracking for affected subgraph.\nE_REP_SYMMETRY:Color labels are arbitrary; search suffers from symmetry. Canonicalize by compressing\/renaming colors to contiguous [1..k_hat] and lexicographically minimal relabeling after each move.\nE_PARSE_OVERHEAD:String parsing on every evaluation is costly. Maintain list[int] internally; convert to string only at API edges. Provide dual interfaces or a small adapter.\nE_EVAL_COST:omega and k-colorability are recomputed per evaluation. Cache omega once; gate backtracking checks behind events that reduce k_hat to avoid exponential cost each step.\nE_OBJ_PLATEAU:Fixed optimality_penalty=100 introduces wide plateaus. Replace with smooth merit: score = k_hat + \u03bb\u00b7violations + \u03bc\u00b7(max_color_load variance) and zero violations for feasibility; or anneal the penalty weight.\nE_MOVE_REPAIR_WEAK:Single-pass neighbor repair may leave immediate conflicts. Use greedy recolor with DSATUR order on local neighborhood until conflict-free or abort move.\nE_INIT_STRATEGY:Sample solution feasible but not guided. Build initial solutions with DSATUR\/Greedy with random tie-breaking to start near low k_hat while preserving diversity.\nE_TABU_MEMORY_BLOAT:Do not store whole solutions. Store only recent moves with tenure L\u2248n to avoid excessive memory and false prohibitions.\nE_STOPPING_CRITERIA:No explicit termination conditions beyond errors. Add max evaluations, time budget, and no-improvement window.\nE_LOGGING_DIAG:No traceability. Log (iter, score, k_hat, violations, move_type) to detect stagnation and tune parameters; ensure logs avoid FS\/OS access.\nE_CONSTRAINT_GUARD:Audit all code for MAIN_CRITICAL_INSTRUCTION compliance; remove\/avoid any FS\/network\/OS calls.\nEVAL_ASSERT:evaluate_solution validated against the provided reference; returned score matched the expected value.\nFIX_LOCAL_SOLVER_ERRORS_FIRST_PATCH: \n- Add 'import random' in solver modules or pass rng.\n- Conform to TARGET_HEURISTIC_GENERAL_SIGNATURE; wrap SA\/ILS\/TS inside Heuristic adapter that dispatches based on other_params['method'].\n- Replace '$Perturb' with: def perturb_solution(sol): return generate_neighbour(sol)[0] applied t times, or a multi-vertex Kempe-chain perturbation.\n- Ensure solvers pass function references generate_neighbour\/evaluate_solution\/perturb_solution and handle their inputs\/outputs consistently.\nNEIGHBOR_UPGRADES:\n- NB_Kempe: pick conflicting vertex u and color a!=b; flip Kempe component between colors a,b.\n- NB_SwapColors: swap two color classes that reduce adjacent conflicts or lower max color usage.\n- NB_TargetedReduce: for vertices with max color k_hat, try assign in [1..k_hat-1] with local BFS constraint propagation; if success and class k_hat empty, decrement k_hat.\nPERF_OPT:\n- Cache adjacency, degrees, and omega globally.\n- Memoize evaluate_solution for recently seen assignments via compact hashing of color list.\n- Avoid repeated string splitting\/joining in hot loops; keep list[int] during search.\nTESTS_MINIMAL:\n- Unit-test neighbor never returns invalid length or color<1.\n- Assert evaluate_solution decreases or remains after accepted moves; catch regressions quickly.\n\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Componentes":{"REPRESENTATION":"COMMA_SEPARATED_9_INTS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n    omega = max_clique_size()\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n    def k_colorable(k):\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    # determine current k and allowed palette [1..max(2,k)] to keep feasible search\n    k_hat = max(1, max(colors))\n    palette_max = max(2, k_hat)\n    # pick a vertex to recolor; prioritize conflicts, else random\n    conflict_vertices = []\n    color_list = list(colors)\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.append(u)\n            conflict_vertices.append(v)\n    if conflict_vertices:\n        idx = random.choice(conflict_vertices) - 1\n    else:\n        idx = random.randrange(n)\n    current_color = color_list[idx]\n    # choose a new color different from current\n    choices = [c for c in range(1, palette_max+1) if c != current_color]\n    if not choices:\n        choices = [current_color]\n    new_color = random.choice(choices)\n    color_list[idx] = new_color\n    # slight greedy repair: if new assignment creates direct conflict with any neighbor, try one alternative if available\n    neighbors = set()\n    for (u,v) in edges:\n        if u-1 == idx:\n            neighbors.add(v-1)\n        elif v-1 == idx:\n            neighbors.add(u-1)\n    if any(color_list[idx] == color_list[j] for j in neighbors):\n        alt = [c for c in range(1, palette_max+1) if c != current_color and all(c != color_list[j] for j in neighbors)]\n        if alt:\n            color_list[idx] = random.choice(alt)\n    return stringify(color_list), \"NB_Recolor\", \"Single-Vertex\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n    k_hat = max(1, max(colors))\n    palette_max = max(3, k_hat)  # allow one extra color occasionally to traverse infeasible\/plateau regions\n    q = random.randint(2, 4)  # perturb 2..4 vertices\n    idxs = random.sample(range(n), q)\n    new_colors = list(colors)\n    for idx in idxs:\n        cur = new_colors[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        new_colors[idx] = random.choice(choices)\n    return stringify(new_colors)\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_IMPORT_RANDOM:Heuristics fail due to missing import. Add 'import random' at top of all heuristic modules to prevent NameError.\nE_PERTURB_UNDEFINED:Perturbation placeholder '$Perturb' is unresolved. Implement a concrete 'perturb_solution(solution)' function returning a valid neighbor string; e.g., apply a multi-vertex Kempe-chain swap or random recolor of t vertices.\nE_FUNC_NAME_MISMATCH:Reported 'Taboo_Search' vs standard 'Tabu'. Standardize to 'Tabu_Search' to avoid loader mismatches.\nE_SIG_MISMATCH:Local solvers use custom signatures (SA\/ILS\/TS) inconsistent with TARGET_HEURISTIC_GENERAL_SIGNATURE. Provide a wrapper 'Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' that dispatches to SA\/ILS\/TS based on 'other_params', or refactor solvers to match the required signature.\nE_GEN_NEIGH_API:Signatures shown as 'generate_neighbour()' in logs suggest incorrect invocation. Ensure the engine passes the function object, then call as 'generate_neighbour(solution)' internally. Validate return type is a 3-tuple; ignore metadata if the solver expects only the neighbor string.\nE_STATEFUL_SEEDING:Missing RNG seeding creates nondeterministic tests. Add optional 'seed' in other_params and seed RNG locally to ensure reproducibility when required.\nEVAL_COST_EXPENSIVE:evaluate_solution recomputes omega via O(2^n) brute force and runs exponential k-colorability for k<k_hat every call. Cache 'omega', 'adj', and 'edge_set' once, and memoize k_colorable(k). Consider early-exit: if violations>0, skip optimality checks entirely.\nEVAL_INCR_DISABLED:No delta-evaluation. For single-vertex recolors, compute only changed conflicts and updated k_hat incrementally to reduce time from O(|E|) to O(deg(v)).\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to recolor of one vertex with palette_max=max(2,k_hat), which blocks exploration to fewer colors and can stagnate in plateaus. Add directed moves: (1) greedy recolor to smallest feasible color, (2) color-merge attempt (try to eliminate color k_hat by recoloring its vertices), (3) Kempe-chain interchanges to escape conflicts without increasing palette.\nNB_CONFLICT_PRIORITY_WEAK:Conflict target selection duplicates vertices and skews distribution. Replace with frequency-weighted selection over unique conflict vertices or max-conflict vertex to intensify repair.\nNB_PALETTE_POLICY:Using palette_max=max(2,k_hat) prevents trying k_hat-1 unless by chance. Add a periodic 'reduce-color' phase: freeze palette to [1..k_hat-1], attempt repair via tabu\/Kempe. If fails after T steps, revert.\nNB_RETURN_FORMAT:Generator returns (string,'NB_Recolor','Single-Vertex'). Ensure solvers consume only the first element or adapt parsers; otherwise, parsing errors propagate.\nH_SA_PARAM_WEAK:Missing temperature schedule details. Use geometric cooling with reheat on stagnation, e.g., T*=alpha per step, reheat when acceptance<r_min for R iterations. Bound iterations per temperature to O(n) neighbors to limit cost.\nH_TS_MEMORY:Tabu tenure\/dimensions unspecified. Maintain tabu on (vertex,color) moves with dynamic tenure in [tenure_min,tenure_max] based on conflict count. Add aspiration for best-so-far improvements.\nH_ILS_NO_ACCEPT:Acceptance misspelled 'aceptance_rate' and undefined policy. Implement proper acceptance (e.g., accept if score<=current or with prob exp(-(delta)\/T)) and define perturb strength proportional to stagnation.\nR_STR_INADEQUATE:Single list of colors without color-class structure hinders color elimination. Maintain auxiliary color-classes (lists of vertices per color) to accelerate feasibility checks and color-drop attempts.\nSEARCH_STOPPING:No stopping criteria specified. Add max_evals, max_time, and no_improve_budget to prevent unbounded runs and to standardize benchmarking.\nTEST_HARNESS:No unit tests for parser\/stringify. Add quick tests for malformed inputs, length!=9, and out-of-domain values to prevent silent penalties.\nEVAL_ASSERT:Evaluator verified to return a finite feasible score for a known-valid reference; harness consistency confirmed. Do not hardcode any target values; rely on evaluate_solution only.\nCONCRETE_FIX_IMPORT:At top of each heuristic file add: 'import random, math' and guard: 'from typing import Any, Tuple' as needed.\nCONCRETE_FIX_WRAPPER:Provide a compliant entry-point:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    algo=other_params.get('algo','SA')\n    if algo=='SA': return SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,other_params.get('TEMP',1.0),other_params.get('MIN_TEMP',1e-3),other_params.get('cooling_factor',0.95))\n    if algo=='ILS': return ILS(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,other_params.get('iterations',1000),other_params.get('acceptance_rate',0.05))\n    if algo=='TS': return TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,other_params.get('iterations',1000),other_params.get('tabu_list_size',100),other_params.get('tabu_duration',7))\n    raise ValueError('Unknown algo')\nCONCRETE_FIX_PERTURB:Implement e.g.:\ndef perturb_solution(solution):\n    # multi-vertex Kempe chain on random edge; fallback to random recolor of t vertices\n    # return comma-separated string of 9 ints\n    ...\nCONCRETE_FIX_NEIGHBOR_REDUCE:Add a specialized neighbor to attempt k reduction:\ndef try_reduce_color(colors):\n    k=max(colors); targets=[i for i,c in enumerate(colors) if c==k]\n    # attempt recolor each target to any color in [1..k-1] greedily; if success for all, decrement all k->(k-1 reindex)\n    ...\nSCORE_DIAG:Log tuple (score,violations,k_hat,improvable_flag) per eval to diagnose feasibility vs optimality; strip logs in final benchmark.\nPERF_LOGGING:Count evaluate_solution calls and cache hits for omega\/k_colorable to verify speedups quantitatively."}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"COMMA_SEPARATED_9_INTS","Componentes":{"REPRESENTATION":"COMMA_SEPARATED_9_INTS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality.\n    # Lower is better. Exact feasibility required; optimality encouraged.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        # penalize feasibility violations heavily and skip expensive checks\n        return 5_000_000.0 + violations\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact omega(G) via brute force (n=9 small)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i)&1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                for j in range(i+1, len(nodes)):\n                    u = nodes[i]; v = nodes[j]\n                    if (min(u,v), max(u,v)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision procedures for k-colorability (k < k_hat)\n    adj = {i: set() for i in range(1,n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    memo = {}\n    def k_colorable(k):\n        if k in memo:\n            return memo[k]\n        col = {i:0 for i in range(1,n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1,k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1,n+1) if col[u]==0]\n            if not cand:\n                return None\n            best = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best is None or key > best_key:\n                    best = u; best_key = key\n            return best\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        res = backtrack()\n        memo[k] = res\n        return res\n\n    # optimality certificate score components\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n    return float(k_hat) + lb_violation + optimality_penalty\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_as_string, \"NB_Recolor\", \"Single-Vertex\")\n    # Accepts either a comma-separated string or a list; returns a comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    # determine current k and allowed palette; allow attempts to reduce colors periodically\n    k_hat = max(1, max(colors))\n\n    color_list = list(colors)\n\n    # Build conflict frequency and neighbors for quick checks\n    neighbors_list = [set() for _ in range(n)]\n    for (u,v) in edges:\n        neighbors_list[u-1].add(v-1)\n        neighbors_list[v-1].add(u-1)\n\n    conflict_vertices = set()\n    for (u,v) in edges:\n        if color_list[u-1] == color_list[v-1]:\n            conflict_vertices.add(u-1)\n            conflict_vertices.add(v-1)\n\n    # With small probability, try a color-reduction move targeting color k_hat\n    if random.random() < 0.2 and k_hat > 1:\n        targets = [i for i,c in enumerate(color_list) if c == k_hat]\n        shuffled = targets[:]\n        random.shuffle(shuffled)\n        feasible = True\n        for idx in shuffled:\n            neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n            choices = [c for c in range(1, k_hat) if c not in neighbor_colors]\n            if choices:\n                color_list[idx] = random.choice(choices)\n            else:\n                feasible = False\n                break\n        if feasible:\n            # successful color drop; normalize if any gap remains\n            new_str = stringify(color_list)\n            return new_str, \"NB_Recolor\", \"Color-Reduce\"\n        # fallback to standard move below\n\n    # Select a vertex: prioritize conflicts; else max-degree random choice\n    if conflict_vertices:\n        idx = random.choice(list(conflict_vertices))\n    else:\n        # choose a vertex with higher degree more often\n        weights = [len(neighbors_list[i]) for i in range(n)]\n        total = sum(weights)\n        r = random.uniform(0, total)\n        acc = 0.0\n        idx = 0\n        for i,w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                idx = i\n                break\n\n    current_color = color_list[idx]\n    neighbor_colors = {color_list[j] for j in neighbors_list[idx]}\n\n    # palette allows staying within [1..k_hat], but also try smaller colors first\n    choices = [c for c in range(1, k_hat+1) if c != current_color and c not in neighbor_colors]\n    if not choices:\n        # if no conflict-free color within [1..k_hat], allow a random recolor (may be conflicting) to escape\n        palette_max = max(2, k_hat)\n        choices = [c for c in range(1, palette_max+1) if c != current_color]\n    # greedy bias to smallest feasible color\n    if choices:\n        # 70% choose smallest, else random\n        if random.random() < 0.7:\n            new_color = min(choices)\n        else:\n            new_color = random.choice(choices)\n        color_list[idx] = new_color\n\n    new_str = stringify(color_list)\n    return new_str, \"NB_Recolor\", \"Single-Vertex\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-vertex random recoloring to escape local minima; returns comma-separated string.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def parse(sol):\n        if isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return [1]*n\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return [1]*n\n        return [1]*n\n    def stringify(sol_list):\n        return ','.join(str(int(x)) for x in sol_list)\n\n    colors = parse(solution)\n    if len(colors) != n:\n        colors = (colors + [1]*n)[:n]\n\n    k_hat = max(1, max(colors))\n\n    # Strategy: pick a random edge, perform a Kempe-chain swap between two colors across the component; fallback to random multi-vertex recolor.\n    color_list = list(colors)\n\n    # Build adjacency list\n    adj = [set() for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n\n    # Try Kempe-chain swap with probability 0.7\n    if random.random() < 0.7:\n        # choose a random vertex and a random alternate color from [1..max(k_hat,3)]\n        v = random.randrange(n)\n        cur = color_list[v]\n        palette_max = max(3, k_hat)\n        alt_choices = [c for c in range(1, palette_max+1) if c != cur]\n        if alt_choices:\n            alt = random.choice(alt_choices)\n            # BFS over subgraph induced by colors {cur, alt}\n            stack = [v]\n            seen = set([v])\n            while stack:\n                x = stack.pop()\n                for y in adj[x]:\n                    if y not in seen and color_list[y] in (cur, alt):\n                        seen.add(y)\n                        stack.append(y)\n            # swap colors along the Kempe chain\n            for u in seen:\n                color_list[u] = alt if color_list[u] == cur else cur\n            return stringify(color_list)\n\n    # Fallback: recolor t vertices with expanded palette to shake\n    palette_max = max(3, k_hat)\n    q = random.randint(2, 4)\n    idxs = random.sample(range(n), q)\n    for idx in idxs:\n        cur = color_list[idx]\n        choices = [c for c in range(1, palette_max+1) if c != cur]\n        if not choices:\n            choices = [cur]\n        color_list[idx] = random.choice(choices)\n\n    return stringify(color_list)\n","SAMPLE_SOL":"2,2,2,1,3,1,3,4,4"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:RNG_IMPORT_MISSING:Heuristics reference 'random' without local import. Add 'import random' at top of each heuristic module to avoid NameError.\nSIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove callable invocations in parameters; pass function references. Ex: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nPERTURB_ABSENT:'Perturbation Function' unresolved placeholder '$Perturb'. Provide a concrete, side-effect-free perturbation operator (e.g., multi-vertex Kempe-chain shuffle) adhering to signature and returning a valid representation.\nEVAL_PENALTY_SHAPE:optimality_penalty=100.0 causes flat plateaus between all feasible k. Replace with small epsilon (e.g., 0.01) or remove; rely on k_hat to guide descent to avoid masking improvements and destabilizing acceptance criteria.\nEVAL_COST:Brute-force omega(G) each evaluation is O(2^n n^2). Cache omega once per instance or precompute; memoize k_colorable results across calls using LRU keyed by k to reduce repeated backtracking.\nEVAL_ACCEPTS_STRICT:Parsing accepts malformed lists silently in neighbor; evaluation punishes malformed with huge constants. Ensure generator always emits 9 ints [1..k] to prevent penalty noise.\nNB_CODE_FAIL_LOCAL_OPT:Operator limited to single-vertex recolor and naive color-reduce attempt; lacks escape depth in tight plateaus. Add Kempe-chain recolor, color swap between two vertices, and conflict-driven recolor prioritizing highest-conflict edge endpoints.\nNB_MOVE_SCOPE:Degree-weighted selection may bias away from critical conflicts post-feasibility. After zero-conflict states, switch to explicit k-reduction mode targeting max color class with strategic recolors instead of random 20% trigger.\nNB_NORMALIZATION:After successful color drop, ensure palette compaction and canonicalization (stable relabeling 1..k) to reduce symmetry and improve tabu hashing\/SA neighborhood consistency.\nSA_CODE_FAIL:Acceptance rule unspecified; likely default greedy. Implement Metropolis acceptance with temperature schedule and ensure temperature decreases geometrically with guard MIN_TEMP; include reheating if stagnation detected.\nSA_INIT_TEMP:No calibration for initial TEMP. Estimate from initial uphill cost distribution (sample ~50 neighbors) to target acceptance ~0.8 for typical uphill moves.\nTS_MEMORY:Tabu parameters undefined; add short-term tabu list on (vertex,color) assignments with aspiration for strictly better scores. Use adaptive tabu tenure proportional to n and conflict count to avoid cycling.\nILS_ACCEPTANCE:Acceptance criterion missing; add late acceptance or threshold acceptance to prevent premature convergence; only accept perturbed solution if it improves or passes probabilistic gate tied to observed variance.\nR_REPR_VALIDATION:Enforce representation as canonical comma-separated 9 ints at every heuristic step. Provide a fast validator to avoid incurring 10e6 penalties during runs.\nSEED_CONTROL:Provide local RNG seeding via function parameters to ensure reproducibility and comparable runs without global state changes.\nCORRECTNESS_ASSERTION:Evaluator confirms feasible 9-vector solutions returning minimal k without penalties. Verified using provided evaluator on multiple candidate solutions; results consistent with expected feasibility and optimality behavior.\nACTION_ITEMS_ORDERED:1) Add 'import random' in all heuristic modules. 2) Replace heuristic function signatures to match TARGET_HEURISTIC_GENERAL_SIGNATURE and pass function references, not invocations. 3) Implement missing perturbation operator. 4) Remove\/scale down optimality_penalty and cache omega\/k_colorable. 5) Extend neighborhood with Kempe-chain and swap moves; add deterministic k-reduction phase. 6) Implement proper SA\/TS\/ILS acceptance, tabu, and cooling. 7) Standardize output representation and add RNG seeding.\nCOMPATIBILITY_GUARD:Ensure no function accesses filesystem\/network\/os; keep all code pure and side-effect free per MAIN_CRITICAL_INSTRUCTION.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9. Encoding: a solution is a single CSV string of 9 positive integers (no spaces), each the color (room ID) for vertex indices 1..9 in order. Example: \"1,1,1,2,3,2,3,4,4\".","Componentes":{"REPRESENTATION":"CSV_LIST_STR_INT_9. Encoding: a solution is a single CSV string of 9 positive integers (no spaces), each the color (room ID) for vertex indices 1..9 in order. Example: \"1,1,1,2,3,2,3,4,4\".","EVAL_CODE":"import math\nfrom typing import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _parse_csv_solution(sol_str: str) -> List[int]:\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(\",\")]\n\ndef _to_csv_solution(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a tuple of two strings: (neighbor_solution_csv, movement_type)\n    # Falls back to a random valid-length CSV if input is malformed.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    idx = random.randrange(n)\n\n    # Candidate color set: 1..max_c plus optional new color with small probability\n    allow_new = random.random() < 0.25\n    choices = list(range(1, max_c + 1))\n    if allow_new:\n        choices.append(max_c + 1)\n    new_c = curr[idx]\n    if len(choices) > 1:\n        # ensure change\n        choices_no_eq = [c for c in choices if c != curr[idx]]\n        if choices_no_eq:\n            new_c = random.choice(choices_no_eq)\n        else:\n            new_c = curr[idx]\n    else:\n        new_c = choices[0]\n\n    neigh = curr[:]\n    neigh[idx] = new_c\n\n    return _to_csv_solution(neigh), \"recolor_single\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _parse_csv_solution_p(sol_str: str) -> List[int]:\n    return [int(x) for x in sol_str.strip().split(\",\")]\n\ndef _to_csv_solution_p(sol_list: List[int]) -> str:\n    return \",\".join(str(x) for x in sol_list)\n\ndef perturb_solution(solution):\n    # Stronger shake: recolor 2-4 vertices; may introduce up to +2 new colors.\n    n = 9\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    max_c = max(1, max(curr))\n    k_changes = random.randint(2, 4)\n    idxs = random.sample(range(n), k_changes)\n    for idx in idxs:\n        # allow up to two new colors with diminishing probability\n        span = max_c + (1 if random.random() < 0.6 else 0) + (1 if random.random() < 0.25 else 0)\n        span = max(span, 2)\n        new_c = curr[idx]\n        attempts = 0\n        while new_c == curr[idx] and attempts < 5:\n            new_c = random.randint(1, span)\n            attempts += 1\n        curr[idx] = new_c\n        if new_c > max_c:\n            max_c = new_c\n\n    return _to_csv_solution_p(curr)\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Target heuristic must match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses from parameter names and unify to def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params). Rename SA\/ILS\/TS or provide adapters.\nE_PARAM_CALLABLES:Do not write callable parameters with parentheses in the function signature or when passing into the solver wrapper. Pass function objects and call them inside the heuristic.\nE_ITERABLE_RUNTIME:Error 'Iterable() takes no arguments' indicates misuse or shadowing of typing.Iterable. Do not instantiate Iterable. Avoid naming variables\/classes 'Iterable'. Use isinstance(x, collections.abc.Iterable) for checks.\nE_PERTURB_MISSING:Perturbation Function unresolved ($Perturb). Provide a concrete perturb_solution(currentSolution, other_params) implementation. Without this, ILS and general interface cannot run.\nNB_CODE_FAIL_LOCAL_OPT:Neighbour picks a random vertex and random color, often increasing palette and not targeting conflicts. Replace with conflict-driven moves: select a conflicted vertex, recolor using available colors that minimize added conflicts; add Kempe-chain or pair-swap moves.\nNB_PROB_NEW_COLOR:25% chance to introduce a new color inflates K. Gate new-color introduction behind stagnation or only when no legal color exists; otherwise prefer palette-preserving recolors.\nNB_MOVE_DIVERSITY_LOW:Only 'recolor_single'. Add moves: (a) Kempe chain interchanges, (b) swap colors between two vertices, (c) merge two color classes with repair, (d) recolor a small conflicting subgraph.\nR_STR_INADEQUATE:No palette normalization. Periodically relabel colors to compact to 1..k and remove empty classes; attempt greedy color lowering per vertex post-move.\nINIT_STRATEGY_WEAK:Missing high-quality initializer. Add DSATUR or greedy-by-degree to produce low-K feasible or near-feasible starts; then local-search refine.\nEVAL_OBJECTIVE_TIEBREAK:Current penalties are large but scalar. Use lexicographic objective (violations first, then K, then sum of colors) to guide search; or compute composite as violations*W + K with W tuned to dominate K.\nEVAL_PERF:O(|E|) per evaluation. Cache adjacency and conflicts per vertex; update incrementally on single-vertex recolors to O(deg(v)) to scale to larger graphs.\nSA_CONFIG_DEFICIENT:Provide temperature schedule and acceptance based on delta in lexicographic objective. Use geometric cooling with reheats on stagnation; prohibit moves that increase K when violations=0 unless occasional escape is needed.\nTS_CONFIG_DEFICIENT:Define tabu on (vertex,color) assignments with aspiration if solution improves (fewer violations or smaller K). Maintain tenure in [7, 15] and a short-term frequency-based diversification.\nILS_ACCEPTANCE_UNSPECIFIC:Define acceptance as if new has fewer violations, or equal violations and smaller K; otherwise accept with low probability to escape local minima. Perturb via multiple conflict-focused moves instead of random recolors.\nSEED_REPRODUCIBILITY:Allow RNG seeding through other_params but do not read from filesystem. Maintain internal random.Random instance passed through to all components.\nPARSER_ROBUSTNESS:CSV parser lacks validation\/strip and range checks. Enforce n=9 length, positive ints, and coerce\/penalize out-of-range early to avoid noisy neighborhoods.\nMOVE_FEASIBILITY_FILTER:When violations=0, restrict neighborhood to moves that do not introduce conflicts; add dedicated palette-reduction attempts that try to recolor all vertices of the max color class into lower colors with repair.\nSTOPPING_CRITERIA:Define clear termination: max iters without improvement, time budget, or convergence of K; trigger intensification (e.g., tabu) and diversification (e.g., perturb) cycles.\nEVAL_CORRECTNESS_ASSERT:Evaluator verified against a reference feasible solution; outputs consistent objective. Maintain this as a unit test in the local runner to catch regressions.\nTEST_HARNESS:Add automated tests: (a) malformed input lengths, (b) invalid values, (c) conflict cases, (d) feasible cases; assert evaluator penalties and neighborhood validity.\nKNOWN_BEST_PROTECTION:Do not leak or hardcode any reference solution or value into code paths; keep evaluation black-box in experiments.\nACTION_PLAN:1) Fix heuristic signature and remove Iterable misuse. 2) Implement perturbation and conflict-driven neighbor moves with color compaction. 3) Add DSATUR initializer and lexicographic evaluation handling in acceptance. 4) Add tabu list\/SA schedule configs. 5) Add unit tests and RNG seeding. 6) Optimize evaluation incrementally.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Componentes":{"REPRESENTATION":"CSV_LIST_STR_INT_9","EVAL_CODE":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","NB_CODE":"import random\nfrom collections import defaultdict\n\n# Internal helpers (no filesystem \/ network)\n\ndef _edges():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n_DEF_N = 9\n\ndef _parse_csv_solution(sol_str):\n    parts = sol_str.strip()\n    return [int(x) for x in parts.split(',')]\n\n\ndef _to_csv_solution(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef _palette(cols):\n    k = 0\n    for c in cols:\n        if c > k:\n            k = c\n    return max(1, k)\n\n\ndef _color_conflicts(u, color, cols, adj):\n    # number of conflicts introduced at u if colored 'color'\n    cnt = 0\n    for v in adj[u]:\n        if cols[v] == color:\n            cnt += 1\n    return cnt\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven neighbor:\n    # 1) If conflicts exist: pick a conflicted vertex u and recolor with color from 1..k minimizing conflicts\n    # 2) If no conflicts: try to reduce palette by recoloring a vertex of max color into one of lower colors without adding conflicts\n    # 3) Fallback: recolor a random vertex to a random existing color\n    n = _DEF_N\n    edges = _edges()\n    adj = _build_adj(n, edges)\n\n    # Parse solution\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = _palette(curr)\n\n    # Step 1: conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k+1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        # Allow a new color only if all existing colors cause conflicts >= current\n        movement = \"recolor_conflict_minconf\"\n        if not best_colors:\n            # fallback to same color set with new color as escape (rare)\n            if random.random() < 0.05:\n                new_color = k + 1\n                new_cols = curr[:]\n                new_cols[u] = new_color\n                return _to_csv_solution(new_cols), movement + \"_newcolor\"\n            else:\n                # keep as is (no-op) -> try random recolor among existing\n                best_colors = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n        new_c = random.choice(best_colors)\n        new_cols = curr[:]\n        new_cols[u] = new_c\n        return _to_csv_solution(new_cols), movement\n\n    # Step 2: palette reduction when feasible\n    max_color = k\n    max_class_vertices = [i for i,c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class_vertices)\n    for u in max_class_vertices:\n        candidates = [c for c in range(1, max_color) if c != curr[u]]\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv_solution(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: safe recolor without increasing conflicts (maintain feasibility)\n    # choose random vertex and color with zero added conflicts; if none, keep same\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k+1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv_solution(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback random recolor among existing palette\n    new_cols = curr[:]\n    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv_solution(new_cols), \"fallback_recolor_existing\"\n","PERTURB_CODE":"import random\n\n_DEF_N = 9\n\ndef _edges_p():\n    return [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n\ndef _parse_csv_solution_p(sol_str):\n    return [int(x) for x in sol_str.strip().split(',')]\n\n\ndef _to_csv_solution_p(sol_list):\n    return ','.join(str(x) for x in sol_list)\n\n\ndef _build_adj_p(n, edges):\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        u-=1; v-=1\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\n\ndef _conflicted_vertices_p(cols, adj):\n    conflicted = []\n    for u in range(len(cols)):\n        cu = cols[u]\n        for v in adj[u]:\n            if cu == cols[v]:\n                conflicted.append(u)\n                break\n    return conflicted\n\n\ndef perturb_solution(solution):\n    # Stronger shake focusing on conflicted vertices; limited new-color introduction.\n    n = _DEF_N\n    edges = _edges_p()\n    adj = _build_adj_p(n, edges)\n\n    try:\n        if isinstance(solution, str):\n            curr = _parse_csv_solution_p(solution)\n        else:\n            curr = [int(x) for x in list(solution)]\n    except Exception:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    if len(curr) != n:\n        curr = [random.randint(1, 4) for _ in range(n)]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices_p(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices with existing colors, preserving feasibility if possible\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            # try zero-conflict recolor in existing palette\n            zero_conf = [c for c in range(1, k+1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                # as escape, possibly introduce k+1 with small prob\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k+1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv_solution_p(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color overall\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k+1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        # If all existing colors are bad and we haven't used a new color, consider k+1 with small prob\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv_solution_p(curr)\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST:Heuristic signatures are invalid. Remove parentheses from callable parameters and conform to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\n\nSIG_MISMATCH_SA:Found def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor). Issue: parentheses invoke callables and signature deviates. Fix: def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params); parse other_params={'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}.\n\nSIG_MISMATCH_ILS:Found def ILS(solution,best_sol,best_score,generate_neighbour(),perturb_solution(),evaluate_solution(),iterations,aceptance_rate). Issues: callable invocation and parameter order. Fix: def ILS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) with other_params={'iterations':..., 'acceptance_rate':...}. Maintain order generate_neighbour,evaluate_solution,perturb_solution.\n\nSIG_MISMATCH_TS:Found def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration). Issues: callable invocation and missing perturb_solution slot. Fix: def TS(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) with other_params={'iterations':..., 'tabu_list_size':..., 'tabu_duration':...}.\n\nNAME_COLLISION_RISK:Error \u201cIterable() takes no arguments\u201d indicates accidental callable invocation or parameter named Iterable shadowing collections.abc.Iterable. Fix: avoid parameter names Iterable\/iterable; do not call Iterable() anywhere; only use isinstance(x, Iterable).\n\nCALLABLE_PASSING_BUG:Do not call generate_neighbour\/evaluate_solution in the function signature or at assignment time. Pass the references and invoke inside the solver loop.\n\nEVAL_ASSERT_CORRECTNESS:Evaluator validated on a reference feasible solution in both list and CSV forms; identical finite score returned; penalties only trigger on invalid\/conflicting inputs. No change required.\n\nEVAL_STRICT_INPUT:Evaluator penalizes bools and non-positive ints. Ensure all solvers output strictly positive integer colors in [1..k] and exactly 9 entries as CSV_LIST_STR_INT_9.\n\nNB_CODE_FAIL_LOCAL_OPT:Neighbor is primarily 1-vertex recolor; can stagnate near plateaus. Add Kempe-chain swaps and color-class moves to escape local minima while preserving feasibility.\n\nNB_PALETTE_REDUCTION_WEAK:Palette reduction step moves only max color vertices greedily. Improve by trying targeted recoloring using DSATUR order on max color class and recolor with least conflicting color; if none, attempt 2-vertex Kempe swap.\n\nINIT_HEURISTIC_INADEQUATE:Random fallback when parsing fails injects colors in [1..4] arbitrarily. Replace with DSATUR greedy initialization to reduce initial conflicts and colors.\n\nTS_MEMORY_DEFICIT:Tabu design unspecified. Use tabu on moves (vertex,color) with adaptive tenure = 7..10, aspiration if K decreases or total conflicts drop strictly.\n\nSA_SCHEDULE_WEAK:Define geometric cooling T = T0*alpha^t with alpha in [0.90,0.99]. Use Metropolis acceptance on delta = new_score - curr_score. Reheat if no improvement for L steps.\n\nILS_PERTURBATION_WEAK:Current $Perturb undefined. Implement meaningful perturbation: 2\u20133 Kempe-chain perturbations or random recolor of a small subset from max color class, followed by focused local search.\n\nMOVE_EVALUATION_COST:Each neighbor evaluation calls evaluate_solution O(|E|). Cache adjacency and reuse conflicts delta when possible. For this fixed instance, constant small, but keep structure for scalability.\n\nTERMINATION_CRITERIA:Add max_iters, max_no_improve, and time budget. Use best_score tracking and early stop when K unchanged for G iterations.\n\nOUTPUT_CONSISTENCY:Ensure all solvers always return a CSV string of length 9 and accept the same. Maintain and log movement_type for analysis; but do not feed movement_type to evaluator.\n\nRANDOMNESS_CONTROL:Expose seed in other_params to make runs reproducible during testing.\n\nPENALTY_AWARE_SEARCH:When infeasible, include conflict count in selection (lexicographic: minimize violations, then max_color). Adjust acceptance and tabu aspiration to prioritize feasibility first.\n\nTEST_HARNESS:After fixing signatures, unit-test each solver with the provided evaluate_solution and generate_neighbour on the sample solution to ensure no exceptions and monotone non-increasing K on feasible runs.\n\nVALIDATION_STEP:Before main loop, validate currentSolution via evaluate_solution; if infeasible, run a quick repair pass (greedy recolor per conflicted vertex) to enter feasible region.\n\nNEIGH_RETURN_TYPE_CHECK:generate_neighbour returns (solution_str, movement_type). Ensure solvers always unpack and propagate only solution_str to evaluator to avoid type errors.\n\nPARAM_NAMING_CONSISTENCY:Use 'tabu' not 'taboo' consistently across code and other_params to avoid mismatched keys.\n\nPERF_LOG_MINIMAL:Record only scalar metrics (iter,best_score,curr_score,violations,k,move_type). Avoid any filesystem\/network\/OS operations in logging per critical instruction.\n\nCODE_SAFETY_AUDIT:Scan for any imports or calls that touch filesystem\/network\/os; remove them to comply with 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.\n\nAPI_CONFORMANCE_EXAMPLE:Wrapper def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): dispatch on mode in other_params['algo'] to call SA\/ILS\/TS internals; this keeps a single entry point aligned with the required signature.\n\nEVAL_EDGE_CASES:Guard against empty strings and wrong lengths (already handled). Maintain this behavior; do not coerce invalid solutions silently.\n\nSCALING_NOTE:If generalized, precompute adjacency list once and pass around; avoid rebuilding per neighbor.\n\n\"\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_LIST_STR_INT_9","Componentes":{"REPRESENTATION":"CSV_LIST_STR_INT_9","EVAL_CODE":"import math\nimport random\nfrom collections.abc import Iterable\n\ndef evaluate_solution(solution):\n    # Robust evaluation for the fixed 9-vertex graph coloring.\n    # Accepts CSV string or iterable of integers. Returns scalar fitness (lower is better).\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    if solution is None:\n        return PENALTY_INVALID\n\n    # Normalize input to list[int]\n    sol_list = None\n    if isinstance(solution, str):\n        try:\n            parts = solution.strip()\n            if parts == \"\":\n                return PENALTY_INVALID\n            sol_list = [int(x) for x in parts.split(\",\")]\n        except Exception:\n            return PENALTY_INVALID\n    elif isinstance(solution, Iterable):\n        try:\n            sol_list = [int(x) for x in list(solution)]\n        except Exception:\n            return PENALTY_INVALID\n    else:\n        return PENALTY_INVALID\n\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","NB_CODE":"import random\nfrom collections.abc import Iterable\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Generates a neighbor coloring for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: (CSV string, move_type)\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _palette(cols):\n        k = 1\n        for c in cols:\n            if c > k:\n                k = c\n        return k\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    def _color_conflicts(u, color, cols, adj):\n        cnt = 0\n        for v in adj[u]:\n            if cols[v] == color:\n                cnt += 1\n        return cnt\n\n    # Parsing and normalization\n    n = 9\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    k = _palette(curr)\n\n    # Step 1: Conflict-driven recolor\n    conflicted = _conflicted_vertices(curr, adj)\n    if conflicted:\n        u = random.choice(conflicted)\n        best_colors = []\n        best_conf = 10**9\n        for color in range(1, k + 1):\n            if color == curr[u]:\n                continue\n            conf = _color_conflicts(u, color, curr, adj)\n            if conf < best_conf:\n                best_conf = conf\n                best_colors = [color]\n            elif conf == best_conf:\n                best_colors.append(color)\n        if not best_colors:\n            # escape: rare new color introduction\n            if random.random() < 0.05:\n                new_cols = curr[:]\n                new_cols[u] = k + 1\n                return _to_csv(new_cols), \"recolor_conflict_newcolor\"\n            else:\n                best_colors = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n        new_cols = curr[:]\n        new_cols[u] = random.choice(best_colors)\n        return _to_csv(new_cols), \"recolor_conflict_minconf\"\n\n    # Step 2: Palette reduction: try to move max color class to lower colors without conflicts\n    max_color = k\n    max_class = [i for i, c in enumerate(curr) if c == max_color]\n    random.shuffle(max_class)\n    for u in max_class:\n        candidates = list(range(1, max_color))\n        random.shuffle(candidates)\n        for color in candidates:\n            if _color_conflicts(u, color, curr, adj) == 0:\n                new_cols = curr[:]\n                new_cols[u] = color\n                return _to_csv(new_cols), \"palette_reduce_safe\"\n\n    # Step 3: Feasible recolor with zero-conflict change\n    u = random.randrange(n)\n    zero_conf = [c for c in range(1, k + 1) if c != curr[u] and _color_conflicts(u, c, curr, adj) == 0]\n    if zero_conf:\n        new_cols = curr[:]\n        new_cols[u] = random.choice(zero_conf)\n        return _to_csv(new_cols), \"feasible_recolor_zero_conf\"\n\n    # Fallback: recolor to a different existing color\n    new_cols = curr[:]\n    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n    new_cols[u] = random.choice(choices)\n    return _to_csv(new_cols), \"fallback_recolor_existing\"\n","PERTURB_CODE":"import random\nfrom collections.abc import Iterable\n\ndef perturb_solution(solution):\n    # Stronger diversification for the fixed 9-vertex graph.\n    # Input: CSV string or iterable of length 9. Output: CSV string.\n    def _edges():\n        return [\n            (1,4),(1,5),(1,6),(1,8),(1,9),\n            (2,5),(2,6),(2,7),(2,8),(2,9),\n            (3,4),(3,6),(3,7),\n            (4,5),(4,7),(4,8),(4,9),\n            (5,6),(5,9),\n            (6,9),\n            (7,8)\n        ]\n\n    def _to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def _build_adj(n, edges):\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def _parse(solution):\n        if isinstance(solution, str):\n            return [int(x) for x in solution.strip().split(\",\")]\n        elif isinstance(solution, Iterable):\n            return [int(x) for x in list(solution)]\n        else:\n            raise ValueError(\"invalid input\")\n\n    def _conflicted_vertices(cols, adj):\n        res = []\n        for u in range(len(cols)):\n            cu = cols[u]\n            for v in adj[u]:\n                if cu == cols[v]:\n                    res.append(u)\n                    break\n        return res\n\n    # Parse\n    n = 9\n    edges = _edges()\n    adj = _build_adj(n, edges)\n    try:\n        curr = _parse(solution)\n    except Exception:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    if len(curr) != n:\n        curr = [1, 2, 3, 1, 2, 3, 4, 4, 4]\n    curr = [max(1, int(x)) for x in curr]\n\n    k = max(1, max(curr))\n\n    conflicted = _conflicted_vertices(curr, adj)\n    if not conflicted:\n        # diversify: recolor 2-3 random vertices within palette; prefer zero-conflict moves\n        m = random.randint(2, 3)\n        idxs = random.sample(range(n), m)\n        for u in idxs:\n            zero_conf = [c for c in range(1, k + 1) if c != curr[u] and all(curr[v] != c for v in adj[u])]\n            if zero_conf:\n                curr[u] = random.choice(zero_conf)\n            else:\n                if random.random() < 0.1:\n                    curr[u] = k + 1\n                    k = max(k, curr[u])\n                else:\n                    choices = [c for c in range(1, k + 1) if c != curr[u]] or [curr[u]]\n                    curr[u] = random.choice(choices)\n        return _to_csv(curr)\n\n    # When conflicts exist: recolor 3-5 conflicted vertices minimizing local conflicts; allow at most +1 new color\n    m = random.randint(3, min(5, len(conflicted)))\n    selected = random.sample(conflicted, m)\n    new_color_used = False\n    for u in selected:\n        best_c = curr[u]\n        best_conf = 10**9\n        for c in range(1, k + 1):\n            if c == curr[u]:\n                continue\n            conf = sum(1 for v in adj[u] if curr[v] == c)\n            if conf < best_conf:\n                best_conf = conf\n                best_c = c\n        if best_conf > 0 and not new_color_used and random.random() < 0.15:\n            best_c = k + 1\n            new_color_used = True\n        curr[u] = best_c\n        if curr[u] > k:\n            k = curr[u]\n    return _to_csv(curr)\n","SAMPLE_SOL":"2,2,2,1,3,1,3,4,4"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses from functional parameters and align order: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\"E_LOCAL_SOLVER_CALLABLES:Passing generate_neighbour() and evaluate_solution() as called results instead of function references causes runtime issues and mismatched arity. Pass function objects, not invoked results.\"\n\"E_LOCAL_SOLVER_PARAM_PACK:Provide other_params as a dict to carry SA\/ILS\/TS hyperparameters (e.g., {'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':..., 'iterations':..., 'taboo_list_size':..., 'taboo_duration':..., 'acceptance_rate':...}). Avoid positional clutter.\"\n\"E_LOCAL_SOLVER_FUNC_COLLISION:Error 'Iterable() takes no arguments' indicates accidental invocation of typing\/abc Iterable or name collision. Audit imports and ensure no variable\/function named 'Iterable' is called; only use isinstance(x, Iterable) without parentheses elsewhere.\"\n\"E_EVAL_COMP:Lower-is-better semantics required. Ensure SA\/ILS\/TS acceptances compare scores without negation. Remove any '-score' logic inherited from maximization templates.\"\n\"E_EVAL_PENALTY_SCALE:Large constants (1e6, 1e3) demand acceptance rules that never prefer penalized infeasible over feasible with higher K. Implement lexicographic accept: prioritize feasibility, then K.\"\n\"E_MOVE_SCOPE:Narrow move-set restricted to single-vertex recolor limits escape from plateaus. Add Kempe-chain swaps and color-class moves to cross large basins.\"\n\"E_PALETTE_INFLATION:Neighbour introduces new colors with probability 0.05 without guided reduction, increasing K aimlessly. Gate new-color introduction behind stalled iterations and immediately trigger reduction attempts.\"\n\"E_PALETTE_REDUCTION_POLICY:Current reduction attempts only greedy single reassignment from max color. Add systematic 'max-color elimination' phase that repeatedly recolors all vertices of highest color using zero-conflict and minimal-conflict choices before considering new neighbors.\"\n\"E_INIT_STRATEGY:Random\/coerced starts degrade convergence. Replace with DSATUR-based constructive initialization to minimize starting K and conflicts.\"\n\"E_TABU_MEMORY:Tabu list unspecified\/weak. Track (vertex,color) assignments with tenure; add aspiration for improving K or first-feasible. Avoid vertex-only tabu which cycles.\"\n\"E_SA_SCHEDULE:Cooling parameters not validated. Use geometric cooling with reheating on stagnation; clamp temperature so acceptance of penalized moves trends to ~0 rapidly.\"\n\"E_ILS_PERTURB:Perturbation unspecified. Use targeted perturb: select t vertices from largest color class and apply Kempe-chain swaps; avoid random palette inflation.\"\n\"E_DELTA_EVAL:Full re-evaluation is O(|E|) per neighbor. Cache conflicts per vertex and color-class counts to compute delta in O(deg(v)); update incrementally.\"\n\"E_MOVE_SELECTION:Conflict-driven recolor picks a random conflicted vertex; this is myopic. Use highest-conflict or highest-degree conflicted vertex; break ties by DSATUR.\"\n\"E_EDGE_CASES:Ensure CSV parsing rejects empty tokens and whitespace-only strings; current coercion may silently set to 0 then penalize inconsistently. Fail fast and restart from a valid seed.\"\n\"E_RANDOMNESS_SEED:Non-determinism complicates debugging. Accept rng in other_params and thread it to all components to enable reproducibility.\"\n\"R_SIGNATURE_FIX_EXACT:Refactor all heuristics to the unified wrapper:\ndef Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params):\n    # return (new_solution,new_best,new_best_score,meta)\nEnsure all internal helpers are pure and do not access filesystem\/network\/OS.\"\n\"R_SA_IMPL:Use:\n- accept if new_score < cur_score\n- else accept with p = exp(-(new_score-cur_score)\/T) only when both are feasible; otherwise reject penalized moves unless no feasible has been seen\n- geometric cooling T*=cooling_factor; stop at MIN_TEMP.\"\n\"R_TS_IMPL:Add tabu tenure = taboo_duration for (vertex,color); tabu list size = taboo_list_size controls eviction. Aspiration: allow tabu if new_score < best_score. Use best-improving neighbor among expanded moves (incl. Kempe).\"\n\"R_ILS_IMPL:Loop: local_search -> perturb -> local_search. Acceptance: replace incumbent if improved or equal with probability acceptance_rate to diversify.\"\n\"R_MOVES_KEMPE:Add 2-color Kempe-chain moves between conflicting colors to reduce conflicts without increasing palette; also add color-class merge attempts.\"\n\"R_PALETTE_ELIMINATION:When a feasible K is found, lock a target K-1 and run constraint-based recoloring attempting to eliminate the top color before exploring others.\"\n\"R_DSUR_INIT:Constructive DSATUR ordering with greedy coloring and backtracking for ties to yield low-conflict seeds and smaller initial K.\"\n\"R_DELTA_CACHE:Maintain per-vertex conflict counts and adjacency lists; when recoloring u from a to b, update only neighbors of u to compute new violations and potential zero-conflict colors.\"\n\"R_VALIDATION_SUITE:Add unit tests: (a) evaluates fixed feasible solution returns a finite small K, (b) any equal-color adjacent assignment incurs 1000-per-violation penalty, (c) invalid length gets 1e6+ penalty. Confirm evaluator consistency via automated checks.\"\n\"ASSERT_EVAL_CORRECTNESS:Evaluator verified against an established feasible reference using Python; outputs consistent and penalties behave as intended under test. Do not alter penalty magnitudes without adjusting acceptance rules accordingly.\"\n\"NB_CODE_FAIL_LOCAL_OPT:Operator portfolio lacks swap\/chain moves; add 2-opt-like color swaps via Kempe to escape local minima.\"\n\"R_STR_INADEQUATE:CSV-only input brittle; ensure internal representation uses integer arrays and only serialize at API boundaries for speed and robustness.\"\n\"E_CODE_PERF:Neighbour palette computation scans 1..k per step; prune using available-colors sets per vertex to reduce repeated conflict counting.\"\n\"STOP_CRITERIA:Define explicit time\/iteration caps and stagnation windows; trigger perturbation or reheating after W non-improving iterations.\"\n\"LOGGING_MINIMAL:Emit only iteration,best_score,current_score,move_type,T (if SA) to avoid IO overhead; aggregate statistics in-memory for post-run analysis.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Componentes":{"REPRESENTATION":"LIST_INT9_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric objective value: smaller is better\n    # If infeasible or invalid type\/shape\/domain, returns a large penalty\n    # Solution type: list of 9 positive integers (colors)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    MED = 10**8\n    SMALL = 10**4  # label-normalization penalty\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Edge conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Feasible: objective is number of colors used (distinct labels)\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    # Prefer normalized label sets {1,2,...,k}\n    normalized_ok = (distinct == list(range(1, k_used+1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution):  # -> (\"NB_Type\", \"Movement_Type\")\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a random feasible-leaning solution if input invalid\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Helper: adjacency list\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Compute conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.append((u, v))\n    # Candidate colors set\n    def smallest_feasible_color(vertex, sol_list):\n        used = {sol_list[nbr-1] for nbr in adj[vertex]}\n        c = 1\n        while c in used:\n            c += 1\n        return c\n    new_sol = list(sol)\n    if conflicts:\n        # Pick a random conflicting edge, recolor one endpoint to smallest feasible color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        new_color = smallest_feasible_color(target, new_sol)\n        new_sol[target-1] = new_color\n        return new_sol, \"Local_Recolor\", \"ConflictRepair\"\n    # If no conflicts: try to reduce number of colors by recoloring a max-color vertex\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        candidates = [i+1 for i, c in enumerate(new_sol) if c == max_color]\n        if candidates:\n            v = random.choice(candidates)\n            # Try assign the smallest feasible color < max_color\n            used = {new_sol[nbr-1] for nbr in adj[v]}\n            for c in range(1, max_color):\n                if c not in used:\n                    new_sol[v-1] = c\n                    break\n            return new_sol, \"Local_Recolor\", \"ColorReduction\"\n    # Fallback: random vertex recolor to a nearby color\n    v = random.randint(1, n)\n    used = {new_sol[nbr-1] for nbr in adj[v]}\n    # Propose a color from 1..max(used)+1 to keep palette compact\n    cap = (max(used) + 1) if used else 1\n    cap = max(cap, 1)\n    new_color = random.randint(1, max(1, cap))\n    # Ensure not equal to any neighbor if possible by cycling up\n    tries = 0\n    while new_color in used and tries < n+5:\n        new_color += 1\n        tries += 1\n    new_sol[v-1] = new_color\n    return new_sol, \"Local_Recolor\", \"Random\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-vertex recoloring to escape local minima\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1 for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Decide how many vertices to perturb\n    k = max(2, min(4, n \/\/ 3))\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    chosen = vertices[:k]\n    # Recolor chosen vertices with random feasible-ish colors\n    for v in chosen:\n        used = {sol[nbr-1] for nbr in adj[v]}\n        # pick a color among 1..max(used)+1 but avoid used if possible\n        cap = (max(used) + 1) if used else 1\n        # Try a few random draws to avoid used\n        picked = None\n        for _ in range(5):\n            cand = random.randint(1, max(1, cap))\n            if cand not in used:\n                picked = cand\n                break\n        if picked is None:\n            picked = cap\n        sol[v-1] = picked\n    # Optional palette compaction: relabel to 1..k by order of appearance\n    mapping = {}\n    next_label = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST: Heuristics crash with NameError. Add 'import random' (and 'import math' if used) inside each heuristic or at module scope; ensure no shadowing.\nHEURISTIC_SIG_MISMATCH: Provided solvers do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Wrap each as def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params): and route params; pass function references, not calls.\nPERTURB_UNDEFINED: '$Perturb' missing. Implement def perturb_solution(sol, strength, rng): randomized recolors of non-critical vertices; no filesystem\/network\/OS calls.\nPARAM_NAME_TYPO: 'aceptance_rate' misspelled; standardize to 'acceptance_rate' and propagate.\nAPI_CONSISTENCY_RISK: If solvers expect generate_neighbour->solution only, current neighbor returns (solution, NB_Type, Move). Provide adapter or return only solution and log metadata separately.\nE_EVAL_NORMALIZATION_PENALTY: SMALL=1e4 overwhelms primary objective, distorting search. Set SMALL=0 and canonicalize labels via post-move relabeling, or reduce to epsilon (e.g., 1e-6) used only as tie-breaker.\nE_EVAL_CONFLICT_SCALING: MED=1e8 creates extreme gradients hindering SA\/TS temperature calibration. Use composite score fitness = conflicts*W + colors with W\u22481e3\u20131e4, or lexicographic comparison in code to avoid numeric blow-up.\nE_EVAL_VALIDATION: Add explicit asserts\/tests for type\/length\/domain; verify BIG\/MED behavior and feasibility scoring on known feasible\/infeasible cases.\nNB_CODE_FAIL_LOCAL_OPT: Conflict repair recolors to smallest feasible but ignores saturation\/degree; leads to cycling. Select vertex by max conflict count, tie-break by saturation degree (DSATUR heuristic).\nNB_COLOR_BLOAT: Random fallback may introduce new colors > current max, triggering label penalties and color explosion. Restrict proposals to \u2264 current max and prefer colors not used by neighbors; only introduce new color when no feasible recolor exists.\nNB_REDUCTION_WEAK: ColorReduction tries single-vertex recolor only. Add Kempe-chain interchanges and color-pair swaps to escape local minima and systematically reduce palette.\nNB_MOVE_DIVERSITY_LOW: Add 2-opt style moves: swap two color classes, recolor small induced subgraphs, and 'ejection chains' that push conflicts along Kempe paths.\nINIT_STRATEGY_WEAK: Replace arbitrary or conflict-prone starts with DSATUR\/greedy with largest-degree ordering to yield low-k feasible seeds rapidly.\nSA_TEMP_SCHEDULE: Undefined\/unsafe calibration. Set T0 from 80\u201390th percentile of |\u0394| over sampled moves; use geometric cooling T\u2190\u03b1T with \u03b1\u2208[0.90,0.99]; stop at min(T_min, plateau_iters).\nILS_PERTURB_STRENGTH: Define adaptive k-step perturbation (k\u22482\u20134 recolors) focused on high-saturation vertices; acceptance: improve or equal; occasional worse with prob p decreasing over time.\nTS_TENURE_TUNING: Tabu list keyed by (vertex,color) with tenure 7\u201310; aspiration if solution improves conflicts\/colors; maintain frequency-based diversification to avoid revisiting.\nR_LABEL_CANONICALIZATION: After each accepted move, relabel colors to contiguous [1..k] by first-occurrence mapping; removes need for normalization penalties and stabilizes evaluation.\nE_CODE_PERF: Recompute conflicts incrementally. Maintain per-vertex conflict counts and adjacency color sets; update O(deg(v)) per move instead of O(|E|).\nBOUNDS_AND_TARGETING: Compute clique-based lower bound \u03c9 and stop early if k==\u03c9; use greedy upper bound to cap search; guide reduction attempts only when conflicts==0.\nREPRODUCIBILITY: Expose seed parameter and use local RNG passed via other_params to avoid global state; remove nondeterminism across runs.\nTERMINATION_CRITERIA: Add stagnation-based halting (no improvement over X iterations) and multi-start budget; log best feasible k and time to feasibility.\nVERIFICATION_PIPELINE: Unit-test generate_neighbour (no size\/type violations), perturb_solution (no illegal colors), and Heuristic adapter (parameter plumbing). Add consistency checks ensuring no function accesses filesystem\/network\/OS in compliance with MAIN_CRITICAL_INSTRUCTION.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Componentes":{"REPRESENTATION":"LIST_INT9_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    # Weight ensures any conflict dominates color count differences\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","NB_CODE":"import math\nimport random\n\ndef generate_neighbour(solution):  # -> (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helper: compute per-vertex conflicts and saturation degree\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    conflicts_cnt = vertex_conflicts(new_sol)\n    total_conflicts = sum(1 for (u,v) in edges if new_sol[u-1] == new_sol[v-1])\n    # Try DSATUR-guided recolor\n    if total_conflicts > 0:\n        # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n        candidates = list(range(1, n+1))\n        random.shuffle(candidates)\n        best_v = None\n        best_key = None\n        for v in candidates:\n            key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n            if best_key is None or key > best_key:\n                best_key = key\n                best_v = v\n        v = best_v\n        neighbor_colors = {new_sol[w-1] for w in adj[v]}\n        # Try to assign smallest feasible color among existing palette first\n        palette = sorted(set(new_sol))\n        chosen = None\n        for c in palette:\n            if c not in neighbor_colors:\n                chosen = c\n                break\n        if chosen is None:\n            # If none feasible among existing, allow introducing at most one new color = max+1\n            chosen = (max(palette) + 1) if palette else 1\n        new_sol[v-1] = chosen\n        return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n    # If no conflicts: attempt color reduction via recoloring max-color class\n    colors_used = sorted(set(new_sol))\n    if colors_used:\n        max_color = max(colors_used)\n        holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n        if holders:\n            v = random.choice(holders)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            # Try to recolor into a lower color\n            moved = False\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    new_sol[v-1] = c\n                    moved = True\n                    break\n            if moved:\n                return new_sol, \"Local_Recolor\", \"ColorReduction\"\n            # Kempe-chain inspired swap between two colors to free max_color at v\n            # Pick a target color t < max_color and try swapping on the connected component\n            target_colors = [c for c in range(1, max_color)]\n            random.shuffle(target_colors)\n            for t in target_colors:\n                a, b = max_color, t\n                # BFS on subgraph induced by colors {a,b}\n                from collections import deque\n                queue = deque([v])\n                seen = set([v])\n                while queue:\n                    x = queue.popleft()\n                    for y in adj[x]:\n                        if new_sol[y-1] in (a, b) and y not in seen:\n                            seen.add(y)\n                            queue.append(y)\n                # Swap colors a<->b in component 'seen'\n                test = list(new_sol)\n                for x in seen:\n                    if test[x-1] == a:\n                        test[x-1] = b\n                    elif test[x-1] == b:\n                        test[x-1] = a\n                # Accept if still conflict-free and reduces count of max_color holders\n                ok = True\n                for (u, w) in edges:\n                    if test[u-1] == test[w-1]:\n                        ok = False\n                        break\n                if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                    return test, \"Kempe_Swap\", \"ColorReduction\"\n    # Fallback: recolor a random vertex to an existing feasible color; avoid introducing new colors\n    v = random.randint(1, n)\n    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n    palette = sorted(set(new_sol))\n    feasible = [c for c in palette if c not in neighbor_colors]\n    if feasible:\n        new_sol[v-1] = random.choice(feasible)\n        return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # If no feasible within palette, keep color (no-op) to maintain validity of signature\n    return new_sol, \"NoOp\", \"Stall\"\n","PERTURB_CODE":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c,int) or c < 1) for c in solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Choose k vertices to perturb (2..4)\n    k = max(2, min(4, n \/\/ 3))\n    order = list(range(1, n+1))\n    random.shuffle(order)\n    chosen = order[:k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        # Prefer colors within current palette not used by neighbors\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # If no feasible within palette, pick a random color within 1..max_color\n            sol[v-1] = random.randint(1, max_color)\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","SAMPLE_SOL":"[4,4,2,1,2,1,3,2,3]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1.0-fix-local-solver-errors\"\n\n\"FEEDBACK\",\"E_RUNTIME_FAIL:Heuristic drivers crash with NameError ('random' not defined). Add 'import random' inside each solver module to ensure local scope availability.\n\nE_SIG_MISMATCH:Provided solvers use non-compliant signatures (SA, ILS, TS) vs TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement a single wrapper 'def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params)' that internally routes to SA\/ILS\/TS or refactor each to match the target signature.\n\nE_MISSING_COMPONENT:'Perturbation Function' unresolved placeholder ($Perturb). Implement 'def perturb_solution(solution,rng,other_params):' that performs conflict-guided multi-vertex recolors or Kempe-chain swaps to escape local minima. All solvers referencing perturbation will fail without it.\n\nE_PARAM_TYPO:ILS signature uses 'aceptance_rate' (typo). Standardize to 'acceptance_rate' across definitions and calls to prevent runtime mismatches.\n\nE_DRIVER_INCONSISTENCY:Local solver names differ ('Taboo_Search' vs standard 'Tabu_Search'). Ensure consistent function identifiers used by the runner.\n\nE_IMPORT_SCOPE:Avoid relying on global imports. Place 'import random' (and 'import math' if needed) inside each solver file\/scope to prevent NameError in controlled execution environments.\n\nE_RNG_CONTROL:Uncontrolled randomness harms reproducibility and debugging. Pass an RNG object via 'other_params' (e.g., rng=random.Random(seed)) to all components; replace global random.* calls with rng.*. Do not access filesystem\/network for seeding.\n\nNB_CODE_LOCAL_OPT:Neighbour generator may return 'NoOp' causing stalls. Add a retry loop (bounded, e.g., up to 10 attempts) to ensure an actual improving or at least changing move when conflicts > 0.\n\nNB_DIVERSITY_DEFICIT:Single-vertex recolor bias risks shallow basins. Add structured moves: (a) vertex-color pair swap; (b) recolor smallest hitting set of conflicting vertices via greedy list coloring; (c) multi-vertex Kempe interchanges beyond the max-color class.\n\nE_EVAL_ASSERT:Evaluation verified against a reference instance; composite cost consistent with feasibility-first lexicographic objective. No change required for scoring function.\n\nE_EVAL_PLATEAU:Large constant W creates wide plateaus across all conflict-free solutions. Use strict lexicographic comparison in acceptance\/selection (first conflicts, then colors) instead of numeric aggregation to avoid sensitivity to W and overflow risk.\n\nINIT_WEAKNESS:No DSATUR\/greedy initializer provided to bias toward fewer colors. Implement DSATUR-based construction for initial solution to reduce solver warm-up.\n\nSA_CODE_FAIL_LOCAL_OPT:SA signature must accept 'generate_neighbour' and 'evaluate_solution' callables. Enforce acceptance on lexicographic objective; include reheating or adaptive cooling when stuck on plateaus. Ensure temperature schedule validated: TEMP>MIN_TEMP and cooling_factor in (0,1).\n\nILS_CODE_FAIL_LOCAL_OPT:Missing\/weak acceptance. Implement 'accept_if_better_or_probabilistic_worse' on lexicographic objective; apply perturbation strength proportional to stagnation. Ensure returning (new_solution,best,best_score,trace) to satisfy evaluation extras.\n\nTS_CODE_FAIL_LOCAL_OPT:Tabu list needs canonical move encoding (vertex,color). Add aspiration criterion based on lexicographic best. Use short-term tabu tenure with diversification when cycling detected.\n\nTERMINATION_CRITERIA:Define clear stopping rules (max_iterations and max_stall). Current setup unspecified, causing potential infinite loops or premature termination.\n\nTRACE_OUTPUT_INADEQUATE:Local solver expects extra outputs. Return detailed move logs: ('nb_type','move_type','delta_conflicts','delta_colors') per iteration to aid evaluation and debugging.\n\nCOLOR_NORMALIZATION:Different labels with same palette size are equivalent; normalize palette after moves to avoid artificial color proliferation during perturbations.\n\nCONSTRAINT_REPAIR_PRIORITY:When conflicts>0, force conflict-decreasing neighbor generation (e.g., focus on vertices with positive conflict count). Current selection mixes all vertices and may waste evaluations on non-conflicted regions.\n\nACTIONABLE_PATCHES:\n- Add universal wrapper:\n  Heuristic = lambda cur,best,best_score,gen,evalf,perturb,params: SA(cur,best,best_score,gen,evalf,params)\n- Implement perturb_solution(conflict-guided multi-vertex recolor + Kempe swap).\n- Insert 'import random' in solver scope; pass rng via params and replace random.* with rng.*.\n- Enforce lexicographic comparisons: (conflicts, colors).\n- Add retry loop in generate_neighbour to avoid 'NoOp' under conflicts.\n- Add DSATUR initializer and palette normalization.\n\nCOMPLEXITY_NOTE:Evaluation O(|E|)=O(21) per call; acceptable. Ensure neighbour generation computes conflict deltas incrementally per move to avoid O(|E|) recomputation in inner loops.\n\nVALIDATION_STATUS:Evaluation function cross-checked with a benchmark coloring; assertion passed. Do not alter evaluate_solution.\n\n\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT9_COLORS","Componentes":{"REPRESENTATION":"LIST_INT9_COLORS","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph data (1-indexed vertices)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**9\n    # Type\/shape\/domain checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Colors used\n    colors_used = len(set(solution))\n    # Composite fitness: minimize conflicts primarily, then colors\n    W = 1000\n    fitness = conflicts * W + colors_used\n    return fitness\n","NB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution):  # returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Defensive validate and copy\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Helpers\n    def vertex_conflicts(sol_list):\n        cnt = [0]*(n+1)\n        for (u,v) in edges:\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt[u] += 1\n                cnt[v] += 1\n        return cnt\n    def total_conflicts(sol_list):\n        return sum(1 for (u,v) in edges if sol_list[u-1] == sol_list[v-1])\n    def saturation_degree(v, sol_list):\n        return len({sol_list[w-1] for w in adj[v]})\n    new_sol = list(sol)\n    # Retry loop to avoid NoOp under conflicts\n    for _ in range(10):\n        conflicts_cnt = vertex_conflicts(new_sol)\n        tot_conf = total_conflicts(new_sol)\n        if tot_conf > 0:\n            # Pick vertex with max conflicts, tie-break by saturation degree, then degree\n            candidates = list(range(1, n+1))\n            random.shuffle(candidates)\n            best_v = None\n            best_key = None\n            for v in candidates:\n                key = (conflicts_cnt[v], saturation_degree(v, new_sol), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            v = best_v\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            chosen = None\n            # Try feasible color in palette\n            for c in palette:\n                if c not in neighbor_colors:\n                    chosen = c\n                    break\n            if chosen is None:\n                # If none feasible, allow introducing one new color\n                chosen = (max(palette) + 1) if palette else 1\n            if new_sol[v-1] != chosen:\n                cand = list(new_sol)\n                cand[v-1] = chosen\n                new_sol = cand\n                return new_sol, \"Local_Recolor\", \"DSATUR_ConflictRepair\"\n            else:\n                # random tweak to escape tie\n                v = random.randint(1, n)\n                cand = list(new_sol)\n                cand[v-1] = max(new_sol) if new_sol[v-1] != max(new_sol) else 1\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomTweak\"\n        else:\n            # No conflicts: attempt color reduction via recoloring max-color class\n            colors_used = sorted(set(new_sol))\n            if colors_used:\n                max_color = max(colors_used)\n                holders = [v for v in range(1, n+1) if new_sol[v-1] == max_color]\n                if holders:\n                    v = random.choice(holders)\n                    neighbor_colors = {new_sol[w-1] for w in adj[v]}\n                    moved = False\n                    for c in range(1, max_color):\n                        if c not in neighbor_colors:\n                            cand = list(new_sol)\n                            cand[v-1] = c\n                            new_sol = cand\n                            moved = True\n                            break\n                    if moved:\n                        return new_sol, \"Local_Recolor\", \"ColorReduction\"\n                    # Kempe-chain swap between max_color and target t < max_color\n                    target_colors = [c for c in range(1, max_color)]\n                    random.shuffle(target_colors)\n                    for t in target_colors:\n                        a, b = max_color, t\n                        queue = deque([v])\n                        seen = set([v])\n                        while queue:\n                            x = queue.popleft()\n                            for y in adj[x]:\n                                if new_sol[y-1] in (a, b) and y not in seen:\n                                    seen.add(y)\n                                    queue.append(y)\n                        test = list(new_sol)\n                        for x in seen:\n                            if test[x-1] == a:\n                                test[x-1] = b\n                            elif test[x-1] == b:\n                                test[x-1] = a\n                        # Verify no conflicts introduced\n                        ok = True\n                        for (u, w) in edges:\n                            if test[u-1] == test[w-1]:\n                                ok = False\n                                break\n                        if ok and sum(1 for x in range(1, n+1) if test[x-1] == max_color) < len(holders):\n                            return test, \"Kempe_Swap\", \"ColorReduction\"\n            # Fallback: random feasible recolor within current palette\n            v = random.randint(1, n)\n            neighbor_colors = {new_sol[w-1] for w in adj[v]}\n            palette = sorted(set(new_sol))\n            feasible = [c for c in palette if c not in neighbor_colors]\n            if feasible:\n                cand = list(new_sol)\n                cand[v-1] = random.choice(feasible)\n                if cand != new_sol:\n                    new_sol = cand\n                    return new_sol, \"Local_Recolor\", \"RandomFeasible\"\n    # As a last resort, return the original (NoOp)\n    return new_sol, \"NoOp\", \"Stall\"\n","PERTURB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    def valid(sol):\n        return isinstance(sol, list) and len(sol) == n and all(isinstance(c,int) and c>=1 for c in sol)\n    if not valid(solution):\n        sol = [((i % 3) + 1) for i in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    # Conflict-guided vertex set\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    # Choose k vertices to perturb (bias to conflicts)\n    base_k = max(2, min(4, n \/\/ 3))\n    chosen = list(conflicts)\n    random.shuffle(chosen)\n    if len(chosen) < base_k:\n        extra = [v for v in vertices if v not in chosen]\n        chosen += extra[: base_k - len(chosen)]\n    else:\n        chosen = chosen[:base_k]\n    palette = sorted(set(sol))\n    max_color = max(palette) if palette else 1\n    # Apply mixed perturbations\n    for v in chosen:\n        neighbor_colors = {sol[w-1] for w in adj[v]}\n        feasible = [c for c in palette if c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            sol[v-1] = random.randint(1, max_color)\n    # Optionally perform one Kempe swap between two random colors to diversify\n    if len(palette) >= 2:\n        a, b = random.sample(palette, 2)\n        start = random.randint(1, n)\n        queue = deque([start])\n        seen = set([start])\n        while queue:\n            x = queue.popleft()\n            for y in adj[x]:\n                if sol[y-1] in (a, b) and y not in seen:\n                    seen.add(y)\n                    queue.append(y)\n        for x in seen:\n            if sol[x-1] == a:\n                sol[x-1] = b\n            elif sol[x-1] == b:\n                sol[x-1] = a\n        # Repair if conflicts exploded: greedy recolor conflicted vertices within palette\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                # try to recolor u first\n                used = {sol[w-1] for w in adj[u]}\n                for c in sorted(set(sol)):\n                    if c not in used:\n                        sol[u-1] = c\n                        break\n    # Relabel to contiguous [1..k] by order of appearance for stability\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,4,3,4]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIG_MISMATCH:Target heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Replace SA\/ILS\/TS with Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Remove bespoke parameter orders to avoid adapter errors.\"\n\"FEEDBACK\",\"E_CALLABLE_PASSING:Heuristic implementations pass called functions in the signature (e.g., generate_neighbour()). Pass callables, not invocations. Use generate_neighbour and evaluate_solution, not generate_neighbour() or evaluate_solution().\"\n\"FEEDBACK\",\"E_NB_RETURN_ARITY:generate_neighbour returns 3 values (solution, NB_Type, Movement_Type) but solvers unpack 1\u20132. Standardize to triple-unpack everywhere or change neighbour to return only the neighbor solution and route metadata via a side-channel.\"\n\"FEEDBACK\",\"R_UNPACK_FIX_SA:In SA move generation, use neigh, nb_type, mv_type = generate_neighbour(currentSolution) and then score = evaluate_solution(neigh). Remove any code assuming a pair.\"\n\"FEEDBACK\",\"R_UNPACK_FIX_ILS:In ILS local search loop, triple-unpack neighbour and propagate metadata to logs; only neigh is evaluated. Ensure acceptance tests use evaluate_solution(neigh).\"\n\"FEEDBACK\",\"R_UNPACK_FIX_TS:In TS, triple-unpack generate_neighbour and update tabu attributes with (nb_type, mv_type). Current error 'expected 2, got 1' implies incorrect invocation or arity; verify you are not calling generate_neighbour() at function definition.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Perturbation Function placeholder '$Perturb' is invalid and breaks ILS signature. Implement a deterministic, side-effect-free perturb_solution(solution, strength, rng) returning a new solution without external I\/O.\"\n\"FEEDBACK\",\"R_PERTURB_IMPL:Implement perturbation as bounded vertex recolors or small Kempe-chain swaps. Example: randomly select p vertices and recolor with minimum-conflict feasible colors; if none, introduce at most one new color. Ensure no filesystem\/network\/OS calls.\"\n\"FEEDBACK\",\"E_HEURISTIC_RETURNS:Verify Heuristic returns both improved currentSolution and best\/best_score consistently. Missing\/incorrect return tuples propagate unpacking errors.\"\n\"FEEDBACK\",\"E_EVAL_CORRECTNESS_ASSERT:Evaluation function validated against the provided reference solution and expected score using the internal Python tool; consistency confirmed.\"\n\"FEEDBACK\",\"E_CODE_PERF:Full evaluation is O(|E|) per call; SA\/TS inner loops multiply cost. Adopt incremental delta evaluation for recolors to reduce per-move cost to O(deg(v)). Cache color counts per adjacency.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbour currently introduces a new color on conflict repair, inflating palette and hindering reduction. Limit new color introduction to when all current colors are infeasible across multiple trials; otherwise enforce min-conflicts recolor within palette.\"\n\"FEEDBACK\",\"R_COLOR_REDUCTION:During conflict-free phases, prioritize targeted recolor of max-color class using greedy DSATUR order before attempting Kempe swaps. After any change, normalize colors to a compact {1..k} to reduce symmetry.\"\n\"FEEDBACK\",\"R_CANONICALIZE:Introduce color relabeling canonicalization (e.g., stable remap by first occurrence) after each accepted move to improve tabu hashing and solution comparison.\"\n\"FEEDBACK\",\"R_INIT_SOL:Replace ad-hoc cyclic init with greedy DSATUR\/least-constraining-value to reduce initial conflicts and speed convergence.\"\n\"FEEDBACK\",\"R_TABU_DESIGN:Tabu attributes should encode (vertex, old_color->new_color). Duration should be adaptive to graph size; ensure aspiration if a move yields a strictly better fitness. Current errors suggest tabu list stores inconsistent keys due to neighbour metadata mismatch.\"\n\"FEEDBACK\",\"R_SA_PARAMS:Use geometric cooling with validated bounds: TEMP0 chosen so ~80% of uphill moves of size 1 are accepted; MIN_TEMP small enough to freeze. Ensure accept = exp(-(delta)\/T) with composite fitness.\"\n\"FEEDBACK\",\"R_ILS_ACCEPT:Define acceptance as accept if fitness(neigh) <= fitness(local_best) or with probability p for diversification; currently unspecified, leading to stalls.\"\n\"FEEDBACK\",\"E_RANDOMNESS:All randomness must come from a passed-in rng object or Python's random without seeding side-effects across components; avoid hidden globals to keep runs reproducible for verification.\"\n\"FEEDBACK\",\"R_LOGGING:If extra outputs are expected, log (iter, fitness, conflicts, colors_used, nb_type, mv_type) every k steps for diagnosis, but do not alter return values or neighbour arity.\"\n\"FEEDBACK\",\"R_SAFETY_MAIN:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Review all components for accidental imports\/usages; keep pure in-memory operations only.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color of vertex i. Colors are 1-based labels. Equal colors are allowed only if the corresponding vertex pair is an edge in G. Objective: minimize number of distinct colors.","Componentes":{"REPRESENTATION":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color of vertex i. Colors are 1-based labels. Equal colors are allowed only if the corresponding vertex pair is an edge in G. Objective: minimize number of distinct colors.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate basic structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected, u<v normalized)\n    edges = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    E = set()\n    for (u,v) in edges:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    non_edges = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                non_edges.append((i,j))\n    # Count violations of complement-coloring constraint\n    violations = 0\n    for (i,j) in non_edges:\n        if solution[i-1] == solution[j-1]:\n            violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective is number of colors used\n    return float(len(set(solution)))\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Provide a basic valid random solution if input invalid\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(9)]\n    else:\n        sol = list(solution)\n    n = 9\n    # Neighborhood move types: single-vertex recolor, color-swap, pairwise swap of vertices\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = set(sol)\n        # Allow moving to an existing color or (rarely) a new color to escape local minima\n        if random.random() < 0.1:\n            new_color = max(current_colors) + 1\n        else:\n            candidates = list(current_colors)\n            if len(candidates) == 1:\n                new_color = max(candidates) + 1\n            else:\n                new_color = random.choice([c for c in candidates if c != sol[i]])\n        sol[i] = int(new_color)\n        return sol\n    elif move_choice < 0.85:\n        # Swap the labels of two colors globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        else:\n            # fallback to recolor\n            i = random.randrange(n)\n            sol[i] = sol[i] if sol[i] > 1 else 2\n        return sol\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Apply multiple random neighbor moves for diversification\n    if not isinstance(solution, list) or len(solution) != 9:\n        sol = [random.randint(1, 4) for _ in range(9)]\n    else:\n        sol = list(solution)\n    steps = 1 + int(3 + 4 * random.random())  # 4-7 random steps\n    for _ in range(steps):\n        # Inline minimal neighbor logic to avoid external deps\n        n = 9\n        move = random.random()\n        if move < 0.5:\n            i = random.randrange(n)\n            current_colors = set(sol)\n            if random.random() < 0.2:\n                new_color = max(current_colors) + 1\n            else:\n                cand = list(current_colors)\n                if len(cand) == 1:\n                    new_color = max(cand) + 1\n                else:\n                    new_color = random.choice([c for c in cand if c != sol[i]])\n            sol[i] = int(new_color)\n        elif move < 0.8:\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx in range(n):\n                    if sol[idx] == a:\n                        sol[idx] = b\n                    elif sol[idx] == b:\n                        sol[idx] = a\n        else:\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_IMPORT_MISSING:Local solvers fail due to missing import of random. Add 'import random, math' at module scope for all solver modules.\nE_SIGNATURE_MISMATCH:Provided solver signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove parentheses from parameters and align names: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_PARAM_CALLABLES:Do not write generate_neighbour() or evaluate_solution() in the signature; pass callables without invoking.\nE_PERTURB_ABSENT:Perturbation Function unresolved placeholder '$Perturb'. Implement def perturb_solution(solution, intensity, rng) -> solution.\nE_NEIGHBOR_RET:generate_neighbour claims multiple return types but returns only a solution. Standardize to return (new_solution, move_type) where move_type in {'recolor','color_swap','vertex_swap'} for TS memory and analysis.\nE_RETURN_PROTOCOL:Ensure all solvers return (best_solution, best_score, meta) where meta contains trace data; current failures stop before any output.\nE_OBJ_DIRECTION:Confirm comparators use lower-is-better; current notes on negatives for maximization are irrelevant here and risk misuse.\nE_SEEDING:Stochastic solvers lack RNG control. Accept rng or seed param; avoid implicit global random for reproducibility.\nE_TS_TABU:Tabu parameters undefined (taboo_list_size, taboo_duration) and aspiration criterion absent. Define explicit tabu tenure, aspiration (override when score improves best), and proper move encoding for tabu list.\nE_ILS_ACCEPT:ILS acceptance rule undefined\/incorrect 'aceptance_rate'. Specify probabilistic acceptance on non-improving moves with bounded stall control; fix typo and semantics.\nE_SA_COOLING:SA signature incorrect and cooling parameters ill-defined. Use geometric cooling T *= alpha with alpha in (0.90,0.99), stop on T<=MIN_TEMP or stall.\nE_EVAL_REBUILD:Evaluation rebuilds non-edges O(n^2) every call. Precompute complement adjacency once and close over it to cut per-eval cost; current cost is avoidable overhead.\nE_SAMPLE_CHECK:Sample solution feasibility depends on complement constraint; ensure neighbor ops don\u2019t introduce violations without penalties. Current evaluation penalizes but solvers must handle penalties correctly in acceptance.\nE_COLOR_BLOAT:Rare new-color creation in neighbor (10%) can inflate palette and stall compaction. Gate new colors to perturbation only; main neighborhood should prefer existing colors and explicit color-merge attempts.\nE_MOVE_SCOPE:Narrow neighborhood hampers escaping plateaus. Add conflict-directed recoloring (pick a conflicting non-edge pair and recolor one endpoint), Kempe-chain swaps, and color-class merge with local repair.\nE_INIT:No constructive initializer. Add greedy heuristic on complement graph (DSATUR or largest-degree-first) to start with low color count and fewer violations.\nE_LOCAL_COMPACTION:Missing color-compaction phase. After any improvement, attempt sequential color elimination: try to reassign vertices of highest label into existing colors using feasibility checks.\nE_TS_MEMORY:Current move representation absent. Store tabu on (vertex,color) or on swapped color labels consistently; without this, tabu cannot prevent cycling.\nE_ACCEPT_TIES:Tie-breaking undefined. Prefer lexicographically minimal solution or minimal sum of labels to stabilize search and cache hits.\nE_METRICS:No stall counters or iteration budgets. Add max_iters, max_no_improve, and early-stop when no improvements over threshold.\nE_VALIDATION:Solver should assert structure validity of solutions (length=9, ints>=1) before evaluation to avoid wasted calls returning sentinel penalties.\nE_EVAL_ASSERT:Evaluator consistency verified on feasible instances; returns exact color count when no violations and large penalties when violations exist. No discrepancies detected.\nS_FIX_ORDER:1) Import random\/math in all solver modules. 2) Correct heuristic signature to TARGET_HEURISTIC_GENERAL_SIGNATURE. 3) Implement perturb_solution. 4) Standardize neighbor to return (solution, move_type). 5) Define return value contract (solution, score, meta). 6) Add RNG parameter.\nS_SA_SPEC:Use def Heuristic(..., other_params={'T0':1.0,'Tmin':1e-3,'alpha':0.95,'iters_per_T':100,'rng':None}) with Metropolis acceptance p=exp(-(new-old)\/T) for worse moves; clamp to feasible-first (reject if violation count increases above a cap).\nS_ILS_SPEC:Use kick via perturb_solution with adaptive intensity; accept new solution if score improves or with small probability if equal\/worse; restart on stalls.\nS_TS_SPEC:Tabu tenure ~7\u201315 moves, aspiration overrides when new_score<best_score; use short-term memory on (vertex,color) and long-term frequency to diversify.\nS_NEIGHBORS:Add: (a) move vertex to best feasible color; (b) 2-opt on color classes (swap subsets); (c) color merge + local repair; (d) Kempe chain exchanges between two colors.\nS_EVAL_OPT:Precompute complement adjacency list once; implement evaluate(solution) using adjacency to count conflicts and colors in O(n + m\u0304).\nS_INITIALIZER:Construct DSATUR on complement to produce a low-color starting solution; back it with random tie-breaking via rng for diversity.\nS_LOGGING:Record per-iter (iter,score,violations,move_type,T or tenure). Keep best trajectory for analysis and reproducibility.\nS_CONSTRAINT_ENFORCE:Prefer feasibility-preserving moves; if allowing violations, incorporate composite score = violations*1e5 + colors to guide back to feasibility deterministically.\nS_TESTS:Add unit tests: (i) invalid structure returns >1e6; (ii) single violation returns 100001; (iii) feasible solutions return integer color count; (iv) neighbor never returns invalid list length\/types.\nE_LOCAL_SOLVER_ERRORS_FIRST:Address import\/signature\/perturbation issues before tuning heuristics; current code cannot execute, blocking any optimization.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-based). Vertices sharing a color must be pairwise adjacent in G; objective is to minimize the number of distinct colors.","Componentes":{"REPRESENTATION":"INDEX_LIST_COLORS_LEN9: solution is a JSON list of 9 positive integers [c1,...,c9], where ci is the color assigned to vertex i (1-based). Vertices sharing a color must be pairwise adjacent in G; objective is to minimize the number of distinct colors.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","NB_CODE":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a basic valid random solution\n        max_color = 4\n        sol = [random.randint(1, max_color) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Neighborhood: recolor single vertex (prefer existing colors), color-swap, vertex-swap\n    r = random.random()\n    if r < 0.6:\n        # Single-vertex recolor\n        i = random.randrange(n)\n        current_colors = list(set(sol))\n        # Prefer existing colors different from current; rarely add a new color\n        if len(current_colors) > 1 and random.random() < 0.95:\n            candidates = [c for c in current_colors if c != sol[i]]\n            if candidates:\n                sol[i] = int(random.choice(candidates))\n            else:\n                sol[i] = sol[i]\n        else:\n            sol[i] = int(max(current_colors) + 1)\n        return sol, \"recolor\"\n    elif r < 0.85:\n        # Swap two color labels globally\n        colors = list(set(sol))\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        return sol, \"color_swap\"\n    else:\n        # Swap colors of two vertices\n        i, j = random.sample(range(n), 2)\n        sol[i], sol[j] = sol[j], sol[i]\n        return sol, \"vertex_swap\"\n","PERTURB_CODE":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-step randomized diversification\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 4) for _ in range(n)]\n    else:\n        sol = list(solution)\n    steps = 4 + int(4 * random.random())  # 4-7 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # Recolor vertex, occasionally introduce new color\n            i = random.randrange(n)\n            colors = list(set(sol))\n            if random.random() < 0.8 and len(colors) > 1:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n                else:\n                    sol[i] = sol[i]\n            else:\n                sol[i] = int(max(colors) + 1)\n        elif move < 0.8:\n            # Global color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        else:\n            # Swap colors between two vertices\n            i, j = random.sample(range(n), 2)\n            sol[i], sol[j] = sol[j], sol[i]\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.0\"\n\n\"FEEDBACK\":\"FIX_IMPORT_RANDOM:All three local solvers crash with NameError due to missing 'import random'. Add 'import random' at top of each heuristic implementation.;FIX_SIGNATURE_MISMATCH:Heuristics do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Implement a single entry point def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) and route SA\/ILS\/TS via a 'method' key in other_params. Ensure return (best_solution,best_score,meta).;FIX_MISSING_PERTURB:'Perturbation Function' is undefined ($Perturb placeholder). Provide a valid def perturb_solution(solution): ... with controlled, diversified moves (e.g., multi-vertex recolor, Kempe-chain swap). Pass this handle to Heuristic.;EVAL_ASSERTION:Evaluation function verified against a reference input using the provided evaluate_solution; correctness assertion passes. Maintain this evaluate_solution unchanged during integration.;INIT_GEN_NEIGH_RANDOM_SCOPE:generate_neighbour relies on random without deterministic controls. Expose rng seed via other_params and inject rng methods to ensure reproducibility and testability.;NB_CODE_FAIL_LOCAL_OPT:Neighborhood limited to recolor\/swap operations; lacks structure-exploiting moves. Add Kempe-chain interchanges, color-class merge\/split, and vertex ejection chains to escape plateaus.;NB_COLOR_EXPANSION_BIAS:Recolor prefers existing colors but occasionally adds new colors, which increases objective and stalls pruning. Add targeted 'reduce-color' moves that attempt to eliminate the highest color label by reassignment and feasibility repair.;LABEL_NORMALIZATION_MISSING:Color labels drift and create redundant states. After each move, relabel colors to a compact canonical form (e.g., remap to 1..m in first-appearance order) to shrink search space and make tabu hashing effective.;VIOLATION_PENALTY_SCALING:Current evaluation imposes 1e5+violations. Heuristics must treat feasibility first. Use lexicographic acceptance (violations first, then colors), or a composite score score=(violations, colors) with tuple-comparison, not floating additions inside the heuristic logic.;SA_PARAM_DEFECT:SA signature in logs is wrong and missing imports. Replace with SA wrapper inside Heuristic: parameters {T0, Tmin, alpha, iters_per_T}. Use Metropolis with acceptance on lexicographic score and reheating on stagnation. Avoid creating new colors unless violation reduction achieved.;ILS_DEFECT:ILS lacks a defined acceptance and uses undefined random. Implement: local_search via repeated generate_neighbour until no improvement; perturb via perturb_solution with strength k; use better-or-equal acceptance on lexicographic score; adaptive k if stagnating.;TABU_TENURE_CONFIG:Tabu Search missing random and uses unclear 'taboo' naming. Implement aspiration, dynamic tenure tt in [5,10] based on improvement rate, and hash state via normalized color vector or edge-conflict set to prevent cycling.;MOVE_EVALUATION_COST:E_CODE_PERF:O(n^2) re-evaluation each step. Cache conflicts per vertex and update incrementally on single-vertex recolors for O(degree) updates. For color swaps, update affected vertices only.;STOPPING_CRITERIA_WEAK:Define iteration\/time caps, no-improvement window, and early termination when a target color count is reached. Emit meta stats required by the local solver (iterations, best_at, moves_counts).;TEST_HARNESS_MISSING:Add unit tests: (1) structure validation (wrong length\/types), (2) feasibility checks on crafted conflicts, (3) invariants after normalization, (4) neighbor never returns invalid length\/types. Use deterministic RNG seeds.;INTERFACE_CONTRACT:Ensure Heuristic never accesses filesystem\/network\/OS (MAIN_CRITICAL_INSTRUCTION). No prints required; return extra diagnostics via meta dict only.;SUGGESTED_STUB:Implement Heuristic router with method in other_params in {SA, ILS, TS}, all calling common evaluate(move) that compares (violations, colors) tuples, uses normalized labels, and respects injected rng.;KNOWN_BEST_CHECK:Do not hardcode or leak any target solution or value. Use evaluate_solution only for runtime verification inside tests without exposing reference outcomes in logs.;EXPECTED_EXTRA_OUTPUTS:Return structure: (best_solution, best_score, {'method':..., 'iters':..., 'accepted':..., 'improvements':..., 'tabu_hits':..., 'seed':...}) to satisfy the local solver\u2019s expectation for additional outputs.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"INDEX_LIST_COLORS_LEN9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv.","Componentes":{"REPRESENTATION":"INDEX_LIST_COLORS_LEN9: solution is a list of 9 positive integers [c1,...,c9] where ci is the color assigned to vertex i (1-based). Objective: minimize number of distinct colors subject to: for all non-edges (u,v) in G, cu != cv.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate structure\n    if not isinstance(solution, list):\n        return 1000000.0\n    n = 9\n    if len(solution) != n:\n        return 1000000.0 + float(abs(len(solution) - n))\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1000000.0 + 1.0\n    # Graph data (undirected)\n    edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for (u,v) in edges_input:\n        if u > v:\n            u, v = v, u\n        E.add((u,v))\n    # Build non-edges of G and count violations when same color appears on non-edge pair\n    violations = 0\n    for i in range(1, n+1):\n        ci = solution[i-1]\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if ci == solution[j-1]:\n                    violations += 1\n    if violations > 0:\n        return 100000.0 + float(violations)\n    # Feasible: objective = number of distinct colors (lower is better)\n    return float(len(set(solution)))\n","NB_CODE":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers local to this function to avoid globals\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        # A vertex can join a color class if it is adjacent in G to all vertices already in that color\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    def reduce_color_move(E, sol):\n        # Attempt to remove the highest color by reassigning its vertices to existing colors\n        sol = list(sol)\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        max_color = max(colors)\n        verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n        other_colors = [c for c in colors if c != max_color]\n        success = True\n        random.shuffle(verts)\n        for v in verts:\n            random.shuffle(other_colors)\n            placed = False\n            for c in other_colors:\n                if compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            sol = [c if c != max_color else max_color for c in sol]  # no remaining max_color\n            sol = normalize_colors(sol)\n            return sol, True\n        return sol, False\n    def kempe_chain_swap_on_conflict_graph(E, sol):\n        # Build conflict graph H where an edge exists if two vertices are non-adjacent in G\n        n = 9\n        H_adj = {i: [] for i in range(1,n+1)}\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                if not is_edge(E, i, j):\n                    H_adj[i].append(j)\n                    H_adj[j].append(i)\n        colors = list(set(sol))\n        if len(colors) < 2:\n            return list(sol)\n        a, b = random.sample(colors, 2)\n        # vertices with color a or b\n        nodes = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not nodes:\n            return list(sol)\n        start = random.choice(nodes)\n        # BFS in H restricted to nodes colored a or b\n        visited = set()\n        q = deque([start])\n        visited.add(start)\n        while q:\n            u = q.popleft()\n            for v in H_adj[u]:\n                if v not in visited and sol[v-1] in (a,b):\n                    visited.add(v)\n                    q.append(v)\n        out = list(sol)\n        for v in visited:\n            out[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return normalize_colors(out)\n    # Start\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    r = random.random()\n    if r < 0.45:\n        # Single-vertex recolor (prefer existing colors, occasionally new)\n        i = random.randrange(n)\n        current_colors = sorted(set(sol))\n        move_to_new = (random.random() < 0.05)\n        if move_to_new:\n            sol[i] = max(current_colors) + 1\n            move = \"recolor_new\"\n        else:\n            choices = [c for c in current_colors if c != sol[i]]\n            if choices:\n                sol[i] = int(random.choice(choices))\n            move = \"recolor_existing\"\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.7:\n        # Global color label swap\n        colors = list(set(sol))\n        move = \"color_swap\"\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            for idx in range(n):\n                if sol[idx] == a:\n                    sol[idx] = b\n                elif sol[idx] == b:\n                    sol[idx] = a\n        sol = normalize_colors(sol)\n        return sol, move\n    elif r < 0.85:\n        # Reduce-color attempt\n        new_sol, ok = reduce_color_move(E, sol)\n        return (new_sol if ok else sol), (\"reduce_color\" if ok else \"reduce_color_fail\")\n    else:\n        # Kempe-chain style swap in conflict graph\n        sol2 = kempe_chain_swap_on_conflict_graph(E, sol)\n        return sol2, \"kempe_chain\"\n","PERTURB_CODE":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helpers\n    def normalize_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    def build_edges():\n        edges_input = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n        E = set()\n        for (u,v) in edges_input:\n            if u > v:\n                u, v = v, u\n            E.add((u,v))\n        return E\n    def is_edge(E,u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    def compatible_with_color(E, sol, vertex, color):\n        for idx, c in enumerate(sol, start=1):\n            if c == color and idx != vertex:\n                if not is_edge(E, vertex, idx):\n                    return False\n        return True\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [i+1 for i in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize_colors(sol)\n    E = build_edges()\n    steps = 5 + int(5 * random.random())  # 5-9 steps\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.35:\n            # Random recolor (allow new colors with small prob)\n            i = random.randrange(n)\n            colors = sorted(set(sol))\n            if random.random() < 0.15:\n                sol[i] = max(colors) + 1\n            else:\n                choices = [c for c in colors if c != sol[i]]\n                if choices:\n                    sol[i] = int(random.choice(choices))\n        elif move < 0.6:\n            # Random color label swap\n            colors = list(set(sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for k in range(n):\n                    if sol[k] == a:\n                        sol[k] = b\n                    elif sol[k] == b:\n                        sol[k] = a\n        elif move < 0.8:\n            # Greedy reassignment to existing colors for a random vertex\n            v = random.randrange(n) + 1\n            colors = sorted(set(sol))\n            random.shuffle(colors)\n            for c in colors:\n                if c != sol[v-1] and compatible_with_color(E, sol, v, c):\n                    sol[v-1] = c\n                    break\n        else:\n            # Attempt to remove highest color by reassigning its vertices greedily\n            colors = sorted(set(sol))\n            if len(colors) > 1:\n                max_color = max(colors)\n                verts = [i+1 for i,c in enumerate(sol) if c == max_color]\n                other_colors = [c for c in colors if c != max_color]\n                random.shuffle(verts)\n                for v in verts:\n                    random.shuffle(other_colors)\n                    for c in other_colors:\n                        if compatible_with_color(E, sol, v, c):\n                            sol[v-1] = c\n                            break\n        sol = normalize_colors(sol)\n    return sol\n","SAMPLE_SOL":"[1,2,3,4,5,6,7,8,9]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"v1.0.1\"\n\n\"FEEDBACK\":\n- FIX_LOCAL_SOLVER_SIGNATURES:Remove parentheses from function parameters; pass callables not results. Use def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor) and similarly for ILS\/TS. Current use of generate_neighbour() and evaluate_solution() in signatures triggers premature execution and unpack errors.\n- FIX_NEIGHBOR_RETURN_CONTRACT:Standardize generate_neighbour to always return exactly (new_solution, move_meta). Ensure all solvers unpack as new_sol, move = generate_neighbour(curr). Mixed expectations (1 vs 2 values) caused both \u201ctoo many\u201d and \u201cnot enough\u201d unpack errors.\n- FIX_TS_EXPECTED_RETURNS:Tabu Search must consistently handle the 2-tuple from generate_neighbour. Update TS iteration to: cand, move = generate_neighbour(curr); if move in tabu and not aspiration: continue.\n- FIX_PERTURB_MISSING:$Perturb is undefined. Implement perturb_solution(solution, strength, rng) returning a valid solution and a meta tag. Example operations: (a) multi-vertex recolor with existing colors only, (b) one Kempe-chain swap on the conflict graph, (c) one reduce-color attempt; choose based on strength.\n- NB_CODE_BUG:reduce_color_move contains a no-op line sol = [c if c != max_color else max_color ...]. This fails to eliminate the removed color label. Replace with: after successful reassignment, drop max_color and call normalize_colors once to compress labels.\n- NB_CODE_FAIL_LOCAL_OPT:Single-vertex recolor and color-swap are weak for minimizing colors. Add targeted moves: (a) merge two smallest color classes where all cross pairs are edges in G; (b) vertex ejection with best-fit insertion into existing compatible colors; (c) focused Kempe swap between largest and second-largest classes in conflict graph.\n- EVAL_CORRECTNESS_ASSERT:Evaluation function verified against a reference feasible solution via Python; returns the correct objective and penalizes violations. No discrepancies detected.\n- EVAL_PERF:Current evaluate_solution is O(n^2) per call with repeated E construction. Precompute E and non-edges once and close over them, or cache adjacency as bitsets to reduce constant factors. For iterative local search, consider incremental delta evaluation for single-vertex recolors.\n- CONSTRAINT_ENFORCEMENT:Neighbourhood must respect complement-coloring feasibility when attempting color reduction. Enforce compatible_with_color before assignments; reject infeasible candidates early to avoid expensive penalty evaluations.\n- COLOR_NORMALIZATION_POLICY:Normalize colors after every move (including perturbation and reduce-color) to break symmetry and stabilize the objective count. Ensure normalization preserves class partitioning and does not trigger unintended label collisions mid-iteration.\n- SA_ACCEPTANCE_RULE:Use delta = f(new)-f(curr). If delta < 0 accept; else accept with p = exp(-delta\/T). Never accept infeasible candidates with penalty floor unless explicitly using a staged feasibility phase; otherwise search drifts into penalty plateaus.\n- ILS_ACCEPTANCE_AND_PERTURB:Define acceptance as accept if f(new) < f(best) or if f(new) <= f(curr) with probability p_accept. Perturb with adaptive strength: increase when stagnating, decrease after improvement; keep solutions feasible post-perturb.\n- TS_TABU_POLICY:Tabu entries should store (move signature, tenure). Use aspiration: allow tabu if candidate strictly improves best_score. Maintain tabu tenure = O(n) and list size bounded; evict expired entries each iteration.\n- TERMINATION_AND_OUTPUTS:Local solvers should return a consistent triple (best_solution, best_score, extras_dict) where extras_dict may include trace logs, last_move, iter_count, and timing. Ensure compatibility with evaluation harness expecting extra outputs.\n- PARAM_INIT:Start from a feasibility-preserving solution with low color count: greedy constructive under complement-constraint (largest-first insertion into smallest compatible color class) to reduce time to improvements versus [1..9].\n- RANDOMNESS_CONTROL:Set rng seed via local RNG objects passed in other_params to ensure reproducibility. Do not rely on global random state inside components.\n- KNOWN_ISSUE_EDGE_BUILD_DUP:Edges E are rebuilt in both evaluate and neighbor; refactor into a shared closure or constant to avoid overhead and inconsistencies.\n- TESTS_MINIMAL:Unit-test generate_neighbour for: (a) returns 2-tuple, (b) preserves feasibility for moves that claim feasibility, (c) reduce_color_move truly reduces color count when possible, (d) kempe_chain maintains feasibility in conflict graph context.\n- METRICS_LOGGING:Track best_score over time, accepted_worse_count, and move-type frequencies to detect stagnation and tune r-branch probabilities in generate_neighbour.\n- SUGGESTED_PARAMS:SA: TEMP=1.0, MIN_TEMP=1e-3, cooling=0.95, iters_per_temp\u224850. TS: iterations=2000, tabu_tenure=7\u201310. ILS: iterations=1000, acceptance_rate\u22480.05 initially, adaptive thereafter. Adjust based on move acceptance logs."}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}.Example: \"1,1,1,2,3,2,3,4,4\"","Componentes":{"REPRESENTATION":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}.Example: \"1,1,1,2,3,2,3,4,4\"","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Parse\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n    # Graph definition\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n    # Minimality via complement coloring with k-1 colors\n    V = list(range(1, 10))\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j:\n                if not friends(i, j):\n                    comp_adj[i].add(j)\n                    comp_adj[j].add(i)\n    def can_color(K):\n        order = sorted(V, key=lambda x: len(comp_adj[x]), reverse=True)\n        color = {v: 0 for v in V}\n        def dfs(idx):\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            color[v] = 0\n            return False\n        return dfs(0)\n    if k > 1 and can_color(k-1):\n        return k + 10**6\n    return k\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        # Map existing labels to 1..k in order of appearance\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    def feasible(L):\n        g = groups_of(L)\n        return all(is_group_clique(m) for m in g.values())\n\n    L = labels[:]\n\n    # Candidate moves: move, swap, merge, split\n    for _ in range(64):\n        move_type = random.choices([\"move\",\"swap\",\"merge\",\"split\"], weights=[0.5,0.2,0.15,0.15])[0]\n        cand = L[:]\n        if move_type == \"move\":\n            i = random.randrange(9)  # vertex index 0..8\n            current_lab = cand[i]\n            k = max(cand)\n            # possible target labels among existing labels or new one k+1\n            targets = list(set(range(1, k+1)))\n            # Optionally allow new label to diversify\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            moved = False\n            for t in targets:\n                if t == current_lab:\n                    continue\n                # Check clique with target group members\n                members = [idx+1 for idx, lab in enumerate(cand) if lab == t]\n                v = i+1\n                if all(friends(v, u) for u in members):\n                    cand[i] = t\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"move\"\n            # no move found, continue to other attempt\n        elif move_type == \"swap\":\n            i, j = random.sample(range(9), 2)\n            if L[i] != L[j]:\n                cand[i], cand[j] = cand[j], cand[i]\n                cand = compress(cand)\n                if feasible(cand):\n                    L = cand\n                    return ','.join(str(x) for x in L), \"swap\"\n        elif move_type == \"merge\":\n            k = max(L)\n            if k >= 2:\n                a, b = sorted(random.sample(range(1, k+1), 2))\n                # try merging group b into a if clique holds\n                members_a = [idx+1 for idx, lab in enumerate(cand) if lab == a]\n                members_b = [idx+1 for idx, lab in enumerate(cand) if lab == b]\n                ok = True\n                for u in members_b:\n                    if not all(friends(u, v) for v in members_a):\n                        ok = False\n                        break\n                if ok:\n                    for idx, lab in enumerate(cand):\n                        if lab == b:\n                            cand[idx] = a\n                    cand = compress(cand)\n                    if feasible(cand):\n                        L = cand\n                        return ','.join(str(x) for x in L), \"merge\"\n        else:  # split\n            # Split a clique into two cliques by separating a subset that is a clique itself\n            g = groups_of(cand)\n            labs = [lab for lab, mem in g.items() if len(mem) >= 2]\n            if labs:\n                lab = random.choice(labs)\n                members = g[lab][:]\n                random.shuffle(members)\n                # try take a non-empty proper subset that is a clique\n                for sz in range(1, len(members)):\n                    subset = set(members[:sz])\n                    # check subset is clique and remaining is clique (always true since original is clique)\n                    def is_clique(S):\n                        S = list(S)\n                        for a in range(len(S)):\n                            for b in range(a+1, len(S)):\n                                if not friends(S[a], S[b]):\n                                    return False\n                        return True\n                    if is_clique(subset):\n                        new_lab = max(cand) + 1\n                        for idx, labv in enumerate(cand):\n                            if labv == lab and (idx+1) in subset:\n                                cand[idx] = new_lab\n                        cand = compress(cand)\n                        if feasible(cand):\n                            L = cand\n                            return ','.join(str(x) for x in L), \"split\"\n    return ','.join(str(x) for x in L), \"noop\"\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake: multiple random feasible moves with repairs\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(3, 8)\n    for _ in range(steps):\n        k = max(L)\n        i = random.randrange(9)\n        v = i+1\n        # choose candidate target labels including possibly new one\n        targets = list(set(range(1, k+1)))\n        if k < 9:\n            targets.append(k+1)\n        random.shuffle(targets)\n        moved = False\n        for t in targets:\n            if t == L[i]:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n            if all(friends(v, u) for u in members):\n                L[i] = t\n                L = compress(L)\n                if feasible(L):\n                    moved = True\n                    break\n        if not moved:\n            # try random relabel then repair by moving into singleton\n            L[i] = random.randint(1, max(L)+1)\n            L = compress(L)\n            if not feasible(L):\n                # revert if infeasible\n                L = labels[:]\n                break\n    return ','.join(str(x) for x in L)\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_SIG_MISMATCH:Target heuristics not conforming to TARGET_HEURISTIC_GENERAL_SIGNATURE. Remove per-algorithm custom signatures and implement a single wrapper Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params) that internally dispatches to SA\/ILS\/TS if needed.\"\n\n\"FEEDBACK\",\"E_TYPEHINT_Tuple:Runtime error 'Type Tuple cannot be instantiated; use tuple() instead' indicates misuse of typing.Tuple as a constructor or solver attempting to call annotations. Remove typing-based Tuple instantiation and avoid annotations that the runner might eval. Use either no return annotation or a builtin tuple alias (tuple[str, str]) strictly as a static hint, never as a callable.\"\n\n\"FEEDBACK\",\"E_FUNC_ARG_CALL:Local solver signatures show generate_neighbour() and evaluate_solution() with parentheses in signature strings. Do not pass called results; pass function objects. Ensure all heuristic constructors accept callables without invoking them in signatures or at binding time.\"\n\n\"FEEDBACK\",\"E_MISSING_COMPONENT:Perturbation Function is placeholder '$Perturb'. Provide a valid deterministic, side-effect-free perturb_solution(solution) that returns a CSV9 string and never accesses FS\/Network\/OS per 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS.\"\n\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:generate_neighbour return annotation uses a string literal ('NB_Type','Movement_Type') and imports Tuple unused. Remove import typing.Tuple, and if annotations are required, prefer -> tuple[str, str]. Avoid any runtime use of annotations by the local solver.\"\n\n\"FEEDBACK\",\"NB_MOVE_INEFF:Neighbour generation loops up to 64 random attempts with full feasibility checks per attempt, O(9^2) each. Consider deterministic neighborhood enumeration for local descent steps and restrict randomization to perturbation to reduce variance and speed convergence.\"\n\n\"FEEDBACK\",\"NB_COMPRESS_SIDE_EFFECT:compress remaps labels by order-of-appearance after each tentative move, potentially masking whether a move reduced k versus just relabeling. Apply compress only after move acceptance, and track k changes pre\/post to bias selection toward k reduction.\"\n\n\"FEEDBACK\",\"NB_SPLIT_OVEREXPAND:split introduces a new label even when not needed, inflating k and relying on compress to clean up later. Guard with: only split if it produces a valid move that leads to improved or diversified state (e.g., creates a path to merge elsewhere) and cap k <= 9.\"\n\n\"FEEDBACK\",\"NB_MERGE_CHECK_COST:merge feasibility checks cross edges between all pairs of groups; currently checks only b->a cross edges. That\u2019s sufficient but repeated full feasible() after compress is redundant. Replace with targeted validation: verify clique of merged group only.\"\n\n\"FEEDBACK\",\"EVAL_MINIMALITY_PENALTY:Minimality test increases objective by 1e6 when k-1 coloring possible; this causes extreme discontinuities that can trap SA\/TS acceptance rules. Replace hard penalty with soft constraint or separate feasibility flag to let annealing accept borderline moves.\"\n\n\"FEEDBACK\",\"EVAL_EXP_BACKTRACK:Complement coloring uses DFS backtracking exponential in n; acceptable for n=9 but still heavy in inner loops. Cache colorability results by K with bitmask key of current grouping or use DSATUR heuristic to prune earlier.\"\n\n\"FEEDBACK\",\"R_STR_INADEQUATE:Pure random neighbor choices inhibit systematic exploration. Recommend hybrid: greedy-improving neighborhood first (move\/merge prioritized by delta-k, then by least-added conflicts), fallback to random for diversification.\"\n\n\"FEEDBACK\",\"SA_PARAM_DRIFT:No temperature schedule provided. Use geometric cooling with adaptive restarts: TEMP0 tuned to accept ~80% uphill moves of size 1 on average; cooling_factor in [0.90,0.99]; MIN_TEMP set so expected improvements freeze after no-improve epochs.\"\n\n\"FEEDBACK\",\"TS_MEMORY_DEF:No taboo list management given. Implement fixed-size FIFO tabu for moves (vertex,label) with aspiration if k decreases. Tabu tenure ~ [5,10] steps given n=9 to prevent cycling while allowing escape.\"\n\n\"FEEDBACK\",\"ILS_WEAK_PERTURB:ILS acceptance and perturbation undefined. Implement kick as 1\u20132 random vertex relabels into compatible cliques or a random split+merge chain preserving feasibility. Use acceptance if score improves or with small probability for equal score to diversify.\"\n\n\"FEEDBACK\",\"EVAL_CORRECTNESS_ASSERT:Using the provided evaluation function, the supplied reference solution evaluates to a finite minimal objective. Independent verification executed to assert evaluator consistency and catch regressions.\"\n\n\"FEEDBACK\",\"CODE_SAFETY:Ensure all components avoid FS\/Network\/OS access. Keep randomness local via Python\u2019s random module, no seeding from environment. Return pure strings; no printing\/logging side effects from components.\"\n\n\"FEEDBACK\",\"TEST_SCENARIOS:Add unit tests: (1) malformed input lengths; (2) non-contiguous labels; (3) group with non-edges -> infeasible; (4) feasible with k decreased by a merge; (5) non-minimality caught via complement coloring; (6) neighbour always returns CSV9 and a movement tag.\"\n\n\"FEEDBACK\",\"IMPLEMENTATION_PATCHES:\n- Fix signatures: def Heuristic(currentSolution, best, best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params): ...\n- Remove typing.Tuple import; remove string tuple return annotation in generate_neighbour.\n- Provide perturb_solution(solution): random valid move sequence bounded to keep feasibility; return CSV9.\n- Pass callable references to SA\/ILS\/TS, do not call them on binding.\n- Reduce penalty magnitude or separate minimality from score for acceptance logic.\n- Cache complement colorability results for given K to cut repeated DFS work.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Componentes":{"REPRESENTATION":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","EVAL_CODE":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return 10**9\n    s = solution.strip()\n    if s == \"\":\n        return 10**9\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if len(labels) != 9:\n        return 10**9\n    if any(x <= 0 for x in labels):\n        return 10**9\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return 10**9\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return 10**9\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        def dfs(idx: int) -> bool:\n            if idx == len(order):\n                return True\n            v = order[idx]\n            used_colors = set(color[u] for u in comp_adj[v] if color[u] != 0)\n            for c in range(1, K+1):\n                if c not in used_colors:\n                    color[v] = c\n                    if dfs(idx+1):\n                        return True\n                    color[v] = 0\n            return False\n        return dfs(0)\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000  # soft penalty to discourage non-minimal k\n    return k\n","NB_CODE":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Try greedy MERGE that reduces k\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) Deterministic MOVE: try moving a single vertex to another existing label to enable future merges (keep feasibility)\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) As fallback, random feasible slight diversification: move into new singleton if allowed\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","PERTURB_CODE":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # light randomization\n        if move_type == \"merge\" and k >= 2:\n            # attempt random merge if compatible\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle labels of two vertices if remains feasible\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        # fallback to original if perturbation broke feasibility\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","SAMPLE_SOL":"1,1,1,2,3,2,3,4,4"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"v1\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Heuristic wrappers pass function CALLS instead of callables. Remove parentheses in parameters. Align to TARGET_HEURISTIC_GENERAL_SIGNATURE exactly.\nE_LOCAL_SOLVER_ARG_ORDER:SA\/ILS\/TS signatures mismatch target. Provide adapters that map (currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Do not rely on positional variadics.\nE_LOCAL_SOLVER_FIRST_ARG:Framework error 'Expected first argument to be an integer, a callable, or None' indicates a callable was evaluated prematurely. Ensure generate_neighbour and evaluate_solution are passed by reference, not invoked.\nE_PERTURB_ABSENT:'$Perturb' placeholder breaks ILS\/SA. Implement a concrete perturbation that preserves feasibility or performs repair after perturb, else search stagnates or crashes.\nE_API_CONTRACT:Movement_Type string is returned but not standardized. If TS relies on move classification for tabu tenure, define a fixed finite set {'merge','move','swap','diversify'} and consume it consistently.\nE_EVAL_CORRECTNESS_ASSERT:PASS. The provided evaluate_solution returns the expected value on the secret reference input; no disclosure provided.\nE_EVAL_MINIMALITY_CHECK:Backtracking coloring in can_color is exponential. Although n=9 is small, this can dominate runtime in loops. Introduce early bounds (degree ordering with DSATUR, color availability pruning) or cache by bitmask to cut states.\nE_EVAL_STATEFUL_CACHE:can_color is cached only by K; order is constant but color dict is reallocated each call. Memoize by (K,forbidden_sets_signature) or precompute complement adjacency bitmasks and use bit DP to accelerate lower-bound checks.\nE_EVAL_RETURN_SCALE:Use consistent numeric domains. Returning 10**9 for infeasible mixes with objective k. Prefer a sentinel large constant stored as INF=10**6 for this instance or keep 10**9 but document and never compare with > vs >= ambiguities.\nNB_CODE_FAIL_LOCAL_OPT:Neighborhood is shallow and largely greedy; may stall. Deterministic first-fit merge\/move limits exploration and induces cycling under TS without aspiration.\nNB_MOVE_VALIDATION:SWAP feasibility is rechecked fully each time (O(n^2) per check). Pre-check only the two affected groups with incremental adjacency to reduce cost.\nNB_MERGE_CRITERION:MERGE accepts only fully compatible cross-edges; misses opportunity to move blocker vertices out to enable merge. Integrate 'evict-and-merge' local move.\nNB_DIVERSIFY_WEAK:Diversification step injects a new singleton and immediately compresses; effect is minimal and may reverse next iteration. Add multi-vertex perturb or random re-labeling of a small block.\nREP_CONTIGUITY:compress changes label identities non-deterministically across iterations, breaking tabu lists keyed by labels. Use canonical relabeling but store tabu on vertex-to-vertex co-membership or sorted group membership to remain stable.\nINIT_STRATEGY:Single 'Sample Solution' is feasible but lacks construction diversity. Provide greedy clique-building randomized constructor to seed multiple runs for SA\/TS\/ILS.\nR_ACCEPTANCE:SA acceptance rule unspecified. Use delta=neigh_score-cur_score; accept if delta<0 or random()<exp(-delta\/T). Ensure lesser-is-better handling.\nTS_TABU_LIST:No aspiration or frequency-based memory specified. Add aspiration if neigh_score<bests_score; include short-term tabu on moved vertices, and long-term penalty for frequently used moves.\nILS_PERTURB_INTENSITY:No control. Define perturb strength proportional to stagnation counter; e.g., reassign 1-3 vertices to new\/existing cliques with feasibility repair.\nREPAIR_OPERATOR_MISSING:After random perturb, feasibility may break if used elsewhere. Add repair: split any non-clique group by peeling a vertex that violates clique property.\nPARAM_TUNING:Lack of calibrated defaults causes instability. Provide default SA(T0=5, Tmin=1e-3, alpha=0.95, iters_per_T=50), TS(iters=200, tabu_size=7, tenure=5), ILS(iters=200, accept_if<=, perturb_k=2).\nCODE_STYLE_CONTRACT:Ensure 0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS. Current components comply; maintain this in all new adapters.\nCONCRETE_FIX_ADAPTER_SA:def SA_adapter(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params):\\n    T=params.get('TEMP',5.0); Tmin=params.get('MIN_TEMP',1e-3); alpha=params.get('cooling_factor',0.95)\\n    cur=currentSolution; cur_s=evaluate_solution(cur); best_s=best_score; best_sol=best\\n    import random\\n    while T>Tmin:\\n        for _ in range(params.get('iters_per_T',50)):\\n            nb,_mt=generate_neighbour(cur)\\n            nb_s=evaluate_solution(nb)\\n            d=nb_s-cur_s\\n            if d<0 or random.random()<math.exp(-d\/T):\\n                cur,cur_s=nb,nb_s\\n                if cur_s<best_s:\\n                    best_sol, best_s = cur, cur_s\\n        T*=alpha\\n    return best_sol, best_s\nCONCRETE_FIX_ADAPTER_TS:def TS_adapter(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,params):\\n    tabu_tenure=params.get('tabu_duration',5); max_size=params.get('taboo_list_size',7); iters=params.get('iterations',200)\\n    cur=currentSolution; cur_s=evaluate_solution(cur); best_sol=best; best_s=best_score\\n    from collections import deque\\n    tabu=deque()\\n    for _ in range(iters):\\n        best_nb=None; best_nb_s=10**9; best_move=None\\n        # sample limited neighbors for efficiency\\n        for __ in range(params.get('nb_samples',30)):\\n            nb,mt=generate_neighbour(cur)\\n            move=(cur,nb,mt)\\n            if move in tabu: continue\\n            s=evaluate_solution(nb)\\n            if s<best_nb_s or (s<best_s):\\n                best_nb, best_nb_s, best_move = nb, s, move\\n        if best_nb is None:\\n            nb,mt=generate_neighbour(cur); best_nb, best_nb_s, best_move=nb, evaluate_solution(nb), (cur,nb,mt)\\n        cur,cur_s=best_nb,best_nb_s\\n        tabu.append(best_move)\\n        if len(tabu)>max_size: tabu.popleft()\\n        if cur_s<best_s: best_sol,best_s=cur,cur_s\\n    return best_sol, best_s\nCONCRETE_FIX_ADAPTER_ILS:def ILS_adapter(currentSolution,best,best_score,generate_neighbour,perturb_solution,evaluate_solution,params):\\n    iters=params.get('iterations',200); accept=params.get('accept_if_better',True)\\n    cur=currentSolution; cur_s=evaluate_solution(cur); best_sol=best; best_s=best_score\\n    for _ in range(iters):\\n        # Local search phase\\n        improved=True\\n        while improved:\\n            improved=False\\n            nb,_=generate_neighbour(cur)\\n            s=evaluate_solution(nb)\\n            if s<cur_s:\\n                cur,cur_s=nb,s; improved=True\\n        # Update best\\n        if cur_s<best_s: best_sol,best_s=cur,cur_s\\n        # Perturb\\n        cur=perturb_solution(cur)\\n        cur_s=evaluate_solution(cur)\\n        # Acceptance\\n        if not accept and cur_s>best_s:\\n            cur,cur_s=best_sol,best_s\\n    return best_sol, best_s\nCONCRETE_FIX_PERTURB:def perturb_solution(solution):\\n    import random\\n    parts=solution.strip().split(','); L=[int(p) for p in parts]\\n    n=len(L); k=max(L)\\n    # choose 1-2 vertices to reassign\\n    r=random.randint(1,2)\\n    idx=random.sample(range(n), r)\\n    for i in idx:\\n        # try existing labels first\\n        cand_labels=list(range(1,k+1))+[k+1]\\n        random.shuffle(cand_labels)\\n        for t in cand_labels:\\n            cand=L[:]; cand[i]=t\\n            # compress and quick feasibility check\\n            def compress(A):\\n                uniq=[]; seen=set()\\n                for x in A:\\n                    if x not in seen:\\n                        seen.add(x); uniq.append(x)\\n                mp={old:i+1 for i,old in enumerate(uniq)}\\n                return [mp[x] for x in A]\\n            C=compress(cand)\\n            # validate only affected groups\\n            def is_clique(mems):\\n                E={(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\\n                EU=set((min(u,v),max(u,v)) for (u,v) in E)\\n                def friends(u,v):\\n                    if u==v: return True\\n                    a,b=(u,v) if u<v else (v,u)\\n                    return (a,b) in EU\\n                g={}\\n                for j,lab in enumerate(C, start=1): g.setdefault(lab, []).append(j)\\n                for mem in g.values():\\n                    m=len(mem)\\n                    for a in range(m):\\n                        for b in range(a+1,m):\\n                            if not friends(mem[a],mem[b]):\\n                                return False\\n                return True\\n            if is_clique([i+1 for i,_ in enumerate(C)]):\\n                L=C; k=max(L); break\\n    return ','.join(str(x) for x in L)\nNB_IMPROVEMENT_SUGGESTION:Add 'evict-and-merge' and 'pairwise-group-local-search': for each pair of groups A,B, try moving each blocker v\u2208B\\A to a helper group or singleton to enable A\u222aB merge; evaluate delta k first.\nLB_GUIDANCE:Compute simple lower bounds (\u03c9(G) via clique in complement or fractional coloring via degree bound) to prune obviously non-improving neighborhoods.\nRANDOMIZATION_CONTROL:Add seed parameter in adapters to ensure reproducibility during evaluation runs.\nSCALABILITY_NOTE:For larger n, replace backtracking with MILP or CP-SAT model for minimality checks offline; keep cached outcomes online to avoid repeated exponential checks.\nTEST_COVERAGE:Unit-test: signature compliance, infeasible parsing, clique verification, complement-coloring penalty trigger, and neighbor feasibility for all move types. Ensure zero filesystem\/network usage.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","Componentes":{"REPRESENTATION":"INDEX_LIST.CSV9.PositiveIntLabels.Contiguous{1..k}","EVAL_CODE":"import math\nimport random\nfrom functools import lru_cache\n\ndef evaluate_solution(solution):\n    INF = 10**9\n    # Parse and basic validation\n    if not isinstance(solution, str):\n        return INF\n    s = solution.strip()\n    if s == \"\":\n        return INF\n    parts = s.split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return INF\n    if len(labels) != 9:\n        return INF\n    if any(x <= 0 for x in labels):\n        return INF\n    k = max(labels)\n    used = set(labels)\n    if used != set(range(1, k+1)):\n        return INF\n\n    # Graph definition (embedded)\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    # Clique feasibility\n    groups = {}\n    for i, g in enumerate(labels, start=1):\n        groups.setdefault(g, []).append(i)\n    for members in groups.values():\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return INF\n\n    # Complement graph adjacency\n    comp_adj = {u: set() for u in V}\n    for i in V:\n        for j in V:\n            if i < j and not friends(i, j):\n                comp_adj[i].add(j)\n                comp_adj[j].add(i)\n\n    # DSATUR-based backtracking to check colorability with K colors\n    order = tuple(sorted(V, key=lambda x: len(comp_adj[x]), reverse=True))\n\n    @lru_cache(maxsize=None)\n    def can_color(K: int) -> bool:\n        color = {v: 0 for v in V}\n        sat_deg = {v: 0 for v in V}\n        used_colors_by = {v: set() for v in V}\n\n        def select_vertex():\n            # choose uncolored vertex with max saturation degree; break ties by degree\n            candidates = [v for v in V if color[v] == 0]\n            if not candidates:\n                return None\n            return max(candidates, key=lambda v: (sat_deg[v], len(comp_adj[v])))\n\n        def assign(v, c):\n            color[v] = c\n            for u in comp_adj[v]:\n                if color[u] == 0 and c not in used_colors_by[u]:\n                    used_colors_by[u].add(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def unassign(v, c):\n            color[v] = 0\n            for u in comp_adj[v]:\n                if color[u] == 0 and c in used_colors_by[u]:\n                    used_colors_by[u].remove(c)\n                    sat_deg[u] = len(used_colors_by[u])\n\n        def dfs() -> bool:\n            v = select_vertex()\n            if v is None:\n                return True\n            forbidden = {color[u] for u in comp_adj[v] if color[u] != 0}\n            # try least constraining color first\n            for c in range(1, K+1):\n                if c not in forbidden:\n                    assign(v, c)\n                    if dfs():\n                        return True\n                    unassign(v, c)\n            return False\n\n        return dfs()\n\n    # Soft minimality check via complement coloring with k-1 colors\n    if k > 1 and can_color(k-1):\n        return k + 1000\n    return k\n","NB_CODE":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (neighbor_solution_csv, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"noop\"\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution, \"noop\"\n    if len(labels) != 9:\n        return solution, \"noop\"\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n    V = list(range(1, 10))\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def groups_of(L):\n        g = {}\n        for i, lab in enumerate(L, start=1):\n            g.setdefault(lab, []).append(i)\n        return g\n\n    def is_group_clique(members):\n        m = len(members)\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not friends(ui, vj):\n                    return False\n        return True\n\n    L0 = labels[:]\n    k = max(L0)\n    gmap = groups_of(L0)\n\n    # 1) Greedy MERGE that reduces k if feasible\n    labs = list(range(1, k+1))\n    for a in labs:\n        for b in labs:\n            if a >= b:\n                continue\n            A = gmap.get(a, [])\n            B = gmap.get(b, [])\n            if not A or not B:\n                continue\n            ok = True\n            for u in B:\n                for v in A:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cand = L0[:]\n                for idx, lab in enumerate(cand):\n                    if lab == b:\n                        cand[idx] = a\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"merge\"\n\n    # 2) MOVE: move a single vertex to another label while keeping feasibility\n    for i in range(9):\n        vi = i+1\n        cur = L0[i]\n        for t in range(1, k+1):\n            if t == cur:\n                continue\n            members = [idx+1 for idx, lab in enumerate(L0) if lab == t]\n            if all(friends(vi, u) for u in members):\n                cand = L0[:]\n                cand[i] = t\n                cand = compress(cand)\n                return ','.join(str(x) for x in cand), \"move\"\n\n    # 3) SWAP two vertices' labels if keeps feasibility\n    for i in range(9):\n        for j in range(i+1, 9):\n            if L0[i] == L0[j]:\n                continue\n            cand = L0[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            # validate feasibility quickly\n            g = groups_of(cand)\n            feasible = True\n            for mem in g.values():\n                if not is_group_clique(mem):\n                    feasible = False\n                    break\n            if feasible:\n                return ','.join(str(x) for x in cand), \"swap\"\n\n    # 4) Diversify: move a random vertex to a new label (then compress)\n    i = random.randrange(9)\n    cand = L0[:]\n    cand[i] = max(cand) + 1\n    cand = compress(cand)\n    return ','.join(str(x) for x in cand), \"diversify\"\n","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Stronger random shake preserving feasibility as much as possible\n    if not isinstance(solution, str):\n        return solution\n    parts = solution.strip().split(',')\n    try:\n        labels = [int(p) for p in parts]\n    except Exception:\n        return solution\n    if len(labels) != 9:\n        return solution\n\n    # Embedded graph\n    E = {(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)}\n    EU = set((min(u,v), max(u,v)) for (u,v) in E)\n\n    def friends(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in EU\n\n    def compress(L):\n        uniq = []\n        seen = set()\n        for x in L:\n            if x not in seen:\n                seen.add(x)\n                uniq.append(x)\n        mp = {old: i+1 for i, old in enumerate(uniq)}\n        return [mp[x] for x in L]\n\n    def feasible(L):\n        groups = {}\n        for i, g in enumerate(L, start=1):\n            groups.setdefault(g, []).append(i)\n        for members in groups.values():\n            m = len(members)\n            for i in range(m):\n                ui = members[i]\n                for j in range(i+1, m):\n                    vj = members[j]\n                    if not friends(ui, vj):\n                        return False\n        return True\n\n    L = labels[:]\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        k = max(L)\n        move_type = random.choice([\"move\",\"merge\",\"shuffle\"])  # randomization\n        if move_type == \"merge\" and k >= 2:\n            a, b = sorted(random.sample(range(1, k+1), 2))\n            members_a = [idx+1 for idx, lab in enumerate(L) if lab == a]\n            members_b = [idx+1 for idx, lab in enumerate(L) if lab == b]\n            ok = True\n            for u in members_b:\n                for v in members_a:\n                    if not friends(u, v):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                for idx, lab in enumerate(L):\n                    if lab == b:\n                        L[idx] = a\n                L = compress(L)\n                continue\n        elif move_type == \"move\":\n            i = random.randrange(9)\n            vi = i+1\n            targets = list(range(1, k+1))\n            if k < 9:\n                targets.append(k+1)\n            random.shuffle(targets)\n            for t in targets:\n                if t == L[i]:\n                    continue\n                members = [idx+1 for idx, lab in enumerate(L) if lab == t]\n                if all(friends(vi, u) for u in members):\n                    L[i] = t\n                    L = compress(L)\n                    break\n        else:  # shuffle\n            i, j = random.sample(range(9), 2)\n            cand = L[:]\n            cand[i], cand[j] = cand[j], cand[i]\n            cand = compress(cand)\n            if feasible(cand):\n                L = cand\n    if not feasible(L):\n        return ','.join(str(x) for x in labels)\n    return ','.join(str(x) for x in L)\n","SAMPLE_SOL":"2,2,1,3,4,3,4,1,1"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_SIG_CALLABLE_PASSING:Signatures use generate_neighbour() and evaluate_solution() with parentheses; pass callables, not results. Correct to generate_neighbour and evaluate_solution in all heuristic definitions and invocations.\nE_PERTURB_MISSING:Perturbation Function is '$Perturb' placeholder; define a concrete callable perturb_solution(solution) returning a valid CSV9 string.\nE_EVAL_INPUT_TYPE:generate_neighbour returns (csv,move_type). Ensure solvers pass only csv to evaluate_solution; unpack neighbor before evaluation to avoid type errors.\nE_SA_SIG:Expected SA signature mismatched. Use def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor): and ensure it returns (new_solution,new_score,new_best,best_score).\nE_ILS_SIG:Expected ILS signature mismatched. Use def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate): unpack neighbors correctly.\nE_TS_SIG:Expected TS signature mismatched. Use def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration): taboo list must store visited csv strings; compare on strings.\nFIX_SA_MIN_ACCEPT:Heuristic is minimization; acceptance condition must use delta = cand_score - curr_score. Accept if delta <= 0 or random() < exp(-delta\/T).\nFIX_TS_TABOO_KEY:Taboo list keyed by raw csv string; do not store tuples or objects. Evict by duration and size. Always allow aspiration if cand_score < best_score.\nNB_CODE_FAIL_LOCAL_OPT:Neighbor search is greedy-first and deterministic; it returns the first feasible move causing premature stagnation. Randomize iteration order or sample multiple candidates; keep best-improving among N trials per step.\nNB_MOVE_WEAK:MOVE step ignores whether moving reduces k or improves penalty. Add priority: try merges that reduce k, then moves that decrease group count or improve feasibility margin; evaluate delta and choose best.\nNB_SWAP_COSTLY:SWAP validates full feasibility per attempt; O(n^2) checks per pair. Precompute group conflicts and early abort on first violation to reduce overhead.\nNB_DIVERSIFY_RISK:Diversify always increases k by +1 before compress; this can inflate search space. Cap max k growth and bias diversify to split the largest non-clique group instead.\nR_STR_INADEQUATE:INDEX_LIST is fine but compression after every move can reshuffle labels and break short-term memory in Tabu. Introduce stable relabeling (only compress when k decreases) to preserve recency structures.\nEVAL_MINIMALITY_COST_SPIKE:Penalty k+1000 creates a large discontinuity that can mislead SA\/ILS temperature\/acceptance scales. Use adaptive penalty (k + P where P scales with number of conflicts in a (k-1)-coloring attempt or a fast LB) to smooth landscape.\nEVAL_COLORING_COST:DSATUR backtracking invoked per evaluation; worst-case exponential. Cache graph constants outside function; add quick infeasibility bounds: if max_degree(comp)+1 > k-1, skip DSATUR; if greedy-color(comp) > k-1, skip.\nEVAL_CACHE_WEAK:lru_cache keyed only by K; still recomputes state each call. Replace with iterative greedy lower bound and only call DSATUR when bounds are close; also memoize last (k-1) result to avoid repeated calls for same k across iterations.\nEVAL_VALIDATION_GAP:Feasibility checks all pairs per group each evaluation; O(n^2) per group. Maintain incremental feasibility diffs in solvers (when moving a single vertex, only recheck affected groups).\nILS_PERTURB_SCOPE:Current perturbation unspecified; use multi-vertex kicks targeting vertices in largest conflicting groups to escape local minima instead of random single split.\nTS_ASPIRATION_RULE:Missing explicit aspiration. Always override tabu if candidate improves best_score; otherwise enforce tabu to prevent cycling.\nINIT_SOLUTION_SENS:Sample solution evaluates feasible but solvers must handle infeasible\/invalid inputs robustly. Add repair-on-load: if labels not contiguous, compress; if any non-clique group, greedily split offending vertices into new groups then compress.\nRNG_CONTROL:random not seeded per run causing non-reproducibility in tests. Accept a seed parameter in other_params to seed random for deterministic regression tests.\nCODE_SNIPPET_SA_FIX:def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor): \n    import random, math\n    curr = solution; curr_score = evaluate_solution(curr)\n    if curr_score < best_score: best_sol, best_score = curr, curr_score\n    T = TEMP\n    while T > MIN_TEMP:\n        nb, _ = generate_neighbour(curr)\n        cand = nb\n        cand_score = evaluate_solution(cand)\n        delta = cand_score - curr_score\n        if delta <= 0 or random.random() < math.exp(-delta \/ T):\n            curr, curr_score = cand, cand_score\n            if curr_score < best_score:\n                best_sol, best_score = curr, curr_score\n        T *= cooling_factor\n    return curr, curr_score, best_sol, best_score\nCODE_SNIPPET_ILS_FIX:def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate):\n    import random\n    curr = solution; curr_score = evaluate_solution(curr)\n    if curr_score < best_score: best_sol, best_score = curr, curr_score\n    for _ in range(iterations):\n        nb, _ = generate_neighbour(curr)\n        cand = nb; cand_score = evaluate_solution(cand)\n        if cand_score <= curr_score or random.random() < acceptance_rate:\n            curr, curr_score = cand, cand_score\n            if curr_score < best_score:\n                best_sol, best_score = curr, curr_score\n        # perturb\n        p = perturb_solution(curr)\n        p_score = evaluate_solution(p)\n        if p_score < curr_score:\n            curr, curr_score = p, p_score\n    return curr, curr_score, best_sol, best_score\nCODE_SNIPPET_TS_FIX:def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,taboo_list_size,taboo_duration):\n    from collections import deque\n    curr = solution; curr_score = evaluate_solution(curr)\n    if curr_score < best_score: best_sol, best_score = curr, curr_score\n    taboo = {}  # csv -> remaining_duration\n    order = deque()\n    for _ in range(iterations):\n        best_nb = None; best_nb_score = float('inf'); best_move = None\n        # sample multiple neighbors to avoid first-improvement bias\n        for _s in range(20):\n            nb, mv = generate_neighbour(curr)\n            cand = nb; cand_score = evaluate_solution(cand)\n            if cand in taboo and cand_score >= best_score:\n                continue\n            if cand_score < best_nb_score:\n                best_nb, best_nb_score, best_move = cand, cand_score, mv\n        if best_nb is None:\n            # decay tabu and continue\n            for k in list(taboo.keys()):\n                taboo[k] -= 1\n                if taboo[k] <= 0:\n                    del taboo[k]\n            continue\n        curr, curr_score = best_nb, best_nb_score\n        if curr_score < best_score:\n            best_sol, best_score = curr, curr_score\n        taboo[curr] = taboo_duration\n        order.append(curr)\n        if len(taboo) > taboo_list_size:\n            oldest = order.popleft()\n            if oldest in taboo:\n                del taboo[oldest]\n        for k in list(taboo.keys()):\n            taboo[k] -= 1\n            if taboo[k] <= 0:\n                del taboo[k]\n    return curr, curr_score, best_sol, best_score\nCODE_SNIPPET_PERTURB:def perturb_solution(solution):\n    import random\n    parts = [int(p) for p in solution.strip().split(',')]\n    n = len(parts)\n    # split the largest group\n    from collections import Counter\n    cnt = Counter(parts)\n    largest_label = max(cnt, key=lambda x: cnt[x])\n    idxs = [i for i,p in enumerate(parts) if p == largest_label]\n    if len(idxs) >= 2:\n        move_count = max(1, len(idxs)\/\/2)\n        for i in random.sample(idxs, move_count):\n            parts[i] = max(parts) + 1\n    # compress to keep labels contiguous\n    uniq = []\n    seen = set()\n    for x in parts:\n        if x not in seen:\n            seen.add(x); uniq.append(x)\n    mp = {old:i+1 for i,old in enumerate(uniq)}\n    parts = [mp[x] for x in parts]\n    return ','.join(map(str, parts))\nNB_RANDOMIZATION:Shuffle iteration orders in MERGE\/MOVE\/SWAP loops and consider top-M candidates by delta to reduce bias and cycling.\nEVAL_SELFTEST:Cross-validated evaluate_solution against a reference solution locally; outputs consistent. Retain this as a unit test to catch regressions.\nSCALING_HINT:Set TEMP, cooling_factor so that typical exp(-delta\/T) covers penalty step sizes introduced by minimality check; calibrate using empirical median |delta| from 100 neighbor samples.\nRUNTIME_CTRL:Bound DSATUR recursion by early cutoffs when partial color count exceeds K; already implicit but add counter to abort after N backtracks and fall back to greedy lower bound.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; each solution is a string of 9 positive integers separated by commas, e.g., \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive ints; objective is to minimize max label. Functions accept either this CSV string or a Python list of 9 ints; they always return the CSV string form when producing solutions.","Componentes":{"REPRESENTATION":"CSV_INT_LIST_LEN9; each solution is a string of 9 positive integers separated by commas, e.g., \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive ints; objective is to minimize max label. Functions accept either this CSV string or a Python list of 9 ints; they always return the CSV string form when producing solutions.","EVAL_CODE":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    # Map labels to 1..m by order of first appearance to keep canonical\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None:\n        return 10**9\n    if len(arr) != n:\n        return 10**9\n    # Validate entries\n    k = -1\n    for x in arr:\n        if not isinstance(x, int):\n            return 10**9\n        if x <= 0:\n            return 10**9\n        if x > k:\n            k = x\n    if k < 1:\n        return 10**9\n    # Build complement edge set (non-edges in original graph among distinct pairs)\n    comp: Set[Tuple[int,int]] = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations (equal labels on complement pairs)\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","NB_CODE":"import random\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        # fallback to a random valid-shaped solution\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    move = None\n    r = random.random()\n    if r < 0.5:\n        # Relabel a single vertex to an existing or new label\n        idx = random.randrange(n)\n        # choose from 1..k+1 with small prob to explore new label\n        if random.random() < 0.2:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _compress_labels(arr2)\n        move = 'RelabelSingle'\n        nb_type = 'Local'\n        return (_encode_csv(arr2), nb_type, move)\n    else:\n        # Swap two labels present in the solution\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _compress_labels(arr2)\n            move = 'SwapLabels'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n        else:\n            # Fallback to relabel if only one label present\n            idx = random.randrange(n)\n            new_label = 1\n            arr2 = arr[:]\n            arr2[idx] = new_label\n            arr2 = _compress_labels(arr2)\n            move = 'RelabelSingle'\n            nb_type = 'Local'\n            return (_encode_csv(arr2), nb_type, move)\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Apply a moderate random shake: multiple random relabels and an optional label merge\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel 3 positions\n    m = 3\n    for _ in range(m):\n        idx = random.randrange(n)\n        # pick label from 1..max(1,k+1) to allow exploration\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With some probability, try to merge highest label into a lower label (without feasibility check here)\n    if random.random() < 0.5 and max(arr2) > 1:\n        labels = sorted(set(arr2))\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1]) if len(labels) > 1 else hi\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _compress_labels(arr2)\n    return _encode_csv(arr2)\n","SAMPLE_SOL":"1,1,3,4,3,4,2,3,2"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.3\"\n\n\"FIX_LOCAL_SOLVER_ERR_1\",\"SA\/ILS\/TS signatures misuse callables: parameters shown as generate_neighbour(), evaluate_solution(), perturb_solution() imply invocation at definition\/use time. Pass callables, not calls. Rename to match TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\"\n\n\"FIX_LOCAL_SOLVER_ERR_2\",\"Typing misuse: error 'Type List cannot be instantiated; use list() instead' indicates constructs like List() (or Set(), Tuple()) are being instantiated. Replace all typing.List\/Set\/Tuple constructions with concrete built-ins: list(), set(), tuple(). Remove from typing in any runtime instantiation.\"\n\n\"FIX_LOCAL_SOLVER_ERR_3\",\"Absent perturbation: $Perturb placeholder is undefined. Provide a concrete perturb_solution callable with the required signature; ensure it returns a CSV solution string per Representation.\"\n\n\"FIX_LOCAL_SOLVER_ERR_4\",\"Parameter name\/typo errors: 'aceptance_rate' misspelled; standardize to 'acceptance_rate'. 'taboo_*' inconsistent; standardize to 'tabu_list_size' and 'tabu_tenure' (or 'tabu_duration') and use consistently across call sites.\"\n\n\"FIX_LOCAL_SOLVER_ERR_5\",\"Return types: Ensure all heuristic functions return (best_solution_csv, best_score, meta_info). Current failures likely arise before any return; add defensive validation of inputs and callable types at entry.\"\n\n\"EVAL_ASSERT_CORRECTNESS\",\"evaluate_solution validated against a known feasible solution: PASS. Do not change evaluation semantics.\"\n\n\"E_EVAL_FUNC_PERF\",\"O(n^2) per call via full complement scan and pairwise checks. For scalability, implement incremental delta-evaluation: maintain per-label conflicts and update only affected vertices on local moves to reduce to O(degree) per move.\"\n\n\"E_EVAL_FUNC_ROBUSTNESS\",\"No canonicalization in evaluator. If solvers introduce unused labels, k inflates unnecessarily. Enforce canonical compression immediately after each move in solvers before evaluation.\"\n\n\"E_NEIGH_OPER_LIMIT\",\"RelabelSingle may introduce k+1 indiscriminately, inflating label space and slowing convergence. Gate new-label creation behind detected infeasibility on current label set or a cooling-based probability that decays; otherwise restrict to labels in 1..k.\"\n\n\"E_NEIGH_OPER_SCOPE\",\"SwapLabels limited to global label swap; lacks structure-aware moves. Add Kempe-chain interchanges and conflict-directed recoloring (pick a conflicting vertex, try best color by minimal added conflicts) to escape local minima more efficiently.\"\n\n\"E_PERTURB_WEAK\",\"Missing multi-vertex structured perturbation. Implement a k-shake: select r vertices from the most frequent\/conflicted color classes and reassign using greedy least-conflict color; random r in [2,4] recommended.\"\n\n\"E_SA_DESIGN\",\"Cooling schedule unspecified. Use geometric cooling with adaptive restarts: T <- T*alpha, alpha in [0.90,0.99]; reheating when no improvement in X iterations. Acceptance should use delta = new-old; accept if delta<0 or rand<exp(-delta\/T). Ensure delta computed from true scores (lower is better).\"\n\n\"E_TS_DESIGN\",\"Tabu tenure not adaptive and move attributes unspecified. Tabu list should store move attributes (vertex index, old_label->new_label). Use dynamic tenure: tenure = base + beta*conflict_count. Include aspiration by best: allow tabu if it improves global best.\"\n\n\"E_ILS_CRITERIA\",\"Acceptance rule absent\/unclear. Use better-or-equal acceptance; optionally incorporate late acceptance or threshold acceptance to diversify. Limit perturbation strength to avoid losing high-quality structure.\"\n\n\"E_REP_IO\",\"All solvers must accept both CSV string and list[int], but always emit CSV strings. Enforce _compress_labels after every move and before returning. Validate length==9 and all labels>0; otherwise repair.\"\n\n\"E_RANDOMNESS_SEED\",\"For reproducibility and debugging, allow an optional RNG seed parameter passed via other_params, and thread it to all stochastic components. Do not use global random state without control.\"\n\n\"E_METRICS_LOGGING\",\"Meta info should include iteration of best, number of evaluations, acceptance rate (SA\/ILS), and tabu hits (TS). This is required for diagnosing stagnation.\"\n\n\"E_STOPPING\",\"Define clear stopping criteria: max iterations, max evaluations, or time budget. Report premature terminations (e.g., due to invalid inputs) explicitly in meta.\"\n\n\"E_ERROR_HANDLING\",\"Add try\/except around neighbour and perturb calls; on exception, count as failed move and continue. Never instantiate typing objects in handlers. Return last valid state.\"\n\n\"E_COMPAT_SIGNATURE\",\"Normalize all heuristic function signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE. Wrap SA\/ILS\/TS with thin adapters that map their internal params from other_params, e.g., other_params={'TEMP':..., 'MIN_TEMP':..., 'cooling_factor':...}.\"\n\n\"E_TESTS_MINIMAL\",\"Unit-test with: (a) valid feasible input; (b) invalid length; (c) non-positive labels; (d) string CSV with spaces; (e) neighbor returning list vs string; (f) perturb returning invalid; assert evaluator penalties and graceful recovery.\"\n\n\"SUGG_MOVE_SELECTION\",\"Conflict-driven selection: prioritize vertices in conflicts (w.r.t. complement graph) instead of uniform random. Evaluate candidate colors by minimal added conflicts; tie-break by reducing k when feasible.\"\n\n\"SUGG_COLOR_REDUCTION\",\"When feasible at k, attempt color class elimination: pick smallest class, try to reassign all its vertices to other colors via greedy\/conflict-minimization; if success, decrement k.\"\n\n\"SUGG_LOCAL_BEST_FIRST\",\"Use first-improvement hill climbing within SA\/TS neighborhoods to cut evaluations: scan colors until improvement then apply; avoids exhaustive evaluation each step.\"\n\n\"SUGG_SCALING\",\"Precompute complement adjacency lists once and reuse across moves. Avoid reconstructing sets in inner loops. Cache in other_params for all heuristics.\"\n\n\"FINAL_ACTION_ITEMS\",\"1) Replace all List()\/Set()\/Tuple() with list()\/set()\/tuple(); 2) Implement perturb_solution callable; 3) Unify function signatures to TARGET_HEURISTIC_GENERAL_SIGNATURE and remove parentheses on callable params; 4) Enforce label compression post-move; 5) Add conflict-guided neighborhood (Kempe chain, greedy recolor); 6) Add adaptive SA cooling, TS tenure\/aspiration; 7) Add robust error handling and meta logging; 8) Validate with unit tests before rerun.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a string of 9 positive integers separated by commas (or a Python list[int] of length 9 accepted as input but always emitted as CSV string). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive integers; objective minimizes max label under feasibility on complement graph.","Componentes":{"REPRESENTATION":"CSV_INT_LIST_LEN9; solution is a string of 9 positive integers separated by commas (or a Python list[int] of length 9 accepted as input but always emitted as CSV string). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positive integers; objective minimizes max label under feasibility on complement graph.","EVAL_CODE":"import math\nfrom typing import List, Tuple, Set\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","NB_CODE":"import random\nfrom typing import List\n\ndef _nb_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _nb_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _nb_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    r = random.random()\n    if r < 0.5:\n        # Conflict-directed single relabel if possible, else random relabel\n        idx = random.randrange(n)\n        # Prefer existing labels; small chance to explore new label\n        if random.random() < 0.15:\n            new_label = k + 1\n        else:\n            new_label = random.randint(1, max(1, k))\n        arr2 = arr[:]\n        arr2[idx] = new_label\n        arr2 = _nb_compress_labels(arr2)\n        return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n    else:\n        # Swap two existing labels if at least two exist; else fallback relabel\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'SwapLabels')\n        else:\n            idx = random.randrange(n)\n            arr2 = arr[:]\n            arr2[idx] = 1\n            arr2 = _nb_compress_labels(arr2)\n            return (_nb_encode_csv(arr2), 'Local', 'RelabelSingle')\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _pt_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        return solution[:]\n    return None\n\ndef _pt_compress_labels(arr: List[int]) -> List[int]:\n    mapping = {}\n    nxt = 1\n    out = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = nxt\n            nxt += 1\n        out.append(mapping[x])\n    return out\n\ndef _pt_encode_csv(arr: List[int]) -> str:\n    return ','.join(str(x) for x in arr)\n\ndef perturb_solution(solution):\n    # Moderate shake: multiple relabels + optional label merge\n    arr = _pt_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1]*9\n    n = 9\n    k = max(arr)\n    arr2 = arr[:]\n    # Randomly relabel r positions\n    r = random.randint(2, 4)\n    idxs = random.sample(range(n), r)\n    for idx in idxs:\n        new_label = random.randint(1, max(1, k+1))\n        arr2[idx] = new_label\n    # With probability, merge highest label into a random lower label\n    labels = sorted(set(arr2))\n    if len(labels) > 1 and random.random() < 0.5:\n        hi = labels[-1]\n        tgt = random.choice(labels[:-1])\n        arr2 = [tgt if x==hi else x for x in arr2]\n    arr2 = _pt_compress_labels(arr2)\n    return _pt_encode_csv(arr2)\n","SAMPLE_SOL":"1,1,3,4,3,4,2,3,2"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"1.0.0\",\n\"FEEDBACK\":\"E_RUNTIME_SIG:Heuristic signatures call functions in parameters (e.g., generate_neighbour(), evaluate_solution()). Fix to accept callables without invoking them. Use TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_TYPING_INSTANT:Type List cannot be instantiated; use list() or [] instead. Remove any List() usage and any typing-based runtime instantiation.\nE_PERTURB_UNDEFINED:Perturbation Function is '$Perturb' (undefined). Provide a concrete perturb_solution(currentSolution, other_params) that returns a valid CSV solution string.\nE_IO_FORMAT:Heuristic must always emit CSV_INT_LIST_LEN9 string. Current code accepts list but may emit list; enforce encoding via ','.join and length checks.\nE_FEASIBILITY_PENALTY:Ensure evaluation is called from heuristic for feasibility; do not attempt custom penalty. Use provided evaluate_solution as single source of truth.\nE_ACCEPTANCE_MIN:Scoring is minimization. Ensure acceptance criteria and 'best' tracking assume lower is better. Remove any maximization logic or negative-score conventions.\nE_TABU_API:Taboo_Search signature mismatched. Conform to general signature; manage tabu list internally via state in other_params, not as formal parameters.\nE_SA_API:Simulated_Annealing signature mismatched. Conform to general signature; parse TEMP, MIN_TEMP, cooling_factor from other_params dict.\nE_ILS_API:Iterated_Local_Search signature mismatched. Conform to general signature; parse iterations, acceptance_rate from other_params dict. Call perturb_solution callable passed in.\nE_STATE_INIT:Guard currentSolution parsing. If invalid, initialize with a feasible 4-color seed or compressed variant of sample, not all-ones which is highly infeasible.\nE_LABEL_COMPRESS:Neighbour compresses labels each move. This can cause unstable basins and hampers annealing\/tabu memory. Restrict compression to a normalization step when improving k only; otherwise preserve label IDs to maintain search continuity.\nE_NB_OP_SCOPE:Neighbour moves limited to single relabel and label-swap. This is weak for graph coloring. Add Kempe-chain interchange and conflict-vertex focused relabel for stronger local search.\nE_NB_BIAS:Relabel picks random vertex regardless of conflicts. Bias selection to conflicted vertices in complement graph; sample from vertices with highest conflict degree under current labeling.\nE_NEW_LABEL_SPARSITY:15% chance to introduce k+1 increases search space unnecessarily. Decrease when feasible (no violations) to focus on reducing k; increase only under infeasibility pressure or stagnation.\nE_TABU_MEMORY:Tabu tenure not specified. Use fixed-size FIFO with tenure ~7\u201310 moves on (vertex,label) assignments; aspiration if move improves best_score.\nE_SA_SCHEDULE:Cooling factor unspecified. Use geometric cooling: T <- alpha*T with alpha in [0.90,0.99], stop at MIN_TEMP with stall cap; scale acceptance by delta=score_new-score_old.\nE_ILS_PERTURB:ILS perturbation undefined. Implement multi-vertex shake: change 2\u20133 conflicted vertices to random existing labels; optionally a single label swap on two labels with many conflicts.\nE_MOVE_EVAL:O(n^2) full re-evaluation per move is wasteful. Maintain current k and violations; compute delta cost incrementally per edited vertex using precomputed complement adjacency.\nE_STOPPING:Iterations\/stop criteria missing. Add max_steps, no_improve_limit; record best_score and best solution strictly by evaluate_solution.\nE_RANDOM_SEED:For reproducibility in tests, accept optional seed in other_params; use random.Random instance passed down, avoid global state.\nE_VALIDATION:Always validate and, if feasible with k>1, attempt greedy recolor to reduce k before returning; compress labels after successful k reduction only.\nE_OUTPUT_EXTRA:Local solver expects extra diagnostics; return alongside solution logs via structured prints but ensure final returned object is the CSV string only.\nE_TEST_KNOWN_SOL:Evaluation check: known solution score equals expected. Verified evaluate_solution('1,1,3,4,3,4,2,3,2')==4. Use as unit test to assert evaluator wiring.\nR_SIG_FIX_EXAMPLE:Refactor to wrapper Heuristic that dispatches by other_params['mode'] in a single signature; remove heuristic-specific mismatched signatures.\nR_NEIGHBOR_SET:Add operators: (1) KempeChainSwap(u,colorA,colorB), (2) RecolorConflictVertex(u) to min-conflict color in [1..k+1], (3) SwapTwoVerticesLabels(u,v) when both same color in complement, (4) MergeColorsAttempt(a,b) if no conflicts when unifying.\nR_CONFLICT_GRAPH:Precompute complement adjacency list and per-color conflict counts; choose moves that reduce conflicts first, then reduce k.\nR_TENURE_TUNING:Set tabu_duration adaptively to 5+randint(0,5) and reset on aspiration; store last assignments for vertices to prevent immediate reversal.\nR_SA_PARAMS:Initialize T from observed standard deviation of recent deltas; MIN_TEMP based on minimal non-zero delta; use reheating on stagnation.\nR_ILS_ACCEPT:Use acceptance_rate on non-improving local minima escapes; otherwise only accept strictly better solutions; always deep-copy best.\nR_COMPRESS_POLICY:Implement compress_labels(arr) only when feasibility holds and after decreasing k; otherwise keep label ids stable across steps.\nR_PERF_DELTA:Cache current violations and color class memberships; updating a single vertex is O(deg) in complement graph, not O(n^2).\nR_ENCODING_STRICT:Provide helper encode_csv(arr)->str; ensure length==9 and all ints>0 before emission; reject otherwise.\nR_STAGNATION:If feasible with current k, run focused color-class elimination: pick color with smallest class, try to recolor its vertices greedily to remove the class and reduce k by 1.\nR_TESTS:Unit tests: (1) parsing robustness, (2) neighbour invariants, (3) evaluator returns 1e9+violations for infeasible, (4) best tracking monotonic, (5) tabu prohibits immediate reversal, (6) SA acceptance probability correct.\nR_METRICS:Track move acceptance ratio, conflicts over time, k over time; adjust operator probabilities via softmax on recent improvements.\nR_NO_FILES_OS:Ensure no code path accesses filesystem\/network\/OS per MAIN_CRITICAL_INSTRUCTION; keep all state in memory and deterministic inputs only.\nR_API_USE:Never instantiate typing.List\/Set\/Dict; use built-ins list\/dict\/set; annotate types if desired but avoid runtime use.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","Componentes":{"REPRESENTATION":"CSV_INT_LIST_LEN9; solution is a CSV string of 9 positive integers (or a Python list[int] of length 9 accepted as input but always emitted as CSV). Example: \"1,1,3,4,3,4,2,3,2\". Labels are arbitrary positives; objective minimizes max label under feasibility on the complement graph.","EVAL_CODE":"import math\nfrom typing import List, Tuple, Set\n\ndef _eval_parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            arr = [int(x) for x in solution]\n        except Exception:\n            return None\n        return arr\n    return None\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: fewer is better; large penalty if infeasible.\n    n = 9\n    # Undirected edges of G (given)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # normalize undirected edges\n    E = set()\n    for a,b in edges:\n        if a==b:\n            continue\n        if a>b:\n            a,b = b,a\n        E.add((a,b))\n    arr = _eval_parse_solution_csv_or_list(solution)\n    if arr is None or len(arr) != n:\n        return float(10**9)\n    # Validate entries and find k\n    k = -1\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return float(10**9)\n        if x > k:\n            k = x\n    if k < 1:\n        return float(10**9)\n    # Build complement edges\n    comp = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i,j) not in E:\n                comp.add((i,j))\n    # Count violations: equal labels on complement pairs\n    violations = 0\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in range(i+1, n+1):\n            if arr[j-1] == ci and (i,j) in comp:\n                violations += 1\n    if violations > 0:\n        return float(10**9 + violations)\n    # Feasible: minimize max label\n    return float(k)\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef _nb_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _nb_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _nb_comp_adjacency():\n    # complement adjacency list for nodes 1..9\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _nb_conflict_vertices(arr, comp_adj):\n    # returns list of vertices (1-indexed) with at least one conflict in complement graph\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef _nb_color_conflicts(u, color, arr, comp_adj):\n    # number of conflicts at vertex u if assigned 'color'\n    cnt = 0\n    for v in comp_adj[u]:\n        if arr[v-1] == color:\n            cnt += 1\n    return cnt\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    arr = _nb_parse(solution)\n    if arr is None or len(arr) != 9:\n        # initialize with a reasonable seed close to known optimal pattern\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    comp_adj = _nb_comp_adjacency()\n    k = max(arr)\n    conflicted = _nb_conflict_vertices(arr, comp_adj)\n    rng = random.random()\n    if conflicted:\n        # Conflict-directed recolor (min-conflicts)\n        u = random.choice(conflicted)\n        # Candidate colors: 1..k plus with small probability k+1 when conflicts persist\n        cand = list(range(1, k+1))\n        if rng < 0.1:\n            cand.append(k+1)\n        best_colors = []\n        best_val = None\n        for c in cand:\n            val = _nb_color_conflicts(u, c, arr, comp_adj)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        new_c = random.choice(best_colors)\n        arr2 = arr[:]\n        arr2[u-1] = new_c\n        return (_nb_encode(arr2), 'Local', 'MinConflictsRelabel')\n    else:\n        # Feasible: try to reduce k by moving a vertex of the highest label to a lower feasible label\n        highest = k\n        idxs = [i for i,x in enumerate(arr, start=1) if x == highest]\n        random.shuffle(idxs)\n        moved = False\n        for u in idxs:\n            lower_colors = list(range(1, highest))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if _nb_color_conflicts(u, c, arr, comp_adj) == 0:\n                    arr2 = arr[:]\n                    arr2[u-1] = c\n                    # do not compress labels here; maintain continuity\n                    return (_nb_encode(arr2), 'Local', 'FeasibleReduceK')\n        # If no direct reduction possible, perform a label swap between two labels to reshape landscape\n        labels = sorted(set(arr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            arr2 = [b if x==a else a if x==b else x for x in arr]\n            return (_nb_encode(arr2), 'Local', 'SwapLabels')\n        # Fallback: random single relabel to any existing color\n        u = random.randint(1, n)\n        c = random.randint(1, k)\n        arr2 = arr[:]\n        arr2[u-1] = c\n        return (_nb_encode(arr2), 'Local', 'FallbackRelabel')\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef _pt_parse(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n        try:\n            arr = [int(p) for p in parts]\n        except Exception:\n            return None\n        return arr\n    if isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _pt_encode(arr):\n    if not isinstance(arr, list) or len(arr) != 9:\n        return '1,1,1,1,1,1,1,1,1'\n    for x in arr:\n        if not isinstance(x, int) or x <= 0:\n            return '1,1,1,1,1,1,1,1,1'\n    return ','.join(str(x) for x in arr)\n\ndef _pt_comp_adjacency():\n    n = 9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        if a!=b:\n            E.add((a,b))\n    comp_adj = {i: set() for i in range(1, n+1)}\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i==j:\n                continue\n            a,b = (i,j) if i<j else (j,i)\n            if (a,b) not in E:\n                comp_adj[i].add(j)\n    return comp_adj\n\ndef _pt_conflict_vertices(arr, comp_adj):\n    n = len(arr)\n    conf = []\n    for i in range(1, n+1):\n        ci = arr[i-1]\n        for j in comp_adj[i]:\n            if arr[j-1] == ci:\n                conf.append(i)\n                break\n    return conf\n\ndef perturb_solution(solution):\n    # Moderate shake focusing on conflicted vertices; preserves encoding\n    arr = _pt_parse(solution)\n    if arr is None or len(arr) != 9:\n        arr = [1,1,3,4,3,4,2,3,2]\n    n = 9\n    k = max(arr)\n    comp_adj = _pt_comp_adjacency()\n    conf = _pt_conflict_vertices(arr, comp_adj)\n    arr2 = arr[:]\n    # Relabel 2-4 vertices (prefer conflicted ones)\n    r = random.randint(2, 4)\n    pool = conf[:] if conf else list(range(1, n+1))\n    idxs = []\n    if len(pool) >= r:\n        idxs = random.sample(pool, r)\n    else:\n        idxs = pool + random.sample([i for i in range(1, n+1) if i not in pool], r - len(pool))\n    for u in idxs:\n        # Choose random existing color; with small prob introduce k+1\n        if random.random() < 0.15:\n            new_c = k + 1\n        else:\n            new_c = random.randint(1, max(1, k))\n        arr2[u-1] = new_c\n    # Optional label swap to diversify\n    labels = sorted(set(arr2))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        arr2 = [b if x==a else a if x==b else x for x in arr2]\n    return _pt_encode(arr2)\n","SAMPLE_SOL":"1,1,3,4,3,4,2,3,2"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"2025-11-21.a\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:SA\/ILS\/TS signatures violate TARGET_HEURISTIC_GENERAL_SIGNATURE; remove parentheses on callable params and match: Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params).\nE_LOCAL_SOLVER_TYPE_HINT_INSTANTIATION:Error 'Type List cannot be instantiated; use list() instead.' indicates misuse of typing.List() as a constructor. Replace all List() with [] and use list() only for conversion, keep typing.List solely for annotations.\nE_LOCAL_SOLVER_CALLABLE_USE:Do not call generate_neighbour() or evaluate_solution() in the signature; accept callables and invoke inside the loop. Passing called results breaks polymorphism and caused runtime errors.\nE_PERTURB_MISSING:Perturbation Function is '$Perturb' placeholder; implement a concrete perturbation callable and pass it to Heuristic. Suggested: multi-vertex Kempe-chain swaps or batch recolor of the highest label class with min-conflicts.\nE_OUTPUT_FORMAT:Heuristics must emit CSV string for best solution; do not return Python list. Enforce via encode step before returning.\nE_RETURN_CONTRACT:Standardize return to (best_csv, best_score, extra_outputs). Include fields: iterations, accepted_moves, k_trajectory, violations_trajectory, last_NB_Type, last_Movement_Type.\nE_RANDOM_SOURCE:Unseeded global RNG in neighbour\/evaluators causes nondeterminism. Accept rng in other_params and thread it through generate_neighbour\/perturb to ensure reproducibility.\nE_SA_PARAMS:Validate SA params: TEMP>0, MIN_TEMP>0, MIN_TEMP<TEMP, 0<cooling_factor<1. Add guards and clamp to safe ranges; abort if no improvement over X iterations.\nE_SA_ACCEPT:Use standard Metropolis: accept if d<=0 or exp(-d\/T)>U. Compute d via evaluate_solution(nei)-evaluate_solution(cur) once; avoid duplicated evaluations.\nE_TS_TABU_TENURE:Implement tabu tenure on move attributes (vertex,color) not full solutions; use dict[int->int] expiration counters instead of a 'List()'. Add aspiration: allow tabu if candidate improves best_score.\nE_TS_NEIGHBOR_FILTER:When generating neighbors, filter out tabu moves unless aspiration applies; cap neighborhood size to avoid O(n*k) blow-up each step.\nE_ILS_ACCEPTANCE:Implement acceptance criterion consistent with minimization: accept new if score<=incumbent or with probability p under a temperature-like parameter; do not accept worse solutions unconditionally.\nE_EVAL_SCALING:Penalty 1e9+violations is valid but too coarse for SA\/TS; consider dynamic penalty P that decreases with current best feasibility to guide search. Example: score = k + alpha*violations with alpha annealed.\nE_EVAL_CALLS:Current loops likely re-evaluate same states; cache evaluate_solution for last (arr) using tuple key to reduce recomputation in SA\/TS\/ILS.\nE_NEIGHBOR_FAILSAFE:_nb_encode returns '1,1,1,1,1,1,1,1,1' on invalid arr, injecting maximal-penalty states silently. Replace with no-op return and flag in Movement_Type to avoid destabilizing the search.\nE_NEIGHBOR_LABEL_MANAGEMENT:FeasibleReduceK attempts single-vertex reduction only; add greedy merge of highest label class: try reassigning all vertices with label k to lower colors with min-conflicts before attempting label swap.\nE_NEIGHBOR_KEMPE:Add Kempe-chain interchanges on the complement graph to escape local minima more effectively than raw label swaps.\nE_LABEL_COMPRESSION:After a successful recolor that removes a label class, compress labels to 1..k\u2019 to keep k minimal and stabilize evaluation.\nE_MOVE_ACCOUNTING:Capture NB_Type and Movement_Type returned by generate_neighbour and propagate to extra_outputs for diagnostics; currently ignored by solvers.\nE_PERF_ORDER:For each step keep O(1) delta where possible: precompute comp adjacency once; compute delta conflicts on changed vertex only; avoid rebuilding sets.\nE_INIT_POLICY:Do not hardcode initial solution inside neighbor; pass initial currentSolution externally. Provide construction heuristic (e.g., DSATUR on complement) when input is invalid.\nE_VALIDATION:Before main loop, parse solution via evaluator\u2019s parser and assert length==9 and all labels>0; otherwise reinitialize via construction heuristic and log reason in extra_outputs.\nE_STOPPING:Define clear stopping: max_iterations, max_no_improve, time budget; currently unspecified leading to potential infinite loops.\nE_CORRECTNESS_ASSERT:Validation with evaluate_solution on provided reference instance returns feasible objective as expected. Ensure all solvers assert evaluate_solution(best_csv)==best_score at return time to prevent drift.\nR_FIX_ORDER:Apply fixes in order: (1) signatures and List() misuse; (2) implement perturb callable; (3) enforce return\/emit CSV; (4) integrate RNG via other_params; (5) add aspiration\/tenure in TS; (6) add SA acceptance and cooling guards; (7) integrate neighbor enhancements; (8) add caching and delta eval.\nTEST_PLAN:Unit-test SA\/ILS\/TS with a stub neighbour returning known-improving moves; assert no 'Type List' errors. Then integrate real neighbour and verify best_score monotone nonincreasing on feasible states and trajectories recorded.\nE_COMPATIBILITY:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS\u2014verify all proposed changes avoid any filesystem\/network\/OS calls.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a list of 9 positive integers [x1,...,x9], where xi is the party label of vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better. SA target (to be used by user): def SA(currentSolution,best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor).","Componentes":{"REPRESENTATION":"R_STR: PARTY_LIST. A solution is a list of 9 positive integers [x1,...,x9], where xi is the party label of vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better. SA target (to be used by user): def SA(currentSolution,best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor).","EVAL_CODE":"import math\nfrom typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    # Validate domain\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    undirected: Set[Tuple[int,int]] = set()\n    for a,b in edges:\n        undirected.add((a,b))\n        undirected.add((b,a))\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j]:\n                if (i+1, j+1) not in undirected:\n                    conflicts += 1\n    distinct_parties = len(set(solution))\n    # Big-M penalty ensures feasibility preferred before minimizing parties\n    return conflicts * 1_000_000 + distinct_parties\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        # Relabel parties to 1..m in order of first appearance\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    move = random.choice([\"Reassign\", \"SwapLabels\", \"MergeLabels\"])  # movement types\n\n    if move == \"Reassign\":\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # choose either existing label or a potential new label up to max_label+1\n        candidates = list(used) + [max_label + 1]\n        new_label = random.choice(candidates)\n        curr[i] = new_label\n        nb_type = \"Local\"\n        mv_type = \"Reassign\"\n    elif move == \"SwapLabels\":\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            curr = [b if x == a else a if x == b else x for x in curr]\n            nb_type = \"Local\"\n            mv_type = \"SwapLabels\"\n        else:\n            # fallback to reassignment\n            i = random.randrange(n)\n            curr[i] = curr[i]\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n    else:  # MergeLabels\n        labels = list(set(curr))\n        if len(labels) >= 2:\n            a, b = random.sample(labels, 2)\n            # Merge label b into a\n            curr = [a if x == b else x for x in curr]\n            nb_type = \"PerturbLocal\"\n            mv_type = \"MergeLabels\"\n        else:\n            nb_type = \"Fallback\"\n            mv_type = \"NoOp\"\n\n    curr = canonicalize(curr)\n    return curr, nb_type, mv_type\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake: multiple random reassignments and a random relabel shuffle\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        i = random.randrange(n)\n        used = set(curr)\n        max_label = max(used) if used else 0\n        # allow creating a new label with small probability\n        if random.random() < 0.4:\n            new_label = max_label + 1\n        else:\n            new_label = random.choice(list(used))\n        curr[i] = new_label\n        curr = canonicalize(curr)\n\n    # Random relabel permutation to escape label-symmetry traps\n    labels = list(set(curr))\n    perm = labels[:]\n    random.shuffle(perm)\n    mapping = {labels[i]: perm[i] for i in range(len(labels))}\n    curr = [mapping[x] for x in curr]\n    curr = canonicalize(curr)\n    return curr\n","SAMPLE_SOL":"[1, 1, 1, 2, 3, 2, 3, 4, 4]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_TYPEHINT:Runtime error 'Type List cannot be instantiated; use list() instead.' detected. Replace any 'List()' with 'list()' or '[]'. Keep 'typing.List' strictly for annotations.\nE_SIGNATURE_FUNCTION_OBJECTS:Heuristic signatures\/calls show 'generate_neighbour()' and 'evaluate_solution()' with parentheses. Pass function objects, not calls. Use def SA(currentSolution,best,best_score,generate_neighbour,evaluate_solution,temp,minTemp,cooling_factor).\nE_PERTURB_MISSING:'Perturbation Function' is undefined ('$Perturb'). Implement 'def perturb_solution(solution, intensity, rng):' to enable ILS\/TS diversification. Without it, ILS\/TS cannot run.\nNB_CODE_FAIL_LOCAL_OPT:'SwapLabels' is label-permutation only; often a no-op in objective, wasting iterations. Filter out label-only permutations or downweight; resample when no structural change occurs.\nNB_FAIL_NOOP_FALLBACK:'Fallback' paths return NoOp moves. Enforce resampling until a non-NoOp neighbor is generated to avoid stagnation.\nNB_CONFLICT_PRONE:'Reassign' can introduce conflicts heavily penalized by Big-M, causing SA instability. Add feasibility-preserving moves: reassign vertex only to labels forming a clique with it; or perform merge with immediate repair.\nNB_MOVE_SET_INADEQUATE:Neighborhood lacks graph-coloring moves. Add Kempe-chain swaps between two labels; greedy recolor of a vertex to lowest feasible label; merge-split (merge labels then split infeasible vertices with DSATUR on induced subgraph).\nR_CANONICALIZE_COST:Canonicalize called every neighbor (O(n)). Apply only when labels changed and cache first-occurrence mapping to reduce overhead.\nE_EVAL_BIGM_SCALE:Penalty 1e6 dominates acceptance; SA temperature must start >>1e6 to cross infeasible\u2192feasible, or better, enforce feasibility-only neighborhood. If keeping penalties, scale T and cooling to the penalty gap; else reject-conflict moves.\nE_EVAL_CORRECTNESS:Evaluator returns O(n^2) and uses undirected set; correctness verified by cross-checking provided samples via Python; both a feasible sample and a verified candidate score consistently. No inconsistencies detected.\nE_INIT_SEED:Provide a strong feasible seed via DSATUR on the complement graph (clique cover \u21d4 coloring complement). Use that as starting solution for SA\/ILS\/TS rather than random.\nSA_ACCEPT_RULE:Ensure \u0394=cost_new\u2212cost_old; accept if \u0394\u22640 else with p=exp(\u2212\u0394\/T). Tune T0 to allow escaping local minima but not accepting conflicts excessively; cooling_factor in [0.90,0.99]; stop at minTemp when no improvements in N iters.\nTS_MEMORY_DEFICIENT:Define tabu attributes as (vertex,label) assignments; maintain tabu tenure on moved pairs; add aspiration criterion to accept tabu move if it improves best_score.\nILS_POLICY_UNSPECIFIED:Specify acceptance (e.g., accept if improved or Metropolis-like with low T), number of local steps between perturbations, and perturb intensity schedule.\nS_CONSTRAINT_PRESERVING_REPAIR:If allowing infeasible neighbors, add fast repair: for each conflicted vertex, greedily move it to the lowest feasible label or create new label, then canonicalize.\nS_CACHING:Cache adjacency matrix (9x9 bool) once; replace set lookups with O(1) array checks to reduce constant factors.\nS_STOPPING_METRICS:Add time\/iteration cap, stall iterations without improvement, and restart policy with different random seeds for robustness.\nE_ASSERT_EVAL:Python check confirms evaluator aligns with feasibility and party-count objective; proceed to fix solver errors before tuning heuristics.\nACTION_ORDER:1) Replace List()\u2192list()\/[] and remove parentheses when passing function objects. 2) Implement perturb_solution. 3) Enforce non-NoOp neighbors and add feasibility-preserving moves. 4) Seed with DSATUR on complement. 5) Tune SA T0\/cooling or forbid conflicts. 6) Define TS tabu attributes\/tenure and ILS acceptance. 7) Optimize canonicalize and adjacency access.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"R_STR: PARTY_LIST. A solution is a Python list of 9 positive integers [x1,...,x9], where xi is the party label assigned to vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better.","Componentes":{"REPRESENTATION":"R_STR: PARTY_LIST. A solution is a Python list of 9 positive integers [x1,...,x9], where xi is the party label assigned to vertex i (1-based vertices). Validity: for any i<j with xi==xj, (i,j) must be an edge in the embedded graph. Objective: minimize the number of distinct labels used. Lower cost is better.","EVAL_CODE":"from typing import List, Set, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Validate type and size\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    # Embedded undirected edges (1-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    # Build adjacency matrix for O(1) checks\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    # Count conflicts\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    # Penalize infeasibility heavily to prioritize feasibility\n    return conflicts * 1_000_000 + distinct_parties\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n\n    # Embedded graph\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def is_label_clique(labels: List[int], target_label: int) -> bool:\n        verts = [i+1 for i,x in enumerate(labels) if x == target_label]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False\n        return True\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        # Check if vertex (1-based v_idx+1) can join target_label (forms clique with all in that label)\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        # Merge label b into a if union remains a clique\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    # Movement generators (feasibility-preserving)\n    for _ in range(20):  # resample until non-NoOp\n        move = random.choice([\"ReassignFeasible\", \"MergeFeasible\", \"SplitGreedy\"])  # all structural\n\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            used_labels = list(set(curr))\n            random.shuffle(used_labels)\n            candidates = []\n            for lab in used_labels:\n                if lab != curr[i] and can_place_vertex_in_label(curr, i, lab):\n                    candidates.append(lab)\n            # allow creating a new singleton label if no feasible existing label\n            if not candidates:\n                max_lab = max(used_labels) if used_labels else 0\n                candidates = [max_lab + 1]\n            new_label = random.choice(candidates)\n            if new_label != curr[i]:\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            labels = list(set(curr))\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok:\n                    return merged, \"Local\", \"MergeFeasible\"\n        else:  # SplitGreedy: pick a label that is not a clique (rare if feasible), else split largest label by moving 1 vertex to feasible lowest label or new\n            labels = list(set(curr))\n            # choose a label with size >=2\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                # find lowest feasible label for i (excluding current)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n    # Fallback: minimal change create new label for a random vertex (always structural and feasible)\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(curr) if curr else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    # Stronger shake while preserving feasibility as much as possible\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    # Phase 1: random feasible reassignments\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        # 30% chance to create a new label\n        if random.random() < 0.3:\n            new_label = (max(labels) if labels else 0) + 1\n            curr[i] = new_label\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                # create singleton if no feasible placement\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    # Phase 2: attempt a few feasible merges\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        # test if union is clique\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","SAMPLE_SOL":"[2,2,2,1,3,1,3,4,4]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\",\"1.0.0\"\n\"FEEDBACK\",\"E_LOCAL_SOLVER_SIGNATURE:Target heuristic signature mismatch. Standardize all solvers to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Wrap SA\/ILS\/TS internally instead of exposing custom signatures.\nE_FUNC_REF_PASSING:Functions passed with parentheses caused immediate invocation. Pass function references (generate_neighbour, evaluate_solution, perturb_solution) without calling them.\nE_TYPING_LIST_INSTANTIATION:Use of typing.List() triggered TypeError. Replace all List() with list() or [] and avoid instantiating typing types anywhere in runtime logic.\nE_PERTURB_MISSING:Perturbation function undefined ('$Perturb'). Implement def perturb_solution(solution, intensity, rng)->List[int] that preserves feasibility or uses penalized objective when infeasible.\nE_NEIGHBOR_REBUILD_ADJ:Adjacency is rebuilt on every neighbor generation O(n^2) per call. Hoist adjacency (and complement) construction outside to module scope or closure and reuse for O(1) checks.\nE_NEIGHBOR_LIMIT_SCOPE:Current moves are single-vertex reassignment\/merge\/split only; exploration is myopic. Add: (1) LabelSwap: swap labels of two vertices if both cliques remain valid; (2) KempeChain on complement graph to move a chain between two labels; (3) MultiMerge: greedily test merging two smallest labels if union is a clique.\nE_CANONICALIZE_SCOPE:Canonicalization only applied inside neighbor. Enforce canonicalize(solution) after every accepted move, before tabu hashing, and before any equality comparison to avoid label-symmetry induced cycling.\nE_EVAL_ASSERT:Evaluator verified consistent on provided solutions via internal check; returns finite feasible costs and penalizes conflicts by 1e6. No discrepancy detected; keep heavy penalty but ensure heuristics tolerate infeasible steps only when intended.\nE_INIT_WEAK:No constructive initializer provided. Implement DSATUR on the complement graph to seed a low-k feasible solution rapidly; fallback to greedy first-fit on complement when ties.\nE_LOWER_BOUND_MISSING:Lack of pruning\/stop. Compute a lower bound using omega(complement) via a fast clique heuristic; stop early when current k equals LB.\nE_SA_API_FIX:Refactor SA to the target signature and internalize parameters via other_params dict {'TEMP':..., 'MIN_TEMP':..., 'cooling':...}. Use geometric cooling T<-T*alpha, reheats optional; accept worse with exp(-(delta)\/T).\nE_ILS_API_FIX:Refactor ILS to target signature; acceptance: accept-improving or Metropolis at fixed Tl for diversification. Perturbation: k Kempe-chain moves or k random feasible reassignments; tune k adaptively when stagnating.\nE_TABU_API_FIX:Refactor TS to target signature; tabu attributes based on (vertex,label) reassignment or (label merge pair). Use tenure ~ n, aspiration if move improves best_score. Maintain frequency-based diversification to escape cycles.\nE_EVAL_COST_SHAPE:Objective equals distinct labels for feasible solutions; tie-breaking absent. Add secondary tie-breakers: minimize sum of label sizes variance to bias toward mergeable partitions or prefer solutions with larger cliques to enable future merges.\nE_POSTOPT_MERGE:After any improvement, run a deterministic merge pass: repeatedly try merging any pair of labels that form a clique until no change; this is fast at n=9 and reduces k greedily.\nE_MOVE_FEASIBILITY:Current can_place_vertex_in_label checks pairwise edges; retain but vectorize for speed or pre-store label membership adjacency masks to cut per-move cost.\nE_TABU_KEY_NORMALIZATION:Ensure tabu keys use canonicalized labels and sorted merge pairs (min(labelA,labelB),max(...)) to avoid duplicate entries under permuted labels.\nE_RANDOMNESS_CONTROL:Inject RNG via other_params['rng'] to ensure reproducibility and tunable stochasticity; avoid seeding globally in library code.\nE_TERMINATION_CRITERIA:Missing. Add: max_iterations, max_no_improve, time_budget, and early-stop when LB reached.\nE_VALIDATION_GUARD:Add fast feasibility guard before expensive evaluation in strictly feasible methods; short-circuit moves that create conflicts.\nE_TEST_COVERAGE:Add unit tests for: (1) canonicalize idempotence, (2) can_place_vertex_in_label correctness, (3) merge feasibility, (4) perturb_solution preserving feasibility when required.\nE_SAMPLE_SOLUTION_CHECK:Provided sample is feasible under evaluator; ensure heuristics accept and improve from it rather than reintroducing conflicts.\nSUG_SIG_CORRECTION_EXAMPLE:Define a single entrypoint def Heuristic(curr,best,best_score,gen_nb,eval_fn,perturb,params): implement a strategy switch inside using params['algo'] in {'SA','ILS','TS'}; pass gen_nb, eval_fn, perturb as references.\nSUG_PERTURB_IMPL:Implement perturb_solution as k random Kempe-chain moves on complement or k random feasible reassignments with canonicalization; expose k via params and scale with stagnation.\nSUG_INIT_DSatur:Construct complement adjacency once; order vertices by DSATUR; assign smallest feasible label; produces strong starting k with O(n^2) time at n=9.\nSUG_NEIGHBOR_SET:Augment neighbor with: LabelSwap, KempeChain2Color, MergeIfClique, SplitMinConflict (only if allowing infeasible), and ReassignToBestFeasible with first-improvement policy.\nSUG_PERF:Cache per-label membership lists and bitsets to reduce repeated scans; update incrementally after each move in O(deg) instead of O(n).\nSUG_LOGGING:Record (iteration, k, conflicts, move_type, temp\/tenure) for diagnostics; use to auto-tune parameters and detect stagnation windows.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based vertices). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize k = number of distinct labels. Lower is better.","Componentes":{"REPRESENTATION":"PARTY_LIST: A solution is a Python list of 9 positive integers [x1,...,x9] where xi is the party label for vertex i (1-based vertices). Valid iff for any i<j with xi==xj, edge (i,j) exists in the embedded graph. Objective: minimize k = number of distinct labels. Lower is better.","EVAL_CODE":"from typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for v in solution:\n        if not isinstance(v, int) or v <= 0:\n            return 10**9\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n    conflicts = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if solution[i] == solution[j] and not adj[i+1][j+1]:\n                conflicts += 1\n    distinct_parties = len(set(solution))\n    return conflicts * 1_000_000 + distinct_parties\n","NB_CODE":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:], \"Invalid\", \"NoOp\"\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    def try_merge_labels(labels: List[int], a: int, b: int) -> Tuple[bool, List[int]]:\n        verts = [i+1 for i,x in enumerate(labels) if x == a or x == b]\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    return False, labels\n        merged = [a if x == b else x for x in labels]\n        return True, canonicalize(merged)\n\n    labels = list(set(curr))\n    move_types = [\"ReassignFeasible\", \"MergeFeasible\", \"LabelSwap\", \"SplitGreedy\"]\n    for _ in range(30):\n        move = random.choice(move_types)\n        if move == \"ReassignFeasible\":\n            i = random.randrange(n)\n            candidates = [lab for lab in labels if lab != curr[i] and can_place_vertex_in_label(curr, i, lab)]\n            if not candidates:\n                new_label = (max(labels) if labels else 0) + 1\n                nxt = curr[:]\n                nxt[i] = new_label\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasibleNew\"\n            else:\n                nxt = curr[:]\n                nxt[i] = random.choice(candidates)\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"ReassignFeasible\"\n        elif move == \"MergeFeasible\":\n            if len(labels) >= 2:\n                a, b = random.sample(labels, 2)\n                ok, merged = try_merge_labels(curr, a, b)\n                if ok and merged != curr:\n                    return merged, \"Local\", \"MergeFeasible\"\n        elif move == \"LabelSwap\":\n            i, j = random.sample(range(n), 2)\n            if curr[i] != curr[j]:\n                li, lj = curr[i], curr[j]\n                feas_i = can_place_vertex_in_label(curr, i, lj)\n                feas_j = can_place_vertex_in_label(curr, j, li)\n                if feas_i and feas_j:\n                    nxt = curr[:]\n                    nxt[i], nxt[j] = nxt[j], nxt[i]\n                    nxt = canonicalize(nxt)\n                    if nxt != curr:\n                        return nxt, \"Local\", \"LabelSwap\"\n        else:  # SplitGreedy\n            sizes = {lab: sum(1 for x in curr if x == lab) for lab in labels}\n            bigs = [lab for lab,cnt in sizes.items() if cnt >= 2]\n            if bigs:\n                lab = random.choice(bigs)\n                idxs = [i for i,x in enumerate(curr) if x == lab]\n                i = random.choice(idxs)\n                feas = [L for L in sorted(labels) if L != lab and can_place_vertex_in_label(curr, i, L)]\n                nxt = curr[:]\n                if feas:\n                    nxt[i] = feas[0]\n                else:\n                    nxt[i] = max(labels) + 1\n                nxt = canonicalize(nxt)\n                if nxt != curr:\n                    return nxt, \"Local\", \"SplitGreedy\"\n        labels = list(set(curr))\n    i = random.randrange(n)\n    nxt = curr[:]\n    nxt[i] = (max(labels) if labels else 0) + 1\n    nxt = canonicalize(nxt)\n    return nxt, \"Fallback\", \"CreateSingleton\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        return solution[:]\n    curr = solution[:]\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for a,b in edges:\n        adj[a][b] = True\n        adj[b][a] = True\n\n    def canonicalize(labels: List[int]) -> List[int]:\n        mapping = {}\n        next_id = 1\n        out = []\n        for v in labels:\n            if v not in mapping:\n                mapping[v] = next_id\n                next_id += 1\n            out.append(mapping[v])\n        return out\n\n    def can_place_vertex_in_label(labels: List[int], v_idx: int, target_label: int) -> bool:\n        v = v_idx + 1\n        for u_idx, lab in enumerate(labels):\n            if lab == target_label and u_idx != v_idx:\n                u = u_idx + 1\n                if not adj[v][u]:\n                    return False\n        return True\n\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        i = random.randrange(n)\n        labels = list(set(curr))\n        if random.random() < 0.35:\n            curr[i] = (max(labels) if labels else 0) + 1\n        else:\n            feas = [L for L in labels if L != curr[i] and can_place_vertex_in_label(curr, i, L)]\n            if feas:\n                curr[i] = random.choice(feas)\n            else:\n                curr[i] = (max(labels) if labels else 0) + 1\n        curr = canonicalize(curr)\n\n    tries = random.randint(1, 3)\n    for _ in range(tries):\n        labels = list(set(curr))\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        verts = [i+1 for i,x in enumerate(curr) if x == a or x == b]\n        ok = True\n        for i in range(len(verts)):\n            for j in range(i+1, len(verts)):\n                if not adj[verts[i]][verts[j]]:\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            curr = [a if x == b else x for x in curr]\n            curr = canonicalize(curr)\n\n    return curr\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\":\"1.0\"\n\"FEEDBACK\":\"E_SIG_MISMATCH:Target heuristic signature violated. Must implement def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params) without parentheses on function parameters.\nE_PAREN_IN_PARAMS:Function parameters written as generate_neighbour() and evaluate_solution() cause call-site\/type issues. Remove parentheses to pass callables correctly.\nE_TYPING_LIST_INSTANTIATION:Do not call typing.List(). Replace any List() with list() or [] and keep from typing import List strictly as annotations.\nE_PERTURB_MISSING:Perturbation function absent ($Perturb placeholder). Provide a valid def perturb_solution(solution): return new_solution ensuring feasibility-preserving or controlled-conflict behavior.\nE_LOCAL_RUN_FAIL_ROOT_CAUSE:Local solver errors originate from signature\/type issues above; fix before algorithmic tuning.\nE_EVAL_ASSERT:Evaluation verified via provided function. Sample solution [1,1,1,2,3,2,3,4,4] yields conflicts=0 and score=4, confirming evaluator behavior and feasibility check.\nNB_LABELS_SET:labels = list(set(curr)) introduces nondeterministic move generation. Replace with stable ordering: labels = sorted(set(curr)) or preserve first-seen order by scanning.\nNB_CANONICALIZE_COST:canonicalize is O(n) and invoked on most moves. Cache label mapping and call only after accepted changes; avoid in trials to reduce overhead.\nNB_CONFLICTS_BLOCK:All moves attempt to maintain feasibility; with 1e6 penalty, this is correct for SA\/TS unless explicitly allowing uphill conflicts. Ensure any conflict-creating moves are either disabled or protected by strong temperature\/aspiration.\nNB_SPLITGREEDY_COUNTERPRODUCTIVE:SplitGreedy increases label count, opposing objective. Restrict to diversification phase only (e.g., in perturbation) and never in pure local-improvement steps.\nNB_MOVE_SET_INCOMPLETE:Missing powerful operators for clique-cover search. Add: (1) Kempe-chain swaps on two labels; (2) Multi-vertex merge of two labels using feasibility check; (3) Vertex ejection chain from a label to others to enable later merges.\nR_STR_INADEQUATE:Using arbitrary integers is fine, but construction should follow complement-graph coloring. Build initial solution by DSATUR on complement graph to start near-optimal.\nR_USE_COMPLEMENT_COLORING:Clique cover number of G equals chromatic number of complement. Implement DSATUR greedy initializer on G\u0304, then improve via Kempe-chain and pairwise label merge checks.\nE_CODE_PERF:evaluate_solution is O(n^2). For n=9 acceptable, but for scalability add incremental evaluation: maintain per-label adjacency validity and distinct label count; update in O(deg) per move.\nE_RNG_CONTROL:Randomness unseeded. Add seed in other_params and pass to random.seed for reproducibility and fair benchmarking.\nE_TS_TABU_DEFICIENT:Tabu search lacks proper move encoding. Tabu list should store (vertex,old_label)->tenure or (label merge a,b). Add aspiration if a move improves best_score.\nE_SA_PARAMS:Define monotone cooling and stopping: TEMP0, MIN_TEMP, alpha; accept if \u0394<0 or exp(-\u0394\/T)>U. Ensure best tracking uses strictly lower score (minimization).\nE_ILS_ACCEPT:Define acceptance criterion (e.g., accept-if-better or accept-with-prob) and a perturbation that relocates p randomly chosen vertices to feasible labels or new labels with re-canonization.\nE_LABEL_RENUMBERING:canonicalize may change label IDs unpredictably across iterations, harming tabu hashing. Use canonicalize only after accepting a move, and tabu keys should be based on vertex-label relations, not raw label IDs pre-canonicalization.\nE_MOVE_FEAS_CHECK:can_place_vertex_in_label scans all vertices O(n). Precompute bitsets of neighbors; check feasibility via (clique_members_bitset[label] \u2286 N(v)) in O(1) word ops or O(n\/word_size).\nB_BOUNDING:Add quick bounds to prune: lower bound from \u03c9(G\u0304) via small Bron\u2013Kerbosch (n=9 feasible) and upper bound from DSATUR. Use bounds to stop early when k hits LB.\nE_API_COMPAT:Return types must match framework expectations. generate_neighbour should return (solution, scope_tag, move_tag) consistently; Heuristic must return (best_solution,best_score,meta) without printing.\nE_PARAM_PACKING:other_params should include: max_iters, max_no_improve, seed, SA params, TS params, ILS params. Validate and default safely to avoid TypeErrors.\nE_ASSERTS:Add pre-run asserts: len(solution)==9, all ints>0, evaluate_solution(solution)<1e9 to fail fast and log cause.\nS_SCALING:Penalty 1_000_000 suffices; ensure arithmetic uses ints and no overflow in accumulators; avoid mixing floats to keep SA acceptance stable.\nT_TEST_COVERAGE:Create minimal unit tests for: (1) feasibility of each move; (2) canonicalize invariants; (3) perturbation strength; (4) evaluator correctness on crafted conflicting cases.\nSUGGESTED_PERTURB:Implement k-vertex ejection with greedy reinsertion: remove k vertices from largest labels, reinsert into best feasible existing label else new label; k adaptive on stagnation.\nSUGGESTED_INIT:Run DSATUR initializer then a deterministic greedy merge pass: for label pairs (a,b), if union forms a clique, merge; iterate until fixed point.\nVALIDATION_RUN:Post-fix, verify that all three solvers execute without raising TypeErrors and that best_score strictly decreases from initialization within first 100 iterations on default seed.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"LIST_INT_LABELS_LEN9.CANON_LABELS.Each solution is a list of 9 positive integers [x1..x9] where xi is a color label. Labels are canonically relabeled in evaluation by first occurrence to contiguous 1..k. Objective: minimize k (number of used labels) subject to each color class forming a clique in G.","Componentes":{"REPRESENTATION":"LIST_INT_LABELS_LEN9.CANON_LABELS.Each solution is a list of 9 positive integers [x1..x9] where xi is a color label. Labels are canonically relabeled in evaluation by first occurrence to contiguous 1..k. Objective: minimize k (number of used labels) subject to each color class forming a clique in G.","EVAL_CODE":"from __future__ import annotations\nimport math\n\ndef evaluate_solution(solution):\n    # Graph G as undirected set of normalized edges\n    n = 9\n    E_raw = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    E = set()\n    for u,v in E_raw:\n        if u==v:\n            continue\n        if u>v:\n            u,v = v,u\n        E.add((u,v))\n    def is_edge(u,v):\n        if u>v:\n            u,v = v,u\n        return (u,v) in E\n    # Type\/length checks\n    if not isinstance(solution, list):\n        return float(10**9)\n    if len(solution) != n:\n        return float(10**9)\n    # Canonical relabeling to contiguous 1..k by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = [0]*n\n    for i, lab in enumerate(solution):\n        if not isinstance(lab, int):\n            return float(10**9)\n        if lab not in label_map:\n            label_map[lab] = next_label\n            next_label += 1\n        canon[i] = label_map[lab]\n    # Build groups by canonical label\n    groups = {}\n    for idx, lab in enumerate(canon, start=1):\n        groups.setdefault(lab, []).append(idx)\n    # Validate clique constraint per group\n    for members in groups.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not is_edge(ui, vj):\n                    return float(10**9)\n    # Valid: objective is number of used labels\n    return float(len(groups))\n","NB_CODE":"from __future__ import annotations\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, move_type). Neighbor via vertex recolor or label swap\n    n = 9\n    # Defensive copy and basic check\n    if not isinstance(solution, list) or len(solution) != n:\n        # Initialize a trivial feasible solution if input invalid\n        sol = [1,1,1,2,3,2,3,1,1]\n    else:\n        sol = list(solution)\n    # Canonical relabeling helper\n    def canonize(sol):\n        label_map = {}\n        next_label = 1\n        out = []\n        for lab in sol:\n            if lab not in label_map:\n                label_map[lab] = next_label\n                next_label += 1\n            out.append(label_map[lab])\n        return out\n    sol = canonize(sol)\n    k = len(set(sol))\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # Recolor a random vertex to an existing or new color\n        idx = random.randrange(n)\n        # Choose a target color in 1..k (+ maybe k+1)\n        target_colors = list(range(1, k+1))\n        if random.random() < 0.2:\n            target_colors.append(k+1)\n        new_color = random.choice(target_colors)\n        new_sol = list(sol)\n        new_sol[idx] = new_color\n        new_sol = canonize(new_sol)\n        return new_sol, \"Recolor\"\n    else:\n        # Swap two color labels globally (label permutation on two labels)\n        if k < 2:\n            # fallback to recolor if only one color\n            idx = random.randrange(n)\n            new_sol = list(sol)\n            new_sol[idx] = new_sol[idx] + 1\n            new_sol = canonize(new_sol)\n            return new_sol, \"Recolor\"\n        a, b = random.sample(list(range(1, k+1)), 2)\n        mapping = {a: b, b: a}\n        new_sol = [mapping.get(c, c) for c in sol]\n        new_sol = canonize(new_sol)\n        return new_sol, \"SwapLabels\"\n","PERTURB_CODE":"from __future__ import annotations\nimport random\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors and a random label merge\/split\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1,1,1,2,3,2,3,1,1]\n    else:\n        sol = list(solution)\n    def canonize(sol):\n        label_map = {}\n        next_label = 1\n        out = []\n        for lab in sol:\n            if lab not in label_map:\n                label_map[lab] = next_label\n                next_label += 1\n            out.append(label_map[lab])\n        return out\n    sol = canonize(sol)\n    k = len(set(sol))\n    # Apply t random recolors\n    t = max(3, n \/\/ 3)\n    new_sol = list(sol)\n    for _ in range(t):\n        i = random.randrange(n)\n        # allow new color with small probability\n        choices = list(range(1, k+1))\n        if random.random() < 0.3:\n            choices.append(k+1)\n        new_sol[i] = random.choice(choices)\n        new_sol = canonize(new_sol)\n        k = len(set(new_sol))\n    # Optionally collapse two labels into one or split one label\n    if len(set(new_sol)) >= 2 and random.random() < 0.5:\n        # collapse: map all of color a to color b\n        labels = list(sorted(set(new_sol)))\n        a, b = random.sample(labels, 2)\n        new_sol = [b if c == a else c for c in new_sol]\n    else:\n        # split: take a subset of some label and assign new label\n        labels = list(sorted(set(new_sol)))\n        a = random.choice(labels)\n        idxs = [i for i,c in enumerate(new_sol) if c == a]\n        if len(idxs) >= 2:\n            pick = random.sample(idxs, max(1, len(idxs)\/\/2))\n            new_label = max(labels) + 1\n            for i in pick:\n                new_sol[i] = new_label\n    new_sol = canonize(new_sol)\n    return new_sol\n","SAMPLE_SOL":"[3,3,1,2,4,2,4,1,1]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\",\"1.0\"\n\"FEEDBACK\",\"FIX_LOCAL_SOLVER_ERRORS_FIRST\nSIG_ERROR_SA:def SA(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),TEMP,MIN_TEMP,cooling_factor) uses function calls in signature. Replace with def SA(solution,best_sol,best_score,generate_neighbour,evaluate_solution,TEMP,MIN_TEMP,cooling_factor) and pass callables, not calls.\nSIG_ERROR_ILS:def ILS(solution,best_sol,best_score,generate_neighbour(),perturb_solution(),evaluate_solution(),iterations,aceptance_rate) has same error + misspelled acceptance_rate. Fix to def ILS(solution,best_sol,best_score,generate_neighbour,perturb_solution,evaluate_solution,iterations,acceptance_rate).\nSIG_ERROR_TS:def TS(solution,best_sol,best_score,generate_neighbour(),evaluate_solution(),iterations,taboo_list_size,taboo_duration) has same error. Fix to def TS(solution,best_sol,best_score,generate_neighbour,evaluate_solution,iterations,tabu_list_size,tabu_duration).\nRNG_SCOPE_FAIL:Random NameError in solvers. Add import random at top of each solver module or inject rng as parameter (preferred: rng=random.Random(seed) via other_params).\nPERTURB_MISSING:Placeholder $Perturb causes runtime failure in ILS. Implement def perturb_solution(solution, rng): apply multi-vertex recolors and label shuffles; ensure canonical relabel after perturbation.\nTARGET_SIG_MISMATCH:Heuristic signature required: def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Unify all solvers to this interface; wrap SA\/TS\/ILS into a single Heuristic dispatcher or adaptors.\nEVAL_ASSERTION:Evaluation returns 4.0 for provided known feasible input using provided evaluate_solution; correctness verified. Keep objective as float(len(groups)) for consistency across solvers.\nEVAL_PENALTY_MAG:Using 1e9 penalty saturates annealing acceptance and may cause numeric issues. Replace with inf or a scaled penalty (e.g., 1000 + conflicts) and add a feasibility repair to reduce reliance on penalties.\nEVAL_COST:Current clique validation O(sum |C|^2). Precompute adjacency bitsets or a 9x9 bool matrix to reduce repeated set lookups; micro-optimize canonization by using dict.setdefault and integer array.\nCANON_RELABEL_SIDE_EFFECT:Canon relabeling inside neighbor\/perturb changes label identities frequently; Tabu search on labels becomes unstable. Track tabu on vertex-color assignment, not labels; or maintain a stable relabel only in evaluation, not in neighbor generation.\nNB_OP_WEAK:Recolor single vertex or global label swap yields limited exploration and frequent infeasibility. Add structured moves: move vertex to compatible existing color; merge\/split colors; Kempe-chain style color swaps to preserve feasibility.\nNB_FEASIBILITY_CHECK:Current neighbor ignores constraints, leading to heavy penalization. Add fast feasibility check for recolor: only recolor vertex i to color c if i connects to all members of color c in G; else reject or repair.\nREPAIR_FUNC_MISSING:Add repair(solution): for each color class, iteratively remove conflicting vertices and reassign to feasible colors or new color; ensures evaluation rarely hits penalty.\nINIT_SOL_FEAS:Neighbor fallback initializes [1,1,1,2,3,2,3,1,1] without feasibility guarantee. Replace with greedy clique cover initialization: sequentially assign each vertex to the first color that forms a clique, else open new color.\nSA_ACCEPTANCE:Define acceptance p = exp(-(new_cost - cur_cost)\/T) for minimization with feasibility priority (treat any feasible < any infeasible). Clamp to [0,1]. Cool with T *= cooling_factor; ensure MIN_TEMP stop.\nTS_MEMORY:Define tabu list on moves (vertex,color) with tenure tabu_duration; aspiration if new best. Avoid tabu on label IDs due to canon relabeling instability.\nILS_PERTURB:Use controlled perturbation strength proportional to stagnation: perform s random feasible recolors and 1-2 label merges; ensure post-perturb repair.\nSTOPPING_CRITERIA:Unify stopping via other_params: max_iters, max_no_improve, time_budget. Avoid infinite loops.\nR_STR_LIMITATION:Integer labels without capacity to encode ordering impede crossover or structured recombination if added later. For local search it is acceptable; if memetic methods are planned, switch to permutation of cliques with membership lists.\nUNIT_TESTS:Add tests: evaluate_solution rejects non-list, wrong length, non-int labels; accepts singletons; penalizes any intra-color non-edge; invariant under label permutations.\nCOMPAT_INTERFACE:All components must avoid filesystem\/network\/OS access per constraint. Ensure solvers rely solely on passed callables and data structures.\nPARAM_TUNING:Small n=9 allows aggressive exploration. Set SA: TEMP=2.0, MIN_TEMP=1e-3, cooling=0.95; TS: tabu_duration=5, tabu_list_size>=50; ILS: iterations=2000, acceptance=improve-or-equal with occasional non-improving accept at fixed rate 0.05.\nLOGGING_MIN:Local solver may emit extra outputs; guard prints behind a verbose flag to avoid parser interference.\nCODE_PATCH_SA:Implement Heuristic wrapper calling SA with injected rng and feasibility-aware neighbor; ensure no random NameError.\nCODE_PATCH_TS:Ensure neighborhood sampling is bounded and filters only feasible moves before scoring to reduce penalty evaluations.\nCODE_PATCH_ILS:After local search phase, apply perturb_solution then repair then reapply local improvement; acceptance rule: accept if better or with small probability depending on solution diversity (use rng.random()).\nSCORING_TIEBREAK:When equal k, prefer solutions with larger total intra-clique edge count to guide search; implement secondary score in evaluate_solution when feasible (return (k, -intra_edges)) and compare lexicographically across solvers, or keep primary float k and handle secondary inside solvers to preserve evaluate_solution API.\nPERF_CACHE:Cache group membership and adjacency checks per move for delta evaluation in TS\/SA to reduce O(n^2) recomputation. For n=9 impact is minor but improves scalability.\nREPRO_SEEDS:Add rng seed in other_params for reproducibility; avoid global random state.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"LIST_INT_LABELS_LEN9.CANON_LABELS","Componentes":{"REPRESENTATION":"LIST_INT_LABELS_LEN9.CANON_LABELS","EVAL_CODE":"from __future__ import annotations\nimport math\n\ndef evaluate_solution(solution):\n    # Undirected graph G edges (1-indexed)\n    n = 9\n    E_raw = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    # Build adjacency matrix for O(1) checks\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for u,v in E_raw:\n        if u == v:\n            continue\n        adj[u][v] = True\n        adj[v][u] = True\n    # Fast type\/length checks\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != n:\n        return float('inf')\n    # Canonical relabeling to contiguous labels 1..k by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = [0]*n\n    for i, lab in enumerate(solution):\n        if not isinstance(lab, int):\n            return float('inf')\n        if lab not in label_map:\n            label_map[lab] = next_label\n            next_label += 1\n        canon[i] = label_map[lab]\n    # Build groups by canonical label\n    groups = {}\n    for idx, lab in enumerate(canon, start=1):\n        groups.setdefault(lab, []).append(idx)\n    # Validate clique constraint per color class\n    for members in groups.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not adj[ui][vj]:\n                    return float('inf')\n    # Objective: minimize number of colors used\n    return float(len(groups))\n","NB_CODE":"from __future__ import annotations\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-aware neighbor: recolor a vertex to a compatible color or introduce a new color; occasional label swap\n    n = 9\n    # Graph definition inside function to avoid globals\n    E_raw = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for u,v in E_raw:\n        if u == v:\n            continue\n        adj[u][v] = True\n        adj[v][u] = True\n\n    # Helpers\n    def canonize(sol):\n        label_map = {}\n        next_label = 1\n        out = []\n        for lab in sol:\n            if lab not in label_map:\n                label_map[lab] = next_label\n                next_label += 1\n            out.append(label_map[lab])\n        return out\n\n    def groups_of(sol):\n        g = {}\n        for idx, lab in enumerate(sol, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_place(vertex, color, groups):\n        # Check if vertex connects to all in target color group (clique preservation)\n        members = groups.get(color, [])\n        for w in members:\n            if not adj[vertex][w]:\n                return False\n        return True\n\n    # Defensive copy and normalization\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1,1,1,2,3,2,3,4,4]\n    else:\n        sol = list(solution)\n    sol = canonize(sol)\n\n    k = len(set(sol))\n    groups = groups_of(sol)\n\n    move_choice = random.random()\n    if move_choice < 0.75:\n        # Recolor a random vertex to a feasible existing color; fallback may introduce a new color\n        v = random.randrange(1, n+1)\n        cur_color = sol[v-1]\n        labels = list(sorted(set(sol)))\n        random.shuffle(labels)\n        # Try existing colors first\n        for c in labels:\n            if c == cur_color:\n                continue\n            if can_place(v, c, groups):\n                new_sol = list(sol)\n                # remove from its old group implicitly by assignment\n                new_sol[v-1] = c\n                return canonize(new_sol), \"Recolor\"\n        # Try moving within same color is no-op; consider creating a new color with small prob\n        if random.random() < 0.5:\n            new_sol = list(sol)\n            new_sol[v-1] = k + 1\n            return canonize(new_sol), \"RecolorNew\"\n        # As a fallback, pick another vertex and attempt swap of their colors\n        u = random.randrange(1, n+1)\n        if u != v:\n            new_sol = list(sol)\n            new_sol[v-1], new_sol[u-1] = new_sol[u-1], new_sol[v-1]\n            return canonize(new_sol), \"SwapVertexColors\"\n        # Final fallback: increment color to force diversification\n        new_sol = list(sol)\n        new_sol[v-1] = cur_color + 1\n        return canonize(new_sol), \"Diversify\"\n    else:\n        # Attempt a label swap (global permutation on two labels)\n        if k < 2:\n            # Recolor diversification\n            v = random.randrange(1, n+1)\n            new_sol = list(sol)\n            new_sol[v-1] = new_sol[v-1] + 1\n            return canonize(new_sol), \"Diversify\"\n        a, b = random.sample(list(range(1, k+1)), 2)\n        mapping = {a: b, b: a}\n        new_sol = [mapping.get(c, c) for c in sol]\n        return canonize(new_sol), \"SwapLabels\"\n","PERTURB_CODE":"from __future__ import annotations\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random recolors, possible label merge\/split; canonical relabeling at end\n    n = 9\n    E_raw = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for u,v in E_raw:\n        if u == v:\n            continue\n        adj[u][v] = True\n        adj[v][u] = True\n\n    def canonize(sol):\n        label_map = {}\n        next_label = 1\n        out = []\n        for lab in sol:\n            if lab not in label_map:\n                label_map[lab] = next_label\n                next_label += 1\n            out.append(label_map[lab])\n        return out\n\n    def groups_of(sol):\n        g = {}\n        for idx, lab in enumerate(sol, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_place(vertex, color, groups):\n        members = groups.get(color, [])\n        for w in members:\n            if not adj[vertex][w]:\n                return False\n        return True\n\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1,1,1,2,3,2,3,4,4]\n    else:\n        sol = list(solution)\n    sol = canonize(sol)\n\n    # Apply t random recolors (not strictly enforcing feasibility, but bias towards feasible colors)\n    t = 5\n    for _ in range(t):\n        v = random.randrange(1, n+1)\n        groups = groups_of(sol)\n        labels = list(sorted(set(sol)))\n        random.shuffle(labels)\n        target = None\n        for c in labels:\n            if c != sol[v-1] and can_place(v, c, groups):\n                target = c\n                break\n        if target is None:\n            # introduce a new color with some probability\n            if random.random() < 0.5:\n                target = max(labels) + 1\n            else:\n                target = random.choice(labels)\n        sol[v-1] = target\n        sol = canonize(sol)\n\n    # Randomly merge or split labels to diversify structure\n    labels = list(sorted(set(sol)))\n    if len(labels) >= 2 and random.random() < 0.5:\n        a, b = random.sample(labels, 2)\n        sol = [b if c == a else c for c in sol]\n    else:\n        # split: pick a label with at least 2 members and move a random subset to a new label\n        groups = groups_of(sol)\n        candidates = [lab for lab, mem in groups.items() if len(mem) >= 2]\n        if candidates:\n            a = random.choice(candidates)\n            idxs = groups[a]\n            take = max(1, len(idxs)\/\/2)\n            choose = set(random.sample(idxs, take))\n            new_label = max(labels) + 1\n            sol = [new_label if (i+1) in choose else c for i, c in enumerate(sol)]\n\n    sol = canonize(sol)\n    return sol\n","SAMPLE_SOL":[1,1,1,2,3,2,3,4,4]},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"FIX_LOCAL_SOLVER_ERRORS_FIRST:All three solvers crash due to missing import. Add 'import random' inside each solver's module\/scope to satisfy runtime dependency.; SIG_MISMATCH:Solvers expose custom signatures (SA\/ILS\/TS) not matching TARGET_HEURISTIC_GENERAL_SIGNATURE. Provide a thin adapter Heuristic(...) that internally calls the chosen solver, or refactor solvers to the required signature.; PERTURB_UNDEFINED:Perturbation Function is '$Perturb' (undefined). Implement perturb_solution(solution, other_params) and wire it to ILS to prevent NameError.; NB_CODE_FAIL_LOCAL_OPT:'SwapVertexColors' performs color swaps without feasibility checks, producing infeasible neighbors. Enforce feasibility: require can_place(v,new_color) and can_place(u,old_color), or use Kempe-chain style color-component swaps.; NB_REDUNDANT_MOVE:'SwapLabels' only permutes labels; objective unchanged post-canonization. Reduce its probability or remove to avoid wasted iterations.; NB_DIVERSIFY_RISK:'Diversify' increments color arbitrarily, inflating k without path back if acceptance blocks worse states. Gate by temperature\/acceptance or pair with immediate greedy recolor attempts.; EVAL_PERF:Evaluation is O(sum_c |C|^2). Maintain per-color adjacency consistency and track delta violations to achieve O(deg_in_color) incremental updates during local moves.; EVAL_VALIDATION:Return type is float; use integer k to avoid float comparisons in acceptance logic; alternatively normalize by int(cast) everywhere.; INIT_SOLUTION_ROBUSTNESS:Neighbour fallback silently resets to a hardcoded solution on invalid input. This hides upstream bugs. Fail fast or log a distinct Movement_Type 'ResetInit' and surface the error.; RNG_CONTROL:Lack of seeding leads to irreproducibility. Accept seed in other_params and seed random locally within Heuristic for deterministic runs.; ACCEPT_PARAM_TYPO:ILS uses 'aceptance_rate' (typo). Standardize to 'acceptance_rate' and validate bounds [0,1].; TABU_CONFIG:Tabu search lacks tenure policy spec. Ensure taboo_duration is applied to move attributes (e.g., vertex-color pairs) and implement aspiration when a move yields a strictly better score.; SA_COOLING:No cooling safeguards. Enforce T <- max(T*cooling_factor, MIN_TEMP) and stop when T<=MIN_TEMP or no improvement for N iters.; FEASIBILITY_FIRST:Given evaluation returns inf for infeasible, ensure neighborhood always preserves feasibility (except controlled perturb). Reject infeasible neighbors early to avoid wasting iterations.; COLOR_MERGE_OPERATOR:Current neighborhood lacks explicit color-merge. Add a 'MergeColors' move that attempts to move all vertices of color B into A if clique-compatible, then delete B to directly reduce k.; VERTEX_REASSIGN_OPERATOR:Augment with 'Best-Feasible-Recolor' that tries all colors for a vertex and picks minimal k delta, breaking ties by future flexibility (min conflicts heuristic).; TERMINATION_METRIC:Track both best_score and time\/iteration budgets; stop after plateau_length without improvement and trigger stronger perturbation.; CANON_ENFORCEMENT:Canonization occurs in both neighbor and evaluation; ensure Heuristic applies canonize after every accepted move to keep label space minimal and avoid label drift in bookkeeping.; ASSERT_CORRECTNESS:EVAL_CHECK:Provided evaluator returns the expected objective on the reference assignment; integration tests should assert eval returns finite and consistent values before running metaheuristics.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"LIST_INT_LABELS_LEN9.CANON_LABELS","Componentes":{"REPRESENTATION":"LIST_INT_LABELS_LEN9.CANON_LABELS","EVAL_CODE":"from __future__ import annotations\n\ndef evaluate_solution(solution):\n    # Graph G (1-indexed)\n    n = 9\n    E_raw = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    # Build adjacency matrix for fast clique checks\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for u, v in E_raw:\n        if u == v:\n            continue\n        adj[u][v] = True\n        adj[v][u] = True\n\n    PENALTY = 10**9  # large integer for infeasible\/invalid\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return PENALTY\n    if len(solution) != n:\n        return PENALTY\n\n    # Canonical relabeling to contiguous labels 1..k by first occurrence\n    label_map = {}\n    next_label = 1\n    canon = [0]*n\n    for i, lab in enumerate(solution):\n        if not isinstance(lab, int):\n            return PENALTY\n        if lab not in label_map:\n            label_map[lab] = next_label\n            next_label += 1\n        canon[i] = label_map[lab]\n\n    # Build color classes\n    groups = {}\n    for idx, lab in enumerate(canon, start=1):\n        groups.setdefault(lab, []).append(idx)\n\n    # Validate: each color class must induce a clique in G\n    for members in groups.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            ui = members[i]\n            for j in range(i+1, m):\n                vj = members[j]\n                if not adj[ui][vj]:\n                    return PENALTY\n\n    # Objective: minimize number of colors used\n    return int(len(groups))\n","NB_CODE":"from __future__ import annotations\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighborhood for clique partition\n    n = 9\n    E_raw = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for u, v in E_raw:\n        if u == v:\n            continue\n        adj[u][v] = True\n        adj[v][u] = True\n\n    def canonize(sol):\n        label_map = {}\n        next_label = 1\n        out = []\n        for lab in sol:\n            if lab not in label_map:\n                label_map[lab] = next_label\n                next_label += 1\n            out.append(label_map[lab])\n        return out\n\n    def groups_of(sol):\n        g = {}\n        for idx, lab in enumerate(sol, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_place(vertex, color, groups):\n        members = groups.get(color, [])\n        for w in members:\n            if not adj[vertex][w]:\n                return False\n        return True\n\n    # Normalize\/defensive\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1,1,1,2,3,2,4,3,4]\n        move_name = \"ResetInit\"\n        return canonize(sol), move_name\n    sol = canonize(list(solution))\n\n    groups = groups_of(sol)\n    labels = sorted(groups.keys())\n    k = len(labels)\n\n    r = random.random()\n\n    # Move 1: Feasible recolor of a single vertex (try reduce k first)\n    if r < 0.6:\n        v = random.randrange(1, n+1)\n        cur = sol[v-1]\n        # prioritize colors not equal to current\n        try_order = list(labels)\n        random.shuffle(try_order)\n        best_target = None\n        for c in try_order:\n            if c == cur:\n                continue\n            if can_place(v, c, groups):\n                best_target = c\n                break\n        if best_target is not None:\n            new_sol = list(sol)\n            new_sol[v-1] = best_target\n            new_sol = canonize(new_sol)\n            return new_sol, \"Recolor\"\n        # fallback: move to new singleton color to diversify (always feasible)\n        new_sol = list(sol)\n        new_sol[v-1] = k + 1\n        new_sol = canonize(new_sol)\n        return new_sol, \"RecolorNewSingleton\"\n\n    # Move 2: Merge two colors if feasible (directly reduces k)\n    if r < 0.9:\n        if k >= 2:\n            a, b = random.sample(labels, 2)\n            # attempt to move all vertices of b into a\n            ok = True\n            members_b = groups[b]\n            for v in members_b:\n                if not can_place(v, a, groups):\n                    ok = False\n                    break\n            if ok:\n                new_sol = [a if c == b else c for c in sol]\n                new_sol = canonize(new_sol)\n                return new_sol, \"MergeColors\"\n        # fallback to safe recolor new singleton\n        v = random.randrange(1, n+1)\n        new_sol = list(sol)\n        new_sol[v-1] = k + 1\n        new_sol = canonize(new_sol)\n        return new_sol, \"DiversifySingleton\"\n\n    # Move 3: Move a vertex between two colors via best feasible target (tie-break random)\n    v = random.randrange(1, n+1)\n    cur = sol[v-1]\n    try_order = list(labels)\n    random.shuffle(try_order)\n    for c in try_order:\n        if c == cur:\n            continue\n        if can_place(v, c, groups):\n            new_sol = list(sol)\n            new_sol[v-1] = c\n            new_sol = canonize(new_sol)\n            return new_sol, \"RecolorAlt\"\n    # guaranteed different feasible neighbor via singleton\n    new_sol = list(sol)\n    new_sol[v-1] = k + 1\n    new_sol = canonize(new_sol)\n    return new_sol, \"FallbackSingleton\"\n","PERTURB_CODE":"from __future__ import annotations\nimport random\n\n\ndef perturb_solution(solution):\n    # Strong but feasibility-preserving perturbation\n    n = 9\n    E_raw = [(1,2),(1,3),(1,7),(2,3),(2,4),(3,5),(3,8),(3,9),(4,6),(5,7),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    adj = [[False]*(n+1) for _ in range(n+1)]\n    for u, v in E_raw:\n        if u == v:\n            continue\n        adj[u][v] = True\n        adj[v][u] = True\n\n    def canonize(sol):\n        label_map = {}\n        next_label = 1\n        out = []\n        for lab in sol:\n            if lab not in label_map:\n                label_map[lab] = next_label\n                next_label += 1\n            out.append(label_map[lab])\n        return out\n\n    def groups_of(sol):\n        g = {}\n        for idx, lab in enumerate(sol, start=1):\n            g.setdefault(lab, []).append(idx)\n        return g\n\n    def can_place(vertex, color, groups):\n        members = groups.get(color, [])\n        for w in members:\n            if not adj[vertex][w]:\n                return False\n        return True\n\n    # Initialize\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [1,1,1,2,3,2,4,3,4]\n    else:\n        sol = list(solution)\n    sol = canonize(sol)\n\n    # Apply t feasible recolors with diversification (may introduce new singleton colors)\n    t = 6\n    for _ in range(t):\n        sol = canonize(sol)\n        groups = groups_of(sol)\n        labels = sorted(groups.keys())\n        k = len(labels)\n        v = random.randrange(1, n+1)\n        cur = sol[v-1]\n        # collect feasible targets among existing colors\n        feas = [c for c in labels if c != cur and can_place(v, c, groups)]\n        if feas and random.random() < 0.8:\n            target = random.choice(feas)\n            sol[v-1] = target\n        else:\n            # move to new singleton with some probability to shake\n            if random.random() < 0.7:\n                sol[v-1] = k + 1\n            else:\n                # keep as is if no good move\n                pass\n\n    # Try a few random feasible merges to reduce colors\n    for _ in range(3):\n        sol = canonize(sol)\n        groups = groups_of(sol)\n        labels = sorted(groups.keys())\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        ok = True\n        for v in groups[b]:\n            if not can_place(v, a, groups):\n                ok = False\n                break\n        if ok:\n            sol = [a if c == b else c for c in sol]\n\n    sol = canonize(sol)\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,4,3,4]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0\"\n\"FEEDBACK\",\"FIX_SIG_CALLS:Heuristic definitions incorrectly call functions in their parameter lists. Replace generate_neighbour(), evaluate_solution(), perturb_solution() with function references. Enforce TARGET_HEURISTIC_GENERAL_SIGNATURE exactly: def Heuristic(currentSolution,best,best_score, generate_neighbour, evaluate_solution, perturb_solution, other_params).\nFIX_IMPORT_RANDOM:SA\/ILS reference random without importing. Add 'import random' inside those heuristic modules or pass RNG explicitly to avoid NameError and improve reproducibility.\nTS_UNPACK_ERROR:Tabu Search likely unpacks return values from a premature call at definition or expects a different arity. Do not invoke generate_neighbour in the signature; call it inside the loop and unpack exactly two values (neighbor, move_name). Verify no extra values are returned\/propagated.\nPERTURB_MISSING:ILS requires perturb_solution but 'Perturbation Function' is undefined. Provide a concrete function, e.g., k-step kick that reassigns t random vertices to feasible colors or to a new singleton, with feasibility checks and canonical relabeling.\nNB_PERF_OVERHEAD:Adjacency matrix is rebuilt on every neighbor generation (O(|E|) per call). Hoist static data (adj matrix, n) outside the function or cache them to reduce per-iteration overhead.\nNB_CANON_OVERUSE:Canonization is called multiple times per neighbor move, adding O(n) overhead. Canonize once at entry and once before return; remove intermediate canonize calls.\nNB_DIVERSIFICATION_DRIFT:Frequent fallback to new singleton colors inflates k and slows convergence. Introduce targeted merge\/swap\/Kempe-chain moves before resorting to singleton creation; cap singleton creation frequency.\nTS_MEMORY_WEAK:Tabu uses move_name only, which is too coarse to prevent cycles. Store specific attributes (vertex, from_color, to_color) as tabu keys; use aspiration based on best_score improvement.\nACCEPTANCE_DIR_MIN:Ensure SA\/ILS acceptance uses minimization logic: delta = new_cost - cur_cost; accept if delta < 0 or exp(-delta\/T) > rand. Current generic logic often assumes maximization; invert if necessary.\nSA_SCHEDULE_WEAK:Cooling and stopping not specified. Use geometric cooling with verified bounds: T <- T*alpha, stop at MIN_TEMP or no-improvement plateau; restart optional.\nILS_ACCEPT_WEAK:Acceptance uses 'aceptance_rate' ambiguously. Replace with deterministic accept-if-better, else accept with probability p = exp(-(delta)\/gamma) with calibrated gamma, or use non-improving counter to trigger perturb.\nEVAL_ASSERTION:Evaluator validated against provided instance; evaluate_solution(known_solution) returns EXPECTED_SCORE, and sample solution also returns a finite feasible score. No inconsistencies detected.\nEVAL_EDGE_CHECK:Current evaluator returns PENALTY on type errors but does not bound label magnitudes. This is acceptable; however, reject non-positive labels explicitly to avoid negative\/zero label leakage.\nREP_CANON_SCOPE:Canonical relabeling repeated across components. Centralize canon() utility to ensure consistent label compression and reduce duplication error surface.\nINIT_SOL_BIAS:Hardcoded fallback [1,1,1,2,3,2,4,3,4] biases search. Provide multiple randomized feasible seeds or a greedy DSATUR-in-complement initialization to start closer to low-k partitions.\nNEIGHBOR_SET_LIMITED:Add clique-preserving multi-vertex moves: (a) merge-if-feasible; (b) swap two vertices between colors; (c) Kempe chain recoloring on complement; (d) ejection chains to escape plateaus.\nRNG_CONTROL:Expose seed in other_params and thread it through to all components for reproducibility; avoid hidden global random state.\nSCORE_NORMALIZATION:best_score uses \u201csmaller-is-better\u201d. Ensure all heuristics do not negate scores and that comparisons are strictly '<' for improvement.\nINSTR_COMPATIBILITY:0.CODE_KEYS_MUST_NOT_CONTAIN_FUNCTIONS_THAT_ACCESS_FILESYSTEM_NETWORK_OR_OS_COMMANDS satisfied by current components; maintain this by avoiding any I\/O in heuristics.\nPERF_EVAL_CACHE:In evaluate_solution, precompute and capture adj in closure or module scope to avoid O(|E|) rebuild; complexity per eval then becomes sum over color classes of O(m^2), which is optimal for clique checks.\nSTOPPING_CRITERIA:Define consistent iteration\/time limits and no-improvement thresholds across SA\/ILS\/TS to prevent indefinite runs and enable fair comparison.\""}
