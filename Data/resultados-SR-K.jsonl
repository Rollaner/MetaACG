{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, 1-based, unique)\n    if not isinstance(solution, list):\n        return -1\n    if not all(isinstance(i, int) for i in solution):\n        return -1\n    if len(solution) != len(set(solution)):\n        return -1\n    if any(i < 1 or i > 24 for i in solution):\n        return -1\n    # strictly increasing\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return -1\n    # Data (embedded)\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return -1\n        total_value += v[idx - 1]\n    # Use negatives for maximization (lower is better)\n    return -total_value\n","Vecindad":"import math, random, typing as t\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helper validations and utilities\n    def is_strict_increasing_unique(lst):\n        return all(a < b for a, b in zip(lst, lst[1:])) and len(lst) == len(set(lst))\n    def weight_of(lst):\n        return sum(w[i - 1] for i in lst)\n    def feasible(lst):\n        if not isinstance(lst, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in lst):\n            return False\n        if not is_strict_increasing_unique(sorted(lst)):\n            return False\n        tw = 0\n        for i in sorted(lst):\n            tw += w[i - 1]\n            if tw > capacity:\n                return False\n        return True\n    def normalize(lst):\n        return sorted(lst)\n\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    cur = list(solution) if isinstance(solution, list) else []\n    cur = normalize([int(i) for i in cur if isinstance(i, int)])\n    cur = [i for i in cur if 1 <= i <= 24]\n    if not feasible(cur):\n        # reset to empty feasible\n        cur = []\n\n    move_types = [\"add\", \"drop\", \"swap\"]\n    # Bias moves: prefer add when there is capacity room, else drop\/swap\n    current_w = weight_of(cur)\n    # Try to choose a viable move type\n    random.shuffle(move_types)\n\n    chosen_move = None\n    for mt in move_types:\n        if mt == \"add\":\n            if len(cur) < 24:\n                # Check if there exists any addable item\n                candidates = [i for i in range(1, 25) if i not in cur and current_w + w[i-1] <= capacity]\n                if candidates:\n                    chosen_move = \"add\"\n                    break\n        elif mt == \"drop\":\n            if cur:\n                chosen_move = \"drop\"\n                break\n        else:  # swap\n            if cur and len(cur) < 24:\n                # Check if any swap is feasible\n                found = False\n                for i_in in cur:\n                    for i_out in range(1, 25):\n                        if i_out in cur:\n                            continue\n                        new_w = current_w - w[i_in-1] + w[i_out-1]\n                        if new_w <= capacity:\n                            found = True\n                            break\n                    if found:\n                        break\n                if found:\n                    chosen_move = \"swap\"\n                    break\n    if chosen_move is None:\n        # Fallback deterministic: drop if any, else return current\n        if cur:\n            chosen_move = \"drop\"\n        else:\n            return cur, (\"feasible\", \"none\")\n\n    new_sol = cur[:]\n    if chosen_move == \"add\":\n        candidates = [i for i in range(1, 25) if i not in new_sol and current_w + w[i-1] <= capacity]\n        pick = random.choice(candidates)\n        new_sol.append(pick)\n    elif chosen_move == \"drop\":\n        pick = random.choice(new_sol)\n        new_sol.remove(pick)\n    else:  # swap\n        # Try a few random attempts to find a feasible swap\n        for _ in range(50):\n            i_in = random.choice(new_sol)\n            i_out = random.choice([i for i in range(1, 25) if i not in new_sol])\n            new_w = current_w - w[i_in-1] + w[i_out-1]\n            if new_w <= capacity:\n                new_sol.remove(i_in)\n                new_sol.append(i_out)\n                break\n        else:\n            # If swap failed, revert to drop\n            if new_sol:\n                pick = random.choice(new_sol)\n                new_sol.remove(pick)\n                chosen_move = \"drop\"\n\n    new_sol = normalize(new_sol)\n    # Ensure feasibility (should hold by construction)\n    if not feasible(new_sol):\n        # As a safety net, shrink until feasible\n        while not feasible(new_sol) and new_sol:\n            new_sol.pop()\n        new_sol = normalize(new_sol)\n\n    return new_sol, (\"feasible\", chosen_move)\n","Perturbacion":"import math, random, typing as t\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def normalize(lst):\n        return sorted(lst)\n    def feasible(lst):\n        if not isinstance(lst, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n    def weight_of(lst):\n        return sum(w[i - 1] for i in lst)\n\n    cur = list(solution) if isinstance(solution, list) else []\n    cur = normalize([int(i) for i in cur if isinstance(i, int)])\n    cur = [i for i in cur if 1 <= i <= 24]\n    if not feasible(cur):\n        cur = []\n\n    steps = random.randint(2, 6)\n    for _ in range(steps):\n        move = random.choice([\"add\", \"drop\", \"swap\", \"swap\", \"add\"])  # slight bias to add\/swap\n        current_w = weight_of(cur)\n        if move == \"add\":\n            candidates = [i for i in range(1, 25) if i not in cur and current_w + w[i-1] <= capacity]\n            if candidates:\n                cur.append(random.choice(candidates))\n                cur = normalize(cur)\n        elif move == \"drop\":\n            if cur:\n                cur.remove(random.choice(cur))\n        else:  # swap\n            if cur and len(cur) < 24:\n                # attempt several feasible swaps\n                ok = False\n                for __ in range(30):\n                    i_in = random.choice(cur)\n                    i_out = random.choice([i for i in range(1, 25) if i not in cur])\n                    new_w = current_w - w[i_in-1] + w[i_out-1]\n                    if new_w <= capacity:\n                        cur.remove(i_in)\n                        cur.append(i_out)\n                        cur = normalize(cur)\n                        ok = True\n                        break\n                if not ok and cur:\n                    # fallback drop\n                    cur.remove(random.choice(cur))\n        # Ensure feasibility guard\n        if not feasible(cur):\n            # aggressively trim if overweight or invalid\n            cur = normalize(list(sorted(set([i for i in cur if 1 <= i <= 24]))))\n            while not feasible(cur) and cur:\n                cur.pop()\n    return normalize(cur)\n","Resultados":[[2,3,4,5,8,9,10,11,14,15,17,19,20,21,22,23,24],-214,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19],-234],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00213292}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, 1-based, unique)\n    if not isinstance(solution, list):\n        return -1\n    if not all(isinstance(i, int) for i in solution):\n        return -1\n    if len(solution) != len(set(solution)):\n        return -1\n    if any(i < 1 or i > 24 for i in solution):\n        return -1\n    # strictly increasing\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return -1\n    # Data (embedded)\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return -1\n        total_value += v[idx - 1]\n    # Use negatives for maximization (lower is better)\n    return -total_value\n","Vecindad":"import math, random, typing as t\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helper validations and utilities\n    def is_strict_increasing_unique(lst):\n        return all(a < b for a, b in zip(lst, lst[1:])) and len(lst) == len(set(lst))\n    def weight_of(lst):\n        return sum(w[i - 1] for i in lst)\n    def feasible(lst):\n        if not isinstance(lst, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in lst):\n            return False\n        if not is_strict_increasing_unique(sorted(lst)):\n            return False\n        tw = 0\n        for i in sorted(lst):\n            tw += w[i - 1]\n            if tw > capacity:\n                return False\n        return True\n    def normalize(lst):\n        return sorted(lst)\n\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    cur = list(solution) if isinstance(solution, list) else []\n    cur = normalize([int(i) for i in cur if isinstance(i, int)])\n    cur = [i for i in cur if 1 <= i <= 24]\n    if not feasible(cur):\n        # reset to empty feasible\n        cur = []\n\n    move_types = [\"add\", \"drop\", \"swap\"]\n    # Bias moves: prefer add when there is capacity room, else drop\/swap\n    current_w = weight_of(cur)\n    # Try to choose a viable move type\n    random.shuffle(move_types)\n\n    chosen_move = None\n    for mt in move_types:\n        if mt == \"add\":\n            if len(cur) < 24:\n                # Check if there exists any addable item\n                candidates = [i for i in range(1, 25) if i not in cur and current_w + w[i-1] <= capacity]\n                if candidates:\n                    chosen_move = \"add\"\n                    break\n        elif mt == \"drop\":\n            if cur:\n                chosen_move = \"drop\"\n                break\n        else:  # swap\n            if cur and len(cur) < 24:\n                # Check if any swap is feasible\n                found = False\n                for i_in in cur:\n                    for i_out in range(1, 25):\n                        if i_out in cur:\n                            continue\n                        new_w = current_w - w[i_in-1] + w[i_out-1]\n                        if new_w <= capacity:\n                            found = True\n                            break\n                    if found:\n                        break\n                if found:\n                    chosen_move = \"swap\"\n                    break\n    if chosen_move is None:\n        # Fallback deterministic: drop if any, else return current\n        if cur:\n            chosen_move = \"drop\"\n        else:\n            return cur, (\"feasible\", \"none\")\n\n    new_sol = cur[:]\n    if chosen_move == \"add\":\n        candidates = [i for i in range(1, 25) if i not in new_sol and current_w + w[i-1] <= capacity]\n        pick = random.choice(candidates)\n        new_sol.append(pick)\n    elif chosen_move == \"drop\":\n        pick = random.choice(new_sol)\n        new_sol.remove(pick)\n    else:  # swap\n        # Try a few random attempts to find a feasible swap\n        for _ in range(50):\n            i_in = random.choice(new_sol)\n            i_out = random.choice([i for i in range(1, 25) if i not in new_sol])\n            new_w = current_w - w[i_in-1] + w[i_out-1]\n            if new_w <= capacity:\n                new_sol.remove(i_in)\n                new_sol.append(i_out)\n                break\n        else:\n            # If swap failed, revert to drop\n            if new_sol:\n                pick = random.choice(new_sol)\n                new_sol.remove(pick)\n                chosen_move = \"drop\"\n\n    new_sol = normalize(new_sol)\n    # Ensure feasibility (should hold by construction)\n    if not feasible(new_sol):\n        # As a safety net, shrink until feasible\n        while not feasible(new_sol) and new_sol:\n            new_sol.pop()\n        new_sol = normalize(new_sol)\n\n    return new_sol, (\"feasible\", chosen_move)\n","Perturbacion":"import math, random, typing as t\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def normalize(lst):\n        return sorted(lst)\n    def feasible(lst):\n        if not isinstance(lst, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n    def weight_of(lst):\n        return sum(w[i - 1] for i in lst)\n\n    cur = list(solution) if isinstance(solution, list) else []\n    cur = normalize([int(i) for i in cur if isinstance(i, int)])\n    cur = [i for i in cur if 1 <= i <= 24]\n    if not feasible(cur):\n        cur = []\n\n    steps = random.randint(2, 6)\n    for _ in range(steps):\n        move = random.choice([\"add\", \"drop\", \"swap\", \"swap\", \"add\"])  # slight bias to add\/swap\n        current_w = weight_of(cur)\n        if move == \"add\":\n            candidates = [i for i in range(1, 25) if i not in cur and current_w + w[i-1] <= capacity]\n            if candidates:\n                cur.append(random.choice(candidates))\n                cur = normalize(cur)\n        elif move == \"drop\":\n            if cur:\n                cur.remove(random.choice(cur))\n        else:  # swap\n            if cur and len(cur) < 24:\n                # attempt several feasible swaps\n                ok = False\n                for __ in range(30):\n                    i_in = random.choice(cur)\n                    i_out = random.choice([i for i in range(1, 25) if i not in cur])\n                    new_w = current_w - w[i_in-1] + w[i_out-1]\n                    if new_w <= capacity:\n                        cur.remove(i_in)\n                        cur.append(i_out)\n                        cur = normalize(cur)\n                        ok = True\n                        break\n                if not ok and cur:\n                    # fallback drop\n                    cur.remove(random.choice(cur))\n        # Ensure feasibility guard\n        if not feasible(cur):\n            # aggressively trim if overweight or invalid\n            cur = normalize(list(sorted(set([i for i in cur if 1 <= i <= 24]))))\n            while not feasible(cur) and cur:\n                cur.pop()\n    return normalize(cur)\n","Resultados":[[2,3,4,5,6,7,8,11,12,13,14,15,16,17,19,20,22,24],-235,[1,2,3,4,7,8,10,11,12,14,15,16,17,19,20,21,22,23,24],-256],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0038687941}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate type and canonical ordering (strictly increasing, 1-based, unique)\n    if not isinstance(solution, list):\n        return -1\n    if not all(isinstance(i, int) for i in solution):\n        return -1\n    if len(solution) != len(set(solution)):\n        return -1\n    if any(i < 1 or i > 24 for i in solution):\n        return -1\n    # strictly increasing\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return -1\n    # Data (embedded)\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return -1\n        total_value += v[idx - 1]\n    # Use negatives for maximization (lower is better)\n    return -total_value\n","Vecindad":"import math, random, typing as t\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helper validations and utilities\n    def is_strict_increasing_unique(lst):\n        return all(a < b for a, b in zip(lst, lst[1:])) and len(lst) == len(set(lst))\n    def weight_of(lst):\n        return sum(w[i - 1] for i in lst)\n    def feasible(lst):\n        if not isinstance(lst, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in lst):\n            return False\n        if not is_strict_increasing_unique(sorted(lst)):\n            return False\n        tw = 0\n        for i in sorted(lst):\n            tw += w[i - 1]\n            if tw > capacity:\n                return False\n        return True\n    def normalize(lst):\n        return sorted(lst)\n\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    cur = list(solution) if isinstance(solution, list) else []\n    cur = normalize([int(i) for i in cur if isinstance(i, int)])\n    cur = [i for i in cur if 1 <= i <= 24]\n    if not feasible(cur):\n        # reset to empty feasible\n        cur = []\n\n    move_types = [\"add\", \"drop\", \"swap\"]\n    # Bias moves: prefer add when there is capacity room, else drop\/swap\n    current_w = weight_of(cur)\n    # Try to choose a viable move type\n    random.shuffle(move_types)\n\n    chosen_move = None\n    for mt in move_types:\n        if mt == \"add\":\n            if len(cur) < 24:\n                # Check if there exists any addable item\n                candidates = [i for i in range(1, 25) if i not in cur and current_w + w[i-1] <= capacity]\n                if candidates:\n                    chosen_move = \"add\"\n                    break\n        elif mt == \"drop\":\n            if cur:\n                chosen_move = \"drop\"\n                break\n        else:  # swap\n            if cur and len(cur) < 24:\n                # Check if any swap is feasible\n                found = False\n                for i_in in cur:\n                    for i_out in range(1, 25):\n                        if i_out in cur:\n                            continue\n                        new_w = current_w - w[i_in-1] + w[i_out-1]\n                        if new_w <= capacity:\n                            found = True\n                            break\n                    if found:\n                        break\n                if found:\n                    chosen_move = \"swap\"\n                    break\n    if chosen_move is None:\n        # Fallback deterministic: drop if any, else return current\n        if cur:\n            chosen_move = \"drop\"\n        else:\n            return cur, (\"feasible\", \"none\")\n\n    new_sol = cur[:]\n    if chosen_move == \"add\":\n        candidates = [i for i in range(1, 25) if i not in new_sol and current_w + w[i-1] <= capacity]\n        pick = random.choice(candidates)\n        new_sol.append(pick)\n    elif chosen_move == \"drop\":\n        pick = random.choice(new_sol)\n        new_sol.remove(pick)\n    else:  # swap\n        # Try a few random attempts to find a feasible swap\n        for _ in range(50):\n            i_in = random.choice(new_sol)\n            i_out = random.choice([i for i in range(1, 25) if i not in new_sol])\n            new_w = current_w - w[i_in-1] + w[i_out-1]\n            if new_w <= capacity:\n                new_sol.remove(i_in)\n                new_sol.append(i_out)\n                break\n        else:\n            # If swap failed, revert to drop\n            if new_sol:\n                pick = random.choice(new_sol)\n                new_sol.remove(pick)\n                chosen_move = \"drop\"\n\n    new_sol = normalize(new_sol)\n    # Ensure feasibility (should hold by construction)\n    if not feasible(new_sol):\n        # As a safety net, shrink until feasible\n        while not feasible(new_sol) and new_sol:\n            new_sol.pop()\n        new_sol = normalize(new_sol)\n\n    return new_sol, (\"feasible\", chosen_move)\n","Perturbacion":"import math, random, typing as t\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    def normalize(lst):\n        return sorted(lst)\n    def feasible(lst):\n        if not isinstance(lst, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n    def weight_of(lst):\n        return sum(w[i - 1] for i in lst)\n\n    cur = list(solution) if isinstance(solution, list) else []\n    cur = normalize([int(i) for i in cur if isinstance(i, int)])\n    cur = [i for i in cur if 1 <= i <= 24]\n    if not feasible(cur):\n        cur = []\n\n    steps = random.randint(2, 6)\n    for _ in range(steps):\n        move = random.choice([\"add\", \"drop\", \"swap\", \"swap\", \"add\"])  # slight bias to add\/swap\n        current_w = weight_of(cur)\n        if move == \"add\":\n            candidates = [i for i in range(1, 25) if i not in cur and current_w + w[i-1] <= capacity]\n            if candidates:\n                cur.append(random.choice(candidates))\n                cur = normalize(cur)\n        elif move == \"drop\":\n            if cur:\n                cur.remove(random.choice(cur))\n        else:  # swap\n            if cur and len(cur) < 24:\n                # attempt several feasible swaps\n                ok = False\n                for __ in range(30):\n                    i_in = random.choice(cur)\n                    i_out = random.choice([i for i in range(1, 25) if i not in cur])\n                    new_w = current_w - w[i_in-1] + w[i_out-1]\n                    if new_w <= capacity:\n                        cur.remove(i_in)\n                        cur.append(i_out)\n                        cur = normalize(cur)\n                        ok = True\n                        break\n                if not ok and cur:\n                    # fallback drop\n                    cur.remove(random.choice(cur))\n        # Ensure feasibility guard\n        if not feasible(cur):\n            # aggressively trim if overweight or invalid\n            cur = normalize(list(sorted(set([i for i in cur if 1 <= i <= 24]))))\n            while not feasible(cur) and cur:\n                cur.pop()\n    return normalize(cur)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001265977}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: list of strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as tiny epsilon: smaller INDEX_LIST preferred\n    # Create deterministic lex rank: base-25 positional weight\n    lex_hash = 0\n    base = 25\n    n = len(solution)\n    for pos, idx in enumerate(solution):\n        power = n - pos\n        lex_hash += idx * (base ** power)\n    # Lower cost is better; maximize total_value => minimize -total_value\n    # Add tiny epsilon to prefer lexicographically smaller solutions when values equal\n    return (-float(total_value)) + (1e-6 * float(lex_hash))\n","Vecindad":"import math, random, typing as t\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    # Helpers\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    # Normalize\/repair input\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        # Reset to empty feasible solution deterministically\n        return [], (\"repaired\", \"reset\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - tw\n\n    # 1) Try ADD: choose best ratio item that fits (tie: lighter, then smaller index)\n    add_candidates = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_candidates:\n        add_candidates.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_candidates[0][0]\n        new_sol = canonical(cur + [pick])\n        return new_sol, (\"feasible\", \"add\")\n\n    # 2) Try SWAP for an improving move: best delta value subject to feasibility\n    best_swap = None  # (delta_v, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                if delta_v > 0:\n                    # Prefer highest delta_v, then lexicographically smaller resulting list\n                    cand = canonical([x for x in cur if x != i_in] + [i_out])\n                    # Lex key is the tuple itself\n                    key = tuple(cand)\n                    if best_swap is None:\n                        best_swap = (delta_v, key, i_out, i_in)\n                    else:\n                        if delta_v > best_swap[0] or (delta_v == best_swap[0] and key < best_swap[1]):\n                            best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 3) If no improving swap, try best feasible non-worsening\/worst-minimizing swap\n    best_swap2 = None  # (delta_v, key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap2 is None:\n                    best_swap2 = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap2[0]) or (delta_v == best_swap2[0] and key < best_swap2[1]):\n                        best_swap2 = (delta_v, key, i_out, i_in)\n    if best_swap2 is not None:\n        _, _, i_out, i_in = best_swap2\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 4) Fallback: DROP worst ratio item (tie: largest index)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio, then smaller index\n        # To prefer lexicographically smaller list, drop the item with lowest ratio; if multiple, drop the largest index among those minimal ratios\n        min_ratio = ratios[0][1]\n        worst_items = [i for i, r in ratios if r == min_ratio]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and cannot add (shouldn't happen), return same\n    return cur, (\"feasible\", \"none\")\n","Perturbacion":"import math, random, typing as t\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    # Start from repaired canonical solution\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation\n    k = random.randint(3, 6)\n\n    # Drop up to k items with lowest value\/weight (ties: larger index first)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        # Prefer dropping larger indices among equal ratios\n        for i in sorted(to_drop, reverse=True):\n            if i in cur:\n                cur.remove(i)\n\n    # Then greedily add up to k best ratio items that fit\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - total_weight(cur)\n    add_cands = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining]\n    add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n    added = 0\n    for i, _, wi in add_cands:\n        if added >= k:\n            break\n        if wi <= residual:\n            cur.append(i)\n            cur = canonical(cur)\n            residual -= wi\n            added += 1\n\n    # Final feasibility guard (trim heaviest items if overweight; should not trigger)\n    while valid(cur) is False and cur:\n        # remove worst ratio then largest index\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))\n        drop_i = max([i for i, r in ratios if r == ratios[0][1]])\n        cur.remove(drop_i)\n        cur = canonical(cur)\n\n    return canonical(cur)\n","Resultados":"Failed to run target heuristic: name 't' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001393659}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: list of strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as tiny epsilon: smaller INDEX_LIST preferred\n    # Create deterministic lex rank: base-25 positional weight\n    lex_hash = 0\n    base = 25\n    n = len(solution)\n    for pos, idx in enumerate(solution):\n        power = n - pos\n        lex_hash += idx * (base ** power)\n    # Lower cost is better; maximize total_value => minimize -total_value\n    # Add tiny epsilon to prefer lexicographically smaller solutions when values equal\n    return (-float(total_value)) + (1e-6 * float(lex_hash))\n","Vecindad":"import math, random, typing as t\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    # Helpers\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    # Normalize\/repair input\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        # Reset to empty feasible solution deterministically\n        return [], (\"repaired\", \"reset\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - tw\n\n    # 1) Try ADD: choose best ratio item that fits (tie: lighter, then smaller index)\n    add_candidates = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_candidates:\n        add_candidates.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_candidates[0][0]\n        new_sol = canonical(cur + [pick])\n        return new_sol, (\"feasible\", \"add\")\n\n    # 2) Try SWAP for an improving move: best delta value subject to feasibility\n    best_swap = None  # (delta_v, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                if delta_v > 0:\n                    # Prefer highest delta_v, then lexicographically smaller resulting list\n                    cand = canonical([x for x in cur if x != i_in] + [i_out])\n                    # Lex key is the tuple itself\n                    key = tuple(cand)\n                    if best_swap is None:\n                        best_swap = (delta_v, key, i_out, i_in)\n                    else:\n                        if delta_v > best_swap[0] or (delta_v == best_swap[0] and key < best_swap[1]):\n                            best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 3) If no improving swap, try best feasible non-worsening\/worst-minimizing swap\n    best_swap2 = None  # (delta_v, key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap2 is None:\n                    best_swap2 = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap2[0]) or (delta_v == best_swap2[0] and key < best_swap2[1]):\n                        best_swap2 = (delta_v, key, i_out, i_in)\n    if best_swap2 is not None:\n        _, _, i_out, i_in = best_swap2\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 4) Fallback: DROP worst ratio item (tie: largest index)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio, then smaller index\n        # To prefer lexicographically smaller list, drop the item with lowest ratio; if multiple, drop the largest index among those minimal ratios\n        min_ratio = ratios[0][1]\n        worst_items = [i for i, r in ratios if r == min_ratio]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and cannot add (shouldn't happen), return same\n    return cur, (\"feasible\", \"none\")\n","Perturbacion":"import math, random, typing as t\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    # Start from repaired canonical solution\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation\n    k = random.randint(3, 6)\n\n    # Drop up to k items with lowest value\/weight (ties: larger index first)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        # Prefer dropping larger indices among equal ratios\n        for i in sorted(to_drop, reverse=True):\n            if i in cur:\n                cur.remove(i)\n\n    # Then greedily add up to k best ratio items that fit\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - total_weight(cur)\n    add_cands = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining]\n    add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n    added = 0\n    for i, _, wi in add_cands:\n        if added >= k:\n            break\n        if wi <= residual:\n            cur.append(i)\n            cur = canonical(cur)\n            residual -= wi\n            added += 1\n\n    # Final feasibility guard (trim heaviest items if overweight; should not trigger)\n    while valid(cur) is False and cur:\n        # remove worst ratio then largest index\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))\n        drop_i = max([i for i, r in ratios if r == ratios[0][1]])\n        cur.remove(drop_i)\n        cur = canonical(cur)\n\n    return canonical(cur)\n","Resultados":"Failed to run target heuristic: name 't' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001595702}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: list of strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as tiny epsilon: smaller INDEX_LIST preferred\n    # Create deterministic lex rank: base-25 positional weight\n    lex_hash = 0\n    base = 25\n    n = len(solution)\n    for pos, idx in enumerate(solution):\n        power = n - pos\n        lex_hash += idx * (base ** power)\n    # Lower cost is better; maximize total_value => minimize -total_value\n    # Add tiny epsilon to prefer lexicographically smaller solutions when values equal\n    return (-float(total_value)) + (1e-6 * float(lex_hash))\n","Vecindad":"import math, random, typing as t\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    # Helpers\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    # Normalize\/repair input\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        # Reset to empty feasible solution deterministically\n        return [], (\"repaired\", \"reset\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - tw\n\n    # 1) Try ADD: choose best ratio item that fits (tie: lighter, then smaller index)\n    add_candidates = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_candidates:\n        add_candidates.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_candidates[0][0]\n        new_sol = canonical(cur + [pick])\n        return new_sol, (\"feasible\", \"add\")\n\n    # 2) Try SWAP for an improving move: best delta value subject to feasibility\n    best_swap = None  # (delta_v, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                if delta_v > 0:\n                    # Prefer highest delta_v, then lexicographically smaller resulting list\n                    cand = canonical([x for x in cur if x != i_in] + [i_out])\n                    # Lex key is the tuple itself\n                    key = tuple(cand)\n                    if best_swap is None:\n                        best_swap = (delta_v, key, i_out, i_in)\n                    else:\n                        if delta_v > best_swap[0] or (delta_v == best_swap[0] and key < best_swap[1]):\n                            best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 3) If no improving swap, try best feasible non-worsening\/worst-minimizing swap\n    best_swap2 = None  # (delta_v, key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap2 is None:\n                    best_swap2 = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap2[0]) or (delta_v == best_swap2[0] and key < best_swap2[1]):\n                        best_swap2 = (delta_v, key, i_out, i_in)\n    if best_swap2 is not None:\n        _, _, i_out, i_in = best_swap2\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 4) Fallback: DROP worst ratio item (tie: largest index)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio, then smaller index\n        # To prefer lexicographically smaller list, drop the item with lowest ratio; if multiple, drop the largest index among those minimal ratios\n        min_ratio = ratios[0][1]\n        worst_items = [i for i, r in ratios if r == min_ratio]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and cannot add (shouldn't happen), return same\n    return cur, (\"feasible\", \"none\")\n","Perturbacion":"import math, random, typing as t\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    # Start from repaired canonical solution\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation\n    k = random.randint(3, 6)\n\n    # Drop up to k items with lowest value\/weight (ties: larger index first)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        # Prefer dropping larger indices among equal ratios\n        for i in sorted(to_drop, reverse=True):\n            if i in cur:\n                cur.remove(i)\n\n    # Then greedily add up to k best ratio items that fit\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - total_weight(cur)\n    add_cands = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining]\n    add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n    added = 0\n    for i, _, wi in add_cands:\n        if added >= k:\n            break\n        if wi <= residual:\n            cur.append(i)\n            cur = canonical(cur)\n            residual -= wi\n            added += 1\n\n    # Final feasibility guard (trim heaviest items if overweight; should not trigger)\n    while valid(cur) is False and cur:\n        # remove worst ratio then largest index\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))\n        drop_i = max([i for i, r in ratios if r == ratios[0][1]])\n        cur.remove(drop_i)\n        cur = canonical(cur)\n\n    return canonical(cur)\n","Resultados":"Failed to run target heuristic: name 't' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001595992}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    # eps term strictly < 1e-9 and never dominates the -value component\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    # Try 2-1: replace two current items by one remaining\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    # Try 1-2: replace one current item by two remaining\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add (should not occur), rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        tw = 0\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard (rare)\n    while not valid(cur) and cur:\n        # remove currently worst ratio then largest index\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst)\n        cur.remove(drop_i)\n        cur = canonical(cur)\n        cur = greedy_refill(cur)\n\n    return canonical(cur)\n","Resultados":"Failed to run target heuristic: name 't' is not defined.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001650332}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    # eps term strictly < 1e-9 and never dominates the -value component\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    # Try 2-1: replace two current items by one remaining\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    # Try 1-2: replace one current item by two remaining\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add (should not occur), rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        tw = 0\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard (rare)\n    while not valid(cur) and cur:\n        # remove currently worst ratio then largest index\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst)\n        cur.remove(drop_i)\n        cur = canonical(cur)\n        cur = greedy_refill(cur)\n\n    return canonical(cur)\n","Resultados":"Failed to run target heuristic: name 't' is not defined.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001859876}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    # eps term strictly < 1e-9 and never dominates the -value component\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    # Try 2-1: replace two current items by one remaining\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    # Try 1-2: replace one current item by two remaining\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add (should not occur), rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        tw = 0\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard (rare)\n    while not valid(cur) and cur:\n        # remove currently worst ratio then largest index\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst)\n        cur.remove(drop_i)\n        cur = canonical(cur)\n        cur = greedy_refill(cur)\n\n    return canonical(cur)\n","Resultados":"Failed to run target heuristic: name 't' is not defined.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0018634461}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add, rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard\n    def ensure_feasible(cur_list: t.List[int]) -> t.List[int]:\n        while not valid(cur_list) and cur_list:\n            ratios = [(i, v[i-1] \/ w[i-1]) for i in cur_list]\n            min_ratio = min(r for _, r in ratios)\n            worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n            drop_i = max(worst)\n            cur_list.remove(drop_i)\n            cur_list = canonical(cur_list)\n            cur_list = greedy_refill(cur_list)\n        return canonical(cur_list)\n\n    return ensure_feasible(cur)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'replace'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0000051401}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add, rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard\n    def ensure_feasible(cur_list: t.List[int]) -> t.List[int]:\n        while not valid(cur_list) and cur_list:\n            ratios = [(i, v[i-1] \/ w[i-1]) for i in cur_list]\n            min_ratio = min(r for _, r in ratios)\n            worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n            drop_i = max(worst)\n            cur_list.remove(drop_i)\n            cur_list = canonical(cur_list)\n            cur_list = greedy_refill(cur_list)\n        return canonical(cur_list)\n\n    return ensure_feasible(cur)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000197}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add, rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard\n    def ensure_feasible(cur_list: t.List[int]) -> t.List[int]:\n        while not valid(cur_list) and cur_list:\n            ratios = [(i, v[i-1] \/ w[i-1]) for i in cur_list]\n            min_ratio = min(r for _, r in ratios)\n            worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n            drop_i = max(worst)\n            cur_list.remove(drop_i)\n            cur_list = canonical(cur_list)\n            cur_list = greedy_refill(cur_list)\n        return canonical(cur_list)\n\n    return ensure_feasible(cur)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000010501}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based item indices in [1,24]. Order irrelevant. Example: [1,5,9].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> large positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Penalize proportional to violation\n        return 10**9 + (total_cost - B)\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). May be infeasible; evaluation handles feasibility.\n    n = 24\n    if not isinstance(solution, list):\n        solution = []\n    sol_set = set([x for x in solution if isinstance(x, int) and 1 <= x <= n])\n    current = list(sol_set)\n    moves = [\"add\", \"drop\", \"swap\"]\n    if len(current) == 0:\n        move = \"add\"\n    elif len(current) == n:\n        move = random.choice([\"drop\", \"swap\"])  # cannot add\n    else:\n        move = random.choice(moves)\n    neighbor = current[:]\n    if move == \"add\":\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n    elif move == \"drop\":\n        if neighbor:\n            i = random.randrange(len(neighbor))\n            neighbor.pop(i)\n    else:  # swap\n        if neighbor and len(sol_set) < n:\n            out_idx = random.randrange(len(neighbor))\n            out_item = neighbor[out_idx]\n            candidates = [i for i in range(1, n + 1) if i not in sol_set or i == out_item]\n            # ensure actual change\n            candidates = [i for i in candidates if i != out_item]\n            if candidates:\n                in_item = random.choice(candidates)\n                neighbor[out_idx] = in_item\n    # Normalize order (not required, but stable)\n    neighbor = sorted(set(neighbor))\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply 2-4 random neighborhood moves to escape local minima.\n    n = 24\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n    sol = sorted(set(sol))\n    k = random.randint(2, 4)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"])\n        sol_set = set(sol)\n        if move == \"add\" and len(sol) < n:\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            if candidates:\n                sol.append(random.choice(candidates))\n        elif move == \"drop\" and len(sol) > 0:\n            sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if len(sol) > 0:\n                out_idx = random.randrange(len(sol))\n                out_item = sol[out_idx]\n                candidates = [i for i in range(1, n + 1) if i not in sol_set]\n                if candidates:\n                    in_item = random.choice(candidates)\n                    sol[out_idx] = in_item\n        sol = sorted(set([x for x in sol if 1 <= x <= n]))\n    return sol\n","Resultados":[[1,3,4,6,7,8,9,10,11,12,13,14,16,17,18,19,22,23,24],-219,[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23],-268],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000951953}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based item indices in [1,24]. Order irrelevant. Example: [1,5,9].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> large positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Penalize proportional to violation\n        return 10**9 + (total_cost - B)\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). May be infeasible; evaluation handles feasibility.\n    n = 24\n    if not isinstance(solution, list):\n        solution = []\n    sol_set = set([x for x in solution if isinstance(x, int) and 1 <= x <= n])\n    current = list(sol_set)\n    moves = [\"add\", \"drop\", \"swap\"]\n    if len(current) == 0:\n        move = \"add\"\n    elif len(current) == n:\n        move = random.choice([\"drop\", \"swap\"])  # cannot add\n    else:\n        move = random.choice(moves)\n    neighbor = current[:]\n    if move == \"add\":\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n    elif move == \"drop\":\n        if neighbor:\n            i = random.randrange(len(neighbor))\n            neighbor.pop(i)\n    else:  # swap\n        if neighbor and len(sol_set) < n:\n            out_idx = random.randrange(len(neighbor))\n            out_item = neighbor[out_idx]\n            candidates = [i for i in range(1, n + 1) if i not in sol_set or i == out_item]\n            # ensure actual change\n            candidates = [i for i in candidates if i != out_item]\n            if candidates:\n                in_item = random.choice(candidates)\n                neighbor[out_idx] = in_item\n    # Normalize order (not required, but stable)\n    neighbor = sorted(set(neighbor))\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply 2-4 random neighborhood moves to escape local minima.\n    n = 24\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n    sol = sorted(set(sol))\n    k = random.randint(2, 4)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"])\n        sol_set = set(sol)\n        if move == \"add\" and len(sol) < n:\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            if candidates:\n                sol.append(random.choice(candidates))\n        elif move == \"drop\" and len(sol) > 0:\n            sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if len(sol) > 0:\n                out_idx = random.randrange(len(sol))\n                out_item = sol[out_idx]\n                candidates = [i for i in range(1, n + 1) if i not in sol_set]\n                if candidates:\n                    in_item = random.choice(candidates)\n                    sol[out_idx] = in_item\n        sol = sorted(set([x for x in sol if 1 <= x <= n]))\n    return sol\n","Resultados":[[1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],-259,[17,22,1,16,10,15,4,20,19,3,14,2,24,11,7,12,18,6,8,23],-268],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00142638}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST: list of unique 1-based item indices in [1,24]. Order irrelevant. Example: [1,5,9].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> large positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Penalize proportional to violation\n        return 10**9 + (total_cost - B)\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). May be infeasible; evaluation handles feasibility.\n    n = 24\n    if not isinstance(solution, list):\n        solution = []\n    sol_set = set([x for x in solution if isinstance(x, int) and 1 <= x <= n])\n    current = list(sol_set)\n    moves = [\"add\", \"drop\", \"swap\"]\n    if len(current) == 0:\n        move = \"add\"\n    elif len(current) == n:\n        move = random.choice([\"drop\", \"swap\"])  # cannot add\n    else:\n        move = random.choice(moves)\n    neighbor = current[:]\n    if move == \"add\":\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n    elif move == \"drop\":\n        if neighbor:\n            i = random.randrange(len(neighbor))\n            neighbor.pop(i)\n    else:  # swap\n        if neighbor and len(sol_set) < n:\n            out_idx = random.randrange(len(neighbor))\n            out_item = neighbor[out_idx]\n            candidates = [i for i in range(1, n + 1) if i not in sol_set or i == out_item]\n            # ensure actual change\n            candidates = [i for i in candidates if i != out_item]\n            if candidates:\n                in_item = random.choice(candidates)\n                neighbor[out_idx] = in_item\n    # Normalize order (not required, but stable)\n    neighbor = sorted(set(neighbor))\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply 2-4 random neighborhood moves to escape local minima.\n    n = 24\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = [x for x in solution if isinstance(x, int) and 1 <= x <= n]\n    sol = sorted(set(sol))\n    k = random.randint(2, 4)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"])\n        sol_set = set(sol)\n        if move == \"add\" and len(sol) < n:\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            if candidates:\n                sol.append(random.choice(candidates))\n        elif move == \"drop\" and len(sol) > 0:\n            sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if len(sol) > 0:\n                out_idx = random.randrange(len(sol))\n                out_item = sol[out_idx]\n                candidates = [i for i in range(1, n + 1) if i not in sol_set]\n                if candidates:\n                    in_item = random.choice(candidates)\n                    sol[out_idx] = in_item\n        sol = sorted(set([x for x in sol if 1 <= x <= n]))\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000612008}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> large positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Penalize proportional to violation\n        return 10**9 + (total_cost - B)\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). May be infeasible; evaluation handles feasibility.\n    # Includes add, drop, swap (1-1), 2-1 and 1-2 exchanges. Optionally repairs feasibility with probability p_repair.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique(solution)\n\n    sol_set = set(current)\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    # Determine feasible move types given current composition\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    move = random.choice(feasible_moves)\n    neighbor = current[:]\n\n    if move == \"add\":\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n\n    elif move == \"drop\":\n        if neighbor:\n            idx = random.randrange(len(neighbor))\n            neighbor.pop(idx)\n\n    elif move == \"swap\":\n        if neighbor and len(sol_set) < n:\n            out_idx = random.randrange(len(neighbor))\n            out_item = neighbor[out_idx]\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            if candidates:\n                in_item = random.choice(candidates)\n                neighbor[out_idx] = in_item\n\n    elif move == \"2-1\":\n        # drop two, add one not in solution\n        if len(neighbor) >= 2 and len(sol_set) < n:\n            outs = random.sample(neighbor, 2)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n            if cand_in:\n                in_item = random.choice(cand_in)\n                neighbor = [x for x in neighbor if x not in outs]\n                neighbor.append(in_item)\n\n    else:  # \"1-2\"\n        # drop one, add two not in solution\n        if len(neighbor) >= 1 and (n - len(sol_set)) >= 2:\n            out_item = random.choice(neighbor)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n            if len(cand_in) >= 2:\n                ins = random.sample(cand_in, 2)\n                neighbor = [x for x in neighbor if x != out_item]\n                neighbor.extend(ins)\n\n    neighbor = normalize_unique(neighbor)\n\n    # Capacity-aware repair with probability p_repair\n    p_repair = 0.7\n    if random.random() < p_repair:\n        while total_cost(neighbor) > B and neighbor:\n            # Drop worst density item to regain feasibility\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply k random moves to diversify. Uses add\/drop\/swap\/2-1\/1-2 with feasibility repair at the end.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        sol_set = set(sol)\n        moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n        feasible_moves = []\n        if len(sol) < n:\n            feasible_moves.append(\"add\")\n        if len(sol) > 0:\n            feasible_moves.append(\"drop\")\n        if 0 < len(sol) < n:\n            feasible_moves.append(\"swap\")\n        if len(sol) >= 2 and len(sol) < n:\n            feasible_moves.append(\"2-1\")\n        if len(sol) >= 1 and (n - len(sol)) >= 2:\n            feasible_moves.append(\"1-2\")\n        if not feasible_moves:\n            feasible_moves = moves\n        move = random.choice(feasible_moves)\n\n        if move == \"add\":\n            cand = [i for i in range(1, n + 1) if i not in sol_set]\n            if cand:\n                sol.append(random.choice(cand))\n        elif move == \"drop\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        elif move == \"swap\":\n            if sol and len(sol) < n:\n                out_idx = random.randrange(len(sol))\n                out_item = sol[out_idx]\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if cand:\n                    sol[out_idx] = random.choice(cand)\n        elif move == \"2-1\":\n            if len(sol) >= 2 and len(sol) < n:\n                outs = random.sample(sol, 2)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n                if cand:\n                    sol = [x for x in sol if x not in outs]\n                    sol.append(random.choice(cand))\n        else:  # \"1-2\"\n            if len(sol) >= 1 and (n - len(sol)) >= 2:\n                out_item = random.choice(sol)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if len(cand) >= 2:\n                    ins = random.sample(cand, 2)\n                    sol = [x for x in sol if x != out_item]\n                    sol.extend(ins)\n\n        sol = normalize_unique(sol)\n\n    # Final feasibility repair by dropping worst densities\n    while total_cost(sol) > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'replace'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00000515}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> large positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Penalize proportional to violation\n        return 10**9 + (total_cost - B)\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). May be infeasible; evaluation handles feasibility.\n    # Includes add, drop, swap (1-1), 2-1 and 1-2 exchanges. Optionally repairs feasibility with probability p_repair.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique(solution)\n\n    sol_set = set(current)\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    # Determine feasible move types given current composition\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    move = random.choice(feasible_moves)\n    neighbor = current[:]\n\n    if move == \"add\":\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n\n    elif move == \"drop\":\n        if neighbor:\n            idx = random.randrange(len(neighbor))\n            neighbor.pop(idx)\n\n    elif move == \"swap\":\n        if neighbor and len(sol_set) < n:\n            out_idx = random.randrange(len(neighbor))\n            out_item = neighbor[out_idx]\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            if candidates:\n                in_item = random.choice(candidates)\n                neighbor[out_idx] = in_item\n\n    elif move == \"2-1\":\n        # drop two, add one not in solution\n        if len(neighbor) >= 2 and len(sol_set) < n:\n            outs = random.sample(neighbor, 2)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n            if cand_in:\n                in_item = random.choice(cand_in)\n                neighbor = [x for x in neighbor if x not in outs]\n                neighbor.append(in_item)\n\n    else:  # \"1-2\"\n        # drop one, add two not in solution\n        if len(neighbor) >= 1 and (n - len(sol_set)) >= 2:\n            out_item = random.choice(neighbor)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n            if len(cand_in) >= 2:\n                ins = random.sample(cand_in, 2)\n                neighbor = [x for x in neighbor if x != out_item]\n                neighbor.extend(ins)\n\n    neighbor = normalize_unique(neighbor)\n\n    # Capacity-aware repair with probability p_repair\n    p_repair = 0.7\n    if random.random() < p_repair:\n        while total_cost(neighbor) > B and neighbor:\n            # Drop worst density item to regain feasibility\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply k random moves to diversify. Uses add\/drop\/swap\/2-1\/1-2 with feasibility repair at the end.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        sol_set = set(sol)\n        moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n        feasible_moves = []\n        if len(sol) < n:\n            feasible_moves.append(\"add\")\n        if len(sol) > 0:\n            feasible_moves.append(\"drop\")\n        if 0 < len(sol) < n:\n            feasible_moves.append(\"swap\")\n        if len(sol) >= 2 and len(sol) < n:\n            feasible_moves.append(\"2-1\")\n        if len(sol) >= 1 and (n - len(sol)) >= 2:\n            feasible_moves.append(\"1-2\")\n        if not feasible_moves:\n            feasible_moves = moves\n        move = random.choice(feasible_moves)\n\n        if move == \"add\":\n            cand = [i for i in range(1, n + 1) if i not in sol_set]\n            if cand:\n                sol.append(random.choice(cand))\n        elif move == \"drop\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        elif move == \"swap\":\n            if sol and len(sol) < n:\n                out_idx = random.randrange(len(sol))\n                out_item = sol[out_idx]\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if cand:\n                    sol[out_idx] = random.choice(cand)\n        elif move == \"2-1\":\n            if len(sol) >= 2 and len(sol) < n:\n                outs = random.sample(sol, 2)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n                if cand:\n                    sol = [x for x in sol if x not in outs]\n                    sol.append(random.choice(cand))\n        else:  # \"1-2\"\n            if len(sol) >= 1 and (n - len(sol)) >= 2:\n                out_item = random.choice(sol)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if len(cand) >= 2:\n                    ins = random.sample(cand, 2)\n                    sol = [x for x in sol if x != out_item]\n                    sol.extend(ins)\n\n        sol = normalize_unique(sol)\n\n    # Final feasibility repair by dropping worst densities\n    while total_cost(sol) > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0000017}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> large positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Penalize proportional to violation\n        return 10**9 + (total_cost - B)\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). May be infeasible; evaluation handles feasibility.\n    # Includes add, drop, swap (1-1), 2-1 and 1-2 exchanges. Optionally repairs feasibility with probability p_repair.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique(solution)\n\n    sol_set = set(current)\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    # Determine feasible move types given current composition\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    move = random.choice(feasible_moves)\n    neighbor = current[:]\n\n    if move == \"add\":\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n\n    elif move == \"drop\":\n        if neighbor:\n            idx = random.randrange(len(neighbor))\n            neighbor.pop(idx)\n\n    elif move == \"swap\":\n        if neighbor and len(sol_set) < n:\n            out_idx = random.randrange(len(neighbor))\n            out_item = neighbor[out_idx]\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            if candidates:\n                in_item = random.choice(candidates)\n                neighbor[out_idx] = in_item\n\n    elif move == \"2-1\":\n        # drop two, add one not in solution\n        if len(neighbor) >= 2 and len(sol_set) < n:\n            outs = random.sample(neighbor, 2)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n            if cand_in:\n                in_item = random.choice(cand_in)\n                neighbor = [x for x in neighbor if x not in outs]\n                neighbor.append(in_item)\n\n    else:  # \"1-2\"\n        # drop one, add two not in solution\n        if len(neighbor) >= 1 and (n - len(sol_set)) >= 2:\n            out_item = random.choice(neighbor)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n            if len(cand_in) >= 2:\n                ins = random.sample(cand_in, 2)\n                neighbor = [x for x in neighbor if x != out_item]\n                neighbor.extend(ins)\n\n    neighbor = normalize_unique(neighbor)\n\n    # Capacity-aware repair with probability p_repair\n    p_repair = 0.7\n    if random.random() < p_repair:\n        while total_cost(neighbor) > B and neighbor:\n            # Drop worst density item to regain feasibility\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply k random moves to diversify. Uses add\/drop\/swap\/2-1\/1-2 with feasibility repair at the end.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        sol_set = set(sol)\n        moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n        feasible_moves = []\n        if len(sol) < n:\n            feasible_moves.append(\"add\")\n        if len(sol) > 0:\n            feasible_moves.append(\"drop\")\n        if 0 < len(sol) < n:\n            feasible_moves.append(\"swap\")\n        if len(sol) >= 2 and len(sol) < n:\n            feasible_moves.append(\"2-1\")\n        if len(sol) >= 1 and (n - len(sol)) >= 2:\n            feasible_moves.append(\"1-2\")\n        if not feasible_moves:\n            feasible_moves = moves\n        move = random.choice(feasible_moves)\n\n        if move == \"add\":\n            cand = [i for i in range(1, n + 1) if i not in sol_set]\n            if cand:\n                sol.append(random.choice(cand))\n        elif move == \"drop\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        elif move == \"swap\":\n            if sol and len(sol) < n:\n                out_idx = random.randrange(len(sol))\n                out_item = sol[out_idx]\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if cand:\n                    sol[out_idx] = random.choice(cand)\n        elif move == \"2-1\":\n            if len(sol) >= 2 and len(sol) < n:\n                outs = random.sample(sol, 2)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n                if cand:\n                    sol = [x for x in sol if x not in outs]\n                    sol.append(random.choice(cand))\n        else:  # \"1-2\"\n            if len(sol) >= 1 and (n - len(sol)) >= 2:\n                out_item = random.choice(sol)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if len(cand) >= 2:\n                    ins = random.sample(cand, 2)\n                    sol = [x for x in sol if x != out_item]\n                    sol.extend(ins)\n\n        sol = normalize_unique(sol)\n\n    # Final feasibility repair by dropping worst densities\n    while total_cost(sol) > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n    return sol\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.00000116}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        # Scaled penalty to keep gradient informative yet dominant over objective scale\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Preserves order; deduplicates only.\n    # Returns (neighbor_solution, movement_type). Ensures deterministic feasibility repair and greedy refill.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    # Bias weights by heuristic expectation (add\/swap generally stronger)\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        # Choose best density item that fits slack; fallback to random if none fits (will be repaired)\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            # Drop worst density item\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            # Remove worst density, insert best density not in solution (prefer fitting slack + freed cost)\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            # Drop two worst densities, add best outsider that fits\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            # Drop worst, add two best that fit greedily\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    # Normalize after move\n    neighbor = normalize_unique_order(neighbor)\n\n    # Deterministic repair + greedy refill; track movement drift\n    movement_type = move\n\n    # Make feasible by dropping worst densities while updating cumulative cost\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        # Efficiently drop worst-density items until feasible\n        # Use simple loop with recomputation due to small n\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    # Greedy refill to utilize slack\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then greedy epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items (if available)\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed (rare after drops)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Greedy epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        # With probability epsilon, sample a random candidate from the top-m window to diversify\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    # Final normalization (order preserved) and ensure feasibility (should already hold)\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Resultados":[[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,18,8,23],-268,[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,8,23,18],-268],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0020856661}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        # Scaled penalty to keep gradient informative yet dominant over objective scale\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Preserves order; deduplicates only.\n    # Returns (neighbor_solution, movement_type). Ensures deterministic feasibility repair and greedy refill.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    # Bias weights by heuristic expectation (add\/swap generally stronger)\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        # Choose best density item that fits slack; fallback to random if none fits (will be repaired)\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            # Drop worst density item\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            # Remove worst density, insert best density not in solution (prefer fitting slack + freed cost)\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            # Drop two worst densities, add best outsider that fits\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            # Drop worst, add two best that fit greedily\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    # Normalize after move\n    neighbor = normalize_unique_order(neighbor)\n\n    # Deterministic repair + greedy refill; track movement drift\n    movement_type = move\n\n    # Make feasible by dropping worst densities while updating cumulative cost\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        # Efficiently drop worst-density items until feasible\n        # Use simple loop with recomputation due to small n\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    # Greedy refill to utilize slack\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then greedy epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items (if available)\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed (rare after drops)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Greedy epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        # With probability epsilon, sample a random candidate from the top-m window to diversify\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    # Final normalization (order preserved) and ensure feasibility (should already hold)\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Resultados":[[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,18,8,23],-268,[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,18,8,23],-268],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.002996475}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        # Scaled penalty to keep gradient informative yet dominant over objective scale\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Preserves order; deduplicates only.\n    # Returns (neighbor_solution, movement_type). Ensures deterministic feasibility repair and greedy refill.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    # Bias weights by heuristic expectation (add\/swap generally stronger)\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        # Choose best density item that fits slack; fallback to random if none fits (will be repaired)\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            # Drop worst density item\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            # Remove worst density, insert best density not in solution (prefer fitting slack + freed cost)\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            # Drop two worst densities, add best outsider that fits\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            # Drop worst, add two best that fit greedily\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    # Normalize after move\n    neighbor = normalize_unique_order(neighbor)\n\n    # Deterministic repair + greedy refill; track movement drift\n    movement_type = move\n\n    # Make feasible by dropping worst densities while updating cumulative cost\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        # Efficiently drop worst-density items until feasible\n        # Use simple loop with recomputation due to small n\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    # Greedy refill to utilize slack\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then greedy epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items (if available)\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed (rare after drops)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Greedy epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        # With probability epsilon, sample a random candidate from the top-m window to diversify\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    # Final normalization (order preserved) and ensure feasibility (should already hold)\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001470117}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Returns (neighbor_solution, movement_type)\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    neighbor = normalize_unique_order(neighbor)\n\n    movement_type = move\n\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Resultados":[[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,18,8,23],-268,[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,18,8,23],-268],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.002084073}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Returns (neighbor_solution, movement_type)\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    neighbor = normalize_unique_order(neighbor)\n\n    movement_type = move\n\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Resultados":[[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,18,8,23],-268,[17,22,1,16,4,15,20,19,3,14,10,11,2,12,24,6,7,18,8,23],-268],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.002889024}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Returns (neighbor_solution, movement_type)\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    neighbor = normalize_unique_order(neighbor)\n\n    movement_type = move\n\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001394262}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # INDEX_LIST evaluation: return cost (minimize). For feasible solutions: cost = -revenue. Infeasible: large positive penalty\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # Validate input\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n    capacity = 304\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + float(overflow)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst: List[int]) -> int:\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst: List[int]) -> List[int]:\n        # If overweight, remove items with lowest value density first; ensure uniqueness and bounds\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        # compute density\n        dens = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        # remove lowest density until feasible\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1]))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = sorted(i for i in solution if isinstance(i, int))\n    cur = [i for i in cur if 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    move_type = None\n    op = random.random()\n    if op < 1\/3 and len(cur) > 0:\n        # Remove\n        i = random.choice(cur)\n        nbr = [x for x in cur if x != i]\n        move_type = \"Remove\"\n    elif op < 2\/3:\n        # Add or swap to add\n        not_in = [i for i in range(1, n+1) if i not in cur]\n        if not_in:\n            j = random.choice(not_in)\n            nbr = cur + [j]\n            if total_weight(nbr) > capacity and len(cur) > 0:\n                # try swap: remove one random existing and add j\n                r = random.choice(cur)\n                nbr = [x for x in cur if x != r] + [j]\n                move_type = \"Swap\"\n            else:\n                move_type = \"Add\"\n        else:\n            # fallback to remove if full set\n            if len(cur) > 0:\n                i = random.choice(cur)\n                nbr = [x for x in cur if x != i]\n                move_type = \"Remove\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n    else:\n        # Swap between in and not-in if possible\n        if len(cur) > 0:\n            not_in = [i for i in range(1, n+1) if i not in cur]\n            if not_in:\n                r = random.choice(cur)\n                j = random.choice(not_in)\n                nbr = [x for x in cur if x != r] + [j]\n                move_type = \"Swap\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n        else:\n            # try add if empty\n            j = random.randrange(1, n+1)\n            nbr = [j]\n            move_type = \"Add\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, \"INDEX_LIST\", move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst: List[int]) -> int:\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst: List[int]) -> List[int]:\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1]))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    # Apply k random moves with feasible repair after\n    k = 5\n    nbr = cur[:]\n    for _ in range(k):\n        op = random.randrange(3)\n        if op == 0 and nbr:\n            # remove\n            r = random.choice(nbr)\n            nbr = [x for x in nbr if x != r]\n        elif op == 1:\n            # add\n            not_in = [i for i in range(1, n+1) if i not in nbr]\n            if not_in:\n                j = random.choice(not_in)\n                nbr.append(j)\n        else:\n            # swap\n            if nbr:\n                not_in = [i for i in range(1, n+1) if i not in nbr]\n                if not_in:\n                    r = random.choice(nbr)\n                    j = random.choice(not_in)\n                    nbr = [x for x in nbr if x != r] + [j]\n        nbr = repair_feasible(nbr)\n\n    return repair_feasible(nbr)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000855083}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # INDEX_LIST evaluation: return cost (minimize). For feasible solutions: cost = -revenue. Infeasible: large positive penalty\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # Validate input\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n    capacity = 304\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + float(overflow)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst: List[int]) -> int:\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst: List[int]) -> List[int]:\n        # If overweight, remove items with lowest value density first; ensure uniqueness and bounds\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        # compute density\n        dens = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        # remove lowest density until feasible\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1]))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = sorted(i for i in solution if isinstance(i, int))\n    cur = [i for i in cur if 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    move_type = None\n    op = random.random()\n    if op < 1\/3 and len(cur) > 0:\n        # Remove\n        i = random.choice(cur)\n        nbr = [x for x in cur if x != i]\n        move_type = \"Remove\"\n    elif op < 2\/3:\n        # Add or swap to add\n        not_in = [i for i in range(1, n+1) if i not in cur]\n        if not_in:\n            j = random.choice(not_in)\n            nbr = cur + [j]\n            if total_weight(nbr) > capacity and len(cur) > 0:\n                # try swap: remove one random existing and add j\n                r = random.choice(cur)\n                nbr = [x for x in cur if x != r] + [j]\n                move_type = \"Swap\"\n            else:\n                move_type = \"Add\"\n        else:\n            # fallback to remove if full set\n            if len(cur) > 0:\n                i = random.choice(cur)\n                nbr = [x for x in cur if x != i]\n                move_type = \"Remove\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n    else:\n        # Swap between in and not-in if possible\n        if len(cur) > 0:\n            not_in = [i for i in range(1, n+1) if i not in cur]\n            if not_in:\n                r = random.choice(cur)\n                j = random.choice(not_in)\n                nbr = [x for x in cur if x != r] + [j]\n                move_type = \"Swap\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n        else:\n            # try add if empty\n            j = random.randrange(1, n+1)\n            nbr = [j]\n            move_type = \"Add\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, \"INDEX_LIST\", move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst: List[int]) -> int:\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst: List[int]) -> List[int]:\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1]))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    # Apply k random moves with feasible repair after\n    k = 5\n    nbr = cur[:]\n    for _ in range(k):\n        op = random.randrange(3)\n        if op == 0 and nbr:\n            # remove\n            r = random.choice(nbr)\n            nbr = [x for x in nbr if x != r]\n        elif op == 1:\n            # add\n            not_in = [i for i in range(1, n+1) if i not in nbr]\n            if not_in:\n                j = random.choice(not_in)\n                nbr.append(j)\n        else:\n            # swap\n            if nbr:\n                not_in = [i for i in range(1, n+1) if i not in nbr]\n                if not_in:\n                    r = random.choice(nbr)\n                    j = random.choice(not_in)\n                    nbr = [x for x in nbr if x != r] + [j]\n        nbr = repair_feasible(nbr)\n\n    return repair_feasible(nbr)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001096043}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # INDEX_LIST evaluation: return cost (minimize). For feasible solutions: cost = -revenue. Infeasible: large positive penalty\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n\n    # Validate input\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n    capacity = 304\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + float(overflow)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst: List[int]) -> int:\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst: List[int]) -> List[int]:\n        # If overweight, remove items with lowest value density first; ensure uniqueness and bounds\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        # compute density\n        dens = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        # remove lowest density until feasible\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1]))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = sorted(i for i in solution if isinstance(i, int))\n    cur = [i for i in cur if 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    move_type = None\n    op = random.random()\n    if op < 1\/3 and len(cur) > 0:\n        # Remove\n        i = random.choice(cur)\n        nbr = [x for x in cur if x != i]\n        move_type = \"Remove\"\n    elif op < 2\/3:\n        # Add or swap to add\n        not_in = [i for i in range(1, n+1) if i not in cur]\n        if not_in:\n            j = random.choice(not_in)\n            nbr = cur + [j]\n            if total_weight(nbr) > capacity and len(cur) > 0:\n                # try swap: remove one random existing and add j\n                r = random.choice(cur)\n                nbr = [x for x in cur if x != r] + [j]\n                move_type = \"Swap\"\n            else:\n                move_type = \"Add\"\n        else:\n            # fallback to remove if full set\n            if len(cur) > 0:\n                i = random.choice(cur)\n                nbr = [x for x in cur if x != i]\n                move_type = \"Remove\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n    else:\n        # Swap between in and not-in if possible\n        if len(cur) > 0:\n            not_in = [i for i in range(1, n+1) if i not in cur]\n            if not_in:\n                r = random.choice(cur)\n                j = random.choice(not_in)\n                nbr = [x for x in cur if x != r] + [j]\n                move_type = \"Swap\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n        else:\n            # try add if empty\n            j = random.randrange(1, n+1)\n            nbr = [j]\n            move_type = \"Add\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, \"INDEX_LIST\", move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]):\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst: List[int]) -> int:\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst: List[int]) -> List[int]:\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1]))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = sorted(set(i for i in solution if isinstance(i, int) and 1 <= i <= n))\n\n    # Apply k random moves with feasible repair after\n    k = 5\n    nbr = cur[:]\n    for _ in range(k):\n        op = random.randrange(3)\n        if op == 0 and nbr:\n            # remove\n            r = random.choice(nbr)\n            nbr = [x for x in nbr if x != r]\n        elif op == 1:\n            # add\n            not_in = [i for i in range(1, n+1) if i not in nbr]\n            if not_in:\n                j = random.choice(not_in)\n                nbr.append(j)\n        else:\n            # swap\n            if nbr:\n                not_in = [i for i in range(1, n+1) if i not in nbr]\n                if not_in:\n                    r = random.choice(nbr)\n                    j = random.choice(not_in)\n                    nbr = [x for x in nbr if x != r] + [j]\n        nbr = repair_feasible(nbr)\n\n    return repair_feasible(nbr)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001068323}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric cost (lower is better). Feasible: -revenue. Infeasible: large penalty.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"INDEX_LIST\", movement_type)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Uniquify, bound-check, then drop lowest density until feasible\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        # stochastic tie-breaking among equal density to reduce bias\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur_set = set(cur)\n    cur = sorted(cur_set)\n\n    move_type = \"None\"\n\n    # Define candidate operations with probabilities\n    op = random.random()\n    nbr = cur[:]\n\n    # Precompute not-in list efficiently\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n\n    if op < 0.2 and cur:\n        # Remove 1\n        r = random.choice(cur)\n        nbr = [x for x in cur if x != r]\n        move_type = \"Remove1\"\n    elif op < 0.4:\n        # Add 1 (if full, fallback to remove)\n        if not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n    elif op < 0.6 and cur and not_in:\n        # Swap 1-1\n        r = random.choice(cur)\n        a = random.choice(not_in)\n        nbr = [x for x in cur if x != r] + [a]\n        move_type = \"Swap1\"\n    elif op < 0.8:\n        # Add2-Remove1 or Remove2-Add1 depending on feasibility\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            nbr_try = cur + adds\n            if total_weight(nbr_try) <= capacity or len(cur) >= 1:\n                if total_weight(nbr_try) <= capacity:\n                    nbr = nbr_try\n                    move_type = \"Add2\"\n                else:\n                    r = random.choice(cur) if cur else None\n                    if r is not None:\n                        nbr = [x for x in cur if x != r] + adds\n                        move_type = \"Add2Remove1\"\n                    else:\n                        nbr = cur[:]\n                        move_type = \"None\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n        elif len(cur) >= 2:\n            rs = random.sample(cur, 2)\n            nbr = [x for x in cur if x not in rs]\n            move_type = \"Remove2\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n    else:\n        # Swap2 (2-2 exchange) if possible, else fallback to single swap\/add\/remove\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rs = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rs] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            r = random.choice(cur)\n            a = random.choice(not_in)\n            nbr = [x for x in cur if x != r] + [a]\n            move_type = \"Swap1\"\n        elif not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, \"INDEX_LIST\", move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Multi-move random kick with feasible repair\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    # Intensity: proportional to problem size\n    k = max(3, n \/\/ 8)\n    nbr = cur[:]\n    for _ in range(k):\n        # Randomly choose among remove, add, swap\n        op = random.randrange(3)\n        in_set = set(nbr)\n        not_in = [i for i in range(1, n+1) if i not in in_set]\n        if op == 0 and nbr:\n            # remove\n            r = random.choice(nbr)\n            nbr = [x for x in nbr if x != r]\n        elif op == 1:\n            # add\n            if not_in:\n                a = random.choice(not_in)\n                nbr.append(a)\n        else:\n            # swap\n            if nbr and not_in:\n                r = random.choice(nbr)\n                a = random.choice(not_in)\n                nbr = [x for x in nbr if x != r] + [a]\n        nbr = repair_feasible(nbr)\n\n    return repair_feasible(nbr)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000945375}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric cost (lower is better). Feasible: -revenue. Infeasible: large penalty.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"INDEX_LIST\", movement_type)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Uniquify, bound-check, then drop lowest density until feasible\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        # stochastic tie-breaking among equal density to reduce bias\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur_set = set(cur)\n    cur = sorted(cur_set)\n\n    move_type = \"None\"\n\n    # Define candidate operations with probabilities\n    op = random.random()\n    nbr = cur[:]\n\n    # Precompute not-in list efficiently\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n\n    if op < 0.2 and cur:\n        # Remove 1\n        r = random.choice(cur)\n        nbr = [x for x in cur if x != r]\n        move_type = \"Remove1\"\n    elif op < 0.4:\n        # Add 1 (if full, fallback to remove)\n        if not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n    elif op < 0.6 and cur and not_in:\n        # Swap 1-1\n        r = random.choice(cur)\n        a = random.choice(not_in)\n        nbr = [x for x in cur if x != r] + [a]\n        move_type = \"Swap1\"\n    elif op < 0.8:\n        # Add2-Remove1 or Remove2-Add1 depending on feasibility\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            nbr_try = cur + adds\n            if total_weight(nbr_try) <= capacity or len(cur) >= 1:\n                if total_weight(nbr_try) <= capacity:\n                    nbr = nbr_try\n                    move_type = \"Add2\"\n                else:\n                    r = random.choice(cur) if cur else None\n                    if r is not None:\n                        nbr = [x for x in cur if x != r] + adds\n                        move_type = \"Add2Remove1\"\n                    else:\n                        nbr = cur[:]\n                        move_type = \"None\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n        elif len(cur) >= 2:\n            rs = random.sample(cur, 2)\n            nbr = [x for x in cur if x not in rs]\n            move_type = \"Remove2\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n    else:\n        # Swap2 (2-2 exchange) if possible, else fallback to single swap\/add\/remove\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rs = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rs] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            r = random.choice(cur)\n            a = random.choice(not_in)\n            nbr = [x for x in cur if x != r] + [a]\n            move_type = \"Swap1\"\n        elif not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, \"INDEX_LIST\", move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Multi-move random kick with feasible repair\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    # Intensity: proportional to problem size\n    k = max(3, n \/\/ 8)\n    nbr = cur[:]\n    for _ in range(k):\n        # Randomly choose among remove, add, swap\n        op = random.randrange(3)\n        in_set = set(nbr)\n        not_in = [i for i in range(1, n+1) if i not in in_set]\n        if op == 0 and nbr:\n            # remove\n            r = random.choice(nbr)\n            nbr = [x for x in nbr if x != r]\n        elif op == 1:\n            # add\n            if not_in:\n                a = random.choice(not_in)\n                nbr.append(a)\n        else:\n            # swap\n            if nbr and not_in:\n                r = random.choice(nbr)\n                a = random.choice(not_in)\n                nbr = [x for x in nbr if x != r] + [a]\n        nbr = repair_feasible(nbr)\n\n    return repair_feasible(nbr)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001233196}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric cost (lower is better). Feasible: -revenue. Infeasible: large penalty.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"INDEX_LIST\", movement_type)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Uniquify, bound-check, then drop lowest density until feasible\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        # stochastic tie-breaking among equal density to reduce bias\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur_set = set(cur)\n    cur = sorted(cur_set)\n\n    move_type = \"None\"\n\n    # Define candidate operations with probabilities\n    op = random.random()\n    nbr = cur[:]\n\n    # Precompute not-in list efficiently\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n\n    if op < 0.2 and cur:\n        # Remove 1\n        r = random.choice(cur)\n        nbr = [x for x in cur if x != r]\n        move_type = \"Remove1\"\n    elif op < 0.4:\n        # Add 1 (if full, fallback to remove)\n        if not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n    elif op < 0.6 and cur and not_in:\n        # Swap 1-1\n        r = random.choice(cur)\n        a = random.choice(not_in)\n        nbr = [x for x in cur if x != r] + [a]\n        move_type = \"Swap1\"\n    elif op < 0.8:\n        # Add2-Remove1 or Remove2-Add1 depending on feasibility\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            nbr_try = cur + adds\n            if total_weight(nbr_try) <= capacity or len(cur) >= 1:\n                if total_weight(nbr_try) <= capacity:\n                    nbr = nbr_try\n                    move_type = \"Add2\"\n                else:\n                    r = random.choice(cur) if cur else None\n                    if r is not None:\n                        nbr = [x for x in cur if x != r] + adds\n                        move_type = \"Add2Remove1\"\n                    else:\n                        nbr = cur[:]\n                        move_type = \"None\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n        elif len(cur) >= 2:\n            rs = random.sample(cur, 2)\n            nbr = [x for x in cur if x not in rs]\n            move_type = \"Remove2\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n    else:\n        # Swap2 (2-2 exchange) if possible, else fallback to single swap\/add\/remove\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rs = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rs] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            r = random.choice(cur)\n            a = random.choice(not_in)\n            nbr = [x for x in cur if x != r] + [a]\n            move_type = \"Swap1\"\n        elif not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, \"INDEX_LIST\", move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Multi-move random kick with feasible repair\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    # Intensity: proportional to problem size\n    k = max(3, n \/\/ 8)\n    nbr = cur[:]\n    for _ in range(k):\n        # Randomly choose among remove, add, swap\n        op = random.randrange(3)\n        in_set = set(nbr)\n        not_in = [i for i in range(1, n+1) if i not in in_set]\n        if op == 0 and nbr:\n            # remove\n            r = random.choice(nbr)\n            nbr = [x for x in nbr if x != r]\n        elif op == 1:\n            # add\n            if not_in:\n                a = random.choice(not_in)\n                nbr.append(a)\n        else:\n            # swap\n            if nbr and not_in:\n                r = random.choice(nbr)\n                a = random.choice(not_in)\n                nbr = [x for x in nbr if x != r] + [a]\n        nbr = repair_feasible(nbr)\n\n    return repair_feasible(nbr)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001160286}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Maximize total price with capacity constraint; return cost (lower is better)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type) with INDEX_LIST representation\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Enforce INDEX_LIST canonical form: unique, in-range, sorted asc\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        # Deterministic removal by lowest density, tie-break by price, weight, index\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    cur_set = set(cur)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n    r = random.random()\n\n    if r < 0.2 and cur:\n        # Remove 1\n        rem = random.choice(cur)\n        nbr = [x for x in cur if x != rem]\n        move_type = \"Remove1\"\n    elif r < 0.4:\n        # Add 1 or fallback remove\n        if not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n    elif r < 0.6 and cur and not_in:\n        # Swap 1-1\n        rem = random.choice(cur)\n        add = random.choice(not_in)\n        nbr = [x for x in cur if x != rem] + [add]\n        move_type = \"Swap1\"\n    elif r < 0.8:\n        # Add2, Remove2, or Add2Remove1\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            trial = cur + adds\n            if total_weight(trial) <= capacity:\n                nbr = trial\n                move_type = \"Add2\"\n            elif cur:\n                rem = random.choice(cur)\n                nbr = [x for x in cur if x != rem] + adds\n                move_type = \"Add2Remove1\"\n        elif len(cur) >= 2:\n            rems = set(random.sample(cur, 2))\n            nbr = [x for x in cur if x not in rems]\n            move_type = \"Remove2\"\n    else:\n        # Swap2 if possible, else fallback\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rems = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rems] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            rem = random.choice(cur)\n            add = random.choice(not_in)\n            nbr = [x for x in cur if x != rem] + [add]\n            move_type = \"Swap1\"\n        elif not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Deterministic kick based on densities, then greedy refill\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    # Remove k lowest-density items deterministically\n    k = max(3, n \/\/ 8)\n    densities = {i: prices[i-1] \/ gallons[i-1] for i in cur}\n    rm_order = sorted(cur, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(k, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n    base = repair_feasible(base)\n\n    # Greedy refill by highest density among items not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    densities_all = {i: prices[i-1] \/ gallons[i-1] for i in candidates}\n    # Sort by descending density, tie-break by higher price, lower weight, then lower index\n    cand_sorted = sorted(candidates, key=lambda i: (-densities_all[i], -prices[i-1], gallons[i-1], i))\n\n    w = total_weight(base)\n    sol = list(base)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    return sorted(set(sol))\n","Resultados":[[1,2,3,4,7,8,9,10,11,12,14,15,16,17,18,20,21,22,23,24],-247.0,[1,2,3,4,7,8,10,11,12,14,15,17,18,19,20,21,22,23,24],-259.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001382609}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Maximize total price with capacity constraint; return cost (lower is better)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type) with INDEX_LIST representation\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Enforce INDEX_LIST canonical form: unique, in-range, sorted asc\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        # Deterministic removal by lowest density, tie-break by price, weight, index\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    cur_set = set(cur)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n    r = random.random()\n\n    if r < 0.2 and cur:\n        # Remove 1\n        rem = random.choice(cur)\n        nbr = [x for x in cur if x != rem]\n        move_type = \"Remove1\"\n    elif r < 0.4:\n        # Add 1 or fallback remove\n        if not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n    elif r < 0.6 and cur and not_in:\n        # Swap 1-1\n        rem = random.choice(cur)\n        add = random.choice(not_in)\n        nbr = [x for x in cur if x != rem] + [add]\n        move_type = \"Swap1\"\n    elif r < 0.8:\n        # Add2, Remove2, or Add2Remove1\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            trial = cur + adds\n            if total_weight(trial) <= capacity:\n                nbr = trial\n                move_type = \"Add2\"\n            elif cur:\n                rem = random.choice(cur)\n                nbr = [x for x in cur if x != rem] + adds\n                move_type = \"Add2Remove1\"\n        elif len(cur) >= 2:\n            rems = set(random.sample(cur, 2))\n            nbr = [x for x in cur if x not in rems]\n            move_type = \"Remove2\"\n    else:\n        # Swap2 if possible, else fallback\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rems = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rems] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            rem = random.choice(cur)\n            add = random.choice(not_in)\n            nbr = [x for x in cur if x != rem] + [add]\n            move_type = \"Swap1\"\n        elif not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Deterministic kick based on densities, then greedy refill\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    # Remove k lowest-density items deterministically\n    k = max(3, n \/\/ 8)\n    densities = {i: prices[i-1] \/ gallons[i-1] for i in cur}\n    rm_order = sorted(cur, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(k, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n    base = repair_feasible(base)\n\n    # Greedy refill by highest density among items not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    densities_all = {i: prices[i-1] \/ gallons[i-1] for i in candidates}\n    # Sort by descending density, tie-break by higher price, lower weight, then lower index\n    cand_sorted = sorted(candidates, key=lambda i: (-densities_all[i], -prices[i-1], gallons[i-1], i))\n\n    w = total_weight(base)\n    sol = list(base)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    return sorted(set(sol))\n","Resultados":[[1,2,3,4,6,7,8,10,11,12,14,15,16,17,18,19,20,22,23,24],-47.0,[1,2,3,4,6,7,8,10,11,12,14,15,16,17,18,19,20,22,23,24],-268.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.002570827}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Maximize total price with capacity constraint; return cost (lower is better)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type) with INDEX_LIST representation\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Enforce INDEX_LIST canonical form: unique, in-range, sorted asc\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        # Deterministic removal by lowest density, tie-break by price, weight, index\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    cur_set = set(cur)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n    r = random.random()\n\n    if r < 0.2 and cur:\n        # Remove 1\n        rem = random.choice(cur)\n        nbr = [x for x in cur if x != rem]\n        move_type = \"Remove1\"\n    elif r < 0.4:\n        # Add 1 or fallback remove\n        if not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n    elif r < 0.6 and cur and not_in:\n        # Swap 1-1\n        rem = random.choice(cur)\n        add = random.choice(not_in)\n        nbr = [x for x in cur if x != rem] + [add]\n        move_type = \"Swap1\"\n    elif r < 0.8:\n        # Add2, Remove2, or Add2Remove1\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            trial = cur + adds\n            if total_weight(trial) <= capacity:\n                nbr = trial\n                move_type = \"Add2\"\n            elif cur:\n                rem = random.choice(cur)\n                nbr = [x for x in cur if x != rem] + adds\n                move_type = \"Add2Remove1\"\n        elif len(cur) >= 2:\n            rems = set(random.sample(cur, 2))\n            nbr = [x for x in cur if x not in rems]\n            move_type = \"Remove2\"\n    else:\n        # Swap2 if possible, else fallback\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rems = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rems] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            rem = random.choice(cur)\n            add = random.choice(not_in)\n            nbr = [x for x in cur if x != rem] + [add]\n            move_type = \"Swap1\"\n        elif not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Deterministic kick based on densities, then greedy refill\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    # Remove k lowest-density items deterministically\n    k = max(3, n \/\/ 8)\n    densities = {i: prices[i-1] \/ gallons[i-1] for i in cur}\n    rm_order = sorted(cur, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(k, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n    base = repair_feasible(base)\n\n    # Greedy refill by highest density among items not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    densities_all = {i: prices[i-1] \/ gallons[i-1] for i in candidates}\n    # Sort by descending density, tie-break by higher price, lower weight, then lower index\n    cand_sorted = sorted(candidates, key=lambda i: (-densities_all[i], -prices[i-1], gallons[i-1], i))\n\n    w = total_weight(base)\n    sol = list(base)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    return sorted(set(sol))\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001174618}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # INDEX_LIST representation: list of 1-based indices\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-break encoded as tiny offset to the cost\n        # Compute a bounded lex key in (0,1) where lexicographically smaller list has smaller key\n        lex_key = 0.0\n        base = 100.0  # base large enough to separate digits\n        for pos, idx in enumerate(solution):\n            lex_key += idx \/ (base ** (pos + 1))\n        # Lower is better: cost = -revenue + eps * lex_key\n        return -float(revenue) + 1e-9 * lex_key\n\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic, feasibility-preserving neighborhood on INDEX_LIST\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    # Canonicalize current solution\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    in_set = set(cur)\n\n    # Deterministic RNG seeded by current solution state\n    seed_val = 1469598103934665603  # FNV offset basis\n    for x in cur:\n        seed_val ^= x + 0x9e3779b97f4a7c15\n        seed_val = (seed_val * 1099511628211) & ((1 << 64) - 1)\n    rng = random.Random(seed_val)\n\n    # Precompute helpers\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def canonical(lst):\n        return sorted(set(lst))\n\n    w_cur = total_weight(cur)\n    slack = capacity - w_cur\n\n    # Density and candidate lists\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n    not_in = [i for i in range(1, n+1) if i not in in_set]\n\n    # Sort helpers with deterministic tie-breaks\n    def sort_in_items(lst):\n        return sorted(lst, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))  # ascending density (worst first)\n\n    def sort_out_items_desc(lst):\n        return sorted(lst, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))  # descending density (best first)\n\n    worst_in = sort_in_items(cur)\n    best_out = sort_out_items_desc(not_in)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    # Utility to evaluate delta revenue for a prospective move\n    def delta_rev(adds, rems):\n        return sum(prices[i-1] for i in adds) - sum(prices[i-1] for i in rems)\n\n    r = rng.random()\n\n    # Attempt Add1 of best fitting item\n    if r < 0.3:\n        for j in best_out:\n            wj = gallons[j-1]\n            if slack >= wj:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        # If no add fits, try 1-for-1 targeted swap that increases revenue\n        best_gain = -1e18\n        best_pair = None\n        # Limit search windows for efficiency\n        cand_in = worst_in[:min(10, len(worst_in))]\n        cand_out = best_out[:min(14, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: remove worst to free capacity\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # Swap1: best improving or least-worse feasible swap within candidate lists\n    elif r < 0.6:\n        best_gain = -1e18\n        best_pair = None\n        cand_in = worst_in[:min(12, len(worst_in))]\n        cand_out = best_out[:min(16, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: Add1 if possible else Remove1\n        for j in best_out:\n            if slack >= gallons[j-1]:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 2-for-1 targeted ejection chain\n    elif r < 0.8 and len(cur) >= 2 and best_out:\n        cand_in = worst_in[:min(8, len(worst_in))]\n        # Precompute pair weights and prices\n        pairs = []\n        L = len(cand_in)\n        for a in range(L):\n            for b in range(a+1, L):\n                i1, i2 = cand_in[a], cand_in[b]\n                pairs.append((i1, i2, gallons[i1-1] + gallons[i2-1], prices[i1-1] + prices[i2-1]))\n        best_gain = -1e18\n        best_tuple = None\n        for j in best_out[:min(16, len(best_out))]:\n            wj = gallons[j-1]\n            pj = prices[j-1]\n            for (i1, i2, w12, p12) in pairs:\n                if slack + w12 >= wj:\n                    gain = pj - p12\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i1, i2) < best_tuple):\n                        best_gain = gain\n                        best_tuple = (j, i1, i2)\n        if best_tuple is not None:\n            j, i1, i2 = best_tuple\n            base = [x for x in cur if x not in (i1, i2)]\n            nbr = canonical(base + [j])\n            move_type = \"Swap2for1\"\n            return (nbr, move_type)\n        # Fallback: Remove1 of worst\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 1-for-2 targeted chain (if there is slack to allow two adds after one removal)\n    if cur and len(best_out) >= 2:\n        cand_out = best_out[:min(14, len(best_out))]\n        cand_in = worst_in[:min(8, len(worst_in))]\n        best_gain = -1e18\n        best_move = None\n        for i in cand_in:\n            wi = gallons[i-1]\n            pi = prices[i-1]\n            # two adds j,k with j<k in candidate list\n            for a in range(len(cand_out)):\n                j = cand_out[a]\n                wj = gallons[j-1]\n                pj = prices[j-1]\n                for b in range(a+1, len(cand_out)):\n                    k = cand_out[b]\n                    wk = gallons[k-1]\n                    pk = prices[k-1]\n                    if slack + wi >= wj + wk:\n                        gain = (pj + pk) - pi\n                        if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, k, i) < best_move):\n                            best_gain = gain\n                            best_move = (j, k, i)\n        if best_move is not None:\n            j, k, i = best_move\n            base = [x for x in cur if x != i]\n            nbr = canonical(base + [j, k])\n            move_type = \"Swap1for2\"\n            return (nbr, move_type)\n\n    # Final fallback: if nothing else triggered, try best Add1 else Remove1\n    for j in best_out:\n        if slack >= gallons[j-1]:\n            nbr = canonical(cur + [j])\n            move_type = \"Add1\"\n            return (nbr, move_type)\n    if cur:\n        i = worst_in[0]\n        nbr = canonical([x for x in cur if x != i])\n        move_type = \"Remove1\"\n        return (nbr, move_type)\n\n    # If empty and nothing to add (shouldn't happen), return as is\n    return (cur, \"None\")\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    # Deterministic ruin-and-recreate based on densities with lexicographic tie-breaks\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n\n    # Remove r lowest-density items (deterministic order)\n    r = max(3, n \/\/ 6)\n    rm_order = sorted(cur, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(r, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n\n    # Greedy refill by highest density not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    cand_sorted = sorted(candidates, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))\n\n    # Pack while capacity allows\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    sol = sorted(set(base))\n    w = total_weight(sol)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    sol = sorted(set(sol))\n    # Ensure feasibility (should be by construction)\n    if total_weight(sol) <= capacity:\n        return sol\n    # If any rounding issue, trim by lowest density until feasible\n    trim = sorted(sol, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    keep = set(sol)\n    w = total_weight(sol)\n    for i in trim:\n        if w <= capacity:\n            break\n        if i in keep:\n            keep.remove(i)\n            w -= gallons[i-1]\n    return sorted(keep)\n","Resultados":[[1,2,3,4,6,8,10,11,12,14,15,16,17,18,19,20,21,22,23,24],-269.0,[1,2,3,4,6,8,10,11,12,14,15,16,17,18,19,20,21,22,23,24],-269.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.002983483}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # INDEX_LIST representation: list of 1-based indices\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-break encoded as tiny offset to the cost\n        # Compute a bounded lex key in (0,1) where lexicographically smaller list has smaller key\n        lex_key = 0.0\n        base = 100.0  # base large enough to separate digits\n        for pos, idx in enumerate(solution):\n            lex_key += idx \/ (base ** (pos + 1))\n        # Lower is better: cost = -revenue + eps * lex_key\n        return -float(revenue) + 1e-9 * lex_key\n\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic, feasibility-preserving neighborhood on INDEX_LIST\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    # Canonicalize current solution\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    in_set = set(cur)\n\n    # Deterministic RNG seeded by current solution state\n    seed_val = 1469598103934665603  # FNV offset basis\n    for x in cur:\n        seed_val ^= x + 0x9e3779b97f4a7c15\n        seed_val = (seed_val * 1099511628211) & ((1 << 64) - 1)\n    rng = random.Random(seed_val)\n\n    # Precompute helpers\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def canonical(lst):\n        return sorted(set(lst))\n\n    w_cur = total_weight(cur)\n    slack = capacity - w_cur\n\n    # Density and candidate lists\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n    not_in = [i for i in range(1, n+1) if i not in in_set]\n\n    # Sort helpers with deterministic tie-breaks\n    def sort_in_items(lst):\n        return sorted(lst, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))  # ascending density (worst first)\n\n    def sort_out_items_desc(lst):\n        return sorted(lst, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))  # descending density (best first)\n\n    worst_in = sort_in_items(cur)\n    best_out = sort_out_items_desc(not_in)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    # Utility to evaluate delta revenue for a prospective move\n    def delta_rev(adds, rems):\n        return sum(prices[i-1] for i in adds) - sum(prices[i-1] for i in rems)\n\n    r = rng.random()\n\n    # Attempt Add1 of best fitting item\n    if r < 0.3:\n        for j in best_out:\n            wj = gallons[j-1]\n            if slack >= wj:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        # If no add fits, try 1-for-1 targeted swap that increases revenue\n        best_gain = -1e18\n        best_pair = None\n        # Limit search windows for efficiency\n        cand_in = worst_in[:min(10, len(worst_in))]\n        cand_out = best_out[:min(14, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: remove worst to free capacity\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # Swap1: best improving or least-worse feasible swap within candidate lists\n    elif r < 0.6:\n        best_gain = -1e18\n        best_pair = None\n        cand_in = worst_in[:min(12, len(worst_in))]\n        cand_out = best_out[:min(16, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: Add1 if possible else Remove1\n        for j in best_out:\n            if slack >= gallons[j-1]:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 2-for-1 targeted ejection chain\n    elif r < 0.8 and len(cur) >= 2 and best_out:\n        cand_in = worst_in[:min(8, len(worst_in))]\n        # Precompute pair weights and prices\n        pairs = []\n        L = len(cand_in)\n        for a in range(L):\n            for b in range(a+1, L):\n                i1, i2 = cand_in[a], cand_in[b]\n                pairs.append((i1, i2, gallons[i1-1] + gallons[i2-1], prices[i1-1] + prices[i2-1]))\n        best_gain = -1e18\n        best_tuple = None\n        for j in best_out[:min(16, len(best_out))]:\n            wj = gallons[j-1]\n            pj = prices[j-1]\n            for (i1, i2, w12, p12) in pairs:\n                if slack + w12 >= wj:\n                    gain = pj - p12\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i1, i2) < best_tuple):\n                        best_gain = gain\n                        best_tuple = (j, i1, i2)\n        if best_tuple is not None:\n            j, i1, i2 = best_tuple\n            base = [x for x in cur if x not in (i1, i2)]\n            nbr = canonical(base + [j])\n            move_type = \"Swap2for1\"\n            return (nbr, move_type)\n        # Fallback: Remove1 of worst\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 1-for-2 targeted chain (if there is slack to allow two adds after one removal)\n    if cur and len(best_out) >= 2:\n        cand_out = best_out[:min(14, len(best_out))]\n        cand_in = worst_in[:min(8, len(worst_in))]\n        best_gain = -1e18\n        best_move = None\n        for i in cand_in:\n            wi = gallons[i-1]\n            pi = prices[i-1]\n            # two adds j,k with j<k in candidate list\n            for a in range(len(cand_out)):\n                j = cand_out[a]\n                wj = gallons[j-1]\n                pj = prices[j-1]\n                for b in range(a+1, len(cand_out)):\n                    k = cand_out[b]\n                    wk = gallons[k-1]\n                    pk = prices[k-1]\n                    if slack + wi >= wj + wk:\n                        gain = (pj + pk) - pi\n                        if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, k, i) < best_move):\n                            best_gain = gain\n                            best_move = (j, k, i)\n        if best_move is not None:\n            j, k, i = best_move\n            base = [x for x in cur if x != i]\n            nbr = canonical(base + [j, k])\n            move_type = \"Swap1for2\"\n            return (nbr, move_type)\n\n    # Final fallback: if nothing else triggered, try best Add1 else Remove1\n    for j in best_out:\n        if slack >= gallons[j-1]:\n            nbr = canonical(cur + [j])\n            move_type = \"Add1\"\n            return (nbr, move_type)\n    if cur:\n        i = worst_in[0]\n        nbr = canonical([x for x in cur if x != i])\n        move_type = \"Remove1\"\n        return (nbr, move_type)\n\n    # If empty and nothing to add (shouldn't happen), return as is\n    return (cur, \"None\")\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    # Deterministic ruin-and-recreate based on densities with lexicographic tie-breaks\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n\n    # Remove r lowest-density items (deterministic order)\n    r = max(3, n \/\/ 6)\n    rm_order = sorted(cur, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(r, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n\n    # Greedy refill by highest density not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    cand_sorted = sorted(candidates, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))\n\n    # Pack while capacity allows\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    sol = sorted(set(base))\n    w = total_weight(sol)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    sol = sorted(set(sol))\n    # Ensure feasibility (should be by construction)\n    if total_weight(sol) <= capacity:\n        return sol\n    # If any rounding issue, trim by lowest density until feasible\n    trim = sorted(sol, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    keep = set(sol)\n    w = total_weight(sol)\n    for i in trim:\n        if w <= capacity:\n            break\n        if i in keep:\n            keep.remove(i)\n            w -= gallons[i-1]\n    return sorted(keep)\n","Resultados":[[1,2,3,4,6,8,10,11,12,14,15,16,17,18,19,20,21,22,23,24],-253.0,[1,2,3,4,6,8,10,11,12,14,15,16,17,18,19,20,21,22,23,24],-269.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0038146389}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # INDEX_LIST representation: list of 1-based indices\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-break encoded as tiny offset to the cost\n        # Compute a bounded lex key in (0,1) where lexicographically smaller list has smaller key\n        lex_key = 0.0\n        base = 100.0  # base large enough to separate digits\n        for pos, idx in enumerate(solution):\n            lex_key += idx \/ (base ** (pos + 1))\n        # Lower is better: cost = -revenue + eps * lex_key\n        return -float(revenue) + 1e-9 * lex_key\n\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic, feasibility-preserving neighborhood on INDEX_LIST\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    # Canonicalize current solution\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    in_set = set(cur)\n\n    # Deterministic RNG seeded by current solution state\n    seed_val = 1469598103934665603  # FNV offset basis\n    for x in cur:\n        seed_val ^= x + 0x9e3779b97f4a7c15\n        seed_val = (seed_val * 1099511628211) & ((1 << 64) - 1)\n    rng = random.Random(seed_val)\n\n    # Precompute helpers\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def canonical(lst):\n        return sorted(set(lst))\n\n    w_cur = total_weight(cur)\n    slack = capacity - w_cur\n\n    # Density and candidate lists\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n    not_in = [i for i in range(1, n+1) if i not in in_set]\n\n    # Sort helpers with deterministic tie-breaks\n    def sort_in_items(lst):\n        return sorted(lst, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))  # ascending density (worst first)\n\n    def sort_out_items_desc(lst):\n        return sorted(lst, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))  # descending density (best first)\n\n    worst_in = sort_in_items(cur)\n    best_out = sort_out_items_desc(not_in)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    # Utility to evaluate delta revenue for a prospective move\n    def delta_rev(adds, rems):\n        return sum(prices[i-1] for i in adds) - sum(prices[i-1] for i in rems)\n\n    r = rng.random()\n\n    # Attempt Add1 of best fitting item\n    if r < 0.3:\n        for j in best_out:\n            wj = gallons[j-1]\n            if slack >= wj:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        # If no add fits, try 1-for-1 targeted swap that increases revenue\n        best_gain = -1e18\n        best_pair = None\n        # Limit search windows for efficiency\n        cand_in = worst_in[:min(10, len(worst_in))]\n        cand_out = best_out[:min(14, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: remove worst to free capacity\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # Swap1: best improving or least-worse feasible swap within candidate lists\n    elif r < 0.6:\n        best_gain = -1e18\n        best_pair = None\n        cand_in = worst_in[:min(12, len(worst_in))]\n        cand_out = best_out[:min(16, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: Add1 if possible else Remove1\n        for j in best_out:\n            if slack >= gallons[j-1]:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 2-for-1 targeted ejection chain\n    elif r < 0.8 and len(cur) >= 2 and best_out:\n        cand_in = worst_in[:min(8, len(worst_in))]\n        # Precompute pair weights and prices\n        pairs = []\n        L = len(cand_in)\n        for a in range(L):\n            for b in range(a+1, L):\n                i1, i2 = cand_in[a], cand_in[b]\n                pairs.append((i1, i2, gallons[i1-1] + gallons[i2-1], prices[i1-1] + prices[i2-1]))\n        best_gain = -1e18\n        best_tuple = None\n        for j in best_out[:min(16, len(best_out))]:\n            wj = gallons[j-1]\n            pj = prices[j-1]\n            for (i1, i2, w12, p12) in pairs:\n                if slack + w12 >= wj:\n                    gain = pj - p12\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i1, i2) < best_tuple):\n                        best_gain = gain\n                        best_tuple = (j, i1, i2)\n        if best_tuple is not None:\n            j, i1, i2 = best_tuple\n            base = [x for x in cur if x not in (i1, i2)]\n            nbr = canonical(base + [j])\n            move_type = \"Swap2for1\"\n            return (nbr, move_type)\n        # Fallback: Remove1 of worst\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 1-for-2 targeted chain (if there is slack to allow two adds after one removal)\n    if cur and len(best_out) >= 2:\n        cand_out = best_out[:min(14, len(best_out))]\n        cand_in = worst_in[:min(8, len(worst_in))]\n        best_gain = -1e18\n        best_move = None\n        for i in cand_in:\n            wi = gallons[i-1]\n            pi = prices[i-1]\n            # two adds j,k with j<k in candidate list\n            for a in range(len(cand_out)):\n                j = cand_out[a]\n                wj = gallons[j-1]\n                pj = prices[j-1]\n                for b in range(a+1, len(cand_out)):\n                    k = cand_out[b]\n                    wk = gallons[k-1]\n                    pk = prices[k-1]\n                    if slack + wi >= wj + wk:\n                        gain = (pj + pk) - pi\n                        if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, k, i) < best_move):\n                            best_gain = gain\n                            best_move = (j, k, i)\n        if best_move is not None:\n            j, k, i = best_move\n            base = [x for x in cur if x != i]\n            nbr = canonical(base + [j, k])\n            move_type = \"Swap1for2\"\n            return (nbr, move_type)\n\n    # Final fallback: if nothing else triggered, try best Add1 else Remove1\n    for j in best_out:\n        if slack >= gallons[j-1]:\n            nbr = canonical(cur + [j])\n            move_type = \"Add1\"\n            return (nbr, move_type)\n    if cur:\n        i = worst_in[0]\n        nbr = canonical([x for x in cur if x != i])\n        move_type = \"Remove1\"\n        return (nbr, move_type)\n\n    # If empty and nothing to add (shouldn't happen), return as is\n    return (cur, \"None\")\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    # Deterministic ruin-and-recreate based on densities with lexicographic tie-breaks\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n\n    # Remove r lowest-density items (deterministic order)\n    r = max(3, n \/\/ 6)\n    rm_order = sorted(cur, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(r, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n\n    # Greedy refill by highest density not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    cand_sorted = sorted(candidates, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))\n\n    # Pack while capacity allows\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    sol = sorted(set(base))\n    w = total_weight(sol)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    sol = sorted(set(sol))\n    # Ensure feasibility (should be by construction)\n    if total_weight(sol) <= capacity:\n        return sol\n    # If any rounding issue, trim by lowest density until feasible\n    trim = sorted(sol, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    keep = set(sol)\n    w = total_weight(sol)\n    for i in trim:\n        if w <= capacity:\n            break\n        if i in keep:\n            keep.remove(i)\n            w -= gallons[i-1]\n    return sorted(keep)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001646252}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST (1-based). A solution is a list\/tuple of unique integers in [1,24], each integer denotes selecting that item.","Evaluacion":"import math\nfrom typing import Sequence\n\ndef evaluate_solution(solution: Sequence[int]) -> float:\n    # Validate representation: INDEX_LIST (1-based)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    # Problem data (embedded)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1  # map to 0-based\n        total_time += times[j]\n        total_value += values[j]\n    # Feasibility and fitness (minimization cost; negatives for maximization)\n    if total_time > capacity:\n        return float(10**9)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple, Sequence\n\ndef generate_neighbour(solution: Sequence[int]) -> Tuple[Sequence[int], str, str]:\n    # Representation: INDEX_LIST (1-based). Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"INPUT_ERROR\")\n\n    sel = set(current)\n    all_items = set(range(1, n+1))\n    unsel = list(all_items - sel)\n    current_list = list(sel)\n\n    if not current_list and unsel:\n        # If empty, must add\n        add_item = random.choice(unsel)\n        neighbor = [add_item]\n        return neighbor, \"add\", \"single\"\n\n    move = random.random()\n    # Prefer swap when both sides exist; otherwise fall back to add\/drop\n    if current_list and unsel and move < 0.5:\n        a = random.choice(current_list)\n        b = random.choice(unsel)\n        neighbor = [x for x in current_list if x != a]\n        neighbor.append(b)\n        neighbor.sort()\n        return neighbor, \"swap\", \"1-1\"\n    elif unsel and move < 0.75:\n        b = random.choice(unsel)\n        neighbor = current_list + [b]\n        neighbor.sort()\n        return neighbor, \"add\", \"single\"\n    else:\n        # drop if possible; if not, force add\n        if current_list:\n            a = random.choice(current_list)\n            neighbor = [x for x in current_list if x != a]\n            neighbor.sort()\n            return neighbor, \"drop\", \"single\"\n        else:\n            b = random.choice(unsel) if unsel else None\n            neighbor = [b] if b is not None else []\n            return neighbor, \"add\", \"single\"\n","Perturbacion":"import random\nfrom typing import Sequence, List\n\ndef perturb_solution(solution: Sequence[int]) -> Sequence[int]:\n    # Multi-move random perturbation preserving INDEX_LIST validity\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"INPUT_ERROR\")\n\n    sel = set(current)\n    all_items = set(range(1, n+1))\n\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        unsel = list(all_items - sel)\n        move_type = random.random()\n        if sel and unsel and move_type < 0.5:\n            # swap 1-1\n            a = random.choice(list(sel))\n            b = random.choice(unsel)\n            sel.remove(a)\n            sel.add(b)\n        elif unsel and move_type < 0.8:\n            # add\n            b = random.choice(unsel)\n            sel.add(b)\n        elif sel:\n            # drop\n            a = random.choice(list(sel))\n            sel.remove(a)\n        # else: nothing to do when both empty cases, which cannot happen given domain\n    result = sorted(sel)\n    return result\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Sequence() takes no arguments","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0008189781}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST (1-based). A solution is a list\/tuple of unique integers in [1,24], each integer denotes selecting that item.","Evaluacion":"import math\nfrom typing import Sequence\n\ndef evaluate_solution(solution: Sequence[int]) -> float:\n    # Validate representation: INDEX_LIST (1-based)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    # Problem data (embedded)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1  # map to 0-based\n        total_time += times[j]\n        total_value += values[j]\n    # Feasibility and fitness (minimization cost; negatives for maximization)\n    if total_time > capacity:\n        return float(10**9)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple, Sequence\n\ndef generate_neighbour(solution: Sequence[int]) -> Tuple[Sequence[int], str, str]:\n    # Representation: INDEX_LIST (1-based). Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"INPUT_ERROR\")\n\n    sel = set(current)\n    all_items = set(range(1, n+1))\n    unsel = list(all_items - sel)\n    current_list = list(sel)\n\n    if not current_list and unsel:\n        # If empty, must add\n        add_item = random.choice(unsel)\n        neighbor = [add_item]\n        return neighbor, \"add\", \"single\"\n\n    move = random.random()\n    # Prefer swap when both sides exist; otherwise fall back to add\/drop\n    if current_list and unsel and move < 0.5:\n        a = random.choice(current_list)\n        b = random.choice(unsel)\n        neighbor = [x for x in current_list if x != a]\n        neighbor.append(b)\n        neighbor.sort()\n        return neighbor, \"swap\", \"1-1\"\n    elif unsel and move < 0.75:\n        b = random.choice(unsel)\n        neighbor = current_list + [b]\n        neighbor.sort()\n        return neighbor, \"add\", \"single\"\n    else:\n        # drop if possible; if not, force add\n        if current_list:\n            a = random.choice(current_list)\n            neighbor = [x for x in current_list if x != a]\n            neighbor.sort()\n            return neighbor, \"drop\", \"single\"\n        else:\n            b = random.choice(unsel) if unsel else None\n            neighbor = [b] if b is not None else []\n            return neighbor, \"add\", \"single\"\n","Perturbacion":"import random\nfrom typing import Sequence, List\n\ndef perturb_solution(solution: Sequence[int]) -> Sequence[int]:\n    # Multi-move random perturbation preserving INDEX_LIST validity\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"INPUT_ERROR\")\n\n    sel = set(current)\n    all_items = set(range(1, n+1))\n\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        unsel = list(all_items - sel)\n        move_type = random.random()\n        if sel and unsel and move_type < 0.5:\n            # swap 1-1\n            a = random.choice(list(sel))\n            b = random.choice(unsel)\n            sel.remove(a)\n            sel.add(b)\n        elif unsel and move_type < 0.8:\n            # add\n            b = random.choice(unsel)\n            sel.add(b)\n        elif sel:\n            # drop\n            a = random.choice(list(sel))\n            sel.remove(a)\n        # else: nothing to do when both empty cases, which cannot happen given domain\n    result = sorted(sel)\n    return result\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Sequence() takes no arguments","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000801568}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST (1-based). A solution is a list\/tuple of unique integers in [1,24], each integer denotes selecting that item.","Evaluacion":"import math\nfrom typing import Sequence\n\ndef evaluate_solution(solution: Sequence[int]) -> float:\n    # Validate representation: INDEX_LIST (1-based)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"INPUT_ERROR\")\n    # Problem data (embedded)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"INPUT_ERROR\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1  # map to 0-based\n        total_time += times[j]\n        total_value += values[j]\n    # Feasibility and fitness (minimization cost; negatives for maximization)\n    if total_time > capacity:\n        return float(10**9)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple, Sequence\n\ndef generate_neighbour(solution: Sequence[int]) -> Tuple[Sequence[int], str, str]:\n    # Representation: INDEX_LIST (1-based). Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"INPUT_ERROR\")\n\n    sel = set(current)\n    all_items = set(range(1, n+1))\n    unsel = list(all_items - sel)\n    current_list = list(sel)\n\n    if not current_list and unsel:\n        # If empty, must add\n        add_item = random.choice(unsel)\n        neighbor = [add_item]\n        return neighbor, \"add\", \"single\"\n\n    move = random.random()\n    # Prefer swap when both sides exist; otherwise fall back to add\/drop\n    if current_list and unsel and move < 0.5:\n        a = random.choice(current_list)\n        b = random.choice(unsel)\n        neighbor = [x for x in current_list if x != a]\n        neighbor.append(b)\n        neighbor.sort()\n        return neighbor, \"swap\", \"1-1\"\n    elif unsel and move < 0.75:\n        b = random.choice(unsel)\n        neighbor = current_list + [b]\n        neighbor.sort()\n        return neighbor, \"add\", \"single\"\n    else:\n        # drop if possible; if not, force add\n        if current_list:\n            a = random.choice(current_list)\n            neighbor = [x for x in current_list if x != a]\n            neighbor.sort()\n            return neighbor, \"drop\", \"single\"\n        else:\n            b = random.choice(unsel) if unsel else None\n            neighbor = [b] if b is not None else []\n            return neighbor, \"add\", \"single\"\n","Perturbacion":"import random\nfrom typing import Sequence, List\n\ndef perturb_solution(solution: Sequence[int]) -> Sequence[int]:\n    # Multi-move random perturbation preserving INDEX_LIST validity\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"INPUT_ERROR\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"INPUT_ERROR\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"INPUT_ERROR\")\n    n = 24\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"INPUT_ERROR\")\n\n    sel = set(current)\n    all_items = set(range(1, n+1))\n\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        unsel = list(all_items - sel)\n        move_type = random.random()\n        if sel and unsel and move_type < 0.5:\n            # swap 1-1\n            a = random.choice(list(sel))\n            b = random.choice(unsel)\n            sel.remove(a)\n            sel.add(b)\n        elif unsel and move_type < 0.8:\n            # add\n            b = random.choice(unsel)\n            sel.add(b)\n        elif sel:\n            # drop\n            a = random.choice(list(sel))\n            sel.remove(a)\n        # else: nothing to do when both empty cases, which cannot happen given domain\n    result = sorted(sel)\n    return result\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Sequence() takes no arguments","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000774477}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list\/tuple of unique integers in [1,24], each integer denotes selecting that item.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Validate representation: INDEX_LIST (1-based)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Problem data (embedded)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1  # map to 0-based\n        total_time += times[j]\n        total_value += values[j]\n    # Feasibility and fitness (minimization cost; negatives for maximization)\n    if total_time > capacity:\n        excess = total_time - capacity\n        base_pen = 1_000_000.0\n        lam = 1000.0\n        return float(base_pen + lam * excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import Any, List, Tuple\n\ndef generate_neighbour(solution: Any) -> Tuple[List[int], str, str]:\n    # Representation: INDEX_LIST (1-based). Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel_set = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel_set)\n\n    # Compute current load and value\n    total_time = sum(times[i-1] for i in sel_set)\n    # total_value not needed for feasibility\n\n    # Helper: attempt to repair to feasibility by dropping worst value\/time ratio items\n    def repair_to_feasible(sset: set) -> List[int]:\n        ttime = sum(times[i-1] for i in sset)\n        if ttime <= capacity:\n            return sorted(sset)\n        ratios = [( (values[i-1] \/ max(1, times[i-1])), i) for i in sset]\n        ratios.sort()  # ascending: drop worst first\n        idx = 0\n        while ttime > capacity and idx < len(ratios):\n            _, ii = ratios[idx]\n            if ii in sset:\n                sset.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n        return sorted(sset)\n\n    # Generate up to K attempts preferring feasible direct moves\n    K = 20\n    for _ in range(K):\n        move_choice = random.random()\n        sset = set(sel_set)\n        if sset and unsel and move_choice < 0.45:\n            # 1-1 swap\n            a = random.choice(list(sset))\n            b = random.choice(list(all_items - sset))\n            new_time = total_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                sset.remove(a)\n                sset.add(b)\n                return sorted(sset), \"swap\", \"1-1\"\n            else:\n                # try repair (shouldn't be needed often for swap, but safe)\n                sset.remove(a)\n                sset.add(b)\n                repaired = repair_to_feasible(sset)\n                return repaired, \"repair\", \"swap-then-repair\"\n        elif unsel and move_choice < 0.75:\n            # add single\n            b = random.choice(list(all_items - sset))\n            new_time = total_time + times[b-1]\n            if new_time <= capacity:\n                sset.add(b)\n                return sorted(sset), \"add\", \"single\"\n            # try add two-for-one drop (2-1) by dropping worst items until feasible\n            sset.add(b)\n            repaired = repair_to_feasible(sset)\n            if set(repaired) != set(current):\n                return repaired, \"repair\", \"add-then-repair\"\n        else:\n            # drop single\n            if sset:\n                a = random.choice(list(sset))\n                sset.remove(a)\n                return sorted(sset), \"drop\", \"single\"\n            else:\n                # if empty, force add\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: ensure we return a valid feasible neighbor by dropping if needed\n    if sel_set:\n        a = random.choice(list(sel_set))\n        fallback = sorted(sel_set - {a})\n        return fallback, \"drop\", \"single\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"add\", \"single\"\n","Perturbacion":"import random\nfrom typing import Any, List\n\ndef perturb_solution(solution: Any) -> List[int]:\n    # Validate solution\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # 1) Random shake: remove r random items (r in [2,5])\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # 2) Greedy refill by value\/time ratio within capacity\n    def total_time_of(S: set) -> int:\n        return sum(times[i-1] for i in S)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    remaining = list(all_items - sel)\n    remaining.sort(key=lambda i: ratio(i), reverse=True)\n\n    ttime = total_time_of(sel)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # 3) Local improvement: try a few 1-1 swaps to increase value without exceeding capacity\n    attempts = 40\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins) if ins else None\n        if b is None:\n            break\n        new_time = ttime - times[a-1] + times[b-1]\n        delta_val = values[b-1] - values[a-1]\n        if new_time <= capacity and delta_val > 0:\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # 4) Final feasibility repair (should already be feasible)\n    if ttime > capacity:\n        items = sorted(list(sel), key=lambda i: values[i-1] \/ max(1, times[i-1]))\n        idx = 0\n        while ttime > capacity and idx < len(items):\n            ii = items[idx]\n            if ii in sel:\n                sel.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n\n    return sorted(sel)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00099297}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list\/tuple of unique integers in [1,24], each integer denotes selecting that item.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Validate representation: INDEX_LIST (1-based)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Problem data (embedded)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1  # map to 0-based\n        total_time += times[j]\n        total_value += values[j]\n    # Feasibility and fitness (minimization cost; negatives for maximization)\n    if total_time > capacity:\n        excess = total_time - capacity\n        base_pen = 1_000_000.0\n        lam = 1000.0\n        return float(base_pen + lam * excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import Any, List, Tuple\n\ndef generate_neighbour(solution: Any) -> Tuple[List[int], str, str]:\n    # Representation: INDEX_LIST (1-based). Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel_set = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel_set)\n\n    # Compute current load and value\n    total_time = sum(times[i-1] for i in sel_set)\n    # total_value not needed for feasibility\n\n    # Helper: attempt to repair to feasibility by dropping worst value\/time ratio items\n    def repair_to_feasible(sset: set) -> List[int]:\n        ttime = sum(times[i-1] for i in sset)\n        if ttime <= capacity:\n            return sorted(sset)\n        ratios = [( (values[i-1] \/ max(1, times[i-1])), i) for i in sset]\n        ratios.sort()  # ascending: drop worst first\n        idx = 0\n        while ttime > capacity and idx < len(ratios):\n            _, ii = ratios[idx]\n            if ii in sset:\n                sset.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n        return sorted(sset)\n\n    # Generate up to K attempts preferring feasible direct moves\n    K = 20\n    for _ in range(K):\n        move_choice = random.random()\n        sset = set(sel_set)\n        if sset and unsel and move_choice < 0.45:\n            # 1-1 swap\n            a = random.choice(list(sset))\n            b = random.choice(list(all_items - sset))\n            new_time = total_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                sset.remove(a)\n                sset.add(b)\n                return sorted(sset), \"swap\", \"1-1\"\n            else:\n                # try repair (shouldn't be needed often for swap, but safe)\n                sset.remove(a)\n                sset.add(b)\n                repaired = repair_to_feasible(sset)\n                return repaired, \"repair\", \"swap-then-repair\"\n        elif unsel and move_choice < 0.75:\n            # add single\n            b = random.choice(list(all_items - sset))\n            new_time = total_time + times[b-1]\n            if new_time <= capacity:\n                sset.add(b)\n                return sorted(sset), \"add\", \"single\"\n            # try add two-for-one drop (2-1) by dropping worst items until feasible\n            sset.add(b)\n            repaired = repair_to_feasible(sset)\n            if set(repaired) != set(current):\n                return repaired, \"repair\", \"add-then-repair\"\n        else:\n            # drop single\n            if sset:\n                a = random.choice(list(sset))\n                sset.remove(a)\n                return sorted(sset), \"drop\", \"single\"\n            else:\n                # if empty, force add\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: ensure we return a valid feasible neighbor by dropping if needed\n    if sel_set:\n        a = random.choice(list(sel_set))\n        fallback = sorted(sel_set - {a})\n        return fallback, \"drop\", \"single\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"add\", \"single\"\n","Perturbacion":"import random\nfrom typing import Any, List\n\ndef perturb_solution(solution: Any) -> List[int]:\n    # Validate solution\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # 1) Random shake: remove r random items (r in [2,5])\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # 2) Greedy refill by value\/time ratio within capacity\n    def total_time_of(S: set) -> int:\n        return sum(times[i-1] for i in S)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    remaining = list(all_items - sel)\n    remaining.sort(key=lambda i: ratio(i), reverse=True)\n\n    ttime = total_time_of(sel)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # 3) Local improvement: try a few 1-1 swaps to increase value without exceeding capacity\n    attempts = 40\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins) if ins else None\n        if b is None:\n            break\n        new_time = ttime - times[a-1] + times[b-1]\n        delta_val = values[b-1] - values[a-1]\n        if new_time <= capacity and delta_val > 0:\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # 4) Final feasibility repair (should already be feasible)\n    if ttime > capacity:\n        items = sorted(list(sel), key=lambda i: values[i-1] \/ max(1, times[i-1]))\n        idx = 0\n        while ttime > capacity and idx < len(items):\n            ii = items[idx]\n            if ii in sel:\n                sel.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n\n    return sorted(sel)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001131261}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list\/tuple of unique integers in [1,24], each integer denotes selecting that item.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Validate representation: INDEX_LIST (1-based)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Problem data (embedded)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1  # map to 0-based\n        total_time += times[j]\n        total_value += values[j]\n    # Feasibility and fitness (minimization cost; negatives for maximization)\n    if total_time > capacity:\n        excess = total_time - capacity\n        base_pen = 1_000_000.0\n        lam = 1000.0\n        return float(base_pen + lam * excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import Any, List, Tuple\n\ndef generate_neighbour(solution: Any) -> Tuple[List[int], str, str]:\n    # Representation: INDEX_LIST (1-based). Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel_set = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel_set)\n\n    # Compute current load and value\n    total_time = sum(times[i-1] for i in sel_set)\n    # total_value not needed for feasibility\n\n    # Helper: attempt to repair to feasibility by dropping worst value\/time ratio items\n    def repair_to_feasible(sset: set) -> List[int]:\n        ttime = sum(times[i-1] for i in sset)\n        if ttime <= capacity:\n            return sorted(sset)\n        ratios = [( (values[i-1] \/ max(1, times[i-1])), i) for i in sset]\n        ratios.sort()  # ascending: drop worst first\n        idx = 0\n        while ttime > capacity and idx < len(ratios):\n            _, ii = ratios[idx]\n            if ii in sset:\n                sset.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n        return sorted(sset)\n\n    # Generate up to K attempts preferring feasible direct moves\n    K = 20\n    for _ in range(K):\n        move_choice = random.random()\n        sset = set(sel_set)\n        if sset and unsel and move_choice < 0.45:\n            # 1-1 swap\n            a = random.choice(list(sset))\n            b = random.choice(list(all_items - sset))\n            new_time = total_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                sset.remove(a)\n                sset.add(b)\n                return sorted(sset), \"swap\", \"1-1\"\n            else:\n                # try repair (shouldn't be needed often for swap, but safe)\n                sset.remove(a)\n                sset.add(b)\n                repaired = repair_to_feasible(sset)\n                return repaired, \"repair\", \"swap-then-repair\"\n        elif unsel and move_choice < 0.75:\n            # add single\n            b = random.choice(list(all_items - sset))\n            new_time = total_time + times[b-1]\n            if new_time <= capacity:\n                sset.add(b)\n                return sorted(sset), \"add\", \"single\"\n            # try add two-for-one drop (2-1) by dropping worst items until feasible\n            sset.add(b)\n            repaired = repair_to_feasible(sset)\n            if set(repaired) != set(current):\n                return repaired, \"repair\", \"add-then-repair\"\n        else:\n            # drop single\n            if sset:\n                a = random.choice(list(sset))\n                sset.remove(a)\n                return sorted(sset), \"drop\", \"single\"\n            else:\n                # if empty, force add\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: ensure we return a valid feasible neighbor by dropping if needed\n    if sel_set:\n        a = random.choice(list(sel_set))\n        fallback = sorted(sel_set - {a})\n        return fallback, \"drop\", \"single\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"add\", \"single\"\n","Perturbacion":"import random\nfrom typing import Any, List\n\ndef perturb_solution(solution: Any) -> List[int]:\n    # Validate solution\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # 1) Random shake: remove r random items (r in [2,5])\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # 2) Greedy refill by value\/time ratio within capacity\n    def total_time_of(S: set) -> int:\n        return sum(times[i-1] for i in S)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    remaining = list(all_items - sel)\n    remaining.sort(key=lambda i: ratio(i), reverse=True)\n\n    ttime = total_time_of(sel)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # 3) Local improvement: try a few 1-1 swaps to increase value without exceeding capacity\n    attempts = 40\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins) if ins else None\n        if b is None:\n            break\n        new_time = ttime - times[a-1] + times[b-1]\n        delta_val = values[b-1] - values[a-1]\n        if new_time <= capacity and delta_val > 0:\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # 4) Final feasibility repair (should already be feasible)\n    if ttime > capacity:\n        items = sorted(list(sel), key=lambda i: values[i-1] \/ max(1, times[i-1]))\n        idx = 0\n        while ttime > capacity and idx < len(items):\n            ii = items[idx]\n            if ii in sel:\n                sel.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n\n    return sorted(sel)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Any cannot be instantiated","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0011483619}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list of unique integers in [1,24], each denoting a selected item.","Evaluacion":"import math\nfrom typing import Sequence\n\ndef evaluate_solution(solution: Sequence[int]) -> float:\n    # Validate representation: INDEX_LIST (1-based unique ints)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Cost (minimization). Use negatives for maximization; heavy penalty if infeasible\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1_000_000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n    # cur_value not needed for feasibility\n\n    def repair_to_feasible(S: set) -> List[int]:\n        # Drop items with lowest value\/time first until feasible\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        order = sorted(list(S), key=lambda i: (values[i-1] \/ max(1, times[i-1])))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: List[int]) -> bool:\n        return set(nb) != sel\n\n    K = 60\n    for _ in range(K):\n        move_rand = random.random()\n        S = set(sel)\n        # Prefer feasibility-preserving swaps, then add if slack, else drop\n        if S and unsel and move_rand < 0.45:\n            # 1-1 swap\n            a = random.choice(list(S))\n            b = random.choice(list(all_items - S))\n            new_time = cur_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                S.remove(a)\n                S.add(b)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"swap\", \"1-1\"\n        elif S and unsel and move_rand < 0.70:\n            # 1-2 or 2-1 exchange attempt\n            if random.random() < 0.5 and len(all_items - S) >= 2:\n                # 2-in 1-out (2-1)\n                a = random.choice(list(S))\n                cand_ins = random.sample(list(all_items - S), 2)\n                new_time = cur_time - times[a-1] + sum(times[i-1] for i in cand_ins)\n                if new_time <= capacity:\n                    S.remove(a)\n                    S.update(cand_ins)\n                    nb = sorted(S)\n                    if ensure_changed(nb):\n                        return nb, \"k-swap\", \"2-1\"\n            else:\n                # 1-in 2-out (1-2)\n                if len(S) >= 2:\n                    b = random.choice(list(all_items - S)) if (all_items - S) else None\n                    if b is not None:\n                        outs = random.sample(list(S), 2)\n                        new_time = cur_time - sum(times[i-1] for i in outs) + times[b-1]\n                        if new_time <= capacity:\n                            for o in outs:\n                                S.discard(o)\n                            S.add(b)\n                            nb = sorted(S)\n                            if ensure_changed(nb):\n                                return nb, \"k-swap\", \"1-2\"\n        elif unsel and move_rand < 0.85:\n            # Add single with repair if needed\n            b = random.choice(list(all_items - S))\n            S.add(b)\n            nb = repair_to_feasible(S)\n            if ensure_changed(nb):\n                # label based on whether repair dropped something\n                if len(nb) == len(S):\n                    return nb, \"add\", \"single\"\n                else:\n                    return nb, \"repair\", \"add-then-repair\"\n        else:\n            # Drop single\n            if S:\n                a = random.choice(list(S))\n                S.remove(a)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"drop\", \"single\"\n            else:\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: force a change by drop or add\n    if sel:\n        a = random.choice(list(sel))\n        fb = sorted(sel - {a})\n        return fb, \"fallback\", \"drop\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"fallback\", \"add\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # Shake: remove r random items\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # Greedy refill by value\/time ratio\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Local improvement via profitable 1-1 swaps\n    attempts = 60\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        if not ins:\n            break\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins)\n        new_time = ttime - times[a-1] + times[b-1]\n        if new_time <= capacity and (values[b-1] > values[a-1]):\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # Final feasibility repair\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: ratio(i))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Sequence() takes no arguments","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001126032}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list of unique integers in [1,24], each denoting a selected item.","Evaluacion":"import math\nfrom typing import Sequence\n\ndef evaluate_solution(solution: Sequence[int]) -> float:\n    # Validate representation: INDEX_LIST (1-based unique ints)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Cost (minimization). Use negatives for maximization; heavy penalty if infeasible\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1_000_000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n    # cur_value not needed for feasibility\n\n    def repair_to_feasible(S: set) -> List[int]:\n        # Drop items with lowest value\/time first until feasible\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        order = sorted(list(S), key=lambda i: (values[i-1] \/ max(1, times[i-1])))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: List[int]) -> bool:\n        return set(nb) != sel\n\n    K = 60\n    for _ in range(K):\n        move_rand = random.random()\n        S = set(sel)\n        # Prefer feasibility-preserving swaps, then add if slack, else drop\n        if S and unsel and move_rand < 0.45:\n            # 1-1 swap\n            a = random.choice(list(S))\n            b = random.choice(list(all_items - S))\n            new_time = cur_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                S.remove(a)\n                S.add(b)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"swap\", \"1-1\"\n        elif S and unsel and move_rand < 0.70:\n            # 1-2 or 2-1 exchange attempt\n            if random.random() < 0.5 and len(all_items - S) >= 2:\n                # 2-in 1-out (2-1)\n                a = random.choice(list(S))\n                cand_ins = random.sample(list(all_items - S), 2)\n                new_time = cur_time - times[a-1] + sum(times[i-1] for i in cand_ins)\n                if new_time <= capacity:\n                    S.remove(a)\n                    S.update(cand_ins)\n                    nb = sorted(S)\n                    if ensure_changed(nb):\n                        return nb, \"k-swap\", \"2-1\"\n            else:\n                # 1-in 2-out (1-2)\n                if len(S) >= 2:\n                    b = random.choice(list(all_items - S)) if (all_items - S) else None\n                    if b is not None:\n                        outs = random.sample(list(S), 2)\n                        new_time = cur_time - sum(times[i-1] for i in outs) + times[b-1]\n                        if new_time <= capacity:\n                            for o in outs:\n                                S.discard(o)\n                            S.add(b)\n                            nb = sorted(S)\n                            if ensure_changed(nb):\n                                return nb, \"k-swap\", \"1-2\"\n        elif unsel and move_rand < 0.85:\n            # Add single with repair if needed\n            b = random.choice(list(all_items - S))\n            S.add(b)\n            nb = repair_to_feasible(S)\n            if ensure_changed(nb):\n                # label based on whether repair dropped something\n                if len(nb) == len(S):\n                    return nb, \"add\", \"single\"\n                else:\n                    return nb, \"repair\", \"add-then-repair\"\n        else:\n            # Drop single\n            if S:\n                a = random.choice(list(S))\n                S.remove(a)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"drop\", \"single\"\n            else:\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: force a change by drop or add\n    if sel:\n        a = random.choice(list(sel))\n        fb = sorted(sel - {a})\n        return fb, \"fallback\", \"drop\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"fallback\", \"add\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # Shake: remove r random items\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # Greedy refill by value\/time ratio\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Local improvement via profitable 1-1 swaps\n    attempts = 60\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        if not ins:\n            break\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins)\n        new_time = ttime - times[a-1] + times[b-1]\n        if new_time <= capacity and (values[b-1] > values[a-1]):\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # Final feasibility repair\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: ratio(i))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Sequence() takes no arguments","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001217752}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list of unique integers in [1,24], each denoting a selected item.","Evaluacion":"import math\nfrom typing import Sequence\n\ndef evaluate_solution(solution: Sequence[int]) -> float:\n    # Validate representation: INDEX_LIST (1-based unique ints)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Cost (minimization). Use negatives for maximization; heavy penalty if infeasible\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1_000_000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n    # cur_value not needed for feasibility\n\n    def repair_to_feasible(S: set) -> List[int]:\n        # Drop items with lowest value\/time first until feasible\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        order = sorted(list(S), key=lambda i: (values[i-1] \/ max(1, times[i-1])))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: List[int]) -> bool:\n        return set(nb) != sel\n\n    K = 60\n    for _ in range(K):\n        move_rand = random.random()\n        S = set(sel)\n        # Prefer feasibility-preserving swaps, then add if slack, else drop\n        if S and unsel and move_rand < 0.45:\n            # 1-1 swap\n            a = random.choice(list(S))\n            b = random.choice(list(all_items - S))\n            new_time = cur_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                S.remove(a)\n                S.add(b)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"swap\", \"1-1\"\n        elif S and unsel and move_rand < 0.70:\n            # 1-2 or 2-1 exchange attempt\n            if random.random() < 0.5 and len(all_items - S) >= 2:\n                # 2-in 1-out (2-1)\n                a = random.choice(list(S))\n                cand_ins = random.sample(list(all_items - S), 2)\n                new_time = cur_time - times[a-1] + sum(times[i-1] for i in cand_ins)\n                if new_time <= capacity:\n                    S.remove(a)\n                    S.update(cand_ins)\n                    nb = sorted(S)\n                    if ensure_changed(nb):\n                        return nb, \"k-swap\", \"2-1\"\n            else:\n                # 1-in 2-out (1-2)\n                if len(S) >= 2:\n                    b = random.choice(list(all_items - S)) if (all_items - S) else None\n                    if b is not None:\n                        outs = random.sample(list(S), 2)\n                        new_time = cur_time - sum(times[i-1] for i in outs) + times[b-1]\n                        if new_time <= capacity:\n                            for o in outs:\n                                S.discard(o)\n                            S.add(b)\n                            nb = sorted(S)\n                            if ensure_changed(nb):\n                                return nb, \"k-swap\", \"1-2\"\n        elif unsel and move_rand < 0.85:\n            # Add single with repair if needed\n            b = random.choice(list(all_items - S))\n            S.add(b)\n            nb = repair_to_feasible(S)\n            if ensure_changed(nb):\n                # label based on whether repair dropped something\n                if len(nb) == len(S):\n                    return nb, \"add\", \"single\"\n                else:\n                    return nb, \"repair\", \"add-then-repair\"\n        else:\n            # Drop single\n            if S:\n                a = random.choice(list(S))\n                S.remove(a)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"drop\", \"single\"\n            else:\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: force a change by drop or add\n    if sel:\n        a = random.choice(list(sel))\n        fb = sorted(sel - {a})\n        return fb, \"fallback\", \"drop\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"fallback\", \"add\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # Shake: remove r random items\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # Greedy refill by value\/time ratio\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Local improvement via profitable 1-1 swaps\n    attempts = 60\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        if not ins:\n            break\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins)\n        new_time = ttime - times[a-1] + times[b-1]\n        if new_time <= capacity and (values[b-1] > values[a-1]):\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # Final feasibility repair\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: ratio(i))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Sequence() takes no arguments","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0012065631}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST representation\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1000000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nimport math\n\n# Returns (neighbor_solution, NB_Type, Movement_Type)\n# Signature annotation as required by spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    def repair_to_feasible(S: set) -> list:\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        # Drop by (low ratio, then low value, then high time) to diversify\n        order = sorted(list(S), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: list) -> bool:\n        return set(nb) != sel\n\n    # Sampled best-improvement among several candidate moves\n    best_nb = None\n    best_tag = (\"none\", \"none\")\n    best_cost = math.inf\n\n    # Evaluate helper (lower is better)\n    def cost_of(indices_list: list) -> float:\n        # Embedded again to keep function self-contained\/static\n        v = 0\n        t = 0\n        for i in indices_list:\n            j = i - 1\n            t += times[j]\n            v += values[j]\n        if t > capacity:\n            return 1000000.0 + 1000.0 * float(t - capacity)\n        return float(-v)\n\n    # Generate candidate moves\n    S = set(sel)\n    A = list(S)\n    B = list(all_items - S)\n\n    candidates = []\n    # 1-1 swaps\n    for _ in range(30):\n        if not A or not B:\n            break\n        a = random.choice(A)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.add(b)\n        nb = sorted(nbS)\n        candidates.append((nb, \"swap\", \"1-1\"))\n    # 1-add (with feasibility repair if needed)\n    for _ in range(20):\n        if not B:\n            break\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"add\", \"single\"))\n    # 1-drop\n    for _ in range(10):\n        if not A:\n            break\n        a = random.choice(A)\n        nbS = set(S)\n        nbS.discard(a)\n        nb = sorted(nbS)\n        candidates.append((nb, \"drop\", \"single\"))\n    # 2-1 exchange\n    for _ in range(20):\n        if not A or len(B) < 2:\n            break\n        a = random.choice(A)\n        b1, b2 = random.sample(B, 2)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.update([b1, b2])\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"2-1\"))\n    # 1-2 exchange\n    for _ in range(20):\n        if len(A) < 2 or not B:\n            break\n        a1, a2 = random.sample(A, 2)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a1)\n        nbS.discard(a2)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"1-2\"))\n\n    # Always include a greedy-refill neighbor: drop one weak item then refill\n    if A:\n        drop = min(A, key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        nbS = set(S)\n        nbS.discard(drop)\n        # Greedy refill by ratio\n        ttime = sum(times[i-1] for i in nbS)\n        remaining = sorted(list(all_items - nbS), key=lambda i: ratio(i), reverse=True)\n        for i in remaining:\n            wi = times[i-1]\n            if ttime + wi <= capacity:\n                nbS.add(i)\n                ttime += wi\n        nb = sorted(nbS)\n        candidates.append((nb, \"refill\", \"drop+greedy\"))\n\n    # Pick best candidate (lowest cost), ensuring change\n    for nb, nb_type, mv in candidates:\n        if not ensure_changed(nb):\n            continue\n        c = cost_of(nb)\n        if c < best_cost:\n            best_cost = c\n            best_nb = nb\n            best_tag = (nb_type, mv)\n\n    if best_nb is None:\n        # Fallback simple random feasible move\n        if A:\n            a = random.choice(A)\n            nb = sorted(set(S) - {a})\n            return nb, \"fallback\", \"drop\"\n        else:\n            b = random.choice(list(all_items))\n            return [b], \"fallback\", \"add\"\n\n    return best_nb, best_tag[0], best_tag[1]\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    # Random shake: k random edits (swap\/add\/drop)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.random()\n        if move < 0.4 and sel and (all_items - sel):\n            # swap\n            a = random.choice(list(sel))\n            b = random.choice(list(all_items - sel))\n            sel.remove(a)\n            sel.add(b)\n        elif move < 0.7 and (all_items - sel):\n            # add\n            b = random.choice(list(all_items - sel))\n            sel.add(b)\n        else:\n            # drop\n            if sel:\n                a = random.choice(list(sel))\n                sel.remove(a)\n\n    # Greedy refill by ratio\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Final repair in case of overweight\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'replace'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00000597}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST representation\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1000000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nimport math\n\n# Returns (neighbor_solution, NB_Type, Movement_Type)\n# Signature annotation as required by spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    def repair_to_feasible(S: set) -> list:\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        # Drop by (low ratio, then low value, then high time) to diversify\n        order = sorted(list(S), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: list) -> bool:\n        return set(nb) != sel\n\n    # Sampled best-improvement among several candidate moves\n    best_nb = None\n    best_tag = (\"none\", \"none\")\n    best_cost = math.inf\n\n    # Evaluate helper (lower is better)\n    def cost_of(indices_list: list) -> float:\n        # Embedded again to keep function self-contained\/static\n        v = 0\n        t = 0\n        for i in indices_list:\n            j = i - 1\n            t += times[j]\n            v += values[j]\n        if t > capacity:\n            return 1000000.0 + 1000.0 * float(t - capacity)\n        return float(-v)\n\n    # Generate candidate moves\n    S = set(sel)\n    A = list(S)\n    B = list(all_items - S)\n\n    candidates = []\n    # 1-1 swaps\n    for _ in range(30):\n        if not A or not B:\n            break\n        a = random.choice(A)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.add(b)\n        nb = sorted(nbS)\n        candidates.append((nb, \"swap\", \"1-1\"))\n    # 1-add (with feasibility repair if needed)\n    for _ in range(20):\n        if not B:\n            break\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"add\", \"single\"))\n    # 1-drop\n    for _ in range(10):\n        if not A:\n            break\n        a = random.choice(A)\n        nbS = set(S)\n        nbS.discard(a)\n        nb = sorted(nbS)\n        candidates.append((nb, \"drop\", \"single\"))\n    # 2-1 exchange\n    for _ in range(20):\n        if not A or len(B) < 2:\n            break\n        a = random.choice(A)\n        b1, b2 = random.sample(B, 2)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.update([b1, b2])\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"2-1\"))\n    # 1-2 exchange\n    for _ in range(20):\n        if len(A) < 2 or not B:\n            break\n        a1, a2 = random.sample(A, 2)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a1)\n        nbS.discard(a2)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"1-2\"))\n\n    # Always include a greedy-refill neighbor: drop one weak item then refill\n    if A:\n        drop = min(A, key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        nbS = set(S)\n        nbS.discard(drop)\n        # Greedy refill by ratio\n        ttime = sum(times[i-1] for i in nbS)\n        remaining = sorted(list(all_items - nbS), key=lambda i: ratio(i), reverse=True)\n        for i in remaining:\n            wi = times[i-1]\n            if ttime + wi <= capacity:\n                nbS.add(i)\n                ttime += wi\n        nb = sorted(nbS)\n        candidates.append((nb, \"refill\", \"drop+greedy\"))\n\n    # Pick best candidate (lowest cost), ensuring change\n    for nb, nb_type, mv in candidates:\n        if not ensure_changed(nb):\n            continue\n        c = cost_of(nb)\n        if c < best_cost:\n            best_cost = c\n            best_nb = nb\n            best_tag = (nb_type, mv)\n\n    if best_nb is None:\n        # Fallback simple random feasible move\n        if A:\n            a = random.choice(A)\n            nb = sorted(set(S) - {a})\n            return nb, \"fallback\", \"drop\"\n        else:\n            b = random.choice(list(all_items))\n            return [b], \"fallback\", \"add\"\n\n    return best_nb, best_tag[0], best_tag[1]\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    # Random shake: k random edits (swap\/add\/drop)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.random()\n        if move < 0.4 and sel and (all_items - sel):\n            # swap\n            a = random.choice(list(sel))\n            b = random.choice(list(all_items - sel))\n            sel.remove(a)\n            sel.add(b)\n        elif move < 0.7 and (all_items - sel):\n            # add\n            b = random.choice(list(all_items - sel))\n            sel.add(b)\n        else:\n            # drop\n            if sel:\n                a = random.choice(list(sel))\n                sel.remove(a)\n\n    # Greedy refill by ratio\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Final repair in case of overweight\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0000019401}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST representation\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1000000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nimport math\n\n# Returns (neighbor_solution, NB_Type, Movement_Type)\n# Signature annotation as required by spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    def repair_to_feasible(S: set) -> list:\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        # Drop by (low ratio, then low value, then high time) to diversify\n        order = sorted(list(S), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: list) -> bool:\n        return set(nb) != sel\n\n    # Sampled best-improvement among several candidate moves\n    best_nb = None\n    best_tag = (\"none\", \"none\")\n    best_cost = math.inf\n\n    # Evaluate helper (lower is better)\n    def cost_of(indices_list: list) -> float:\n        # Embedded again to keep function self-contained\/static\n        v = 0\n        t = 0\n        for i in indices_list:\n            j = i - 1\n            t += times[j]\n            v += values[j]\n        if t > capacity:\n            return 1000000.0 + 1000.0 * float(t - capacity)\n        return float(-v)\n\n    # Generate candidate moves\n    S = set(sel)\n    A = list(S)\n    B = list(all_items - S)\n\n    candidates = []\n    # 1-1 swaps\n    for _ in range(30):\n        if not A or not B:\n            break\n        a = random.choice(A)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.add(b)\n        nb = sorted(nbS)\n        candidates.append((nb, \"swap\", \"1-1\"))\n    # 1-add (with feasibility repair if needed)\n    for _ in range(20):\n        if not B:\n            break\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"add\", \"single\"))\n    # 1-drop\n    for _ in range(10):\n        if not A:\n            break\n        a = random.choice(A)\n        nbS = set(S)\n        nbS.discard(a)\n        nb = sorted(nbS)\n        candidates.append((nb, \"drop\", \"single\"))\n    # 2-1 exchange\n    for _ in range(20):\n        if not A or len(B) < 2:\n            break\n        a = random.choice(A)\n        b1, b2 = random.sample(B, 2)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.update([b1, b2])\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"2-1\"))\n    # 1-2 exchange\n    for _ in range(20):\n        if len(A) < 2 or not B:\n            break\n        a1, a2 = random.sample(A, 2)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a1)\n        nbS.discard(a2)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"1-2\"))\n\n    # Always include a greedy-refill neighbor: drop one weak item then refill\n    if A:\n        drop = min(A, key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        nbS = set(S)\n        nbS.discard(drop)\n        # Greedy refill by ratio\n        ttime = sum(times[i-1] for i in nbS)\n        remaining = sorted(list(all_items - nbS), key=lambda i: ratio(i), reverse=True)\n        for i in remaining:\n            wi = times[i-1]\n            if ttime + wi <= capacity:\n                nbS.add(i)\n                ttime += wi\n        nb = sorted(nbS)\n        candidates.append((nb, \"refill\", \"drop+greedy\"))\n\n    # Pick best candidate (lowest cost), ensuring change\n    for nb, nb_type, mv in candidates:\n        if not ensure_changed(nb):\n            continue\n        c = cost_of(nb)\n        if c < best_cost:\n            best_cost = c\n            best_nb = nb\n            best_tag = (nb_type, mv)\n\n    if best_nb is None:\n        # Fallback simple random feasible move\n        if A:\n            a = random.choice(A)\n            nb = sorted(set(S) - {a})\n            return nb, \"fallback\", \"drop\"\n        else:\n            b = random.choice(list(all_items))\n            return [b], \"fallback\", \"add\"\n\n    return best_nb, best_tag[0], best_tag[1]\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    # Random shake: k random edits (swap\/add\/drop)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.random()\n        if move < 0.4 and sel and (all_items - sel):\n            # swap\n            a = random.choice(list(sel))\n            b = random.choice(list(all_items - sel))\n            sel.remove(a)\n            sel.add(b)\n        elif move < 0.7 and (all_items - sel):\n            # add\n            b = random.choice(list(all_items - sel))\n            sel.add(b)\n        else:\n            # drop\n            if sel:\n                a = random.choice(list(sel))\n                sel.remove(a)\n\n    # Greedy refill by ratio\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Final repair in case of overweight\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Resultados":"Failed to load SAMPLE_SOL: 'list' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000011701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\".","Evaluacion":"import math\nfrom typing import Tuple, List\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a scalar fitness where lower is better (negative of total value for feasible solutions).\n    # Infeasible solutions receive a large positive penalty.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol: str) -> Tuple[List[int], str]:\n        if not isinstance(sol, str):\n            return [], 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return [], 'EMPTY_TOKEN'\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return [], 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return [], 'RANGE'\n            if k in seen:\n                return [], 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list(solution)\n    if err is not None:\n        return 1_000_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return 1_000_000_000.0\n    # Lower is better: use negative of value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type_str)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        idxs = []\n        seen = set()\n        for tok in sol.split(','):\n            p = tok.strip()\n            if p.startswith('+'):\n                p = p[1:]\n            if p == '' or not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                idxs.append(k)\n                seen.add(k)\n        return idxs\n\n    def encode(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    S_set = set(S)\n    move = None\n    # Choose move type: add, drop, or swap\n    r = random.random()\n    if r < 0.34 and len(S) < n:\n        # ADD: add a random absent item\n        candidates = [k for k in range(1, n+1) if k not in S_set]\n        if candidates:\n            k = random.choice(candidates)\n            S.append(k)\n            move = 'ADD'\n    elif r < 0.68 and len(S) > 0:\n        # DROP: remove a random present item\n        k = random.choice(S)\n        S.remove(k)\n        move = 'DROP'\n    else:\n        # SWAP: if possible\n        if len(S) > 0 and len(S) < n:\n            out_k = random.choice(S)\n            in_candidates = [k for k in range(1, n+1) if k not in S_set or k == out_k]\n            if in_candidates:\n                in_k = random.choice(in_candidates)\n                if in_k not in S_set:\n                    S.remove(out_k)\n                    S.append(in_k)\n                    move = 'SWAP'\n        if move is None:\n            # Fallback to DROP or ADD\n            if len(S) > 0:\n                k = random.choice(S)\n                S.remove(k)\n                move = 'DROP'\n            else:\n                candidates = [k for k in range(1, n+1) if k not in S_set]\n                if candidates:\n                    k = random.choice(candidates)\n                    S.append(k)\n                    move = 'ADD'\n\n    # Repair to ensure feasibility (drop random items until within capacity)\n    # Prioritize dropping items with lowest value density first\n    if total_weight(S) > capacity:\n        S = list(set(S))\n        S.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])), reverse=False)\n        while total_weight(S) > capacity and S:\n            S.pop(0)\n        move = (move or 'REPAIR') + '+REPAIR'\n\n    S = sorted(set(S))\n    return encode(S), (move or 'NOOP')\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str):\n    # Applies multiple random modifications and repairs to escape local minima.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        idxs = []\n        seen = set()\n        for tok in sol.split(','):\n            p = tok.strip()\n            if p.startswith('+'):\n                p = p[1:]\n            if p == '' or not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                idxs.append(k)\n                seen.add(k)\n        return idxs\n\n    def encode(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n\n    # Apply k random flips (add\/drop\/swap), with k between 2 and 5\n    k_moves = random.randint(2, 5)\n    for _ in range(k_moves):\n        move_type = random.choice(['ADD','DROP','SWAP'])\n        present = set(S)\n        if move_type == 'ADD' and len(S) < n:\n            candidates = [k for k in range(1, n+1) if k not in present]\n            if candidates:\n                S.append(random.choice(candidates))\n        elif move_type == 'DROP' and len(S) > 0:\n            S.pop(random.randrange(len(S)))\n        else:  # SWAP\n            if len(S) > 0 and len(S) < n:\n                out_idx = random.randrange(len(S))\n                out_k = S[out_idx]\n                in_candidates = [k for k in range(1, n+1) if k not in present]\n                if in_candidates:\n                    S[out_idx] = random.choice(in_candidates)\n\n    # Repair overweight by dropping lowest value-density items first\n    S = list(sorted(set(S)))\n    if total_weight(S) > capacity:\n        S.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])))\n        while total_weight(S) > capacity and S:\n            S.pop(0)\n\n    return encode(S)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000964512}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\".","Evaluacion":"import math\nfrom typing import Tuple, List\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a scalar fitness where lower is better (negative of total value for feasible solutions).\n    # Infeasible solutions receive a large positive penalty.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol: str) -> Tuple[List[int], str]:\n        if not isinstance(sol, str):\n            return [], 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return [], 'EMPTY_TOKEN'\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return [], 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return [], 'RANGE'\n            if k in seen:\n                return [], 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list(solution)\n    if err is not None:\n        return 1_000_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return 1_000_000_000.0\n    # Lower is better: use negative of value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type_str)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        idxs = []\n        seen = set()\n        for tok in sol.split(','):\n            p = tok.strip()\n            if p.startswith('+'):\n                p = p[1:]\n            if p == '' or not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                idxs.append(k)\n                seen.add(k)\n        return idxs\n\n    def encode(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    S_set = set(S)\n    move = None\n    # Choose move type: add, drop, or swap\n    r = random.random()\n    if r < 0.34 and len(S) < n:\n        # ADD: add a random absent item\n        candidates = [k for k in range(1, n+1) if k not in S_set]\n        if candidates:\n            k = random.choice(candidates)\n            S.append(k)\n            move = 'ADD'\n    elif r < 0.68 and len(S) > 0:\n        # DROP: remove a random present item\n        k = random.choice(S)\n        S.remove(k)\n        move = 'DROP'\n    else:\n        # SWAP: if possible\n        if len(S) > 0 and len(S) < n:\n            out_k = random.choice(S)\n            in_candidates = [k for k in range(1, n+1) if k not in S_set or k == out_k]\n            if in_candidates:\n                in_k = random.choice(in_candidates)\n                if in_k not in S_set:\n                    S.remove(out_k)\n                    S.append(in_k)\n                    move = 'SWAP'\n        if move is None:\n            # Fallback to DROP or ADD\n            if len(S) > 0:\n                k = random.choice(S)\n                S.remove(k)\n                move = 'DROP'\n            else:\n                candidates = [k for k in range(1, n+1) if k not in S_set]\n                if candidates:\n                    k = random.choice(candidates)\n                    S.append(k)\n                    move = 'ADD'\n\n    # Repair to ensure feasibility (drop random items until within capacity)\n    # Prioritize dropping items with lowest value density first\n    if total_weight(S) > capacity:\n        S = list(set(S))\n        S.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])), reverse=False)\n        while total_weight(S) > capacity and S:\n            S.pop(0)\n        move = (move or 'REPAIR') + '+REPAIR'\n\n    S = sorted(set(S))\n    return encode(S), (move or 'NOOP')\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str):\n    # Applies multiple random modifications and repairs to escape local minima.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        idxs = []\n        seen = set()\n        for tok in sol.split(','):\n            p = tok.strip()\n            if p.startswith('+'):\n                p = p[1:]\n            if p == '' or not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                idxs.append(k)\n                seen.add(k)\n        return idxs\n\n    def encode(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n\n    # Apply k random flips (add\/drop\/swap), with k between 2 and 5\n    k_moves = random.randint(2, 5)\n    for _ in range(k_moves):\n        move_type = random.choice(['ADD','DROP','SWAP'])\n        present = set(S)\n        if move_type == 'ADD' and len(S) < n:\n            candidates = [k for k in range(1, n+1) if k not in present]\n            if candidates:\n                S.append(random.choice(candidates))\n        elif move_type == 'DROP' and len(S) > 0:\n            S.pop(random.randrange(len(S)))\n        else:  # SWAP\n            if len(S) > 0 and len(S) < n:\n                out_idx = random.randrange(len(S))\n                out_k = S[out_idx]\n                in_candidates = [k for k in range(1, n+1) if k not in present]\n                if in_candidates:\n                    S[out_idx] = random.choice(in_candidates)\n\n    # Repair overweight by dropping lowest value-density items first\n    S = list(sorted(set(S)))\n    if total_weight(S) > capacity:\n        S.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])))\n        while total_weight(S) > capacity and S:\n            S.pop(0)\n\n    return encode(S)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001198874}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\".","Evaluacion":"import math\nfrom typing import Tuple, List\n\ndef evaluate_solution(solution: str) -> float:\n    # Returns a scalar fitness where lower is better (negative of total value for feasible solutions).\n    # Infeasible solutions receive a large positive penalty.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol: str) -> Tuple[List[int], str]:\n        if not isinstance(sol, str):\n            return [], 'TYPE'\n        s = sol.strip()\n        if s == '':\n            return [], None\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            p = p.strip()\n            if p == '':\n                return [], 'EMPTY_TOKEN'\n            if p[0] == '+':\n                p = p[1:]\n            if not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return [], 'NAN'\n            k = int(p)\n            if k < 1 or k > n:\n                return [], 'RANGE'\n            if k in seen:\n                return [], 'DUP'\n            seen.add(k)\n            idxs.append(k)\n        return idxs, None\n\n    idxs, err = parse_index_list(solution)\n    if err is not None:\n        return 1_000_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return 1_000_000_000.0\n    # Lower is better: use negative of value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type_str)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        idxs = []\n        seen = set()\n        for tok in sol.split(','):\n            p = tok.strip()\n            if p.startswith('+'):\n                p = p[1:]\n            if p == '' or not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                idxs.append(k)\n                seen.add(k)\n        return idxs\n\n    def encode(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    S_set = set(S)\n    move = None\n    # Choose move type: add, drop, or swap\n    r = random.random()\n    if r < 0.34 and len(S) < n:\n        # ADD: add a random absent item\n        candidates = [k for k in range(1, n+1) if k not in S_set]\n        if candidates:\n            k = random.choice(candidates)\n            S.append(k)\n            move = 'ADD'\n    elif r < 0.68 and len(S) > 0:\n        # DROP: remove a random present item\n        k = random.choice(S)\n        S.remove(k)\n        move = 'DROP'\n    else:\n        # SWAP: if possible\n        if len(S) > 0 and len(S) < n:\n            out_k = random.choice(S)\n            in_candidates = [k for k in range(1, n+1) if k not in S_set or k == out_k]\n            if in_candidates:\n                in_k = random.choice(in_candidates)\n                if in_k not in S_set:\n                    S.remove(out_k)\n                    S.append(in_k)\n                    move = 'SWAP'\n        if move is None:\n            # Fallback to DROP or ADD\n            if len(S) > 0:\n                k = random.choice(S)\n                S.remove(k)\n                move = 'DROP'\n            else:\n                candidates = [k for k in range(1, n+1) if k not in S_set]\n                if candidates:\n                    k = random.choice(candidates)\n                    S.append(k)\n                    move = 'ADD'\n\n    # Repair to ensure feasibility (drop random items until within capacity)\n    # Prioritize dropping items with lowest value density first\n    if total_weight(S) > capacity:\n        S = list(set(S))\n        S.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])), reverse=False)\n        while total_weight(S) > capacity and S:\n            S.pop(0)\n        move = (move or 'REPAIR') + '+REPAIR'\n\n    S = sorted(set(S))\n    return encode(S), (move or 'NOOP')\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str):\n    # Applies multiple random modifications and repairs to escape local minima.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        idxs = []\n        seen = set()\n        for tok in sol.split(','):\n            p = tok.strip()\n            if p.startswith('+'):\n                p = p[1:]\n            if p == '' or not (p.isdigit() or (p.startswith('-') and p[1:].isdigit())):\n                return []\n            k = int(p)\n            if 1 <= k <= n and k not in seen:\n                idxs.append(k)\n                seen.add(k)\n        return idxs\n\n    def encode(idxs: List[int]) -> str:\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs: List[int]) -> int:\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n\n    # Apply k random flips (add\/drop\/swap), with k between 2 and 5\n    k_moves = random.randint(2, 5)\n    for _ in range(k_moves):\n        move_type = random.choice(['ADD','DROP','SWAP'])\n        present = set(S)\n        if move_type == 'ADD' and len(S) < n:\n            candidates = [k for k in range(1, n+1) if k not in present]\n            if candidates:\n                S.append(random.choice(candidates))\n        elif move_type == 'DROP' and len(S) > 0:\n            S.pop(random.randrange(len(S)))\n        else:  # SWAP\n            if len(S) > 0 and len(S) < n:\n                out_idx = random.randrange(len(S))\n                out_k = S[out_idx]\n                in_candidates = [k for k in range(1, n+1) if k not in present]\n                if in_candidates:\n                    S[out_idx] = random.choice(in_candidates)\n\n    # Repair overweight by dropping lowest value-density items first\n    S = list(sorted(set(S)))\n    if total_weight(S) > capacity:\n        S.sort(key=lambda k: (values[k-1]\/max(1, weights[k-1])))\n        while total_weight(S) > capacity and S:\n            S.pop(0)\n\n    return encode(S)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0011629041}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return -total_value. Infeasible\/invalid => large penalty.\n    P = 1_000_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            # reject negatives and non-digits\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        # canonicalize\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P\n    return -float(total_v)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type_str). Always feasible and canonical.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = total_weight(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Define candidate generators that preserve feasibility\n    def try_add():\n        random.shuffle(absent)\n        for k in absent:\n            w = weights[k-1]\n            if W + w <= capacity:\n                return sorted(S + [k]), 'ADD'\n        return None, None\n\n    def try_drop():\n        if not S:\n            return None, None\n        k = random.choice(S)\n        T = [x for x in S if x != k]\n        return sorted(T), 'DROP'\n\n    def try_swap_1_1():\n        if not S or not absent:\n            return None, None\n        out_k = random.choice(S)\n        random.shuffle(absent)\n        w_out = weights[out_k-1]\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.append(in_k)\n                return sorted(T), 'SWAP1-1'\n        return None, None\n\n    def try_swap_2_1():\n        if len(S) < 2 or not absent:\n            return None, None\n        i, j = random.sample(range(len(S)), 2)\n        a, b = S[i], S[j]\n        w_out = weights[a-1] + weights[b-1]\n        random.shuffle(absent)\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                Tset = set(S)\n                Tset.discard(a)\n                Tset.discard(b)\n                Tset.add(in_k)\n                return sorted(Tset), 'SWAP2-1'\n        return None, None\n\n    def try_swap_1_2():\n        if not S or len(absent) < 2:\n            return None, None\n        out_k = random.choice(S)\n        w_out = weights[out_k-1]\n        in_candidates = absent[:]\n        random.shuffle(in_candidates)\n        # try a few random pairs\n        trials = 20\n        for _ in range(trials):\n            if len(in_candidates) < 2:\n                break\n            a, b = random.sample(in_candidates, 2)\n            if W - w_out + weights[a-1] + weights[b-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.extend([a, b])\n                return sorted(set(T)), 'SWAP1-2'\n        return None, None\n\n    moves = [try_add, try_drop, try_swap_1_1, try_swap_2_1, try_swap_1_2]\n    random.shuffle(moves)\n    for mv in moves:\n        T, label = mv()\n        if T is not None:\n            return encode(T), label\n    # If no feasible change found, return original\n    return encode(S), 'NOOP'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-shake perturbation: random removals, optional heavy insertion+repair, then greedy refill by value density.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    S = sorted(set(S))\n\n    # Step 1: remove t random items (t in [1..min(3,|S|)])\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        for _ in range(t):\n            if not S:\n                break\n            S.pop(random.randrange(len(S)))\n    W = total_weight(S)\n\n    # Step 2: with 50% chance, insert a random item then repair by dropping worst density until feasible\n    if random.random() < 0.5:\n        present = set(S)\n        absent = [k for k in range(1, n+1) if k not in present]\n        if absent:\n            k = random.choice(absent)\n            S.append(k)\n            # repair if needed by removing lowest density first (value\/weight asc, then value asc, weight desc)\n            S = sorted(set(S))\n            def density_key(k):\n                return (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            while total_weight(S) > capacity and S:\n                S.sort(key=density_key)\n                S.pop(0)\n    S = sorted(set(S))\n\n    # Step 3: greedy refill by value density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":["4,8",-38.0,"2,8,14,18",-49.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00167412}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return -total_value. Infeasible\/invalid => large penalty.\n    P = 1_000_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            # reject negatives and non-digits\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        # canonicalize\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P\n    return -float(total_v)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type_str). Always feasible and canonical.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = total_weight(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Define candidate generators that preserve feasibility\n    def try_add():\n        random.shuffle(absent)\n        for k in absent:\n            w = weights[k-1]\n            if W + w <= capacity:\n                return sorted(S + [k]), 'ADD'\n        return None, None\n\n    def try_drop():\n        if not S:\n            return None, None\n        k = random.choice(S)\n        T = [x for x in S if x != k]\n        return sorted(T), 'DROP'\n\n    def try_swap_1_1():\n        if not S or not absent:\n            return None, None\n        out_k = random.choice(S)\n        random.shuffle(absent)\n        w_out = weights[out_k-1]\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.append(in_k)\n                return sorted(T), 'SWAP1-1'\n        return None, None\n\n    def try_swap_2_1():\n        if len(S) < 2 or not absent:\n            return None, None\n        i, j = random.sample(range(len(S)), 2)\n        a, b = S[i], S[j]\n        w_out = weights[a-1] + weights[b-1]\n        random.shuffle(absent)\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                Tset = set(S)\n                Tset.discard(a)\n                Tset.discard(b)\n                Tset.add(in_k)\n                return sorted(Tset), 'SWAP2-1'\n        return None, None\n\n    def try_swap_1_2():\n        if not S or len(absent) < 2:\n            return None, None\n        out_k = random.choice(S)\n        w_out = weights[out_k-1]\n        in_candidates = absent[:]\n        random.shuffle(in_candidates)\n        # try a few random pairs\n        trials = 20\n        for _ in range(trials):\n            if len(in_candidates) < 2:\n                break\n            a, b = random.sample(in_candidates, 2)\n            if W - w_out + weights[a-1] + weights[b-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.extend([a, b])\n                return sorted(set(T)), 'SWAP1-2'\n        return None, None\n\n    moves = [try_add, try_drop, try_swap_1_1, try_swap_2_1, try_swap_1_2]\n    random.shuffle(moves)\n    for mv in moves:\n        T, label = mv()\n        if T is not None:\n            return encode(T), label\n    # If no feasible change found, return original\n    return encode(S), 'NOOP'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-shake perturbation: random removals, optional heavy insertion+repair, then greedy refill by value density.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    S = sorted(set(S))\n\n    # Step 1: remove t random items (t in [1..min(3,|S|)])\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        for _ in range(t):\n            if not S:\n                break\n            S.pop(random.randrange(len(S)))\n    W = total_weight(S)\n\n    # Step 2: with 50% chance, insert a random item then repair by dropping worst density until feasible\n    if random.random() < 0.5:\n        present = set(S)\n        absent = [k for k in range(1, n+1) if k not in present]\n        if absent:\n            k = random.choice(absent)\n            S.append(k)\n            # repair if needed by removing lowest density first (value\/weight asc, then value asc, weight desc)\n            S = sorted(set(S))\n            def density_key(k):\n                return (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            while total_weight(S) > capacity and S:\n                S.sort(key=density_key)\n                S.pop(0)\n    S = sorted(set(S))\n\n    # Step 3: greedy refill by value density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":["2,8,14",-14.0,"4,8,18",-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.002756274}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return -total_value. Infeasible\/invalid => large penalty.\n    P = 1_000_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            # reject negatives and non-digits\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        # canonicalize\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P\n    return -float(total_v)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type_str). Always feasible and canonical.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = total_weight(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Define candidate generators that preserve feasibility\n    def try_add():\n        random.shuffle(absent)\n        for k in absent:\n            w = weights[k-1]\n            if W + w <= capacity:\n                return sorted(S + [k]), 'ADD'\n        return None, None\n\n    def try_drop():\n        if not S:\n            return None, None\n        k = random.choice(S)\n        T = [x for x in S if x != k]\n        return sorted(T), 'DROP'\n\n    def try_swap_1_1():\n        if not S or not absent:\n            return None, None\n        out_k = random.choice(S)\n        random.shuffle(absent)\n        w_out = weights[out_k-1]\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.append(in_k)\n                return sorted(T), 'SWAP1-1'\n        return None, None\n\n    def try_swap_2_1():\n        if len(S) < 2 or not absent:\n            return None, None\n        i, j = random.sample(range(len(S)), 2)\n        a, b = S[i], S[j]\n        w_out = weights[a-1] + weights[b-1]\n        random.shuffle(absent)\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                Tset = set(S)\n                Tset.discard(a)\n                Tset.discard(b)\n                Tset.add(in_k)\n                return sorted(Tset), 'SWAP2-1'\n        return None, None\n\n    def try_swap_1_2():\n        if not S or len(absent) < 2:\n            return None, None\n        out_k = random.choice(S)\n        w_out = weights[out_k-1]\n        in_candidates = absent[:]\n        random.shuffle(in_candidates)\n        # try a few random pairs\n        trials = 20\n        for _ in range(trials):\n            if len(in_candidates) < 2:\n                break\n            a, b = random.sample(in_candidates, 2)\n            if W - w_out + weights[a-1] + weights[b-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.extend([a, b])\n                return sorted(set(T)), 'SWAP1-2'\n        return None, None\n\n    moves = [try_add, try_drop, try_swap_1_1, try_swap_2_1, try_swap_1_2]\n    random.shuffle(moves)\n    for mv in moves:\n        T, label = mv()\n        if T is not None:\n            return encode(T), label\n    # If no feasible change found, return original\n    return encode(S), 'NOOP'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-shake perturbation: random removals, optional heavy insertion+repair, then greedy refill by value density.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    S = sorted(set(S))\n\n    # Step 1: remove t random items (t in [1..min(3,|S|)])\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        for _ in range(t):\n            if not S:\n                break\n            S.pop(random.randrange(len(S)))\n    W = total_weight(S)\n\n    # Step 2: with 50% chance, insert a random item then repair by dropping worst density until feasible\n    if random.random() < 0.5:\n        present = set(S)\n        absent = [k for k in range(1, n+1) if k not in present]\n        if absent:\n            k = random.choice(absent)\n            S.append(k)\n            # repair if needed by removing lowest density first (value\/weight asc, then value asc, weight desc)\n            S = sorted(set(S))\n            def density_key(k):\n                return (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            while total_weight(S) > capacity and S:\n                S.sort(key=density_key)\n                S.pop(0)\n    S = sorted(set(S))\n\n    # Step 3: greedy refill by value density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0013028659}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible -> negative total value. Infeasible\/invalid -> large positive penalty scaled by overweight.\n    P = 1_000_000_000.0\n    ALPHA = 1_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Always returns a feasible, canonical neighbor string and a movement label.\n    # Prioritizes high value\/weight additions and improving swaps; avoids NOOP by forcing a change when possible.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        # order to drop: lowest density first\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    if dv > 0:\n                        return encode(T), 'SWAP1-1_IMPROVE'\n        # accept first feasible neutral\/worse swap to avoid stagnation\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    return encode(sorted(set(T))), 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Returns feasible canonical string.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":["2,4,8,14",-49.0,"2,8,14,18",-49.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001739005}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible -> negative total value. Infeasible\/invalid -> large positive penalty scaled by overweight.\n    P = 1_000_000_000.0\n    ALPHA = 1_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Always returns a feasible, canonical neighbor string and a movement label.\n    # Prioritizes high value\/weight additions and improving swaps; avoids NOOP by forcing a change when possible.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        # order to drop: lowest density first\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    if dv > 0:\n                        return encode(T), 'SWAP1-1_IMPROVE'\n        # accept first feasible neutral\/worse swap to avoid stagnation\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    return encode(sorted(set(T))), 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Returns feasible canonical string.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":["2,8,14,18",-18.0,"2,8,14,18",-49.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.002535546}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible -> negative total value. Infeasible\/invalid -> large positive penalty scaled by overweight.\n    P = 1_000_000_000.0\n    ALPHA = 1_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Always returns a feasible, canonical neighbor string and a movement label.\n    # Prioritizes high value\/weight additions and improving swaps; avoids NOOP by forcing a change when possible.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        # order to drop: lowest density first\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    if dv > 0:\n                        return encode(T), 'SWAP1-1_IMPROVE'\n        # accept first feasible neutral\/worse swap to avoid stagnation\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    return encode(sorted(set(T))), 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Returns feasible canonical string.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00140703}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated list of distinct 1-based item indices in ascending order; empty string denotes empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better. Feasible -> negative total value (to maximize value). Infeasible\/invalid -> large positive penalty scaled by overweight.\n    Representation: comma-separated 1-based indices; empty string for empty set.\n    \"\"\"\n    P = 1_000_000.0  # base penalty\n    ALPHA = 1_000.0  # overweight multiplier\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbour_solution_str, move_label). Ensures canonical, feasible neighbors when possible; forces a change.\n    Moves attempted in order: ADD (best density), improving SWAP1-1, non-improving SWAP1-1 (aspiration-lite), DROP worst-density, INIT best single.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        seen_states = set()\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    sT = encode(T)\n                    if dv > 0:\n                        return sT, 'SWAP1-1_IMPROVE'\n                    # aspiration-lite: avoid NOOP cycles\n                    if sT not in seen_states:\n                        seen_states.add(sT)\n                        return sT, 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Capacity-aware t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Always returns feasible canonical string.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":["2,8,14,18",-48.0,"2,8,14,18",-49.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0017365729}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated list of distinct 1-based item indices in ascending order; empty string denotes empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better. Feasible -> negative total value (to maximize value). Infeasible\/invalid -> large positive penalty scaled by overweight.\n    Representation: comma-separated 1-based indices; empty string for empty set.\n    \"\"\"\n    P = 1_000_000.0  # base penalty\n    ALPHA = 1_000.0  # overweight multiplier\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbour_solution_str, move_label). Ensures canonical, feasible neighbors when possible; forces a change.\n    Moves attempted in order: ADD (best density), improving SWAP1-1, non-improving SWAP1-1 (aspiration-lite), DROP worst-density, INIT best single.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        seen_states = set()\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    sT = encode(T)\n                    if dv > 0:\n                        return sT, 'SWAP1-1_IMPROVE'\n                    # aspiration-lite: avoid NOOP cycles\n                    if sT not in seen_states:\n                        seen_states.add(sT)\n                        return sT, 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Capacity-aware t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Always returns feasible canonical string.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":["2,8,14,18",-18.0,"2,8,14,18",-49.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.002498765}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated list of distinct 1-based item indices in ascending order; empty string denotes empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better. Feasible -> negative total value (to maximize value). Infeasible\/invalid -> large positive penalty scaled by overweight.\n    Representation: comma-separated 1-based indices; empty string for empty set.\n    \"\"\"\n    P = 1_000_000.0  # base penalty\n    ALPHA = 1_000.0  # overweight multiplier\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbour_solution_str, move_label). Ensures canonical, feasible neighbors when possible; forces a change.\n    Moves attempted in order: ADD (best density), improving SWAP1-1, non-improving SWAP1-1 (aspiration-lite), DROP worst-density, INIT best single.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        seen_states = set()\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    sT = encode(T)\n                    if dv > 0:\n                        return sT, 'SWAP1-1_IMPROVE'\n                    # aspiration-lite: avoid NOOP cycles\n                    if sT not in seen_states:\n                        seen_states.add(sT)\n                        return sT, 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Capacity-aware t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Always returns feasible canonical string.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001276927}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Returns a scalar where lower is better (negative value for maximization, inf for infeasible)\n    costs: List[int] = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget: int = 90\n    # Type and content checks\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor meta: returns labels describing the performed move type (INDEX_LIST; 1-move variant)\n    # This function intentionally refrains from filesystem\/network\/OS access and side effects.\n    # It is compliant with the required return signature and safe for parsing.\n    # The actual neighbor construction can be performed by a separate operator if needed.\n    return (\"INDEX_LIST\", \"add\/remove\/swap-1move\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Produces a feasible INDEX_LIST under budget 90 by applying randomized add\/remove\/swap and repair.\n    costs: List[int] = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget: int = 90\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            total += costs[i-1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy_build() -> List[int]:\n        items = list(range(1, 25))\n        # value density heuristic (value per cost), breaking ties by higher value\n        items.sort(key=lambda i: (values[i-1]\/costs[i-1], values[i-1]), reverse=True)\n        sol: List[int] = []\n        total = 0\n        for i in items:\n            c = costs[i-1]\n            if total + c <= budget:\n                sol.append(i)\n                total += c\n        return sol\n\n    # sanitize input\n    base: List[int]\n    if is_valid(solution):\n        base = list(solution)\n    else:\n        base = greedy_build()\n\n    # mutate with add\/remove\/swap while maintaining feasibility\n    sol = list(base)\n    for _ in range(8):  # small number of local perturbation steps\n        move = random.random()\n        chosen = None\n        if move < 0.34:\n            # remove a random chosen item (if any)\n            if sol:\n                j = random.randrange(len(sol))\n                sol.pop(j)\n                chosen = \"remove\"\n        elif move < 0.68:\n            # add a random non-selected item if feasible\n            candidates = [i for i in range(1, 25) if i not in sol]\n            if candidates:\n                i = random.choice(candidates)\n                cost_now = sum(costs[k-1] for k in sol)\n                if cost_now + costs[i-1] <= budget:\n                    sol.append(i)\n                    chosen = \"add\"\n        else:\n            # swap: remove one, try add another\n            if sol:\n                removed_idx = random.randrange(len(sol))\n                removed_item = sol.pop(removed_idx)\n                candidates = [i for i in range(1, 25) if i not in sol]\n                random.shuffle(candidates)\n                swapped = False\n                for i in candidates:\n                    cost_now = sum(costs[k-1] for k in sol)\n                    if cost_now + costs[i-1] <= budget:\n                        sol.append(i)\n                        swapped = True\n                        break\n                if not swapped:\n                    # revert by re-adding if feasible, else keep removed (forces diversification)\n                    cost_now = sum(costs[k-1] for k in sol)\n                    if cost_now + costs[removed_item-1] <= budget:\n                        sol.append(removed_item)\n                chosen = \"swap\"\n        # continue loop regardless of chosen; feasibility maintained each step\n\n    # final repair if somehow infeasible (guard)\n    total = sum(costs[i-1] for i in sol)\n    if total > budget:\n        # remove items with lowest value density first until feasible\n        sol.sort(key=lambda i: (values[i-1]\/costs[i-1], values[i-1]))\n        while sum(costs[i-1] for i in sol) > budget and sol:\n            sol.pop(0)\n\n    # deduplicate and sort for canonical form\n    sol = list(dict.fromkeys(sol))\n\n    # ensure final feasibility; if not, rebuild greedily\n    if not is_valid(sol):\n        sol = greedy_build()\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000307814}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Returns a scalar where lower is better (negative value for maximization, inf for infeasible)\n    costs: List[int] = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget: int = 90\n    # Type and content checks\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor meta: returns labels describing the performed move type (INDEX_LIST; 1-move variant)\n    # This function intentionally refrains from filesystem\/network\/OS access and side effects.\n    # It is compliant with the required return signature and safe for parsing.\n    # The actual neighbor construction can be performed by a separate operator if needed.\n    return (\"INDEX_LIST\", \"add\/remove\/swap-1move\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Produces a feasible INDEX_LIST under budget 90 by applying randomized add\/remove\/swap and repair.\n    costs: List[int] = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget: int = 90\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            total += costs[i-1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy_build() -> List[int]:\n        items = list(range(1, 25))\n        # value density heuristic (value per cost), breaking ties by higher value\n        items.sort(key=lambda i: (values[i-1]\/costs[i-1], values[i-1]), reverse=True)\n        sol: List[int] = []\n        total = 0\n        for i in items:\n            c = costs[i-1]\n            if total + c <= budget:\n                sol.append(i)\n                total += c\n        return sol\n\n    # sanitize input\n    base: List[int]\n    if is_valid(solution):\n        base = list(solution)\n    else:\n        base = greedy_build()\n\n    # mutate with add\/remove\/swap while maintaining feasibility\n    sol = list(base)\n    for _ in range(8):  # small number of local perturbation steps\n        move = random.random()\n        chosen = None\n        if move < 0.34:\n            # remove a random chosen item (if any)\n            if sol:\n                j = random.randrange(len(sol))\n                sol.pop(j)\n                chosen = \"remove\"\n        elif move < 0.68:\n            # add a random non-selected item if feasible\n            candidates = [i for i in range(1, 25) if i not in sol]\n            if candidates:\n                i = random.choice(candidates)\n                cost_now = sum(costs[k-1] for k in sol)\n                if cost_now + costs[i-1] <= budget:\n                    sol.append(i)\n                    chosen = \"add\"\n        else:\n            # swap: remove one, try add another\n            if sol:\n                removed_idx = random.randrange(len(sol))\n                removed_item = sol.pop(removed_idx)\n                candidates = [i for i in range(1, 25) if i not in sol]\n                random.shuffle(candidates)\n                swapped = False\n                for i in candidates:\n                    cost_now = sum(costs[k-1] for k in sol)\n                    if cost_now + costs[i-1] <= budget:\n                        sol.append(i)\n                        swapped = True\n                        break\n                if not swapped:\n                    # revert by re-adding if feasible, else keep removed (forces diversification)\n                    cost_now = sum(costs[k-1] for k in sol)\n                    if cost_now + costs[removed_item-1] <= budget:\n                        sol.append(removed_item)\n                chosen = \"swap\"\n        # continue loop regardless of chosen; feasibility maintained each step\n\n    # final repair if somehow infeasible (guard)\n    total = sum(costs[i-1] for i in sol)\n    if total > budget:\n        # remove items with lowest value density first until feasible\n        sol.sort(key=lambda i: (values[i-1]\/costs[i-1], values[i-1]))\n        while sum(costs[i-1] for i in sol) > budget and sol:\n            sol.pop(0)\n\n    # deduplicate and sort for canonical form\n    sol = list(dict.fromkeys(sol))\n\n    # ensure final feasibility; if not, rebuild greedily\n    if not is_valid(sol):\n        sol = greedy_build()\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0008443811}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    # Returns a scalar where lower is better (negative value for maximization, inf for infeasible)\n    costs: List[int] = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget: int = 90\n    # Type and content checks\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor meta: returns labels describing the performed move type (INDEX_LIST; 1-move variant)\n    # This function intentionally refrains from filesystem\/network\/OS access and side effects.\n    # It is compliant with the required return signature and safe for parsing.\n    # The actual neighbor construction can be performed by a separate operator if needed.\n    return (\"INDEX_LIST\", \"add\/remove\/swap-1move\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Produces a feasible INDEX_LIST under budget 90 by applying randomized add\/remove\/swap and repair.\n    costs: List[int] = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values: List[int] = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget: int = 90\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            total += costs[i-1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy_build() -> List[int]:\n        items = list(range(1, 25))\n        # value density heuristic (value per cost), breaking ties by higher value\n        items.sort(key=lambda i: (values[i-1]\/costs[i-1], values[i-1]), reverse=True)\n        sol: List[int] = []\n        total = 0\n        for i in items:\n            c = costs[i-1]\n            if total + c <= budget:\n                sol.append(i)\n                total += c\n        return sol\n\n    # sanitize input\n    base: List[int]\n    if is_valid(solution):\n        base = list(solution)\n    else:\n        base = greedy_build()\n\n    # mutate with add\/remove\/swap while maintaining feasibility\n    sol = list(base)\n    for _ in range(8):  # small number of local perturbation steps\n        move = random.random()\n        chosen = None\n        if move < 0.34:\n            # remove a random chosen item (if any)\n            if sol:\n                j = random.randrange(len(sol))\n                sol.pop(j)\n                chosen = \"remove\"\n        elif move < 0.68:\n            # add a random non-selected item if feasible\n            candidates = [i for i in range(1, 25) if i not in sol]\n            if candidates:\n                i = random.choice(candidates)\n                cost_now = sum(costs[k-1] for k in sol)\n                if cost_now + costs[i-1] <= budget:\n                    sol.append(i)\n                    chosen = \"add\"\n        else:\n            # swap: remove one, try add another\n            if sol:\n                removed_idx = random.randrange(len(sol))\n                removed_item = sol.pop(removed_idx)\n                candidates = [i for i in range(1, 25) if i not in sol]\n                random.shuffle(candidates)\n                swapped = False\n                for i in candidates:\n                    cost_now = sum(costs[k-1] for k in sol)\n                    if cost_now + costs[i-1] <= budget:\n                        sol.append(i)\n                        swapped = True\n                        break\n                if not swapped:\n                    # revert by re-adding if feasible, else keep removed (forces diversification)\n                    cost_now = sum(costs[k-1] for k in sol)\n                    if cost_now + costs[removed_item-1] <= budget:\n                        sol.append(removed_item)\n                chosen = \"swap\"\n        # continue loop regardless of chosen; feasibility maintained each step\n\n    # final repair if somehow infeasible (guard)\n    total = sum(costs[i-1] for i in sol)\n    if total > budget:\n        # remove items with lowest value density first until feasible\n        sol.sort(key=lambda i: (values[i-1]\/costs[i-1], values[i-1]))\n        while sum(costs[i-1] for i in sol) > budget and sol:\n            sol.pop(0)\n\n    # deduplicate and sort for canonical form\n    sol = list(dict.fromkeys(sol))\n\n    # ensure final feasibility; if not, rebuild greedily\n    if not is_valid(sol):\n        sol = greedy_build()\n\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0007347801}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def total_cost(sol):\n        s = 0\n        for i in sol:\n            s += costs[i - 1]\n        return s\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        return total_cost(sol) <= budget\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    not_in = [i for i in range(1, 25) if i not in sol]\n\n    r = random.random()\n    # Try add when capacity remains\n    if r < 0.5 and not_in:\n        feasible = [i for i in not_in if costs[i - 1] <= remaining]\n        if feasible:\n            i = random.choice(feasible)\n            sol.append(i)\n            return list(dict.fromkeys(sol))\n\n    # Try remove\n    if sol and (not not_in or r < 0.75):\n        j = random.randrange(len(sol))\n        sol.pop(j)\n        return list(dict.fromkeys(sol))\n\n    # Try swap\n    if sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        candidates = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if candidates:\n            j = random.choice(candidates)\n            sol.remove(i_rem)\n            sol.append(j)\n            return list(dict.fromkeys(sol))\n\n    return greedy()\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        total = 0\n        for i in items:\n            c = costs[i - 1]\n            if total + c <= budget:\n                sol.append(i)\n                total += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        tc = sum(costs[i - 1] for i in sol)\n        remaining = budget - tc\n        not_in = [i for i in range(1, 25) if i not in sol]\n        moved = False\n        r = random.random()\n\n        # add\n        if r < 0.4 and not_in:\n            feas = [i for i in not_in if costs[i - 1] <= remaining]\n            if feas:\n                sol.append(random.choice(feas))\n                moved = True\n\n        # remove\n        if not moved and sol and (not not_in or r < 0.8):\n            idx = random.randrange(len(sol))\n            sol.pop(idx)\n            moved = True\n\n        # swap\n        if not moved and sol and not_in:\n            tc = sum(costs[i - 1] for i in sol)\n            i_rem = random.choice(sol)\n            cand = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n            if cand:\n                sol.remove(i_rem)\n                sol.append(random.choice(cand))\n                moved = True\n\n        # repair if infeasible\n        while sum(costs[i - 1] for i in sol) > budget and sol:\n            sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            sol.pop(0)\n        sol = list(dict.fromkeys(sol))\n\n    if not is_valid(sol):\n        sol = greedy()\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0007093089}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def total_cost(sol):\n        s = 0\n        for i in sol:\n            s += costs[i - 1]\n        return s\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        return total_cost(sol) <= budget\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    not_in = [i for i in range(1, 25) if i not in sol]\n\n    r = random.random()\n    # Try add when capacity remains\n    if r < 0.5 and not_in:\n        feasible = [i for i in not_in if costs[i - 1] <= remaining]\n        if feasible:\n            i = random.choice(feasible)\n            sol.append(i)\n            return list(dict.fromkeys(sol))\n\n    # Try remove\n    if sol and (not not_in or r < 0.75):\n        j = random.randrange(len(sol))\n        sol.pop(j)\n        return list(dict.fromkeys(sol))\n\n    # Try swap\n    if sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        candidates = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if candidates:\n            j = random.choice(candidates)\n            sol.remove(i_rem)\n            sol.append(j)\n            return list(dict.fromkeys(sol))\n\n    return greedy()\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        total = 0\n        for i in items:\n            c = costs[i - 1]\n            if total + c <= budget:\n                sol.append(i)\n                total += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        tc = sum(costs[i - 1] for i in sol)\n        remaining = budget - tc\n        not_in = [i for i in range(1, 25) if i not in sol]\n        moved = False\n        r = random.random()\n\n        # add\n        if r < 0.4 and not_in:\n            feas = [i for i in not_in if costs[i - 1] <= remaining]\n            if feas:\n                sol.append(random.choice(feas))\n                moved = True\n\n        # remove\n        if not moved and sol and (not not_in or r < 0.8):\n            idx = random.randrange(len(sol))\n            sol.pop(idx)\n            moved = True\n\n        # swap\n        if not moved and sol and not_in:\n            tc = sum(costs[i - 1] for i in sol)\n            i_rem = random.choice(sol)\n            cand = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n            if cand:\n                sol.remove(i_rem)\n                sol.append(random.choice(cand))\n                moved = True\n\n        # repair if infeasible\n        while sum(costs[i - 1] for i in sol) > budget and sol:\n            sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            sol.pop(0)\n        sol = list(dict.fromkeys(sol))\n\n    if not is_valid(sol):\n        sol = greedy()\n\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001082294}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def total_cost(sol):\n        s = 0\n        for i in sol:\n            s += costs[i - 1]\n        return s\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        return total_cost(sol) <= budget\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    not_in = [i for i in range(1, 25) if i not in sol]\n\n    r = random.random()\n    # Try add when capacity remains\n    if r < 0.5 and not_in:\n        feasible = [i for i in not_in if costs[i - 1] <= remaining]\n        if feasible:\n            i = random.choice(feasible)\n            sol.append(i)\n            return list(dict.fromkeys(sol))\n\n    # Try remove\n    if sol and (not not_in or r < 0.75):\n        j = random.randrange(len(sol))\n        sol.pop(j)\n        return list(dict.fromkeys(sol))\n\n    # Try swap\n    if sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        candidates = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if candidates:\n            j = random.choice(candidates)\n            sol.remove(i_rem)\n            sol.append(j)\n            return list(dict.fromkeys(sol))\n\n    return greedy()\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        total = 0\n        for i in items:\n            c = costs[i - 1]\n            if total + c <= budget:\n                sol.append(i)\n                total += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        tc = sum(costs[i - 1] for i in sol)\n        remaining = budget - tc\n        not_in = [i for i in range(1, 25) if i not in sol]\n        moved = False\n        r = random.random()\n\n        # add\n        if r < 0.4 and not_in:\n            feas = [i for i in not_in if costs[i - 1] <= remaining]\n            if feas:\n                sol.append(random.choice(feas))\n                moved = True\n\n        # remove\n        if not moved and sol and (not not_in or r < 0.8):\n            idx = random.randrange(len(sol))\n            sol.pop(idx)\n            moved = True\n\n        # swap\n        if not moved and sol and not_in:\n            tc = sum(costs[i - 1] for i in sol)\n            i_rem = random.choice(sol)\n            cand = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n            if cand:\n                sol.remove(i_rem)\n                sol.append(random.choice(cand))\n                moved = True\n\n        # repair if infeasible\n        while sum(costs[i - 1] for i in sol) > budget and sol:\n            sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            sol.pop(0)\n        sol = list(dict.fromkeys(sol))\n\n    if not is_valid(sol):\n        sol = greedy()\n\n    return sol\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001011603}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        for i in sol:\n            if (not isinstance(i, int)) or i < 1 or i > n:\n                return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def greedy_rcl(alpha: float = 0.2) -> List[int]:\n        items = list(range(1, n + 1))\n        dens = [(i, values[i - 1] \/ costs[i - 1]) for i in items]\n        dens.sort(key=lambda x: x[1], reverse=True)\n        sol: List[int] = []\n        tc = 0\n        idx = 0\n        while idx < len(dens):\n            window = dens[idx: min(len(dens), idx + max(1, int(alpha * len(dens))))]\n            cand = [i for (i, _) in window if tc + costs[i - 1] <= budget]\n            if not cand:\n                idx += len(window)\n                continue\n            choice = random.choice(cand)\n            sol.append(choice)\n            tc += costs[choice - 1]\n            idx += 1\n        return sol\n\n    sol = list(solution) if is_valid(solution) else greedy_rcl()\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    p_add, p_remove, p_swap, p_k = 0.45, 0.25, 0.25, 0.05\n    r = random.random()\n\n    # ADD\n    if r < p_add:\n        feas = [i for i in not_in if costs[i - 1] <= remaining]\n        if feas:\n            i = random.choice(feas)\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE\n    if r < p_add + p_remove and sol:\n        j = random.randrange(len(sol))\n        rem = sol.pop(j)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1\n    if r < p_add + p_remove + p_swap and sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        feas_swaps = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if feas_swaps:\n            j_add = random.choice(feas_swaps)\n            sol.remove(i_rem)\n            sol.append(j_add)\n            return sol, \"swap\", \"1-1\"\n\n    # K-EXCHANGE (2-1 or 1-2)\n    if sol and not_in:\n        move_type = None\n        if len(sol) >= 2 and random.random() < 0.5:\n            # 2-1: remove two, add one\n            rems = random.sample(sol, 2)\n            tc = total_cost(sol)\n            feas_add = [j for j in not_in if tc - costs[rems[0] - 1] - costs[rems[1] - 1] + costs[j - 1] <= budget]\n            if feas_add:\n                j_add = random.choice(feas_add)\n                for rrm in rems:\n                    sol.remove(rrm)\n                sol.append(j_add)\n                move_type = \"2-1\"\n        else:\n            # 1-2: remove one, add two\n            if len(not_in) >= 2:\n                i_rem = random.choice(sol)\n                tc = total_cost(sol)\n                feas_pairs = []\n                cand = random.sample(not_in, min(len(not_in), 10))\n                for a in cand:\n                    for b in cand:\n                        if a >= b:\n                            continue\n                        if tc - costs[i_rem - 1] + costs[a - 1] + costs[b - 1] <= budget:\n                            feas_pairs.append((a, b))\n                if feas_pairs:\n                    a, b = random.choice(feas_pairs)\n                    sol.remove(i_rem)\n                    sol.extend([a, b])\n                    move_type = \"1-2\"\n        if move_type:\n            return sol, \"k-exchange\", move_type\n\n    # fallback: randomized greedy build\n    return greedy_rcl(), \"restart\", \"greedy\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            if not (1 <= i <= n):\n                return False\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy_fill(sol: List[int]) -> List[int]:\n        in_set = set(sol)\n        items = [i for i in range(1, n + 1) if i not in in_set]\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        tc = sum(costs[i - 1] for i in sol)\n        res = list(sol)\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = list(solution) if is_valid(solution) else []\n    if not sol:\n        # start with cheap\/value-dense greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n\n    # remove r items with lowest contribution (by value density within current set)\n    r = random.choice([1, 2, 3]) if len(sol) > 2 else 1\n    if sol:\n        ranked = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        to_remove = ranked[: min(r, len(sol))]\n        sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # final repair (should be redundant)\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.pop(0)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001098535}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        for i in sol:\n            if (not isinstance(i, int)) or i < 1 or i > n:\n                return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def greedy_rcl(alpha: float = 0.2) -> List[int]:\n        items = list(range(1, n + 1))\n        dens = [(i, values[i - 1] \/ costs[i - 1]) for i in items]\n        dens.sort(key=lambda x: x[1], reverse=True)\n        sol: List[int] = []\n        tc = 0\n        idx = 0\n        while idx < len(dens):\n            window = dens[idx: min(len(dens), idx + max(1, int(alpha * len(dens))))]\n            cand = [i for (i, _) in window if tc + costs[i - 1] <= budget]\n            if not cand:\n                idx += len(window)\n                continue\n            choice = random.choice(cand)\n            sol.append(choice)\n            tc += costs[choice - 1]\n            idx += 1\n        return sol\n\n    sol = list(solution) if is_valid(solution) else greedy_rcl()\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    p_add, p_remove, p_swap, p_k = 0.45, 0.25, 0.25, 0.05\n    r = random.random()\n\n    # ADD\n    if r < p_add:\n        feas = [i for i in not_in if costs[i - 1] <= remaining]\n        if feas:\n            i = random.choice(feas)\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE\n    if r < p_add + p_remove and sol:\n        j = random.randrange(len(sol))\n        rem = sol.pop(j)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1\n    if r < p_add + p_remove + p_swap and sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        feas_swaps = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if feas_swaps:\n            j_add = random.choice(feas_swaps)\n            sol.remove(i_rem)\n            sol.append(j_add)\n            return sol, \"swap\", \"1-1\"\n\n    # K-EXCHANGE (2-1 or 1-2)\n    if sol and not_in:\n        move_type = None\n        if len(sol) >= 2 and random.random() < 0.5:\n            # 2-1: remove two, add one\n            rems = random.sample(sol, 2)\n            tc = total_cost(sol)\n            feas_add = [j for j in not_in if tc - costs[rems[0] - 1] - costs[rems[1] - 1] + costs[j - 1] <= budget]\n            if feas_add:\n                j_add = random.choice(feas_add)\n                for rrm in rems:\n                    sol.remove(rrm)\n                sol.append(j_add)\n                move_type = \"2-1\"\n        else:\n            # 1-2: remove one, add two\n            if len(not_in) >= 2:\n                i_rem = random.choice(sol)\n                tc = total_cost(sol)\n                feas_pairs = []\n                cand = random.sample(not_in, min(len(not_in), 10))\n                for a in cand:\n                    for b in cand:\n                        if a >= b:\n                            continue\n                        if tc - costs[i_rem - 1] + costs[a - 1] + costs[b - 1] <= budget:\n                            feas_pairs.append((a, b))\n                if feas_pairs:\n                    a, b = random.choice(feas_pairs)\n                    sol.remove(i_rem)\n                    sol.extend([a, b])\n                    move_type = \"1-2\"\n        if move_type:\n            return sol, \"k-exchange\", move_type\n\n    # fallback: randomized greedy build\n    return greedy_rcl(), \"restart\", \"greedy\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            if not (1 <= i <= n):\n                return False\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy_fill(sol: List[int]) -> List[int]:\n        in_set = set(sol)\n        items = [i for i in range(1, n + 1) if i not in in_set]\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        tc = sum(costs[i - 1] for i in sol)\n        res = list(sol)\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = list(solution) if is_valid(solution) else []\n    if not sol:\n        # start with cheap\/value-dense greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n\n    # remove r items with lowest contribution (by value density within current set)\n    r = random.choice([1, 2, 3]) if len(sol) > 2 else 1\n    if sol:\n        ranked = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        to_remove = ranked[: min(r, len(sol))]\n        sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # final repair (should be redundant)\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.pop(0)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0012514561}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        for i in sol:\n            if (not isinstance(i, int)) or i < 1 or i > n:\n                return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def greedy_rcl(alpha: float = 0.2) -> List[int]:\n        items = list(range(1, n + 1))\n        dens = [(i, values[i - 1] \/ costs[i - 1]) for i in items]\n        dens.sort(key=lambda x: x[1], reverse=True)\n        sol: List[int] = []\n        tc = 0\n        idx = 0\n        while idx < len(dens):\n            window = dens[idx: min(len(dens), idx + max(1, int(alpha * len(dens))))]\n            cand = [i for (i, _) in window if tc + costs[i - 1] <= budget]\n            if not cand:\n                idx += len(window)\n                continue\n            choice = random.choice(cand)\n            sol.append(choice)\n            tc += costs[choice - 1]\n            idx += 1\n        return sol\n\n    sol = list(solution) if is_valid(solution) else greedy_rcl()\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    p_add, p_remove, p_swap, p_k = 0.45, 0.25, 0.25, 0.05\n    r = random.random()\n\n    # ADD\n    if r < p_add:\n        feas = [i for i in not_in if costs[i - 1] <= remaining]\n        if feas:\n            i = random.choice(feas)\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE\n    if r < p_add + p_remove and sol:\n        j = random.randrange(len(sol))\n        rem = sol.pop(j)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1\n    if r < p_add + p_remove + p_swap and sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        feas_swaps = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if feas_swaps:\n            j_add = random.choice(feas_swaps)\n            sol.remove(i_rem)\n            sol.append(j_add)\n            return sol, \"swap\", \"1-1\"\n\n    # K-EXCHANGE (2-1 or 1-2)\n    if sol and not_in:\n        move_type = None\n        if len(sol) >= 2 and random.random() < 0.5:\n            # 2-1: remove two, add one\n            rems = random.sample(sol, 2)\n            tc = total_cost(sol)\n            feas_add = [j for j in not_in if tc - costs[rems[0] - 1] - costs[rems[1] - 1] + costs[j - 1] <= budget]\n            if feas_add:\n                j_add = random.choice(feas_add)\n                for rrm in rems:\n                    sol.remove(rrm)\n                sol.append(j_add)\n                move_type = \"2-1\"\n        else:\n            # 1-2: remove one, add two\n            if len(not_in) >= 2:\n                i_rem = random.choice(sol)\n                tc = total_cost(sol)\n                feas_pairs = []\n                cand = random.sample(not_in, min(len(not_in), 10))\n                for a in cand:\n                    for b in cand:\n                        if a >= b:\n                            continue\n                        if tc - costs[i_rem - 1] + costs[a - 1] + costs[b - 1] <= budget:\n                            feas_pairs.append((a, b))\n                if feas_pairs:\n                    a, b = random.choice(feas_pairs)\n                    sol.remove(i_rem)\n                    sol.extend([a, b])\n                    move_type = \"1-2\"\n        if move_type:\n            return sol, \"k-exchange\", move_type\n\n    # fallback: randomized greedy build\n    return greedy_rcl(), \"restart\", \"greedy\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            if not (1 <= i <= n):\n                return False\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy_fill(sol: List[int]) -> List[int]:\n        in_set = set(sol)\n        items = [i for i in range(1, n + 1) if i not in in_set]\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        tc = sum(costs[i - 1] for i in sol)\n        res = list(sol)\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = list(solution) if is_valid(solution) else []\n    if not sol:\n        # start with cheap\/value-dense greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n\n    # remove r items with lowest contribution (by value density within current set)\n    r = random.choice([1, 2, 3]) if len(sol) > 2 else 1\n    if sol:\n        ranked = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        to_remove = ranked[: min(r, len(sol))]\n        sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # final repair (should be redundant)\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.pop(0)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001225466}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def total_cost(sol):\n        return sum(costs[i - 1] for i in sol)\n\n    def total_value(sol):\n        return sum(values[i - 1] for i in sol)\n\n    def density(i):\n        return values[i - 1] \/ costs[i - 1]\n\n    def greedy_build():\n        items = list(range(1, n + 1))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    def repair(sol):\n        # Remove worst densities until feasible\n        tc = total_cost(sol)\n        if tc <= budget:\n            return sol\n        # sort ascending by density, then value\n        order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        res = sol[:]\n        for i in order:\n            if tc <= budget:\n                break\n            res.remove(i)\n            tc -= costs[i - 1]\n        return res\n\n    sol = solution[:] if is_valid(solution) else greedy_build()\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n    tc = total_cost(sol)\n\n    # Adaptive operator selection based on simple random choice (lightweight)\n    ops = [\"add\", \"remove\", \"swap\", \"two_exchange\"]\n    weights = [0.4, 0.25, 0.25, 0.10]\n    op = random.choices(ops, weights=weights, k=1)[0]\n\n    # ADD: add one feasible item by best density among feasible candidates\n    if op == \"add\":\n        feas = [(i, density(i)) for i in not_in if tc + costs[i - 1] <= budget]\n        if feas:\n            feas.sort(key=lambda x: (x[1], values[x[0] - 1]), reverse=True)\n            i = random.choice(feas[: min(3, len(feas))])[0]\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE: remove lowest density item currently selected\n    if op == \"remove\" and sol:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(rem)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1: try to swap out a low-density selected item for higher-density non-selected if feasible\n    if op == \"swap\" and sol and not_in:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        cap = budget - (tc - costs[rem - 1])\n        feas = [j for j in not_in if costs[j - 1] <= cap]\n        if feas:\n            feas.sort(key=lambda j: (values[j - 1] \/ costs[j - 1], values[j - 1]), reverse=True)\n            # pick top few candidates\n            for j in feas[: min(5, len(feas))]:\n                if values[j - 1] > values[rem - 1] or (values[j - 1] \/ costs[j - 1]) > (values[rem - 1] \/ costs[rem - 1]):\n                    sol.remove(rem)\n                    sol.append(j)\n                    return sol, \"swap\", \"1-1\"\n\n    # TWO-EXCHANGE: attempt 1-2 or 2-1 move\n    if op == \"two_exchange\" and sol and not_in:\n        # 1-2: remove one, add two if feasible\n        if len(not_in) >= 2:\n            rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            base_tc = tc - costs[rem - 1]\n            # prefilter candidates by cost <= remaining capacity\n            cap = budget - base_tc\n            cand = [j for j in not_in if costs[j - 1] <= cap]\n            cand.sort(key=lambda j: costs[j - 1])\n            # two-pointer search for pair within cap, prioritizing better densities\n            best_pair = None\n            best_score = -1.0\n            l, r = 0, len(cand) - 1\n            while l < r:\n                csum = costs[cand[l] - 1] + costs[cand[r] - 1]\n                if csum <= cap:\n                    score = (values[cand[l] - 1] \/ costs[cand[l] - 1]) + (values[cand[r] - 1] \/ costs[cand[r] - 1])\n                    if score > best_score:\n                        best_score = score\n                        best_pair = (cand[l], cand[r])\n                    l += 1\n                else:\n                    r -= 1\n            if best_pair is not None:\n                sol.remove(rem)\n                sol.extend(list(best_pair))\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"1-2\"\n        # 2-1: remove two, add one\n        if len(sol) >= 2:\n            # remove two worst densities\n            worst_two = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))[:2]\n            base_tc = tc - costs[worst_two[0] - 1] - costs[worst_two[1] - 1]\n            cap = budget - base_tc\n            feas = [j for j in not_in if costs[j - 1] <= cap]\n            if feas:\n                j = max(feas, key=lambda k: (values[k - 1] \/ costs[k - 1], values[k - 1]))\n                # apply move\n                for rrm in worst_two:\n                    sol.remove(rrm)\n                sol.append(j)\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"2-1\"\n\n    # fallback: randomized greedy build\n    return greedy_build(), \"restart\", \"greedy\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def greedy_fill(sol):\n        in_set = set(sol)\n        cand = [i for i in range(1, n + 1) if i not in in_set]\n        cand.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = sol[:]\n        tc = sum(costs[i - 1] for i in res)\n        for i in cand:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    if not is_valid(solution):\n        # build a feasible start via greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = solution[:]\n\n    # choose number of removals\n    r = 1\n    if len(sol) > 4:\n        r = random.choice([1, 2, 3])\n    # remove r worst-density items\n    remove_order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n    to_remove = remove_order[: min(r, len(sol))]\n    sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # ensure feasibility via light repair\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        # remove worst-density until feasible\n        worst = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(worst)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0011744541}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def total_cost(sol):\n        return sum(costs[i - 1] for i in sol)\n\n    def total_value(sol):\n        return sum(values[i - 1] for i in sol)\n\n    def density(i):\n        return values[i - 1] \/ costs[i - 1]\n\n    def greedy_build():\n        items = list(range(1, n + 1))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    def repair(sol):\n        # Remove worst densities until feasible\n        tc = total_cost(sol)\n        if tc <= budget:\n            return sol\n        # sort ascending by density, then value\n        order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        res = sol[:]\n        for i in order:\n            if tc <= budget:\n                break\n            res.remove(i)\n            tc -= costs[i - 1]\n        return res\n\n    sol = solution[:] if is_valid(solution) else greedy_build()\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n    tc = total_cost(sol)\n\n    # Adaptive operator selection based on simple random choice (lightweight)\n    ops = [\"add\", \"remove\", \"swap\", \"two_exchange\"]\n    weights = [0.4, 0.25, 0.25, 0.10]\n    op = random.choices(ops, weights=weights, k=1)[0]\n\n    # ADD: add one feasible item by best density among feasible candidates\n    if op == \"add\":\n        feas = [(i, density(i)) for i in not_in if tc + costs[i - 1] <= budget]\n        if feas:\n            feas.sort(key=lambda x: (x[1], values[x[0] - 1]), reverse=True)\n            i = random.choice(feas[: min(3, len(feas))])[0]\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE: remove lowest density item currently selected\n    if op == \"remove\" and sol:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(rem)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1: try to swap out a low-density selected item for higher-density non-selected if feasible\n    if op == \"swap\" and sol and not_in:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        cap = budget - (tc - costs[rem - 1])\n        feas = [j for j in not_in if costs[j - 1] <= cap]\n        if feas:\n            feas.sort(key=lambda j: (values[j - 1] \/ costs[j - 1], values[j - 1]), reverse=True)\n            # pick top few candidates\n            for j in feas[: min(5, len(feas))]:\n                if values[j - 1] > values[rem - 1] or (values[j - 1] \/ costs[j - 1]) > (values[rem - 1] \/ costs[rem - 1]):\n                    sol.remove(rem)\n                    sol.append(j)\n                    return sol, \"swap\", \"1-1\"\n\n    # TWO-EXCHANGE: attempt 1-2 or 2-1 move\n    if op == \"two_exchange\" and sol and not_in:\n        # 1-2: remove one, add two if feasible\n        if len(not_in) >= 2:\n            rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            base_tc = tc - costs[rem - 1]\n            # prefilter candidates by cost <= remaining capacity\n            cap = budget - base_tc\n            cand = [j for j in not_in if costs[j - 1] <= cap]\n            cand.sort(key=lambda j: costs[j - 1])\n            # two-pointer search for pair within cap, prioritizing better densities\n            best_pair = None\n            best_score = -1.0\n            l, r = 0, len(cand) - 1\n            while l < r:\n                csum = costs[cand[l] - 1] + costs[cand[r] - 1]\n                if csum <= cap:\n                    score = (values[cand[l] - 1] \/ costs[cand[l] - 1]) + (values[cand[r] - 1] \/ costs[cand[r] - 1])\n                    if score > best_score:\n                        best_score = score\n                        best_pair = (cand[l], cand[r])\n                    l += 1\n                else:\n                    r -= 1\n            if best_pair is not None:\n                sol.remove(rem)\n                sol.extend(list(best_pair))\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"1-2\"\n        # 2-1: remove two, add one\n        if len(sol) >= 2:\n            # remove two worst densities\n            worst_two = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))[:2]\n            base_tc = tc - costs[worst_two[0] - 1] - costs[worst_two[1] - 1]\n            cap = budget - base_tc\n            feas = [j for j in not_in if costs[j - 1] <= cap]\n            if feas:\n                j = max(feas, key=lambda k: (values[k - 1] \/ costs[k - 1], values[k - 1]))\n                # apply move\n                for rrm in worst_two:\n                    sol.remove(rrm)\n                sol.append(j)\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"2-1\"\n\n    # fallback: randomized greedy build\n    return greedy_build(), \"restart\", \"greedy\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def greedy_fill(sol):\n        in_set = set(sol)\n        cand = [i for i in range(1, n + 1) if i not in in_set]\n        cand.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = sol[:]\n        tc = sum(costs[i - 1] for i in res)\n        for i in cand:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    if not is_valid(solution):\n        # build a feasible start via greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = solution[:]\n\n    # choose number of removals\n    r = 1\n    if len(sol) > 4:\n        r = random.choice([1, 2, 3])\n    # remove r worst-density items\n    remove_order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n    to_remove = remove_order[: min(r, len(sol))]\n    sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # ensure feasibility via light repair\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        # remove worst-density until feasible\n        worst = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(worst)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001459409}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def total_cost(sol):\n        return sum(costs[i - 1] for i in sol)\n\n    def total_value(sol):\n        return sum(values[i - 1] for i in sol)\n\n    def density(i):\n        return values[i - 1] \/ costs[i - 1]\n\n    def greedy_build():\n        items = list(range(1, n + 1))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    def repair(sol):\n        # Remove worst densities until feasible\n        tc = total_cost(sol)\n        if tc <= budget:\n            return sol\n        # sort ascending by density, then value\n        order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        res = sol[:]\n        for i in order:\n            if tc <= budget:\n                break\n            res.remove(i)\n            tc -= costs[i - 1]\n        return res\n\n    sol = solution[:] if is_valid(solution) else greedy_build()\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n    tc = total_cost(sol)\n\n    # Adaptive operator selection based on simple random choice (lightweight)\n    ops = [\"add\", \"remove\", \"swap\", \"two_exchange\"]\n    weights = [0.4, 0.25, 0.25, 0.10]\n    op = random.choices(ops, weights=weights, k=1)[0]\n\n    # ADD: add one feasible item by best density among feasible candidates\n    if op == \"add\":\n        feas = [(i, density(i)) for i in not_in if tc + costs[i - 1] <= budget]\n        if feas:\n            feas.sort(key=lambda x: (x[1], values[x[0] - 1]), reverse=True)\n            i = random.choice(feas[: min(3, len(feas))])[0]\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE: remove lowest density item currently selected\n    if op == \"remove\" and sol:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(rem)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1: try to swap out a low-density selected item for higher-density non-selected if feasible\n    if op == \"swap\" and sol and not_in:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        cap = budget - (tc - costs[rem - 1])\n        feas = [j for j in not_in if costs[j - 1] <= cap]\n        if feas:\n            feas.sort(key=lambda j: (values[j - 1] \/ costs[j - 1], values[j - 1]), reverse=True)\n            # pick top few candidates\n            for j in feas[: min(5, len(feas))]:\n                if values[j - 1] > values[rem - 1] or (values[j - 1] \/ costs[j - 1]) > (values[rem - 1] \/ costs[rem - 1]):\n                    sol.remove(rem)\n                    sol.append(j)\n                    return sol, \"swap\", \"1-1\"\n\n    # TWO-EXCHANGE: attempt 1-2 or 2-1 move\n    if op == \"two_exchange\" and sol and not_in:\n        # 1-2: remove one, add two if feasible\n        if len(not_in) >= 2:\n            rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            base_tc = tc - costs[rem - 1]\n            # prefilter candidates by cost <= remaining capacity\n            cap = budget - base_tc\n            cand = [j for j in not_in if costs[j - 1] <= cap]\n            cand.sort(key=lambda j: costs[j - 1])\n            # two-pointer search for pair within cap, prioritizing better densities\n            best_pair = None\n            best_score = -1.0\n            l, r = 0, len(cand) - 1\n            while l < r:\n                csum = costs[cand[l] - 1] + costs[cand[r] - 1]\n                if csum <= cap:\n                    score = (values[cand[l] - 1] \/ costs[cand[l] - 1]) + (values[cand[r] - 1] \/ costs[cand[r] - 1])\n                    if score > best_score:\n                        best_score = score\n                        best_pair = (cand[l], cand[r])\n                    l += 1\n                else:\n                    r -= 1\n            if best_pair is not None:\n                sol.remove(rem)\n                sol.extend(list(best_pair))\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"1-2\"\n        # 2-1: remove two, add one\n        if len(sol) >= 2:\n            # remove two worst densities\n            worst_two = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))[:2]\n            base_tc = tc - costs[worst_two[0] - 1] - costs[worst_two[1] - 1]\n            cap = budget - base_tc\n            feas = [j for j in not_in if costs[j - 1] <= cap]\n            if feas:\n                j = max(feas, key=lambda k: (values[k - 1] \/ costs[k - 1], values[k - 1]))\n                # apply move\n                for rrm in worst_two:\n                    sol.remove(rrm)\n                sol.append(j)\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"2-1\"\n\n    # fallback: randomized greedy build\n    return greedy_build(), \"restart\", \"greedy\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def greedy_fill(sol):\n        in_set = set(sol)\n        cand = [i for i in range(1, n + 1) if i not in in_set]\n        cand.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = sol[:]\n        tc = sum(costs[i - 1] for i in res)\n        for i in cand:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    if not is_valid(solution):\n        # build a feasible start via greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = solution[:]\n\n    # choose number of removals\n    r = 1\n    if len(sol) > 4:\n        r = random.choice([1, 2, 3])\n    # remove r worst-density items\n    remove_order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n    to_remove = remove_order[: min(r, len(sol))]\n    sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # ensure feasibility via light repair\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        # remove worst-density until feasible\n        worst = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(worst)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0014965989}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Example: \"8,4,18\". Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness where lower is better.\n    # Feasible: fitness = -total_value (so higher revenue -> more negative -> better)\n    # Infeasible\/invalid: large positive penalty\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = 1e18\n    # Type check\n    if not isinstance(solution, str):\n        return BAD\n    # Normalize tokens\n    raw_tokens = solution.split(',') if solution is not None else []\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return BAD\n        tokens.append(s)\n    # Parse IDs\n    ids_list = [int(t) for t in tokens]\n    # Duplicate check\n    if len(ids_list) != len(set(ids_list)):\n        return BAD\n    # Range check\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return BAD\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)","Vecindad":"import random\nfrom typing import Tuple, List, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_string, movement_type)\n    # Representation: comma-separated unique IDs with no spaces\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == \"\":\n            return []\n        ids = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            ids.append(int(s))\n        # enforce unique & valid range\n        ids = [i for i in ids if 1 <= i <= 24]\n        ids = sorted(set(ids))\n        return ids\n\n    def encode(ids: List[int]) -> str:\n        return \",\".join(str(i) for i in ids)\n\n    ids = parse(solution)\n    current_set: Set[int] = set(ids)\n\n    # Define candidate pools\n    all_ids = list(range(1, 25))\n\n    # Decide move type\n    move_types = [\"add\", \"remove\", \"swap\"]\n    # Bias towards feasibility-aware moves if overweight\n    # Compute current weight\n    cur_w = 0\n    for i in ids:\n        cur_w += offers[i][1]\n\n    if cur_w > CAP:\n        # Prefer remove when overweight\n        weights = [0.7, 0.2, 0.1]\n    elif len(ids) == 0:\n        weights = [0.6, 0.1, 0.3]\n    else:\n        weights = [0.45, 0.2, 0.35]\n\n    r = random.random()\n    if r < weights[0]:\n        move = \"add\"\n    elif r < weights[0] + weights[1]:\n        move = \"remove\"\n    else:\n        move = \"swap\"\n\n    new_set = set(current_set)\n\n    if move == \"add\":\n        candidates = [i for i in all_ids if i not in new_set]\n        if candidates:\n            i = random.choice(candidates)\n            new_set.add(i)\n    elif move == \"remove\":\n        if new_set:\n            i = random.choice(list(new_set))\n            new_set.remove(i)\n    else:  # swap\n        if all_ids:\n            add_i = random.choice(all_ids)\n            new_set.add(add_i)\n            if len(new_set) > 0:\n                rem_i = random.choice(list(new_set))\n                new_set.remove(rem_i)\n                # ensure swap changed something\n                if rem_i == add_i and len(all_ids) > 1:\n                    # force different\n                    alt = random.choice([x for x in all_ids if x != add_i])\n                    new_set.add(alt)\n\n    new_ids = sorted(new_set)\n    neighbour_solution = encode(new_ids)\n    return neighbour_solution, move","Perturbacion":"import random\nfrom typing import List, Set\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random flips + greedy repair for feasibility\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == \"\":\n            return []\n        ids = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            ids.append(int(s))\n        ids = [i for i in ids if 1 <= i <= 24]\n        ids = sorted(set(ids))\n        return ids\n\n    def encode(ids: List[int]) -> str:\n        return \",\".join(str(i) for i in ids)\n\n    ids = parse(solution)\n    current: Set[int] = set(ids)\n\n    # Random flips count\n    flips = random.randint(3, 6)\n    universe = list(range(1, 25))\n\n    for _ in range(flips):\n        i = random.choice(universe)\n        if i in current:\n            current.remove(i)\n        else:\n            current.add(i)\n\n    # Greedy feasibility repair: if overweight, remove worst ratio first; if under, optionally add good small items\n    def total_w(S: Set[int]) -> int:\n        return sum(offers[i][1] for i in S)\n\n    def ratio(i: int) -> float:\n        v, w = offers[i]\n        return v \/ w if w > 0 else 0.0\n\n    # If overweight, remove by lowest value\/weight first\n    while total_w(current) > CAP and len(current) > 0:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Opportunistic fill with high ratio light items if capacity remains\n    # Consider only items not in set and with w <= remaining\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), offers[i][1]))\n    for i in candidates:\n        if offers[i][1] <= remaining:\n            current.add(i)\n            remaining -= offers[i][1]\n        if remaining <= 0:\n            break\n\n    new_ids = sorted(current)\n    return encode(new_ids)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000849881}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Example: \"8,4,18\". Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness where lower is better.\n    # Feasible: fitness = -total_value (so higher revenue -> more negative -> better)\n    # Infeasible\/invalid: large positive penalty\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = 1e18\n    # Type check\n    if not isinstance(solution, str):\n        return BAD\n    # Normalize tokens\n    raw_tokens = solution.split(',') if solution is not None else []\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return BAD\n        tokens.append(s)\n    # Parse IDs\n    ids_list = [int(t) for t in tokens]\n    # Duplicate check\n    if len(ids_list) != len(set(ids_list)):\n        return BAD\n    # Range check\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return BAD\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)","Vecindad":"import random\nfrom typing import Tuple, List, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_string, movement_type)\n    # Representation: comma-separated unique IDs with no spaces\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == \"\":\n            return []\n        ids = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            ids.append(int(s))\n        # enforce unique & valid range\n        ids = [i for i in ids if 1 <= i <= 24]\n        ids = sorted(set(ids))\n        return ids\n\n    def encode(ids: List[int]) -> str:\n        return \",\".join(str(i) for i in ids)\n\n    ids = parse(solution)\n    current_set: Set[int] = set(ids)\n\n    # Define candidate pools\n    all_ids = list(range(1, 25))\n\n    # Decide move type\n    move_types = [\"add\", \"remove\", \"swap\"]\n    # Bias towards feasibility-aware moves if overweight\n    # Compute current weight\n    cur_w = 0\n    for i in ids:\n        cur_w += offers[i][1]\n\n    if cur_w > CAP:\n        # Prefer remove when overweight\n        weights = [0.7, 0.2, 0.1]\n    elif len(ids) == 0:\n        weights = [0.6, 0.1, 0.3]\n    else:\n        weights = [0.45, 0.2, 0.35]\n\n    r = random.random()\n    if r < weights[0]:\n        move = \"add\"\n    elif r < weights[0] + weights[1]:\n        move = \"remove\"\n    else:\n        move = \"swap\"\n\n    new_set = set(current_set)\n\n    if move == \"add\":\n        candidates = [i for i in all_ids if i not in new_set]\n        if candidates:\n            i = random.choice(candidates)\n            new_set.add(i)\n    elif move == \"remove\":\n        if new_set:\n            i = random.choice(list(new_set))\n            new_set.remove(i)\n    else:  # swap\n        if all_ids:\n            add_i = random.choice(all_ids)\n            new_set.add(add_i)\n            if len(new_set) > 0:\n                rem_i = random.choice(list(new_set))\n                new_set.remove(rem_i)\n                # ensure swap changed something\n                if rem_i == add_i and len(all_ids) > 1:\n                    # force different\n                    alt = random.choice([x for x in all_ids if x != add_i])\n                    new_set.add(alt)\n\n    new_ids = sorted(new_set)\n    neighbour_solution = encode(new_ids)\n    return neighbour_solution, move","Perturbacion":"import random\nfrom typing import List, Set\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random flips + greedy repair for feasibility\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == \"\":\n            return []\n        ids = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            ids.append(int(s))\n        ids = [i for i in ids if 1 <= i <= 24]\n        ids = sorted(set(ids))\n        return ids\n\n    def encode(ids: List[int]) -> str:\n        return \",\".join(str(i) for i in ids)\n\n    ids = parse(solution)\n    current: Set[int] = set(ids)\n\n    # Random flips count\n    flips = random.randint(3, 6)\n    universe = list(range(1, 25))\n\n    for _ in range(flips):\n        i = random.choice(universe)\n        if i in current:\n            current.remove(i)\n        else:\n            current.add(i)\n\n    # Greedy feasibility repair: if overweight, remove worst ratio first; if under, optionally add good small items\n    def total_w(S: Set[int]) -> int:\n        return sum(offers[i][1] for i in S)\n\n    def ratio(i: int) -> float:\n        v, w = offers[i]\n        return v \/ w if w > 0 else 0.0\n\n    # If overweight, remove by lowest value\/weight first\n    while total_w(current) > CAP and len(current) > 0:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Opportunistic fill with high ratio light items if capacity remains\n    # Consider only items not in set and with w <= remaining\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), offers[i][1]))\n    for i in candidates:\n        if offers[i][1] <= remaining:\n            current.add(i)\n            remaining -= offers[i][1]\n        if remaining <= 0:\n            break\n\n    new_ids = sorted(current)\n    return encode(new_ids)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001121084}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Example: \"8,4,18\". Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\nfrom typing import List, Set\n\ndef evaluate_solution(solution):\n    # Returns a scalar fitness where lower is better.\n    # Feasible: fitness = -total_value (so higher revenue -> more negative -> better)\n    # Infeasible\/invalid: large positive penalty\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = 1e18\n    # Type check\n    if not isinstance(solution, str):\n        return BAD\n    # Normalize tokens\n    raw_tokens = solution.split(',') if solution is not None else []\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return BAD\n        tokens.append(s)\n    # Parse IDs\n    ids_list = [int(t) for t in tokens]\n    # Duplicate check\n    if len(ids_list) != len(set(ids_list)):\n        return BAD\n    # Range check\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return BAD\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)","Vecindad":"import random\nfrom typing import Tuple, List, Set\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_string, movement_type)\n    # Representation: comma-separated unique IDs with no spaces\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == \"\":\n            return []\n        ids = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            ids.append(int(s))\n        # enforce unique & valid range\n        ids = [i for i in ids if 1 <= i <= 24]\n        ids = sorted(set(ids))\n        return ids\n\n    def encode(ids: List[int]) -> str:\n        return \",\".join(str(i) for i in ids)\n\n    ids = parse(solution)\n    current_set: Set[int] = set(ids)\n\n    # Define candidate pools\n    all_ids = list(range(1, 25))\n\n    # Decide move type\n    move_types = [\"add\", \"remove\", \"swap\"]\n    # Bias towards feasibility-aware moves if overweight\n    # Compute current weight\n    cur_w = 0\n    for i in ids:\n        cur_w += offers[i][1]\n\n    if cur_w > CAP:\n        # Prefer remove when overweight\n        weights = [0.7, 0.2, 0.1]\n    elif len(ids) == 0:\n        weights = [0.6, 0.1, 0.3]\n    else:\n        weights = [0.45, 0.2, 0.35]\n\n    r = random.random()\n    if r < weights[0]:\n        move = \"add\"\n    elif r < weights[0] + weights[1]:\n        move = \"remove\"\n    else:\n        move = \"swap\"\n\n    new_set = set(current_set)\n\n    if move == \"add\":\n        candidates = [i for i in all_ids if i not in new_set]\n        if candidates:\n            i = random.choice(candidates)\n            new_set.add(i)\n    elif move == \"remove\":\n        if new_set:\n            i = random.choice(list(new_set))\n            new_set.remove(i)\n    else:  # swap\n        if all_ids:\n            add_i = random.choice(all_ids)\n            new_set.add(add_i)\n            if len(new_set) > 0:\n                rem_i = random.choice(list(new_set))\n                new_set.remove(rem_i)\n                # ensure swap changed something\n                if rem_i == add_i and len(all_ids) > 1:\n                    # force different\n                    alt = random.choice([x for x in all_ids if x != add_i])\n                    new_set.add(alt)\n\n    new_ids = sorted(new_set)\n    neighbour_solution = encode(new_ids)\n    return neighbour_solution, move","Perturbacion":"import random\nfrom typing import List, Set\n\ndef perturb_solution(solution):\n    # Strong perturbation: multiple random flips + greedy repair for feasibility\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol: str) -> List[int]:\n        if not isinstance(sol, str) or sol.strip() == \"\":\n            return []\n        ids = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            ids.append(int(s))\n        ids = [i for i in ids if 1 <= i <= 24]\n        ids = sorted(set(ids))\n        return ids\n\n    def encode(ids: List[int]) -> str:\n        return \",\".join(str(i) for i in ids)\n\n    ids = parse(solution)\n    current: Set[int] = set(ids)\n\n    # Random flips count\n    flips = random.randint(3, 6)\n    universe = list(range(1, 25))\n\n    for _ in range(flips):\n        i = random.choice(universe)\n        if i in current:\n            current.remove(i)\n        else:\n            current.add(i)\n\n    # Greedy feasibility repair: if overweight, remove worst ratio first; if under, optionally add good small items\n    def total_w(S: Set[int]) -> int:\n        return sum(offers[i][1] for i in S)\n\n    def ratio(i: int) -> float:\n        v, w = offers[i]\n        return v \/ w if w > 0 else 0.0\n\n    # If overweight, remove by lowest value\/weight first\n    while total_w(current) > CAP and len(current) > 0:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Opportunistic fill with high ratio light items if capacity remains\n    # Consider only items not in set and with w <= remaining\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), offers[i][1]))\n    for i in candidates:\n        if offers[i][1] <= remaining:\n            current.add(i)\n            remaining -= offers[i][1]\n        if remaining <= 0:\n            break\n\n    new_ids = sorted(current)\n    return encode(new_ids)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001084954}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = 1e18\n    if not isinstance(solution, str):\n        return BAD\n    # Normalize tokens\n    raw_tokens = solution.split(',') if solution is not None else []\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return BAD\n        tokens.append(s)\n    try:\n        ids_list = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # Duplicate and range check\n    if len(ids_list) != len(set(ids_list)):\n        return BAD\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return BAD\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return None\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return None\n            toks.append(int(s))\n        # duplicates or out of range invalidates\n        if len(toks) != len(set(toks)):\n            return None\n        for i in toks:\n            if i < 1 or i > 24:\n                return None\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids = parse_strict(solution)\n    if ids is None:\n        ids = []\n        movement = \"reset:empty\"\n    else:\n        movement = \"\"\n\n    current_set = set(ids)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current_set]\n\n    rem = remaining_cap(current_set)\n\n    # Decide move with feasibility awareness\n    if rem <= 0 and current_set:\n        move = \"remove\"\n    else:\n        r = random.random()\n        if r < 0.45:\n            move = \"add\"\n        elif r < 0.65:\n            move = \"remove\"\n        else:\n            move = \"swap\"\n\n    if move == \"add\":\n        # capacity-aware add\n        candidates = [i for i in not_in if offers[i][1] <= rem]\n        if candidates:\n            i = random.choice(candidates)\n            current_set.add(i)\n            movement = f\"add:{i}\" if not movement else movement\n        else:\n            # fallback: try a swap that fits\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current_set:\n            i = random.choice(list(current_set))\n            current_set.remove(i)\n            movement = f\"remove:{i}\" if not movement else movement\n        else:\n            # fallback to add if nothing to remove\n            move = \"add\"\n\n    if move == \"swap\":\n        if current_set:\n            out_i = random.choice(list(current_set))\n            # capacity remaining if we remove out_i first\n            cap_after_remove = rem + offers[out_i][1]\n            add_candidates = [j for j in not_in if offers[j][1] <= cap_after_remove and j != out_i]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.remove(out_i)\n                current_set.add(in_i)\n                movement = f\"swap:out={out_i},in={in_i}\" if not movement else movement\n            else:\n                # if no feasible swap, perform a remove to stay feasible\n                current_set.remove(out_i)\n                movement = f\"remove:{out_i}\" if not movement else movement\n        else:\n            # nothing to swap, try feasible add\n            add_candidates = [j for j in not_in if offers[j][1] <= rem]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.add(in_i)\n                movement = f\"add:{in_i}\" if not movement else movement\n\n    neighbour_solution = encode(current_set)\n    if movement == \"\":\n        movement = \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return []\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            toks.append(int(s))\n        if len(toks) != len(set(toks)):\n            return []\n        toks = [i for i in toks if 1 <= i <= 24]\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse_strict(solution))\n\n    universe = list(range(1, 25))\n\n    # Random flips\n    flips = random.randint(3, 6)\n    for _ in range(flips):\n        i = random.choice(universe)\n        if i in current:\n            current.remove(i)\n        else:\n            current.add(i)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    # Repair overweight: drop lowest value\/weight until feasible\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Opportunistic fill\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), offers[i][1]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Resultados":["2,14,19",-24.0,"4,8,18",-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001389837}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = 1e18\n    if not isinstance(solution, str):\n        return BAD\n    # Normalize tokens\n    raw_tokens = solution.split(',') if solution is not None else []\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return BAD\n        tokens.append(s)\n    try:\n        ids_list = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # Duplicate and range check\n    if len(ids_list) != len(set(ids_list)):\n        return BAD\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return BAD\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return None\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return None\n            toks.append(int(s))\n        # duplicates or out of range invalidates\n        if len(toks) != len(set(toks)):\n            return None\n        for i in toks:\n            if i < 1 or i > 24:\n                return None\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids = parse_strict(solution)\n    if ids is None:\n        ids = []\n        movement = \"reset:empty\"\n    else:\n        movement = \"\"\n\n    current_set = set(ids)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current_set]\n\n    rem = remaining_cap(current_set)\n\n    # Decide move with feasibility awareness\n    if rem <= 0 and current_set:\n        move = \"remove\"\n    else:\n        r = random.random()\n        if r < 0.45:\n            move = \"add\"\n        elif r < 0.65:\n            move = \"remove\"\n        else:\n            move = \"swap\"\n\n    if move == \"add\":\n        # capacity-aware add\n        candidates = [i for i in not_in if offers[i][1] <= rem]\n        if candidates:\n            i = random.choice(candidates)\n            current_set.add(i)\n            movement = f\"add:{i}\" if not movement else movement\n        else:\n            # fallback: try a swap that fits\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current_set:\n            i = random.choice(list(current_set))\n            current_set.remove(i)\n            movement = f\"remove:{i}\" if not movement else movement\n        else:\n            # fallback to add if nothing to remove\n            move = \"add\"\n\n    if move == \"swap\":\n        if current_set:\n            out_i = random.choice(list(current_set))\n            # capacity remaining if we remove out_i first\n            cap_after_remove = rem + offers[out_i][1]\n            add_candidates = [j for j in not_in if offers[j][1] <= cap_after_remove and j != out_i]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.remove(out_i)\n                current_set.add(in_i)\n                movement = f\"swap:out={out_i},in={in_i}\" if not movement else movement\n            else:\n                # if no feasible swap, perform a remove to stay feasible\n                current_set.remove(out_i)\n                movement = f\"remove:{out_i}\" if not movement else movement\n        else:\n            # nothing to swap, try feasible add\n            add_candidates = [j for j in not_in if offers[j][1] <= rem]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.add(in_i)\n                movement = f\"add:{in_i}\" if not movement else movement\n\n    neighbour_solution = encode(current_set)\n    if movement == \"\":\n        movement = \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return []\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            toks.append(int(s))\n        if len(toks) != len(set(toks)):\n            return []\n        toks = [i for i in toks if 1 <= i <= 24]\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse_strict(solution))\n\n    universe = list(range(1, 25))\n\n    # Random flips\n    flips = random.randint(3, 6)\n    for _ in range(flips):\n        i = random.choice(universe)\n        if i in current:\n            current.remove(i)\n        else:\n            current.add(i)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    # Repair overweight: drop lowest value\/weight until feasible\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Opportunistic fill\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), offers[i][1]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Resultados":["8,18",-5.0,"2,8,14,18",-49.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0022465989}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = 1e18\n    if not isinstance(solution, str):\n        return BAD\n    # Normalize tokens\n    raw_tokens = solution.split(',') if solution is not None else []\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return BAD\n        tokens.append(s)\n    try:\n        ids_list = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # Duplicate and range check\n    if len(ids_list) != len(set(ids_list)):\n        return BAD\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return BAD\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return None\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return None\n            toks.append(int(s))\n        # duplicates or out of range invalidates\n        if len(toks) != len(set(toks)):\n            return None\n        for i in toks:\n            if i < 1 or i > 24:\n                return None\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids = parse_strict(solution)\n    if ids is None:\n        ids = []\n        movement = \"reset:empty\"\n    else:\n        movement = \"\"\n\n    current_set = set(ids)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current_set]\n\n    rem = remaining_cap(current_set)\n\n    # Decide move with feasibility awareness\n    if rem <= 0 and current_set:\n        move = \"remove\"\n    else:\n        r = random.random()\n        if r < 0.45:\n            move = \"add\"\n        elif r < 0.65:\n            move = \"remove\"\n        else:\n            move = \"swap\"\n\n    if move == \"add\":\n        # capacity-aware add\n        candidates = [i for i in not_in if offers[i][1] <= rem]\n        if candidates:\n            i = random.choice(candidates)\n            current_set.add(i)\n            movement = f\"add:{i}\" if not movement else movement\n        else:\n            # fallback: try a swap that fits\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current_set:\n            i = random.choice(list(current_set))\n            current_set.remove(i)\n            movement = f\"remove:{i}\" if not movement else movement\n        else:\n            # fallback to add if nothing to remove\n            move = \"add\"\n\n    if move == \"swap\":\n        if current_set:\n            out_i = random.choice(list(current_set))\n            # capacity remaining if we remove out_i first\n            cap_after_remove = rem + offers[out_i][1]\n            add_candidates = [j for j in not_in if offers[j][1] <= cap_after_remove and j != out_i]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.remove(out_i)\n                current_set.add(in_i)\n                movement = f\"swap:out={out_i},in={in_i}\" if not movement else movement\n            else:\n                # if no feasible swap, perform a remove to stay feasible\n                current_set.remove(out_i)\n                movement = f\"remove:{out_i}\" if not movement else movement\n        else:\n            # nothing to swap, try feasible add\n            add_candidates = [j for j in not_in if offers[j][1] <= rem]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.add(in_i)\n                movement = f\"add:{in_i}\" if not movement else movement\n\n    neighbour_solution = encode(current_set)\n    if movement == \"\":\n        movement = \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return []\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            toks.append(int(s))\n        if len(toks) != len(set(toks)):\n            return []\n        toks = [i for i in toks if 1 <= i <= 24]\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse_strict(solution))\n\n    universe = list(range(1, 25))\n\n    # Random flips\n    flips = random.randint(3, 6)\n    for _ in range(flips):\n        i = random.choice(universe)\n        if i in current:\n            current.remove(i)\n        else:\n            current.add(i)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    # Repair overweight: drop lowest value\/weight until feasible\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Opportunistic fill\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), offers[i][1]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001207585}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    # Parse tokens strictly\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # duplicate or range invalid\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    # compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def ratio(i:int) -> float:\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def parse_and_repair(sol):\n        # Minimal-feasible repair: dedup, range filter, then drop worst ratio until feasible\n        if not isinstance(sol, str) or sol is None:\n            ids = []\n        else:\n            toks = []\n            for t in sol.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if not s.isdigit():\n                    # salvage nothing from non-digit tokens\n                    continue\n                toks.append(int(s))\n            # dedup preserving first occurrence\n            seen = set()\n            ids = []\n            for i in toks:\n                if 1 <= i <= 24 and i not in seen:\n                    seen.add(i)\n                    ids.append(i)\n        S = list(ids)\n        def total_w(L):\n            return sum(offers[i][1] for i in L)\n        mov_log = []\n        # repair overweight by removing worst ratio until feasible\n        while S and total_w(S) > CAP:\n            worst = min(S, key=lambda i: ratio(i))\n            S.remove(worst)\n            mov_log.append(f\"repair:remove:{worst}\")\n        return S, mov_log\n\n    def encode(ids_list):\n        # canonical order for set representation\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids, repair_log = parse_and_repair(solution)\n    current = set(ids)\n    movement_parts = list(repair_log)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current]\n    rem = remaining_cap(current)\n\n    # Decide neighbourhood based on capacity\n    # Candidate neighbourhoods: add, remove, swap(1-1 best gain), two_add, two_exchange (remove1+add2)\n    moves = []\n    if rem > 0:\n        moves.append('add')\n        moves.append('swap')\n        if rem >= 2:  # allow potential two-add if feasible by weights\n            moves.append('two_add')\n    if current:\n        moves.append('remove')\n        moves.append('swap')\n        moves.append('two_exchange')\n    if not moves:\n        moves = ['remove']\n\n    move = random.choice(moves)\n\n    # Implement moves\n    if move == 'add':\n        # capacity-aware add: pick best gain by ratio among feasible\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (ratio(i), offers[i][0]))\n            current.add(j)\n            movement_parts.append(f\"add:{j}\")\n        else:\n            move = 'swap'\n\n    if move == 'remove':\n        if current:\n            # remove worst ratio to keep room\n            i = min(current, key=lambda x: ratio(x))\n            current.remove(i)\n            movement_parts.append(f\"remove:{i}\")\n\n    if move == 'swap':\n        if current:\n            # best-improvement single swap\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and (best_gain > 0 or random.random() < 0.25):\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_parts.append(f\"swap:out={out_i},in={in_j}\")\n            elif current:\n                # fallback: random feasible remove\n                out_i = random.choice(list(current))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    if move == 'two_add':\n        # try to add up to two items greedily by ratio\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        cand.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n        added = []\n        remaining = rem\n        for j in cand:\n            wj = offers[j][1]\n            if wj <= remaining:\n                current.add(j)\n                added.append(j)\n                remaining -= wj\n                if len(added) >= 2:\n                    break\n        if added:\n            movement_parts.append(\"two_add:\" + \",\".join(str(x) for x in added))\n\n    if move == 'two_exchange':\n        # remove 1, add up to 2 under capacity with best net gain\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas = [j for j in not_in if offers[j][1] <= cap_after]\n                feas.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n                # consider add best one or best pair\n                # single add\n                if feas:\n                    gain1 = offers[feas[0]][0] - offers[out_i][0]\n                    if gain1 > best_gain:\n                        best_gain = gain1\n                        best = (out_i, [feas[0]])\n                # pair add\n                for a_idx in range(len(feas)):\n                    a = feas[a_idx]\n                    wa = offers[a][1]\n                    for b_idx in range(a_idx + 1, len(feas)):\n                        b = feas[b_idx]\n                        wb = offers[b][1]\n                        if wa + wb <= cap_after:\n                            gain2 = offers[a][0] + offers[b][0] - offers[out_i][0]\n                            if gain2 > best_gain:\n                                best_gain = gain2\n                                best = (out_i, [a, b])\n                            break  # feas sorted; further b will be heavier or worse\n            if best is not None and (best_gain > 0 or random.random() < 0.2):\n                out_i, ins = best\n                current.remove(out_i)\n                for j in ins:\n                    current.add(j)\n                movement_parts.append(\"two_exchange:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in ins))\n            else:\n                # fallback small remove to diversify\n                out_i = min(current, key=lambda x: ratio(x))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_parts) if movement_parts else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return []\n        ids = []\n        seen = set()\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                continue\n            i = int(s)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse(solution))\n    universe = list(range(1, 25))\n\n    # Destroy: remove k random items\n    k = random.randint(2, 4)\n    to_remove = random.sample(list(current), k=min(k, len(current))) if current else []\n    for i in to_remove:\n        current.remove(i)\n    # Random add flips on universe for diversification\n    flips = random.randint(2, 4)\n    for _ in range(flips):\n        j = random.choice(universe)\n        if j in current:\n            current.remove(j)\n        else:\n            current.add(j)\n\n    # Repair overweight by dropping worst ratio items\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Greedy refill by ratio up to capacity\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Resultados":["4,8,14",-38.0,"4,8,18",-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0021833669}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    # Parse tokens strictly\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # duplicate or range invalid\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    # compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def ratio(i:int) -> float:\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def parse_and_repair(sol):\n        # Minimal-feasible repair: dedup, range filter, then drop worst ratio until feasible\n        if not isinstance(sol, str) or sol is None:\n            ids = []\n        else:\n            toks = []\n            for t in sol.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if not s.isdigit():\n                    # salvage nothing from non-digit tokens\n                    continue\n                toks.append(int(s))\n            # dedup preserving first occurrence\n            seen = set()\n            ids = []\n            for i in toks:\n                if 1 <= i <= 24 and i not in seen:\n                    seen.add(i)\n                    ids.append(i)\n        S = list(ids)\n        def total_w(L):\n            return sum(offers[i][1] for i in L)\n        mov_log = []\n        # repair overweight by removing worst ratio until feasible\n        while S and total_w(S) > CAP:\n            worst = min(S, key=lambda i: ratio(i))\n            S.remove(worst)\n            mov_log.append(f\"repair:remove:{worst}\")\n        return S, mov_log\n\n    def encode(ids_list):\n        # canonical order for set representation\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids, repair_log = parse_and_repair(solution)\n    current = set(ids)\n    movement_parts = list(repair_log)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current]\n    rem = remaining_cap(current)\n\n    # Decide neighbourhood based on capacity\n    # Candidate neighbourhoods: add, remove, swap(1-1 best gain), two_add, two_exchange (remove1+add2)\n    moves = []\n    if rem > 0:\n        moves.append('add')\n        moves.append('swap')\n        if rem >= 2:  # allow potential two-add if feasible by weights\n            moves.append('two_add')\n    if current:\n        moves.append('remove')\n        moves.append('swap')\n        moves.append('two_exchange')\n    if not moves:\n        moves = ['remove']\n\n    move = random.choice(moves)\n\n    # Implement moves\n    if move == 'add':\n        # capacity-aware add: pick best gain by ratio among feasible\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (ratio(i), offers[i][0]))\n            current.add(j)\n            movement_parts.append(f\"add:{j}\")\n        else:\n            move = 'swap'\n\n    if move == 'remove':\n        if current:\n            # remove worst ratio to keep room\n            i = min(current, key=lambda x: ratio(x))\n            current.remove(i)\n            movement_parts.append(f\"remove:{i}\")\n\n    if move == 'swap':\n        if current:\n            # best-improvement single swap\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and (best_gain > 0 or random.random() < 0.25):\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_parts.append(f\"swap:out={out_i},in={in_j}\")\n            elif current:\n                # fallback: random feasible remove\n                out_i = random.choice(list(current))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    if move == 'two_add':\n        # try to add up to two items greedily by ratio\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        cand.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n        added = []\n        remaining = rem\n        for j in cand:\n            wj = offers[j][1]\n            if wj <= remaining:\n                current.add(j)\n                added.append(j)\n                remaining -= wj\n                if len(added) >= 2:\n                    break\n        if added:\n            movement_parts.append(\"two_add:\" + \",\".join(str(x) for x in added))\n\n    if move == 'two_exchange':\n        # remove 1, add up to 2 under capacity with best net gain\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas = [j for j in not_in if offers[j][1] <= cap_after]\n                feas.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n                # consider add best one or best pair\n                # single add\n                if feas:\n                    gain1 = offers[feas[0]][0] - offers[out_i][0]\n                    if gain1 > best_gain:\n                        best_gain = gain1\n                        best = (out_i, [feas[0]])\n                # pair add\n                for a_idx in range(len(feas)):\n                    a = feas[a_idx]\n                    wa = offers[a][1]\n                    for b_idx in range(a_idx + 1, len(feas)):\n                        b = feas[b_idx]\n                        wb = offers[b][1]\n                        if wa + wb <= cap_after:\n                            gain2 = offers[a][0] + offers[b][0] - offers[out_i][0]\n                            if gain2 > best_gain:\n                                best_gain = gain2\n                                best = (out_i, [a, b])\n                            break  # feas sorted; further b will be heavier or worse\n            if best is not None and (best_gain > 0 or random.random() < 0.2):\n                out_i, ins = best\n                current.remove(out_i)\n                for j in ins:\n                    current.add(j)\n                movement_parts.append(\"two_exchange:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in ins))\n            else:\n                # fallback small remove to diversify\n                out_i = min(current, key=lambda x: ratio(x))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_parts) if movement_parts else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return []\n        ids = []\n        seen = set()\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                continue\n            i = int(s)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse(solution))\n    universe = list(range(1, 25))\n\n    # Destroy: remove k random items\n    k = random.randint(2, 4)\n    to_remove = random.sample(list(current), k=min(k, len(current))) if current else []\n    for i in to_remove:\n        current.remove(i)\n    # Random add flips on universe for diversification\n    flips = random.randint(2, 4)\n    for _ in range(flips):\n        j = random.choice(universe)\n        if j in current:\n            current.remove(j)\n        else:\n            current.add(j)\n\n    # Repair overweight by dropping worst ratio items\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Greedy refill by ratio up to capacity\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Resultados":["2,8,18",0.0,"2,8,14,18",-49.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.002824886}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    # Parse tokens strictly\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # duplicate or range invalid\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    # compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def ratio(i:int) -> float:\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def parse_and_repair(sol):\n        # Minimal-feasible repair: dedup, range filter, then drop worst ratio until feasible\n        if not isinstance(sol, str) or sol is None:\n            ids = []\n        else:\n            toks = []\n            for t in sol.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if not s.isdigit():\n                    # salvage nothing from non-digit tokens\n                    continue\n                toks.append(int(s))\n            # dedup preserving first occurrence\n            seen = set()\n            ids = []\n            for i in toks:\n                if 1 <= i <= 24 and i not in seen:\n                    seen.add(i)\n                    ids.append(i)\n        S = list(ids)\n        def total_w(L):\n            return sum(offers[i][1] for i in L)\n        mov_log = []\n        # repair overweight by removing worst ratio until feasible\n        while S and total_w(S) > CAP:\n            worst = min(S, key=lambda i: ratio(i))\n            S.remove(worst)\n            mov_log.append(f\"repair:remove:{worst}\")\n        return S, mov_log\n\n    def encode(ids_list):\n        # canonical order for set representation\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids, repair_log = parse_and_repair(solution)\n    current = set(ids)\n    movement_parts = list(repair_log)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current]\n    rem = remaining_cap(current)\n\n    # Decide neighbourhood based on capacity\n    # Candidate neighbourhoods: add, remove, swap(1-1 best gain), two_add, two_exchange (remove1+add2)\n    moves = []\n    if rem > 0:\n        moves.append('add')\n        moves.append('swap')\n        if rem >= 2:  # allow potential two-add if feasible by weights\n            moves.append('two_add')\n    if current:\n        moves.append('remove')\n        moves.append('swap')\n        moves.append('two_exchange')\n    if not moves:\n        moves = ['remove']\n\n    move = random.choice(moves)\n\n    # Implement moves\n    if move == 'add':\n        # capacity-aware add: pick best gain by ratio among feasible\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (ratio(i), offers[i][0]))\n            current.add(j)\n            movement_parts.append(f\"add:{j}\")\n        else:\n            move = 'swap'\n\n    if move == 'remove':\n        if current:\n            # remove worst ratio to keep room\n            i = min(current, key=lambda x: ratio(x))\n            current.remove(i)\n            movement_parts.append(f\"remove:{i}\")\n\n    if move == 'swap':\n        if current:\n            # best-improvement single swap\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and (best_gain > 0 or random.random() < 0.25):\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_parts.append(f\"swap:out={out_i},in={in_j}\")\n            elif current:\n                # fallback: random feasible remove\n                out_i = random.choice(list(current))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    if move == 'two_add':\n        # try to add up to two items greedily by ratio\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        cand.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n        added = []\n        remaining = rem\n        for j in cand:\n            wj = offers[j][1]\n            if wj <= remaining:\n                current.add(j)\n                added.append(j)\n                remaining -= wj\n                if len(added) >= 2:\n                    break\n        if added:\n            movement_parts.append(\"two_add:\" + \",\".join(str(x) for x in added))\n\n    if move == 'two_exchange':\n        # remove 1, add up to 2 under capacity with best net gain\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas = [j for j in not_in if offers[j][1] <= cap_after]\n                feas.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n                # consider add best one or best pair\n                # single add\n                if feas:\n                    gain1 = offers[feas[0]][0] - offers[out_i][0]\n                    if gain1 > best_gain:\n                        best_gain = gain1\n                        best = (out_i, [feas[0]])\n                # pair add\n                for a_idx in range(len(feas)):\n                    a = feas[a_idx]\n                    wa = offers[a][1]\n                    for b_idx in range(a_idx + 1, len(feas)):\n                        b = feas[b_idx]\n                        wb = offers[b][1]\n                        if wa + wb <= cap_after:\n                            gain2 = offers[a][0] + offers[b][0] - offers[out_i][0]\n                            if gain2 > best_gain:\n                                best_gain = gain2\n                                best = (out_i, [a, b])\n                            break  # feas sorted; further b will be heavier or worse\n            if best is not None and (best_gain > 0 or random.random() < 0.2):\n                out_i, ins = best\n                current.remove(out_i)\n                for j in ins:\n                    current.add(j)\n                movement_parts.append(\"two_exchange:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in ins))\n            else:\n                # fallback small remove to diversify\n                out_i = min(current, key=lambda x: ratio(x))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_parts) if movement_parts else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return []\n        ids = []\n        seen = set()\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                continue\n            i = int(s)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse(solution))\n    universe = list(range(1, 25))\n\n    # Destroy: remove k random items\n    k = random.randint(2, 4)\n    to_remove = random.sample(list(current), k=min(k, len(current))) if current else []\n    for i in to_remove:\n        current.remove(i)\n    # Random add flips on universe for diversification\n    flips = random.randint(2, 4)\n    for _ in range(flips):\n        j = random.choice(universe)\n        if j in current:\n            current.remove(j)\n        else:\n            current.add(j)\n\n    # Repair overweight by dropping worst ratio items\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Greedy refill by ratio up to capacity\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 1).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0016748511}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\nimport itertools\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return None\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        if any(t != '' and not t.isdigit() for t in toks):\n            return None\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        if len(ids) != len(set(ids)):\n            return None\n        return ids\n\n    def exact_repair(ids):\n        # Given a list of ids, return a subset maximizing value under CAP using 0\/1 DP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        # reconstruct\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= items[k-1][2]\n        return set(chosen)\n\n    ids = parse_ids(solution)\n    if ids is None:\n        return \"\", \"invalid_input\"\n\n    current = set(ids)\n    # If overweight, exact repair on current set\n    if sum(offers[i][1] for i in current) > CAP:\n        repaired = exact_repair(list(current))\n        if repaired != current:\n            return encode(repaired), \"repair:exact\"\n        current = repaired\n\n    # neighborhood move selection\n    all_ids = set(range(1, 25))\n    not_in = list(all_ids - current)\n    rem = CAP - sum(offers[i][1] for i in current)\n\n    movement_log = []\n\n    def choose_best_additional(candidates, capacity):\n        # bounded enumeration up to size 2 for adds under capacity maximizing value gain\n        best_set = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(candidates, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= capacity:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_set = list(comb)\n        return best_set, (best_gain if best_set else -math.inf)\n\n    moves = []\n    if rem > 0:\n        moves.extend([\"add\", \"two_add\", \"swap\", \"one_to_two\"])\n    if current:\n        moves.extend([\"remove\", \"swap\", \"two_to_one\"]) \n    if not moves:\n        moves = [\"remove\"]\n\n    move = random.choice(moves)\n\n    if move == \"add\":\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (offers[i][0]\/offers[i][1], offers[i][0]))\n            current.add(j)\n            movement_log.append(f\"add:{j}\")\n        else:\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current:\n            i = min(current, key=lambda x: offers[x][0]\/offers[x][1])\n            current.remove(i)\n            movement_log.append(f\"remove:{i}\")\n\n    if move == \"swap\":\n        if current:\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and best_gain > 0:\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_log.append(f\"swap:out={out_i},in={in_j}\")\n\n    if move == \"two_add\":\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        add_set, gain = choose_best_additional(cand, rem)\n        if add_set:\n            for j in add_set:\n                current.add(j)\n            movement_log.append(\"two_add:\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"one_to_two\":\n        # remove 1, add up to 2\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                cand = [j for j in not_in if offers[j][1] <= cap_after]\n                add_set, gain = choose_best_additional(cand, cap_after)\n                net_gain = (gain if gain != -math.inf else -math.inf) - offers[out_i][0]\n                if gain != -math.inf and net_gain > best_gain:\n                    best_gain = net_gain\n                    best = (out_i, add_set)\n            if best is not None and best_gain > 0:\n                out_i, add_set = best\n                current.remove(out_i)\n                for j in add_set:\n                    current.add(j)\n                movement_log.append(\"one_to_two:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"two_to_one\":\n        # remove up to 2, add 1\n        if current:\n            best = None\n            best_gain = -math.inf\n            current_list = list(current)\n            for r in [1, 2]:\n                for rem_set in itertools.combinations(current_list, r):\n                    cap_after = rem + sum(offers[i][1] for i in rem_set)\n                    feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                    if not feas_in:\n                        continue\n                    j = max(feas_in, key=lambda i: offers[i][0])\n                    net_gain = offers[j][0] - sum(offers[i][0] for i in rem_set)\n                    if net_gain > best_gain:\n                        best_gain = net_gain\n                        best = (list(rem_set), j)\n            if best is not None and best_gain > 0:\n                rem_set, j = best\n                for i in rem_set:\n                    current.remove(i)\n                current.add(j)\n                movement_log.append(\"two_to_one:out=\" + \",\".join(str(x) for x in sorted(rem_set)) + \",in=\" + str(j))\n\n    # final exact feasibility repair if somehow overweight\n    if sum(offers[i][1] for i in current) > CAP:\n        current = exact_repair(list(current))\n        movement_log.append(\"repair:post_exact\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_log) if movement_log else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\nimport math\nimport itertools\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return []\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            if not t.isdigit():\n                return []\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def exact_repair(ids):\n        # Optimal subset of the given ids under CAP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= wt\n        return set(chosen)\n\n    cur = set(parse_ids(solution))\n    universe = list(range(1, 25))\n\n    # Destroy phase: random removals and flips\n    remove_k = random.randint(1, 3)\n    if cur:\n        for i in random.sample(list(cur), k=min(remove_k, len(cur))):\n            cur.remove(i)\n    flip_k = random.randint(2, 4)\n    for _ in range(flip_k):\n        j = random.choice(universe)\n        if j in cur:\n            cur.remove(j)\n        else:\n            cur.add(j)\n\n    # Repair overweight exactly on current set\n    if sum(offers[i][1] for i in cur) > CAP:\n        cur = exact_repair(list(cur))\n    \n    # Intensify: try to add up to two items from outside exactly under remaining capacity\n    rem = CAP - sum(offers[i][1] for i in cur)\n    if rem > 0:\n        outside = [j for j in universe if j not in cur]\n        best_add = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(outside, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= rem:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_add = list(comb)\n        for j in best_add:\n            cur.add(j)\n\n    return encode(cur)\n","Resultados":["13",-24.0,"4,8,18",-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.002353849}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\nimport itertools\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return None\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        if any(t != '' and not t.isdigit() for t in toks):\n            return None\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        if len(ids) != len(set(ids)):\n            return None\n        return ids\n\n    def exact_repair(ids):\n        # Given a list of ids, return a subset maximizing value under CAP using 0\/1 DP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        # reconstruct\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= items[k-1][2]\n        return set(chosen)\n\n    ids = parse_ids(solution)\n    if ids is None:\n        return \"\", \"invalid_input\"\n\n    current = set(ids)\n    # If overweight, exact repair on current set\n    if sum(offers[i][1] for i in current) > CAP:\n        repaired = exact_repair(list(current))\n        if repaired != current:\n            return encode(repaired), \"repair:exact\"\n        current = repaired\n\n    # neighborhood move selection\n    all_ids = set(range(1, 25))\n    not_in = list(all_ids - current)\n    rem = CAP - sum(offers[i][1] for i in current)\n\n    movement_log = []\n\n    def choose_best_additional(candidates, capacity):\n        # bounded enumeration up to size 2 for adds under capacity maximizing value gain\n        best_set = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(candidates, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= capacity:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_set = list(comb)\n        return best_set, (best_gain if best_set else -math.inf)\n\n    moves = []\n    if rem > 0:\n        moves.extend([\"add\", \"two_add\", \"swap\", \"one_to_two\"])\n    if current:\n        moves.extend([\"remove\", \"swap\", \"two_to_one\"]) \n    if not moves:\n        moves = [\"remove\"]\n\n    move = random.choice(moves)\n\n    if move == \"add\":\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (offers[i][0]\/offers[i][1], offers[i][0]))\n            current.add(j)\n            movement_log.append(f\"add:{j}\")\n        else:\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current:\n            i = min(current, key=lambda x: offers[x][0]\/offers[x][1])\n            current.remove(i)\n            movement_log.append(f\"remove:{i}\")\n\n    if move == \"swap\":\n        if current:\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and best_gain > 0:\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_log.append(f\"swap:out={out_i},in={in_j}\")\n\n    if move == \"two_add\":\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        add_set, gain = choose_best_additional(cand, rem)\n        if add_set:\n            for j in add_set:\n                current.add(j)\n            movement_log.append(\"two_add:\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"one_to_two\":\n        # remove 1, add up to 2\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                cand = [j for j in not_in if offers[j][1] <= cap_after]\n                add_set, gain = choose_best_additional(cand, cap_after)\n                net_gain = (gain if gain != -math.inf else -math.inf) - offers[out_i][0]\n                if gain != -math.inf and net_gain > best_gain:\n                    best_gain = net_gain\n                    best = (out_i, add_set)\n            if best is not None and best_gain > 0:\n                out_i, add_set = best\n                current.remove(out_i)\n                for j in add_set:\n                    current.add(j)\n                movement_log.append(\"one_to_two:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"two_to_one\":\n        # remove up to 2, add 1\n        if current:\n            best = None\n            best_gain = -math.inf\n            current_list = list(current)\n            for r in [1, 2]:\n                for rem_set in itertools.combinations(current_list, r):\n                    cap_after = rem + sum(offers[i][1] for i in rem_set)\n                    feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                    if not feas_in:\n                        continue\n                    j = max(feas_in, key=lambda i: offers[i][0])\n                    net_gain = offers[j][0] - sum(offers[i][0] for i in rem_set)\n                    if net_gain > best_gain:\n                        best_gain = net_gain\n                        best = (list(rem_set), j)\n            if best is not None and best_gain > 0:\n                rem_set, j = best\n                for i in rem_set:\n                    current.remove(i)\n                current.add(j)\n                movement_log.append(\"two_to_one:out=\" + \",\".join(str(x) for x in sorted(rem_set)) + \",in=\" + str(j))\n\n    # final exact feasibility repair if somehow overweight\n    if sum(offers[i][1] for i in current) > CAP:\n        current = exact_repair(list(current))\n        movement_log.append(\"repair:post_exact\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_log) if movement_log else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\nimport math\nimport itertools\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return []\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            if not t.isdigit():\n                return []\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def exact_repair(ids):\n        # Optimal subset of the given ids under CAP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= wt\n        return set(chosen)\n\n    cur = set(parse_ids(solution))\n    universe = list(range(1, 25))\n\n    # Destroy phase: random removals and flips\n    remove_k = random.randint(1, 3)\n    if cur:\n        for i in random.sample(list(cur), k=min(remove_k, len(cur))):\n            cur.remove(i)\n    flip_k = random.randint(2, 4)\n    for _ in range(flip_k):\n        j = random.choice(universe)\n        if j in cur:\n            cur.remove(j)\n        else:\n            cur.add(j)\n\n    # Repair overweight exactly on current set\n    if sum(offers[i][1] for i in cur) > CAP:\n        cur = exact_repair(list(cur))\n    \n    # Intensify: try to add up to two items from outside exactly under remaining capacity\n    rem = CAP - sum(offers[i][1] for i in cur)\n    if rem > 0:\n        outside = [j for j in universe if j not in cur]\n        best_add = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(outside, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= rem:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_add = list(comb)\n        for j in best_add:\n            cur.add(j)\n\n    return encode(cur)\n","Resultados":["8,14,18",0.0,"4,8,18",-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0057251219}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\nimport itertools\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return None\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        if any(t != '' and not t.isdigit() for t in toks):\n            return None\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        if len(ids) != len(set(ids)):\n            return None\n        return ids\n\n    def exact_repair(ids):\n        # Given a list of ids, return a subset maximizing value under CAP using 0\/1 DP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        # reconstruct\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= items[k-1][2]\n        return set(chosen)\n\n    ids = parse_ids(solution)\n    if ids is None:\n        return \"\", \"invalid_input\"\n\n    current = set(ids)\n    # If overweight, exact repair on current set\n    if sum(offers[i][1] for i in current) > CAP:\n        repaired = exact_repair(list(current))\n        if repaired != current:\n            return encode(repaired), \"repair:exact\"\n        current = repaired\n\n    # neighborhood move selection\n    all_ids = set(range(1, 25))\n    not_in = list(all_ids - current)\n    rem = CAP - sum(offers[i][1] for i in current)\n\n    movement_log = []\n\n    def choose_best_additional(candidates, capacity):\n        # bounded enumeration up to size 2 for adds under capacity maximizing value gain\n        best_set = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(candidates, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= capacity:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_set = list(comb)\n        return best_set, (best_gain if best_set else -math.inf)\n\n    moves = []\n    if rem > 0:\n        moves.extend([\"add\", \"two_add\", \"swap\", \"one_to_two\"])\n    if current:\n        moves.extend([\"remove\", \"swap\", \"two_to_one\"]) \n    if not moves:\n        moves = [\"remove\"]\n\n    move = random.choice(moves)\n\n    if move == \"add\":\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (offers[i][0]\/offers[i][1], offers[i][0]))\n            current.add(j)\n            movement_log.append(f\"add:{j}\")\n        else:\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current:\n            i = min(current, key=lambda x: offers[x][0]\/offers[x][1])\n            current.remove(i)\n            movement_log.append(f\"remove:{i}\")\n\n    if move == \"swap\":\n        if current:\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and best_gain > 0:\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_log.append(f\"swap:out={out_i},in={in_j}\")\n\n    if move == \"two_add\":\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        add_set, gain = choose_best_additional(cand, rem)\n        if add_set:\n            for j in add_set:\n                current.add(j)\n            movement_log.append(\"two_add:\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"one_to_two\":\n        # remove 1, add up to 2\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                cand = [j for j in not_in if offers[j][1] <= cap_after]\n                add_set, gain = choose_best_additional(cand, cap_after)\n                net_gain = (gain if gain != -math.inf else -math.inf) - offers[out_i][0]\n                if gain != -math.inf and net_gain > best_gain:\n                    best_gain = net_gain\n                    best = (out_i, add_set)\n            if best is not None and best_gain > 0:\n                out_i, add_set = best\n                current.remove(out_i)\n                for j in add_set:\n                    current.add(j)\n                movement_log.append(\"one_to_two:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"two_to_one\":\n        # remove up to 2, add 1\n        if current:\n            best = None\n            best_gain = -math.inf\n            current_list = list(current)\n            for r in [1, 2]:\n                for rem_set in itertools.combinations(current_list, r):\n                    cap_after = rem + sum(offers[i][1] for i in rem_set)\n                    feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                    if not feas_in:\n                        continue\n                    j = max(feas_in, key=lambda i: offers[i][0])\n                    net_gain = offers[j][0] - sum(offers[i][0] for i in rem_set)\n                    if net_gain > best_gain:\n                        best_gain = net_gain\n                        best = (list(rem_set), j)\n            if best is not None and best_gain > 0:\n                rem_set, j = best\n                for i in rem_set:\n                    current.remove(i)\n                current.add(j)\n                movement_log.append(\"two_to_one:out=\" + \",\".join(str(x) for x in sorted(rem_set)) + \",in=\" + str(j))\n\n    # final exact feasibility repair if somehow overweight\n    if sum(offers[i][1] for i in current) > CAP:\n        current = exact_repair(list(current))\n        movement_log.append(\"repair:post_exact\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_log) if movement_log else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\nimport math\nimport itertools\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return []\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            if not t.isdigit():\n                return []\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def exact_repair(ids):\n        # Optimal subset of the given ids under CAP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= wt\n        return set(chosen)\n\n    cur = set(parse_ids(solution))\n    universe = list(range(1, 25))\n\n    # Destroy phase: random removals and flips\n    remove_k = random.randint(1, 3)\n    if cur:\n        for i in random.sample(list(cur), k=min(remove_k, len(cur))):\n            cur.remove(i)\n    flip_k = random.randint(2, 4)\n    for _ in range(flip_k):\n        j = random.choice(universe)\n        if j in cur:\n            cur.remove(j)\n        else:\n            cur.add(j)\n\n    # Repair overweight exactly on current set\n    if sum(offers[i][1] for i in cur) > CAP:\n        cur = exact_repair(list(cur))\n    \n    # Intensify: try to add up to two items from outside exactly under remaining capacity\n    rem = CAP - sum(offers[i][1] for i in cur)\n    if rem > 0:\n        outside = [j for j in universe if j not in cur]\n        best_add = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(outside, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= rem:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_add = list(comb)\n        for j in best_add:\n            cur.add(j)\n\n    return encode(cur)\n","Resultados":"Failed to run target heuristic: not enough values to unpack (expected 2, got 0).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.002136476}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES (solution is a Python list of distinct integers in [1,24])","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (since we maximize value).\n    Infeasible or invalid solutions return a large positive penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = 24\n\n    penalty = 1e12\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min (SA expects lesser cost better)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Note: The neighbor construction itself should be handled by the caller\/other components if needed.\n    \"\"\"\n    # Decide operation type probabilistically based on current solution size\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n    r = random.random()\n    if r < 0.34:\n        return (\"Swap\", \"1-1\")\n    elif r < 0.67:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol\n        # Sort by ascending value\/time (worst first), drop until feasible\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            keep.remove(i)\n        # If still infeasible due to large single item times, trim further\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n+1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n+1) if i not in S]\n        random.shuffle(add_cands)\n        if add_cands:\n            S.add(add_cands[0])\n\n    perturbed = list(S)\n    # Repair feasibility if needed\n    perturbed = greedy_repair(perturbed)\n\n    # Optional greedy fill to utilize remaining capacity with good items\n    remaining = capacity - sum(times[i] for i in perturbed)\n    if remaining > 0:\n        candidates = [i for i in range(1, n+1) if i not in perturbed and times[i] <= remaining]\n        # try to add by best value\/time ratio first\n        for i in sorted(candidates, key=lambda i: (-values[i]\/times[i], -values[i])):\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n    # Final dedup and order normalize\n    perturbed = sorted(set(perturbed))\n    # Ensure feasibility\n    if not is_feasible(perturbed):\n        # fallback: build a fresh greedy feasible solution from scratch\n        items = list(range(1, n+1))\n        items = [i for i in items if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i]\/times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n    return perturbed\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0003649141}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES (solution is a Python list of distinct integers in [1,24])","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (since we maximize value).\n    Infeasible or invalid solutions return a large positive penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = 24\n\n    penalty = 1e12\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min (SA expects lesser cost better)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Note: The neighbor construction itself should be handled by the caller\/other components if needed.\n    \"\"\"\n    # Decide operation type probabilistically based on current solution size\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n    r = random.random()\n    if r < 0.34:\n        return (\"Swap\", \"1-1\")\n    elif r < 0.67:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol\n        # Sort by ascending value\/time (worst first), drop until feasible\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            keep.remove(i)\n        # If still infeasible due to large single item times, trim further\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n+1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n+1) if i not in S]\n        random.shuffle(add_cands)\n        if add_cands:\n            S.add(add_cands[0])\n\n    perturbed = list(S)\n    # Repair feasibility if needed\n    perturbed = greedy_repair(perturbed)\n\n    # Optional greedy fill to utilize remaining capacity with good items\n    remaining = capacity - sum(times[i] for i in perturbed)\n    if remaining > 0:\n        candidates = [i for i in range(1, n+1) if i not in perturbed and times[i] <= remaining]\n        # try to add by best value\/time ratio first\n        for i in sorted(candidates, key=lambda i: (-values[i]\/times[i], -values[i])):\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n    # Final dedup and order normalize\n    perturbed = sorted(set(perturbed))\n    # Ensure feasibility\n    if not is_feasible(perturbed):\n        # fallback: build a fresh greedy feasible solution from scratch\n        items = list(range(1, n+1))\n        items = [i for i in items if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i]\/times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n    return perturbed\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.000871371}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES (solution is a Python list of distinct integers in [1,24])","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution) -> float:\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (since we maximize value).\n    Infeasible or invalid solutions return a large positive penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = 24\n\n    penalty = 1e12\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min (SA expects lesser cost better)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Note: The neighbor construction itself should be handled by the caller\/other components if needed.\n    \"\"\"\n    # Decide operation type probabilistically based on current solution size\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n    r = random.random()\n    if r < 0.34:\n        return (\"Swap\", \"1-1\")\n    elif r < 0.67:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol: List[int]) -> List[int]:\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol\n        # Sort by ascending value\/time (worst first), drop until feasible\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            keep.remove(i)\n        # If still infeasible due to large single item times, trim further\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n+1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n+1) if i not in S]\n        random.shuffle(add_cands)\n        if add_cands:\n            S.add(add_cands[0])\n\n    perturbed = list(S)\n    # Repair feasibility if needed\n    perturbed = greedy_repair(perturbed)\n\n    # Optional greedy fill to utilize remaining capacity with good items\n    remaining = capacity - sum(times[i] for i in perturbed)\n    if remaining > 0:\n        candidates = [i for i in range(1, n+1) if i not in perturbed and times[i] <= remaining]\n        # try to add by best value\/time ratio first\n        for i in sorted(candidates, key=lambda i: (-values[i]\/times[i], -values[i])):\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n    # Final dedup and order normalize\n    perturbed = sorted(set(perturbed))\n    # Ensure feasibility\n    if not is_feasible(perturbed):\n        # fallback: build a fresh greedy feasible solution from scratch\n        items = list(range(1, n+1))\n        items = [i for i in items if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i]\/times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n    return perturbed\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00079937}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (since we maximize value).\n    Infeasible or invalid solutions return a large positive penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1  # 24\n\n    penalty = float('inf')\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current fill level estimate.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    # Adaptive probabilities: fewer items -> prefer Add; many items -> prefer Drop; otherwise mix in Swap\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))  # discourage adds as size grows\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":[[4,8,18],-59.0,[4,8,18],-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000497186}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (since we maximize value).\n    Infeasible or invalid solutions return a large positive penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1  # 24\n\n    penalty = float('inf')\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current fill level estimate.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    # Adaptive probabilities: fewer items -> prefer Add; many items -> prefer Drop; otherwise mix in Swap\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))  # discourage adds as size grows\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":["Drop",null,[4,8,18],-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0012749759}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (since we maximize value).\n    Infeasible or invalid solutions return a large positive penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1  # 24\n\n    penalty = float('inf')\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current fill level estimate.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    # Adaptive probabilities: fewer items -> prefer Add; many items -> prefer Drop; otherwise mix in Swap\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))  # discourage adds as size grows\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.000845641}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":[[4,8,18],-59.0,[4,8,18],-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000456096}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":["Add",1000000000.0,[4,8,18],-59.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0013194761}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00082345}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting encouraging adds when small, swaps otherwise\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sorted(set(sol))\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return sorted(set(keep))\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":["Add",1000000000.0,{"current":[2,8,14,18],"currentScore":-70.0,"best":[2,8,14,18],"bestScore":-70.0},1000000000.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000440156}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting encouraging adds when small, swaps otherwise\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sorted(set(sol))\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return sorted(set(keep))\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":["Add",1000000000.0,{"current":[2,8,14,18],"currentScore":-70.0,"best":[2,8,14,18],"bestScore":-70.0},1000000000.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001378917}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting encouraging adds when small, swaps otherwise\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sorted(set(sol))\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return sorted(set(keep))\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0008454}
