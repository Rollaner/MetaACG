{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24. Index i (1-based) corresponds to Decoration i. Character '1' means selected, '0' means not selected. Example: '101...'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs: List[int] = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values: List[int] = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget: int = 3040\n\n    # Decode solution\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(c not in '01' for c in solution):\n        return float('inf')  # Invalid encoding -> worst\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better. Feasible -> negative value; Infeasible -> large positive penalty\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1e9 + over","Vecindad":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef generate_neighbour(solution: str) -> Tuple[str, str]:\n    # Returns (neighbor_solution_encoded_as_BIN_STR, Movement_Type)\n    if not isinstance(solution, str) or len(solution) == 0:\n        # Fallback to a single '0' if invalid\n        return ('0', 'single_bit_flip')\n    n = len(solution)\n    idx = random.randrange(n)\n    neighbor = _flip_bit(solution, idx)\n    return (neighbor, 'single_bit_flip')","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-bit random flips (k ~ Uniform[2, max(2, n\/\/6)]) for diversification\n    if not isinstance(solution, str) or len(solution) == 0:\n        return '0'\n    n = len(solution)\n    k = max(2, n \/\/ 6)\n    k = random.randint(2, k)\n    idxs = random.sample(range(n), k=min(k, n))\n    sol_list: List[str] = list(solution)\n    for i in idxs:\n        sol_list[i] = '0' if sol_list[i] == '1' else '1'\n    return ''.join(sol_list)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0004012049}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24. Index i (1-based) corresponds to Decoration i. Character '1' means selected, '0' means not selected. Example: '101...'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs: List[int] = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values: List[int] = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget: int = 3040\n\n    # Decode solution\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(c not in '01' for c in solution):\n        return float('inf')  # Invalid encoding -> worst\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better. Feasible -> negative value; Infeasible -> large positive penalty\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1e9 + over","Vecindad":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef generate_neighbour(solution: str) -> Tuple[str, str]:\n    # Returns (neighbor_solution_encoded_as_BIN_STR, Movement_Type)\n    if not isinstance(solution, str) or len(solution) == 0:\n        # Fallback to a single '0' if invalid\n        return ('0', 'single_bit_flip')\n    n = len(solution)\n    idx = random.randrange(n)\n    neighbor = _flip_bit(solution, idx)\n    return (neighbor, 'single_bit_flip')","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-bit random flips (k ~ Uniform[2, max(2, n\/\/6)]) for diversification\n    if not isinstance(solution, str) or len(solution) == 0:\n        return '0'\n    n = len(solution)\n    k = max(2, n \/\/ 6)\n    k = random.randint(2, k)\n    idxs = random.sample(range(n), k=min(k, n))\n    sol_list: List[str] = list(solution)\n    for i in idxs:\n        sol_list[i] = '0' if sol_list[i] == '1' else '1'\n    return ''.join(sol_list)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000369354}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24. Index i (1-based) corresponds to Decoration i. Character '1' means selected, '0' means not selected. Example: '101...'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs: List[int] = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values: List[int] = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget: int = 3040\n\n    # Decode solution\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(c not in '01' for c in solution):\n        return float('inf')  # Invalid encoding -> worst\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better. Feasible -> negative value; Infeasible -> large positive penalty\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1e9 + over","Vecindad":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef generate_neighbour(solution: str) -> Tuple[str, str]:\n    # Returns (neighbor_solution_encoded_as_BIN_STR, Movement_Type)\n    if not isinstance(solution, str) or len(solution) == 0:\n        # Fallback to a single '0' if invalid\n        return ('0', 'single_bit_flip')\n    n = len(solution)\n    idx = random.randrange(n)\n    neighbor = _flip_bit(solution, idx)\n    return (neighbor, 'single_bit_flip')","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-bit random flips (k ~ Uniform[2, max(2, n\/\/6)]) for diversification\n    if not isinstance(solution, str) or len(solution) == 0:\n        return '0'\n    n = len(solution)\n    k = max(2, n \/\/ 6)\n    k = random.randint(2, k)\n    idxs = random.sample(range(n), k=min(k, n))\n    sol_list: List[str] = list(solution)\n    for i in idxs:\n        sol_list[i] = '0' if sol_list[i] == '1' else '1'\n    return ''.join(sol_list)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000363895}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24; index i (1-based) corresponds to Decoration i; '1' means selected, '0' means not selected.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better.\n    # Feasible: negative of total value.\n    # Infeasible: dynamic penalty preferring lower overage and higher value.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Dynamic penalty: base + scaled overage - tiny value term to softly rank among infeasible\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\n\n# Helper ops kept local to avoid globals\n\ndef _flip_bit(s, idx):\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef _ensure_len_or_zeroes(s, n):\n    if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n        return '0' * n\n    return s\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    move_types = ['single_flip', 'double_flip', 'triple_flip', 'swap_1in1out', 'biased_flip']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'triple_flip':\n        k = 3 if n >= 3 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'triple_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            # Fallback to single\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        i_out = random.choice(ones)\n        i_in = random.choice(zeros)\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    # biased_flip\n    ratios = [(values[i] \/ float(costs[i]), i) for i in range(n)]\n    ratios.sort(reverse=True)\n    # Choose better ratio index to add, worse ratio index to drop\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    nb = s\n    performed = False\n    if zeros:\n        # bias toward top quartile of ratios among zeros\n        zero_ratios = [(values[i] \/ float(costs[i]), i) for i in zeros]\n        zero_ratios.sort(reverse=True)\n        k = max(1, len(zero_ratios)\/\/4)\n        idx_in = random.choice([i for _, i in zero_ratios[:k]])\n        nb = _flip_bit(nb, idx_in)\n        performed = True\n    if ones:\n        one_ratios = [(values[i] \/ float(costs[i]), i) for i in ones]\n        one_ratios.sort()  # drop worst\n        k = max(1, len(one_ratios)\/\/4)\n        idx_out = random.choice([i for _, i in one_ratios[:k]])\n        nb = _flip_bit(nb, idx_out)\n        performed = True\n    if not performed:\n        idx = random.randrange(n)\n        nb = _flip_bit(nb, idx)\n    return (nb, 'biased_flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    # Validate \/ normalize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        s = '0' * n\n    else:\n        s = solution\n\n    # Step 1: random multi-bit flips (3-6 or up to n)\n    if n > 0:\n        k = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), k)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helper to compute cost\/value quickly\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair feasibility if over budget by dropping worst value-to-cost items first\n    tc, tv = cv(s)\n    if tc > budget:\n        indices = [i for i, ch in enumerate(s) if ch == '1']\n        # sort by ascending value density and higher cost tie-break to shed costly low value\n        indices.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in indices:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy add best ratio items while remaining under budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i] \/ float(costs[i])), costs[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: _flip_bit() missing 1 required positional argument: 'idx'.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000930871}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24; index i (1-based) corresponds to Decoration i; '1' means selected, '0' means not selected.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better.\n    # Feasible: negative of total value.\n    # Infeasible: dynamic penalty preferring lower overage and higher value.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Dynamic penalty: base + scaled overage - tiny value term to softly rank among infeasible\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\n\n# Helper ops kept local to avoid globals\n\ndef _flip_bit(s, idx):\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef _ensure_len_or_zeroes(s, n):\n    if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n        return '0' * n\n    return s\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    move_types = ['single_flip', 'double_flip', 'triple_flip', 'swap_1in1out', 'biased_flip']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'triple_flip':\n        k = 3 if n >= 3 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'triple_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            # Fallback to single\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        i_out = random.choice(ones)\n        i_in = random.choice(zeros)\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    # biased_flip\n    ratios = [(values[i] \/ float(costs[i]), i) for i in range(n)]\n    ratios.sort(reverse=True)\n    # Choose better ratio index to add, worse ratio index to drop\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    nb = s\n    performed = False\n    if zeros:\n        # bias toward top quartile of ratios among zeros\n        zero_ratios = [(values[i] \/ float(costs[i]), i) for i in zeros]\n        zero_ratios.sort(reverse=True)\n        k = max(1, len(zero_ratios)\/\/4)\n        idx_in = random.choice([i for _, i in zero_ratios[:k]])\n        nb = _flip_bit(nb, idx_in)\n        performed = True\n    if ones:\n        one_ratios = [(values[i] \/ float(costs[i]), i) for i in ones]\n        one_ratios.sort()  # drop worst\n        k = max(1, len(one_ratios)\/\/4)\n        idx_out = random.choice([i for _, i in one_ratios[:k]])\n        nb = _flip_bit(nb, idx_out)\n        performed = True\n    if not performed:\n        idx = random.randrange(n)\n        nb = _flip_bit(nb, idx)\n    return (nb, 'biased_flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    # Validate \/ normalize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        s = '0' * n\n    else:\n        s = solution\n\n    # Step 1: random multi-bit flips (3-6 or up to n)\n    if n > 0:\n        k = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), k)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helper to compute cost\/value quickly\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair feasibility if over budget by dropping worst value-to-cost items first\n    tc, tv = cv(s)\n    if tc > budget:\n        indices = [i for i, ch in enumerate(s) if ch == '1']\n        # sort by ascending value density and higher cost tie-break to shed costly low value\n        indices.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in indices:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy add best ratio items while remaining under budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i] \/ float(costs[i])), costs[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: _flip_bit() missing 1 required positional argument: 'idx'.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000967252}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24; index i (1-based) corresponds to Decoration i; '1' means selected, '0' means not selected.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better.\n    # Feasible: negative of total value.\n    # Infeasible: dynamic penalty preferring lower overage and higher value.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Dynamic penalty: base + scaled overage - tiny value term to softly rank among infeasible\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\n\n# Helper ops kept local to avoid globals\n\ndef _flip_bit(s, idx):\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef _ensure_len_or_zeroes(s, n):\n    if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n        return '0' * n\n    return s\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    move_types = ['single_flip', 'double_flip', 'triple_flip', 'swap_1in1out', 'biased_flip']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'triple_flip':\n        k = 3 if n >= 3 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'triple_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            # Fallback to single\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        i_out = random.choice(ones)\n        i_in = random.choice(zeros)\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    # biased_flip\n    ratios = [(values[i] \/ float(costs[i]), i) for i in range(n)]\n    ratios.sort(reverse=True)\n    # Choose better ratio index to add, worse ratio index to drop\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    nb = s\n    performed = False\n    if zeros:\n        # bias toward top quartile of ratios among zeros\n        zero_ratios = [(values[i] \/ float(costs[i]), i) for i in zeros]\n        zero_ratios.sort(reverse=True)\n        k = max(1, len(zero_ratios)\/\/4)\n        idx_in = random.choice([i for _, i in zero_ratios[:k]])\n        nb = _flip_bit(nb, idx_in)\n        performed = True\n    if ones:\n        one_ratios = [(values[i] \/ float(costs[i]), i) for i in ones]\n        one_ratios.sort()  # drop worst\n        k = max(1, len(one_ratios)\/\/4)\n        idx_out = random.choice([i for _, i in one_ratios[:k]])\n        nb = _flip_bit(nb, idx_out)\n        performed = True\n    if not performed:\n        idx = random.randrange(n)\n        nb = _flip_bit(nb, idx)\n    return (nb, 'biased_flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    # Validate \/ normalize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        s = '0' * n\n    else:\n        s = solution\n\n    # Step 1: random multi-bit flips (3-6 or up to n)\n    if n > 0:\n        k = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), k)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helper to compute cost\/value quickly\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair feasibility if over budget by dropping worst value-to-cost items first\n    tc, tv = cv(s)\n    if tc > budget:\n        indices = [i for i, ch in enumerate(s) if ch == '1']\n        # sort by ascending value density and higher cost tie-break to shed costly low value\n        indices.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in indices:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy add best ratio items while remaining under budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i] \/ float(costs[i])), costs[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: _flip_bit() missing 1 required positional argument: 'idx'.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000961472}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n\n    def _ensure_len_or_zeroes(s, n):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s, idx):\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    # Move set\n    move_types = ['single_flip', 'double_flip', 'swap_1in1out', 'biased_flip', 'two_for_one']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        # Prefer adding high density and removing low density\n        one_ratios = sorted([(values[i]\/float(costs[i]), i) for i in ones])\n        zero_ratios = sorted([(values[i]\/float(costs[i]), i) for i in zeros], reverse=True)\n        i_out = random.choice([i for _, i in one_ratios[:max(1,len(one_ratios)\/\/3)]])\n        i_in  = random.choice([i for _, i in zero_ratios[:max(1,len(zero_ratios)\/\/3)]])\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    if move == 'biased_flip':\n        # epsilon-greedy density bias\n        eps = 0.1\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones  = [i for i,ch in enumerate(s) if ch == '1']\n        nb = s\n        if zeros:\n            if random.random() < eps:\n                i_in = random.choice(zeros)\n            else:\n                zeros_sorted = sorted(zeros, key=lambda i: (values[i]\/float(costs[i]), values[i]), reverse=True)\n                i_in = zeros_sorted[0]\n            nb = _flip_bit(nb, i_in)\n        if ones:\n            if random.random() < eps:\n                i_out = random.choice(ones)\n            else:\n                ones_sorted = sorted(ones, key=lambda i: (values[i]\/float(costs[i]), values[i]))\n                i_out = ones_sorted[0]\n            nb = _flip_bit(nb, i_out)\n        return (nb, 'biased_flip')\n\n    # two_for_one exchange: try toggling 3 indices with 2 out and 1 in (or vice versa)\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        out_idxs = random.sample(ones, 2)\n        in_idx = random.choice(zeros)\n        nb_list = list(s)\n        for i in out_idxs:\n            nb_list[i] = '0'\n        nb_list[in_idx] = '1'\n        return (''.join(nb_list), 'two_for_one')\n    # fallback\n    idx = random.randrange(n)\n    nb = _flip_bit(s, idx)\n    return (nb, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _validate(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    s = _validate(solution)\n\n    # Step 1: random multi-bit flips (r in [3,6])\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helpers\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair if over budget by dropping worst density items first\n    tc, tv = cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i]\/float(costs[i]), -costs[i]))  # ascending density, then higher cost\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i]\/float(costs[i])), -values[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["001000100000011110100100",-115.0,"001000100000011110100100",-124.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001476318}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n\n    def _ensure_len_or_zeroes(s, n):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s, idx):\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    # Move set\n    move_types = ['single_flip', 'double_flip', 'swap_1in1out', 'biased_flip', 'two_for_one']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        # Prefer adding high density and removing low density\n        one_ratios = sorted([(values[i]\/float(costs[i]), i) for i in ones])\n        zero_ratios = sorted([(values[i]\/float(costs[i]), i) for i in zeros], reverse=True)\n        i_out = random.choice([i for _, i in one_ratios[:max(1,len(one_ratios)\/\/3)]])\n        i_in  = random.choice([i for _, i in zero_ratios[:max(1,len(zero_ratios)\/\/3)]])\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    if move == 'biased_flip':\n        # epsilon-greedy density bias\n        eps = 0.1\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones  = [i for i,ch in enumerate(s) if ch == '1']\n        nb = s\n        if zeros:\n            if random.random() < eps:\n                i_in = random.choice(zeros)\n            else:\n                zeros_sorted = sorted(zeros, key=lambda i: (values[i]\/float(costs[i]), values[i]), reverse=True)\n                i_in = zeros_sorted[0]\n            nb = _flip_bit(nb, i_in)\n        if ones:\n            if random.random() < eps:\n                i_out = random.choice(ones)\n            else:\n                ones_sorted = sorted(ones, key=lambda i: (values[i]\/float(costs[i]), values[i]))\n                i_out = ones_sorted[0]\n            nb = _flip_bit(nb, i_out)\n        return (nb, 'biased_flip')\n\n    # two_for_one exchange: try toggling 3 indices with 2 out and 1 in (or vice versa)\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        out_idxs = random.sample(ones, 2)\n        in_idx = random.choice(zeros)\n        nb_list = list(s)\n        for i in out_idxs:\n            nb_list[i] = '0'\n        nb_list[in_idx] = '1'\n        return (''.join(nb_list), 'two_for_one')\n    # fallback\n    idx = random.randrange(n)\n    nb = _flip_bit(s, idx)\n    return (nb, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _validate(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    s = _validate(solution)\n\n    # Step 1: random multi-bit flips (r in [3,6])\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helpers\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair if over budget by dropping worst density items first\n    tc, tv = cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i]\/float(costs[i]), -costs[i]))  # ascending density, then higher cost\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i]\/float(costs[i])), -values[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["111001110111011111110111",-13.0,"111101110111011111111101",-268.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0019737439}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n\n    def _ensure_len_or_zeroes(s, n):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s, idx):\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    # Move set\n    move_types = ['single_flip', 'double_flip', 'swap_1in1out', 'biased_flip', 'two_for_one']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        # Prefer adding high density and removing low density\n        one_ratios = sorted([(values[i]\/float(costs[i]), i) for i in ones])\n        zero_ratios = sorted([(values[i]\/float(costs[i]), i) for i in zeros], reverse=True)\n        i_out = random.choice([i for _, i in one_ratios[:max(1,len(one_ratios)\/\/3)]])\n        i_in  = random.choice([i for _, i in zero_ratios[:max(1,len(zero_ratios)\/\/3)]])\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    if move == 'biased_flip':\n        # epsilon-greedy density bias\n        eps = 0.1\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones  = [i for i,ch in enumerate(s) if ch == '1']\n        nb = s\n        if zeros:\n            if random.random() < eps:\n                i_in = random.choice(zeros)\n            else:\n                zeros_sorted = sorted(zeros, key=lambda i: (values[i]\/float(costs[i]), values[i]), reverse=True)\n                i_in = zeros_sorted[0]\n            nb = _flip_bit(nb, i_in)\n        if ones:\n            if random.random() < eps:\n                i_out = random.choice(ones)\n            else:\n                ones_sorted = sorted(ones, key=lambda i: (values[i]\/float(costs[i]), values[i]))\n                i_out = ones_sorted[0]\n            nb = _flip_bit(nb, i_out)\n        return (nb, 'biased_flip')\n\n    # two_for_one exchange: try toggling 3 indices with 2 out and 1 in (or vice versa)\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        out_idxs = random.sample(ones, 2)\n        in_idx = random.choice(zeros)\n        nb_list = list(s)\n        for i in out_idxs:\n            nb_list[i] = '0'\n        nb_list[in_idx] = '1'\n        return (''.join(nb_list), 'two_for_one')\n    # fallback\n    idx = random.randrange(n)\n    nb = _flip_bit(s, idx)\n    return (nb, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _validate(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    s = _validate(solution)\n\n    # Step 1: random multi-bit flips (r in [3,6])\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helpers\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair if over budget by dropping worst density items first\n    tc, tv = cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i]\/float(costs[i]), -costs[i]))  # ascending density, then higher cost\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i]\/float(costs[i])), -values[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001194965}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better; maximize value under budget\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Quadratic penalty for infeasibility\n    over = float(total_cost - budget)\n    rho = 100.0\n    return rho * (over * over) - 0.001 * float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid_or_zeroes(s: str) -> str:\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    def _cost_value(s: str):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(s):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    def _repair_feasible(s: str) -> str:\n        tc, tv = _cost_value(s)\n        if tc <= budget:\n            return s\n        # Drop lowest density items until feasible\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        return ''.join(s_list)\n\n    s = _valid_or_zeroes(solution)\n    tc, tv = _cost_value(s)\n\n    # Move set with feasibility awareness\n    moves = ['single_flip', 'swap_1in1out', 'double_flip', 'biased_add_or_swap', 'two_for_one']\n    move = random.choice(moves)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        cand = _flip_bit(s, idx)\n        cand = _repair_feasible(cand)\n        return (cand, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        cand = s\n        for i in idxs:\n            cand = _flip_bit(cand, i)\n        cand = _repair_feasible(cand)\n        return (cand, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            cand = _flip_bit(s, idx)\n            cand = _repair_feasible(cand)\n            return (cand, 'swap_fallback')\n        # Remove worst density, add best density\n        i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n        i_in = zeros_sorted[0]\n        cand_list = list(s)\n        cand_list[i_out] = '0'\n        cand_list[i_in] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'swap_1in1out')\n\n    if move == 'biased_add_or_swap':\n        # Prefer adding high-density item if budget allows; else drop worst then add best\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        cand = s\n        if zeros:\n            zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n            for i_in in zeros_sorted[:min(5, len(zeros_sorted))]:\n                if tc + costs[i_in] <= budget:\n                    cand = _flip_bit(cand, i_in)\n                    break\n            else:\n                if ones:\n                    i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n                    cand_list = list(cand)\n                    cand_list[i_out] = '0'\n                    cand_list[zeros_sorted[0]] = '1'\n                    cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'biased_add_or_swap')\n\n    # two_for_one: drop two worst, add one best\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        worst_two = sorted(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))[:2]\n        best_zero = max(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]))\n        cand_list = list(s)\n        for i in worst_two:\n            cand_list[i] = '0'\n        cand_list[best_zero] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'two_for_one')\n\n    # Fallback single flip\n    idx = random.randrange(n)\n    cand = _flip_bit(s, idx)\n    cand = _repair_feasible(cand)\n    return (cand, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    s = _valid(solution)\n\n    # Random multi-bit flips\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Repair if over budget: drop lowest density items first\n    tc, tv = _cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        s = ''.join(s_list)\n        tc, tv = _cv(s)\n\n    # Greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["100100000100001110000100",-93.0,"100100000100001110100100",-123.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0017350321}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better; maximize value under budget\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Quadratic penalty for infeasibility\n    over = float(total_cost - budget)\n    rho = 100.0\n    return rho * (over * over) - 0.001 * float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid_or_zeroes(s: str) -> str:\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    def _cost_value(s: str):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(s):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    def _repair_feasible(s: str) -> str:\n        tc, tv = _cost_value(s)\n        if tc <= budget:\n            return s\n        # Drop lowest density items until feasible\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        return ''.join(s_list)\n\n    s = _valid_or_zeroes(solution)\n    tc, tv = _cost_value(s)\n\n    # Move set with feasibility awareness\n    moves = ['single_flip', 'swap_1in1out', 'double_flip', 'biased_add_or_swap', 'two_for_one']\n    move = random.choice(moves)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        cand = _flip_bit(s, idx)\n        cand = _repair_feasible(cand)\n        return (cand, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        cand = s\n        for i in idxs:\n            cand = _flip_bit(cand, i)\n        cand = _repair_feasible(cand)\n        return (cand, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            cand = _flip_bit(s, idx)\n            cand = _repair_feasible(cand)\n            return (cand, 'swap_fallback')\n        # Remove worst density, add best density\n        i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n        i_in = zeros_sorted[0]\n        cand_list = list(s)\n        cand_list[i_out] = '0'\n        cand_list[i_in] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'swap_1in1out')\n\n    if move == 'biased_add_or_swap':\n        # Prefer adding high-density item if budget allows; else drop worst then add best\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        cand = s\n        if zeros:\n            zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n            for i_in in zeros_sorted[:min(5, len(zeros_sorted))]:\n                if tc + costs[i_in] <= budget:\n                    cand = _flip_bit(cand, i_in)\n                    break\n            else:\n                if ones:\n                    i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n                    cand_list = list(cand)\n                    cand_list[i_out] = '0'\n                    cand_list[zeros_sorted[0]] = '1'\n                    cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'biased_add_or_swap')\n\n    # two_for_one: drop two worst, add one best\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        worst_two = sorted(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))[:2]\n        best_zero = max(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]))\n        cand_list = list(s)\n        for i in worst_two:\n            cand_list[i] = '0'\n        cand_list[best_zero] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'two_for_one')\n\n    # Fallback single flip\n    idx = random.randrange(n)\n    cand = _flip_bit(s, idx)\n    cand = _repair_feasible(cand)\n    return (cand, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    s = _valid(solution)\n\n    # Random multi-bit flips\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Repair if over budget: drop lowest density items first\n    tc, tv = _cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        s = ''.join(s_list)\n        tc, tv = _cv(s)\n\n    # Greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["111101110111011111110101",-24.0,"111101110111011111110111",-268.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.002589792}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better; maximize value under budget\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Quadratic penalty for infeasibility\n    over = float(total_cost - budget)\n    rho = 100.0\n    return rho * (over * over) - 0.001 * float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid_or_zeroes(s: str) -> str:\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    def _cost_value(s: str):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(s):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    def _repair_feasible(s: str) -> str:\n        tc, tv = _cost_value(s)\n        if tc <= budget:\n            return s\n        # Drop lowest density items until feasible\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        return ''.join(s_list)\n\n    s = _valid_or_zeroes(solution)\n    tc, tv = _cost_value(s)\n\n    # Move set with feasibility awareness\n    moves = ['single_flip', 'swap_1in1out', 'double_flip', 'biased_add_or_swap', 'two_for_one']\n    move = random.choice(moves)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        cand = _flip_bit(s, idx)\n        cand = _repair_feasible(cand)\n        return (cand, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        cand = s\n        for i in idxs:\n            cand = _flip_bit(cand, i)\n        cand = _repair_feasible(cand)\n        return (cand, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            cand = _flip_bit(s, idx)\n            cand = _repair_feasible(cand)\n            return (cand, 'swap_fallback')\n        # Remove worst density, add best density\n        i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n        i_in = zeros_sorted[0]\n        cand_list = list(s)\n        cand_list[i_out] = '0'\n        cand_list[i_in] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'swap_1in1out')\n\n    if move == 'biased_add_or_swap':\n        # Prefer adding high-density item if budget allows; else drop worst then add best\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        cand = s\n        if zeros:\n            zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n            for i_in in zeros_sorted[:min(5, len(zeros_sorted))]:\n                if tc + costs[i_in] <= budget:\n                    cand = _flip_bit(cand, i_in)\n                    break\n            else:\n                if ones:\n                    i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n                    cand_list = list(cand)\n                    cand_list[i_out] = '0'\n                    cand_list[zeros_sorted[0]] = '1'\n                    cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'biased_add_or_swap')\n\n    # two_for_one: drop two worst, add one best\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        worst_two = sorted(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))[:2]\n        best_zero = max(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]))\n        cand_list = list(s)\n        for i in worst_two:\n            cand_list[i] = '0'\n        cand_list[best_zero] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'two_for_one')\n\n    # Fallback single flip\n    idx = random.randrange(n)\n    cand = _flip_bit(s, idx)\n    cand = _repair_feasible(cand)\n    return (cand, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    s = _valid(solution)\n\n    # Random multi-bit flips\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Repair if over budget: drop lowest density items first\n    tc, tv = _cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        s = ''.join(s_list)\n        tc, tv = _cv(s)\n\n    # Greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001515058}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; index i (0-based) maps to Customer i+1. '1' means accept offer, '0' means reject. Capacity constraint: total gallons <= 304.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Strong linear penalty on overflow to enforce feasibility\n        penalty = 1_000_000 * overflow + total_value  # keep tie-breaker by value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\n# Neighbour: flip one random bit (accept<->reject one offer)\n# Returns: (new_solution, NB_Type, Movement_Type)\n# NB_Type: 'BIT_FLIP'; Movement_Type: 'LOCAL_1BIT'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not solution:\n        return (solution, \"BIT_FLIP\", \"LOCAL_1BIT\")\n    n = len(solution)\n    i = random.randrange(n)\n    lst = list(solution)\n    lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"BIT_FLIP\", \"LOCAL_1BIT\")\n","Perturbacion":"import random\n\n# Perturbation: flip k distinct random bits to escape local minima (k in [2,5] bounded by length)\n\ndef perturb_solution(solution):\n    if not solution:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(2, 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)\n","Resultados":"Failed to run target heuristic: object of type 'int' has no len().  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000404306}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; index i (0-based) maps to Customer i+1. '1' means accept offer, '0' means reject. Capacity constraint: total gallons <= 304.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Strong linear penalty on overflow to enforce feasibility\n        penalty = 1_000_000 * overflow + total_value  # keep tie-breaker by value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\n# Neighbour: flip one random bit (accept<->reject one offer)\n# Returns: (new_solution, NB_Type, Movement_Type)\n# NB_Type: 'BIT_FLIP'; Movement_Type: 'LOCAL_1BIT'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not solution:\n        return (solution, \"BIT_FLIP\", \"LOCAL_1BIT\")\n    n = len(solution)\n    i = random.randrange(n)\n    lst = list(solution)\n    lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"BIT_FLIP\", \"LOCAL_1BIT\")\n","Perturbacion":"import random\n\n# Perturbation: flip k distinct random bits to escape local minima (k in [2,5] bounded by length)\n\ndef perturb_solution(solution):\n    if not solution:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(2, 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)\n","Resultados":"Failed to run target heuristic: object of type 'int' has no len().  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000412356}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; index i (0-based) maps to Customer i+1. '1' means accept offer, '0' means reject. Capacity constraint: total gallons <= 304.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Strong linear penalty on overflow to enforce feasibility\n        penalty = 1_000_000 * overflow + total_value  # keep tie-breaker by value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\n# Neighbour: flip one random bit (accept<->reject one offer)\n# Returns: (new_solution, NB_Type, Movement_Type)\n# NB_Type: 'BIT_FLIP'; Movement_Type: 'LOCAL_1BIT'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not solution:\n        return (solution, \"BIT_FLIP\", \"LOCAL_1BIT\")\n    n = len(solution)\n    i = random.randrange(n)\n    lst = list(solution)\n    lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"BIT_FLIP\", \"LOCAL_1BIT\")\n","Perturbacion":"import random\n\n# Perturbation: flip k distinct random bits to escape local minima (k in [2,5] bounded by length)\n\ndef perturb_solution(solution):\n    if not solution:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(2, 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)\n","Resultados":"Failed to run target heuristic: object of type 'int' has no len().  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0003876351}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; i-th bit (0-based) -> Customer i+1. '1'=accept offer, '0'=reject. Capacity constraint: sum(weights where bit=1) <= 304 gallons. NB returns (new_solution, NB_Type, Movement_Type).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Moderate linear penalty on overflow; still allows SA temperature to function\n        penalty = 100.0 * overflow + 0.001 * total_value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NOOP\", \"EMPTY\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    # Current weight\n    current_weight = sum(weights[i] for i, ch in enumerate(solution) if ch == '1')\n    s = list(solution)\n    idx = random.randrange(n)\n    if s[idx] == '0':\n        # Try feasibility-preserving add; else attempt swap; else drop a random 1\n        if current_weight + weights[idx] <= capacity:\n            s[idx] = '1'\n            return (''.join(s), \"BIT_FLIP\", \"FEASIBLE_ADD\")\n        ones = [i for i, ch in enumerate(solution) if ch == '1']\n        random.shuffle(ones)\n        for j in ones:\n            if current_weight - weights[j] + weights[idx] <= capacity:\n                s2 = list(solution)\n                s2[j] = '0'\n                s2[idx] = '1'\n                return (''.join(s2), \"SWAP_2BIT\", \"FEASIBLE_SWAP\")\n        if ones:\n            j = random.choice(ones)\n            s3 = list(solution)\n            s3[j] = '0'\n            return (''.join(s3), \"BIT_FLIP\", \"DROP\")\n        return (solution, \"NOOP\", \"NO_MOVE\")\n    else:\n        # Drop always feasible\n        s[idx] = '0'\n        return (''.join(s), \"BIT_FLIP\", \"DROP\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    s = list(solution)\n    # Ensure feasibility by trimming if needed (remove lowest value\/weight first)\n    current_weight = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if current_weight > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if current_weight <= capacity:\n                break\n            s[i] = '0'\n            current_weight -= weights[i]\n    # Random k deletions\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    if ones:\n        k = random.randint(2, min(5, len(ones)))\n        for i in random.sample(ones, k):\n            if s[i] == '1':\n                s[i] = '0'\n                current_weight -= weights[i]\n    # Greedy refill by value\/weight ratio\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if current_weight + weights[i] <= capacity:\n            s[i] = '1'\n            current_weight += weights[i]\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000519197}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; i-th bit (0-based) -> Customer i+1. '1'=accept offer, '0'=reject. Capacity constraint: sum(weights where bit=1) <= 304 gallons. NB returns (new_solution, NB_Type, Movement_Type).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Moderate linear penalty on overflow; still allows SA temperature to function\n        penalty = 100.0 * overflow + 0.001 * total_value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NOOP\", \"EMPTY\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    # Current weight\n    current_weight = sum(weights[i] for i, ch in enumerate(solution) if ch == '1')\n    s = list(solution)\n    idx = random.randrange(n)\n    if s[idx] == '0':\n        # Try feasibility-preserving add; else attempt swap; else drop a random 1\n        if current_weight + weights[idx] <= capacity:\n            s[idx] = '1'\n            return (''.join(s), \"BIT_FLIP\", \"FEASIBLE_ADD\")\n        ones = [i for i, ch in enumerate(solution) if ch == '1']\n        random.shuffle(ones)\n        for j in ones:\n            if current_weight - weights[j] + weights[idx] <= capacity:\n                s2 = list(solution)\n                s2[j] = '0'\n                s2[idx] = '1'\n                return (''.join(s2), \"SWAP_2BIT\", \"FEASIBLE_SWAP\")\n        if ones:\n            j = random.choice(ones)\n            s3 = list(solution)\n            s3[j] = '0'\n            return (''.join(s3), \"BIT_FLIP\", \"DROP\")\n        return (solution, \"NOOP\", \"NO_MOVE\")\n    else:\n        # Drop always feasible\n        s[idx] = '0'\n        return (''.join(s), \"BIT_FLIP\", \"DROP\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    s = list(solution)\n    # Ensure feasibility by trimming if needed (remove lowest value\/weight first)\n    current_weight = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if current_weight > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if current_weight <= capacity:\n                break\n            s[i] = '0'\n            current_weight -= weights[i]\n    # Random k deletions\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    if ones:\n        k = random.randint(2, min(5, len(ones)))\n        for i in random.sample(ones, k):\n            if s[i] == '1':\n                s[i] = '0'\n                current_weight -= weights[i]\n    # Greedy refill by value\/weight ratio\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if current_weight + weights[i] <= capacity:\n            s[i] = '1'\n            current_weight += weights[i]\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0007028701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; i-th bit (0-based) -> Customer i+1. '1'=accept offer, '0'=reject. Capacity constraint: sum(weights where bit=1) <= 304 gallons. NB returns (new_solution, NB_Type, Movement_Type).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Moderate linear penalty on overflow; still allows SA temperature to function\n        penalty = 100.0 * overflow + 0.001 * total_value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NOOP\", \"EMPTY\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    # Current weight\n    current_weight = sum(weights[i] for i, ch in enumerate(solution) if ch == '1')\n    s = list(solution)\n    idx = random.randrange(n)\n    if s[idx] == '0':\n        # Try feasibility-preserving add; else attempt swap; else drop a random 1\n        if current_weight + weights[idx] <= capacity:\n            s[idx] = '1'\n            return (''.join(s), \"BIT_FLIP\", \"FEASIBLE_ADD\")\n        ones = [i for i, ch in enumerate(solution) if ch == '1']\n        random.shuffle(ones)\n        for j in ones:\n            if current_weight - weights[j] + weights[idx] <= capacity:\n                s2 = list(solution)\n                s2[j] = '0'\n                s2[idx] = '1'\n                return (''.join(s2), \"SWAP_2BIT\", \"FEASIBLE_SWAP\")\n        if ones:\n            j = random.choice(ones)\n            s3 = list(solution)\n            s3[j] = '0'\n            return (''.join(s3), \"BIT_FLIP\", \"DROP\")\n        return (solution, \"NOOP\", \"NO_MOVE\")\n    else:\n        # Drop always feasible\n        s[idx] = '0'\n        return (''.join(s), \"BIT_FLIP\", \"DROP\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    s = list(solution)\n    # Ensure feasibility by trimming if needed (remove lowest value\/weight first)\n    current_weight = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if current_weight > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if current_weight <= capacity:\n                break\n            s[i] = '0'\n            current_weight -= weights[i]\n    # Random k deletions\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    if ones:\n        k = random.randint(2, min(5, len(ones)))\n        for i in random.sample(ones, k):\n            if s[i] == '1':\n                s[i] = '0'\n                current_weight -= weights[i]\n    # Greedy refill by value\/weight ratio\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if current_weight + weights[i] <= capacity:\n            s[i] = '1'\n            current_weight += weights[i]\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000666789}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong penalty for infeasibility to guide solvers\n        # Keep monotonic in overflow, independent of value scale\n        penalty = 1_000_000.0 + 10_000.0 * overflow\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, meta_dict)\n    # meta_dict schema: {'nb_type': str, 'move': str}\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution, {'nb_type': 'INVALID', 'move': 'NONE'}\n    n = len(solution)\n    if n != 24:\n        return solution, {'nb_type': 'INVALID', 'move': 'LEN_MISMATCH'}\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Current weight\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    # Randomly choose an operator\n    r = random.random()\n    if r < 0.5:\n        # Single bit flip with feasibility preference\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'DROP'}\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'FEASIBLE_ADD'}\n            # Try a 1-1 swap to keep feasibility\n            ones = [i for i, ch in enumerate(solution) if ch == '1']\n            random.shuffle(ones)\n            for j in ones:\n                if curr_w - weights[j] + weights[idx] <= capacity:\n                    s2 = list(solution)\n                    s2[j] = '0'\n                    s2[idx] = '1'\n                    return ''.join(s2), {'nb_type': 'SWAP_2BIT', 'move': 'FEASIBLE_SWAP'}\n            # Fallback: drop a random 1 if any\n            if ones:\n                j = random.choice(ones)\n                s3 = list(solution)\n                s3[j] = '0'\n                return ''.join(s3), {'nb_type': 'BIT_FLIP', 'move': 'DROP_FALLBACK'}\n            return solution, {'nb_type': 'NOOP', 'move': 'NO_MOVE'}\n    else:\n        # k-flip (k in {2,3}) with repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        # Repair overweight by removing worst density items first\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s2) if ch == '1'))\n            for _, i in items:\n                if curr_w2 <= capacity:\n                    break\n                if s2[i] == '1':\n                    s2[i] = '0'\n                    curr_w2 -= weights[i]\n        return ''.join(s2), {'nb_type': 'K_FLIP', 'move': 'REPAIR'}\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution string (same representation)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Randomly flip between 3 and 6 bits\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    # Feasibility repair: trim by lowest value\/weight until feasible\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if curr_w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                curr_w -= weights[i]\n\n    # Optional greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":[111101010111011111111111,null,111101010111011111111111,null],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000760791}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong penalty for infeasibility to guide solvers\n        # Keep monotonic in overflow, independent of value scale\n        penalty = 1_000_000.0 + 10_000.0 * overflow\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, meta_dict)\n    # meta_dict schema: {'nb_type': str, 'move': str}\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution, {'nb_type': 'INVALID', 'move': 'NONE'}\n    n = len(solution)\n    if n != 24:\n        return solution, {'nb_type': 'INVALID', 'move': 'LEN_MISMATCH'}\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Current weight\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    # Randomly choose an operator\n    r = random.random()\n    if r < 0.5:\n        # Single bit flip with feasibility preference\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'DROP'}\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'FEASIBLE_ADD'}\n            # Try a 1-1 swap to keep feasibility\n            ones = [i for i, ch in enumerate(solution) if ch == '1']\n            random.shuffle(ones)\n            for j in ones:\n                if curr_w - weights[j] + weights[idx] <= capacity:\n                    s2 = list(solution)\n                    s2[j] = '0'\n                    s2[idx] = '1'\n                    return ''.join(s2), {'nb_type': 'SWAP_2BIT', 'move': 'FEASIBLE_SWAP'}\n            # Fallback: drop a random 1 if any\n            if ones:\n                j = random.choice(ones)\n                s3 = list(solution)\n                s3[j] = '0'\n                return ''.join(s3), {'nb_type': 'BIT_FLIP', 'move': 'DROP_FALLBACK'}\n            return solution, {'nb_type': 'NOOP', 'move': 'NO_MOVE'}\n    else:\n        # k-flip (k in {2,3}) with repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        # Repair overweight by removing worst density items first\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s2) if ch == '1'))\n            for _, i in items:\n                if curr_w2 <= capacity:\n                    break\n                if s2[i] == '1':\n                    s2[i] = '0'\n                    curr_w2 -= weights[i]\n        return ''.join(s2), {'nb_type': 'K_FLIP', 'move': 'REPAIR'}\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution string (same representation)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Randomly flip between 3 and 6 bits\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    # Feasibility repair: trim by lowest value\/weight until feasible\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if curr_w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                curr_w -= weights[i]\n\n    # Optional greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":[111101010111011111111111,null,111101010111011111111111,null],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000935022}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong penalty for infeasibility to guide solvers\n        # Keep monotonic in overflow, independent of value scale\n        penalty = 1_000_000.0 + 10_000.0 * overflow\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, meta_dict)\n    # meta_dict schema: {'nb_type': str, 'move': str}\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution, {'nb_type': 'INVALID', 'move': 'NONE'}\n    n = len(solution)\n    if n != 24:\n        return solution, {'nb_type': 'INVALID', 'move': 'LEN_MISMATCH'}\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Current weight\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    # Randomly choose an operator\n    r = random.random()\n    if r < 0.5:\n        # Single bit flip with feasibility preference\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'DROP'}\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'FEASIBLE_ADD'}\n            # Try a 1-1 swap to keep feasibility\n            ones = [i for i, ch in enumerate(solution) if ch == '1']\n            random.shuffle(ones)\n            for j in ones:\n                if curr_w - weights[j] + weights[idx] <= capacity:\n                    s2 = list(solution)\n                    s2[j] = '0'\n                    s2[idx] = '1'\n                    return ''.join(s2), {'nb_type': 'SWAP_2BIT', 'move': 'FEASIBLE_SWAP'}\n            # Fallback: drop a random 1 if any\n            if ones:\n                j = random.choice(ones)\n                s3 = list(solution)\n                s3[j] = '0'\n                return ''.join(s3), {'nb_type': 'BIT_FLIP', 'move': 'DROP_FALLBACK'}\n            return solution, {'nb_type': 'NOOP', 'move': 'NO_MOVE'}\n    else:\n        # k-flip (k in {2,3}) with repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        # Repair overweight by removing worst density items first\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s2) if ch == '1'))\n            for _, i in items:\n                if curr_w2 <= capacity:\n                    break\n                if s2[i] == '1':\n                    s2[i] = '0'\n                    curr_w2 -= weights[i]\n        return ''.join(s2), {'nb_type': 'K_FLIP', 'move': 'REPAIR'}\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution string (same representation)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Randomly flip between 3 and 6 bits\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    # Feasibility repair: trim by lowest value\/weight until feasible\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if curr_w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                curr_w -= weights[i]\n\n    # Optional greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0008825429}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    # Returns a scalar cost to MINIMIZE (negated revenue for feasible, large finite penalty otherwise)\n    n = 24\n    # Fast validation with finite penalties (avoid inf propagation)\n    if not isinstance(solution, str):\n        return 1_000_000_000.0\n    if len(solution) != n:\n        return 1_000_000_000.0 + 100_000.0 * abs(len(solution) - n)\n    if any(c not in '01' for c in solution):\n        return 1_000_000_000.0 + 50_000.0\n\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong monotone penalty in overflow\n        penalty = 1_000_000.0 + 10_000.0 * float(overflow)\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns a neighbouring solution (same 24-bit string representation)\n    # Ensures feasibility via light repair when needed\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    r = random.random()\n    if r < 0.5:\n        # Single flip with feasibility bias and 1-1 swap repair\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s)\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s)\n            # Try swap out a selected item with lowest density that makes room\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda j: densities[j])\n                for j in ones_sorted:\n                    if curr_w - weights[j] + weights[idx] <= capacity:\n                        s2 = list(s)\n                        s2[j] = '0'\n                        s2[idx] = '1'\n                        return ''.join(s2)\n            return ''.join(s)\n    else:\n        # 2- or 3-flip followed by greedy repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            # Remove selected items with lowest density first\n            selected = [i for i, ch in enumerate(s2) if ch == '1']\n            for i in sorted(selected, key=lambda j: densities[j]):\n                if curr_w2 <= capacity:\n                    break\n                s2[i] = '0'\n                curr_w2 -= weights[i]\n        return ''.join(s2)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed 24-bit solution with feasibility repair and optional refill\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        selected = [i for i, ch in enumerate(s) if ch == '1']\n        for i in sorted(selected, key=lambda j: densities[j]):\n            if curr_w <= capacity:\n                break\n            s[i] = '0'\n            curr_w -= weights[i]\n\n    # Greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for i in sorted(zeros, key=lambda j: -densities[j]):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0007598411}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    # Returns a scalar cost to MINIMIZE (negated revenue for feasible, large finite penalty otherwise)\n    n = 24\n    # Fast validation with finite penalties (avoid inf propagation)\n    if not isinstance(solution, str):\n        return 1_000_000_000.0\n    if len(solution) != n:\n        return 1_000_000_000.0 + 100_000.0 * abs(len(solution) - n)\n    if any(c not in '01' for c in solution):\n        return 1_000_000_000.0 + 50_000.0\n\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong monotone penalty in overflow\n        penalty = 1_000_000.0 + 10_000.0 * float(overflow)\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns a neighbouring solution (same 24-bit string representation)\n    # Ensures feasibility via light repair when needed\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    r = random.random()\n    if r < 0.5:\n        # Single flip with feasibility bias and 1-1 swap repair\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s)\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s)\n            # Try swap out a selected item with lowest density that makes room\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda j: densities[j])\n                for j in ones_sorted:\n                    if curr_w - weights[j] + weights[idx] <= capacity:\n                        s2 = list(s)\n                        s2[j] = '0'\n                        s2[idx] = '1'\n                        return ''.join(s2)\n            return ''.join(s)\n    else:\n        # 2- or 3-flip followed by greedy repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            # Remove selected items with lowest density first\n            selected = [i for i, ch in enumerate(s2) if ch == '1']\n            for i in sorted(selected, key=lambda j: densities[j]):\n                if curr_w2 <= capacity:\n                    break\n                s2[i] = '0'\n                curr_w2 -= weights[i]\n        return ''.join(s2)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed 24-bit solution with feasibility repair and optional refill\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        selected = [i for i, ch in enumerate(s) if ch == '1']\n        for i in sorted(selected, key=lambda j: densities[j]):\n            if curr_w <= capacity:\n                break\n            s[i] = '0'\n            curr_w -= weights[i]\n\n    # Greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for i in sorted(zeros, key=lambda j: -densities[j]):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000905482}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    # Returns a scalar cost to MINIMIZE (negated revenue for feasible, large finite penalty otherwise)\n    n = 24\n    # Fast validation with finite penalties (avoid inf propagation)\n    if not isinstance(solution, str):\n        return 1_000_000_000.0\n    if len(solution) != n:\n        return 1_000_000_000.0 + 100_000.0 * abs(len(solution) - n)\n    if any(c not in '01' for c in solution):\n        return 1_000_000_000.0 + 50_000.0\n\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong monotone penalty in overflow\n        penalty = 1_000_000.0 + 10_000.0 * float(overflow)\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns a neighbouring solution (same 24-bit string representation)\n    # Ensures feasibility via light repair when needed\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    r = random.random()\n    if r < 0.5:\n        # Single flip with feasibility bias and 1-1 swap repair\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s)\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s)\n            # Try swap out a selected item with lowest density that makes room\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda j: densities[j])\n                for j in ones_sorted:\n                    if curr_w - weights[j] + weights[idx] <= capacity:\n                        s2 = list(s)\n                        s2[j] = '0'\n                        s2[idx] = '1'\n                        return ''.join(s2)\n            return ''.join(s)\n    else:\n        # 2- or 3-flip followed by greedy repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            # Remove selected items with lowest density first\n            selected = [i for i, ch in enumerate(s2) if ch == '1']\n            for i in sorted(selected, key=lambda j: densities[j]):\n                if curr_w2 <= capacity:\n                    break\n                s2[i] = '0'\n                curr_w2 -= weights[i]\n        return ''.join(s2)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed 24-bit solution with feasibility repair and optional refill\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        selected = [i for i, ch in enumerate(s) if ch == '1']\n        for i in sorted(selected, key=lambda j: densities[j]):\n            if curr_w <= capacity:\n                break\n            s[i] = '0'\n            curr_w -= weights[i]\n\n    # Greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for i in sorted(zeros, key=lambda j: -densities[j]):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000889962}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and content\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a string matching BIN_STR representation.\")\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError(\"Solution must be a 24-length binary string of '0'\/'1'.\")\n\n    # Embedded problem data (scores, times)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # SA expects lesser cost better; we convert maximization to minimization via negatives\n    if total_time <= capacity:\n        # Feasible: minimize negative value\n        cost = -float(total_value)\n    else:\n        # Infeasible: large penalty proportional to overflow; keep a small guidance with -value\n        overflow = total_time - capacity\n        cost = 1e6 + 100.0 * overflow - float(total_value)\n    return cost\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Expect BIN_STR; create 1-bit flip neighbour\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    idx = random.randrange(n)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    # Return neighbour and metadata\n    return neighbour, \"BIT_FLIP\", \"1-bit\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flip to escape local minima\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in indices:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000350205}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and content\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a string matching BIN_STR representation.\")\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError(\"Solution must be a 24-length binary string of '0'\/'1'.\")\n\n    # Embedded problem data (scores, times)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # SA expects lesser cost better; we convert maximization to minimization via negatives\n    if total_time <= capacity:\n        # Feasible: minimize negative value\n        cost = -float(total_value)\n    else:\n        # Infeasible: large penalty proportional to overflow; keep a small guidance with -value\n        overflow = total_time - capacity\n        cost = 1e6 + 100.0 * overflow - float(total_value)\n    return cost\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Expect BIN_STR; create 1-bit flip neighbour\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    idx = random.randrange(n)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    # Return neighbour and metadata\n    return neighbour, \"BIT_FLIP\", \"1-bit\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flip to escape local minima\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in indices:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0003569949}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and content\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a string matching BIN_STR representation.\")\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError(\"Solution must be a 24-length binary string of '0'\/'1'.\")\n\n    # Embedded problem data (scores, times)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # SA expects lesser cost better; we convert maximization to minimization via negatives\n    if total_time <= capacity:\n        # Feasible: minimize negative value\n        cost = -float(total_value)\n    else:\n        # Infeasible: large penalty proportional to overflow; keep a small guidance with -value\n        overflow = total_time - capacity\n        cost = 1e6 + 100.0 * overflow - float(total_value)\n    return cost\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Expect BIN_STR; create 1-bit flip neighbour\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    idx = random.randrange(n)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    # Return neighbour and metadata\n    return neighbour, \"BIT_FLIP\", \"1-bit\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flip to escape local minima\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in indices:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000326864}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate BIN_STR\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # Dynamic penalty based on average value\/weight\n    avg_density = (sum(values) \/ float(sum(weights)))\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow proportionally while keeping guidance from -value\n        lam = 50.0 * avg_density\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Choose a move type\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange (swap one selected=1 to 0 and one unselected=0 to 1)\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided flip: bias towards turning on high value\/weight or turning off low density\n        values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # choose a zero to flip to 1 with prob proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            # turn off the lowest density item\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0006940289}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate BIN_STR\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # Dynamic penalty based on average value\/weight\n    avg_density = (sum(values) \/ float(sum(weights)))\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow proportionally while keeping guidance from -value\n        lam = 50.0 * avg_density\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Choose a move type\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange (swap one selected=1 to 0 and one unselected=0 to 1)\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided flip: bias towards turning on high value\/weight or turning off low density\n        values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # choose a zero to flip to 1 with prob proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            # turn off the lowest density item\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0006063289}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate BIN_STR\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # Dynamic penalty based on average value\/weight\n    avg_density = (sum(values) \/ float(sum(weights)))\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow proportionally while keeping guidance from -value\n        lam = 50.0 * avg_density\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Choose a move type\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange (swap one selected=1 to 0 and one unselected=0 to 1)\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided flip: bias towards turning on high value\/weight or turning off low density\n        values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # choose a zero to flip to 1 with prob proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            # turn off the lowest density item\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0006066579}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from list\/tuple of 0\/1\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception as e:\n            raise ValueError('Solution must be a 24-length binary string or list\/tuple of 0\/1.')\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow strongly to guide towards feasibility\n        # Scale penalty by median density (~value per minute)\n        dens = sorted([v\/float(w) for v, w in zip(values, weights)])\n        median_density = dens[len(dens)\/\/2]\n        lam = 100.0 * median_density  # about 10x value per minute unit\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        # Drop lowest-density items until feasible\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        # sort ones by density ascending\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided move\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # probability proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    s_list = repair_feasible(s_list)\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000966543}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from list\/tuple of 0\/1\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception as e:\n            raise ValueError('Solution must be a 24-length binary string or list\/tuple of 0\/1.')\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow strongly to guide towards feasibility\n        # Scale penalty by median density (~value per minute)\n        dens = sorted([v\/float(w) for v, w in zip(values, weights)])\n        median_density = dens[len(dens)\/\/2]\n        lam = 100.0 * median_density  # about 10x value per minute unit\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        # Drop lowest-density items until feasible\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        # sort ones by density ascending\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided move\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # probability proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    s_list = repair_feasible(s_list)\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001205675}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from list\/tuple of 0\/1\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception as e:\n            raise ValueError('Solution must be a 24-length binary string or list\/tuple of 0\/1.')\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow strongly to guide towards feasibility\n        # Scale penalty by median density (~value per minute)\n        dens = sorted([v\/float(w) for v, w in zip(values, weights)])\n        median_density = dens[len(dens)\/\/2]\n        lam = 100.0 * median_density  # about 10x value per minute unit\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        # Drop lowest-density items until feasible\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        # sort ones by density ascending\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided move\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # probability proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    s_list = repair_feasible(s_list)\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001116765}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from iterable of 0\/1\n    if not isinstance(solution, str):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception:\n            raise ValueError('Solution must be a 24-length binary string or iterable of 0\/1.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Precompute density stats\n    densities = [v\/float(w) for v, w in zip(values, weights)]\n    dens_sorted = sorted(densities)\n    median_density = dens_sorted[len(dens_sorted)\/\/2]\n\n    # Lesser cost is better; feasible solutions prioritized by higher value, then lower time\n    eps = 1e-3\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Quadratic-like penalty on overflow to rank near-feasible solutions more smoothly\n        lam = 15.0 * median_density\n        cost = -float(total_value) + lam * float(overflow ** 1.5)\n    return float(cost)\n","Vecindad":"import random\nfrom typing import Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        # Ensure bits is a list of '0'\/'1'\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        # Drop items with lowest value-per-time (density) first\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        # Sort ones by increasing density; drop until feasible\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    def flip_and_repair(idx_list, tag_type, move_type):\n        for idx in idx_list:\n            s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        repaired = repair_feasible(s_list[:])\n        return repaired, tag_type, move_type\n\n    r = random.random()\n    # Neighborhood mix: 1-bit, 2-bit, 1-0 exchange, 2-1 and 1-2 exchanges, density-guided add\/remove\n    if r < 0.20:\n        # 1-bit flip\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.40:\n        # 2-bit flip (swap2)\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    elif r < 0.60:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            return flip_and_repair([i, j], 'EXCHANGE', '1-0')\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.80:\n        # 2-1 or 1-2 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if len(ones) >= 2 and len(zeros) >= 1 and random.random() < 0.5:\n            i, j = random.sample(ones, 2)\n            k = random.choice(zeros)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '2-1')\n        elif len(zeros) >= 2 and len(ones) >= 1:\n            i, j = random.sample(zeros, 2)\n            k = random.choice(ones)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '1-2')\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    else:\n        # Density-guided: try to add a high-density zero, drop to repair if needed\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            total = sum(max(density[i], 1e-9) for i in zeros)\n            t = random.random() * total\n            acc = 0.0\n            idx = zeros[0]\n            for i in zeros:\n                acc += max(density[i], 1e-9)\n                if acc >= t:\n                    idx = i\n                    break\n            return flip_and_repair([idx], 'GUIDED', 'density-on')\n        elif ones:\n            # Remove lowest density one\n            idx = min(ones, key=lambda i: (density[i], -weights[i]))\n            return flip_and_repair([idx], 'GUIDED', 'density-off')\n        else:\n            return ''.join(s_list), 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    # Ruin-and-recreate: flip k\u2248n\/6 bits off and k on with density bias\n    k = max(3, min(7, (n + 5)\/\/6))\n\n    ones = [i for i, ch in enumerate(s_list) if ch == '1']\n    zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n\n    off_count = min(k, len(ones))\n    on_count = min(k, len(zeros))\n\n    if off_count > 0:\n        # Prefer turning off lowest-density items\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        off_idxs = sorted(ones, key=lambda i: (density[i], -weights[i]))[:off_count]\n        for idx in off_idxs:\n            s_list[idx] = '0'\n\n    if on_count > 0:\n        # Prefer turning on highest-density zeros\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        on_idxs = sorted(zeros, key=lambda i: (-density[i], weights[i]))[:on_count]\n        for idx in on_idxs:\n            s_list[idx] = '1'\n\n    # Final repair to ensure feasibility\n    return repair_feasible(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a 24-length binary string or iterable of 0\/1.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001074594}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from iterable of 0\/1\n    if not isinstance(solution, str):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception:\n            raise ValueError('Solution must be a 24-length binary string or iterable of 0\/1.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Precompute density stats\n    densities = [v\/float(w) for v, w in zip(values, weights)]\n    dens_sorted = sorted(densities)\n    median_density = dens_sorted[len(dens_sorted)\/\/2]\n\n    # Lesser cost is better; feasible solutions prioritized by higher value, then lower time\n    eps = 1e-3\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Quadratic-like penalty on overflow to rank near-feasible solutions more smoothly\n        lam = 15.0 * median_density\n        cost = -float(total_value) + lam * float(overflow ** 1.5)\n    return float(cost)\n","Vecindad":"import random\nfrom typing import Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        # Ensure bits is a list of '0'\/'1'\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        # Drop items with lowest value-per-time (density) first\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        # Sort ones by increasing density; drop until feasible\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    def flip_and_repair(idx_list, tag_type, move_type):\n        for idx in idx_list:\n            s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        repaired = repair_feasible(s_list[:])\n        return repaired, tag_type, move_type\n\n    r = random.random()\n    # Neighborhood mix: 1-bit, 2-bit, 1-0 exchange, 2-1 and 1-2 exchanges, density-guided add\/remove\n    if r < 0.20:\n        # 1-bit flip\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.40:\n        # 2-bit flip (swap2)\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    elif r < 0.60:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            return flip_and_repair([i, j], 'EXCHANGE', '1-0')\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.80:\n        # 2-1 or 1-2 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if len(ones) >= 2 and len(zeros) >= 1 and random.random() < 0.5:\n            i, j = random.sample(ones, 2)\n            k = random.choice(zeros)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '2-1')\n        elif len(zeros) >= 2 and len(ones) >= 1:\n            i, j = random.sample(zeros, 2)\n            k = random.choice(ones)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '1-2')\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    else:\n        # Density-guided: try to add a high-density zero, drop to repair if needed\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            total = sum(max(density[i], 1e-9) for i in zeros)\n            t = random.random() * total\n            acc = 0.0\n            idx = zeros[0]\n            for i in zeros:\n                acc += max(density[i], 1e-9)\n                if acc >= t:\n                    idx = i\n                    break\n            return flip_and_repair([idx], 'GUIDED', 'density-on')\n        elif ones:\n            # Remove lowest density one\n            idx = min(ones, key=lambda i: (density[i], -weights[i]))\n            return flip_and_repair([idx], 'GUIDED', 'density-off')\n        else:\n            return ''.join(s_list), 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    # Ruin-and-recreate: flip k\u2248n\/6 bits off and k on with density bias\n    k = max(3, min(7, (n + 5)\/\/6))\n\n    ones = [i for i, ch in enumerate(s_list) if ch == '1']\n    zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n\n    off_count = min(k, len(ones))\n    on_count = min(k, len(zeros))\n\n    if off_count > 0:\n        # Prefer turning off lowest-density items\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        off_idxs = sorted(ones, key=lambda i: (density[i], -weights[i]))[:off_count]\n        for idx in off_idxs:\n            s_list[idx] = '0'\n\n    if on_count > 0:\n        # Prefer turning on highest-density zeros\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        on_idxs = sorted(zeros, key=lambda i: (-density[i], weights[i]))[:on_count]\n        for idx in on_idxs:\n            s_list[idx] = '1'\n\n    # Final repair to ensure feasibility\n    return repair_feasible(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a 24-length binary string or iterable of 0\/1.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001362078}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from iterable of 0\/1\n    if not isinstance(solution, str):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception:\n            raise ValueError('Solution must be a 24-length binary string or iterable of 0\/1.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Precompute density stats\n    densities = [v\/float(w) for v, w in zip(values, weights)]\n    dens_sorted = sorted(densities)\n    median_density = dens_sorted[len(dens_sorted)\/\/2]\n\n    # Lesser cost is better; feasible solutions prioritized by higher value, then lower time\n    eps = 1e-3\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Quadratic-like penalty on overflow to rank near-feasible solutions more smoothly\n        lam = 15.0 * median_density\n        cost = -float(total_value) + lam * float(overflow ** 1.5)\n    return float(cost)\n","Vecindad":"import random\nfrom typing import Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        # Ensure bits is a list of '0'\/'1'\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        # Drop items with lowest value-per-time (density) first\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        # Sort ones by increasing density; drop until feasible\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    def flip_and_repair(idx_list, tag_type, move_type):\n        for idx in idx_list:\n            s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        repaired = repair_feasible(s_list[:])\n        return repaired, tag_type, move_type\n\n    r = random.random()\n    # Neighborhood mix: 1-bit, 2-bit, 1-0 exchange, 2-1 and 1-2 exchanges, density-guided add\/remove\n    if r < 0.20:\n        # 1-bit flip\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.40:\n        # 2-bit flip (swap2)\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    elif r < 0.60:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            return flip_and_repair([i, j], 'EXCHANGE', '1-0')\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.80:\n        # 2-1 or 1-2 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if len(ones) >= 2 and len(zeros) >= 1 and random.random() < 0.5:\n            i, j = random.sample(ones, 2)\n            k = random.choice(zeros)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '2-1')\n        elif len(zeros) >= 2 and len(ones) >= 1:\n            i, j = random.sample(zeros, 2)\n            k = random.choice(ones)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '1-2')\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    else:\n        # Density-guided: try to add a high-density zero, drop to repair if needed\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            total = sum(max(density[i], 1e-9) for i in zeros)\n            t = random.random() * total\n            acc = 0.0\n            idx = zeros[0]\n            for i in zeros:\n                acc += max(density[i], 1e-9)\n                if acc >= t:\n                    idx = i\n                    break\n            return flip_and_repair([idx], 'GUIDED', 'density-on')\n        elif ones:\n            # Remove lowest density one\n            idx = min(ones, key=lambda i: (density[i], -weights[i]))\n            return flip_and_repair([idx], 'GUIDED', 'density-off')\n        else:\n            return ''.join(s_list), 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    # Ruin-and-recreate: flip k\u2248n\/6 bits off and k on with density bias\n    k = max(3, min(7, (n + 5)\/\/6))\n\n    ones = [i for i, ch in enumerate(s_list) if ch == '1']\n    zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n\n    off_count = min(k, len(ones))\n    on_count = min(k, len(zeros))\n\n    if off_count > 0:\n        # Prefer turning off lowest-density items\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        off_idxs = sorted(ones, key=lambda i: (density[i], -weights[i]))[:off_count]\n        for idx in off_idxs:\n            s_list[idx] = '0'\n\n    if on_count > 0:\n        # Prefer turning on highest-density zeros\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        on_idxs = sorted(zeros, key=lambda i: (-density[i], weights[i]))[:on_count]\n        for idx in on_idxs:\n            s_list[idx] = '1'\n\n    # Final repair to ensure feasibility\n    return repair_feasible(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a 24-length binary string or iterable of 0\/1.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001336857}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"BIN_STR_LEN_24.Each position i in {1..24} indicates inclusion(1)\/exclusion(0) of item i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (weights, values) and capacity\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize solution to 24-length binary string\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    if len(s) < 24:\n        s = s + '0'*(24-len(s))\n    elif len(s) > 24:\n        s = s[:24]\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    if total_w <= capacity:\n        # Minimize cost: use negative value for maximization\n        return -float(total_v)\n    else:\n        # Heavy penalty if infeasible (cost must be large and positive)\n        overweight = total_w - capacity\n        # Penalize proportional to overweight and forego any value benefit\n        return 1e6 + overweight*1e4 + (24 - total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure binary string normalization\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return (s, \"noop\")\n\n    s_list = list(s)\n    move = None\n\n    if random.random() < 0.7 or n == 1:\n        # Single bit flip\n        i = random.randrange(n)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = \"flip_1bit\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        s_list[j] = '1' if s_list[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Strong perturbation: flip about 20% of bits (at least 1)\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return s\n    k = max(1, int(0.2 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flip_idxs = idxs[:k]\n    s_list = list(s)\n    for i in flip_idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00002073}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"BIN_STR_LEN_24.Each position i in {1..24} indicates inclusion(1)\/exclusion(0) of item i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (weights, values) and capacity\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize solution to 24-length binary string\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    if len(s) < 24:\n        s = s + '0'*(24-len(s))\n    elif len(s) > 24:\n        s = s[:24]\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    if total_w <= capacity:\n        # Minimize cost: use negative value for maximization\n        return -float(total_v)\n    else:\n        # Heavy penalty if infeasible (cost must be large and positive)\n        overweight = total_w - capacity\n        # Penalize proportional to overweight and forego any value benefit\n        return 1e6 + overweight*1e4 + (24 - total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure binary string normalization\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return (s, \"noop\")\n\n    s_list = list(s)\n    move = None\n\n    if random.random() < 0.7 or n == 1:\n        # Single bit flip\n        i = random.randrange(n)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = \"flip_1bit\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        s_list[j] = '1' if s_list[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Strong perturbation: flip about 20% of bits (at least 1)\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return s\n    k = max(1, int(0.2 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flip_idxs = idxs[:k]\n    s_list = list(s)\n    for i in flip_idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000582}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"BIN_STR_LEN_24.Each position i in {1..24} indicates inclusion(1)\/exclusion(0) of item i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (weights, values) and capacity\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize solution to 24-length binary string\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    if len(s) < 24:\n        s = s + '0'*(24-len(s))\n    elif len(s) > 24:\n        s = s[:24]\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    if total_w <= capacity:\n        # Minimize cost: use negative value for maximization\n        return -float(total_v)\n    else:\n        # Heavy penalty if infeasible (cost must be large and positive)\n        overweight = total_w - capacity\n        # Penalize proportional to overweight and forego any value benefit\n        return 1e6 + overweight*1e4 + (24 - total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure binary string normalization\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return (s, \"noop\")\n\n    s_list = list(s)\n    move = None\n\n    if random.random() < 0.7 or n == 1:\n        # Single bit flip\n        i = random.randrange(n)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = \"flip_1bit\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        s_list[j] = '1' if s_list[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Strong perturbation: flip about 20% of bits (at least 1)\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return s\n    k = max(1, int(0.2 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flip_idxs = idxs[:k]\n    s_list = list(s)\n    for i in flip_idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000369}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string (positions 1..24). '1' means the item is included; '0' means excluded.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize to 24-length binary string; penalize invalid chars\n    if not isinstance(solution, str):\n        return 1e5  # hard penalty for invalid type\n    s = solution\n    # truncate\/pad\n    if len(s) < 24:\n        s = s + '0' * (24 - len(s))\n    elif len(s) > 24:\n        s = s[:24]\n    invalid = sum(ch not in ('0', '1') for ch in s)\n    if invalid > 0:\n        return 1e4 + 10.0 * invalid  # deterministic penalty keeping scale reasonable\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Adaptive, comparable penalty for infeasibility\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        overweight = total_w - capacity\n        lambda_pen = 100.0  # keeps penalties on the order of values\n        return -float(total_v) + lambda_pen * overweight\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data and helpers embedded to allow local repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        # Drop worst by value\/weight ratio, then by lower value\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n    bits = list(s)\n\n    r = random.random()\n    move = \"flip_1bit\"\n    if r < 0.5:\n        # Single bit flip\n        i = random.randrange(n)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        move = \"flip_1bit\"\n    elif r < 0.8:\n        # 1-0 exchange: turn off a low-ratio selected item and turn on a high-ratio unselected item\n        selected = [i for i, b in enumerate(bits) if b == '1']\n        unselected = [i for i, b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            on_i = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            bits[off_i] = '0'\n            bits[on_i] = '1'\n            move = \"exchange_1_1\"\n        else:\n            i = random.randrange(n)\n            bits[i] = '1' if bits[i] == '0' else '0'\n            move = \"flip_1bit_fallback\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        bits[j] = '1' if bits[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return (cand, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n\n    # Structured multi-bit perturbation: flip ~25% of bits\n    k = max(1, n \/\/ 4)\n    idx = list(range(n))\n    random.shuffle(idx)\n    bits = list(s)\n    for i in idx[:k]:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return cand\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000148001}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string (positions 1..24). '1' means the item is included; '0' means excluded.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize to 24-length binary string; penalize invalid chars\n    if not isinstance(solution, str):\n        return 1e5  # hard penalty for invalid type\n    s = solution\n    # truncate\/pad\n    if len(s) < 24:\n        s = s + '0' * (24 - len(s))\n    elif len(s) > 24:\n        s = s[:24]\n    invalid = sum(ch not in ('0', '1') for ch in s)\n    if invalid > 0:\n        return 1e4 + 10.0 * invalid  # deterministic penalty keeping scale reasonable\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Adaptive, comparable penalty for infeasibility\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        overweight = total_w - capacity\n        lambda_pen = 100.0  # keeps penalties on the order of values\n        return -float(total_v) + lambda_pen * overweight\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data and helpers embedded to allow local repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        # Drop worst by value\/weight ratio, then by lower value\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n    bits = list(s)\n\n    r = random.random()\n    move = \"flip_1bit\"\n    if r < 0.5:\n        # Single bit flip\n        i = random.randrange(n)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        move = \"flip_1bit\"\n    elif r < 0.8:\n        # 1-0 exchange: turn off a low-ratio selected item and turn on a high-ratio unselected item\n        selected = [i for i, b in enumerate(bits) if b == '1']\n        unselected = [i for i, b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            on_i = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            bits[off_i] = '0'\n            bits[on_i] = '1'\n            move = \"exchange_1_1\"\n        else:\n            i = random.randrange(n)\n            bits[i] = '1' if bits[i] == '0' else '0'\n            move = \"flip_1bit_fallback\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        bits[j] = '1' if bits[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return (cand, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n\n    # Structured multi-bit perturbation: flip ~25% of bits\n    k = max(1, n \/\/ 4)\n    idx = list(range(n))\n    random.shuffle(idx)\n    bits = list(s)\n    for i in idx[:k]:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return cand\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000421}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string (positions 1..24). '1' means the item is included; '0' means excluded.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize to 24-length binary string; penalize invalid chars\n    if not isinstance(solution, str):\n        return 1e5  # hard penalty for invalid type\n    s = solution\n    # truncate\/pad\n    if len(s) < 24:\n        s = s + '0' * (24 - len(s))\n    elif len(s) > 24:\n        s = s[:24]\n    invalid = sum(ch not in ('0', '1') for ch in s)\n    if invalid > 0:\n        return 1e4 + 10.0 * invalid  # deterministic penalty keeping scale reasonable\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Adaptive, comparable penalty for infeasibility\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        overweight = total_w - capacity\n        lambda_pen = 100.0  # keeps penalties on the order of values\n        return -float(total_v) + lambda_pen * overweight\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data and helpers embedded to allow local repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        # Drop worst by value\/weight ratio, then by lower value\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n    bits = list(s)\n\n    r = random.random()\n    move = \"flip_1bit\"\n    if r < 0.5:\n        # Single bit flip\n        i = random.randrange(n)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        move = \"flip_1bit\"\n    elif r < 0.8:\n        # 1-0 exchange: turn off a low-ratio selected item and turn on a high-ratio unselected item\n        selected = [i for i, b in enumerate(bits) if b == '1']\n        unselected = [i for i, b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            on_i = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            bits[off_i] = '0'\n            bits[on_i] = '1'\n            move = \"exchange_1_1\"\n        else:\n            i = random.randrange(n)\n            bits[i] = '1' if bits[i] == '0' else '0'\n            move = \"flip_1bit_fallback\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        bits[j] = '1' if bits[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return (cand, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n\n    # Structured multi-bit perturbation: flip ~25% of bits\n    k = max(1, n \/\/ 4)\n    idx = list(range(n))\n    random.shuffle(idx)\n    bits = list(s)\n    for i in idx[:k]:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return cand\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.000002981}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Strict validation: exact length and charset\n    if not isinstance(solution, str):\n        return 1e9\n    if len(solution) != 24:\n        return 1e9\n    if any(ch not in ('0','1') for ch in solution):\n        return 1e9\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Feasible: return negative value (lower is better). Infeasible: hard penalty.\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        # Hard penalty to dominate any feasible score\n        return 1e8 + float(total_w - capacity)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Normalize and validate; if invalid, start from empty feasible solution\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    bits = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def add_if_fits(bits_list, idx):\n        if bits_list[idx] == '1':\n            return False\n        w = total_weight(bits_list)\n        if w + weights[idx] <= cap:\n            bits_list[idx] = '1'\n            return True\n        return False\n\n    def drop_until_fits(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return False\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        # Drop worst by (value\/weight, value, weight desc)\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        changed = False\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    n = 24\n    move = \"flip\"\n    r = random.random()\n\n    # Compute current weight once\n    cur_w = total_weight(bits)\n\n    if r < 0.4:\n        # Add-best-by-ratio if fits\n        cand = max(range(n), key=lambda i: (values[i] \/ max(1, weights[i]), values[i]) if bits[i] == '0' else (-1e9, -1e9))\n        if add_if_fits(bits, cand):\n            move = \"add_best_ratio\"\n        else:\n            # Try dropping worst then add\n            drop_until_fits(bits)\n            if add_if_fits(bits, cand):\n                move = \"drop_then_add\"\n            else:\n                # No change possible, fallback to do-nothing feasible return\n                return (''.join(bits), \"noop\")\n    elif r < 0.8:\n        # Exchange 1-1: drop worst add best by ratio with feasibility check\n        selected = [i for i,b in enumerate(bits) if b == '1']\n        unselected = [i for i,b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n            on_i  = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            # Perform if it fits\n            new_w = cur_w - weights[off_i] + weights[on_i]\n            if new_w <= cap:\n                bits[off_i] = '0'\n                bits[on_i]  = '1'\n                move = \"exchange_1_1\"\n            else:\n                # Try drop more until fits after swap attempt\n                bits[off_i] = '0'\n                if total_weight(bits) + weights[on_i] <= cap:\n                    bits[on_i] = '1'\n                    move = \"drop_more_then_add\"\n                else:\n                    move = \"drop_only\"\n        else:\n            return (''.join(bits), \"noop\")\n    else:\n        # Toggle ultra-light items first (w<=3) guided by ratio\n        ul_idx = [i for i,w in enumerate(weights) if w <= 3]\n        if ul_idx:\n            # Prefer adding best ultra-light if fits; otherwise remove worst ultra-light\n            addables = [i for i in ul_idx if bits[i] == '0' and cur_w + weights[i] <= cap]\n            if addables:\n                on_i = max(addables, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n                bits[on_i] = '1'\n                move = \"add_ultralight\"\n            else:\n                selected_ul = [i for i in ul_idx if bits[i] == '1']\n                if selected_ul:\n                    off_i = min(selected_ul, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n                    bits[off_i] = '0'\n                    move = \"remove_ultralight\"\n                else:\n                    return (''.join(bits), \"noop\")\n        else:\n            return (''.join(bits), \"noop\")\n\n    # Ensure feasibility\n    drop_until_fits(bits)\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Validate base\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        base = ['0'] * 24\n    else:\n        base = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def repair(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return bits_list\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n        return bits_list\n\n    n = 24\n    k = max(2, min(4, n \/\/ 6))  # flip\/exchange 2..4 bits\n\n    # Build candidate by performing k exchanges biased by ratio\n    bits = base[:]\n\n    # Try to add top-k unselected by ratio\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    ranked_add = sorted(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]), reverse=True)\n    adds = ranked_add[:k]\n    for i in adds:\n        bits[i] = '1'\n\n    # Drop until fit preferring worst items\n    bits = repair(bits)\n\n    # Randomize a couple of further toggles within feasibility\n    attempts = 6\n    for _ in range(attempts):\n        i = random.randrange(n)\n        if bits[i] == '1':\n            # Try swapping out i for a better ratio j\n            candidates = [j for j in range(n) if bits[j] == '0']\n            if not candidates:\n                continue\n            j = max(candidates, key=lambda idx: (values[idx] \/ max(1, weights[idx]), values[idx]))\n            new_w = total_weight(bits) - weights[i] + weights[j]\n            if new_w <= cap:\n                bits[i] = '0'\n                bits[j] = '1'\n        else:\n            # Try adding if fits\n            if total_weight(bits) + weights[i] <= cap:\n                bits[i] = '1'\n    bits = repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000015161}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Strict validation: exact length and charset\n    if not isinstance(solution, str):\n        return 1e9\n    if len(solution) != 24:\n        return 1e9\n    if any(ch not in ('0','1') for ch in solution):\n        return 1e9\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Feasible: return negative value (lower is better). Infeasible: hard penalty.\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        # Hard penalty to dominate any feasible score\n        return 1e8 + float(total_w - capacity)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Normalize and validate; if invalid, start from empty feasible solution\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    bits = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def add_if_fits(bits_list, idx):\n        if bits_list[idx] == '1':\n            return False\n        w = total_weight(bits_list)\n        if w + weights[idx] <= cap:\n            bits_list[idx] = '1'\n            return True\n        return False\n\n    def drop_until_fits(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return False\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        # Drop worst by (value\/weight, value, weight desc)\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        changed = False\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    n = 24\n    move = \"flip\"\n    r = random.random()\n\n    # Compute current weight once\n    cur_w = total_weight(bits)\n\n    if r < 0.4:\n        # Add-best-by-ratio if fits\n        cand = max(range(n), key=lambda i: (values[i] \/ max(1, weights[i]), values[i]) if bits[i] == '0' else (-1e9, -1e9))\n        if add_if_fits(bits, cand):\n            move = \"add_best_ratio\"\n        else:\n            # Try dropping worst then add\n            drop_until_fits(bits)\n            if add_if_fits(bits, cand):\n                move = \"drop_then_add\"\n            else:\n                # No change possible, fallback to do-nothing feasible return\n                return (''.join(bits), \"noop\")\n    elif r < 0.8:\n        # Exchange 1-1: drop worst add best by ratio with feasibility check\n        selected = [i for i,b in enumerate(bits) if b == '1']\n        unselected = [i for i,b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n            on_i  = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            # Perform if it fits\n            new_w = cur_w - weights[off_i] + weights[on_i]\n            if new_w <= cap:\n                bits[off_i] = '0'\n                bits[on_i]  = '1'\n                move = \"exchange_1_1\"\n            else:\n                # Try drop more until fits after swap attempt\n                bits[off_i] = '0'\n                if total_weight(bits) + weights[on_i] <= cap:\n                    bits[on_i] = '1'\n                    move = \"drop_more_then_add\"\n                else:\n                    move = \"drop_only\"\n        else:\n            return (''.join(bits), \"noop\")\n    else:\n        # Toggle ultra-light items first (w<=3) guided by ratio\n        ul_idx = [i for i,w in enumerate(weights) if w <= 3]\n        if ul_idx:\n            # Prefer adding best ultra-light if fits; otherwise remove worst ultra-light\n            addables = [i for i in ul_idx if bits[i] == '0' and cur_w + weights[i] <= cap]\n            if addables:\n                on_i = max(addables, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n                bits[on_i] = '1'\n                move = \"add_ultralight\"\n            else:\n                selected_ul = [i for i in ul_idx if bits[i] == '1']\n                if selected_ul:\n                    off_i = min(selected_ul, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n                    bits[off_i] = '0'\n                    move = \"remove_ultralight\"\n                else:\n                    return (''.join(bits), \"noop\")\n        else:\n            return (''.join(bits), \"noop\")\n\n    # Ensure feasibility\n    drop_until_fits(bits)\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Validate base\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        base = ['0'] * 24\n    else:\n        base = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def repair(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return bits_list\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n        return bits_list\n\n    n = 24\n    k = max(2, min(4, n \/\/ 6))  # flip\/exchange 2..4 bits\n\n    # Build candidate by performing k exchanges biased by ratio\n    bits = base[:]\n\n    # Try to add top-k unselected by ratio\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    ranked_add = sorted(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]), reverse=True)\n    adds = ranked_add[:k]\n    for i in adds:\n        bits[i] = '1'\n\n    # Drop until fit preferring worst items\n    bits = repair(bits)\n\n    # Randomize a couple of further toggles within feasibility\n    attempts = 6\n    for _ in range(attempts):\n        i = random.randrange(n)\n        if bits[i] == '1':\n            # Try swapping out i for a better ratio j\n            candidates = [j for j in range(n) if bits[j] == '0']\n            if not candidates:\n                continue\n            j = max(candidates, key=lambda idx: (values[idx] \/ max(1, weights[idx]), values[idx]))\n            new_w = total_weight(bits) - weights[i] + weights[j]\n            if new_w <= cap:\n                bits[i] = '0'\n                bits[j] = '1'\n        else:\n            # Try adding if fits\n            if total_weight(bits) + weights[i] <= cap:\n                bits[i] = '1'\n    bits = repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000441}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Strict validation: exact length and charset\n    if not isinstance(solution, str):\n        return 1e9\n    if len(solution) != 24:\n        return 1e9\n    if any(ch not in ('0','1') for ch in solution):\n        return 1e9\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Feasible: return negative value (lower is better). Infeasible: hard penalty.\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        # Hard penalty to dominate any feasible score\n        return 1e8 + float(total_w - capacity)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Normalize and validate; if invalid, start from empty feasible solution\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    bits = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def add_if_fits(bits_list, idx):\n        if bits_list[idx] == '1':\n            return False\n        w = total_weight(bits_list)\n        if w + weights[idx] <= cap:\n            bits_list[idx] = '1'\n            return True\n        return False\n\n    def drop_until_fits(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return False\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        # Drop worst by (value\/weight, value, weight desc)\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        changed = False\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    n = 24\n    move = \"flip\"\n    r = random.random()\n\n    # Compute current weight once\n    cur_w = total_weight(bits)\n\n    if r < 0.4:\n        # Add-best-by-ratio if fits\n        cand = max(range(n), key=lambda i: (values[i] \/ max(1, weights[i]), values[i]) if bits[i] == '0' else (-1e9, -1e9))\n        if add_if_fits(bits, cand):\n            move = \"add_best_ratio\"\n        else:\n            # Try dropping worst then add\n            drop_until_fits(bits)\n            if add_if_fits(bits, cand):\n                move = \"drop_then_add\"\n            else:\n                # No change possible, fallback to do-nothing feasible return\n                return (''.join(bits), \"noop\")\n    elif r < 0.8:\n        # Exchange 1-1: drop worst add best by ratio with feasibility check\n        selected = [i for i,b in enumerate(bits) if b == '1']\n        unselected = [i for i,b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n            on_i  = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            # Perform if it fits\n            new_w = cur_w - weights[off_i] + weights[on_i]\n            if new_w <= cap:\n                bits[off_i] = '0'\n                bits[on_i]  = '1'\n                move = \"exchange_1_1\"\n            else:\n                # Try drop more until fits after swap attempt\n                bits[off_i] = '0'\n                if total_weight(bits) + weights[on_i] <= cap:\n                    bits[on_i] = '1'\n                    move = \"drop_more_then_add\"\n                else:\n                    move = \"drop_only\"\n        else:\n            return (''.join(bits), \"noop\")\n    else:\n        # Toggle ultra-light items first (w<=3) guided by ratio\n        ul_idx = [i for i,w in enumerate(weights) if w <= 3]\n        if ul_idx:\n            # Prefer adding best ultra-light if fits; otherwise remove worst ultra-light\n            addables = [i for i in ul_idx if bits[i] == '0' and cur_w + weights[i] <= cap]\n            if addables:\n                on_i = max(addables, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n                bits[on_i] = '1'\n                move = \"add_ultralight\"\n            else:\n                selected_ul = [i for i in ul_idx if bits[i] == '1']\n                if selected_ul:\n                    off_i = min(selected_ul, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n                    bits[off_i] = '0'\n                    move = \"remove_ultralight\"\n                else:\n                    return (''.join(bits), \"noop\")\n        else:\n            return (''.join(bits), \"noop\")\n\n    # Ensure feasibility\n    drop_until_fits(bits)\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Validate base\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        base = ['0'] * 24\n    else:\n        base = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def repair(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return bits_list\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n        return bits_list\n\n    n = 24\n    k = max(2, min(4, n \/\/ 6))  # flip\/exchange 2..4 bits\n\n    # Build candidate by performing k exchanges biased by ratio\n    bits = base[:]\n\n    # Try to add top-k unselected by ratio\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    ranked_add = sorted(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]), reverse=True)\n    adds = ranked_add[:k]\n    for i in adds:\n        bits[i] = '1'\n\n    # Drop until fit preferring worst items\n    bits = repair(bits)\n\n    # Randomize a couple of further toggles within feasibility\n    attempts = 6\n    for _ in range(attempts):\n        i = random.randrange(n)\n        if bits[i] == '1':\n            # Try swapping out i for a better ratio j\n            candidates = [j for j in range(n) if bits[j] == '0']\n            if not candidates:\n                continue\n            j = max(candidates, key=lambda idx: (values[idx] \/ max(1, weights[idx]), values[idx]))\n            new_w = total_weight(bits) - weights[i] + weights[j]\n            if new_w <= cap:\n                bits[i] = '0'\n                bits[j] = '1'\n        else:\n            # Try adding if fits\n            if total_weight(bits) + weights[i] <= cap:\n                bits[i] = '1'\n    bits = repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000292}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000' encodes items [4,8,18]. Length must be exactly 24.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Strict validation\n    if not isinstance(solution, str):\n        return 1_000_000.0\n    if len(solution) != n:\n        return 1_000_000.0\n    if any(ch not in ('0','1') for ch in solution):\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n            if total_w > capacity:\n                # Early exit overweight\n                excess = total_w - capacity\n                return 1_000_000.0 + float(excess) * 100.0\n    # Feasible: return negative value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Validate or initialize to feasible empty solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    # Precompute helpers\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def cur_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def cur_value(bl):\n        return sum(values[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        # If overweight, drop items with minimal value loss per weight until feasible\n        w = cur_weight(bl)\n        if w <= capacity:\n            return False\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        # Score: value loss per weight recovered, tie by higher weight then lower value\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        changed = False\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    # Ensure starting feasibility (do not return yet; we will perform a modifying move)\n    repair(bits)\n    w0 = cur_weight(bits)\n\n    # Candidate move strategies; guarantee at least one change\n    move = \"noop\"\n\n    # Strategy A: add best-ratio item that fits\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if unselected:\n        best_add = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        if w0 + weights[best_add] <= capacity:\n            bits[best_add] = '1'\n            move = \"add_best_ratio\"\n            return (''.join(bits), move)\n\n    # Strategy B: 1-1 exchange: drop worst by ratio, add best by ratio if fits\n    idx_on = [i for i,b in enumerate(bits) if b == '1']\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if idx_on and unselected:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        new_w = w0 - weights[worst_on] + weights[best_off]\n        if new_w <= capacity and (values[best_off] > values[worst_on]):\n            bits[worst_on] = '0'\n            bits[best_off] = '1'\n            move = \"swap_1_1\"\n            return (''.join(bits), move)\n\n    # Strategy C: 2-for-1 or 1-for-2 bounded exchanges\n    if unselected and len(idx_on) >= 2:\n        # Try dropping up to 2 worst to add best\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        # pick two worst currently on\n        worst_pair = sorted(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))[:2]\n        drop_w = sum(weights[i] for i in worst_pair)\n        if w0 - drop_w + weights[best_off] <= capacity and values[best_off] > sum(values[i] for i in worst_pair):\n            for i in worst_pair:\n                bits[i] = '0'\n            bits[best_off] = '1'\n            move = \"swap_2_1\"\n            return (''.join(bits), move)\n\n    if len(unselected) >= 2 and idx_on:\n        # Try drop worst_on and add two best offs\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_two = sorted(unselected, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True)[:2]\n        add_w = sum(weights[i] for i in best_two)\n        if w0 - weights[worst_on] + add_w <= capacity and sum(values[i] for i in best_two) > values[worst_on]:\n            bits[worst_on] = '0'\n            for i in best_two:\n                bits[i] = '1'\n            move = \"swap_1_2\"\n            return (''.join(bits), move)\n\n    # Strategy D: if no constructive move, remove the worst item to diversify (if any on)\n    if idx_on:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        bits[worst_on] = '0'\n        move = \"drop_worst\"\n        return (''.join(bits), move)\n\n    # Fallback: flip best feasible bit (should not occur often)\n    unselected = [i for i in range(n) if bits[i] == '0']\n    if unselected:\n        # Choose the lightest highest-value that fits alone\n        cand = sorted(unselected, key=lambda i: (-values[i], weights[i], -ratio[i]))\n        for i in cand:\n            if weights[i] <= capacity:\n                bits[i] = '1'\n                move = \"fallback_add\"\n                break\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Base normalization\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def total_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        w = total_weight(bl)\n        if w <= capacity:\n            return\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n\n    # Strength-controlled random flips then repair\n    k = 3\n    idx = list(range(n))\n    random.shuffle(idx)\n    flips = idx[:k]\n    for i in flips:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Try to greedily add a couple of high-ratio items if room remains\n    repair(bits)\n    w = total_weight(bits)\n    candidates = [i for i in range(n) if bits[i] == '0']\n    for i in sorted(candidates, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True):\n        if w + weights[i] <= capacity:\n            bits[i] = '1'\n            w += weights[i]\n        if w == capacity:\n            break\n\n    repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001125123}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000' encodes items [4,8,18]. Length must be exactly 24.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Strict validation\n    if not isinstance(solution, str):\n        return 1_000_000.0\n    if len(solution) != n:\n        return 1_000_000.0\n    if any(ch not in ('0','1') for ch in solution):\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n            if total_w > capacity:\n                # Early exit overweight\n                excess = total_w - capacity\n                return 1_000_000.0 + float(excess) * 100.0\n    # Feasible: return negative value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Validate or initialize to feasible empty solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    # Precompute helpers\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def cur_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def cur_value(bl):\n        return sum(values[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        # If overweight, drop items with minimal value loss per weight until feasible\n        w = cur_weight(bl)\n        if w <= capacity:\n            return False\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        # Score: value loss per weight recovered, tie by higher weight then lower value\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        changed = False\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    # Ensure starting feasibility (do not return yet; we will perform a modifying move)\n    repair(bits)\n    w0 = cur_weight(bits)\n\n    # Candidate move strategies; guarantee at least one change\n    move = \"noop\"\n\n    # Strategy A: add best-ratio item that fits\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if unselected:\n        best_add = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        if w0 + weights[best_add] <= capacity:\n            bits[best_add] = '1'\n            move = \"add_best_ratio\"\n            return (''.join(bits), move)\n\n    # Strategy B: 1-1 exchange: drop worst by ratio, add best by ratio if fits\n    idx_on = [i for i,b in enumerate(bits) if b == '1']\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if idx_on and unselected:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        new_w = w0 - weights[worst_on] + weights[best_off]\n        if new_w <= capacity and (values[best_off] > values[worst_on]):\n            bits[worst_on] = '0'\n            bits[best_off] = '1'\n            move = \"swap_1_1\"\n            return (''.join(bits), move)\n\n    # Strategy C: 2-for-1 or 1-for-2 bounded exchanges\n    if unselected and len(idx_on) >= 2:\n        # Try dropping up to 2 worst to add best\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        # pick two worst currently on\n        worst_pair = sorted(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))[:2]\n        drop_w = sum(weights[i] for i in worst_pair)\n        if w0 - drop_w + weights[best_off] <= capacity and values[best_off] > sum(values[i] for i in worst_pair):\n            for i in worst_pair:\n                bits[i] = '0'\n            bits[best_off] = '1'\n            move = \"swap_2_1\"\n            return (''.join(bits), move)\n\n    if len(unselected) >= 2 and idx_on:\n        # Try drop worst_on and add two best offs\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_two = sorted(unselected, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True)[:2]\n        add_w = sum(weights[i] for i in best_two)\n        if w0 - weights[worst_on] + add_w <= capacity and sum(values[i] for i in best_two) > values[worst_on]:\n            bits[worst_on] = '0'\n            for i in best_two:\n                bits[i] = '1'\n            move = \"swap_1_2\"\n            return (''.join(bits), move)\n\n    # Strategy D: if no constructive move, remove the worst item to diversify (if any on)\n    if idx_on:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        bits[worst_on] = '0'\n        move = \"drop_worst\"\n        return (''.join(bits), move)\n\n    # Fallback: flip best feasible bit (should not occur often)\n    unselected = [i for i in range(n) if bits[i] == '0']\n    if unselected:\n        # Choose the lightest highest-value that fits alone\n        cand = sorted(unselected, key=lambda i: (-values[i], weights[i], -ratio[i]))\n        for i in cand:\n            if weights[i] <= capacity:\n                bits[i] = '1'\n                move = \"fallback_add\"\n                break\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Base normalization\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def total_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        w = total_weight(bl)\n        if w <= capacity:\n            return\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n\n    # Strength-controlled random flips then repair\n    k = 3\n    idx = list(range(n))\n    random.shuffle(idx)\n    flips = idx[:k]\n    for i in flips:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Try to greedily add a couple of high-ratio items if room remains\n    repair(bits)\n    w = total_weight(bits)\n    candidates = [i for i in range(n) if bits[i] == '0']\n    for i in sorted(candidates, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True):\n        if w + weights[i] <= capacity:\n            bits[i] = '1'\n            w += weights[i]\n        if w == capacity:\n            break\n\n    repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001311096}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000' encodes items [4,8,18]. Length must be exactly 24.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Strict validation\n    if not isinstance(solution, str):\n        return 1_000_000.0\n    if len(solution) != n:\n        return 1_000_000.0\n    if any(ch not in ('0','1') for ch in solution):\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n            if total_w > capacity:\n                # Early exit overweight\n                excess = total_w - capacity\n                return 1_000_000.0 + float(excess) * 100.0\n    # Feasible: return negative value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Validate or initialize to feasible empty solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    # Precompute helpers\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def cur_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def cur_value(bl):\n        return sum(values[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        # If overweight, drop items with minimal value loss per weight until feasible\n        w = cur_weight(bl)\n        if w <= capacity:\n            return False\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        # Score: value loss per weight recovered, tie by higher weight then lower value\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        changed = False\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    # Ensure starting feasibility (do not return yet; we will perform a modifying move)\n    repair(bits)\n    w0 = cur_weight(bits)\n\n    # Candidate move strategies; guarantee at least one change\n    move = \"noop\"\n\n    # Strategy A: add best-ratio item that fits\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if unselected:\n        best_add = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        if w0 + weights[best_add] <= capacity:\n            bits[best_add] = '1'\n            move = \"add_best_ratio\"\n            return (''.join(bits), move)\n\n    # Strategy B: 1-1 exchange: drop worst by ratio, add best by ratio if fits\n    idx_on = [i for i,b in enumerate(bits) if b == '1']\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if idx_on and unselected:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        new_w = w0 - weights[worst_on] + weights[best_off]\n        if new_w <= capacity and (values[best_off] > values[worst_on]):\n            bits[worst_on] = '0'\n            bits[best_off] = '1'\n            move = \"swap_1_1\"\n            return (''.join(bits), move)\n\n    # Strategy C: 2-for-1 or 1-for-2 bounded exchanges\n    if unselected and len(idx_on) >= 2:\n        # Try dropping up to 2 worst to add best\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        # pick two worst currently on\n        worst_pair = sorted(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))[:2]\n        drop_w = sum(weights[i] for i in worst_pair)\n        if w0 - drop_w + weights[best_off] <= capacity and values[best_off] > sum(values[i] for i in worst_pair):\n            for i in worst_pair:\n                bits[i] = '0'\n            bits[best_off] = '1'\n            move = \"swap_2_1\"\n            return (''.join(bits), move)\n\n    if len(unselected) >= 2 and idx_on:\n        # Try drop worst_on and add two best offs\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_two = sorted(unselected, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True)[:2]\n        add_w = sum(weights[i] for i in best_two)\n        if w0 - weights[worst_on] + add_w <= capacity and sum(values[i] for i in best_two) > values[worst_on]:\n            bits[worst_on] = '0'\n            for i in best_two:\n                bits[i] = '1'\n            move = \"swap_1_2\"\n            return (''.join(bits), move)\n\n    # Strategy D: if no constructive move, remove the worst item to diversify (if any on)\n    if idx_on:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        bits[worst_on] = '0'\n        move = \"drop_worst\"\n        return (''.join(bits), move)\n\n    # Fallback: flip best feasible bit (should not occur often)\n    unselected = [i for i in range(n) if bits[i] == '0']\n    if unselected:\n        # Choose the lightest highest-value that fits alone\n        cand = sorted(unselected, key=lambda i: (-values[i], weights[i], -ratio[i]))\n        for i in cand:\n            if weights[i] <= capacity:\n                bits[i] = '1'\n                move = \"fallback_add\"\n                break\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Base normalization\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def total_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        w = total_weight(bl)\n        if w <= capacity:\n            return\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n\n    # Strength-controlled random flips then repair\n    k = 3\n    idx = list(range(n))\n    random.shuffle(idx)\n    flips = idx[:k]\n    for i in flips:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Try to greedily add a couple of high-ratio items if room remains\n    repair(bits)\n    w = total_weight(bits)\n    candidates = [i for i in range(n) if bits[i] == '0']\n    for i in sorted(candidates, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True):\n        if w + weights[i] <= capacity:\n            bits[i] = '1'\n            w += weights[i]\n        if w == capacity:\n            break\n\n    repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0012516739}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Parse binary string to selections\n    sel = [1 if c == '1' else 0 for c in solution.strip()]\n    if len(sel) != len(costs):\n        return float('inf')\n\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Heuristic: lower score is better; maximize value via negative; penalize infeasible\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1_000_000.0 + 1_000.0 * over - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defines the neighbor move type; does not return the neighbor solution per required signature\n    # A single random bit flip is the intended neighbor operator\n    _ = solution  # argument acknowledged to satisfy interface\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k bits (k in {2,3}) to escape local optima\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = 2 if n < 3 else random.choice([2, 3])\n    idxs = random.sample(range(n), k=min(k, n))\n    bits = list(solution)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00002135}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Parse binary string to selections\n    sel = [1 if c == '1' else 0 for c in solution.strip()]\n    if len(sel) != len(costs):\n        return float('inf')\n\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Heuristic: lower score is better; maximize value via negative; penalize infeasible\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1_000_000.0 + 1_000.0 * over - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defines the neighbor move type; does not return the neighbor solution per required signature\n    # A single random bit flip is the intended neighbor operator\n    _ = solution  # argument acknowledged to satisfy interface\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k bits (k in {2,3}) to escape local optima\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = 2 if n < 3 else random.choice([2, 3])\n    idxs = random.sample(range(n), k=min(k, n))\n    bits = list(solution)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000488}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Parse binary string to selections\n    sel = [1 if c == '1' else 0 for c in solution.strip()]\n    if len(sel) != len(costs):\n        return float('inf')\n\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Heuristic: lower score is better; maximize value via negative; penalize infeasible\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1_000_000.0 + 1_000.0 * over - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defines the neighbor move type; does not return the neighbor solution per required signature\n    # A single random bit flip is the intended neighbor operator\n    _ = solution  # argument acknowledged to satisfy interface\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k bits (k in {2,3}) to escape local optima\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = 2 if n < 3 else random.choice([2, 3])\n    idxs = random.sample(range(n), k=min(k, n))\n    bits = list(solution)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000269}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Scaled penalty to guide back to feasibility while preserving gradient by value\n    return 10000.0 * over + 100.0 - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This function reports the neighborhood move type per required signature.\n    # Neighbor operators considered by the search: single flip, double flip, and swap(1->0,0->1)\n    _ = solution\n    move_types = [\n        (\"flip\", \"single_bit\"),\n        (\"flip\", \"double_bit\"),\n        (\"swap\", \"one_one_zero_zero\")\n    ]\n    return random.choice(move_types)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits (k in {3,4,5}); then repair if over budget by dropping worst density items.\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n\n    n = len(solution)\n    bits = list(solution)\n    k = 3 if n < 5 else random.choice([3, 4, 5])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k=k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    candidate = ''.join(bits)\n\n    # Embedded problem data for repair\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def cost_value(sel_str):\n        sel = [1 if c == '1' else 0 for c in sel_str]\n        total_cost = sum(c for c, s in zip(costs, sel) if s)\n        total_value = sum(v for v, s in zip(values, sel) if s)\n        return total_cost, total_value\n\n    total_cost, _ = cost_value(candidate)\n    if total_cost <= budget:\n        return candidate\n\n    # Repair: iteratively drop selected items with lowest value density until feasible\n    sel = [1 if c == '1' else 0 for c in candidate]\n    items = list(range(n))\n    densities = [(i, values[i] \/ costs[i] if costs[i] > 0 else 0.0) for i in items]\n\n    while True:\n        total_cost = sum(costs[i] for i in items if sel[i])\n        if total_cost <= budget:\n            break\n        # find worst density among selected items\n        worst_idx = None\n        worst_density = float('inf')\n        for i, d in densities:\n            if sel[i] and d < worst_density:\n                worst_density = d\n                worst_idx = i\n        if worst_idx is None:\n            break\n        sel[worst_idx] = 0\n\n    return ''.join('1' if x else '0' for x in sel)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000147601}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Scaled penalty to guide back to feasibility while preserving gradient by value\n    return 10000.0 * over + 100.0 - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This function reports the neighborhood move type per required signature.\n    # Neighbor operators considered by the search: single flip, double flip, and swap(1->0,0->1)\n    _ = solution\n    move_types = [\n        (\"flip\", \"single_bit\"),\n        (\"flip\", \"double_bit\"),\n        (\"swap\", \"one_one_zero_zero\")\n    ]\n    return random.choice(move_types)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits (k in {3,4,5}); then repair if over budget by dropping worst density items.\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n\n    n = len(solution)\n    bits = list(solution)\n    k = 3 if n < 5 else random.choice([3, 4, 5])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k=k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    candidate = ''.join(bits)\n\n    # Embedded problem data for repair\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def cost_value(sel_str):\n        sel = [1 if c == '1' else 0 for c in sel_str]\n        total_cost = sum(c for c, s in zip(costs, sel) if s)\n        total_value = sum(v for v, s in zip(values, sel) if s)\n        return total_cost, total_value\n\n    total_cost, _ = cost_value(candidate)\n    if total_cost <= budget:\n        return candidate\n\n    # Repair: iteratively drop selected items with lowest value density until feasible\n    sel = [1 if c == '1' else 0 for c in candidate]\n    items = list(range(n))\n    densities = [(i, values[i] \/ costs[i] if costs[i] > 0 else 0.0) for i in items]\n\n    while True:\n        total_cost = sum(costs[i] for i in items if sel[i])\n        if total_cost <= budget:\n            break\n        # find worst density among selected items\n        worst_idx = None\n        worst_density = float('inf')\n        for i, d in densities:\n            if sel[i] and d < worst_density:\n                worst_density = d\n                worst_idx = i\n        if worst_idx is None:\n            break\n        sel[worst_idx] = 0\n\n    return ''.join('1' if x else '0' for x in sel)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000436}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Scaled penalty to guide back to feasibility while preserving gradient by value\n    return 10000.0 * over + 100.0 - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This function reports the neighborhood move type per required signature.\n    # Neighbor operators considered by the search: single flip, double flip, and swap(1->0,0->1)\n    _ = solution\n    move_types = [\n        (\"flip\", \"single_bit\"),\n        (\"flip\", \"double_bit\"),\n        (\"swap\", \"one_one_zero_zero\")\n    ]\n    return random.choice(move_types)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits (k in {3,4,5}); then repair if over budget by dropping worst density items.\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n\n    n = len(solution)\n    bits = list(solution)\n    k = 3 if n < 5 else random.choice([3, 4, 5])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k=k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    candidate = ''.join(bits)\n\n    # Embedded problem data for repair\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def cost_value(sel_str):\n        sel = [1 if c == '1' else 0 for c in sel_str]\n        total_cost = sum(c for c, s in zip(costs, sel) if s)\n        total_value = sum(v for v, s in zip(values, sel) if s)\n        return total_cost, total_value\n\n    total_cost, _ = cost_value(candidate)\n    if total_cost <= budget:\n        return candidate\n\n    # Repair: iteratively drop selected items with lowest value density until feasible\n    sel = [1 if c == '1' else 0 for c in candidate]\n    items = list(range(n))\n    densities = [(i, values[i] \/ costs[i] if costs[i] > 0 else 0.0) for i in items]\n\n    while True:\n        total_cost = sum(costs[i] for i in items if sel[i])\n        if total_cost <= budget:\n            break\n        # find worst density among selected items\n        worst_idx = None\n        worst_density = float('inf')\n        for i, d in densities:\n            if sel[i] and d < worst_density:\n                worst_density = d\n                worst_idx = i\n        if worst_idx is None:\n            break\n        sel[worst_idx] = 0\n\n    return ''.join('1' if x else '0' for x in sel)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000314}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions with adaptive penalty.\n    if total_cost <= budget:\n        return -float(total_value)\n\n    over = total_cost - budget\n    # Adaptive penalty scale around value magnitudes\n    alpha = 100.0\n    base_penalty = 1000.0\n    return base_penalty + alpha * float(over) - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid 24-bit binary string; if not, create a random feasible start\n    def make_random_feasible(n=24):\n        costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        budget = 90\n        bits = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        solution = make_random_feasible(24)\n\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n\n    def total_cost(bits_list):\n        return sum(costs[i] for i, b in enumerate(bits_list) if b == '1')\n\n    def total_value(bits_list):\n        return sum(values[i] for i, b in enumerate(bits_list) if b == '1')\n\n    current_cost = total_cost(bits)\n\n    # Select move type\n    r = random.random()\n    move_label = 'flip_single_cost_aware'\n\n    if r < 0.4:\n        # Cost-aware add if affordable; else drop a random 1\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        densities = sorted(zeros, key=lambda i: (values[i] \/ costs[i]), reverse=True)\n        applied = False\n        for j in densities:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                applied = True\n                move_label = 'add_single_affordable'\n                break\n        if not applied:\n            if ones:\n                i = random.choice(ones)\n                bits[i] = '0'\n                move_label = 'drop_single'\n            else:\n                # nothing selected; add best density even if over, then repair by dropping one expensive\n                if zeros:\n                    j = densities[0]\n                    bits[j] = '1'\n                    move_label = 'add_then_repair'\n                    # repair: drop worst density selected until feasible\n                    while total_cost(bits) > budget:\n                        sel = [k for k, b in enumerate(bits) if b == '1']\n                        if not sel:\n                            break\n                        worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n                        bits[worst] = '0'\n    elif r < 0.8:\n        # Swap-in-out: try to add a 0-bit item and drop a 1-bit item to remain feasible with best gain\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        random.shuffle(zeros)\n        best_delta = None\n        best_pair = None\n        for j in zeros[:min(len(zeros), 8)]:  # limit tries for speed\n            # if can add directly, do it\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n            for i in ones:\n                new_cost = current_cost - costs[i] + costs[j]\n                if new_cost <= budget:\n                    delta = values[j] - values[i]\n                    if (best_delta is None) or (delta > best_delta):\n                        best_delta = delta\n                        best_pair = (i, j)\n        else:\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_in_out_best_delta'\n            else:\n                # fallback: drop a random 1 if exists\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_fallback'\n                else:\n                    # or add cheapest if feasible\n                    zeros_sorted = sorted(zeros, key=lambda k: costs[k])\n                    for k in zeros_sorted:\n                        if current_cost + costs[k] <= budget:\n                            bits[k] = '1'\n                            move_label = 'add_cheapest'\n                            break\n    else:\n        # Double flip: drop one selected and add one unselected with best value-density feasible\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            bits[i] = '0'\n            current_cost2 = current_cost - costs[i]\n            # add best density that fits\n            zeros_sorted = sorted(zeros, key=lambda j: (values[j]\/costs[j]), reverse=True)\n            added = False\n            for j in zeros_sorted:\n                if current_cost2 + costs[j] <= budget:\n                    bits[j] = '1'\n                    added = True\n                    break\n            move_label = 'double_flip_drop_add' if added else 'double_flip_drop_only'\n        else:\n            # fallback: single add if feasible\n            zeros = [j for j, b in enumerate(bits) if b == '0']\n            zeros_sorted = sorted(zeros, key=lambda j: costs[j])\n            for j in zeros_sorted:\n                if current_cost + costs[j] <= budget:\n                    bits[j] = '1'\n                    move_label = 'fallback_add_single'\n                    break\n\n    neighbour = ''.join(bits)\n    # Final guard: ensure feasibility; if infeasible, repair by dropping worst density until feasible\n    if sum(costs[i] for i, b in enumerate(bits) if b == '1') > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        while sum(costs[i] for i in sel) > budget and sel:\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n            sel.remove(worst)\n        neighbour = ''.join(bits)\n        move_label = move_label + '_repaired'\n\n    return neighbour, move_label\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits then greedy repair by dropping lowest value-density until feasible\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        # If invalid, initialize to all zeros as neutral start\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k random bits (3..6)\n    k = min(max(3, n \/\/ 8), 6)\n    k = random.choice([k, k+1, min(k+2, 6)])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    # Repair if infeasible by dropping worst value-density items\n    def total_cost(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    if total_cost(bits) > budget:\n        while total_cost(bits) > budget:\n            sel = [i for i, b in enumerate(bits) if b == '1']\n            if not sel:\n                break\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000152399}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions with adaptive penalty.\n    if total_cost <= budget:\n        return -float(total_value)\n\n    over = total_cost - budget\n    # Adaptive penalty scale around value magnitudes\n    alpha = 100.0\n    base_penalty = 1000.0\n    return base_penalty + alpha * float(over) - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid 24-bit binary string; if not, create a random feasible start\n    def make_random_feasible(n=24):\n        costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        budget = 90\n        bits = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        solution = make_random_feasible(24)\n\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n\n    def total_cost(bits_list):\n        return sum(costs[i] for i, b in enumerate(bits_list) if b == '1')\n\n    def total_value(bits_list):\n        return sum(values[i] for i, b in enumerate(bits_list) if b == '1')\n\n    current_cost = total_cost(bits)\n\n    # Select move type\n    r = random.random()\n    move_label = 'flip_single_cost_aware'\n\n    if r < 0.4:\n        # Cost-aware add if affordable; else drop a random 1\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        densities = sorted(zeros, key=lambda i: (values[i] \/ costs[i]), reverse=True)\n        applied = False\n        for j in densities:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                applied = True\n                move_label = 'add_single_affordable'\n                break\n        if not applied:\n            if ones:\n                i = random.choice(ones)\n                bits[i] = '0'\n                move_label = 'drop_single'\n            else:\n                # nothing selected; add best density even if over, then repair by dropping one expensive\n                if zeros:\n                    j = densities[0]\n                    bits[j] = '1'\n                    move_label = 'add_then_repair'\n                    # repair: drop worst density selected until feasible\n                    while total_cost(bits) > budget:\n                        sel = [k for k, b in enumerate(bits) if b == '1']\n                        if not sel:\n                            break\n                        worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n                        bits[worst] = '0'\n    elif r < 0.8:\n        # Swap-in-out: try to add a 0-bit item and drop a 1-bit item to remain feasible with best gain\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        random.shuffle(zeros)\n        best_delta = None\n        best_pair = None\n        for j in zeros[:min(len(zeros), 8)]:  # limit tries for speed\n            # if can add directly, do it\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n            for i in ones:\n                new_cost = current_cost - costs[i] + costs[j]\n                if new_cost <= budget:\n                    delta = values[j] - values[i]\n                    if (best_delta is None) or (delta > best_delta):\n                        best_delta = delta\n                        best_pair = (i, j)\n        else:\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_in_out_best_delta'\n            else:\n                # fallback: drop a random 1 if exists\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_fallback'\n                else:\n                    # or add cheapest if feasible\n                    zeros_sorted = sorted(zeros, key=lambda k: costs[k])\n                    for k in zeros_sorted:\n                        if current_cost + costs[k] <= budget:\n                            bits[k] = '1'\n                            move_label = 'add_cheapest'\n                            break\n    else:\n        # Double flip: drop one selected and add one unselected with best value-density feasible\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            bits[i] = '0'\n            current_cost2 = current_cost - costs[i]\n            # add best density that fits\n            zeros_sorted = sorted(zeros, key=lambda j: (values[j]\/costs[j]), reverse=True)\n            added = False\n            for j in zeros_sorted:\n                if current_cost2 + costs[j] <= budget:\n                    bits[j] = '1'\n                    added = True\n                    break\n            move_label = 'double_flip_drop_add' if added else 'double_flip_drop_only'\n        else:\n            # fallback: single add if feasible\n            zeros = [j for j, b in enumerate(bits) if b == '0']\n            zeros_sorted = sorted(zeros, key=lambda j: costs[j])\n            for j in zeros_sorted:\n                if current_cost + costs[j] <= budget:\n                    bits[j] = '1'\n                    move_label = 'fallback_add_single'\n                    break\n\n    neighbour = ''.join(bits)\n    # Final guard: ensure feasibility; if infeasible, repair by dropping worst density until feasible\n    if sum(costs[i] for i, b in enumerate(bits) if b == '1') > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        while sum(costs[i] for i in sel) > budget and sel:\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n            sel.remove(worst)\n        neighbour = ''.join(bits)\n        move_label = move_label + '_repaired'\n\n    return neighbour, move_label\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits then greedy repair by dropping lowest value-density until feasible\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        # If invalid, initialize to all zeros as neutral start\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k random bits (3..6)\n    k = min(max(3, n \/\/ 8), 6)\n    k = random.choice([k, k+1, min(k+2, 6)])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    # Repair if infeasible by dropping worst value-density items\n    def total_cost(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    if total_cost(bits) > budget:\n        while total_cost(bits) > budget:\n            sel = [i for i, b in enumerate(bits) if b == '1']\n            if not sel:\n                break\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0000046}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions with adaptive penalty.\n    if total_cost <= budget:\n        return -float(total_value)\n\n    over = total_cost - budget\n    # Adaptive penalty scale around value magnitudes\n    alpha = 100.0\n    base_penalty = 1000.0\n    return base_penalty + alpha * float(over) - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid 24-bit binary string; if not, create a random feasible start\n    def make_random_feasible(n=24):\n        costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        budget = 90\n        bits = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        solution = make_random_feasible(24)\n\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n\n    def total_cost(bits_list):\n        return sum(costs[i] for i, b in enumerate(bits_list) if b == '1')\n\n    def total_value(bits_list):\n        return sum(values[i] for i, b in enumerate(bits_list) if b == '1')\n\n    current_cost = total_cost(bits)\n\n    # Select move type\n    r = random.random()\n    move_label = 'flip_single_cost_aware'\n\n    if r < 0.4:\n        # Cost-aware add if affordable; else drop a random 1\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        densities = sorted(zeros, key=lambda i: (values[i] \/ costs[i]), reverse=True)\n        applied = False\n        for j in densities:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                applied = True\n                move_label = 'add_single_affordable'\n                break\n        if not applied:\n            if ones:\n                i = random.choice(ones)\n                bits[i] = '0'\n                move_label = 'drop_single'\n            else:\n                # nothing selected; add best density even if over, then repair by dropping one expensive\n                if zeros:\n                    j = densities[0]\n                    bits[j] = '1'\n                    move_label = 'add_then_repair'\n                    # repair: drop worst density selected until feasible\n                    while total_cost(bits) > budget:\n                        sel = [k for k, b in enumerate(bits) if b == '1']\n                        if not sel:\n                            break\n                        worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n                        bits[worst] = '0'\n    elif r < 0.8:\n        # Swap-in-out: try to add a 0-bit item and drop a 1-bit item to remain feasible with best gain\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        random.shuffle(zeros)\n        best_delta = None\n        best_pair = None\n        for j in zeros[:min(len(zeros), 8)]:  # limit tries for speed\n            # if can add directly, do it\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n            for i in ones:\n                new_cost = current_cost - costs[i] + costs[j]\n                if new_cost <= budget:\n                    delta = values[j] - values[i]\n                    if (best_delta is None) or (delta > best_delta):\n                        best_delta = delta\n                        best_pair = (i, j)\n        else:\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_in_out_best_delta'\n            else:\n                # fallback: drop a random 1 if exists\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_fallback'\n                else:\n                    # or add cheapest if feasible\n                    zeros_sorted = sorted(zeros, key=lambda k: costs[k])\n                    for k in zeros_sorted:\n                        if current_cost + costs[k] <= budget:\n                            bits[k] = '1'\n                            move_label = 'add_cheapest'\n                            break\n    else:\n        # Double flip: drop one selected and add one unselected with best value-density feasible\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            bits[i] = '0'\n            current_cost2 = current_cost - costs[i]\n            # add best density that fits\n            zeros_sorted = sorted(zeros, key=lambda j: (values[j]\/costs[j]), reverse=True)\n            added = False\n            for j in zeros_sorted:\n                if current_cost2 + costs[j] <= budget:\n                    bits[j] = '1'\n                    added = True\n                    break\n            move_label = 'double_flip_drop_add' if added else 'double_flip_drop_only'\n        else:\n            # fallback: single add if feasible\n            zeros = [j for j, b in enumerate(bits) if b == '0']\n            zeros_sorted = sorted(zeros, key=lambda j: costs[j])\n            for j in zeros_sorted:\n                if current_cost + costs[j] <= budget:\n                    bits[j] = '1'\n                    move_label = 'fallback_add_single'\n                    break\n\n    neighbour = ''.join(bits)\n    # Final guard: ensure feasibility; if infeasible, repair by dropping worst density until feasible\n    if sum(costs[i] for i, b in enumerate(bits) if b == '1') > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        while sum(costs[i] for i in sel) > budget and sel:\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n            sel.remove(worst)\n        neighbour = ''.join(bits)\n        move_label = move_label + '_repaired'\n\n    return neighbour, move_label\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits then greedy repair by dropping lowest value-density until feasible\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        # If invalid, initialize to all zeros as neutral start\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k random bits (3..6)\n    k = min(max(3, n \/\/ 8), 6)\n    k = random.choice([k, k+1, min(k+2, 6)])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    # Repair if infeasible by dropping worst value-density items\n    def total_cost(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    if total_cost(bits) > budget:\n        while total_cost(bits) > budget:\n            sel = [i for i, b in enumerate(bits) if b == '1']\n            if not sel:\n                break\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000322}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom functools import lru_cache\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return 1e12\n    if not re.fullmatch(r\"[01]{24}\", solution):\n        return 1e12\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better: maximize value via negative score\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Infeasible: linear penalty on budget violation with mild shaping, minus value to preserve gradient\n    over = float(total_cost - budget)\n    lambda_pen = 12.0  # tuned to be > typical value gain per cheapest item\n    return lambda_pen * over - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> tuple[str, str]:\n    # Problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Greedy density-based feasible initializer\n    def greedy_feasible() -> str:\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        bits = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    # Validate\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = greedy_feasible()\n\n    bits = list(solution)\n\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    def total_value_bits(bl):\n        return sum(values[i] for i, b in enumerate(bl) if b == '1')\n\n    current_cost = total_cost_bits(bits)\n\n    r = random.random()\n    move_label = 'noop'\n\n    # Move set: add, drop, 1-out-1-in swap, limited 2-exchange\n    if r < 0.35:\n        # Add best affordable by density\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        zeros.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        for j in zeros:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_best_affordable'\n                break\n        if move_label == 'noop':\n            # Drop worst density to open space\n            ones = [i for i, b in enumerate(bits) if b == '1']\n            if ones:\n                worst = min(ones, key=lambda i: (values[i]\/costs[i], -costs[i]))\n                bits[worst] = '0'\n                move_label = 'drop_worst_density'\n    elif r < 0.7:\n        # Best improving feasible swap (1-out,1-in)\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        best_delta = None\n        best_pair = None\n        for j in zeros:\n            cj = costs[j]\n            vj = values[j]\n            if current_cost + cj <= budget:\n                # direct add if fits\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n        else:\n            for i in ones:\n                ci = costs[i]\n                vi = values[i]\n                for j in zeros:\n                    new_cost = current_cost - ci + costs[j]\n                    if new_cost <= budget:\n                        delta = values[j] - vi\n                        if (best_delta is None) or (delta > best_delta):\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_1out_1in_best'\n            else:\n                # fallback: drop a random selected if any\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_random_fallback'\n    else:\n        # Limited 2-exchange: try remove up to 2 and add up to 2 greedily\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        # Randomly pick a candidate to drop, then refill by best density\n        dropped = []\n        if ones:\n            i = random.choice(ones)\n            bits[i] = '0'\n            dropped.append(i)\n        if len(ones) > 1 and random.random() < 0.5:\n            others = [x for x in ones if x != dropped[0]]\n            i2 = random.choice(others)\n            bits[i2] = '0'\n            dropped.append(i2)\n        move_label = f'drop_{len(dropped)}'\n        # Refill by density while feasible\n        current_cost2 = total_cost_bits(bits)\n        zeros_now = [j for j, b in enumerate(bits) if b == '0']\n        zeros_now.sort(key=lambda j: (values[j]\/costs[j], values[j]), reverse=True)\n        added = 0\n        for j in zeros_now:\n            if current_cost2 + costs[j] <= budget:\n                bits[j] = '1'\n                current_cost2 += costs[j]\n                added += 1\n                if added >= 2:\n                    break\n        move_label = move_label + f'_add_{added}'\n\n    # Final repair to ensure feasibility\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n        move_label = move_label + '_repaired'\n\n    neighbour = ''.join(bits)\n    return neighbour, move_label\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Validate\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k bits (3..6), biased to low-density indices for drops and high-density for adds\n    densities = [(i, (values[i]\/costs[i])) for i in range(n)]\n    densities.sort(key=lambda x: x[1])\n    low_density = [i for i, _ in densities[:max(3, n\/\/6)]]\n    high_density = [i for i, _ in densities[-max(3, n\/\/6):]]\n\n    k = random.choice([3,4,5,6])\n    idxs = set()\n    # Prefer flipping some low-density selected bits to 0\n    selected = [i for i, b in enumerate(bits) if b == '1']\n    random.shuffle(selected)\n    for i in selected:\n        if i in low_density:\n            idxs.add(i)\n            if len(idxs) >= k:\n                break\n    # Fill remaining flips randomly\n    while len(idxs) < k:\n        idxs.add(random.randrange(n))\n\n    for i in idxs:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Repair by dropping worst density until feasible\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000143}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom functools import lru_cache\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return 1e12\n    if not re.fullmatch(r\"[01]{24}\", solution):\n        return 1e12\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better: maximize value via negative score\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Infeasible: linear penalty on budget violation with mild shaping, minus value to preserve gradient\n    over = float(total_cost - budget)\n    lambda_pen = 12.0  # tuned to be > typical value gain per cheapest item\n    return lambda_pen * over - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> tuple[str, str]:\n    # Problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Greedy density-based feasible initializer\n    def greedy_feasible() -> str:\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        bits = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    # Validate\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = greedy_feasible()\n\n    bits = list(solution)\n\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    def total_value_bits(bl):\n        return sum(values[i] for i, b in enumerate(bl) if b == '1')\n\n    current_cost = total_cost_bits(bits)\n\n    r = random.random()\n    move_label = 'noop'\n\n    # Move set: add, drop, 1-out-1-in swap, limited 2-exchange\n    if r < 0.35:\n        # Add best affordable by density\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        zeros.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        for j in zeros:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_best_affordable'\n                break\n        if move_label == 'noop':\n            # Drop worst density to open space\n            ones = [i for i, b in enumerate(bits) if b == '1']\n            if ones:\n                worst = min(ones, key=lambda i: (values[i]\/costs[i], -costs[i]))\n                bits[worst] = '0'\n                move_label = 'drop_worst_density'\n    elif r < 0.7:\n        # Best improving feasible swap (1-out,1-in)\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        best_delta = None\n        best_pair = None\n        for j in zeros:\n            cj = costs[j]\n            vj = values[j]\n            if current_cost + cj <= budget:\n                # direct add if fits\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n        else:\n            for i in ones:\n                ci = costs[i]\n                vi = values[i]\n                for j in zeros:\n                    new_cost = current_cost - ci + costs[j]\n                    if new_cost <= budget:\n                        delta = values[j] - vi\n                        if (best_delta is None) or (delta > best_delta):\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_1out_1in_best'\n            else:\n                # fallback: drop a random selected if any\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_random_fallback'\n    else:\n        # Limited 2-exchange: try remove up to 2 and add up to 2 greedily\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        # Randomly pick a candidate to drop, then refill by best density\n        dropped = []\n        if ones:\n            i = random.choice(ones)\n            bits[i] = '0'\n            dropped.append(i)\n        if len(ones) > 1 and random.random() < 0.5:\n            others = [x for x in ones if x != dropped[0]]\n            i2 = random.choice(others)\n            bits[i2] = '0'\n            dropped.append(i2)\n        move_label = f'drop_{len(dropped)}'\n        # Refill by density while feasible\n        current_cost2 = total_cost_bits(bits)\n        zeros_now = [j for j, b in enumerate(bits) if b == '0']\n        zeros_now.sort(key=lambda j: (values[j]\/costs[j], values[j]), reverse=True)\n        added = 0\n        for j in zeros_now:\n            if current_cost2 + costs[j] <= budget:\n                bits[j] = '1'\n                current_cost2 += costs[j]\n                added += 1\n                if added >= 2:\n                    break\n        move_label = move_label + f'_add_{added}'\n\n    # Final repair to ensure feasibility\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n        move_label = move_label + '_repaired'\n\n    neighbour = ''.join(bits)\n    return neighbour, move_label\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Validate\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k bits (3..6), biased to low-density indices for drops and high-density for adds\n    densities = [(i, (values[i]\/costs[i])) for i in range(n)]\n    densities.sort(key=lambda x: x[1])\n    low_density = [i for i, _ in densities[:max(3, n\/\/6)]]\n    high_density = [i for i, _ in densities[-max(3, n\/\/6):]]\n\n    k = random.choice([3,4,5,6])\n    idxs = set()\n    # Prefer flipping some low-density selected bits to 0\n    selected = [i for i, b in enumerate(bits) if b == '1']\n    random.shuffle(selected)\n    for i in selected:\n        if i in low_density:\n            idxs.add(i)\n            if len(idxs) >= k:\n                break\n    # Fill remaining flips randomly\n    while len(idxs) < k:\n        idxs.add(random.randrange(n))\n\n    for i in idxs:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Repair by dropping worst density until feasible\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000425}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom functools import lru_cache\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return 1e12\n    if not re.fullmatch(r\"[01]{24}\", solution):\n        return 1e12\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better: maximize value via negative score\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Infeasible: linear penalty on budget violation with mild shaping, minus value to preserve gradient\n    over = float(total_cost - budget)\n    lambda_pen = 12.0  # tuned to be > typical value gain per cheapest item\n    return lambda_pen * over - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> tuple[str, str]:\n    # Problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Greedy density-based feasible initializer\n    def greedy_feasible() -> str:\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        bits = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    # Validate\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = greedy_feasible()\n\n    bits = list(solution)\n\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    def total_value_bits(bl):\n        return sum(values[i] for i, b in enumerate(bl) if b == '1')\n\n    current_cost = total_cost_bits(bits)\n\n    r = random.random()\n    move_label = 'noop'\n\n    # Move set: add, drop, 1-out-1-in swap, limited 2-exchange\n    if r < 0.35:\n        # Add best affordable by density\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        zeros.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        for j in zeros:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_best_affordable'\n                break\n        if move_label == 'noop':\n            # Drop worst density to open space\n            ones = [i for i, b in enumerate(bits) if b == '1']\n            if ones:\n                worst = min(ones, key=lambda i: (values[i]\/costs[i], -costs[i]))\n                bits[worst] = '0'\n                move_label = 'drop_worst_density'\n    elif r < 0.7:\n        # Best improving feasible swap (1-out,1-in)\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        best_delta = None\n        best_pair = None\n        for j in zeros:\n            cj = costs[j]\n            vj = values[j]\n            if current_cost + cj <= budget:\n                # direct add if fits\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n        else:\n            for i in ones:\n                ci = costs[i]\n                vi = values[i]\n                for j in zeros:\n                    new_cost = current_cost - ci + costs[j]\n                    if new_cost <= budget:\n                        delta = values[j] - vi\n                        if (best_delta is None) or (delta > best_delta):\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_1out_1in_best'\n            else:\n                # fallback: drop a random selected if any\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_random_fallback'\n    else:\n        # Limited 2-exchange: try remove up to 2 and add up to 2 greedily\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        # Randomly pick a candidate to drop, then refill by best density\n        dropped = []\n        if ones:\n            i = random.choice(ones)\n            bits[i] = '0'\n            dropped.append(i)\n        if len(ones) > 1 and random.random() < 0.5:\n            others = [x for x in ones if x != dropped[0]]\n            i2 = random.choice(others)\n            bits[i2] = '0'\n            dropped.append(i2)\n        move_label = f'drop_{len(dropped)}'\n        # Refill by density while feasible\n        current_cost2 = total_cost_bits(bits)\n        zeros_now = [j for j, b in enumerate(bits) if b == '0']\n        zeros_now.sort(key=lambda j: (values[j]\/costs[j], values[j]), reverse=True)\n        added = 0\n        for j in zeros_now:\n            if current_cost2 + costs[j] <= budget:\n                bits[j] = '1'\n                current_cost2 += costs[j]\n                added += 1\n                if added >= 2:\n                    break\n        move_label = move_label + f'_add_{added}'\n\n    # Final repair to ensure feasibility\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n        move_label = move_label + '_repaired'\n\n    neighbour = ''.join(bits)\n    return neighbour, move_label\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Validate\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k bits (3..6), biased to low-density indices for drops and high-density for adds\n    densities = [(i, (values[i]\/costs[i])) for i in range(n)]\n    densities.sort(key=lambda x: x[1])\n    low_density = [i for i, _ in densities[:max(3, n\/\/6)]]\n    high_density = [i for i, _ in densities[-max(3, n\/\/6):]]\n\n    k = random.choice([3,4,5,6])\n    idxs = set()\n    # Prefer flipping some low-density selected bits to 0\n    selected = [i for i, b in enumerate(bits) if b == '1']\n    random.shuffle(selected)\n    for i in selected:\n        if i in low_density:\n            idxs.add(i)\n            if len(idxs) >= k:\n                break\n    # Fill remaining flips randomly\n    while len(idxs) < k:\n        idxs.add(random.randrange(n))\n\n    for i in idxs:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Repair by dropping worst density until feasible\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000029999}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; positions 1..24 map to customers 1..24; character '1' means take offer, '0' means skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    if total_gallons > capacity:\n        # Penalize infeasibility (minimization perspective)\n        overflow = total_gallons - capacity\n        return 1000.0 + overflow * overflow\n    # Feasible: return negative revenue to convert max->min\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor move: flip a single random bit (metadata only returned per required signature)\n    # This function intentionally returns movement descriptors to satisfy the strict signature.\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-bit flip with feasibility bias: try to keep within capacity\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        # produce a random feasible-ish solution\n        base = ['0'] * 24\n        idxs = list(range(24))\n        random.shuffle(idxs)\n        # embed data locally\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        cap = 9\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= cap and random.random() < 0.5:\n                base[i] = '1'\n                used += gallons[i]\n        return ''.join(base)\n    s = list(solution)\n    n_flips = random.randint(1, 3)\n    idxs = list(range(len(s)))\n    random.shuffle(idxs)\n    for i in idxs[:n_flips]:\n        s[i] = '1' if s[i] == '0' else '0'\n    # Repair if infeasible\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    cap = 9\n    # While over capacity, greedily drop lowest value density items among selected\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    def total_gal(ss):\n        return sum(g for c,g in zip(ss, gallons) if c == '1')\n    if total_gal(s) > cap:\n        selected = [i for i,c in enumerate(s) if c == '1']\n        # compute density (value per gallon; items with gallon>cap considered very poor)\n        dens = [(i, (values[i] \/ gallons[i]) if gallons[i] > 0 else 0.0) for i in selected]\n        # remove lowest density first\n        dens.sort(key=lambda x: x[1])\n        for i,_ in dens:\n            s[i] = '0'\n            if total_gal(s) <= cap:\n                break\n    return ''.join(s)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000165701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; positions 1..24 map to customers 1..24; character '1' means take offer, '0' means skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    if total_gallons > capacity:\n        # Penalize infeasibility (minimization perspective)\n        overflow = total_gallons - capacity\n        return 1000.0 + overflow * overflow\n    # Feasible: return negative revenue to convert max->min\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor move: flip a single random bit (metadata only returned per required signature)\n    # This function intentionally returns movement descriptors to satisfy the strict signature.\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-bit flip with feasibility bias: try to keep within capacity\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        # produce a random feasible-ish solution\n        base = ['0'] * 24\n        idxs = list(range(24))\n        random.shuffle(idxs)\n        # embed data locally\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        cap = 9\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= cap and random.random() < 0.5:\n                base[i] = '1'\n                used += gallons[i]\n        return ''.join(base)\n    s = list(solution)\n    n_flips = random.randint(1, 3)\n    idxs = list(range(len(s)))\n    random.shuffle(idxs)\n    for i in idxs[:n_flips]:\n        s[i] = '1' if s[i] == '0' else '0'\n    # Repair if infeasible\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    cap = 9\n    # While over capacity, greedily drop lowest value density items among selected\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    def total_gal(ss):\n        return sum(g for c,g in zip(ss, gallons) if c == '1')\n    if total_gal(s) > cap:\n        selected = [i for i,c in enumerate(s) if c == '1']\n        # compute density (value per gallon; items with gallon>cap considered very poor)\n        dens = [(i, (values[i] \/ gallons[i]) if gallons[i] > 0 else 0.0) for i in selected]\n        # remove lowest density first\n        dens.sort(key=lambda x: x[1])\n        for i,_ in dens:\n            s[i] = '0'\n            if total_gal(s) <= cap:\n                break\n    return ''.join(s)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000418}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; positions 1..24 map to customers 1..24; character '1' means take offer, '0' means skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    if total_gallons > capacity:\n        # Penalize infeasibility (minimization perspective)\n        overflow = total_gallons - capacity\n        return 1000.0 + overflow * overflow\n    # Feasible: return negative revenue to convert max->min\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor move: flip a single random bit (metadata only returned per required signature)\n    # This function intentionally returns movement descriptors to satisfy the strict signature.\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-bit flip with feasibility bias: try to keep within capacity\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        # produce a random feasible-ish solution\n        base = ['0'] * 24\n        idxs = list(range(24))\n        random.shuffle(idxs)\n        # embed data locally\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        cap = 9\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= cap and random.random() < 0.5:\n                base[i] = '1'\n                used += gallons[i]\n        return ''.join(base)\n    s = list(solution)\n    n_flips = random.randint(1, 3)\n    idxs = list(range(len(s)))\n    random.shuffle(idxs)\n    for i in idxs[:n_flips]:\n        s[i] = '1' if s[i] == '0' else '0'\n    # Repair if infeasible\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    cap = 9\n    # While over capacity, greedily drop lowest value density items among selected\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    def total_gal(ss):\n        return sum(g for c,g in zip(ss, gallons) if c == '1')\n    if total_gal(s) > cap:\n        selected = [i for i,c in enumerate(s) if c == '1']\n        # compute density (value per gallon; items with gallon>cap considered very poor)\n        dens = [(i, (values[i] \/ gallons[i]) if gallons[i] > 0 else 0.0) for i in selected]\n        # remove lowest density first\n        dens.sort(key=lambda x: x[1])\n        for i,_ in dens:\n            s[i] = '0'\n            if total_gal(s) <= cap:\n                break\n    return ''.join(s)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000027999}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip. Example: '000100010000000001000000' selects customers {4,8,18}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict validation\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    # Compute totals\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    # Feasibility penalty: strictly dominate any feasible score\n    penalty_base = 1 + sum(values)  # 283\n    if total_gallons > capacity:\n        overflow = total_gallons - capacity\n        return penalty_base + (10**6) * overflow\n    # Feasible: convert max revenue to min cost\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value density until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        sol = random_feasible()\n    else:\n        sol = solution\n\n    move_choice = random.random()\n    s = list(sol)\n\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit\")\n    elif move_choice < 0.7:\n        # Swap: remove one selected, add one unselected if fits best\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used = sum(g for b, g in zip(s, gallons) if b == '1')\n            room = capacity - used\n            # choose best density that fits\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                i_in = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_in] = '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Add\/remove biased by feasibility\n        used = sum(g for b, g in zip(s, gallons) if b == '1')\n        if used < capacity and any(b == '0' for b in s):\n            # try to add best fitting item\n            room = capacity - used\n            cands = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if cands:\n                i_add = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_fit\")\n        else:\n            # remove worst density item to free space\n            sel = [i for i, b in enumerate(s) if b == '1']\n            if sel:\n                i_rem = min(sel, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value-per-gallon until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    s = solution if is_valid_str(solution) else random_feasible()\n    s = list(s)\n    # Adaptive k: 2..4 random flips\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    s = ''.join(s)\n    # Always repair to feasibility basin\n    s = repair_feasible(s)\n    # Intensify by attempting a greedy add if room remains\n    used = sum(g for b, g in zip(s, gallons) if b == '1')\n    room = capacity - used\n    if room > 0:\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if zeros:\n            i_best = max(zeros, key=lambda i: (values[i] \/ gallons[i]))\n            s = list(s)\n            s[i_best] = '1'\n            s = ''.join(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00001984}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip. Example: '000100010000000001000000' selects customers {4,8,18}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict validation\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    # Compute totals\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    # Feasibility penalty: strictly dominate any feasible score\n    penalty_base = 1 + sum(values)  # 283\n    if total_gallons > capacity:\n        overflow = total_gallons - capacity\n        return penalty_base + (10**6) * overflow\n    # Feasible: convert max revenue to min cost\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value density until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        sol = random_feasible()\n    else:\n        sol = solution\n\n    move_choice = random.random()\n    s = list(sol)\n\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit\")\n    elif move_choice < 0.7:\n        # Swap: remove one selected, add one unselected if fits best\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used = sum(g for b, g in zip(s, gallons) if b == '1')\n            room = capacity - used\n            # choose best density that fits\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                i_in = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_in] = '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Add\/remove biased by feasibility\n        used = sum(g for b, g in zip(s, gallons) if b == '1')\n        if used < capacity and any(b == '0' for b in s):\n            # try to add best fitting item\n            room = capacity - used\n            cands = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if cands:\n                i_add = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_fit\")\n        else:\n            # remove worst density item to free space\n            sel = [i for i, b in enumerate(s) if b == '1']\n            if sel:\n                i_rem = min(sel, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value-per-gallon until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    s = solution if is_valid_str(solution) else random_feasible()\n    s = list(s)\n    # Adaptive k: 2..4 random flips\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    s = ''.join(s)\n    # Always repair to feasibility basin\n    s = repair_feasible(s)\n    # Intensify by attempting a greedy add if room remains\n    used = sum(g for b, g in zip(s, gallons) if b == '1')\n    room = capacity - used\n    if room > 0:\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if zeros:\n            i_best = max(zeros, key=lambda i: (values[i] \/ gallons[i]))\n            s = list(s)\n            s[i_best] = '1'\n            s = ''.join(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000469}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip. Example: '000100010000000001000000' selects customers {4,8,18}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict validation\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    # Compute totals\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    # Feasibility penalty: strictly dominate any feasible score\n    penalty_base = 1 + sum(values)  # 283\n    if total_gallons > capacity:\n        overflow = total_gallons - capacity\n        return penalty_base + (10**6) * overflow\n    # Feasible: convert max revenue to min cost\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value density until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        sol = random_feasible()\n    else:\n        sol = solution\n\n    move_choice = random.random()\n    s = list(sol)\n\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit\")\n    elif move_choice < 0.7:\n        # Swap: remove one selected, add one unselected if fits best\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used = sum(g for b, g in zip(s, gallons) if b == '1')\n            room = capacity - used\n            # choose best density that fits\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                i_in = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_in] = '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Add\/remove biased by feasibility\n        used = sum(g for b, g in zip(s, gallons) if b == '1')\n        if used < capacity and any(b == '0' for b in s):\n            # try to add best fitting item\n            room = capacity - used\n            cands = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if cands:\n                i_add = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_fit\")\n        else:\n            # remove worst density item to free space\n            sel = [i for i, b in enumerate(s) if b == '1']\n            if sel:\n                i_rem = min(sel, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value-per-gallon until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    s = solution if is_valid_str(solution) else random_feasible()\n    s = list(s)\n    # Adaptive k: 2..4 random flips\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    s = ''.join(s)\n    # Always repair to feasibility basin\n    s = repair_feasible(s)\n    # Intensify by attempting a greedy add if room remains\n    used = sum(g for b, g in zip(s, gallons) if b == '1')\n    room = capacity - used\n    if room > 0:\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if zeros:\n            i_best = max(zeros, key=lambda i: (values[i] \/ gallons[i]))\n            s = list(s)\n            s[i_best] = '1'\n            s = ''.join(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000285}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict, self-contained evaluator. Feasible solutions return negative revenue (minimize); infeasible return large penalty.\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        n = 24\n        if len(solution) != n or any(c not in '01' for c in solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def value_of(s):\n        return sum(v for b, v in zip(s, values) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Drop by lowest value-per-gallon, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        # Diverse constructive starts: choose among several heuristics\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            # sort by value density desc\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            # sort by value desc\n            key = lambda i: (values[i], -(gallons[i]))\n        else:\n            # randomized greedy with alpha\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        # Greedy fill according to key\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n\n    # Ensure baseline feasibility; if infeasible, repair\n    if weight_of(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of(s)\n    move_choice = random.random()\n\n    if move_choice < 0.4:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.75:\n        # 1-out 1-in exchange preserving feasibility\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                # try multiple scoring rules\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Greedy add or targeted remove to move along tight capacity boundary\n        if used < capacity:\n            room = capacity - used\n            zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if zeros:\n                i_add = max(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_density\")\n        else:\n            # remove worst density to free space\n            ones = [i for i, b in enumerate(s) if b == '1']\n            if ones:\n                i_rem = min(ones, key=lambda i: (values[i] \/ gallons[i], -gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        # construct a minimal feasible baseline\n        feas = ['0'] * n\n        # try best single item that fits\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    # Ruin: flip k bits (biased to 2-3)\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    # Repair to feasibility and then refill greedily\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000146701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict, self-contained evaluator. Feasible solutions return negative revenue (minimize); infeasible return large penalty.\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        n = 24\n        if len(solution) != n or any(c not in '01' for c in solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def value_of(s):\n        return sum(v for b, v in zip(s, values) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Drop by lowest value-per-gallon, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        # Diverse constructive starts: choose among several heuristics\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            # sort by value density desc\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            # sort by value desc\n            key = lambda i: (values[i], -(gallons[i]))\n        else:\n            # randomized greedy with alpha\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        # Greedy fill according to key\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n\n    # Ensure baseline feasibility; if infeasible, repair\n    if weight_of(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of(s)\n    move_choice = random.random()\n\n    if move_choice < 0.4:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.75:\n        # 1-out 1-in exchange preserving feasibility\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                # try multiple scoring rules\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Greedy add or targeted remove to move along tight capacity boundary\n        if used < capacity:\n            room = capacity - used\n            zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if zeros:\n                i_add = max(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_density\")\n        else:\n            # remove worst density to free space\n            ones = [i for i, b in enumerate(s) if b == '1']\n            if ones:\n                i_rem = min(ones, key=lambda i: (values[i] \/ gallons[i], -gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        # construct a minimal feasible baseline\n        feas = ['0'] * n\n        # try best single item that fits\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    # Ruin: flip k bits (biased to 2-3)\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    # Repair to feasibility and then refill greedily\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000461}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict, self-contained evaluator. Feasible solutions return negative revenue (minimize); infeasible return large penalty.\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        n = 24\n        if len(solution) != n or any(c not in '01' for c in solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def value_of(s):\n        return sum(v for b, v in zip(s, values) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Drop by lowest value-per-gallon, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        # Diverse constructive starts: choose among several heuristics\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            # sort by value density desc\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            # sort by value desc\n            key = lambda i: (values[i], -(gallons[i]))\n        else:\n            # randomized greedy with alpha\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        # Greedy fill according to key\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n\n    # Ensure baseline feasibility; if infeasible, repair\n    if weight_of(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of(s)\n    move_choice = random.random()\n\n    if move_choice < 0.4:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.75:\n        # 1-out 1-in exchange preserving feasibility\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                # try multiple scoring rules\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Greedy add or targeted remove to move along tight capacity boundary\n        if used < capacity:\n            room = capacity - used\n            zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if zeros:\n                i_add = max(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_density\")\n        else:\n            # remove worst density to free space\n            ones = [i for i, b in enumerate(s) if b == '1']\n            if ones:\n                i_rem = min(ones, key=lambda i: (values[i] \/ gallons[i], -gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        # construct a minimal feasible baseline\n        feas = ['0'] * n\n        # try best single item that fits\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    # Ruin: flip k bits (biased to 2-3)\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    # Repair to feasibility and then refill greedily\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000287}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9","Evaluacion":"import math\nimport random\nimport re\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: feasible -> negative revenue (for minimization), infeasible -> large positive penalty\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        if not re.fullmatch(r\"[01]{24}\", solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\nimport re\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Remove by lowest density, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            key = lambda i: (values[i], -gallons[i])\n        else:\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n    if weight_of_s(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of_s(s)\n    move_choice = random.random()\n\n    if move_choice < 0.3:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.6:\n        # 1-out 1-in exchange\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    elif move_choice < 0.8:\n        # k-exchange: remove 1 add up to 2 greedily\n        ones = [i for i, b in enumerate(s) if b == '1']\n        zeros = [i for i, b in enumerate(s) if b == '0']\n        if ones:\n            i_out = random.choice(ones)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in zeros if gallons[i] <= room]\n            s2 = s[:]\n            while True:\n                room = capacity - sum(g for j,g in enumerate(gallons) if s2[j]=='1')\n                feas = [i for i in cands if s2[i]=='0' and gallons[i] <= room]\n                if not feas:\n                    break\n                pick = max(feas, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s2[pick] = '1'\n            nb = ''.join(s2)\n        else:\n            nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"k_exchange\", \"1to2\")\n    else:\n        # Burst flips (2..4) with repair\n        r = random.choice([2,3,4])\n        idxs = random.sample(range(n), r)\n        for i in idxs:\n            s[i] = '0' if s[i] == '1' else '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"burst\", \"r_flip_repair\")\n","Perturbacion":"import random\nimport math\nimport re\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of_s(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of_s(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        feas = ['0'] * n\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00001431}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9","Evaluacion":"import math\nimport random\nimport re\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: feasible -> negative revenue (for minimization), infeasible -> large positive penalty\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        if not re.fullmatch(r\"[01]{24}\", solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\nimport re\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Remove by lowest density, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            key = lambda i: (values[i], -gallons[i])\n        else:\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n    if weight_of_s(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of_s(s)\n    move_choice = random.random()\n\n    if move_choice < 0.3:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.6:\n        # 1-out 1-in exchange\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    elif move_choice < 0.8:\n        # k-exchange: remove 1 add up to 2 greedily\n        ones = [i for i, b in enumerate(s) if b == '1']\n        zeros = [i for i, b in enumerate(s) if b == '0']\n        if ones:\n            i_out = random.choice(ones)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in zeros if gallons[i] <= room]\n            s2 = s[:]\n            while True:\n                room = capacity - sum(g for j,g in enumerate(gallons) if s2[j]=='1')\n                feas = [i for i in cands if s2[i]=='0' and gallons[i] <= room]\n                if not feas:\n                    break\n                pick = max(feas, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s2[pick] = '1'\n            nb = ''.join(s2)\n        else:\n            nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"k_exchange\", \"1to2\")\n    else:\n        # Burst flips (2..4) with repair\n        r = random.choice([2,3,4])\n        idxs = random.sample(range(n), r)\n        for i in idxs:\n            s[i] = '0' if s[i] == '1' else '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"burst\", \"r_flip_repair\")\n","Perturbacion":"import random\nimport math\nimport re\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of_s(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of_s(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        feas = ['0'] * n\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000435}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9","Evaluacion":"import math\nimport random\nimport re\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: feasible -> negative revenue (for minimization), infeasible -> large positive penalty\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        if not re.fullmatch(r\"[01]{24}\", solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\nimport re\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Remove by lowest density, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            key = lambda i: (values[i], -gallons[i])\n        else:\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n    if weight_of_s(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of_s(s)\n    move_choice = random.random()\n\n    if move_choice < 0.3:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.6:\n        # 1-out 1-in exchange\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    elif move_choice < 0.8:\n        # k-exchange: remove 1 add up to 2 greedily\n        ones = [i for i, b in enumerate(s) if b == '1']\n        zeros = [i for i, b in enumerate(s) if b == '0']\n        if ones:\n            i_out = random.choice(ones)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in zeros if gallons[i] <= room]\n            s2 = s[:]\n            while True:\n                room = capacity - sum(g for j,g in enumerate(gallons) if s2[j]=='1')\n                feas = [i for i in cands if s2[i]=='0' and gallons[i] <= room]\n                if not feas:\n                    break\n                pick = max(feas, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s2[pick] = '1'\n            nb = ''.join(s2)\n        else:\n            nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"k_exchange\", \"1to2\")\n    else:\n        # Burst flips (2..4) with repair\n        r = random.choice([2,3,4])\n        idxs = random.sample(range(n), r)\n        for i in idxs:\n            s[i] = '0' if s[i] == '1' else '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"burst\", \"r_flip_repair\")\n","Perturbacion":"import random\nimport math\nimport re\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of_s(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of_s(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        feas = ['0'] * n\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000278}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect solution as a binary string of length 24\n    # Returns lesser-is-better fitness: feasible -> negative total score; infeasible -> large penalty\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Basic validation and normalization\n    if isinstance(solution, (list, tuple)):\n        # Convert list\/tuple of 0\/1 to string\n        try:\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        except Exception:\n            return 10**9\n    if not isinstance(solution, str):\n        return 10**9\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        return 10**6 + (total_time - capacity)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # 1-bit flip neighborhood on binary string representation\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return (solution, 'binary', 'noop')\n    idx = random.randrange(n)\n    sol[idx] = 1 - sol[idx]\n    new_solution = ''.join('1' if b else '0' for b in sol)\n    return (new_solution, 'binary', '1-bit-flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flips (k in [2, max(2, n\/\/6)]) for shaking\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = max(2, n \/\/ 6)\n    k = random.randint(k_min, k_max)\n    indices = random.sample(range(n), k=min(k, n))\n    for idx in indices:\n        sol[idx] = 1 - sol[idx]\n    return ''.join('1' if b else '0' for b in sol)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000157499}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect solution as a binary string of length 24\n    # Returns lesser-is-better fitness: feasible -> negative total score; infeasible -> large penalty\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Basic validation and normalization\n    if isinstance(solution, (list, tuple)):\n        # Convert list\/tuple of 0\/1 to string\n        try:\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        except Exception:\n            return 10**9\n    if not isinstance(solution, str):\n        return 10**9\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        return 10**6 + (total_time - capacity)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # 1-bit flip neighborhood on binary string representation\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return (solution, 'binary', 'noop')\n    idx = random.randrange(n)\n    sol[idx] = 1 - sol[idx]\n    new_solution = ''.join('1' if b else '0' for b in sol)\n    return (new_solution, 'binary', '1-bit-flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flips (k in [2, max(2, n\/\/6)]) for shaking\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = max(2, n \/\/ 6)\n    k = random.randint(k_min, k_max)\n    indices = random.sample(range(n), k=min(k, n))\n    for idx in indices:\n        sol[idx] = 1 - sol[idx]\n    return ''.join('1' if b else '0' for b in sol)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0000042}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect solution as a binary string of length 24\n    # Returns lesser-is-better fitness: feasible -> negative total score; infeasible -> large penalty\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Basic validation and normalization\n    if isinstance(solution, (list, tuple)):\n        # Convert list\/tuple of 0\/1 to string\n        try:\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        except Exception:\n            return 10**9\n    if not isinstance(solution, str):\n        return 10**9\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        return 10**6 + (total_time - capacity)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # 1-bit flip neighborhood on binary string representation\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return (solution, 'binary', 'noop')\n    idx = random.randrange(n)\n    sol[idx] = 1 - sol[idx]\n    new_solution = ''.join('1' if b else '0' for b in sol)\n    return (new_solution, 'binary', '1-bit-flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flips (k in [2, max(2, n\/\/6)]) for shaking\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = max(2, n \/\/ 6)\n    k = random.randint(k_min, k_max)\n    indices = random.sample(range(n), k=min(k, n))\n    for idx in indices:\n        sol[idx] = 1 - sol[idx]\n    return ''.join('1' if b else '0' for b in sol)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000027601}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize input to binary string\n    try:\n        if isinstance(solution, (list, tuple)):\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        elif not isinstance(solution, str):\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 10**6 + 1000*overflow\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            # Return original encoding on invalid input; caller should evaluate penalty\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\n# Returns (new_solution, movement_type)\n# NB_Type is the binary-encoded solution string\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n    n = len(bits)\n    if n == 0:\n        return (solution, 'noop')\n\n    move_type = random.random()\n    if move_type < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip')\n    elif move_type < 0.85:\n        # k-bit flip, k in {2,3}\n        k = 2 if random.random() < 0.7 else 3\n        k = min(k, n)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), f'{k}-bit-flip')\n    else:\n        # paired swap: set one 1->0 and one 0->1 when possible\n        ones = [i for i,b in enumerate(bits) if b==1]\n        zeros = [i for i,b in enumerate(bits) if b==0]\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            bits[i1] = 0\n            bits[i0] = 1\n            return (_bits_to_str(bits), 'swap-1-0')\n        # fallback to 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip-fallback')\n","Perturbacion":"import random\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\ndef perturb_solution(solution):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return solution\n    n = len(bits)\n    if n == 0:\n        return solution\n    # Flip between 3 and max(5, n\/\/6) bits to strongly shake the solution\n    k_min, k_max = 3, max(5, n\/\/6)\n    k = random.randint(k_min, min(k_max, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        bits[idx] = 1 - bits[idx]\n    return _bits_to_str(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000151099}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize input to binary string\n    try:\n        if isinstance(solution, (list, tuple)):\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        elif not isinstance(solution, str):\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 10**6 + 1000*overflow\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            # Return original encoding on invalid input; caller should evaluate penalty\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\n# Returns (new_solution, movement_type)\n# NB_Type is the binary-encoded solution string\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n    n = len(bits)\n    if n == 0:\n        return (solution, 'noop')\n\n    move_type = random.random()\n    if move_type < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip')\n    elif move_type < 0.85:\n        # k-bit flip, k in {2,3}\n        k = 2 if random.random() < 0.7 else 3\n        k = min(k, n)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), f'{k}-bit-flip')\n    else:\n        # paired swap: set one 1->0 and one 0->1 when possible\n        ones = [i for i,b in enumerate(bits) if b==1]\n        zeros = [i for i,b in enumerate(bits) if b==0]\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            bits[i1] = 0\n            bits[i0] = 1\n            return (_bits_to_str(bits), 'swap-1-0')\n        # fallback to 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip-fallback')\n","Perturbacion":"import random\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\ndef perturb_solution(solution):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return solution\n    n = len(bits)\n    if n == 0:\n        return solution\n    # Flip between 3 and max(5, n\/\/6) bits to strongly shake the solution\n    k_min, k_max = 3, max(5, n\/\/6)\n    k = random.randint(k_min, min(k_max, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        bits[idx] = 1 - bits[idx]\n    return _bits_to_str(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000433}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize input to binary string\n    try:\n        if isinstance(solution, (list, tuple)):\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        elif not isinstance(solution, str):\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 10**6 + 1000*overflow\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            # Return original encoding on invalid input; caller should evaluate penalty\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\n# Returns (new_solution, movement_type)\n# NB_Type is the binary-encoded solution string\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n    n = len(bits)\n    if n == 0:\n        return (solution, 'noop')\n\n    move_type = random.random()\n    if move_type < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip')\n    elif move_type < 0.85:\n        # k-bit flip, k in {2,3}\n        k = 2 if random.random() < 0.7 else 3\n        k = min(k, n)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), f'{k}-bit-flip')\n    else:\n        # paired swap: set one 1->0 and one 0->1 when possible\n        ones = [i for i,b in enumerate(bits) if b==1]\n        zeros = [i for i,b in enumerate(bits) if b==0]\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            bits[i1] = 0\n            bits[i0] = 1\n            return (_bits_to_str(bits), 'swap-1-0')\n        # fallback to 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip-fallback')\n","Perturbacion":"import random\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\ndef perturb_solution(solution):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return solution\n    n = len(bits)\n    if n == 0:\n        return solution\n    # Flip between 3 and max(5, n\/\/6) bits to strongly shake the solution\n    k_min, k_max = 3, max(5, n\/\/6)\n    k = random.randint(k_min, min(k_max, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        bits[idx] = 1 - bits[idx]\n    return _bits_to_str(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000299}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; bit i (1-indexed) = 1 iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize to 24-bit string\n    try:\n        if isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        elif isinstance(solution, str):\n            bits = solution\n        else:\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = 24\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Moderate penalty to preserve gradient while making infeasible clearly worse\n        return 1e5 + 100*overflow - 0.01*total_value\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        # Ensure feasibility (time <= capacity), then greedily refill by value\/time\n        t, v = totals(b)\n        if t > capacity:\n            # Drop lowest value density items until feasible\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)  # lowest density\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Greedy refill by value density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    # Choose move type\n    r = random.random()\n    move = ''\n    b = bits[:]\n    if r < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip'\n    elif r < 0.85:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip'\n    else:\n        # swap: drop one selected and add one unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            i_drop = min(ones, key=lambda i: values[i]\/times[i])\n            i_add  = max(zeros, key=lambda i: values[i]\/times[i])\n            b[i_drop] = 0\n            b[i_add] = 1\n            move = 'swap-density'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = '1-bit-flip-fallback'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake: drop k lowest-density selected items\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        # choose k in [2..4], but not exceeding number of ones\n        k = min(max(2, 2 + (1 if random.random() < 0.5 else 2)), len(ones))\n        ones_sorted = sorted(ones, key=lambda i: values[i]\/times[i])\n        for i in ones_sorted[:k]:\n            b[i] = 0\n\n    # Random add attempts before repair to diversify\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    for i in zeros[:min(5, len(zeros))]:\n        b[i] = 1 - b[i]\n\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000146701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; bit i (1-indexed) = 1 iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize to 24-bit string\n    try:\n        if isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        elif isinstance(solution, str):\n            bits = solution\n        else:\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = 24\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Moderate penalty to preserve gradient while making infeasible clearly worse\n        return 1e5 + 100*overflow - 0.01*total_value\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        # Ensure feasibility (time <= capacity), then greedily refill by value\/time\n        t, v = totals(b)\n        if t > capacity:\n            # Drop lowest value density items until feasible\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)  # lowest density\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Greedy refill by value density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    # Choose move type\n    r = random.random()\n    move = ''\n    b = bits[:]\n    if r < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip'\n    elif r < 0.85:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip'\n    else:\n        # swap: drop one selected and add one unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            i_drop = min(ones, key=lambda i: values[i]\/times[i])\n            i_add  = max(zeros, key=lambda i: values[i]\/times[i])\n            b[i_drop] = 0\n            b[i_add] = 1\n            move = 'swap-density'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = '1-bit-flip-fallback'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake: drop k lowest-density selected items\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        # choose k in [2..4], but not exceeding number of ones\n        k = min(max(2, 2 + (1 if random.random() < 0.5 else 2)), len(ones))\n        ones_sorted = sorted(ones, key=lambda i: values[i]\/times[i])\n        for i in ones_sorted[:k]:\n            b[i] = 0\n\n    # Random add attempts before repair to diversify\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    for i in zeros[:min(5, len(zeros))]:\n        b[i] = 1 - b[i]\n\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000458}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; bit i (1-indexed) = 1 iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize to 24-bit string\n    try:\n        if isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        elif isinstance(solution, str):\n            bits = solution\n        else:\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = 24\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Moderate penalty to preserve gradient while making infeasible clearly worse\n        return 1e5 + 100*overflow - 0.01*total_value\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        # Ensure feasibility (time <= capacity), then greedily refill by value\/time\n        t, v = totals(b)\n        if t > capacity:\n            # Drop lowest value density items until feasible\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)  # lowest density\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Greedy refill by value density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    # Choose move type\n    r = random.random()\n    move = ''\n    b = bits[:]\n    if r < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip'\n    elif r < 0.85:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip'\n    else:\n        # swap: drop one selected and add one unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            i_drop = min(ones, key=lambda i: values[i]\/times[i])\n            i_add  = max(zeros, key=lambda i: values[i]\/times[i])\n            b[i_drop] = 0\n            b[i_add] = 1\n            move = 'swap-density'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = '1-bit-flip-fallback'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake: drop k lowest-density selected items\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        # choose k in [2..4], but not exceeding number of ones\n        k = min(max(2, 2 + (1 if random.random() < 0.5 else 2)), len(ones))\n        ones_sorted = sorted(ones, key=lambda i: values[i]\/times[i])\n        for i in ones_sorted[:k]:\n            b[i] = 0\n\n    # Random add attempts before repair to diversify\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    for i in zeros[:min(5, len(zeros))]:\n        b[i] = 1 - b[i]\n\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000031299}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"24-bit binary string; bit i (1-indexed) = 1 iff attraction i is selected.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Normalize input to bitstring\n    try:\n        if isinstance(solution, str):\n            bits = solution\n        elif isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        else:\n            return 10**12\n    except Exception:\n        return 10**12\n\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**12\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Feasibility-first: any infeasible solution is worse than any feasible\n        # Encode as large base + scaled overflow - small value term to break ties\n        return 1_000_000_000 + overflow * 1_000 - 0.001 * total_value\n\n    # Maximization -> return negative value for minimization-based heuristics\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by value density with random tie-breaking\n        t, v = totals(b)\n        if t > capacity:\n            # Remove lowest density items until feasible\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                # Randomized tie-break: shuffle equal densities implicitly by jitter\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Refill greedily by density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    b = bits[:]\n    move = ''\n\n    # Move selection with targeted exchanges for tight capacity\n    r = random.random()\n    if r < 0.40:\n        # 1-bit flip then repair\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip+repair'\n    elif r < 0.75:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip+repair'\n    elif r < 0.90:\n        # 1-1 exchange: drop lowest-density selected, add highest-density unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            b[drop] = 0\n            b[add] = 1\n            move = '1-1-density-swap+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n    else:\n        # 1-2 or 2-1 exchange guided by density\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and len(zeros) >= 2 and random.random() < 0.5:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add_candidates = sorted(zeros, key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)[:2]\n            b[drop] = 0\n            for j in add_candidates:\n                b[j] = 1\n            move = '1-2-exchange+repair'\n        elif len(ones) >= 2 and zeros:\n            drop_candidates = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))[:2]\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            for j in drop_candidates:\n                b[j] = 0\n            b[add] = 1\n            move = '2-1-exchange+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by density with slight randomness\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake:\n    # 1) Drop r items with lowest density among selected (r in [2,4])\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        r = min(len(ones), random.randint(2, 4))\n        ones_sorted = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n        for i in ones_sorted[:r]:\n            b[i] = 0\n    # 2) Flip up to q random zeros to ones to diversify (q in [2,5])\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    q = min(len(zeros), random.randint(2, 5))\n    for i in zeros[:q]:\n        b[i] = 1\n\n    # 3) Repair to feasibility and greedily refill\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00001354}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"24-bit binary string; bit i (1-indexed) = 1 iff attraction i is selected.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Normalize input to bitstring\n    try:\n        if isinstance(solution, str):\n            bits = solution\n        elif isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        else:\n            return 10**12\n    except Exception:\n        return 10**12\n\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**12\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Feasibility-first: any infeasible solution is worse than any feasible\n        # Encode as large base + scaled overflow - small value term to break ties\n        return 1_000_000_000 + overflow * 1_000 - 0.001 * total_value\n\n    # Maximization -> return negative value for minimization-based heuristics\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by value density with random tie-breaking\n        t, v = totals(b)\n        if t > capacity:\n            # Remove lowest density items until feasible\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                # Randomized tie-break: shuffle equal densities implicitly by jitter\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Refill greedily by density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    b = bits[:]\n    move = ''\n\n    # Move selection with targeted exchanges for tight capacity\n    r = random.random()\n    if r < 0.40:\n        # 1-bit flip then repair\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip+repair'\n    elif r < 0.75:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip+repair'\n    elif r < 0.90:\n        # 1-1 exchange: drop lowest-density selected, add highest-density unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            b[drop] = 0\n            b[add] = 1\n            move = '1-1-density-swap+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n    else:\n        # 1-2 or 2-1 exchange guided by density\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and len(zeros) >= 2 and random.random() < 0.5:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add_candidates = sorted(zeros, key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)[:2]\n            b[drop] = 0\n            for j in add_candidates:\n                b[j] = 1\n            move = '1-2-exchange+repair'\n        elif len(ones) >= 2 and zeros:\n            drop_candidates = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))[:2]\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            for j in drop_candidates:\n                b[j] = 0\n            b[add] = 1\n            move = '2-1-exchange+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by density with slight randomness\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake:\n    # 1) Drop r items with lowest density among selected (r in [2,4])\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        r = min(len(ones), random.randint(2, 4))\n        ones_sorted = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n        for i in ones_sorted[:r]:\n            b[i] = 0\n    # 2) Flip up to q random zeros to ones to diversify (q in [2,5])\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    q = min(len(zeros), random.randint(2, 5))\n    for i in zeros[:q]:\n        b[i] = 1\n\n    # 3) Repair to feasibility and greedily refill\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000419}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"24-bit binary string; bit i (1-indexed) = 1 iff attraction i is selected.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Normalize input to bitstring\n    try:\n        if isinstance(solution, str):\n            bits = solution\n        elif isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        else:\n            return 10**12\n    except Exception:\n        return 10**12\n\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**12\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Feasibility-first: any infeasible solution is worse than any feasible\n        # Encode as large base + scaled overflow - small value term to break ties\n        return 1_000_000_000 + overflow * 1_000 - 0.001 * total_value\n\n    # Maximization -> return negative value for minimization-based heuristics\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by value density with random tie-breaking\n        t, v = totals(b)\n        if t > capacity:\n            # Remove lowest density items until feasible\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                # Randomized tie-break: shuffle equal densities implicitly by jitter\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Refill greedily by density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    b = bits[:]\n    move = ''\n\n    # Move selection with targeted exchanges for tight capacity\n    r = random.random()\n    if r < 0.40:\n        # 1-bit flip then repair\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip+repair'\n    elif r < 0.75:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip+repair'\n    elif r < 0.90:\n        # 1-1 exchange: drop lowest-density selected, add highest-density unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            b[drop] = 0\n            b[add] = 1\n            move = '1-1-density-swap+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n    else:\n        # 1-2 or 2-1 exchange guided by density\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and len(zeros) >= 2 and random.random() < 0.5:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add_candidates = sorted(zeros, key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)[:2]\n            b[drop] = 0\n            for j in add_candidates:\n                b[j] = 1\n            move = '1-2-exchange+repair'\n        elif len(ones) >= 2 and zeros:\n            drop_candidates = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))[:2]\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            for j in drop_candidates:\n                b[j] = 0\n            b[add] = 1\n            move = '2-1-exchange+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by density with slight randomness\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake:\n    # 1) Drop r items with lowest density among selected (r in [2,4])\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        r = min(len(ones), random.randint(2, 4))\n        ones_sorted = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n        for i in ones_sorted[:r]:\n            b[i] = 0\n    # 2) Flip up to q random zeros to ones to diversify (q in [2,5])\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    q = min(len(zeros), random.randint(2, 5))\n    for i in zeros[:q]:\n        b[i] = 1\n\n    # 3) Repair to feasibility and greedily refill\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000289}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated list of selected item indices in ascending order (e.g., \"1,2,5\").","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Parse representation: comma-separated indices\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            chosen = set()\n        else:\n            chosen = set(int(x) for x in s.split(\",\") if x.strip())\n    elif isinstance(solution, (list, set, tuple)):\n        chosen = set(int(x) for x in solution)\n    else:\n        # Unsupported type -> heavy penalty\n        return 10**12\n    # Problem data (1-indexed)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(weights)\n    # Sanitize chosen to valid range\n    chosen = {i for i in chosen if 1 <= i <= n}\n    total_w = 0\n    total_v = 0\n    for i in chosen:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    # Minimization: lesser is better. Enforce weight >= 275 via penalty.\n    capacity = 275\n    if total_w >= capacity:\n        return float(total_v)\n    # Linear penalty scaled to deficit\n    deficit = capacity - total_w\n    return float(10**6 * deficit + total_v)\n","Vecindad":"import random\n\n# Returns: (new_solution_repr, NB_Type, Movement_Type)\n# NB_Type: 'stochastic-local'\n# Movement_Type: 'flip-or-swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(weights)\n    current_set = set(i for i in current if 1 <= i <= n)\n    move_type = random.choice([\"flip\", \"swap\"]) if len(current_set) >= 1 else \"flip\"\n    if move_type == \"flip\":\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    else:  # swap: drop one (if any) and add one not in set\n        if current_set:\n            drop = random.choice(tuple(current_set))\n            current_set.remove(drop)\n        # ensure we add something (may re-add same index)\n        add = random.randint(1, n)\n        current_set.add(add)\n    new_list = sorted(current_set)\n    new_repr = \",\".join(str(x) for x in new_list)\n    return new_repr, \"stochastic-local\", \"flip-or-swap\"\n","Perturbacion":"import random\n\n# Strong perturbation for escaping local minima\n\ndef perturb_solution(solution):\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    n = 24\n    current_set = set(i for i in current if 1 <= i <= n)\n    # Apply k random flips; k sampled from 3..6\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    # Optional bias: if underweight, add random items until near-feasible\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 275\n    # Quick greedy add to push toward feasibility\n    def total_w(S):\n        return sum(weights[i-1] for i in S)\n    if total_w(current_set) < capacity:\n        # sort items not in set by weight descending to reach capacity faster\n        candidates = sorted([i for i in range(1, n+1) if i not in current_set], key=lambda i: weights[i-1], reverse=True)\n        for i in candidates:\n            if total_w(current_set) >= capacity:\n                break\n            current_set.add(i)\n    new_list = sorted(current_set)\n    return \",\".join(str(x) for x in new_list)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0006129369}
