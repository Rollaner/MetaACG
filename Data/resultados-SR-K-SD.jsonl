{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24. Index i (1-based) corresponds to Decoration i. Character '1' means selected, '0' means not selected. Example: '101...'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs: List[int] = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values: List[int] = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget: int = 3040\n\n    # Decode solution\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(c not in '01' for c in solution):\n        return float('inf')  # Invalid encoding -> worst\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better. Feasible -> negative value; Infeasible -> large positive penalty\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1e9 + over","Vecindad":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef generate_neighbour(solution: str) -> Tuple[str, str]:\n    # Returns (neighbor_solution_encoded_as_BIN_STR, Movement_Type)\n    if not isinstance(solution, str) or len(solution) == 0:\n        # Fallback to a single '0' if invalid\n        return ('0', 'single_bit_flip')\n    n = len(solution)\n    idx = random.randrange(n)\n    neighbor = _flip_bit(solution, idx)\n    return (neighbor, 'single_bit_flip')","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-bit random flips (k ~ Uniform[2, max(2, n\/\/6)]) for diversification\n    if not isinstance(solution, str) or len(solution) == 0:\n        return '0'\n    n = len(solution)\n    k = max(2, n \/\/ 6)\n    k = random.randint(2, k)\n    idxs = random.sample(range(n), k=min(k, n))\n    sol_list: List[str] = list(solution)\n    for i in idxs:\n        sol_list[i] = '0' if sol_list[i] == '1' else '1'\n    return ''.join(sol_list)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0004012049}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24. Index i (1-based) corresponds to Decoration i. Character '1' means selected, '0' means not selected. Example: '101...'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs: List[int] = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values: List[int] = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget: int = 3040\n\n    # Decode solution\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(c not in '01' for c in solution):\n        return float('inf')  # Invalid encoding -> worst\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better. Feasible -> negative value; Infeasible -> large positive penalty\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1e9 + over","Vecindad":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef generate_neighbour(solution: str) -> Tuple[str, str]:\n    # Returns (neighbor_solution_encoded_as_BIN_STR, Movement_Type)\n    if not isinstance(solution, str) or len(solution) == 0:\n        # Fallback to a single '0' if invalid\n        return ('0', 'single_bit_flip')\n    n = len(solution)\n    idx = random.randrange(n)\n    neighbor = _flip_bit(solution, idx)\n    return (neighbor, 'single_bit_flip')","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-bit random flips (k ~ Uniform[2, max(2, n\/\/6)]) for diversification\n    if not isinstance(solution, str) or len(solution) == 0:\n        return '0'\n    n = len(solution)\n    k = max(2, n \/\/ 6)\n    k = random.randint(2, k)\n    idxs = random.sample(range(n), k=min(k, n))\n    sol_list: List[str] = list(solution)\n    for i in idxs:\n        sol_list[i] = '0' if sol_list[i] == '1' else '1'\n    return ''.join(sol_list)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000369354}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24. Index i (1-based) corresponds to Decoration i. Character '1' means selected, '0' means not selected. Example: '101...'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs: List[int] = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values: List[int] = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget: int = 3040\n\n    # Decode solution\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(c not in '01' for c in solution):\n        return float('inf')  # Invalid encoding -> worst\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better. Feasible -> negative value; Infeasible -> large positive penalty\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1e9 + over","Vecindad":"import random\nfrom typing import Tuple\n\ndef _flip_bit(s: str, idx: int) -> str:\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef generate_neighbour(solution: str) -> Tuple[str, str]:\n    # Returns (neighbor_solution_encoded_as_BIN_STR, Movement_Type)\n    if not isinstance(solution, str) or len(solution) == 0:\n        # Fallback to a single '0' if invalid\n        return ('0', 'single_bit_flip')\n    n = len(solution)\n    idx = random.randrange(n)\n    neighbor = _flip_bit(solution, idx)\n    return (neighbor, 'single_bit_flip')","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-bit random flips (k ~ Uniform[2, max(2, n\/\/6)]) for diversification\n    if not isinstance(solution, str) or len(solution) == 0:\n        return '0'\n    n = len(solution)\n    k = max(2, n \/\/ 6)\n    k = random.randint(2, k)\n    idxs = random.sample(range(n), k=min(k, n))\n    sol_list: List[str] = list(solution)\n    for i in idxs:\n        sol_list[i] = '0' if sol_list[i] == '1' else '1'\n    return ''.join(sol_list)","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000363895}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24; index i (1-based) corresponds to Decoration i; '1' means selected, '0' means not selected.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better.\n    # Feasible: negative of total value.\n    # Infeasible: dynamic penalty preferring lower overage and higher value.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Dynamic penalty: base + scaled overage - tiny value term to softly rank among infeasible\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\n\n# Helper ops kept local to avoid globals\n\ndef _flip_bit(s, idx):\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef _ensure_len_or_zeroes(s, n):\n    if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n        return '0' * n\n    return s\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    move_types = ['single_flip', 'double_flip', 'triple_flip', 'swap_1in1out', 'biased_flip']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'triple_flip':\n        k = 3 if n >= 3 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'triple_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            # Fallback to single\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        i_out = random.choice(ones)\n        i_in = random.choice(zeros)\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    # biased_flip\n    ratios = [(values[i] \/ float(costs[i]), i) for i in range(n)]\n    ratios.sort(reverse=True)\n    # Choose better ratio index to add, worse ratio index to drop\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    nb = s\n    performed = False\n    if zeros:\n        # bias toward top quartile of ratios among zeros\n        zero_ratios = [(values[i] \/ float(costs[i]), i) for i in zeros]\n        zero_ratios.sort(reverse=True)\n        k = max(1, len(zero_ratios)\/\/4)\n        idx_in = random.choice([i for _, i in zero_ratios[:k]])\n        nb = _flip_bit(nb, idx_in)\n        performed = True\n    if ones:\n        one_ratios = [(values[i] \/ float(costs[i]), i) for i in ones]\n        one_ratios.sort()  # drop worst\n        k = max(1, len(one_ratios)\/\/4)\n        idx_out = random.choice([i for _, i in one_ratios[:k]])\n        nb = _flip_bit(nb, idx_out)\n        performed = True\n    if not performed:\n        idx = random.randrange(n)\n        nb = _flip_bit(nb, idx)\n    return (nb, 'biased_flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    # Validate \/ normalize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        s = '0' * n\n    else:\n        s = solution\n\n    # Step 1: random multi-bit flips (3-6 or up to n)\n    if n > 0:\n        k = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), k)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helper to compute cost\/value quickly\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair feasibility if over budget by dropping worst value-to-cost items first\n    tc, tv = cv(s)\n    if tc > budget:\n        indices = [i for i, ch in enumerate(s) if ch == '1']\n        # sort by ascending value density and higher cost tie-break to shed costly low value\n        indices.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in indices:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy add best ratio items while remaining under budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i] \/ float(costs[i])), costs[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: _flip_bit() missing 1 required positional argument: 'idx'.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000930871}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24; index i (1-based) corresponds to Decoration i; '1' means selected, '0' means not selected.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better.\n    # Feasible: negative of total value.\n    # Infeasible: dynamic penalty preferring lower overage and higher value.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Dynamic penalty: base + scaled overage - tiny value term to softly rank among infeasible\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\n\n# Helper ops kept local to avoid globals\n\ndef _flip_bit(s, idx):\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef _ensure_len_or_zeroes(s, n):\n    if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n        return '0' * n\n    return s\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    move_types = ['single_flip', 'double_flip', 'triple_flip', 'swap_1in1out', 'biased_flip']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'triple_flip':\n        k = 3 if n >= 3 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'triple_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            # Fallback to single\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        i_out = random.choice(ones)\n        i_in = random.choice(zeros)\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    # biased_flip\n    ratios = [(values[i] \/ float(costs[i]), i) for i in range(n)]\n    ratios.sort(reverse=True)\n    # Choose better ratio index to add, worse ratio index to drop\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    nb = s\n    performed = False\n    if zeros:\n        # bias toward top quartile of ratios among zeros\n        zero_ratios = [(values[i] \/ float(costs[i]), i) for i in zeros]\n        zero_ratios.sort(reverse=True)\n        k = max(1, len(zero_ratios)\/\/4)\n        idx_in = random.choice([i for _, i in zero_ratios[:k]])\n        nb = _flip_bit(nb, idx_in)\n        performed = True\n    if ones:\n        one_ratios = [(values[i] \/ float(costs[i]), i) for i in ones]\n        one_ratios.sort()  # drop worst\n        k = max(1, len(one_ratios)\/\/4)\n        idx_out = random.choice([i for _, i in one_ratios[:k]])\n        nb = _flip_bit(nb, idx_out)\n        performed = True\n    if not performed:\n        idx = random.randrange(n)\n        nb = _flip_bit(nb, idx)\n    return (nb, 'biased_flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    # Validate \/ normalize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        s = '0' * n\n    else:\n        s = solution\n\n    # Step 1: random multi-bit flips (3-6 or up to n)\n    if n > 0:\n        k = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), k)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helper to compute cost\/value quickly\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair feasibility if over budget by dropping worst value-to-cost items first\n    tc, tv = cv(s)\n    if tc > budget:\n        indices = [i for i, ch in enumerate(s) if ch == '1']\n        # sort by ascending value density and higher cost tie-break to shed costly low value\n        indices.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in indices:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy add best ratio items while remaining under budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i] \/ float(costs[i])), costs[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: _flip_bit() missing 1 required positional argument: 'idx'.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000967252}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR length=24; index i (1-based) corresponds to Decoration i; '1' means selected, '0' means not selected.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better.\n    # Feasible: negative of total value.\n    # Infeasible: dynamic penalty preferring lower overage and higher value.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Dynamic penalty: base + scaled overage - tiny value term to softly rank among infeasible\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\n\n# Helper ops kept local to avoid globals\n\ndef _flip_bit(s, idx):\n    return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\ndef _ensure_len_or_zeroes(s, n):\n    if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n        return '0' * n\n    return s\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    move_types = ['single_flip', 'double_flip', 'triple_flip', 'swap_1in1out', 'biased_flip']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'triple_flip':\n        k = 3 if n >= 3 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'triple_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            # Fallback to single\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        i_out = random.choice(ones)\n        i_in = random.choice(zeros)\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    # biased_flip\n    ratios = [(values[i] \/ float(costs[i]), i) for i in range(n)]\n    ratios.sort(reverse=True)\n    # Choose better ratio index to add, worse ratio index to drop\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    nb = s\n    performed = False\n    if zeros:\n        # bias toward top quartile of ratios among zeros\n        zero_ratios = [(values[i] \/ float(costs[i]), i) for i in zeros]\n        zero_ratios.sort(reverse=True)\n        k = max(1, len(zero_ratios)\/\/4)\n        idx_in = random.choice([i for _, i in zero_ratios[:k]])\n        nb = _flip_bit(nb, idx_in)\n        performed = True\n    if ones:\n        one_ratios = [(values[i] \/ float(costs[i]), i) for i in ones]\n        one_ratios.sort()  # drop worst\n        k = max(1, len(one_ratios)\/\/4)\n        idx_out = random.choice([i for _, i in one_ratios[:k]])\n        nb = _flip_bit(nb, idx_out)\n        performed = True\n    if not performed:\n        idx = random.randrange(n)\n        nb = _flip_bit(nb, idx)\n    return (nb, 'biased_flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    # Validate \/ normalize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        s = '0' * n\n    else:\n        s = solution\n\n    # Step 1: random multi-bit flips (3-6 or up to n)\n    if n > 0:\n        k = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), k)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helper to compute cost\/value quickly\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair feasibility if over budget by dropping worst value-to-cost items first\n    tc, tv = cv(s)\n    if tc > budget:\n        indices = [i for i, ch in enumerate(s) if ch == '1']\n        # sort by ascending value density and higher cost tie-break to shed costly low value\n        indices.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in indices:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy add best ratio items while remaining under budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i] \/ float(costs[i])), costs[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: _flip_bit() missing 1 required positional argument: 'idx'.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000961472}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n\n    def _ensure_len_or_zeroes(s, n):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s, idx):\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    # Move set\n    move_types = ['single_flip', 'double_flip', 'swap_1in1out', 'biased_flip', 'two_for_one']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        # Prefer adding high density and removing low density\n        one_ratios = sorted([(values[i]\/float(costs[i]), i) for i in ones])\n        zero_ratios = sorted([(values[i]\/float(costs[i]), i) for i in zeros], reverse=True)\n        i_out = random.choice([i for _, i in one_ratios[:max(1,len(one_ratios)\/\/3)]])\n        i_in  = random.choice([i for _, i in zero_ratios[:max(1,len(zero_ratios)\/\/3)]])\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    if move == 'biased_flip':\n        # epsilon-greedy density bias\n        eps = 0.1\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones  = [i for i,ch in enumerate(s) if ch == '1']\n        nb = s\n        if zeros:\n            if random.random() < eps:\n                i_in = random.choice(zeros)\n            else:\n                zeros_sorted = sorted(zeros, key=lambda i: (values[i]\/float(costs[i]), values[i]), reverse=True)\n                i_in = zeros_sorted[0]\n            nb = _flip_bit(nb, i_in)\n        if ones:\n            if random.random() < eps:\n                i_out = random.choice(ones)\n            else:\n                ones_sorted = sorted(ones, key=lambda i: (values[i]\/float(costs[i]), values[i]))\n                i_out = ones_sorted[0]\n            nb = _flip_bit(nb, i_out)\n        return (nb, 'biased_flip')\n\n    # two_for_one exchange: try toggling 3 indices with 2 out and 1 in (or vice versa)\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        out_idxs = random.sample(ones, 2)\n        in_idx = random.choice(zeros)\n        nb_list = list(s)\n        for i in out_idxs:\n            nb_list[i] = '0'\n        nb_list[in_idx] = '1'\n        return (''.join(nb_list), 'two_for_one')\n    # fallback\n    idx = random.randrange(n)\n    nb = _flip_bit(s, idx)\n    return (nb, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _validate(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    s = _validate(solution)\n\n    # Step 1: random multi-bit flips (r in [3,6])\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helpers\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair if over budget by dropping worst density items first\n    tc, tv = cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i]\/float(costs[i]), -costs[i]))  # ascending density, then higher cost\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i]\/float(costs[i])), -values[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["001000100000011110100100",-115.0,"001000100000011110100100",-124.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001476318}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n\n    def _ensure_len_or_zeroes(s, n):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s, idx):\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    # Move set\n    move_types = ['single_flip', 'double_flip', 'swap_1in1out', 'biased_flip', 'two_for_one']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        # Prefer adding high density and removing low density\n        one_ratios = sorted([(values[i]\/float(costs[i]), i) for i in ones])\n        zero_ratios = sorted([(values[i]\/float(costs[i]), i) for i in zeros], reverse=True)\n        i_out = random.choice([i for _, i in one_ratios[:max(1,len(one_ratios)\/\/3)]])\n        i_in  = random.choice([i for _, i in zero_ratios[:max(1,len(zero_ratios)\/\/3)]])\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    if move == 'biased_flip':\n        # epsilon-greedy density bias\n        eps = 0.1\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones  = [i for i,ch in enumerate(s) if ch == '1']\n        nb = s\n        if zeros:\n            if random.random() < eps:\n                i_in = random.choice(zeros)\n            else:\n                zeros_sorted = sorted(zeros, key=lambda i: (values[i]\/float(costs[i]), values[i]), reverse=True)\n                i_in = zeros_sorted[0]\n            nb = _flip_bit(nb, i_in)\n        if ones:\n            if random.random() < eps:\n                i_out = random.choice(ones)\n            else:\n                ones_sorted = sorted(ones, key=lambda i: (values[i]\/float(costs[i]), values[i]))\n                i_out = ones_sorted[0]\n            nb = _flip_bit(nb, i_out)\n        return (nb, 'biased_flip')\n\n    # two_for_one exchange: try toggling 3 indices with 2 out and 1 in (or vice versa)\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        out_idxs = random.sample(ones, 2)\n        in_idx = random.choice(zeros)\n        nb_list = list(s)\n        for i in out_idxs:\n            nb_list[i] = '0'\n        nb_list[in_idx] = '1'\n        return (''.join(nb_list), 'two_for_one')\n    # fallback\n    idx = random.randrange(n)\n    nb = _flip_bit(s, idx)\n    return (nb, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _validate(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    s = _validate(solution)\n\n    # Step 1: random multi-bit flips (r in [3,6])\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helpers\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair if over budget by dropping worst density items first\n    tc, tv = cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i]\/float(costs[i]), -costs[i]))  # ascending density, then higher cost\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i]\/float(costs[i])), -values[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["111001110111011111110111",-13.0,"111101110111011111111101",-268.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0019737439}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    return 1_000_000.0 + 1000.0 * over - 0.001 * total_value\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data for biased moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = len(costs)\n\n    def _ensure_len_or_zeroes(s, n):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s, idx):\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    s = _ensure_len_or_zeroes(solution, n)\n    if n == 0:\n        return (s, 'noop')\n\n    # Move set\n    move_types = ['single_flip', 'double_flip', 'swap_1in1out', 'biased_flip', 'two_for_one']\n    move = random.choice(move_types)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        nb = _flip_bit(s, idx)\n        return (nb, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        nb = s\n        for i in idxs:\n            nb = _flip_bit(nb, i)\n        return (nb, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            nb = _flip_bit(s, idx)\n            return (nb, 'single_flip_fallback')\n        # Prefer adding high density and removing low density\n        one_ratios = sorted([(values[i]\/float(costs[i]), i) for i in ones])\n        zero_ratios = sorted([(values[i]\/float(costs[i]), i) for i in zeros], reverse=True)\n        i_out = random.choice([i for _, i in one_ratios[:max(1,len(one_ratios)\/\/3)]])\n        i_in  = random.choice([i for _, i in zero_ratios[:max(1,len(zero_ratios)\/\/3)]])\n        nb_list = list(s)\n        nb_list[i_out] = '0'\n        nb_list[i_in] = '1'\n        return (''.join(nb_list), 'swap_1in1out')\n\n    if move == 'biased_flip':\n        # epsilon-greedy density bias\n        eps = 0.1\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones  = [i for i,ch in enumerate(s) if ch == '1']\n        nb = s\n        if zeros:\n            if random.random() < eps:\n                i_in = random.choice(zeros)\n            else:\n                zeros_sorted = sorted(zeros, key=lambda i: (values[i]\/float(costs[i]), values[i]), reverse=True)\n                i_in = zeros_sorted[0]\n            nb = _flip_bit(nb, i_in)\n        if ones:\n            if random.random() < eps:\n                i_out = random.choice(ones)\n            else:\n                ones_sorted = sorted(ones, key=lambda i: (values[i]\/float(costs[i]), values[i]))\n                i_out = ones_sorted[0]\n            nb = _flip_bit(nb, i_out)\n        return (nb, 'biased_flip')\n\n    # two_for_one exchange: try toggling 3 indices with 2 out and 1 in (or vice versa)\n    ones = [i for i,ch in enumerate(s) if ch == '1']\n    zeros = [i for i,ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        out_idxs = random.sample(ones, 2)\n        in_idx = random.choice(zeros)\n        nb_list = list(s)\n        for i in out_idxs:\n            nb_list[i] = '0'\n        nb_list[in_idx] = '1'\n        return (''.join(nb_list), 'two_for_one')\n    # fallback\n    idx = random.randrange(n)\n    nb = _flip_bit(s, idx)\n    return (nb, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _validate(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    s = _validate(solution)\n\n    # Step 1: random multi-bit flips (r in [3,6])\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Helpers\n    def cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    # Step 2: repair if over budget by dropping worst density items first\n    tc, tv = cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i]\/float(costs[i]), -costs[i]))  # ascending density, then higher cost\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n                tv -= values[i]\n        s = ''.join(s_list)\n        tc, tv = cv(s)\n\n    # Step 3: greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (-(values[i]\/float(costs[i])), -values[i]))\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n            tv += values[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001194965}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better; maximize value under budget\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Quadratic penalty for infeasibility\n    over = float(total_cost - budget)\n    rho = 100.0\n    return rho * (over * over) - 0.001 * float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid_or_zeroes(s: str) -> str:\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    def _cost_value(s: str):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(s):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    def _repair_feasible(s: str) -> str:\n        tc, tv = _cost_value(s)\n        if tc <= budget:\n            return s\n        # Drop lowest density items until feasible\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        return ''.join(s_list)\n\n    s = _valid_or_zeroes(solution)\n    tc, tv = _cost_value(s)\n\n    # Move set with feasibility awareness\n    moves = ['single_flip', 'swap_1in1out', 'double_flip', 'biased_add_or_swap', 'two_for_one']\n    move = random.choice(moves)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        cand = _flip_bit(s, idx)\n        cand = _repair_feasible(cand)\n        return (cand, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        cand = s\n        for i in idxs:\n            cand = _flip_bit(cand, i)\n        cand = _repair_feasible(cand)\n        return (cand, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            cand = _flip_bit(s, idx)\n            cand = _repair_feasible(cand)\n            return (cand, 'swap_fallback')\n        # Remove worst density, add best density\n        i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n        i_in = zeros_sorted[0]\n        cand_list = list(s)\n        cand_list[i_out] = '0'\n        cand_list[i_in] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'swap_1in1out')\n\n    if move == 'biased_add_or_swap':\n        # Prefer adding high-density item if budget allows; else drop worst then add best\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        cand = s\n        if zeros:\n            zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n            for i_in in zeros_sorted[:min(5, len(zeros_sorted))]:\n                if tc + costs[i_in] <= budget:\n                    cand = _flip_bit(cand, i_in)\n                    break\n            else:\n                if ones:\n                    i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n                    cand_list = list(cand)\n                    cand_list[i_out] = '0'\n                    cand_list[zeros_sorted[0]] = '1'\n                    cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'biased_add_or_swap')\n\n    # two_for_one: drop two worst, add one best\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        worst_two = sorted(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))[:2]\n        best_zero = max(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]))\n        cand_list = list(s)\n        for i in worst_two:\n            cand_list[i] = '0'\n        cand_list[best_zero] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'two_for_one')\n\n    # Fallback single flip\n    idx = random.randrange(n)\n    cand = _flip_bit(s, idx)\n    cand = _repair_feasible(cand)\n    return (cand, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    s = _valid(solution)\n\n    # Random multi-bit flips\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Repair if over budget: drop lowest density items first\n    tc, tv = _cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        s = ''.join(s_list)\n        tc, tv = _cv(s)\n\n    # Greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["100100000100001110000100",-93.0,"100100000100001110100100",-123.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0017350321}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better; maximize value under budget\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Quadratic penalty for infeasibility\n    over = float(total_cost - budget)\n    rho = 100.0\n    return rho * (over * over) - 0.001 * float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid_or_zeroes(s: str) -> str:\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    def _cost_value(s: str):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(s):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    def _repair_feasible(s: str) -> str:\n        tc, tv = _cost_value(s)\n        if tc <= budget:\n            return s\n        # Drop lowest density items until feasible\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        return ''.join(s_list)\n\n    s = _valid_or_zeroes(solution)\n    tc, tv = _cost_value(s)\n\n    # Move set with feasibility awareness\n    moves = ['single_flip', 'swap_1in1out', 'double_flip', 'biased_add_or_swap', 'two_for_one']\n    move = random.choice(moves)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        cand = _flip_bit(s, idx)\n        cand = _repair_feasible(cand)\n        return (cand, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        cand = s\n        for i in idxs:\n            cand = _flip_bit(cand, i)\n        cand = _repair_feasible(cand)\n        return (cand, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            cand = _flip_bit(s, idx)\n            cand = _repair_feasible(cand)\n            return (cand, 'swap_fallback')\n        # Remove worst density, add best density\n        i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n        i_in = zeros_sorted[0]\n        cand_list = list(s)\n        cand_list[i_out] = '0'\n        cand_list[i_in] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'swap_1in1out')\n\n    if move == 'biased_add_or_swap':\n        # Prefer adding high-density item if budget allows; else drop worst then add best\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        cand = s\n        if zeros:\n            zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n            for i_in in zeros_sorted[:min(5, len(zeros_sorted))]:\n                if tc + costs[i_in] <= budget:\n                    cand = _flip_bit(cand, i_in)\n                    break\n            else:\n                if ones:\n                    i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n                    cand_list = list(cand)\n                    cand_list[i_out] = '0'\n                    cand_list[zeros_sorted[0]] = '1'\n                    cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'biased_add_or_swap')\n\n    # two_for_one: drop two worst, add one best\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        worst_two = sorted(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))[:2]\n        best_zero = max(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]))\n        cand_list = list(s)\n        for i in worst_two:\n            cand_list[i] = '0'\n        cand_list[best_zero] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'two_for_one')\n\n    # Fallback single flip\n    idx = random.randrange(n)\n    cand = _flip_bit(s, idx)\n    cand = _repair_feasible(cand)\n    return (cand, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    s = _valid(solution)\n\n    # Random multi-bit flips\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Repair if over budget: drop lowest density items first\n    tc, tv = _cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        s = ''.join(s_list)\n        tc, tv = _cv(s)\n\n    # Greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":["111101110111011111110101",-24.0,"111101110111011111110111",-268.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.002589792}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n\n    # Validate encoding\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_value += values[i]\n\n    # Fitness: lower is better; maximize value under budget\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Quadratic penalty for infeasibility\n    over = float(total_cost - budget)\n    rho = 100.0\n    return rho * (over * over) - 0.001 * float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid_or_zeroes(s: str) -> str:\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _flip_bit(s: str, idx: int) -> str:\n        return s[:idx] + ('0' if s[idx] == '1' else '1') + s[idx+1:]\n\n    def _cost_value(s: str):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(s):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    def _repair_feasible(s: str) -> str:\n        tc, tv = _cost_value(s)\n        if tc <= budget:\n            return s\n        # Drop lowest density items until feasible\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        return ''.join(s_list)\n\n    s = _valid_or_zeroes(solution)\n    tc, tv = _cost_value(s)\n\n    # Move set with feasibility awareness\n    moves = ['single_flip', 'swap_1in1out', 'double_flip', 'biased_add_or_swap', 'two_for_one']\n    move = random.choice(moves)\n\n    if move == 'single_flip':\n        idx = random.randrange(n)\n        cand = _flip_bit(s, idx)\n        cand = _repair_feasible(cand)\n        return (cand, 'single_flip')\n\n    if move == 'double_flip':\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        cand = s\n        for i in idxs:\n            cand = _flip_bit(cand, i)\n        cand = _repair_feasible(cand)\n        return (cand, 'double_flip')\n\n    if move == 'swap_1in1out':\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not ones or not zeros:\n            idx = random.randrange(n)\n            cand = _flip_bit(s, idx)\n            cand = _repair_feasible(cand)\n            return (cand, 'swap_fallback')\n        # Remove worst density, add best density\n        i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n        i_in = zeros_sorted[0]\n        cand_list = list(s)\n        cand_list[i_out] = '0'\n        cand_list[i_in] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'swap_1in1out')\n\n    if move == 'biased_add_or_swap':\n        # Prefer adding high-density item if budget allows; else drop worst then add best\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        cand = s\n        if zeros:\n            zeros_sorted = sorted(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n            for i_in in zeros_sorted[:min(5, len(zeros_sorted))]:\n                if tc + costs[i_in] <= budget:\n                    cand = _flip_bit(cand, i_in)\n                    break\n            else:\n                if ones:\n                    i_out = min(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n                    cand_list = list(cand)\n                    cand_list[i_out] = '0'\n                    cand_list[zeros_sorted[0]] = '1'\n                    cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'biased_add_or_swap')\n\n    # two_for_one: drop two worst, add one best\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    if len(ones) >= 2 and len(zeros) >= 1:\n        worst_two = sorted(ones, key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))[:2]\n        best_zero = max(zeros, key=lambda i: (values[i] \/ float(costs[i]), values[i]))\n        cand_list = list(s)\n        for i in worst_two:\n            cand_list[i] = '0'\n        cand_list[best_zero] = '1'\n        cand = ''.join(cand_list)\n        cand = _repair_feasible(cand)\n        return (cand, 'two_for_one')\n\n    # Fallback single flip\n    idx = random.randrange(n)\n    cand = _flip_bit(s, idx)\n    cand = _repair_feasible(cand)\n    return (cand, 'single_flip_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Internal problem data\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget = 3040\n    n = len(costs)\n\n    def _valid(s):\n        if not isinstance(s, str) or len(s) != n or any(ch not in '01' for ch in s):\n            return '0' * n\n        return s\n\n    def _cv(binstr):\n        tc = 0\n        tv = 0\n        for i, ch in enumerate(binstr):\n            if ch == '1':\n                tc += costs[i]\n                tv += values[i]\n        return tc, tv\n\n    s = _valid(solution)\n\n    # Random multi-bit flips\n    if n > 0:\n        r = min(n, random.randint(3, 6))\n        idxs = random.sample(range(n), r)\n        s_list = list(s)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        s = ''.join(s_list)\n\n    # Repair if over budget: drop lowest density items first\n    tc, tv = _cv(s)\n    if tc > budget:\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: (values[i] \/ float(costs[i]), -costs[i]))\n        s_list = list(s)\n        for i in ones:\n            if tc <= budget:\n                break\n            if s_list[i] == '1':\n                s_list[i] = '0'\n                tc -= costs[i]\n        s = ''.join(s_list)\n        tc, tv = _cv(s)\n\n    # Greedy refill by best density under remaining budget\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    zeros.sort(key=lambda i: (values[i] \/ float(costs[i]), values[i]), reverse=True)\n    s_list = list(s)\n    for i in zeros:\n        if tc + costs[i] <= budget:\n            s_list[i] = '1'\n            tc += costs[i]\n    s = ''.join(s_list)\n    return s\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001515058}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; index i (0-based) maps to Customer i+1. '1' means accept offer, '0' means reject. Capacity constraint: total gallons <= 304.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Strong linear penalty on overflow to enforce feasibility\n        penalty = 1_000_000 * overflow + total_value  # keep tie-breaker by value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\n# Neighbour: flip one random bit (accept<->reject one offer)\n# Returns: (new_solution, NB_Type, Movement_Type)\n# NB_Type: 'BIT_FLIP'; Movement_Type: 'LOCAL_1BIT'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not solution:\n        return (solution, \"BIT_FLIP\", \"LOCAL_1BIT\")\n    n = len(solution)\n    i = random.randrange(n)\n    lst = list(solution)\n    lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"BIT_FLIP\", \"LOCAL_1BIT\")\n","Perturbacion":"import random\n\n# Perturbation: flip k distinct random bits to escape local minima (k in [2,5] bounded by length)\n\ndef perturb_solution(solution):\n    if not solution:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(2, 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)\n","Resultados":"Failed to run target heuristic: object of type 'int' has no len().  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000404306}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; index i (0-based) maps to Customer i+1. '1' means accept offer, '0' means reject. Capacity constraint: total gallons <= 304.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Strong linear penalty on overflow to enforce feasibility\n        penalty = 1_000_000 * overflow + total_value  # keep tie-breaker by value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\n# Neighbour: flip one random bit (accept<->reject one offer)\n# Returns: (new_solution, NB_Type, Movement_Type)\n# NB_Type: 'BIT_FLIP'; Movement_Type: 'LOCAL_1BIT'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not solution:\n        return (solution, \"BIT_FLIP\", \"LOCAL_1BIT\")\n    n = len(solution)\n    i = random.randrange(n)\n    lst = list(solution)\n    lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"BIT_FLIP\", \"LOCAL_1BIT\")\n","Perturbacion":"import random\n\n# Perturbation: flip k distinct random bits to escape local minima (k in [2,5] bounded by length)\n\ndef perturb_solution(solution):\n    if not solution:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(2, 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)\n","Resultados":"Failed to run target heuristic: object of type 'int' has no len().  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000412356}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; index i (0-based) maps to Customer i+1. '1' means accept offer, '0' means reject. Capacity constraint: total gallons <= 304.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Strong linear penalty on overflow to enforce feasibility\n        penalty = 1_000_000 * overflow + total_value  # keep tie-breaker by value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\n# Neighbour: flip one random bit (accept<->reject one offer)\n# Returns: (new_solution, NB_Type, Movement_Type)\n# NB_Type: 'BIT_FLIP'; Movement_Type: 'LOCAL_1BIT'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not solution:\n        return (solution, \"BIT_FLIP\", \"LOCAL_1BIT\")\n    n = len(solution)\n    i = random.randrange(n)\n    lst = list(solution)\n    lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"BIT_FLIP\", \"LOCAL_1BIT\")\n","Perturbacion":"import random\n\n# Perturbation: flip k distinct random bits to escape local minima (k in [2,5] bounded by length)\n\ndef perturb_solution(solution):\n    if not solution:\n        return solution\n    n = len(solution)\n    k = min(n, random.randint(2, 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)\n","Resultados":"Failed to run target heuristic: object of type 'int' has no len().  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0003876351}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; i-th bit (0-based) -> Customer i+1. '1'=accept offer, '0'=reject. Capacity constraint: sum(weights where bit=1) <= 304 gallons. NB returns (new_solution, NB_Type, Movement_Type).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Moderate linear penalty on overflow; still allows SA temperature to function\n        penalty = 100.0 * overflow + 0.001 * total_value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NOOP\", \"EMPTY\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    # Current weight\n    current_weight = sum(weights[i] for i, ch in enumerate(solution) if ch == '1')\n    s = list(solution)\n    idx = random.randrange(n)\n    if s[idx] == '0':\n        # Try feasibility-preserving add; else attempt swap; else drop a random 1\n        if current_weight + weights[idx] <= capacity:\n            s[idx] = '1'\n            return (''.join(s), \"BIT_FLIP\", \"FEASIBLE_ADD\")\n        ones = [i for i, ch in enumerate(solution) if ch == '1']\n        random.shuffle(ones)\n        for j in ones:\n            if current_weight - weights[j] + weights[idx] <= capacity:\n                s2 = list(solution)\n                s2[j] = '0'\n                s2[idx] = '1'\n                return (''.join(s2), \"SWAP_2BIT\", \"FEASIBLE_SWAP\")\n        if ones:\n            j = random.choice(ones)\n            s3 = list(solution)\n            s3[j] = '0'\n            return (''.join(s3), \"BIT_FLIP\", \"DROP\")\n        return (solution, \"NOOP\", \"NO_MOVE\")\n    else:\n        # Drop always feasible\n        s[idx] = '0'\n        return (''.join(s), \"BIT_FLIP\", \"DROP\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    s = list(solution)\n    # Ensure feasibility by trimming if needed (remove lowest value\/weight first)\n    current_weight = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if current_weight > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if current_weight <= capacity:\n                break\n            s[i] = '0'\n            current_weight -= weights[i]\n    # Random k deletions\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    if ones:\n        k = random.randint(2, min(5, len(ones)))\n        for i in random.sample(ones, k):\n            if s[i] == '1':\n                s[i] = '0'\n                current_weight -= weights[i]\n    # Greedy refill by value\/weight ratio\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if current_weight + weights[i] <= capacity:\n            s[i] = '1'\n            current_weight += weights[i]\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000519197}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; i-th bit (0-based) -> Customer i+1. '1'=accept offer, '0'=reject. Capacity constraint: sum(weights where bit=1) <= 304 gallons. NB returns (new_solution, NB_Type, Movement_Type).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Moderate linear penalty on overflow; still allows SA temperature to function\n        penalty = 100.0 * overflow + 0.001 * total_value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NOOP\", \"EMPTY\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    # Current weight\n    current_weight = sum(weights[i] for i, ch in enumerate(solution) if ch == '1')\n    s = list(solution)\n    idx = random.randrange(n)\n    if s[idx] == '0':\n        # Try feasibility-preserving add; else attempt swap; else drop a random 1\n        if current_weight + weights[idx] <= capacity:\n            s[idx] = '1'\n            return (''.join(s), \"BIT_FLIP\", \"FEASIBLE_ADD\")\n        ones = [i for i, ch in enumerate(solution) if ch == '1']\n        random.shuffle(ones)\n        for j in ones:\n            if current_weight - weights[j] + weights[idx] <= capacity:\n                s2 = list(solution)\n                s2[j] = '0'\n                s2[idx] = '1'\n                return (''.join(s2), \"SWAP_2BIT\", \"FEASIBLE_SWAP\")\n        if ones:\n            j = random.choice(ones)\n            s3 = list(solution)\n            s3[j] = '0'\n            return (''.join(s3), \"BIT_FLIP\", \"DROP\")\n        return (solution, \"NOOP\", \"NO_MOVE\")\n    else:\n        # Drop always feasible\n        s[idx] = '0'\n        return (''.join(s), \"BIT_FLIP\", \"DROP\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    s = list(solution)\n    # Ensure feasibility by trimming if needed (remove lowest value\/weight first)\n    current_weight = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if current_weight > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if current_weight <= capacity:\n                break\n            s[i] = '0'\n            current_weight -= weights[i]\n    # Random k deletions\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    if ones:\n        k = random.randint(2, min(5, len(ones)))\n        for i in random.sample(ones, k):\n            if s[i] == '1':\n                s[i] = '0'\n                current_weight -= weights[i]\n    # Greedy refill by value\/weight ratio\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if current_weight + weights[i] <= capacity:\n            s[i] = '1'\n            current_weight += weights[i]\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0007028701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24; i-th bit (0-based) -> Customer i+1. '1'=accept offer, '0'=reject. Capacity constraint: sum(weights where bit=1) <= 304 gallons. NB returns (new_solution, NB_Type, Movement_Type).","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate representation\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons), customers 1..24\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = max(0, total_weight - capacity)\n    if overflow > 0:\n        # Moderate linear penalty on overflow; still allows SA temperature to function\n        penalty = 100.0 * overflow + 0.001 * total_value\n        return penalty  # higher is worse; we minimize\n    # Feasible: use negative for maximization\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return (solution, \"INVALID\", \"NONE\")\n    n = len(solution)\n    if n == 0:\n        return (solution, \"NOOP\", \"EMPTY\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    # Current weight\n    current_weight = sum(weights[i] for i, ch in enumerate(solution) if ch == '1')\n    s = list(solution)\n    idx = random.randrange(n)\n    if s[idx] == '0':\n        # Try feasibility-preserving add; else attempt swap; else drop a random 1\n        if current_weight + weights[idx] <= capacity:\n            s[idx] = '1'\n            return (''.join(s), \"BIT_FLIP\", \"FEASIBLE_ADD\")\n        ones = [i for i, ch in enumerate(solution) if ch == '1']\n        random.shuffle(ones)\n        for j in ones:\n            if current_weight - weights[j] + weights[idx] <= capacity:\n                s2 = list(solution)\n                s2[j] = '0'\n                s2[idx] = '1'\n                return (''.join(s2), \"SWAP_2BIT\", \"FEASIBLE_SWAP\")\n        if ones:\n            j = random.choice(ones)\n            s3 = list(solution)\n            s3[j] = '0'\n            return (''.join(s3), \"BIT_FLIP\", \"DROP\")\n        return (solution, \"NOOP\", \"NO_MOVE\")\n    else:\n        # Drop always feasible\n        s[idx] = '0'\n        return (''.join(s), \"BIT_FLIP\", \"DROP\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n == 0:\n        return solution\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    s = list(solution)\n    # Ensure feasibility by trimming if needed (remove lowest value\/weight first)\n    current_weight = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if current_weight > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if current_weight <= capacity:\n                break\n            s[i] = '0'\n            current_weight -= weights[i]\n    # Random k deletions\n    ones = [i for i, ch in enumerate(s) if ch == '1']\n    if ones:\n        k = random.randint(2, min(5, len(ones)))\n        for i in random.sample(ones, k):\n            if s[i] == '1':\n                s[i] = '0'\n                current_weight -= weights[i]\n    # Greedy refill by value\/weight ratio\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if current_weight + weights[i] <= capacity:\n            s[i] = '1'\n            current_weight += weights[i]\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000666789}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong penalty for infeasibility to guide solvers\n        # Keep monotonic in overflow, independent of value scale\n        penalty = 1_000_000.0 + 10_000.0 * overflow\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, meta_dict)\n    # meta_dict schema: {'nb_type': str, 'move': str}\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution, {'nb_type': 'INVALID', 'move': 'NONE'}\n    n = len(solution)\n    if n != 24:\n        return solution, {'nb_type': 'INVALID', 'move': 'LEN_MISMATCH'}\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Current weight\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    # Randomly choose an operator\n    r = random.random()\n    if r < 0.5:\n        # Single bit flip with feasibility preference\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'DROP'}\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'FEASIBLE_ADD'}\n            # Try a 1-1 swap to keep feasibility\n            ones = [i for i, ch in enumerate(solution) if ch == '1']\n            random.shuffle(ones)\n            for j in ones:\n                if curr_w - weights[j] + weights[idx] <= capacity:\n                    s2 = list(solution)\n                    s2[j] = '0'\n                    s2[idx] = '1'\n                    return ''.join(s2), {'nb_type': 'SWAP_2BIT', 'move': 'FEASIBLE_SWAP'}\n            # Fallback: drop a random 1 if any\n            if ones:\n                j = random.choice(ones)\n                s3 = list(solution)\n                s3[j] = '0'\n                return ''.join(s3), {'nb_type': 'BIT_FLIP', 'move': 'DROP_FALLBACK'}\n            return solution, {'nb_type': 'NOOP', 'move': 'NO_MOVE'}\n    else:\n        # k-flip (k in {2,3}) with repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        # Repair overweight by removing worst density items first\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s2) if ch == '1'))\n            for _, i in items:\n                if curr_w2 <= capacity:\n                    break\n                if s2[i] == '1':\n                    s2[i] = '0'\n                    curr_w2 -= weights[i]\n        return ''.join(s2), {'nb_type': 'K_FLIP', 'move': 'REPAIR'}\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution string (same representation)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Randomly flip between 3 and 6 bits\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    # Feasibility repair: trim by lowest value\/weight until feasible\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if curr_w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                curr_w -= weights[i]\n\n    # Optional greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":[111101010111011111111111,null,111101010111011111111111,null],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000760791}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong penalty for infeasibility to guide solvers\n        # Keep monotonic in overflow, independent of value scale\n        penalty = 1_000_000.0 + 10_000.0 * overflow\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, meta_dict)\n    # meta_dict schema: {'nb_type': str, 'move': str}\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution, {'nb_type': 'INVALID', 'move': 'NONE'}\n    n = len(solution)\n    if n != 24:\n        return solution, {'nb_type': 'INVALID', 'move': 'LEN_MISMATCH'}\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Current weight\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    # Randomly choose an operator\n    r = random.random()\n    if r < 0.5:\n        # Single bit flip with feasibility preference\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'DROP'}\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'FEASIBLE_ADD'}\n            # Try a 1-1 swap to keep feasibility\n            ones = [i for i, ch in enumerate(solution) if ch == '1']\n            random.shuffle(ones)\n            for j in ones:\n                if curr_w - weights[j] + weights[idx] <= capacity:\n                    s2 = list(solution)\n                    s2[j] = '0'\n                    s2[idx] = '1'\n                    return ''.join(s2), {'nb_type': 'SWAP_2BIT', 'move': 'FEASIBLE_SWAP'}\n            # Fallback: drop a random 1 if any\n            if ones:\n                j = random.choice(ones)\n                s3 = list(solution)\n                s3[j] = '0'\n                return ''.join(s3), {'nb_type': 'BIT_FLIP', 'move': 'DROP_FALLBACK'}\n            return solution, {'nb_type': 'NOOP', 'move': 'NO_MOVE'}\n    else:\n        # k-flip (k in {2,3}) with repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        # Repair overweight by removing worst density items first\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s2) if ch == '1'))\n            for _, i in items:\n                if curr_w2 <= capacity:\n                    break\n                if s2[i] == '1':\n                    s2[i] = '0'\n                    curr_w2 -= weights[i]\n        return ''.join(s2), {'nb_type': 'K_FLIP', 'move': 'REPAIR'}\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution string (same representation)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Randomly flip between 3 and 6 bits\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    # Feasibility repair: trim by lowest value\/weight until feasible\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if curr_w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                curr_w -= weights[i]\n\n    # Optional greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":[111101010111011111111111,null,111101010111011111111111,null],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000935022}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return float('inf')\n    n = 24\n    if len(solution) != n:\n        return float('inf')\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong penalty for infeasibility to guide solvers\n        # Keep monotonic in overflow, independent of value scale\n        penalty = 1_000_000.0 + 10_000.0 * overflow\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, meta_dict)\n    # meta_dict schema: {'nb_type': str, 'move': str}\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution, {'nb_type': 'INVALID', 'move': 'NONE'}\n    n = len(solution)\n    if n != 24:\n        return solution, {'nb_type': 'INVALID', 'move': 'LEN_MISMATCH'}\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Current weight\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    # Randomly choose an operator\n    r = random.random()\n    if r < 0.5:\n        # Single bit flip with feasibility preference\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'DROP'}\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s), {'nb_type': 'BIT_FLIP', 'move': 'FEASIBLE_ADD'}\n            # Try a 1-1 swap to keep feasibility\n            ones = [i for i, ch in enumerate(solution) if ch == '1']\n            random.shuffle(ones)\n            for j in ones:\n                if curr_w - weights[j] + weights[idx] <= capacity:\n                    s2 = list(solution)\n                    s2[j] = '0'\n                    s2[idx] = '1'\n                    return ''.join(s2), {'nb_type': 'SWAP_2BIT', 'move': 'FEASIBLE_SWAP'}\n            # Fallback: drop a random 1 if any\n            if ones:\n                j = random.choice(ones)\n                s3 = list(solution)\n                s3[j] = '0'\n                return ''.join(s3), {'nb_type': 'BIT_FLIP', 'move': 'DROP_FALLBACK'}\n            return solution, {'nb_type': 'NOOP', 'move': 'NO_MOVE'}\n    else:\n        # k-flip (k in {2,3}) with repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        # Repair overweight by removing worst density items first\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s2) if ch == '1'))\n            for _, i in items:\n                if curr_w2 <= capacity:\n                    break\n                if s2[i] == '1':\n                    s2[i] = '0'\n                    curr_w2 -= weights[i]\n        return ''.join(s2), {'nb_type': 'K_FLIP', 'move': 'REPAIR'}\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution string (same representation)\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    s = list(solution)\n    # Randomly flip between 3 and 6 bits\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    # Feasibility repair: trim by lowest value\/weight until feasible\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        items = sorted(((values[i] \/ weights[i], i) for i, ch in enumerate(s) if ch == '1'))\n        for _, i in items:\n            if curr_w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                curr_w -= weights[i]\n\n    # Optional greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for _, i in sorted(((-values[i] \/ weights[i], i) for i in zeros)):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0008825429}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    # Returns a scalar cost to MINIMIZE (negated revenue for feasible, large finite penalty otherwise)\n    n = 24\n    # Fast validation with finite penalties (avoid inf propagation)\n    if not isinstance(solution, str):\n        return 1_000_000_000.0\n    if len(solution) != n:\n        return 1_000_000_000.0 + 100_000.0 * abs(len(solution) - n)\n    if any(c not in '01' for c in solution):\n        return 1_000_000_000.0 + 50_000.0\n\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong monotone penalty in overflow\n        penalty = 1_000_000.0 + 10_000.0 * float(overflow)\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns a neighbouring solution (same 24-bit string representation)\n    # Ensures feasibility via light repair when needed\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    r = random.random()\n    if r < 0.5:\n        # Single flip with feasibility bias and 1-1 swap repair\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s)\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s)\n            # Try swap out a selected item with lowest density that makes room\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda j: densities[j])\n                for j in ones_sorted:\n                    if curr_w - weights[j] + weights[idx] <= capacity:\n                        s2 = list(s)\n                        s2[j] = '0'\n                        s2[idx] = '1'\n                        return ''.join(s2)\n            return ''.join(s)\n    else:\n        # 2- or 3-flip followed by greedy repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            # Remove selected items with lowest density first\n            selected = [i for i, ch in enumerate(s2) if ch == '1']\n            for i in sorted(selected, key=lambda j: densities[j]):\n                if curr_w2 <= capacity:\n                    break\n                s2[i] = '0'\n                curr_w2 -= weights[i]\n        return ''.join(s2)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed 24-bit solution with feasibility repair and optional refill\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        selected = [i for i, ch in enumerate(s) if ch == '1']\n        for i in sorted(selected, key=lambda j: densities[j]):\n            if curr_w <= capacity:\n                break\n            s[i] = '0'\n            curr_w -= weights[i]\n\n    # Greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for i in sorted(zeros, key=lambda j: -densities[j]):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0007598411}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    # Returns a scalar cost to MINIMIZE (negated revenue for feasible, large finite penalty otherwise)\n    n = 24\n    # Fast validation with finite penalties (avoid inf propagation)\n    if not isinstance(solution, str):\n        return 1_000_000_000.0\n    if len(solution) != n:\n        return 1_000_000_000.0 + 100_000.0 * abs(len(solution) - n)\n    if any(c not in '01' for c in solution):\n        return 1_000_000_000.0 + 50_000.0\n\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong monotone penalty in overflow\n        penalty = 1_000_000.0 + 10_000.0 * float(overflow)\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns a neighbouring solution (same 24-bit string representation)\n    # Ensures feasibility via light repair when needed\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    r = random.random()\n    if r < 0.5:\n        # Single flip with feasibility bias and 1-1 swap repair\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s)\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s)\n            # Try swap out a selected item with lowest density that makes room\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda j: densities[j])\n                for j in ones_sorted:\n                    if curr_w - weights[j] + weights[idx] <= capacity:\n                        s2 = list(s)\n                        s2[j] = '0'\n                        s2[idx] = '1'\n                        return ''.join(s2)\n            return ''.join(s)\n    else:\n        # 2- or 3-flip followed by greedy repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            # Remove selected items with lowest density first\n            selected = [i for i, ch in enumerate(s2) if ch == '1']\n            for i in sorted(selected, key=lambda j: densities[j]):\n                if curr_w2 <= capacity:\n                    break\n                s2[i] = '0'\n                curr_w2 -= weights[i]\n        return ''.join(s2)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed 24-bit solution with feasibility repair and optional refill\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        selected = [i for i, ch in enumerate(s) if ch == '1']\n        for i in sorted(selected, key=lambda j: densities[j]):\n            if curr_w <= capacity:\n                break\n            s[i] = '0'\n            curr_w -= weights[i]\n\n    # Greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for i in sorted(zeros, key=lambda j: -densities[j]):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: cannot unpack non-iterable int object.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000905482}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string; bit i -> take customer i+1 if '1'\n    # Returns a scalar cost to MINIMIZE (negated revenue for feasible, large finite penalty otherwise)\n    n = 24\n    # Fast validation with finite penalties (avoid inf propagation)\n    if not isinstance(solution, str):\n        return 1_000_000_000.0\n    if len(solution) != n:\n        return 1_000_000_000.0 + 100_000.0 * abs(len(solution) - n)\n    if any(c not in '01' for c in solution):\n        return 1_000_000_000.0 + 50_000.0\n\n    # Embedded problem data (values=revenue, weights=gallons)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    total_weight = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_weight += weights[i]\n            total_value += values[i]\n    overflow = total_weight - capacity\n    if overflow > 0:\n        # Strong monotone penalty in overflow\n        penalty = 1_000_000.0 + 10_000.0 * float(overflow)\n        return penalty\n    # Feasible: convert maximization to minimization by negating value\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns a neighbouring solution (same 24-bit string representation)\n    # Ensures feasibility via light repair when needed\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n\n    r = random.random()\n    if r < 0.5:\n        # Single flip with feasibility bias and 1-1 swap repair\n        idx = random.randrange(n)\n        if s[idx] == '1':\n            s[idx] = '0'\n            return ''.join(s)\n        else:\n            if curr_w + weights[idx] <= capacity:\n                s[idx] = '1'\n                return ''.join(s)\n            # Try swap out a selected item with lowest density that makes room\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda j: densities[j])\n                for j in ones_sorted:\n                    if curr_w - weights[j] + weights[idx] <= capacity:\n                        s2 = list(s)\n                        s2[j] = '0'\n                        s2[idx] = '1'\n                        return ''.join(s2)\n            return ''.join(s)\n    else:\n        # 2- or 3-flip followed by greedy repair\n        k = 2 if random.random() < 0.6 else 3\n        idxs = random.sample(range(n), k)\n        s2 = list(s)\n        for idx in idxs:\n            s2[idx] = '1' if s2[idx] == '0' else '0'\n        curr_w2 = sum(weights[i] for i, ch in enumerate(s2) if ch == '1')\n        if curr_w2 > capacity:\n            # Remove selected items with lowest density first\n            selected = [i for i, ch in enumerate(s2) if ch == '1']\n            for i in sorted(selected, key=lambda j: densities[j]):\n                if curr_w2 <= capacity:\n                    break\n                s2[i] = '0'\n                curr_w2 -= weights[i]\n        return ''.join(s2)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed 24-bit solution with feasibility repair and optional refill\n    if not isinstance(solution, str) or any(c not in '01' for c in solution):\n        return solution\n    n = len(solution)\n    if n != 24:\n        return solution\n\n    # Embedded data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    densities = [values[i] \/ weights[i] for i in range(n)]\n\n    s = list(solution)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s[idx] = '1' if s[idx] == '0' else '0'\n\n    curr_w = sum(weights[i] for i, ch in enumerate(s) if ch == '1')\n    if curr_w > capacity:\n        selected = [i for i, ch in enumerate(s) if ch == '1']\n        for i in sorted(selected, key=lambda j: densities[j]):\n            if curr_w <= capacity:\n                break\n            s[i] = '0'\n            curr_w -= weights[i]\n\n    # Greedy refill by density\n    zeros = [i for i, ch in enumerate(s) if ch == '0']\n    for i in sorted(zeros, key=lambda j: -densities[j]):\n        if curr_w + weights[i] <= capacity:\n            s[i] = '1'\n            curr_w += weights[i]\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: 'int' object is not iterable.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000889962}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and content\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a string matching BIN_STR representation.\")\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError(\"Solution must be a 24-length binary string of '0'\/'1'.\")\n\n    # Embedded problem data (scores, times)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # SA expects lesser cost better; we convert maximization to minimization via negatives\n    if total_time <= capacity:\n        # Feasible: minimize negative value\n        cost = -float(total_value)\n    else:\n        # Infeasible: large penalty proportional to overflow; keep a small guidance with -value\n        overflow = total_time - capacity\n        cost = 1e6 + 100.0 * overflow - float(total_value)\n    return cost\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Expect BIN_STR; create 1-bit flip neighbour\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    idx = random.randrange(n)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    # Return neighbour and metadata\n    return neighbour, \"BIT_FLIP\", \"1-bit\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flip to escape local minima\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in indices:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000350205}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and content\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a string matching BIN_STR representation.\")\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError(\"Solution must be a 24-length binary string of '0'\/'1'.\")\n\n    # Embedded problem data (scores, times)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # SA expects lesser cost better; we convert maximization to minimization via negatives\n    if total_time <= capacity:\n        # Feasible: minimize negative value\n        cost = -float(total_value)\n    else:\n        # Infeasible: large penalty proportional to overflow; keep a small guidance with -value\n        overflow = total_time - capacity\n        cost = 1e6 + 100.0 * overflow - float(total_value)\n    return cost\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Expect BIN_STR; create 1-bit flip neighbour\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    idx = random.randrange(n)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    # Return neighbour and metadata\n    return neighbour, \"BIT_FLIP\", \"1-bit\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flip to escape local minima\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in indices:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0003569949}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and content\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a string matching BIN_STR representation.\")\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError(\"Solution must be a 24-length binary string of '0'\/'1'.\")\n\n    # Embedded problem data (scores, times)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # SA expects lesser cost better; we convert maximization to minimization via negatives\n    if total_time <= capacity:\n        # Feasible: minimize negative value\n        cost = -float(total_value)\n    else:\n        # Infeasible: large penalty proportional to overflow; keep a small guidance with -value\n        overflow = total_time - capacity\n        cost = 1e6 + 100.0 * overflow - float(total_value)\n    return cost\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Expect BIN_STR; create 1-bit flip neighbour\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    idx = random.randrange(n)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    # Return neighbour and metadata\n    return neighbour, \"BIT_FLIP\", \"1-bit\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flip to escape local minima\n    if not isinstance(solution, str):\n        raise ValueError(\"Solution must be a BIN_STR string.\")\n    n = len(solution)\n    if n == 0:\n        raise ValueError(\"Empty solution.\")\n    k = random.randint(2, min(5, n))\n    indices = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in indices:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000326864}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate BIN_STR\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # Dynamic penalty based on average value\/weight\n    avg_density = (sum(values) \/ float(sum(weights)))\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow proportionally while keeping guidance from -value\n        lam = 50.0 * avg_density\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Choose a move type\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange (swap one selected=1 to 0 and one unselected=0 to 1)\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided flip: bias towards turning on high value\/weight or turning off low density\n        values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # choose a zero to flip to 1 with prob proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            # turn off the lowest density item\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0006940289}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate BIN_STR\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # Dynamic penalty based on average value\/weight\n    avg_density = (sum(values) \/ float(sum(weights)))\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow proportionally while keeping guidance from -value\n        lam = 50.0 * avg_density\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Choose a move type\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange (swap one selected=1 to 0 and one unselected=0 to 1)\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided flip: bias towards turning on high value\/weight or turning off low density\n        values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # choose a zero to flip to 1 with prob proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            # turn off the lowest density item\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0006063289}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR length=24. Index i (1-based) maps to Attraction i. Char '1' = visit, '0' = skip.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate BIN_STR\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    # Dynamic penalty based on average value\/weight\n    avg_density = (sum(values) \/ float(sum(weights)))\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow proportionally while keeping guidance from -value\n        lam = 50.0 * avg_density\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Choose a move type\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange (swap one selected=1 to 0 and one unselected=0 to 1)\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided flip: bias towards turning on high value\/weight or turning off low density\n        values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n        weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # choose a zero to flip to 1 with prob proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            # turn off the lowest density item\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0006066579}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from list\/tuple of 0\/1\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception as e:\n            raise ValueError('Solution must be a 24-length binary string or list\/tuple of 0\/1.')\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow strongly to guide towards feasibility\n        # Scale penalty by median density (~value per minute)\n        dens = sorted([v\/float(w) for v, w in zip(values, weights)])\n        median_density = dens[len(dens)\/\/2]\n        lam = 100.0 * median_density  # about 10x value per minute unit\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        # Drop lowest-density items until feasible\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        # sort ones by density ascending\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided move\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # probability proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    s_list = repair_feasible(s_list)\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000966543}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from list\/tuple of 0\/1\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception as e:\n            raise ValueError('Solution must be a 24-length binary string or list\/tuple of 0\/1.')\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow strongly to guide towards feasibility\n        # Scale penalty by median density (~value per minute)\n        dens = sorted([v\/float(w) for v, w in zip(values, weights)])\n        median_density = dens[len(dens)\/\/2]\n        lam = 100.0 * median_density  # about 10x value per minute unit\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        # Drop lowest-density items until feasible\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        # sort ones by density ascending\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided move\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # probability proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    s_list = repair_feasible(s_list)\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001205675}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from list\/tuple of 0\/1\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception as e:\n            raise ValueError('Solution must be a 24-length binary string or list\/tuple of 0\/1.')\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a string matching BIN_STR representation.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Lesser cost is better. For feasible: -value; tie-break lower time with tiny epsilon\n    eps = 1e-6\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Penalize overflow strongly to guide towards feasibility\n        # Scale penalty by median density (~value per minute)\n        dens = sorted([v\/float(w) for v, w in zip(values, weights)])\n        median_density = dens[len(dens)\/\/2]\n        lam = 100.0 * median_density  # about 10x value per minute unit\n        cost = -float(total_value) + lam * float(overflow)\n    return float(cost)\n","Vecindad":"import random\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        # Drop lowest-density items until feasible\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        # sort ones by density ascending\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    r = random.random()\n    if r < 0.35:\n        # 1-bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    elif r < 0.70:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            s_list[i] = '0'\n            s_list[j] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'EXCHANGE', '1-0'\n        # fallback\n        idx = random.randrange(n)\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        s_list = repair_feasible(s_list)\n        return ''.join(s_list), 'BIT_FLIP', '1-bit'\n    else:\n        # Density-guided move\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            # probability proportional to density\n            total = sum(density[i] for i in zeros)\n            if total <= 0:\n                idx = random.choice(zeros)\n            else:\n                t = random.random() * total\n                acc = 0.0\n                idx = zeros[0]\n                for i in zeros:\n                    acc += density[i]\n                    if acc >= t:\n                        idx = i\n                        break\n            s_list[idx] = '1'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-on'\n        elif ones:\n            idx = min(ones, key=lambda i: density[i])\n            s_list[idx] = '0'\n            s_list = repair_feasible(s_list)\n            return ''.join(s_list), 'GUIDED', 'density-off'\n        else:\n            return solution, 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string.')\n    n = len(solution)\n    if n == 0:\n        raise ValueError('Empty solution.')\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of(s):\n        return sum(weights[i] for i,ch in enumerate(s) if ch == '1')\n\n    def repair_feasible(s):\n        t = total_time_of(s)\n        if t <= capacity:\n            return s\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        ones_sorted = sorted(ones, key=lambda i: density[i])\n        s2 = s[:]\n        for idx in ones_sorted:\n            if t <= capacity:\n                break\n            s2[idx] = '0'\n            t -= weights[idx]\n        return s2\n\n    k = random.randint(3, min(7, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    s_list = repair_feasible(s_list)\n    return ''.join(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a string matching BIN_STR representation.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001116765}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from iterable of 0\/1\n    if not isinstance(solution, str):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception:\n            raise ValueError('Solution must be a 24-length binary string or iterable of 0\/1.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Precompute density stats\n    densities = [v\/float(w) for v, w in zip(values, weights)]\n    dens_sorted = sorted(densities)\n    median_density = dens_sorted[len(dens_sorted)\/\/2]\n\n    # Lesser cost is better; feasible solutions prioritized by higher value, then lower time\n    eps = 1e-3\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Quadratic-like penalty on overflow to rank near-feasible solutions more smoothly\n        lam = 15.0 * median_density\n        cost = -float(total_value) + lam * float(overflow ** 1.5)\n    return float(cost)\n","Vecindad":"import random\nfrom typing import Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        # Ensure bits is a list of '0'\/'1'\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        # Drop items with lowest value-per-time (density) first\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        # Sort ones by increasing density; drop until feasible\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    def flip_and_repair(idx_list, tag_type, move_type):\n        for idx in idx_list:\n            s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        repaired = repair_feasible(s_list[:])\n        return repaired, tag_type, move_type\n\n    r = random.random()\n    # Neighborhood mix: 1-bit, 2-bit, 1-0 exchange, 2-1 and 1-2 exchanges, density-guided add\/remove\n    if r < 0.20:\n        # 1-bit flip\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.40:\n        # 2-bit flip (swap2)\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    elif r < 0.60:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            return flip_and_repair([i, j], 'EXCHANGE', '1-0')\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.80:\n        # 2-1 or 1-2 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if len(ones) >= 2 and len(zeros) >= 1 and random.random() < 0.5:\n            i, j = random.sample(ones, 2)\n            k = random.choice(zeros)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '2-1')\n        elif len(zeros) >= 2 and len(ones) >= 1:\n            i, j = random.sample(zeros, 2)\n            k = random.choice(ones)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '1-2')\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    else:\n        # Density-guided: try to add a high-density zero, drop to repair if needed\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            total = sum(max(density[i], 1e-9) for i in zeros)\n            t = random.random() * total\n            acc = 0.0\n            idx = zeros[0]\n            for i in zeros:\n                acc += max(density[i], 1e-9)\n                if acc >= t:\n                    idx = i\n                    break\n            return flip_and_repair([idx], 'GUIDED', 'density-on')\n        elif ones:\n            # Remove lowest density one\n            idx = min(ones, key=lambda i: (density[i], -weights[i]))\n            return flip_and_repair([idx], 'GUIDED', 'density-off')\n        else:\n            return ''.join(s_list), 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    # Ruin-and-recreate: flip k\u2248n\/6 bits off and k on with density bias\n    k = max(3, min(7, (n + 5)\/\/6))\n\n    ones = [i for i, ch in enumerate(s_list) if ch == '1']\n    zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n\n    off_count = min(k, len(ones))\n    on_count = min(k, len(zeros))\n\n    if off_count > 0:\n        # Prefer turning off lowest-density items\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        off_idxs = sorted(ones, key=lambda i: (density[i], -weights[i]))[:off_count]\n        for idx in off_idxs:\n            s_list[idx] = '0'\n\n    if on_count > 0:\n        # Prefer turning on highest-density zeros\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        on_idxs = sorted(zeros, key=lambda i: (-density[i], weights[i]))[:on_count]\n        for idx in on_idxs:\n            s_list[idx] = '1'\n\n    # Final repair to ensure feasibility\n    return repair_feasible(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a 24-length binary string or iterable of 0\/1.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001074594}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from iterable of 0\/1\n    if not isinstance(solution, str):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception:\n            raise ValueError('Solution must be a 24-length binary string or iterable of 0\/1.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Precompute density stats\n    densities = [v\/float(w) for v, w in zip(values, weights)]\n    dens_sorted = sorted(densities)\n    median_density = dens_sorted[len(dens_sorted)\/\/2]\n\n    # Lesser cost is better; feasible solutions prioritized by higher value, then lower time\n    eps = 1e-3\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Quadratic-like penalty on overflow to rank near-feasible solutions more smoothly\n        lam = 15.0 * median_density\n        cost = -float(total_value) + lam * float(overflow ** 1.5)\n    return float(cost)\n","Vecindad":"import random\nfrom typing import Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        # Ensure bits is a list of '0'\/'1'\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        # Drop items with lowest value-per-time (density) first\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        # Sort ones by increasing density; drop until feasible\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    def flip_and_repair(idx_list, tag_type, move_type):\n        for idx in idx_list:\n            s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        repaired = repair_feasible(s_list[:])\n        return repaired, tag_type, move_type\n\n    r = random.random()\n    # Neighborhood mix: 1-bit, 2-bit, 1-0 exchange, 2-1 and 1-2 exchanges, density-guided add\/remove\n    if r < 0.20:\n        # 1-bit flip\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.40:\n        # 2-bit flip (swap2)\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    elif r < 0.60:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            return flip_and_repair([i, j], 'EXCHANGE', '1-0')\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.80:\n        # 2-1 or 1-2 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if len(ones) >= 2 and len(zeros) >= 1 and random.random() < 0.5:\n            i, j = random.sample(ones, 2)\n            k = random.choice(zeros)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '2-1')\n        elif len(zeros) >= 2 and len(ones) >= 1:\n            i, j = random.sample(zeros, 2)\n            k = random.choice(ones)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '1-2')\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    else:\n        # Density-guided: try to add a high-density zero, drop to repair if needed\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            total = sum(max(density[i], 1e-9) for i in zeros)\n            t = random.random() * total\n            acc = 0.0\n            idx = zeros[0]\n            for i in zeros:\n                acc += max(density[i], 1e-9)\n                if acc >= t:\n                    idx = i\n                    break\n            return flip_and_repair([idx], 'GUIDED', 'density-on')\n        elif ones:\n            # Remove lowest density one\n            idx = min(ones, key=lambda i: (density[i], -weights[i]))\n            return flip_and_repair([idx], 'GUIDED', 'density-off')\n        else:\n            return ''.join(s_list), 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    # Ruin-and-recreate: flip k\u2248n\/6 bits off and k on with density bias\n    k = max(3, min(7, (n + 5)\/\/6))\n\n    ones = [i for i, ch in enumerate(s_list) if ch == '1']\n    zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n\n    off_count = min(k, len(ones))\n    on_count = min(k, len(zeros))\n\n    if off_count > 0:\n        # Prefer turning off lowest-density items\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        off_idxs = sorted(ones, key=lambda i: (density[i], -weights[i]))[:off_count]\n        for idx in off_idxs:\n            s_list[idx] = '0'\n\n    if on_count > 0:\n        # Prefer turning on highest-density zeros\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        on_idxs = sorted(zeros, key=lambda i: (-density[i], weights[i]))[:on_count]\n        for idx in on_idxs:\n            s_list[idx] = '1'\n\n    # Final repair to ensure feasibility\n    return repair_feasible(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a 24-length binary string or iterable of 0\/1.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.001362078}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"BIN_STR_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept BIN_STR or cast from iterable of 0\/1\n    if not isinstance(solution, str):\n        try:\n            solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n        except Exception:\n            raise ValueError('Solution must be a 24-length binary string or iterable of 0\/1.')\n    n = 24\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        raise ValueError('Solution must be a 24-length binary string of 0\/1.')\n\n    # Embedded problem data (scores=values, times=weights)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    total_value = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_value += values[i]\n            total_time += weights[i]\n\n    overflow = max(0, total_time - capacity)\n\n    # Precompute density stats\n    densities = [v\/float(w) for v, w in zip(values, weights)]\n    dens_sorted = sorted(densities)\n    median_density = dens_sorted[len(dens_sorted)\/\/2]\n\n    # Lesser cost is better; feasible solutions prioritized by higher value, then lower time\n    eps = 1e-3\n    if overflow == 0:\n        cost = -float(total_value) + eps * float(total_time)\n    else:\n        # Quadratic-like penalty on overflow to rank near-feasible solutions more smoothly\n        lam = 15.0 * median_density\n        cost = -float(total_value) + lam * float(overflow ** 1.5)\n    return float(cost)\n","Vecindad":"import random\nfrom typing import Tuple\n\n# Returns (neighbour_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        # Ensure bits is a list of '0'\/'1'\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        # Drop items with lowest value-per-time (density) first\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        # Sort ones by increasing density; drop until feasible\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    def flip_and_repair(idx_list, tag_type, move_type):\n        for idx in idx_list:\n            s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        repaired = repair_feasible(s_list[:])\n        return repaired, tag_type, move_type\n\n    r = random.random()\n    # Neighborhood mix: 1-bit, 2-bit, 1-0 exchange, 2-1 and 1-2 exchanges, density-guided add\/remove\n    if r < 0.20:\n        # 1-bit flip\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.40:\n        # 2-bit flip (swap2)\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    elif r < 0.60:\n        # 1-0 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            return flip_and_repair([i, j], 'EXCHANGE', '1-0')\n        idx = random.randrange(n)\n        return flip_and_repair([idx], 'BIT_FLIP', '1-bit')\n    elif r < 0.80:\n        # 2-1 or 1-2 exchange\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if len(ones) >= 2 and len(zeros) >= 1 and random.random() < 0.5:\n            i, j = random.sample(ones, 2)\n            k = random.choice(zeros)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '2-1')\n        elif len(zeros) >= 2 and len(ones) >= 1:\n            i, j = random.sample(zeros, 2)\n            k = random.choice(ones)\n            return flip_and_repair([i, j, k], 'EXCHANGE', '1-2')\n        idxs = random.sample(range(n), 2)\n        return flip_and_repair(idxs, 'BIT_FLIP', '2-bit')\n    else:\n        # Density-guided: try to add a high-density zero, drop to repair if needed\n        density = [v \/ float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        if zeros:\n            total = sum(max(density[i], 1e-9) for i in zeros)\n            t = random.random() * total\n            acc = 0.0\n            idx = zeros[0]\n            for i in zeros:\n                acc += max(density[i], 1e-9)\n                if acc >= t:\n                    idx = i\n                    break\n            return flip_and_repair([idx], 'GUIDED', 'density-on')\n        elif ones:\n            # Remove lowest density one\n            idx = min(ones, key=lambda i: (density[i], -weights[i]))\n            return flip_and_repair([idx], 'GUIDED', 'density-off')\n        else:\n            return ''.join(s_list), 'NOOP', 'identity'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Normalize input to BIN_STR\n    if isinstance(solution, (list, tuple)):\n        solution = ''.join('1' if int(x) == 1 else '0' for x in solution)\n    if not isinstance(solution, str):\n        raise ValueError('Solution must be a BIN_STR string or iterable of 0\/1.')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('Solution must be 24-length BIN_STR.')\n\n    s_list = list(solution)\n\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    weights = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n\n    def total_time_of_bits(bits):\n        return sum(weights[i] for i, ch in enumerate(bits) if ch == '1')\n\n    def repair_feasible(bits):\n        if isinstance(bits, str):\n            bits = list(bits)\n        t = total_time_of_bits(bits)\n        if t <= capacity:\n            return ''.join(bits)\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        ones = [i for i, ch in enumerate(bits) if ch == '1']\n        for idx in sorted(ones, key=lambda i: (density[i], -weights[i])):\n            if t <= capacity:\n                break\n            bits[idx] = '0'\n            t -= weights[idx]\n        return ''.join(bits)\n\n    # Ruin-and-recreate: flip k\u2248n\/6 bits off and k on with density bias\n    k = max(3, min(7, (n + 5)\/\/6))\n\n    ones = [i for i, ch in enumerate(s_list) if ch == '1']\n    zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n\n    off_count = min(k, len(ones))\n    on_count = min(k, len(zeros))\n\n    if off_count > 0:\n        # Prefer turning off lowest-density items\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        off_idxs = sorted(ones, key=lambda i: (density[i], -weights[i]))[:off_count]\n        for idx in off_idxs:\n            s_list[idx] = '0'\n\n    if on_count > 0:\n        # Prefer turning on highest-density zeros\n        density = [v\/float(w) for v, w in zip(values, weights)]\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        on_idxs = sorted(zeros, key=lambda i: (-density[i], weights[i]))[:on_count]\n        for idx in on_idxs:\n            s_list[idx] = '1'\n\n    # Final repair to ensure feasibility\n    return repair_feasible(s_list)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Solution must be a 24-length binary string or iterable of 0\/1.","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001336857}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    if solution.strip()==\"\":\n        sel = []\n    else:\n        try:\n            sel = [int(x) for x in solution.split(',') if x.strip()!=\"\"]\n        except Exception:\n            return float('inf')\n    # Validate indices and compute totals\n    w_total = 0\n    v_total = 0\n    for idx in sel:\n        if idx < 1 or idx > len(items):\n            return float('inf')\n        w,v = items[idx-1]\n        w_total += w\n        v_total += v\n    # Feasibility: weight must be at least Wmin; otherwise penalize strongly\n    if w_total < Wmin:\n        # penalty encourages reaching feasibility quickly while guiding by shortfall and value\n        return 10_000 + (Wmin - w_total)*100 + v_total\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: comma-separated 1-based indices\n    items_count = 24\n    # Parse current set\n    cur = set()\n    if solution.strip() != \"\":\n        for x in solution.split(','):\n            x=x.strip()\n            if x:\n                try:\n                    xi = int(x)\n                    if 1 <= xi <= items_count:\n                        cur.add(xi)\n                except Exception:\n                    pass\n    universe = set(range(1, items_count+1))\n    # Choose a move type with bias to feasibility exploration\n    moves = [\"ADD\",\"REMOVE\",\"SWAP\"]\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == items_count:\n        move = random.choice([\"REMOVE\",\"SWAP\"])\n    else:\n        move = random.choices(moves, weights=[0.5,0.3,0.2], k=1)[0]\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - cur)\n        if candidates:\n            k = random.choice(candidates)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(cur)\n        if candidates:\n            k = random.choice(candidates)\n            newset.remove(k)\n    else:  # SWAP\n        if cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            newset.remove(a)\n            newset.add(b)\n        else:\n            # fallback\n            if universe - cur:\n                newset.add(random.choice(list(universe - cur)))\n            elif cur:\n                newset.remove(random.choice(list(cur)))\n    # Produce canonical string (sorted, comma-separated)\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n    return new_solution, move\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Stronger random shake: perform 3-6 random ADD\/REMOVE\/SWAP moves\n    items_count = 24\n    def parse(sol):\n        s = set()\n        if sol.strip():\n            for x in sol.split(','):\n                x=x.strip()\n                if x:\n                    try:\n                        xi=int(x)\n                        if 1<=xi<=items_count:\n                            s.add(xi)\n                    except Exception:\n                        pass\n        return s\n    cur = parse(solution)\n    universe = set(range(1, items_count+1))\n    steps = random.randint(3,6)\n    for _ in range(steps):\n        move = random.choice([\"ADD\",\"REMOVE\",\"SWAP\"])\n        if move == \"ADD\" and (universe - cur):\n            cur.add(random.choice(list(universe - cur)))\n        elif move == \"REMOVE\" and cur:\n            cur.remove(random.choice(list(cur)))\n        elif move == \"SWAP\" and cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            cur.remove(a)\n            cur.add(b)\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: 'tuple' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0005879881}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    if solution.strip()==\"\":\n        sel = []\n    else:\n        try:\n            sel = [int(x) for x in solution.split(',') if x.strip()!=\"\"]\n        except Exception:\n            return float('inf')\n    # Validate indices and compute totals\n    w_total = 0\n    v_total = 0\n    for idx in sel:\n        if idx < 1 or idx > len(items):\n            return float('inf')\n        w,v = items[idx-1]\n        w_total += w\n        v_total += v\n    # Feasibility: weight must be at least Wmin; otherwise penalize strongly\n    if w_total < Wmin:\n        # penalty encourages reaching feasibility quickly while guiding by shortfall and value\n        return 10_000 + (Wmin - w_total)*100 + v_total\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: comma-separated 1-based indices\n    items_count = 24\n    # Parse current set\n    cur = set()\n    if solution.strip() != \"\":\n        for x in solution.split(','):\n            x=x.strip()\n            if x:\n                try:\n                    xi = int(x)\n                    if 1 <= xi <= items_count:\n                        cur.add(xi)\n                except Exception:\n                    pass\n    universe = set(range(1, items_count+1))\n    # Choose a move type with bias to feasibility exploration\n    moves = [\"ADD\",\"REMOVE\",\"SWAP\"]\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == items_count:\n        move = random.choice([\"REMOVE\",\"SWAP\"])\n    else:\n        move = random.choices(moves, weights=[0.5,0.3,0.2], k=1)[0]\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - cur)\n        if candidates:\n            k = random.choice(candidates)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(cur)\n        if candidates:\n            k = random.choice(candidates)\n            newset.remove(k)\n    else:  # SWAP\n        if cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            newset.remove(a)\n            newset.add(b)\n        else:\n            # fallback\n            if universe - cur:\n                newset.add(random.choice(list(universe - cur)))\n            elif cur:\n                newset.remove(random.choice(list(cur)))\n    # Produce canonical string (sorted, comma-separated)\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n    return new_solution, move\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Stronger random shake: perform 3-6 random ADD\/REMOVE\/SWAP moves\n    items_count = 24\n    def parse(sol):\n        s = set()\n        if sol.strip():\n            for x in sol.split(','):\n                x=x.strip()\n                if x:\n                    try:\n                        xi=int(x)\n                        if 1<=xi<=items_count:\n                            s.add(xi)\n                    except Exception:\n                        pass\n        return s\n    cur = parse(solution)\n    universe = set(range(1, items_count+1))\n    steps = random.randint(3,6)\n    for _ in range(steps):\n        move = random.choice([\"ADD\",\"REMOVE\",\"SWAP\"])\n        if move == \"ADD\" and (universe - cur):\n            cur.add(random.choice(list(universe - cur)))\n        elif move == \"REMOVE\" and cur:\n            cur.remove(random.choice(list(cur)))\n        elif move == \"SWAP\" and cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            cur.remove(a)\n            cur.add(b)\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: 'tuple' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.000675878}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    if solution.strip()==\"\":\n        sel = []\n    else:\n        try:\n            sel = [int(x) for x in solution.split(',') if x.strip()!=\"\"]\n        except Exception:\n            return float('inf')\n    # Validate indices and compute totals\n    w_total = 0\n    v_total = 0\n    for idx in sel:\n        if idx < 1 or idx > len(items):\n            return float('inf')\n        w,v = items[idx-1]\n        w_total += w\n        v_total += v\n    # Feasibility: weight must be at least Wmin; otherwise penalize strongly\n    if w_total < Wmin:\n        # penalty encourages reaching feasibility quickly while guiding by shortfall and value\n        return 10_000 + (Wmin - w_total)*100 + v_total\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: comma-separated 1-based indices\n    items_count = 24\n    # Parse current set\n    cur = set()\n    if solution.strip() != \"\":\n        for x in solution.split(','):\n            x=x.strip()\n            if x:\n                try:\n                    xi = int(x)\n                    if 1 <= xi <= items_count:\n                        cur.add(xi)\n                except Exception:\n                    pass\n    universe = set(range(1, items_count+1))\n    # Choose a move type with bias to feasibility exploration\n    moves = [\"ADD\",\"REMOVE\",\"SWAP\"]\n    if len(cur) == 0:\n        move = \"ADD\"\n    elif len(cur) == items_count:\n        move = random.choice([\"REMOVE\",\"SWAP\"])\n    else:\n        move = random.choices(moves, weights=[0.5,0.3,0.2], k=1)[0]\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - cur)\n        if candidates:\n            k = random.choice(candidates)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(cur)\n        if candidates:\n            k = random.choice(candidates)\n            newset.remove(k)\n    else:  # SWAP\n        if cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            newset.remove(a)\n            newset.add(b)\n        else:\n            # fallback\n            if universe - cur:\n                newset.add(random.choice(list(universe - cur)))\n            elif cur:\n                newset.remove(random.choice(list(cur)))\n    # Produce canonical string (sorted, comma-separated)\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n    return new_solution, move\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Stronger random shake: perform 3-6 random ADD\/REMOVE\/SWAP moves\n    items_count = 24\n    def parse(sol):\n        s = set()\n        if sol.strip():\n            for x in sol.split(','):\n                x=x.strip()\n                if x:\n                    try:\n                        xi=int(x)\n                        if 1<=xi<=items_count:\n                            s.add(xi)\n                    except Exception:\n                        pass\n        return s\n    cur = parse(solution)\n    universe = set(range(1, items_count+1))\n    steps = random.randint(3,6)\n    for _ in range(steps):\n        move = random.choice([\"ADD\",\"REMOVE\",\"SWAP\"])\n        if move == \"ADD\" and (universe - cur):\n            cur.add(random.choice(list(universe - cur)))\n        elif move == \"REMOVE\" and cur:\n            cur.remove(random.choice(list(cur)))\n        elif move == \"SWAP\" and cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            cur.remove(a)\n            cur.add(b)\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: 'tuple' object has no attribute 'strip'","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.000667299}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    # Type guard\n    if not isinstance(solution, str):\n        return float('inf')\n    # Parse selection\n    sel: List[int] = []\n    s = solution.strip()\n    if s:\n        try:\n            sel = [int(x) for x in s.split(',') if x.strip() != \"\"]\n        except Exception:\n            return float('inf')\n    # Validate and compute totals\n    w_total = 0\n    v_total = 0\n    seen = set()\n    for idx in sel:\n        if not (1 <= idx <= len(items)):\n            return float('inf')\n        if idx in seen:\n            # ignore duplicates by counting once\n            continue\n        seen.add(idx)\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n    # Feasibility check: weight must be at least Wmin\n    if w_total < Wmin:\n        shortfall = Wmin - w_total\n        # Penalty: scaled by shortfall; objective is minimization\n        return 10000.0 + shortfall * 100.0 + float(v_total)\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: comma-separated 1-based indices\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n    # Parse current set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            try:\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n            except Exception:\n                pass\n    # Compute current totals\n    w_total = 0\n    v_total = 0\n    for i in cur:\n        w_total += items[i - 1][0]\n        v_total += items[i - 1][1]\n    infeasible = (w_total < Wmin)\n    universe = set(range(1, n + 1))\n    # State-aware move selection\n    if infeasible:\n        # Prefer ADD and SWAP that increase weight with low value\n        move_choices = [\"ADD\", \"SWAP\"]\n        move = random.choices(move_choices, weights=[0.7, 0.3], k=1)[0]\n    else:\n        # Prefer REMOVE and SWAP to reduce total value while keeping feasible\n        move_choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        move = random.choices(move_choices, weights=[0.5, 0.4, 0.1], k=1)[0]\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - cur)\n        if candidates:\n            # Bias: low value per added weight\n            candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), items[i - 1][1]))\n            k = random.choice(candidates[:max(1, min(5, len(candidates)))])\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(cur)\n        if candidates:\n            # Prefer removing high value per weight items, but keep feasibility if possible\n            candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            # Try top few and pick one that keeps feasibility; else fall back to random\n            picked = None\n            for k in candidates[:max(1, min(5, len(candidates)))]:\n                w_rem = w_total - items[k - 1][0]\n                if w_rem >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = random.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if cur and (universe - cur):\n            out_candidates = list(cur)\n            in_candidates = list(universe - cur)\n            # Prefer swapping out high value\/low weight with in low value\/high weight\n            out_candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), items[i - 1][1]))\n            a = random.choice(out_candidates[:max(1, min(5, len(out_candidates)))])\n            b = random.choice(in_candidates[:max(1, min(5, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        else:\n            # Fallback\n            if universe - cur:\n                newset.add(random.choice(list(universe - cur)))\n            elif cur:\n                newset.discard(random.choice(list(cur)))\n    # Canonical string output\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n    return new_solution\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    n = len(items)\n    # Parse\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            try:\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n            except Exception:\n                pass\n    universe = set(range(1, n + 1))\n    # Perform 3-6 random operations\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])\n        if move == \"ADD\" and (universe - cur):\n            cur.add(random.choice(list(universe - cur)))\n        elif move == \"REMOVE\" and cur:\n            cur.discard(random.choice(list(cur)))\n        elif move == \"SWAP\" and cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            cur.discard(a)\n            cur.add(b)\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0008967121}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    # Type guard\n    if not isinstance(solution, str):\n        return float('inf')\n    # Parse selection\n    sel: List[int] = []\n    s = solution.strip()\n    if s:\n        try:\n            sel = [int(x) for x in s.split(',') if x.strip() != \"\"]\n        except Exception:\n            return float('inf')\n    # Validate and compute totals\n    w_total = 0\n    v_total = 0\n    seen = set()\n    for idx in sel:\n        if not (1 <= idx <= len(items)):\n            return float('inf')\n        if idx in seen:\n            # ignore duplicates by counting once\n            continue\n        seen.add(idx)\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n    # Feasibility check: weight must be at least Wmin\n    if w_total < Wmin:\n        shortfall = Wmin - w_total\n        # Penalty: scaled by shortfall; objective is minimization\n        return 10000.0 + shortfall * 100.0 + float(v_total)\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: comma-separated 1-based indices\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n    # Parse current set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            try:\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n            except Exception:\n                pass\n    # Compute current totals\n    w_total = 0\n    v_total = 0\n    for i in cur:\n        w_total += items[i - 1][0]\n        v_total += items[i - 1][1]\n    infeasible = (w_total < Wmin)\n    universe = set(range(1, n + 1))\n    # State-aware move selection\n    if infeasible:\n        # Prefer ADD and SWAP that increase weight with low value\n        move_choices = [\"ADD\", \"SWAP\"]\n        move = random.choices(move_choices, weights=[0.7, 0.3], k=1)[0]\n    else:\n        # Prefer REMOVE and SWAP to reduce total value while keeping feasible\n        move_choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        move = random.choices(move_choices, weights=[0.5, 0.4, 0.1], k=1)[0]\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - cur)\n        if candidates:\n            # Bias: low value per added weight\n            candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), items[i - 1][1]))\n            k = random.choice(candidates[:max(1, min(5, len(candidates)))])\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(cur)\n        if candidates:\n            # Prefer removing high value per weight items, but keep feasibility if possible\n            candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            # Try top few and pick one that keeps feasibility; else fall back to random\n            picked = None\n            for k in candidates[:max(1, min(5, len(candidates)))]:\n                w_rem = w_total - items[k - 1][0]\n                if w_rem >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = random.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if cur and (universe - cur):\n            out_candidates = list(cur)\n            in_candidates = list(universe - cur)\n            # Prefer swapping out high value\/low weight with in low value\/high weight\n            out_candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), items[i - 1][1]))\n            a = random.choice(out_candidates[:max(1, min(5, len(out_candidates)))])\n            b = random.choice(in_candidates[:max(1, min(5, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        else:\n            # Fallback\n            if universe - cur:\n                newset.add(random.choice(list(universe - cur)))\n            elif cur:\n                newset.discard(random.choice(list(cur)))\n    # Canonical string output\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n    return new_solution\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    n = len(items)\n    # Parse\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            try:\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n            except Exception:\n                pass\n    universe = set(range(1, n + 1))\n    # Perform 3-6 random operations\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])\n        if move == \"ADD\" and (universe - cur):\n            cur.add(random.choice(list(universe - cur)))\n        elif move == \"REMOVE\" and cur:\n            cur.discard(random.choice(list(cur)))\n        elif move == \"SWAP\" and cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            cur.discard(a)\n            cur.add(b)\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0010099619}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    # Type guard\n    if not isinstance(solution, str):\n        return float('inf')\n    # Parse selection\n    sel: List[int] = []\n    s = solution.strip()\n    if s:\n        try:\n            sel = [int(x) for x in s.split(',') if x.strip() != \"\"]\n        except Exception:\n            return float('inf')\n    # Validate and compute totals\n    w_total = 0\n    v_total = 0\n    seen = set()\n    for idx in sel:\n        if not (1 <= idx <= len(items)):\n            return float('inf')\n        if idx in seen:\n            # ignore duplicates by counting once\n            continue\n        seen.add(idx)\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n    # Feasibility check: weight must be at least Wmin\n    if w_total < Wmin:\n        shortfall = Wmin - w_total\n        # Penalty: scaled by shortfall; objective is minimization\n        return 10000.0 + shortfall * 100.0 + float(v_total)\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: comma-separated 1-based indices\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n    # Parse current set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            try:\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n            except Exception:\n                pass\n    # Compute current totals\n    w_total = 0\n    v_total = 0\n    for i in cur:\n        w_total += items[i - 1][0]\n        v_total += items[i - 1][1]\n    infeasible = (w_total < Wmin)\n    universe = set(range(1, n + 1))\n    # State-aware move selection\n    if infeasible:\n        # Prefer ADD and SWAP that increase weight with low value\n        move_choices = [\"ADD\", \"SWAP\"]\n        move = random.choices(move_choices, weights=[0.7, 0.3], k=1)[0]\n    else:\n        # Prefer REMOVE and SWAP to reduce total value while keeping feasible\n        move_choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        move = random.choices(move_choices, weights=[0.5, 0.4, 0.1], k=1)[0]\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - cur)\n        if candidates:\n            # Bias: low value per added weight\n            candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), items[i - 1][1]))\n            k = random.choice(candidates[:max(1, min(5, len(candidates)))])\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(cur)\n        if candidates:\n            # Prefer removing high value per weight items, but keep feasibility if possible\n            candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            # Try top few and pick one that keeps feasibility; else fall back to random\n            picked = None\n            for k in candidates[:max(1, min(5, len(candidates)))]:\n                w_rem = w_total - items[k - 1][0]\n                if w_rem >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = random.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if cur and (universe - cur):\n            out_candidates = list(cur)\n            in_candidates = list(universe - cur)\n            # Prefer swapping out high value\/low weight with in low value\/high weight\n            out_candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), items[i - 1][1]))\n            a = random.choice(out_candidates[:max(1, min(5, len(out_candidates)))])\n            b = random.choice(in_candidates[:max(1, min(5, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        else:\n            # Fallback\n            if universe - cur:\n                newset.add(random.choice(list(universe - cur)))\n            elif cur:\n                newset.discard(random.choice(list(cur)))\n    # Canonical string output\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n    return new_solution\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    items: List[Tuple[int,int]] = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    n = len(items)\n    # Parse\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            try:\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n            except Exception:\n                pass\n    universe = set(range(1, n + 1))\n    # Perform 3-6 random operations\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.choice([\"ADD\", \"REMOVE\", \"SWAP\"])\n        if move == \"ADD\" and (universe - cur):\n            cur.add(random.choice(list(universe - cur)))\n        elif move == \"REMOVE\" and cur:\n            cur.discard(random.choice(list(cur)))\n        elif move == \"SWAP\" and cur and (universe - cur):\n            a = random.choice(list(cur))\n            b = random.choice(list(universe - cur))\n            cur.discard(a)\n            cur.add(b)\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.001000223}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    # Type and parsing guard\n    if not isinstance(solution, str):\n        return float('inf')\n    s = solution.strip()\n    sel = []\n    if s:\n        parts = [x.strip() for x in s.split(',') if x.strip() != \"\"]\n        # Fast path: ensure all tokens are integer-like\n        for tok in parts:\n            if not (tok.lstrip('-').isdigit()):\n                return float('inf')\n            sel.append(int(tok))\n    # Validate unique indices and compute totals\n    w_total = 0\n    v_total = 0\n    n = len(items)\n    seen = set()\n    for idx in sel:\n        if not (1 <= idx <= n):\n            return float('inf')\n        if idx in seen:\n            continue\n        seen.add(idx)\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n    # Feasibility check: weight must be at least Wmin\n    if w_total < Wmin:\n        # Soft penalty that grows with shortfall; objective is minimization\n        shortfall = Wmin - w_total\n        return 1000.0 + shortfall * 50.0 + float(v_total)\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse current solution into a set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def totals_from_set(s):\n        w = 0\n        v = 0\n        for i in s:\n            wi, vi = items[i - 1]\n            w += wi\n            v += vi\n        return w, v\n\n    w_total, v_total = totals_from_set(cur)\n    infeasible = (w_total < Wmin)\n\n    # Choose move type with state-aware bias\n    if infeasible:\n        move_choices = [\"ADD\", \"SWAP\"]\n        weights = [0.75, 0.25]\n    else:\n        move_choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        weights = [0.6, 0.35, 0.05]\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - newset)\n        if candidates:\n            # Prefer low value per weight, tie-break by larger weight then lower value\n            candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n            pick_pool = candidates[:max(1, min(6, len(candidates)))]\n            k = random.choice(pick_pool)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(newset)\n        if candidates:\n            # Prefer removing high value per weight\n            candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            picked = None\n            # Try to preserve feasibility\n            for k in candidates[:max(1, min(6, len(candidates)))]:\n                w_after = w_total - items[k - 1][0]\n                if w_after >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = random.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if newset and (universe - newset):\n            out_candidates = list(newset)\n            in_candidates = list(universe - newset)\n            out_candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n            a = random.choice(out_candidates[:max(1, min(6, len(out_candidates)))])\n            b = random.choice(in_candidates[:max(1, min(6, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        else:\n            if universe - newset:\n                newset.add(random.choice(list(universe - newset)))\n            elif newset:\n                newset.discard(random.choice(list(newset)))\n\n    # Feasibility repair: if underweight, greedily add lowest v\/w until feasible\n    def greedy_repair(s):\n        w, v = totals_from_set(s)\n        if w >= Wmin:\n            return s\n        candidates = sorted(list(universe - s), key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n        for i in candidates:\n            s.add(i)\n            w += items[i - 1][0]\n            if w >= Wmin:\n                break\n        return s\n\n    newset = greedy_repair(newset)\n\n    # Canonical string encoding\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n\n    return new_solution, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse input\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    # Rank items by value\/weight\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    # Decide shake strength r\n    r = random.randint(1, 3)\n\n    # Remove up to r items with highest v\/w (if present)\n    present = sorted(list(cur), key=lambda i: (-vw(i), -items[i - 1][1]))\n    for i in present[:min(r, len(present))]:\n        cur.discard(i)\n\n    # Add up to r items with lowest v\/w (not already selected)\n    candidates = sorted(list(universe - cur), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n    for i in candidates[:min(r, len(candidates))]:\n        cur.add(i)\n\n    # Repair to feasibility if needed by adding more low v\/w items\n    def total_w(s):\n        w = 0\n        for i in s:\n            w += items[i - 1][0]\n        return w\n\n    if total_w(cur) < Wmin:\n        for i in candidates[min(r, len(candidates)):]:\n            cur.add(i)\n            if total_w(cur) >= Wmin:\n                break\n\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":["5,9,13,21",19.0,"5,9,13,21",19.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001706582}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    # Type and parsing guard\n    if not isinstance(solution, str):\n        return float('inf')\n    s = solution.strip()\n    sel = []\n    if s:\n        parts = [x.strip() for x in s.split(',') if x.strip() != \"\"]\n        # Fast path: ensure all tokens are integer-like\n        for tok in parts:\n            if not (tok.lstrip('-').isdigit()):\n                return float('inf')\n            sel.append(int(tok))\n    # Validate unique indices and compute totals\n    w_total = 0\n    v_total = 0\n    n = len(items)\n    seen = set()\n    for idx in sel:\n        if not (1 <= idx <= n):\n            return float('inf')\n        if idx in seen:\n            continue\n        seen.add(idx)\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n    # Feasibility check: weight must be at least Wmin\n    if w_total < Wmin:\n        # Soft penalty that grows with shortfall; objective is minimization\n        shortfall = Wmin - w_total\n        return 1000.0 + shortfall * 50.0 + float(v_total)\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse current solution into a set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def totals_from_set(s):\n        w = 0\n        v = 0\n        for i in s:\n            wi, vi = items[i - 1]\n            w += wi\n            v += vi\n        return w, v\n\n    w_total, v_total = totals_from_set(cur)\n    infeasible = (w_total < Wmin)\n\n    # Choose move type with state-aware bias\n    if infeasible:\n        move_choices = [\"ADD\", \"SWAP\"]\n        weights = [0.75, 0.25]\n    else:\n        move_choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        weights = [0.6, 0.35, 0.05]\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - newset)\n        if candidates:\n            # Prefer low value per weight, tie-break by larger weight then lower value\n            candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n            pick_pool = candidates[:max(1, min(6, len(candidates)))]\n            k = random.choice(pick_pool)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(newset)\n        if candidates:\n            # Prefer removing high value per weight\n            candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            picked = None\n            # Try to preserve feasibility\n            for k in candidates[:max(1, min(6, len(candidates)))]:\n                w_after = w_total - items[k - 1][0]\n                if w_after >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = random.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if newset and (universe - newset):\n            out_candidates = list(newset)\n            in_candidates = list(universe - newset)\n            out_candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n            a = random.choice(out_candidates[:max(1, min(6, len(out_candidates)))])\n            b = random.choice(in_candidates[:max(1, min(6, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        else:\n            if universe - newset:\n                newset.add(random.choice(list(universe - newset)))\n            elif newset:\n                newset.discard(random.choice(list(newset)))\n\n    # Feasibility repair: if underweight, greedily add lowest v\/w until feasible\n    def greedy_repair(s):\n        w, v = totals_from_set(s)\n        if w >= Wmin:\n            return s\n        candidates = sorted(list(universe - s), key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n        for i in candidates:\n            s.add(i)\n            w += items[i - 1][0]\n            if w >= Wmin:\n                break\n        return s\n\n    newset = greedy_repair(newset)\n\n    # Canonical string encoding\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n\n    return new_solution, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse input\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    # Rank items by value\/weight\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    # Decide shake strength r\n    r = random.randint(1, 3)\n\n    # Remove up to r items with highest v\/w (if present)\n    present = sorted(list(cur), key=lambda i: (-vw(i), -items[i - 1][1]))\n    for i in present[:min(r, len(present))]:\n        cur.discard(i)\n\n    # Add up to r items with lowest v\/w (not already selected)\n    candidates = sorted(list(universe - cur), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n    for i in candidates[:min(r, len(candidates))]:\n        cur.add(i)\n\n    # Repair to feasibility if needed by adding more low v\/w items\n    def total_w(s):\n        w = 0\n        for i in s:\n            w += items[i - 1][0]\n        return w\n\n    if total_w(cur) < Wmin:\n        for i in candidates[min(r, len(candidates)):]:\n            cur.add(i)\n            if total_w(cur) >= Wmin:\n                break\n\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":["5,6,9,13,21",19.0,[5,7,9,13],19.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.002222299}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    # Type and parsing guard\n    if not isinstance(solution, str):\n        return float('inf')\n    s = solution.strip()\n    sel = []\n    if s:\n        parts = [x.strip() for x in s.split(',') if x.strip() != \"\"]\n        # Fast path: ensure all tokens are integer-like\n        for tok in parts:\n            if not (tok.lstrip('-').isdigit()):\n                return float('inf')\n            sel.append(int(tok))\n    # Validate unique indices and compute totals\n    w_total = 0\n    v_total = 0\n    n = len(items)\n    seen = set()\n    for idx in sel:\n        if not (1 <= idx <= n):\n            return float('inf')\n        if idx in seen:\n            continue\n        seen.add(idx)\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n    # Feasibility check: weight must be at least Wmin\n    if w_total < Wmin:\n        # Soft penalty that grows with shortfall; objective is minimization\n        shortfall = Wmin - w_total\n        return 1000.0 + shortfall * 50.0 + float(v_total)\n    # Objective: minimize total value\n    return float(v_total)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse current solution into a set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def totals_from_set(s):\n        w = 0\n        v = 0\n        for i in s:\n            wi, vi = items[i - 1]\n            w += wi\n            v += vi\n        return w, v\n\n    w_total, v_total = totals_from_set(cur)\n    infeasible = (w_total < Wmin)\n\n    # Choose move type with state-aware bias\n    if infeasible:\n        move_choices = [\"ADD\", \"SWAP\"]\n        weights = [0.75, 0.25]\n    else:\n        move_choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        weights = [0.6, 0.35, 0.05]\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    newset = set(cur)\n    if move == \"ADD\":\n        candidates = list(universe - newset)\n        if candidates:\n            # Prefer low value per weight, tie-break by larger weight then lower value\n            candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n            pick_pool = candidates[:max(1, min(6, len(candidates)))]\n            k = random.choice(pick_pool)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(newset)\n        if candidates:\n            # Prefer removing high value per weight\n            candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            picked = None\n            # Try to preserve feasibility\n            for k in candidates[:max(1, min(6, len(candidates)))]:\n                w_after = w_total - items[k - 1][0]\n                if w_after >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = random.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if newset and (universe - newset):\n            out_candidates = list(newset)\n            in_candidates = list(universe - newset)\n            out_candidates.sort(key=lambda i: (-items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n            a = random.choice(out_candidates[:max(1, min(6, len(out_candidates)))])\n            b = random.choice(in_candidates[:max(1, min(6, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        else:\n            if universe - newset:\n                newset.add(random.choice(list(universe - newset)))\n            elif newset:\n                newset.discard(random.choice(list(newset)))\n\n    # Feasibility repair: if underweight, greedily add lowest v\/w until feasible\n    def greedy_repair(s):\n        w, v = totals_from_set(s)\n        if w >= Wmin:\n            return s\n        candidates = sorted(list(universe - s), key=lambda i: (items[i - 1][1] \/ max(1, items[i - 1][0]), -items[i - 1][0], items[i - 1][1]))\n        for i in candidates:\n            s.add(i)\n            w += items[i - 1][0]\n            if w >= Wmin:\n                break\n        return s\n\n    newset = greedy_repair(newset)\n\n    # Canonical string encoding\n    if not newset:\n        new_solution = \"\"\n    else:\n        new_solution = \",\".join(str(i) for i in sorted(newset))\n\n    return new_solution, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse input\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    # Rank items by value\/weight\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    # Decide shake strength r\n    r = random.randint(1, 3)\n\n    # Remove up to r items with highest v\/w (if present)\n    present = sorted(list(cur), key=lambda i: (-vw(i), -items[i - 1][1]))\n    for i in present[:min(r, len(present))]:\n        cur.discard(i)\n\n    # Add up to r items with lowest v\/w (not already selected)\n    candidates = sorted(list(universe - cur), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n    for i in candidates[:min(r, len(candidates))]:\n        cur.add(i)\n\n    # Repair to feasibility if needed by adding more low v\/w items\n    def total_w(s):\n        w = 0\n        for i in s:\n            w += items[i - 1][0]\n        return w\n\n    if total_w(cur) < Wmin:\n        for i in candidates[min(r, len(candidates)):]:\n            cur.add(i)\n            if total_w(cur) >= Wmin:\n                break\n\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0011619449}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED_SORTED_UNIQUE","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Type guard\n    if not isinstance(solution, str):\n        return float('inf')\n\n    # Parse and canonicalize\n    s = solution.strip()\n    sel = []\n    if s:\n        parts = [x.strip() for x in s.split(',') if x.strip() != \"\"]\n        for tok in parts:\n            if not tok.lstrip('-').isdigit():\n                return float('inf')\n            sel.append(int(tok))\n    # Enforce domain and uniqueness by set\n    sel_set = set()\n    for idx in sel:\n        if not (1 <= idx <= n):\n            return float('inf')\n        sel_set.add(idx)\n\n    # Totals\n    w_total = 0\n    v_total = 0\n    for idx in sel_set:\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n\n    if w_total < Wmin:\n        # Adaptive soft penalty: encourage moving toward feasibility\n        # Base uses median weight and average value\n        weights = [w for (w, _) in items]\n        values = [v for (_, v) in items]\n        median_w = sorted(weights)[len(weights)\/\/2]\n        avg_v = sum(values) \/ len(values)\n        shortfall = Wmin - w_total\n        penalty = 3.0 * avg_v + shortfall * (0.8 * median_w)\n        return float(v_total + penalty)\n\n    # Feasible: minimize total value\n    return float(v_total)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse solution into a set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    def totals(s):\n        w = 0\n        v = 0\n        for i in s:\n            wi, vi = items[i - 1]\n            w += wi\n            v += vi\n        return w, v\n\n    w_total, _ = totals(cur)\n    infeasible = w_total < Wmin\n\n    # State-aware move choice\n    rng = random\n    if infeasible:\n        choices = [\"ADD\", \"SWAP\"]\n        weights = [0.75, 0.25]\n    else:\n        choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        weights = [0.55, 0.35, 0.10]\n    move = rng.choices(choices, weights=weights, k=1)[0]\n\n    newset = set(cur)\n\n    if move == \"ADD\":\n        candidates = list(universe - newset)\n        if candidates:\n            candidates.sort(key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n            pool = candidates[:max(1, min(6, len(candidates)))]\n            k = rng.choice(pool)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(newset)\n        if candidates:\n            candidates.sort(key=lambda i: (-vw(i), -items[i - 1][1]))\n            picked = None\n            w_cur, _ = totals(newset)\n            for k in candidates:\n                if w_cur - items[k - 1][0] >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = rng.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if newset and (universe - newset):\n            out_candidates = list(newset)\n            in_candidates = list(universe - newset)\n            out_candidates.sort(key=lambda i: (-vw(i), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n            a = rng.choice(out_candidates[:max(1, min(6, len(out_candidates)))])\n            b = rng.choice(in_candidates[:max(1, min(6, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        elif universe - newset:\n            newset.add(rng.choice(list(universe - newset)))\n        elif newset:\n            newset.discard(rng.choice(list(newset)))\n\n    # Greedy feasibility repair if underweight\n    def repair(s):\n        wt, _ = totals(s)\n        if wt >= Wmin:\n            return s\n        cand = sorted(list(universe - s), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n        for i in cand:\n            s.add(i)\n            wt += items[i - 1][0]\n            if wt >= Wmin:\n                break\n        return s\n\n    newset = repair(newset)\n\n    # Canonical encoding: sorted unique CSV\n    new_solution = \",\".join(str(i) for i in sorted(newset)) if newset else \"\"\n    return new_solution, move\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse input set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    rng = random\n\n    # Heavy-tail shake size k in [1..6]\n    k = min(6, 1 + int(1.0 \/ max(1e-9, rng.random())))\n\n    # Remove up to k items with highest v\/w\n    present = sorted(list(cur), key=lambda i: (-vw(i), -items[i - 1][1]))\n    for i in present[:min(k, len(present))]:\n        cur.discard(i)\n\n    # Add up to k items with lowest v\/w\n    candidates = sorted(list(universe - cur), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n    for i in candidates[:min(k, len(candidates))]:\n        cur.add(i)\n\n    # Repair feasibility if needed by adding more low v\/w items\n    def total_w(s):\n        w = 0\n        for i in s:\n            w += items[i - 1][0]\n        return w\n\n    if total_w(cur) < Wmin:\n        for i in candidates[min(k, len(candidates)):]:\n            cur.add(i)\n            if total_w(cur) >= Wmin:\n                break\n\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":["8,9,21,23",21.0,"5,9,13,21",19.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.001737593}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED_SORTED_UNIQUE","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Type guard\n    if not isinstance(solution, str):\n        return float('inf')\n\n    # Parse and canonicalize\n    s = solution.strip()\n    sel = []\n    if s:\n        parts = [x.strip() for x in s.split(',') if x.strip() != \"\"]\n        for tok in parts:\n            if not tok.lstrip('-').isdigit():\n                return float('inf')\n            sel.append(int(tok))\n    # Enforce domain and uniqueness by set\n    sel_set = set()\n    for idx in sel:\n        if not (1 <= idx <= n):\n            return float('inf')\n        sel_set.add(idx)\n\n    # Totals\n    w_total = 0\n    v_total = 0\n    for idx in sel_set:\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n\n    if w_total < Wmin:\n        # Adaptive soft penalty: encourage moving toward feasibility\n        # Base uses median weight and average value\n        weights = [w for (w, _) in items]\n        values = [v for (_, v) in items]\n        median_w = sorted(weights)[len(weights)\/\/2]\n        avg_v = sum(values) \/ len(values)\n        shortfall = Wmin - w_total\n        penalty = 3.0 * avg_v + shortfall * (0.8 * median_w)\n        return float(v_total + penalty)\n\n    # Feasible: minimize total value\n    return float(v_total)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse solution into a set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    def totals(s):\n        w = 0\n        v = 0\n        for i in s:\n            wi, vi = items[i - 1]\n            w += wi\n            v += vi\n        return w, v\n\n    w_total, _ = totals(cur)\n    infeasible = w_total < Wmin\n\n    # State-aware move choice\n    rng = random\n    if infeasible:\n        choices = [\"ADD\", \"SWAP\"]\n        weights = [0.75, 0.25]\n    else:\n        choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        weights = [0.55, 0.35, 0.10]\n    move = rng.choices(choices, weights=weights, k=1)[0]\n\n    newset = set(cur)\n\n    if move == \"ADD\":\n        candidates = list(universe - newset)\n        if candidates:\n            candidates.sort(key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n            pool = candidates[:max(1, min(6, len(candidates)))]\n            k = rng.choice(pool)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(newset)\n        if candidates:\n            candidates.sort(key=lambda i: (-vw(i), -items[i - 1][1]))\n            picked = None\n            w_cur, _ = totals(newset)\n            for k in candidates:\n                if w_cur - items[k - 1][0] >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = rng.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if newset and (universe - newset):\n            out_candidates = list(newset)\n            in_candidates = list(universe - newset)\n            out_candidates.sort(key=lambda i: (-vw(i), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n            a = rng.choice(out_candidates[:max(1, min(6, len(out_candidates)))])\n            b = rng.choice(in_candidates[:max(1, min(6, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        elif universe - newset:\n            newset.add(rng.choice(list(universe - newset)))\n        elif newset:\n            newset.discard(rng.choice(list(newset)))\n\n    # Greedy feasibility repair if underweight\n    def repair(s):\n        wt, _ = totals(s)\n        if wt >= Wmin:\n            return s\n        cand = sorted(list(universe - s), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n        for i in cand:\n            s.add(i)\n            wt += items[i - 1][0]\n            if wt >= Wmin:\n                break\n        return s\n\n    newset = repair(newset)\n\n    # Canonical encoding: sorted unique CSV\n    new_solution = \",\".join(str(i) for i in sorted(newset)) if newset else \"\"\n    return new_solution, move\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse input set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    rng = random\n\n    # Heavy-tail shake size k in [1..6]\n    k = min(6, 1 + int(1.0 \/ max(1e-9, rng.random())))\n\n    # Remove up to k items with highest v\/w\n    present = sorted(list(cur), key=lambda i: (-vw(i), -items[i - 1][1]))\n    for i in present[:min(k, len(present))]:\n        cur.discard(i)\n\n    # Add up to k items with lowest v\/w\n    candidates = sorted(list(universe - cur), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n    for i in candidates[:min(k, len(candidates))]:\n        cur.add(i)\n\n    # Repair feasibility if needed by adding more low v\/w items\n    def total_w(s):\n        w = 0\n        for i in s:\n            w += items[i - 1][0]\n        return w\n\n    if total_w(cur) < Wmin:\n        for i in candidates[min(k, len(candidates)):]:\n            cur.add(i)\n            if total_w(cur) >= Wmin:\n                break\n\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":["5,9,13,21,23",21.0,"5,9,13,21",19.0],"Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0023639901}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"COMMA_SEPARATED_ITEM_INDICES_1_BASED_SORTED_UNIQUE","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data: (weight, value) for items 1..24\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Type guard\n    if not isinstance(solution, str):\n        return float('inf')\n\n    # Parse and canonicalize\n    s = solution.strip()\n    sel = []\n    if s:\n        parts = [x.strip() for x in s.split(',') if x.strip() != \"\"]\n        for tok in parts:\n            if not tok.lstrip('-').isdigit():\n                return float('inf')\n            sel.append(int(tok))\n    # Enforce domain and uniqueness by set\n    sel_set = set()\n    for idx in sel:\n        if not (1 <= idx <= n):\n            return float('inf')\n        sel_set.add(idx)\n\n    # Totals\n    w_total = 0\n    v_total = 0\n    for idx in sel_set:\n        w, v = items[idx - 1]\n        w_total += w\n        v_total += v\n\n    if w_total < Wmin:\n        # Adaptive soft penalty: encourage moving toward feasibility\n        # Base uses median weight and average value\n        weights = [w for (w, _) in items]\n        values = [v for (_, v) in items]\n        median_w = sorted(weights)[len(weights)\/\/2]\n        avg_v = sum(values) \/ len(values)\n        shortfall = Wmin - w_total\n        penalty = 3.0 * avg_v + shortfall * (0.8 * median_w)\n        return float(v_total + penalty)\n\n    # Feasible: minimize total value\n    return float(v_total)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse solution into a set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    def totals(s):\n        w = 0\n        v = 0\n        for i in s:\n            wi, vi = items[i - 1]\n            w += wi\n            v += vi\n        return w, v\n\n    w_total, _ = totals(cur)\n    infeasible = w_total < Wmin\n\n    # State-aware move choice\n    rng = random\n    if infeasible:\n        choices = [\"ADD\", \"SWAP\"]\n        weights = [0.75, 0.25]\n    else:\n        choices = [\"REMOVE\", \"SWAP\", \"ADD\"]\n        weights = [0.55, 0.35, 0.10]\n    move = rng.choices(choices, weights=weights, k=1)[0]\n\n    newset = set(cur)\n\n    if move == \"ADD\":\n        candidates = list(universe - newset)\n        if candidates:\n            candidates.sort(key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n            pool = candidates[:max(1, min(6, len(candidates)))]\n            k = rng.choice(pool)\n            newset.add(k)\n    elif move == \"REMOVE\":\n        candidates = list(newset)\n        if candidates:\n            candidates.sort(key=lambda i: (-vw(i), -items[i - 1][1]))\n            picked = None\n            w_cur, _ = totals(newset)\n            for k in candidates:\n                if w_cur - items[k - 1][0] >= Wmin:\n                    picked = k\n                    break\n            if picked is None:\n                picked = rng.choice(candidates)\n            newset.discard(picked)\n    else:  # SWAP\n        if newset and (universe - newset):\n            out_candidates = list(newset)\n            in_candidates = list(universe - newset)\n            out_candidates.sort(key=lambda i: (-vw(i), -items[i - 1][1]))\n            in_candidates.sort(key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n            a = rng.choice(out_candidates[:max(1, min(6, len(out_candidates)))])\n            b = rng.choice(in_candidates[:max(1, min(6, len(in_candidates)))])\n            newset.discard(a)\n            newset.add(b)\n        elif universe - newset:\n            newset.add(rng.choice(list(universe - newset)))\n        elif newset:\n            newset.discard(rng.choice(list(newset)))\n\n    # Greedy feasibility repair if underweight\n    def repair(s):\n        wt, _ = totals(s)\n        if wt >= Wmin:\n            return s\n        cand = sorted(list(universe - s), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n        for i in cand:\n            s.add(i)\n            wt += items[i - 1][0]\n            if wt >= Wmin:\n                break\n        return s\n\n    newset = repair(newset)\n\n    # Canonical encoding: sorted unique CSV\n    new_solution = \",\".join(str(i) for i in sorted(newset)) if newset else \"\"\n    return new_solution, move\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    items = [\n        (11,19),(23,21),(22,22),(10,13),(17,1),(20,9),(11,7),(24,10),\n        (19,4),(8,11),(14,11),(20,12),(22,6),(16,15),(13,17),(5,8),\n        (4,13),(22,11),(23,24),(9,10),(22,8),(6,18),(20,8),(10,9)\n    ]\n    Wmin = 67\n    n = len(items)\n\n    # Parse input set\n    cur = set()\n    if isinstance(solution, str) and solution.strip():\n        for x in solution.split(','):\n            x = x.strip()\n            if not x:\n                continue\n            if x.lstrip('-').isdigit():\n                xi = int(x)\n                if 1 <= xi <= n:\n                    cur.add(xi)\n    universe = set(range(1, n + 1))\n\n    def vw(i):\n        w, v = items[i - 1]\n        return v \/ max(1, w)\n\n    rng = random\n\n    # Heavy-tail shake size k in [1..6]\n    k = min(6, 1 + int(1.0 \/ max(1e-9, rng.random())))\n\n    # Remove up to k items with highest v\/w\n    present = sorted(list(cur), key=lambda i: (-vw(i), -items[i - 1][1]))\n    for i in present[:min(k, len(present))]:\n        cur.discard(i)\n\n    # Add up to k items with lowest v\/w\n    candidates = sorted(list(universe - cur), key=lambda i: (vw(i), -items[i - 1][0], items[i - 1][1]))\n    for i in candidates[:min(k, len(candidates))]:\n        cur.add(i)\n\n    # Repair feasibility if needed by adding more low v\/w items\n    def total_w(s):\n        w = 0\n        for i in s:\n            w += items[i - 1][0]\n        return w\n\n    if total_w(cur) < Wmin:\n        for i in candidates[min(k, len(candidates)):]:\n            cur.add(i)\n            if total_w(cur) >= Wmin:\n                break\n\n    return \",\".join(str(i) for i in sorted(cur))\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0013288871}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR: length=24. solution[i] in {'0','1'} indicates selecting decoration i+1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Data encoded internally\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n    # Penalize infeasible solutions heavily; lesser fitness is better\n    shortfall = budget_min - total_cost\n    return 1e6 + shortfall + total_points\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Single-bit flip neighbor\n    n = len(solution)\n    if n == 0:\n        return solution, \"bit_flip\", \"single_index\"\n    idx = random.randrange(n)\n    lst = list(solution)\n    lst[idx] = '0' if lst[idx] == '1' else '1'\n    new_solution = ''.join(lst)\n    return new_solution, \"bit_flip\", \"single_index\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k distinct bits (k in [2, min(6, n)])\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = min(max(2, n \/\/ 12), min(6, n))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for idx in idxs:\n        lst[idx] = '0' if lst[idx] == '1' else '1'\n    return ''.join(lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001935}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR: length=24. solution[i] in {'0','1'} indicates selecting decoration i+1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Data encoded internally\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n    # Penalize infeasible solutions heavily; lesser fitness is better\n    shortfall = budget_min - total_cost\n    return 1e6 + shortfall + total_points\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Single-bit flip neighbor\n    n = len(solution)\n    if n == 0:\n        return solution, \"bit_flip\", \"single_index\"\n    idx = random.randrange(n)\n    lst = list(solution)\n    lst[idx] = '0' if lst[idx] == '1' else '1'\n    new_solution = ''.join(lst)\n    return new_solution, \"bit_flip\", \"single_index\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k distinct bits (k in [2, min(6, n)])\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = min(max(2, n \/\/ 12), min(6, n))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for idx in idxs:\n        lst[idx] = '0' if lst[idx] == '1' else '1'\n    return ''.join(lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000469}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR: length=24. solution[i] in {'0','1'} indicates selecting decoration i+1.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Data encoded internally\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n    # Penalize infeasible solutions heavily; lesser fitness is better\n    shortfall = budget_min - total_cost\n    return 1e6 + shortfall + total_points\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Single-bit flip neighbor\n    n = len(solution)\n    if n == 0:\n        return solution, \"bit_flip\", \"single_index\"\n    idx = random.randrange(n)\n    lst = list(solution)\n    lst[idx] = '0' if lst[idx] == '1' else '1'\n    new_solution = ''.join(lst)\n    return new_solution, \"bit_flip\", \"single_index\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k distinct bits (k in [2, min(6, n)])\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = min(max(2, n \/\/ 12), min(6, n))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for idx in idxs:\n        lst[idx] = '0' if lst[idx] == '1' else '1'\n    return ''.join(lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.00000301}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Scaled penalty: prioritize meeting budget while keeping search dynamics reasonable\n    shortfall = budget_min - total_cost\n    penalty_lambda = 1000.0\n    return float(total_points + penalty_lambda * shortfall)","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Mixed neighborhood: bit flip, 2-bit flip, and 1-1 swap\n    n = len(solution)\n    if n == 0:\n        return solution, \"noop\"\n\n    rng = random.random()\n    s_list = list(solution)\n\n    if rng < 1\/3:\n        # Single bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"bit_flip\"\n    elif rng < 2\/3:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"two_bit_flip\"\n    else:\n        # 1-1 swap: flip one '1' to '0' and one '0' to '1' if possible; otherwise fallback to single flip\n        ones = [i for i,ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i,ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            s_list[i1] = '0'\n            s_list[i0] = '1'\n            return ''.join(s_list), \"one_one_swap\"\n        else:\n            idx = random.randrange(n)\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n            return ''.join(s_list), \"bit_flip_fallback\"","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # k-bit random flips with adaptive range\n    n = len(solution)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = min(6, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    return ''.join(s_list)","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.000014401}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Scaled penalty: prioritize meeting budget while keeping search dynamics reasonable\n    shortfall = budget_min - total_cost\n    penalty_lambda = 1000.0\n    return float(total_points + penalty_lambda * shortfall)","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Mixed neighborhood: bit flip, 2-bit flip, and 1-1 swap\n    n = len(solution)\n    if n == 0:\n        return solution, \"noop\"\n\n    rng = random.random()\n    s_list = list(solution)\n\n    if rng < 1\/3:\n        # Single bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"bit_flip\"\n    elif rng < 2\/3:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"two_bit_flip\"\n    else:\n        # 1-1 swap: flip one '1' to '0' and one '0' to '1' if possible; otherwise fallback to single flip\n        ones = [i for i,ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i,ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            s_list[i1] = '0'\n            s_list[i0] = '1'\n            return ''.join(s_list), \"one_one_swap\"\n        else:\n            idx = random.randrange(n)\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n            return ''.join(s_list), \"bit_flip_fallback\"","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # k-bit random flips with adaptive range\n    n = len(solution)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = min(6, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    return ''.join(s_list)","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0000043999}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Scaled penalty: prioritize meeting budget while keeping search dynamics reasonable\n    shortfall = budget_min - total_cost\n    penalty_lambda = 1000.0\n    return float(total_points + penalty_lambda * shortfall)","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Mixed neighborhood: bit flip, 2-bit flip, and 1-1 swap\n    n = len(solution)\n    if n == 0:\n        return solution, \"noop\"\n\n    rng = random.random()\n    s_list = list(solution)\n\n    if rng < 1\/3:\n        # Single bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"bit_flip\"\n    elif rng < 2\/3:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"two_bit_flip\"\n    else:\n        # 1-1 swap: flip one '1' to '0' and one '0' to '1' if possible; otherwise fallback to single flip\n        ones = [i for i,ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i,ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            s_list[i1] = '0'\n            s_list[i0] = '1'\n            return ''.join(s_list), \"one_one_swap\"\n        else:\n            idx = random.randrange(n)\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n            return ''.join(s_list), \"bit_flip_fallback\"","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # k-bit random flips with adaptive range\n    n = len(solution)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = min(6, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    return ''.join(s_list)","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.00000285}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Penalty for infeasibility (shortfall from budget)\n    shortfall = budget_min - total_cost\n    # Use a scaled penalty tied to average points per cost to keep gradients reasonable\n    avg_ppc = (sum(points) \/ sum(costs))\n    penalty_lambda = 200.0 * avg_ppc\n    return float(total_points + penalty_lambda * shortfall)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Mixed neighborhood: bit flip, 2-bit flip, and 1-1 swap\n    n = len(solution)\n    if n == 0:\n        return solution, \"noop\"\n\n    rng = random.random()\n    s_list = list(solution)\n\n    if rng < 1\/3:\n        # Single bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"bit_flip\"\n    elif rng < 2\/3:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"two_bit_flip\"\n    else:\n        # 1-1 swap: flip one '1' to '0' and one '0' to '1' if possible; otherwise fallback to single flip\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            s_list[i1] = '0'\n            s_list[i0] = '1'\n            return ''.join(s_list), \"one_one_swap\"\n        else:\n            idx = random.randrange(n)\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n            return ''.join(s_list), \"bit_flip_fallback\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # k-bit random flips with feasibility repair to enforce cost >= budget\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    def totals(bitstr: str):\n        tc = 0\n        tp = 0\n        for i, ch in enumerate(bitstr):\n            if ch == '1':\n                tc += costs[i]\n                tp += points[i]\n        return tc, tp\n\n    def repair(bitstr: str) -> str:\n        # If feasible, try a light prune-insert to reduce points while staying feasible\n        s = list(bitstr)\n        tc, tp = totals(bitstr)\n        if tc >= budget_min:\n            # Attempt one improving swap: remove highest points\/cost item, insert lowest points\/cost item from zeros if keeps feasibility and reduces points\n            ppc = [points[i]\/costs[i] for i in range(n)]\n            ones = [i for i,ch in enumerate(s) if ch=='1']\n            zeros = [i for i,ch in enumerate(s) if ch=='0']\n            if ones and zeros:\n                remove = max(ones, key=lambda i: ppc[i])\n                best_gain = 0\n                best_add = None\n                for j in zeros:\n                    new_tc = tc - costs[remove] + costs[j]\n                    new_tp = tp - points[remove] + points[j]\n                    if new_tc >= budget_min and new_tp < tp and (tp - new_tp) > best_gain:\n                        best_gain = tp - new_tp\n                        best_add = j\n                if best_add is not None:\n                    s[remove] = '0'\n                    s[best_add] = '1'\n            return ''.join(s)\n        # If infeasible, greedily add items by ascending points per cost until feasible\n        ppc = [(points[i]\/costs[i], i) for i in range(n) if s[i]=='0']\n        ppc.sort()\n        for _, i in ppc:\n            s[i] = '1'\n            tc += costs[i]\n            if tc >= budget_min:\n                break\n        return ''.join(s)\n\n    # Perform k-bit flips with adaptive k\n    k_min = 3\n    k_max = min(7, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    candidate = ''.join(s_list)\n    return repair(candidate)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001458}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Penalty for infeasibility (shortfall from budget)\n    shortfall = budget_min - total_cost\n    # Use a scaled penalty tied to average points per cost to keep gradients reasonable\n    avg_ppc = (sum(points) \/ sum(costs))\n    penalty_lambda = 200.0 * avg_ppc\n    return float(total_points + penalty_lambda * shortfall)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Mixed neighborhood: bit flip, 2-bit flip, and 1-1 swap\n    n = len(solution)\n    if n == 0:\n        return solution, \"noop\"\n\n    rng = random.random()\n    s_list = list(solution)\n\n    if rng < 1\/3:\n        # Single bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"bit_flip\"\n    elif rng < 2\/3:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"two_bit_flip\"\n    else:\n        # 1-1 swap: flip one '1' to '0' and one '0' to '1' if possible; otherwise fallback to single flip\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            s_list[i1] = '0'\n            s_list[i0] = '1'\n            return ''.join(s_list), \"one_one_swap\"\n        else:\n            idx = random.randrange(n)\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n            return ''.join(s_list), \"bit_flip_fallback\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # k-bit random flips with feasibility repair to enforce cost >= budget\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    def totals(bitstr: str):\n        tc = 0\n        tp = 0\n        for i, ch in enumerate(bitstr):\n            if ch == '1':\n                tc += costs[i]\n                tp += points[i]\n        return tc, tp\n\n    def repair(bitstr: str) -> str:\n        # If feasible, try a light prune-insert to reduce points while staying feasible\n        s = list(bitstr)\n        tc, tp = totals(bitstr)\n        if tc >= budget_min:\n            # Attempt one improving swap: remove highest points\/cost item, insert lowest points\/cost item from zeros if keeps feasibility and reduces points\n            ppc = [points[i]\/costs[i] for i in range(n)]\n            ones = [i for i,ch in enumerate(s) if ch=='1']\n            zeros = [i for i,ch in enumerate(s) if ch=='0']\n            if ones and zeros:\n                remove = max(ones, key=lambda i: ppc[i])\n                best_gain = 0\n                best_add = None\n                for j in zeros:\n                    new_tc = tc - costs[remove] + costs[j]\n                    new_tp = tp - points[remove] + points[j]\n                    if new_tc >= budget_min and new_tp < tp and (tp - new_tp) > best_gain:\n                        best_gain = tp - new_tp\n                        best_add = j\n                if best_add is not None:\n                    s[remove] = '0'\n                    s[best_add] = '1'\n            return ''.join(s)\n        # If infeasible, greedily add items by ascending points per cost until feasible\n        ppc = [(points[i]\/costs[i], i) for i in range(n) if s[i]=='0']\n        ppc.sort()\n        for _, i in ppc:\n            s[i] = '1'\n            tc += costs[i]\n            if tc >= budget_min:\n                break\n        return ''.join(s)\n\n    # Perform k-bit flips with adaptive k\n    k_min = 3\n    k_max = min(7, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    candidate = ''.join(s_list)\n    return repair(candidate)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000424}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation\n    if not isinstance(solution, str) or len(solution) != len(costs) or any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Penalty for infeasibility (shortfall from budget)\n    shortfall = budget_min - total_cost\n    # Use a scaled penalty tied to average points per cost to keep gradients reasonable\n    avg_ppc = (sum(points) \/ sum(costs))\n    penalty_lambda = 200.0 * avg_ppc\n    return float(total_points + penalty_lambda * shortfall)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Mixed neighborhood: bit flip, 2-bit flip, and 1-1 swap\n    n = len(solution)\n    if n == 0:\n        return solution, \"noop\"\n\n    rng = random.random()\n    s_list = list(solution)\n\n    if rng < 1\/3:\n        # Single bit flip\n        idx = random.randrange(n)\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"bit_flip\"\n    elif rng < 2\/3:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n        return ''.join(s_list), \"two_bit_flip\"\n    else:\n        # 1-1 swap: flip one '1' to '0' and one '0' to '1' if possible; otherwise fallback to single flip\n        ones = [i for i, ch in enumerate(s_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(s_list) if ch == '0']\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            s_list[i1] = '0'\n            s_list[i0] = '1'\n            return ''.join(s_list), \"one_one_swap\"\n        else:\n            idx = random.randrange(n)\n            s_list[idx] = '0' if s_list[idx] == '1' else '1'\n            return ''.join(s_list), \"bit_flip_fallback\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # k-bit random flips with feasibility repair to enforce cost >= budget\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    def totals(bitstr: str):\n        tc = 0\n        tp = 0\n        for i, ch in enumerate(bitstr):\n            if ch == '1':\n                tc += costs[i]\n                tp += points[i]\n        return tc, tp\n\n    def repair(bitstr: str) -> str:\n        # If feasible, try a light prune-insert to reduce points while staying feasible\n        s = list(bitstr)\n        tc, tp = totals(bitstr)\n        if tc >= budget_min:\n            # Attempt one improving swap: remove highest points\/cost item, insert lowest points\/cost item from zeros if keeps feasibility and reduces points\n            ppc = [points[i]\/costs[i] for i in range(n)]\n            ones = [i for i,ch in enumerate(s) if ch=='1']\n            zeros = [i for i,ch in enumerate(s) if ch=='0']\n            if ones and zeros:\n                remove = max(ones, key=lambda i: ppc[i])\n                best_gain = 0\n                best_add = None\n                for j in zeros:\n                    new_tc = tc - costs[remove] + costs[j]\n                    new_tp = tp - points[remove] + points[j]\n                    if new_tc >= budget_min and new_tp < tp and (tp - new_tp) > best_gain:\n                        best_gain = tp - new_tp\n                        best_add = j\n                if best_add is not None:\n                    s[remove] = '0'\n                    s[best_add] = '1'\n            return ''.join(s)\n        # If infeasible, greedily add items by ascending points per cost until feasible\n        ppc = [(points[i]\/costs[i], i) for i in range(n) if s[i]=='0']\n        ppc.sort()\n        for _, i in ppc:\n            s[i] = '1'\n            tc += costs[i]\n            if tc >= budget_min:\n                break\n        return ''.join(s)\n\n    # Perform k-bit flips with adaptive k\n    k_min = 3\n    k_max = min(7, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    candidate = ''.join(s_list)\n    return repair(candidate)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000028299}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR_24","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation strictly: 24-bit binary string\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n:\n        return float('inf')\n    if any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Penalty for infeasibility (shortfall from budget)\n    shortfall = budget_min - total_cost\n    # Moderate linear penalty to guide toward feasibility without collapsing exploration\n    penalty_per_dollar = 2.0\n    return float(total_points + penalty_per_dollar * shortfall)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Budget- and gap-aware mixed neighborhood for 0\/1 strings\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    s = list(solution)\n    n = len(s)\n    if n == 0:\n        return solution, \"noop\"\n\n    # Compute current totals\n    tc = 0\n    tp = 0\n    ones = []\n    zeros = []\n    for i, ch in enumerate(s):\n        if ch == '1':\n            ones.append(i)\n            tc += costs[i]\n            tp += points[i]\n        else:\n            zeros.append(i)\n\n    gap = budget_min - tc  # negative if over budget\n\n    rng = random.random()\n\n    # If under budget: prefer adding a zero with minimal points-per-cost\n    if gap > 0 and zeros:\n        idx = min(zeros, key=lambda i: points[i]\/costs[i])\n        s[idx] = '1'\n        return ''.join(s), \"targeted_add\"\n\n    # If feasible (>= budget): try to improve points by dropping worst item if we stay feasible\n    if tc >= budget_min and ones:\n        # Candidate drop: highest points-per-cost that keeps feasibility\n        removable = [i for i in ones if (tc - costs[i]) >= budget_min]\n        if removable:\n            idx = max(removable, key=lambda i: points[i]\/costs[i])\n            s[idx] = '0'\n            return ''.join(s), \"targeted_drop\"\n        # Otherwise attempt a swap that reduces points with small cost delta\n        if ones and zeros:\n            i1 = max(ones, key=lambda i: points[i]\/max(1, costs[i]))\n            # Choose j that reduces points and keeps feasibility with minimal |delta_cost|\n            best = None\n            best_key = (10**9, 10**9)\n            for j in zeros:\n                new_tc = tc - costs[i1] + costs[j]\n                new_tp = tp - points[i1] + points[j]\n                if new_tc >= budget_min and new_tp < tp:\n                    key = (abs(new_tc - budget_min), new_tp)\n                    if key < best_key:\n                        best_key = key\n                        best = j\n            if best is not None:\n                s[i1] = '0'\n                s[best] = '1'\n                return ''.join(s), \"cost_gap_swap\"\n\n    # Fallback generic moves\n    if rng < 0.5:\n        # Single bit flip\n        idx = random.randrange(n)\n        s[idx] = '0' if s[idx] == '1' else '1'\n        return ''.join(s), \"bit_flip\"\n    else:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s[idx] = '0' if s[idx] == '1' else '1'\n        return ''.join(s), \"two_bit_flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Intensity-controlled k-flip with feasibility-aware repair (both under- and over-budget)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    def totals(bitstr: str):\n        tc = 0\n        tp = 0\n        for i, ch in enumerate(bitstr):\n            if ch == '1':\n                tc += costs[i]\n                tp += points[i]\n        return tc, tp\n\n    def repair(bitstr: str) -> str:\n        s = list(bitstr)\n        tc, tp = totals(bitstr)\n        # If under budget: greedily add items with minimal points-per-cost until feasible\n        if tc < budget_min:\n            candidates = [(points[i]\/costs[i], i) for i, ch in enumerate(s) if ch == '0']\n            candidates.sort()\n            for _, i in candidates:\n                s[i] = '1'\n                tc += costs[i]\n                tp += points[i]\n                if tc >= budget_min:\n                    break\n            return ''.join(s)\n        # If feasible or over budget: try to reduce points by dropping high ppc while staying feasible\n        improved = True\n        while improved:\n            improved = False\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            removable = [i for i in ones if (tc - costs[i]) >= budget_min]\n            if removable:\n                i = max(removable, key=lambda idx: points[idx]\/costs[idx])\n                # Apply one removal if it reduces points and keeps feasible\n                s[i] = '0'\n                tc -= costs[i]\n                tp -= points[i]\n                improved = True\n        return ''.join(s)\n\n    # Flip k random bits\n    k_min = 3\n    k_max = min(6, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    candidate = ''.join(s_list)\n    return repair(candidate)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001618}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR_24","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation strictly: 24-bit binary string\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n:\n        return float('inf')\n    if any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Penalty for infeasibility (shortfall from budget)\n    shortfall = budget_min - total_cost\n    # Moderate linear penalty to guide toward feasibility without collapsing exploration\n    penalty_per_dollar = 2.0\n    return float(total_points + penalty_per_dollar * shortfall)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Budget- and gap-aware mixed neighborhood for 0\/1 strings\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    s = list(solution)\n    n = len(s)\n    if n == 0:\n        return solution, \"noop\"\n\n    # Compute current totals\n    tc = 0\n    tp = 0\n    ones = []\n    zeros = []\n    for i, ch in enumerate(s):\n        if ch == '1':\n            ones.append(i)\n            tc += costs[i]\n            tp += points[i]\n        else:\n            zeros.append(i)\n\n    gap = budget_min - tc  # negative if over budget\n\n    rng = random.random()\n\n    # If under budget: prefer adding a zero with minimal points-per-cost\n    if gap > 0 and zeros:\n        idx = min(zeros, key=lambda i: points[i]\/costs[i])\n        s[idx] = '1'\n        return ''.join(s), \"targeted_add\"\n\n    # If feasible (>= budget): try to improve points by dropping worst item if we stay feasible\n    if tc >= budget_min and ones:\n        # Candidate drop: highest points-per-cost that keeps feasibility\n        removable = [i for i in ones if (tc - costs[i]) >= budget_min]\n        if removable:\n            idx = max(removable, key=lambda i: points[i]\/costs[i])\n            s[idx] = '0'\n            return ''.join(s), \"targeted_drop\"\n        # Otherwise attempt a swap that reduces points with small cost delta\n        if ones and zeros:\n            i1 = max(ones, key=lambda i: points[i]\/max(1, costs[i]))\n            # Choose j that reduces points and keeps feasibility with minimal |delta_cost|\n            best = None\n            best_key = (10**9, 10**9)\n            for j in zeros:\n                new_tc = tc - costs[i1] + costs[j]\n                new_tp = tp - points[i1] + points[j]\n                if new_tc >= budget_min and new_tp < tp:\n                    key = (abs(new_tc - budget_min), new_tp)\n                    if key < best_key:\n                        best_key = key\n                        best = j\n            if best is not None:\n                s[i1] = '0'\n                s[best] = '1'\n                return ''.join(s), \"cost_gap_swap\"\n\n    # Fallback generic moves\n    if rng < 0.5:\n        # Single bit flip\n        idx = random.randrange(n)\n        s[idx] = '0' if s[idx] == '1' else '1'\n        return ''.join(s), \"bit_flip\"\n    else:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s[idx] = '0' if s[idx] == '1' else '1'\n        return ''.join(s), \"two_bit_flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Intensity-controlled k-flip with feasibility-aware repair (both under- and over-budget)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    def totals(bitstr: str):\n        tc = 0\n        tp = 0\n        for i, ch in enumerate(bitstr):\n            if ch == '1':\n                tc += costs[i]\n                tp += points[i]\n        return tc, tp\n\n    def repair(bitstr: str) -> str:\n        s = list(bitstr)\n        tc, tp = totals(bitstr)\n        # If under budget: greedily add items with minimal points-per-cost until feasible\n        if tc < budget_min:\n            candidates = [(points[i]\/costs[i], i) for i, ch in enumerate(s) if ch == '0']\n            candidates.sort()\n            for _, i in candidates:\n                s[i] = '1'\n                tc += costs[i]\n                tp += points[i]\n                if tc >= budget_min:\n                    break\n            return ''.join(s)\n        # If feasible or over budget: try to reduce points by dropping high ppc while staying feasible\n        improved = True\n        while improved:\n            improved = False\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            removable = [i for i in ones if (tc - costs[i]) >= budget_min]\n            if removable:\n                i = max(removable, key=lambda idx: points[idx]\/costs[idx])\n                # Apply one removal if it reduces points and keeps feasible\n                s[i] = '0'\n                tc -= costs[i]\n                tp -= points[i]\n                improved = True\n        return ''.join(s)\n\n    # Flip k random bits\n    k_min = 3\n    k_max = min(6, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    candidate = ''.join(s_list)\n    return repair(candidate)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0000041799}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"BIN_STR_24","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Internal data encoding\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    # Validate representation strictly: 24-bit binary string\n    if not isinstance(solution, str):\n        return float('inf')\n    n = len(costs)\n    if len(solution) != n:\n        return float('inf')\n    if any(ch not in '01' for ch in solution):\n        return float('inf')\n\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n\n    if total_cost >= budget_min:\n        return float(total_points)\n\n    # Penalty for infeasibility (shortfall from budget)\n    shortfall = budget_min - total_cost\n    # Moderate linear penalty to guide toward feasibility without collapsing exploration\n    penalty_per_dollar = 2.0\n    return float(total_points + penalty_per_dollar * shortfall)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Budget- and gap-aware mixed neighborhood for 0\/1 strings\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    s = list(solution)\n    n = len(s)\n    if n == 0:\n        return solution, \"noop\"\n\n    # Compute current totals\n    tc = 0\n    tp = 0\n    ones = []\n    zeros = []\n    for i, ch in enumerate(s):\n        if ch == '1':\n            ones.append(i)\n            tc += costs[i]\n            tp += points[i]\n        else:\n            zeros.append(i)\n\n    gap = budget_min - tc  # negative if over budget\n\n    rng = random.random()\n\n    # If under budget: prefer adding a zero with minimal points-per-cost\n    if gap > 0 and zeros:\n        idx = min(zeros, key=lambda i: points[i]\/costs[i])\n        s[idx] = '1'\n        return ''.join(s), \"targeted_add\"\n\n    # If feasible (>= budget): try to improve points by dropping worst item if we stay feasible\n    if tc >= budget_min and ones:\n        # Candidate drop: highest points-per-cost that keeps feasibility\n        removable = [i for i in ones if (tc - costs[i]) >= budget_min]\n        if removable:\n            idx = max(removable, key=lambda i: points[i]\/costs[i])\n            s[idx] = '0'\n            return ''.join(s), \"targeted_drop\"\n        # Otherwise attempt a swap that reduces points with small cost delta\n        if ones and zeros:\n            i1 = max(ones, key=lambda i: points[i]\/max(1, costs[i]))\n            # Choose j that reduces points and keeps feasibility with minimal |delta_cost|\n            best = None\n            best_key = (10**9, 10**9)\n            for j in zeros:\n                new_tc = tc - costs[i1] + costs[j]\n                new_tp = tp - points[i1] + points[j]\n                if new_tc >= budget_min and new_tp < tp:\n                    key = (abs(new_tc - budget_min), new_tp)\n                    if key < best_key:\n                        best_key = key\n                        best = j\n            if best is not None:\n                s[i1] = '0'\n                s[best] = '1'\n                return ''.join(s), \"cost_gap_swap\"\n\n    # Fallback generic moves\n    if rng < 0.5:\n        # Single bit flip\n        idx = random.randrange(n)\n        s[idx] = '0' if s[idx] == '1' else '1'\n        return ''.join(s), \"bit_flip\"\n    else:\n        # Two distinct bit flips\n        k = 2 if n >= 2 else 1\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            s[idx] = '0' if s[idx] == '1' else '1'\n        return ''.join(s), \"two_bit_flip\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Intensity-controlled k-flip with feasibility-aware repair (both under- and over-budget)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    budget_min = 670\n\n    n = len(solution)\n    if n == 0:\n        return solution\n\n    def totals(bitstr: str):\n        tc = 0\n        tp = 0\n        for i, ch in enumerate(bitstr):\n            if ch == '1':\n                tc += costs[i]\n                tp += points[i]\n        return tc, tp\n\n    def repair(bitstr: str) -> str:\n        s = list(bitstr)\n        tc, tp = totals(bitstr)\n        # If under budget: greedily add items with minimal points-per-cost until feasible\n        if tc < budget_min:\n            candidates = [(points[i]\/costs[i], i) for i, ch in enumerate(s) if ch == '0']\n            candidates.sort()\n            for _, i in candidates:\n                s[i] = '1'\n                tc += costs[i]\n                tp += points[i]\n                if tc >= budget_min:\n                    break\n            return ''.join(s)\n        # If feasible or over budget: try to reduce points by dropping high ppc while staying feasible\n        improved = True\n        while improved:\n            improved = False\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            removable = [i for i in ones if (tc - costs[i]) >= budget_min]\n            if removable:\n                i = max(removable, key=lambda idx: points[idx]\/costs[idx])\n                # Apply one removal if it reduces points and keeps feasible\n                s[i] = '0'\n                tc -= costs[i]\n                tp -= points[i]\n                improved = True\n        return ''.join(s)\n\n    # Flip k random bits\n    k_min = 3\n    k_max = min(6, n)\n    k = random.randint(k_min, k_max)\n    idxs = random.sample(range(n), k)\n    s_list = list(solution)\n    for idx in idxs:\n        s_list[idx] = '0' if s_list[idx] == '1' else '1'\n    candidate = ''.join(s_list)\n    return repair(candidate)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.00000316}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24. Index i (1-based) corresponds to Customer i. '1' means accept offer, '0' means reject.","Evaluacion":"import random\n\ndef evaluate_solution(solution: str) -> float:\n    \"\"\"\n    Fitness = total_revenue if total_gallons >= 67 else large_penalty.\n    Lower is better.\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    \"\"\"\n    # Embedded problem data: (price, gallons) per customer 1..24\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= 67:\n        return float(total_cost)\n    # Penalize infeasible solutions heavily\n    deficit = 67 - total_gallons\n    return 1_000_000.0 + 1_000.0 * deficit + float(total_cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a neighbouring solution by flipping one random bit.\n    Output: (neighbour_solution_str, movement_type_str)\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    idx = random.randrange(24)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    return (neighbour, \"flip_one_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits, k ~ Uniform{2..5} (capped by 24).\n    Returns a new solution string.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    k = min(5, 24)\n    k = random.randint(2, k)\n    indices = list(range(24))\n    random.shuffle(indices)\n    flip_idx = set(indices[:k])\n    s_list = list(solution)\n    for i in flip_idx:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001808}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24. Index i (1-based) corresponds to Customer i. '1' means accept offer, '0' means reject.","Evaluacion":"import random\n\ndef evaluate_solution(solution: str) -> float:\n    \"\"\"\n    Fitness = total_revenue if total_gallons >= 67 else large_penalty.\n    Lower is better.\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    \"\"\"\n    # Embedded problem data: (price, gallons) per customer 1..24\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= 67:\n        return float(total_cost)\n    # Penalize infeasible solutions heavily\n    deficit = 67 - total_gallons\n    return 1_000_000.0 + 1_000.0 * deficit + float(total_cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a neighbouring solution by flipping one random bit.\n    Output: (neighbour_solution_str, movement_type_str)\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    idx = random.randrange(24)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    return (neighbour, \"flip_one_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits, k ~ Uniform{2..5} (capped by 24).\n    Returns a new solution string.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    k = min(5, 24)\n    k = random.randint(2, k)\n    indices = list(range(24))\n    random.shuffle(indices)\n    flip_idx = set(indices[:k])\n    s_list = list(solution)\n    for i in flip_idx:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000416}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24. Index i (1-based) corresponds to Customer i. '1' means accept offer, '0' means reject.","Evaluacion":"import random\n\ndef evaluate_solution(solution: str) -> float:\n    \"\"\"\n    Fitness = total_revenue if total_gallons >= 67 else large_penalty.\n    Lower is better.\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    \"\"\"\n    # Embedded problem data: (price, gallons) per customer 1..24\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return float('inf')\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= 67:\n        return float(total_cost)\n    # Penalize infeasible solutions heavily\n    deficit = 67 - total_gallons\n    return 1_000_000.0 + 1_000.0 * deficit + float(total_cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a neighbouring solution by flipping one random bit.\n    Output: (neighbour_solution_str, movement_type_str)\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    idx = random.randrange(24)\n    s_list = list(solution)\n    s_list[idx] = '1' if s_list[idx] == '0' else '0'\n    neighbour = ''.join(s_list)\n    return (neighbour, \"flip_one_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits, k ~ Uniform{2..5} (capped by 24).\n    Returns a new solution string.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    k = min(5, 24)\n    k = random.randint(2, k)\n    indices = list(range(24))\n    random.shuffle(indices)\n    flip_idx = set(indices[:k])\n    s_list = list(solution)\n    for i in flip_idx:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000028199}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    \"\"\"\n    Fitness = total_revenue if total_gallons >= 67 else moderated penalty.\n    Lower is better.\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    \"\"\"\n    # Embedded problem data: (price, gallons) per customer 1..24\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= 67:\n        return float(total_cost)\n    deficit = 67 - total_gallons\n    # Moderated penalty to allow exploration while discouraging infeasibility\n    return 10000.0 + 100.0 * deficit + float(total_cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Adaptive neighborhood:\n      - With p=0.6 flip-1-bit (biased): prefer turning ON low-cost-per-gallon offers and turning OFF high-cost-per-gallon offers.\n      - With p=0.3 flip-2-bits (uniform).\n      - With p=0.1 flip-3-bits (uniform).\n    Returns: (neighbour_solution_str, movement_type_str)\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    # Embedded (price, gallons)\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    cpg = [p\/g for (p, g) in data]\n    # rank: lower cpg -> smaller rank value\n    order = sorted(range(24), key=lambda i: cpg[i])\n    rank = [0]*24\n    for r, i in enumerate(order, start=1):\n        rank[i] = r\n    u = random.random()\n    if u < 0.6:\n        # Biased single flip\n        weights = []\n        for i, bit in enumerate(s_list):\n            if bit == '0':\n                # Prefer adding low cpg (higher weight for lower rank)\n                weights.append(3.0 \/ rank[i])\n            else:\n                # Prefer removing high cpg (higher weight for higher rank)\n                weights.append(rank[i] \/ 24.0)\n        # Normalize implicitly via random.choices\n        idx = random.choices(range(24), weights=weights, k=1)[0]\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        move = 'flip_1_bit_biased'\n    elif u < 0.9:\n        # Flip 2 bits uniformly\n        idxs = random.sample(range(24), k=2)\n        for i in idxs:\n            s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = 'flip_2_bits'\n    else:\n        # Flip 3 bits uniformly\n        idxs = random.sample(range(24), k=3)\n        for i in idxs:\n            s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = 'flip_3_bits'\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits, k ~ Uniform{2..5} (capped at 24).\n    Returns a new solution string.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    k = random.randint(2, min(5, 24))\n    idxs = random.sample(range(24), k=k)\n    s_list = list(solution)\n    for i in idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001583}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    \"\"\"\n    Fitness = total_revenue if total_gallons >= 67 else moderated penalty.\n    Lower is better.\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    \"\"\"\n    # Embedded problem data: (price, gallons) per customer 1..24\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= 67:\n        return float(total_cost)\n    deficit = 67 - total_gallons\n    # Moderated penalty to allow exploration while discouraging infeasibility\n    return 10000.0 + 100.0 * deficit + float(total_cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Adaptive neighborhood:\n      - With p=0.6 flip-1-bit (biased): prefer turning ON low-cost-per-gallon offers and turning OFF high-cost-per-gallon offers.\n      - With p=0.3 flip-2-bits (uniform).\n      - With p=0.1 flip-3-bits (uniform).\n    Returns: (neighbour_solution_str, movement_type_str)\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    # Embedded (price, gallons)\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    cpg = [p\/g for (p, g) in data]\n    # rank: lower cpg -> smaller rank value\n    order = sorted(range(24), key=lambda i: cpg[i])\n    rank = [0]*24\n    for r, i in enumerate(order, start=1):\n        rank[i] = r\n    u = random.random()\n    if u < 0.6:\n        # Biased single flip\n        weights = []\n        for i, bit in enumerate(s_list):\n            if bit == '0':\n                # Prefer adding low cpg (higher weight for lower rank)\n                weights.append(3.0 \/ rank[i])\n            else:\n                # Prefer removing high cpg (higher weight for higher rank)\n                weights.append(rank[i] \/ 24.0)\n        # Normalize implicitly via random.choices\n        idx = random.choices(range(24), weights=weights, k=1)[0]\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        move = 'flip_1_bit_biased'\n    elif u < 0.9:\n        # Flip 2 bits uniformly\n        idxs = random.sample(range(24), k=2)\n        for i in idxs:\n            s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = 'flip_2_bits'\n    else:\n        # Flip 3 bits uniformly\n        idxs = random.sample(range(24), k=3)\n        for i in idxs:\n            s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = 'flip_3_bits'\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits, k ~ Uniform{2..5} (capped at 24).\n    Returns a new solution string.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    k = random.randint(2, min(5, 24))\n    idxs = random.sample(range(24), k=k)\n    s_list = list(solution)\n    for i in idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000448}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    \"\"\"\n    Fitness = total_revenue if total_gallons >= 67 else moderated penalty.\n    Lower is better.\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    \"\"\"\n    # Embedded problem data: (price, gallons) per customer 1..24\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= 67:\n        return float(total_cost)\n    deficit = 67 - total_gallons\n    # Moderated penalty to allow exploration while discouraging infeasibility\n    return 10000.0 + 100.0 * deficit + float(total_cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Adaptive neighborhood:\n      - With p=0.6 flip-1-bit (biased): prefer turning ON low-cost-per-gallon offers and turning OFF high-cost-per-gallon offers.\n      - With p=0.3 flip-2-bits (uniform).\n      - With p=0.1 flip-3-bits (uniform).\n    Returns: (neighbour_solution_str, movement_type_str)\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    # Embedded (price, gallons)\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    cpg = [p\/g for (p, g) in data]\n    # rank: lower cpg -> smaller rank value\n    order = sorted(range(24), key=lambda i: cpg[i])\n    rank = [0]*24\n    for r, i in enumerate(order, start=1):\n        rank[i] = r\n    u = random.random()\n    if u < 0.6:\n        # Biased single flip\n        weights = []\n        for i, bit in enumerate(s_list):\n            if bit == '0':\n                # Prefer adding low cpg (higher weight for lower rank)\n                weights.append(3.0 \/ rank[i])\n            else:\n                # Prefer removing high cpg (higher weight for higher rank)\n                weights.append(rank[i] \/ 24.0)\n        # Normalize implicitly via random.choices\n        idx = random.choices(range(24), weights=weights, k=1)[0]\n        s_list[idx] = '1' if s_list[idx] == '0' else '0'\n        move = 'flip_1_bit_biased'\n    elif u < 0.9:\n        # Flip 2 bits uniformly\n        idxs = random.sample(range(24), k=2)\n        for i in idxs:\n            s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = 'flip_2_bits'\n    else:\n        # Flip 3 bits uniformly\n        idxs = random.sample(range(24), k=3)\n        for i in idxs:\n            s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = 'flip_3_bits'\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: flip k random distinct bits, k ~ Uniform{2..5} (capped at 24).\n    Returns a new solution string.\n    \"\"\"\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    k = random.randint(2, min(5, 24))\n    idxs = random.sample(range(24), k=k)\n    s_list = list(solution)\n    for i in idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000028899}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Numerical fitness (lower is better).\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    Objective: minimize total price subject to total gallons >= 67.\n    Feasibility-first via scalarization: if infeasible, return 1000*deficit + cost.\n    This guarantees any feasible solution scores lower than any infeasible one.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= target:\n        return float(total_cost)\n    deficit = target - total_gallons\n    return float(1000 * deficit + total_cost)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-aware mixed neighborhood.\n      - If infeasible: biased to add offers with low cost-per-gallon and high gallons (flip 1 bit 0->1 preferred).\n      - If feasible: biased to remove offers with high cost-per-gallon while attempting to preserve feasibility (flip 1 bit 1->0 preferred, with quick feasibility precheck).\n      - With smaller probability, perform 2- or 3-bit flips for diversification.\n    Returns: (neighbor_solution_str, movement_type_str)\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n    total_cost = 0\n    total_gal = 0\n    on_indices = []\n    off_indices = []\n    for i, b in enumerate(s_list):\n        if b == '1':\n            on_indices.append(i)\n            total_cost += prices[i]\n            total_gal += gallons[i]\n        else:\n            off_indices.append(i)\n    feasible = total_gal >= target\n\n    u = random.random()\n    move = \"\"\n    # Diversification branch\n    if u > 0.9:\n        k = 3 if random.random() < 0.5 else 2\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        move = f\"flip_{k}_bits\"\n        return (\"\".join(s_list), move)\n\n    # Intensification branch\n    if not feasible:\n        # Prefer turning ON low cpg and high gallons\n        if off_indices:\n            # scoring: lower cpg and higher gallons => higher weight\n            weights = []\n            for i in off_indices:\n                # Use inverse cpg with gallon emphasis\n                score = (1.0 \/ cpg[i]) * (1.0 + gallons[i] \/ 30.0)\n                weights.append(max(score, 1e-6))\n            pick = random.choices(off_indices, weights=weights, k=1)[0]\n            s_list[pick] = '1'\n            move = 'add_low_cpg'\n            return (\"\".join(s_list), move)\n        else:\n            # no OFF bits; flip a random bit to escape\n            i = random.randrange(24)\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n            return (\"\".join(s_list), 'flip_1_bit')\n    else:\n        # Prefer turning OFF high cpg while keeping feasibility\n        # Try a few candidates; if none safe, perform a swap (remove one, add one)\n        candidates = sorted(on_indices, key=lambda i: cpg[i], reverse=True)\n        for i in candidates[:8]:  # check top-8 most expensive per gallon first\n            if total_gal - gallons[i] >= target:\n                s_list[i] = '0'\n                move = 'remove_high_cpg_safe'\n                return (\"\".join(s_list), move)\n        # If no safe removal, attempt 1-1 swap: remove a high-cpg ON and add a low-cpg OFF\n        if on_indices and off_indices:\n            i = max(on_indices, key=lambda x: cpg[x])\n            # pick low cpg off with decent gallons\n            j = min(off_indices, key=lambda x: (cpg[x], -gallons[x]))\n            # apply swap\n            s_list[i] = '0'\n            s_list[j] = '1'\n            move = 'swap_1_1'\n            return (\"\".join(s_list), move)\n        # Fallback: flip a random bit\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Ruin-and-recreate perturbation.\n    - If infeasible: flip 3-5 bits uniformly at random to diversify.\n    - If feasible: drop d in [3..6] currently-selected offers with highest cost-per-gallon,\n      then greedily re-add lowest cost-per-gallon offers until feasibility is restored.\n    Returns a new 24-bit solution string.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n\n    # Compute current totals\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n\n    if total_gal < target:\n        # Simple large-k random flip\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    # Feasible: ruin highest-cpg ON items\n    on_indices = [i for i, b in enumerate(s_list) if b == '1']\n    if not on_indices:\n        # Degenerate; flip a few bits\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    d = min(len(on_indices), random.randint(3, 6))\n    to_drop = sorted(on_indices, key=lambda i: cpg[i], reverse=True)[:d]\n    for i in to_drop:\n        s_list[i] = '0'\n\n    # Recreate: add lowest-cpg OFF items until feasible\n    off_indices = [i for i, b in enumerate(s_list) if b == '0']\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n    for i in sorted(off_indices, key=lambda i: (cpg[i], -gallons[i])):\n        if total_gal >= target:\n            break\n        s_list[i] = '1'\n        total_gal += gallons[i]\n\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001521}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Numerical fitness (lower is better).\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    Objective: minimize total price subject to total gallons >= 67.\n    Feasibility-first via scalarization: if infeasible, return 1000*deficit + cost.\n    This guarantees any feasible solution scores lower than any infeasible one.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= target:\n        return float(total_cost)\n    deficit = target - total_gallons\n    return float(1000 * deficit + total_cost)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-aware mixed neighborhood.\n      - If infeasible: biased to add offers with low cost-per-gallon and high gallons (flip 1 bit 0->1 preferred).\n      - If feasible: biased to remove offers with high cost-per-gallon while attempting to preserve feasibility (flip 1 bit 1->0 preferred, with quick feasibility precheck).\n      - With smaller probability, perform 2- or 3-bit flips for diversification.\n    Returns: (neighbor_solution_str, movement_type_str)\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n    total_cost = 0\n    total_gal = 0\n    on_indices = []\n    off_indices = []\n    for i, b in enumerate(s_list):\n        if b == '1':\n            on_indices.append(i)\n            total_cost += prices[i]\n            total_gal += gallons[i]\n        else:\n            off_indices.append(i)\n    feasible = total_gal >= target\n\n    u = random.random()\n    move = \"\"\n    # Diversification branch\n    if u > 0.9:\n        k = 3 if random.random() < 0.5 else 2\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        move = f\"flip_{k}_bits\"\n        return (\"\".join(s_list), move)\n\n    # Intensification branch\n    if not feasible:\n        # Prefer turning ON low cpg and high gallons\n        if off_indices:\n            # scoring: lower cpg and higher gallons => higher weight\n            weights = []\n            for i in off_indices:\n                # Use inverse cpg with gallon emphasis\n                score = (1.0 \/ cpg[i]) * (1.0 + gallons[i] \/ 30.0)\n                weights.append(max(score, 1e-6))\n            pick = random.choices(off_indices, weights=weights, k=1)[0]\n            s_list[pick] = '1'\n            move = 'add_low_cpg'\n            return (\"\".join(s_list), move)\n        else:\n            # no OFF bits; flip a random bit to escape\n            i = random.randrange(24)\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n            return (\"\".join(s_list), 'flip_1_bit')\n    else:\n        # Prefer turning OFF high cpg while keeping feasibility\n        # Try a few candidates; if none safe, perform a swap (remove one, add one)\n        candidates = sorted(on_indices, key=lambda i: cpg[i], reverse=True)\n        for i in candidates[:8]:  # check top-8 most expensive per gallon first\n            if total_gal - gallons[i] >= target:\n                s_list[i] = '0'\n                move = 'remove_high_cpg_safe'\n                return (\"\".join(s_list), move)\n        # If no safe removal, attempt 1-1 swap: remove a high-cpg ON and add a low-cpg OFF\n        if on_indices and off_indices:\n            i = max(on_indices, key=lambda x: cpg[x])\n            # pick low cpg off with decent gallons\n            j = min(off_indices, key=lambda x: (cpg[x], -gallons[x]))\n            # apply swap\n            s_list[i] = '0'\n            s_list[j] = '1'\n            move = 'swap_1_1'\n            return (\"\".join(s_list), move)\n        # Fallback: flip a random bit\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Ruin-and-recreate perturbation.\n    - If infeasible: flip 3-5 bits uniformly at random to diversify.\n    - If feasible: drop d in [3..6] currently-selected offers with highest cost-per-gallon,\n      then greedily re-add lowest cost-per-gallon offers until feasibility is restored.\n    Returns a new 24-bit solution string.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n\n    # Compute current totals\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n\n    if total_gal < target:\n        # Simple large-k random flip\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    # Feasible: ruin highest-cpg ON items\n    on_indices = [i for i, b in enumerate(s_list) if b == '1']\n    if not on_indices:\n        # Degenerate; flip a few bits\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    d = min(len(on_indices), random.randint(3, 6))\n    to_drop = sorted(on_indices, key=lambda i: cpg[i], reverse=True)[:d]\n    for i in to_drop:\n        s_list[i] = '0'\n\n    # Recreate: add lowest-cpg OFF items until feasible\n    off_indices = [i for i, b in enumerate(s_list) if b == '0']\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n    for i in sorted(off_indices, key=lambda i: (cpg[i], -gallons[i])):\n        if total_gal >= target:\n            break\n        s_list[i] = '1'\n        total_gal += gallons[i]\n\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0000046}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Numerical fitness (lower is better).\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    Objective: minimize total price subject to total gallons >= 67.\n    Feasibility-first via scalarization: if infeasible, return 1000*deficit + cost.\n    This guarantees any feasible solution scores lower than any infeasible one.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return math.inf\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= target:\n        return float(total_cost)\n    deficit = target - total_gallons\n    return float(1000 * deficit + total_cost)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-aware mixed neighborhood.\n      - If infeasible: biased to add offers with low cost-per-gallon and high gallons (flip 1 bit 0->1 preferred).\n      - If feasible: biased to remove offers with high cost-per-gallon while attempting to preserve feasibility (flip 1 bit 1->0 preferred, with quick feasibility precheck).\n      - With smaller probability, perform 2- or 3-bit flips for diversification.\n    Returns: (neighbor_solution_str, movement_type_str)\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n    total_cost = 0\n    total_gal = 0\n    on_indices = []\n    off_indices = []\n    for i, b in enumerate(s_list):\n        if b == '1':\n            on_indices.append(i)\n            total_cost += prices[i]\n            total_gal += gallons[i]\n        else:\n            off_indices.append(i)\n    feasible = total_gal >= target\n\n    u = random.random()\n    move = \"\"\n    # Diversification branch\n    if u > 0.9:\n        k = 3 if random.random() < 0.5 else 2\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        move = f\"flip_{k}_bits\"\n        return (\"\".join(s_list), move)\n\n    # Intensification branch\n    if not feasible:\n        # Prefer turning ON low cpg and high gallons\n        if off_indices:\n            # scoring: lower cpg and higher gallons => higher weight\n            weights = []\n            for i in off_indices:\n                # Use inverse cpg with gallon emphasis\n                score = (1.0 \/ cpg[i]) * (1.0 + gallons[i] \/ 30.0)\n                weights.append(max(score, 1e-6))\n            pick = random.choices(off_indices, weights=weights, k=1)[0]\n            s_list[pick] = '1'\n            move = 'add_low_cpg'\n            return (\"\".join(s_list), move)\n        else:\n            # no OFF bits; flip a random bit to escape\n            i = random.randrange(24)\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n            return (\"\".join(s_list), 'flip_1_bit')\n    else:\n        # Prefer turning OFF high cpg while keeping feasibility\n        # Try a few candidates; if none safe, perform a swap (remove one, add one)\n        candidates = sorted(on_indices, key=lambda i: cpg[i], reverse=True)\n        for i in candidates[:8]:  # check top-8 most expensive per gallon first\n            if total_gal - gallons[i] >= target:\n                s_list[i] = '0'\n                move = 'remove_high_cpg_safe'\n                return (\"\".join(s_list), move)\n        # If no safe removal, attempt 1-1 swap: remove a high-cpg ON and add a low-cpg OFF\n        if on_indices and off_indices:\n            i = max(on_indices, key=lambda x: cpg[x])\n            # pick low cpg off with decent gallons\n            j = min(off_indices, key=lambda x: (cpg[x], -gallons[x]))\n            # apply swap\n            s_list[i] = '0'\n            s_list[j] = '1'\n            move = 'swap_1_1'\n            return (\"\".join(s_list), move)\n        # Fallback: flip a random bit\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Ruin-and-recreate perturbation.\n    - If infeasible: flip 3-5 bits uniformly at random to diversify.\n    - If feasible: drop d in [3..6] currently-selected offers with highest cost-per-gallon,\n      then greedily re-add lowest cost-per-gallon offers until feasibility is restored.\n    Returns a new 24-bit solution string.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n\n    # Compute current totals\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n\n    if total_gal < target:\n        # Simple large-k random flip\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    # Feasible: ruin highest-cpg ON items\n    on_indices = [i for i, b in enumerate(s_list) if b == '1']\n    if not on_indices:\n        # Degenerate; flip a few bits\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    d = min(len(on_indices), random.randint(3, 6))\n    to_drop = sorted(on_indices, key=lambda i: cpg[i], reverse=True)[:d]\n    for i in to_drop:\n        s_list[i] = '0'\n\n    # Recreate: add lowest-cpg OFF items until feasible\n    off_indices = [i for i, b in enumerate(s_list) if b == '0']\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n    for i in sorted(off_indices, key=lambda i: (cpg[i], -gallons[i])):\n        if total_gal >= target:\n            break\n        s_list[i] = '1'\n        total_gal += gallons[i]\n\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.00000297}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Numerical fitness (lower is better).\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    Objective: minimize total price subject to total gallons >= 67.\n    Feasibility-first via scalarization: if infeasible, return BIG_F + 1000*deficit + cost.\n    BIG_F = sum(prices) + 1 = 288 ensures any feasible solution scores lower than any infeasible one.\n    Invalid inputs return a large finite penalty to keep comparisons stable.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    BIG_M = 10**9\n    BIG_F = 288\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return float(BIG_M)\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= target:\n        return float(total_cost)\n    deficit = target - total_gallons\n    return float(BIG_F + 1000 * deficit + total_cost)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-aware mixed neighborhood.\n      - If infeasible: biased to add offers with low cost-per-gallon and high gallons (flip 1 bit 0->1 preferred).\n      - If feasible: biased to remove offers with high cost-per-gallon while preserving feasibility (flip 1 bit 1->0 when safe).\n      - With smaller probability, perform 2- or 3-bit flips for diversification.\n    Returns: (neighbor_solution_str, movement_type_str)\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n    total_gal = 0\n    on_indices = []\n    off_indices = []\n    for i, b in enumerate(s_list):\n        if b == '1':\n            on_indices.append(i)\n            total_gal += gallons[i]\n        else:\n            off_indices.append(i)\n    feasible = total_gal >= target\n\n    u = random.random()\n    # Diversification branch\n    if u > 0.9:\n        k = 3 if random.random() < 0.5 else 2\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), f\"flip_{k}_bits\")\n\n    # Intensification branch\n    if not feasible:\n        # Prefer turning ON low cpg and high gallons\n        if off_indices:\n            weights = []\n            for i in off_indices:\n                score = (1.0 \/ cpg[i]) * (1.0 + gallons[i] \/ 30.0)\n                weights.append(max(score, 1e-9))\n            pick = random.choices(off_indices, weights=weights, k=1)[0]\n            s_list[pick] = '1'\n            return (\"\".join(s_list), 'add_low_cpg')\n        # No OFF bits; flip a random bit to escape\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit')\n    else:\n        # Prefer turning OFF high cpg while keeping feasibility\n        candidates = sorted(on_indices, key=lambda i: cpg[i], reverse=True)\n        for i in candidates[:8]:\n            if total_gal - gallons[i] >= target:\n                s_list[i] = '0'\n                return (\"\".join(s_list), 'remove_high_cpg_safe')\n        # If no safe removal, attempt 1-1 swap: remove a high-cpg ON and add a low-cpg OFF\n        if on_indices and off_indices:\n            i = max(on_indices, key=lambda x: cpg[x])\n            j = min(off_indices, key=lambda x: (cpg[x], -gallons[x]))\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return (\"\".join(s_list), 'swap_1_1')\n        # Fallback: flip a random bit\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Ruin-and-recreate perturbation.\n    - If infeasible: flip 3-5 bits uniformly at random to diversify.\n    - If feasible: drop d in [3..6] currently-selected offers with highest cost-per-gallon,\n      then greedily re-add lowest cost-per-gallon offers until feasibility is restored.\n    Returns a new 24-bit solution string.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n\n    if total_gal < target:\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    on_indices = [i for i, b in enumerate(s_list) if b == '1']\n    if not on_indices:\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    d = min(len(on_indices), random.randint(3, 6))\n    to_drop = sorted(on_indices, key=lambda i: cpg[i], reverse=True)[:d]\n    for i in to_drop:\n        s_list[i] = '0'\n\n    # Recreate: add lowest-cpg OFF items until feasible\n    off_indices = [i for i, b in enumerate(s_list) if b == '0']\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n    for i in sorted(off_indices, key=lambda i: (cpg[i], -gallons[i])):\n        if total_gal >= target:\n            break\n        s_list[i] = '1'\n        total_gal += gallons[i]\n\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0000135311}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Numerical fitness (lower is better).\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    Objective: minimize total price subject to total gallons >= 67.\n    Feasibility-first via scalarization: if infeasible, return BIG_F + 1000*deficit + cost.\n    BIG_F = sum(prices) + 1 = 288 ensures any feasible solution scores lower than any infeasible one.\n    Invalid inputs return a large finite penalty to keep comparisons stable.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    BIG_M = 10**9\n    BIG_F = 288\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return float(BIG_M)\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= target:\n        return float(total_cost)\n    deficit = target - total_gallons\n    return float(BIG_F + 1000 * deficit + total_cost)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-aware mixed neighborhood.\n      - If infeasible: biased to add offers with low cost-per-gallon and high gallons (flip 1 bit 0->1 preferred).\n      - If feasible: biased to remove offers with high cost-per-gallon while preserving feasibility (flip 1 bit 1->0 when safe).\n      - With smaller probability, perform 2- or 3-bit flips for diversification.\n    Returns: (neighbor_solution_str, movement_type_str)\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n    total_gal = 0\n    on_indices = []\n    off_indices = []\n    for i, b in enumerate(s_list):\n        if b == '1':\n            on_indices.append(i)\n            total_gal += gallons[i]\n        else:\n            off_indices.append(i)\n    feasible = total_gal >= target\n\n    u = random.random()\n    # Diversification branch\n    if u > 0.9:\n        k = 3 if random.random() < 0.5 else 2\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), f\"flip_{k}_bits\")\n\n    # Intensification branch\n    if not feasible:\n        # Prefer turning ON low cpg and high gallons\n        if off_indices:\n            weights = []\n            for i in off_indices:\n                score = (1.0 \/ cpg[i]) * (1.0 + gallons[i] \/ 30.0)\n                weights.append(max(score, 1e-9))\n            pick = random.choices(off_indices, weights=weights, k=1)[0]\n            s_list[pick] = '1'\n            return (\"\".join(s_list), 'add_low_cpg')\n        # No OFF bits; flip a random bit to escape\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit')\n    else:\n        # Prefer turning OFF high cpg while keeping feasibility\n        candidates = sorted(on_indices, key=lambda i: cpg[i], reverse=True)\n        for i in candidates[:8]:\n            if total_gal - gallons[i] >= target:\n                s_list[i] = '0'\n                return (\"\".join(s_list), 'remove_high_cpg_safe')\n        # If no safe removal, attempt 1-1 swap: remove a high-cpg ON and add a low-cpg OFF\n        if on_indices and off_indices:\n            i = max(on_indices, key=lambda x: cpg[x])\n            j = min(off_indices, key=lambda x: (cpg[x], -gallons[x]))\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return (\"\".join(s_list), 'swap_1_1')\n        # Fallback: flip a random bit\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Ruin-and-recreate perturbation.\n    - If infeasible: flip 3-5 bits uniformly at random to diversify.\n    - If feasible: drop d in [3..6] currently-selected offers with highest cost-per-gallon,\n      then greedily re-add lowest cost-per-gallon offers until feasibility is restored.\n    Returns a new 24-bit solution string.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n\n    if total_gal < target:\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    on_indices = [i for i, b in enumerate(s_list) if b == '1']\n    if not on_indices:\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    d = min(len(on_indices), random.randint(3, 6))\n    to_drop = sorted(on_indices, key=lambda i: cpg[i], reverse=True)[:d]\n    for i in to_drop:\n        s_list[i] = '0'\n\n    # Recreate: add lowest-cpg OFF items until feasible\n    off_indices = [i for i, b in enumerate(s_list) if b == '0']\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n    for i in sorted(off_indices, key=lambda i: (cpg[i], -gallons[i])):\n        if total_gal >= target:\n            break\n        s_list[i] = '1'\n        total_gal += gallons[i]\n\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000612}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Numerical fitness (lower is better).\n    Representation: 24-length binary string, 1=take offer, 0=reject.\n    Objective: minimize total price subject to total gallons >= 67.\n    Feasibility-first via scalarization: if infeasible, return BIG_F + 1000*deficit + cost.\n    BIG_F = sum(prices) + 1 = 288 ensures any feasible solution scores lower than any infeasible one.\n    Invalid inputs return a large finite penalty to keep comparisons stable.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    BIG_M = 10**9\n    BIG_F = 288\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return float(BIG_M)\n    total_cost = 0\n    total_gallons = 0\n    for i, bit in enumerate(solution):\n        if bit == '1':\n            price, gallons = data[i]\n            total_cost += price\n            total_gallons += gallons\n    if total_gallons >= target:\n        return float(total_cost)\n    deficit = target - total_gallons\n    return float(BIG_F + 1000 * deficit + total_cost)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Feasibility-aware mixed neighborhood.\n      - If infeasible: biased to add offers with low cost-per-gallon and high gallons (flip 1 bit 0->1 preferred).\n      - If feasible: biased to remove offers with high cost-per-gallon while preserving feasibility (flip 1 bit 1->0 when safe).\n      - With smaller probability, perform 2- or 3-bit flips for diversification.\n    Returns: (neighbor_solution_str, movement_type_str)\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return (solution, \"invalid_input\")\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n    total_gal = 0\n    on_indices = []\n    off_indices = []\n    for i, b in enumerate(s_list):\n        if b == '1':\n            on_indices.append(i)\n            total_gal += gallons[i]\n        else:\n            off_indices.append(i)\n    feasible = total_gal >= target\n\n    u = random.random()\n    # Diversification branch\n    if u > 0.9:\n        k = 3 if random.random() < 0.5 else 2\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), f\"flip_{k}_bits\")\n\n    # Intensification branch\n    if not feasible:\n        # Prefer turning ON low cpg and high gallons\n        if off_indices:\n            weights = []\n            for i in off_indices:\n                score = (1.0 \/ cpg[i]) * (1.0 + gallons[i] \/ 30.0)\n                weights.append(max(score, 1e-9))\n            pick = random.choices(off_indices, weights=weights, k=1)[0]\n            s_list[pick] = '1'\n            return (\"\".join(s_list), 'add_low_cpg')\n        # No OFF bits; flip a random bit to escape\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit')\n    else:\n        # Prefer turning OFF high cpg while keeping feasibility\n        candidates = sorted(on_indices, key=lambda i: cpg[i], reverse=True)\n        for i in candidates[:8]:\n            if total_gal - gallons[i] >= target:\n                s_list[i] = '0'\n                return (\"\".join(s_list), 'remove_high_cpg_safe')\n        # If no safe removal, attempt 1-1 swap: remove a high-cpg ON and add a low-cpg OFF\n        if on_indices and off_indices:\n            i = max(on_indices, key=lambda x: cpg[x])\n            j = min(off_indices, key=lambda x: (cpg[x], -gallons[x]))\n            s_list[i] = '0'\n            s_list[j] = '1'\n            return (\"\".join(s_list), 'swap_1_1')\n        # Fallback: flip a random bit\n        i = random.randrange(24)\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n        return (\"\".join(s_list), 'flip_1_bit_fallback')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Ruin-and-recreate perturbation.\n    - If infeasible: flip 3-5 bits uniformly at random to diversify.\n    - If feasible: drop d in [3..6] currently-selected offers with highest cost-per-gallon,\n      then greedily re-add lowest cost-per-gallon offers until feasibility is restored.\n    Returns a new 24-bit solution string.\n    \"\"\"\n    data = [\n        (19,11),(21,23),(22,22),(13,10),(1,17),(9,20),(7,11),(10,24),\n        (4,19),(11,8),(11,14),(12,20),(6,22),(15,16),(17,13),(8,5),\n        (13,4),(11,22),(24,23),(10,9),(8,22),(18,6),(8,20),(9,10)\n    ]\n    target = 67\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        return solution\n    s_list = list(solution)\n    prices = [p for p, _ in data]\n    gallons = [g for _, g in data]\n    cpg = [prices[i] \/ gallons[i] for i in range(24)]\n\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n\n    if total_gal < target:\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    on_indices = [i for i, b in enumerate(s_list) if b == '1']\n    if not on_indices:\n        k = random.randint(3, 5)\n        idxs = random.sample(range(24), k=k)\n        for i in idxs:\n            s_list[i] = '0' if s_list[i] == '1' else '1'\n        return ''.join(s_list)\n\n    d = min(len(on_indices), random.randint(3, 6))\n    to_drop = sorted(on_indices, key=lambda i: cpg[i], reverse=True)[:d]\n    for i in to_drop:\n        s_list[i] = '0'\n\n    # Recreate: add lowest-cpg OFF items until feasible\n    off_indices = [i for i, b in enumerate(s_list) if b == '0']\n    total_gal = sum(gallons[i] for i, b in enumerate(s_list) if b == '1')\n    for i in sorted(off_indices, key=lambda i: (cpg[i], -gallons[i])):\n        if total_gal >= target:\n            break\n        s_list[i] = '1'\n        total_gal += gallons[i]\n\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000049301}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index i in [1..24] maps to bit i-1; bit '1' means attraction i is selected for the friend to visit","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Representation: 24-length binary string; '1' means friend visits that attraction.\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 10**9\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    total_time = sum(t for bit, t in zip(solution, times) if bit == '1')\n    total_score = sum(s for bit, s in zip(solution, scores) if bit == '1')\n    # Objective: minimize total_score subject to total_time >= 670\n    if total_time >= 670:\n        return float(total_score)\n    deficit = 670 - total_time\n    # Large penalty plus small tie-breaker on score\n    return float(100000 + deficit * 1000 + total_score)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: flip one random bit\n    if not isinstance(solution, str) or len(solution) == 0:\n        # default to a zero vector\n        solution = '0' * 24\n    n = len(solution)\n    idx = random.randrange(n)\n    lst = list(solution)\n    lst[idx] = '1' if lst[idx] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"flip_1bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: flip k random bits, then repair toward feasibility if needed\n    if not isinstance(solution, str) or len(solution) == 0:\n        solution = '0' * 24\n    n = len(solution)\n    k = random.randint(2, max(2, n \/\/ 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for idx in idxs:\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n    new_sol = ''.join(lst)\n    # Feasibility repair heuristic: add items maximizing time per score until time >= 670\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    def total_time(sol):\n        return sum(t for bit, t in zip(sol, times) if bit == '1')\n    if total_time(new_sol) < 670:\n        order = sorted(range(24), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_t = total_time(new_sol)\n        for i in order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_t += times[i]\n                if cur_t >= 670:\n                    break\n        new_sol = ''.join(lst)\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00004244}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index i in [1..24] maps to bit i-1; bit '1' means attraction i is selected for the friend to visit","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Representation: 24-length binary string; '1' means friend visits that attraction.\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 10**9\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    total_time = sum(t for bit, t in zip(solution, times) if bit == '1')\n    total_score = sum(s for bit, s in zip(solution, scores) if bit == '1')\n    # Objective: minimize total_score subject to total_time >= 670\n    if total_time >= 670:\n        return float(total_score)\n    deficit = 670 - total_time\n    # Large penalty plus small tie-breaker on score\n    return float(100000 + deficit * 1000 + total_score)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: flip one random bit\n    if not isinstance(solution, str) or len(solution) == 0:\n        # default to a zero vector\n        solution = '0' * 24\n    n = len(solution)\n    idx = random.randrange(n)\n    lst = list(solution)\n    lst[idx] = '1' if lst[idx] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"flip_1bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: flip k random bits, then repair toward feasibility if needed\n    if not isinstance(solution, str) or len(solution) == 0:\n        solution = '0' * 24\n    n = len(solution)\n    k = random.randint(2, max(2, n \/\/ 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for idx in idxs:\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n    new_sol = ''.join(lst)\n    # Feasibility repair heuristic: add items maximizing time per score until time >= 670\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    def total_time(sol):\n        return sum(t for bit, t in zip(sol, times) if bit == '1')\n    if total_time(new_sol) < 670:\n        order = sorted(range(24), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_t = total_time(new_sol)\n        for i in order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_t += times[i]\n                if cur_t >= 670:\n                    break\n        new_sol = ''.join(lst)\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000706}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index i in [1..24] maps to bit i-1; bit '1' means attraction i is selected for the friend to visit","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Representation: 24-length binary string; '1' means friend visits that attraction.\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 10**9\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    total_time = sum(t for bit, t in zip(solution, times) if bit == '1')\n    total_score = sum(s for bit, s in zip(solution, scores) if bit == '1')\n    # Objective: minimize total_score subject to total_time >= 670\n    if total_time >= 670:\n        return float(total_score)\n    deficit = 670 - total_time\n    # Large penalty plus small tie-breaker on score\n    return float(100000 + deficit * 1000 + total_score)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbour: flip one random bit\n    if not isinstance(solution, str) or len(solution) == 0:\n        # default to a zero vector\n        solution = '0' * 24\n    n = len(solution)\n    idx = random.randrange(n)\n    lst = list(solution)\n    lst[idx] = '1' if lst[idx] == '0' else '0'\n    new_sol = ''.join(lst)\n    return (new_sol, \"flip_1bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Stronger shake: flip k random bits, then repair toward feasibility if needed\n    if not isinstance(solution, str) or len(solution) == 0:\n        solution = '0' * 24\n    n = len(solution)\n    k = random.randint(2, max(2, n \/\/ 5))\n    idxs = random.sample(range(n), k)\n    lst = list(solution)\n    for idx in idxs:\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n    new_sol = ''.join(lst)\n    # Feasibility repair heuristic: add items maximizing time per score until time >= 670\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    def total_time(sol):\n        return sum(t for bit, t in zip(sol, times) if bit == '1')\n    if total_time(new_sol) < 670:\n        order = sorted(range(24), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_t = total_time(new_sol)\n        for i in order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_t += times[i]\n                if cur_t >= 670:\n                    break\n        new_sol = ''.join(lst)\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000035199}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate representation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Objective: minimize total_score subject to total_time >= 670\n    if total_time >= 670:\n        return float(total_score)\n    deficit = 670 - total_time\n    # Scaled penalty to guide toward feasibility without dwarfing objective\n    return float(10000 + deficit * 100 + total_score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: 24-bit string; ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data for light repair\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def totals(sol):\n        tt = 0; ts = 0\n        for b, s, t in zip(sol, scores, times):\n            if b == '1':\n                tt += t; ts += s\n        return tt, ts\n\n    lst = list(solution)\n\n    move_choice = random.random()\n    move_type = \"\"\n    if move_choice < 0.4:\n        # Flip 1 random bit\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    elif move_choice < 0.8:\n        # Flip 2 random distinct bits\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n    else:\n        # 1-in-1-out swap if possible; otherwise fallback to single flip\n        ones = [i for i, b in enumerate(lst) if b == '1']\n        zeros = [i for i, b in enumerate(lst) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            lst[i] = '0'\n            lst[j] = '1'\n            move_type = \"swap_1in1out\"\n        else:\n            idx = random.randrange(n)\n            lst[idx] = '1' if lst[idx] == '0' else '0'\n            move_type = \"flip_1bit_fallback\"\n\n    new_sol = ''.join(lst)\n\n    # Light feasibility repair toward time >= 670\n    ttime, _ = totals(new_sol)\n    if ttime < 670:\n        # Add items with highest time per score\n        eff_order = sorted(range(n), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_time = ttime\n        for i in eff_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                if cur_time >= 670:\n                    break\n        new_sol = ''.join(lst)\n    else:\n        # Try to trim redundant items with worst efficiency while keeping feasibility\n        lst = list(new_sol)\n        # candidates to remove: low time\/score (i.e., high score per time)\n        rem_order = sorted([i for i, b in enumerate(lst) if b == '1'], key=lambda i: (scores[i] \/ max(1, times[i]), -scores[i]), reverse=True)\n        cur_time, _ = totals(new_sol)\n        for i in rem_order:\n            if lst[i] == '1' and cur_time - times[i] >= 670:\n                lst[i] = '0'\n                cur_time -= times[i]\n        new_sol = ''.join(lst)\n\n    return (new_sol, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sol):\n        tt = 0\n        for b, t in zip(sol, times):\n            if b == '1':\n                tt += t\n        return tt\n\n    lst = list(solution)\n    nbits = random.randint(3, max(3, n \/\/ 4))\n    idxs = random.sample(range(n), nbits)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n\n    # Feasibility repair: add high time\/score items until >=670, then trim highest score\/time items\n    if total_time(new_sol) < 670:\n        add_order = sorted(range(n), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_t = total_time(new_sol)\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_t += times[i]\n                if cur_t >= 670:\n                    break\n        new_sol = ''.join(lst)\n\n    # Trim phase to reduce score while keeping time >= 670\n    lst = list(new_sol)\n    rem_order = sorted([i for i, b in enumerate(lst) if b == '1'], key=lambda i: (scores[i] \/ max(1, times[i]), -scores[i]), reverse=True)\n    cur_t = total_time(new_sol)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= 670:\n            lst[i] = '0'\n            cur_t -= times[i]\n    new_sol = ''.join(lst)\n\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.0000143}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate representation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Objective: minimize total_score subject to total_time >= 670\n    if total_time >= 670:\n        return float(total_score)\n    deficit = 670 - total_time\n    # Scaled penalty to guide toward feasibility without dwarfing objective\n    return float(10000 + deficit * 100 + total_score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: 24-bit string; ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data for light repair\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def totals(sol):\n        tt = 0; ts = 0\n        for b, s, t in zip(sol, scores, times):\n            if b == '1':\n                tt += t; ts += s\n        return tt, ts\n\n    lst = list(solution)\n\n    move_choice = random.random()\n    move_type = \"\"\n    if move_choice < 0.4:\n        # Flip 1 random bit\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    elif move_choice < 0.8:\n        # Flip 2 random distinct bits\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n    else:\n        # 1-in-1-out swap if possible; otherwise fallback to single flip\n        ones = [i for i, b in enumerate(lst) if b == '1']\n        zeros = [i for i, b in enumerate(lst) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            lst[i] = '0'\n            lst[j] = '1'\n            move_type = \"swap_1in1out\"\n        else:\n            idx = random.randrange(n)\n            lst[idx] = '1' if lst[idx] == '0' else '0'\n            move_type = \"flip_1bit_fallback\"\n\n    new_sol = ''.join(lst)\n\n    # Light feasibility repair toward time >= 670\n    ttime, _ = totals(new_sol)\n    if ttime < 670:\n        # Add items with highest time per score\n        eff_order = sorted(range(n), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_time = ttime\n        for i in eff_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                if cur_time >= 670:\n                    break\n        new_sol = ''.join(lst)\n    else:\n        # Try to trim redundant items with worst efficiency while keeping feasibility\n        lst = list(new_sol)\n        # candidates to remove: low time\/score (i.e., high score per time)\n        rem_order = sorted([i for i, b in enumerate(lst) if b == '1'], key=lambda i: (scores[i] \/ max(1, times[i]), -scores[i]), reverse=True)\n        cur_time, _ = totals(new_sol)\n        for i in rem_order:\n            if lst[i] == '1' and cur_time - times[i] >= 670:\n                lst[i] = '0'\n                cur_time -= times[i]\n        new_sol = ''.join(lst)\n\n    return (new_sol, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sol):\n        tt = 0\n        for b, t in zip(sol, times):\n            if b == '1':\n                tt += t\n        return tt\n\n    lst = list(solution)\n    nbits = random.randint(3, max(3, n \/\/ 4))\n    idxs = random.sample(range(n), nbits)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n\n    # Feasibility repair: add high time\/score items until >=670, then trim highest score\/time items\n    if total_time(new_sol) < 670:\n        add_order = sorted(range(n), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_t = total_time(new_sol)\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_t += times[i]\n                if cur_t >= 670:\n                    break\n        new_sol = ''.join(lst)\n\n    # Trim phase to reduce score while keeping time >= 670\n    lst = list(new_sol)\n    rem_order = sorted([i for i, b in enumerate(lst) if b == '1'], key=lambda i: (scores[i] \/ max(1, times[i]), -scores[i]), reverse=True)\n    cur_t = total_time(new_sol)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= 670:\n            lst[i] = '0'\n            cur_t -= times[i]\n    new_sol = ''.join(lst)\n\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.0000043401}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate representation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Objective: minimize total_score subject to total_time >= 670\n    if total_time >= 670:\n        return float(total_score)\n    deficit = 670 - total_time\n    # Scaled penalty to guide toward feasibility without dwarfing objective\n    return float(10000 + deficit * 100 + total_score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: 24-bit string; ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data for light repair\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def totals(sol):\n        tt = 0; ts = 0\n        for b, s, t in zip(sol, scores, times):\n            if b == '1':\n                tt += t; ts += s\n        return tt, ts\n\n    lst = list(solution)\n\n    move_choice = random.random()\n    move_type = \"\"\n    if move_choice < 0.4:\n        # Flip 1 random bit\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    elif move_choice < 0.8:\n        # Flip 2 random distinct bits\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n    else:\n        # 1-in-1-out swap if possible; otherwise fallback to single flip\n        ones = [i for i, b in enumerate(lst) if b == '1']\n        zeros = [i for i, b in enumerate(lst) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            j = random.choice(zeros)\n            lst[i] = '0'\n            lst[j] = '1'\n            move_type = \"swap_1in1out\"\n        else:\n            idx = random.randrange(n)\n            lst[idx] = '1' if lst[idx] == '0' else '0'\n            move_type = \"flip_1bit_fallback\"\n\n    new_sol = ''.join(lst)\n\n    # Light feasibility repair toward time >= 670\n    ttime, _ = totals(new_sol)\n    if ttime < 670:\n        # Add items with highest time per score\n        eff_order = sorted(range(n), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_time = ttime\n        for i in eff_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                if cur_time >= 670:\n                    break\n        new_sol = ''.join(lst)\n    else:\n        # Try to trim redundant items with worst efficiency while keeping feasibility\n        lst = list(new_sol)\n        # candidates to remove: low time\/score (i.e., high score per time)\n        rem_order = sorted([i for i, b in enumerate(lst) if b == '1'], key=lambda i: (scores[i] \/ max(1, times[i]), -scores[i]), reverse=True)\n        cur_time, _ = totals(new_sol)\n        for i in rem_order:\n            if lst[i] == '1' and cur_time - times[i] >= 670:\n                lst[i] = '0'\n                cur_time -= times[i]\n        new_sol = ''.join(lst)\n\n    return (new_sol, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    def total_time(sol):\n        tt = 0\n        for b, t in zip(sol, times):\n            if b == '1':\n                tt += t\n        return tt\n\n    lst = list(solution)\n    nbits = random.randint(3, max(3, n \/\/ 4))\n    idxs = random.sample(range(n), nbits)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    new_sol = ''.join(lst)\n\n    # Feasibility repair: add high time\/score items until >=670, then trim highest score\/time items\n    if total_time(new_sol) < 670:\n        add_order = sorted(range(n), key=lambda i: (times[i] \/ max(1, scores[i]), -times[i]), reverse=True)\n        lst = list(new_sol)\n        cur_t = total_time(new_sol)\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_t += times[i]\n                if cur_t >= 670:\n                    break\n        new_sol = ''.join(lst)\n\n    # Trim phase to reduce score while keeping time >= 670\n    lst = list(new_sol)\n    rem_order = sorted([i for i, b in enumerate(lst) if b == '1'], key=lambda i: (scores[i] \/ max(1, times[i]), -scores[i]), reverse=True)\n    cur_t = total_time(new_sol)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= 670:\n            lst[i] = '0'\n            cur_t -= times[i]\n    new_sol = ''.join(lst)\n\n    return new_sol\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.00000277}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Representation validation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Feasible: objective is to minimize total_score\n    if total_time >= target_time:\n        return float(total_score)\n    # Infeasible: linear penalty with calibrated slope just above max score-per-minute\n    max_spm = max(s \/ t for s, t in zip(scores, times))\n    M = max_spm + 1e-3\n    deficit = target_time - total_time\n    return float(total_score + M * deficit)","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def totals(sol):\n        tt = 0\n        ts = 0\n        for b, s, t in zip(sol, scores, times):\n            if b == '1':\n                tt += t\n                ts += s\n        return tt, ts\n\n    lst = list(solution)\n    cur_time, cur_score = totals(solution)\n\n    # Helper orders (precomputed each call; n is small)\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n    # High score-per-time for removal priority\n    rem_order = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    # High time-per-score for addition priority (maximize time gain per score cost)\n    add_order = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n\n    move_type = \"random\"\n\n    if cur_time < target_time:\n        # Infeasible: greedily add until feasible by best time-per-score\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                cur_score += scores[i]\n                if cur_time >= target_time:\n                    move_type = \"add_greedy_repair\"\n                    break\n        # If still not feasible (edge), flip a random zero\n        if cur_time < target_time and zeros_idx:\n            j = random.choice(zeros_idx)\n            if lst[j] == '0':\n                lst[j] = '1'\n                move_type = \"add_random_fallback\"\n        return (''.join(lst), move_type)\n\n    # Feasible: try to improve (reduce score) while keeping time >= target\n    # 1) Pure removal if slack allows\n    for i in rem_order:\n        if cur_time - times[i] >= target_time:\n            lst[i] = '0'\n            move_type = \"remove_slack\"\n            return (''.join(lst), move_type)\n\n    # 2) 1-in-1-out: try limited candidate pairs to reduce score\n    best_pair = None\n    best_delta = 0  # want negative\n    # Limit candidates for efficiency\n    cand_rem = rem_order[:min(8, len(rem_order))]\n    cand_add = add_order[:min(10, len(add_order))]\n    for i in cand_rem:\n        for j in cand_add:\n            if lst[i] == '1' and lst[j] == '0':\n                new_time = cur_time - times[i] + times[j]\n                if new_time >= target_time:\n                    delta_score = scores[j] - scores[i]\n                    if delta_score < best_delta:\n                        best_delta = delta_score\n                        best_pair = (i, j)\n    if best_pair is not None:\n        i, j = best_pair\n        lst[i] = '0'\n        lst[j] = '1'\n        move_type = \"swap_1in1out_improve\"\n        return (''.join(lst), move_type)\n\n    # 3) As a diversification, flip 1 or 2 bits then repair\/trim minimally\n    move_choice = random.random()\n    if move_choice < 0.5 and (ones_idx or zeros_idx):\n        # flip 1 bit\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    else:\n        # flip 2 distinct bits\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n\n    # Light repair after diversification\n    # Recompute quick totals\n    cur_time2 = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_time2 += t\n    if cur_time2 < target_time:\n        # add best time-per-score until feasible\n        add_order2 = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order2:\n            lst[i] = '1'\n            cur_time2 += times[i]\n            if cur_time2 >= target_time:\n                break\n    else:\n        # trim if possible without breaking feasibility\n        rem_order2 = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n        for i in rem_order2:\n            if cur_time2 - times[i] >= target_time:\n                lst[i] = '0'\n                cur_time2 -= times[i]\n    return (''.join(lst), move_type)","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair and final trim\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def total_time(sol_list):\n        tt = 0\n        for b, t in zip(sol_list, times):\n            if b == '1':\n                tt += t\n        return tt\n\n    lst = list(solution)\n\n    # Identify candidates\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n    # Remove a few high score-per-time ones\n    rem_sorted = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    k_remove = min(len(rem_sorted), random.randint(1, max(1, n \/\/ 8)))\n    for i in rem_sorted[:k_remove]:\n        lst[i] = '0'\n    # Add a few low score, high time-per-score zeros\n    add_sorted = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n    k_add = min(len(add_sorted), random.randint(2, max(2, n \/\/ 6)))\n    for j in add_sorted[:k_add]:\n        lst[j] = '1'\n\n    # Repair to meet time if needed\n    cur_t = total_time(lst)\n    if cur_t < target_time:\n        add_order = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order:\n            lst[i] = '1'\n            cur_t += times[i]\n            if cur_t >= target_time:\n                break\n\n    # Trim to reduce score while keeping feasibility\n    rem_order = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= target_time:\n            lst[i] = '0'\n            cur_t -= times[i]\n\n    return ''.join(lst)","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001546}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Representation validation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Feasible: objective is to minimize total_score\n    if total_time >= target_time:\n        return float(total_score)\n    # Infeasible: linear penalty with calibrated slope just above max score-per-minute\n    max_spm = max(s \/ t for s, t in zip(scores, times))\n    M = max_spm + 1e-3\n    deficit = target_time - total_time\n    return float(total_score + M * deficit)","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def totals(sol):\n        tt = 0\n        ts = 0\n        for b, s, t in zip(sol, scores, times):\n            if b == '1':\n                tt += t\n                ts += s\n        return tt, ts\n\n    lst = list(solution)\n    cur_time, cur_score = totals(solution)\n\n    # Helper orders (precomputed each call; n is small)\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n    # High score-per-time for removal priority\n    rem_order = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    # High time-per-score for addition priority (maximize time gain per score cost)\n    add_order = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n\n    move_type = \"random\"\n\n    if cur_time < target_time:\n        # Infeasible: greedily add until feasible by best time-per-score\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                cur_score += scores[i]\n                if cur_time >= target_time:\n                    move_type = \"add_greedy_repair\"\n                    break\n        # If still not feasible (edge), flip a random zero\n        if cur_time < target_time and zeros_idx:\n            j = random.choice(zeros_idx)\n            if lst[j] == '0':\n                lst[j] = '1'\n                move_type = \"add_random_fallback\"\n        return (''.join(lst), move_type)\n\n    # Feasible: try to improve (reduce score) while keeping time >= target\n    # 1) Pure removal if slack allows\n    for i in rem_order:\n        if cur_time - times[i] >= target_time:\n            lst[i] = '0'\n            move_type = \"remove_slack\"\n            return (''.join(lst), move_type)\n\n    # 2) 1-in-1-out: try limited candidate pairs to reduce score\n    best_pair = None\n    best_delta = 0  # want negative\n    # Limit candidates for efficiency\n    cand_rem = rem_order[:min(8, len(rem_order))]\n    cand_add = add_order[:min(10, len(add_order))]\n    for i in cand_rem:\n        for j in cand_add:\n            if lst[i] == '1' and lst[j] == '0':\n                new_time = cur_time - times[i] + times[j]\n                if new_time >= target_time:\n                    delta_score = scores[j] - scores[i]\n                    if delta_score < best_delta:\n                        best_delta = delta_score\n                        best_pair = (i, j)\n    if best_pair is not None:\n        i, j = best_pair\n        lst[i] = '0'\n        lst[j] = '1'\n        move_type = \"swap_1in1out_improve\"\n        return (''.join(lst), move_type)\n\n    # 3) As a diversification, flip 1 or 2 bits then repair\/trim minimally\n    move_choice = random.random()\n    if move_choice < 0.5 and (ones_idx or zeros_idx):\n        # flip 1 bit\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    else:\n        # flip 2 distinct bits\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n\n    # Light repair after diversification\n    # Recompute quick totals\n    cur_time2 = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_time2 += t\n    if cur_time2 < target_time:\n        # add best time-per-score until feasible\n        add_order2 = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order2:\n            lst[i] = '1'\n            cur_time2 += times[i]\n            if cur_time2 >= target_time:\n                break\n    else:\n        # trim if possible without breaking feasibility\n        rem_order2 = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n        for i in rem_order2:\n            if cur_time2 - times[i] >= target_time:\n                lst[i] = '0'\n                cur_time2 -= times[i]\n    return (''.join(lst), move_type)","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair and final trim\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def total_time(sol_list):\n        tt = 0\n        for b, t in zip(sol_list, times):\n            if b == '1':\n                tt += t\n        return tt\n\n    lst = list(solution)\n\n    # Identify candidates\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n    # Remove a few high score-per-time ones\n    rem_sorted = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    k_remove = min(len(rem_sorted), random.randint(1, max(1, n \/\/ 8)))\n    for i in rem_sorted[:k_remove]:\n        lst[i] = '0'\n    # Add a few low score, high time-per-score zeros\n    add_sorted = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n    k_add = min(len(add_sorted), random.randint(2, max(2, n \/\/ 6)))\n    for j in add_sorted[:k_add]:\n        lst[j] = '1'\n\n    # Repair to meet time if needed\n    cur_t = total_time(lst)\n    if cur_t < target_time:\n        add_order = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order:\n            lst[i] = '1'\n            cur_t += times[i]\n            if cur_t >= target_time:\n                break\n\n    # Trim to reduce score while keeping feasibility\n    rem_order = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= target_time:\n            lst[i] = '0'\n            cur_t -= times[i]\n\n    return ''.join(lst)","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000434}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Representation validation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Feasible: objective is to minimize total_score\n    if total_time >= target_time:\n        return float(total_score)\n    # Infeasible: linear penalty with calibrated slope just above max score-per-minute\n    max_spm = max(s \/ t for s, t in zip(scores, times))\n    M = max_spm + 1e-3\n    deficit = target_time - total_time\n    return float(total_score + M * deficit)","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def totals(sol):\n        tt = 0\n        ts = 0\n        for b, s, t in zip(sol, scores, times):\n            if b == '1':\n                tt += t\n                ts += s\n        return tt, ts\n\n    lst = list(solution)\n    cur_time, cur_score = totals(solution)\n\n    # Helper orders (precomputed each call; n is small)\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n    # High score-per-time for removal priority\n    rem_order = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    # High time-per-score for addition priority (maximize time gain per score cost)\n    add_order = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n\n    move_type = \"random\"\n\n    if cur_time < target_time:\n        # Infeasible: greedily add until feasible by best time-per-score\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                cur_score += scores[i]\n                if cur_time >= target_time:\n                    move_type = \"add_greedy_repair\"\n                    break\n        # If still not feasible (edge), flip a random zero\n        if cur_time < target_time and zeros_idx:\n            j = random.choice(zeros_idx)\n            if lst[j] == '0':\n                lst[j] = '1'\n                move_type = \"add_random_fallback\"\n        return (''.join(lst), move_type)\n\n    # Feasible: try to improve (reduce score) while keeping time >= target\n    # 1) Pure removal if slack allows\n    for i in rem_order:\n        if cur_time - times[i] >= target_time:\n            lst[i] = '0'\n            move_type = \"remove_slack\"\n            return (''.join(lst), move_type)\n\n    # 2) 1-in-1-out: try limited candidate pairs to reduce score\n    best_pair = None\n    best_delta = 0  # want negative\n    # Limit candidates for efficiency\n    cand_rem = rem_order[:min(8, len(rem_order))]\n    cand_add = add_order[:min(10, len(add_order))]\n    for i in cand_rem:\n        for j in cand_add:\n            if lst[i] == '1' and lst[j] == '0':\n                new_time = cur_time - times[i] + times[j]\n                if new_time >= target_time:\n                    delta_score = scores[j] - scores[i]\n                    if delta_score < best_delta:\n                        best_delta = delta_score\n                        best_pair = (i, j)\n    if best_pair is not None:\n        i, j = best_pair\n        lst[i] = '0'\n        lst[j] = '1'\n        move_type = \"swap_1in1out_improve\"\n        return (''.join(lst), move_type)\n\n    # 3) As a diversification, flip 1 or 2 bits then repair\/trim minimally\n    move_choice = random.random()\n    if move_choice < 0.5 and (ones_idx or zeros_idx):\n        # flip 1 bit\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    else:\n        # flip 2 distinct bits\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n\n    # Light repair after diversification\n    # Recompute quick totals\n    cur_time2 = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_time2 += t\n    if cur_time2 < target_time:\n        # add best time-per-score until feasible\n        add_order2 = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order2:\n            lst[i] = '1'\n            cur_time2 += times[i]\n            if cur_time2 >= target_time:\n                break\n    else:\n        # trim if possible without breaking feasibility\n        rem_order2 = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n        for i in rem_order2:\n            if cur_time2 - times[i] >= target_time:\n                lst[i] = '0'\n                cur_time2 -= times[i]\n    return (''.join(lst), move_type)","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair and final trim\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def total_time(sol_list):\n        tt = 0\n        for b, t in zip(sol_list, times):\n            if b == '1':\n                tt += t\n        return tt\n\n    lst = list(solution)\n\n    # Identify candidates\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n    # Remove a few high score-per-time ones\n    rem_sorted = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    k_remove = min(len(rem_sorted), random.randint(1, max(1, n \/\/ 8)))\n    for i in rem_sorted[:k_remove]:\n        lst[i] = '0'\n    # Add a few low score, high time-per-score zeros\n    add_sorted = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n    k_add = min(len(add_sorted), random.randint(2, max(2, n \/\/ 6)))\n    for j in add_sorted[:k_add]:\n        lst[j] = '1'\n\n    # Repair to meet time if needed\n    cur_t = total_time(lst)\n    if cur_t < target_time:\n        add_order = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order:\n            lst[i] = '1'\n            cur_t += times[i]\n            if cur_t >= target_time:\n                break\n\n    # Trim to reduce score while keeping feasibility\n    rem_order = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= target_time:\n            lst[i] = '0'\n            cur_t -= times[i]\n\n    return ''.join(lst)","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.00000298}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate representation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Objective: minimize total_score subject to total_time >= target_time\n    if total_time >= target_time:\n        return float(total_score)\n    # Penalty for infeasibility: calibrated linear penalty\n    max_spm = 0.0\n    for s, t in zip(scores, times):\n        ratio = s \/ t\n        if ratio > max_spm:\n            max_spm = ratio\n    M = max_spm + 1e-3\n    deficit = target_time - total_time\n    return float(total_score + M * deficit)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def totals(sol_list):\n        tt = 0\n        ts = 0\n        for b, s, t in zip(sol_list, scores, times):\n            if b == '1':\n                tt += t\n                ts += s\n        return tt, ts\n\n    lst = list(solution)\n    cur_time, cur_score = totals(lst)\n\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n\n    # Priorities\n    rem_order = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    add_order = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n\n    move_type = \"random\"\n\n    if cur_time < target_time:\n        # Infeasible: greedily add by best time-per-score until feasible\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                cur_score += scores[i]\n                if cur_time >= target_time:\n                    move_type = \"add_greedy_repair\"\n                    break\n        # Fallback random add if still infeasible\n        if cur_time < target_time and zeros_idx:\n            j = random.choice(zeros_idx)\n            if lst[j] == '0':\n                lst[j] = '1'\n                move_type = \"add_random_fallback\"\n        return (''.join(lst), move_type)\n\n    # Feasible: try to reduce score while keeping time >= target\n    # 1) Remove with slack\n    for i in rem_order:\n        if cur_time - times[i] >= target_time:\n            lst[i] = '0'\n            move_type = \"remove_slack\"\n            return (''.join(lst), move_type)\n\n    # 2) 1-in-1-out swaps\n    best_pair = None\n    best_delta = 0  # want negative\n    cand_rem = rem_order[:min(8, len(rem_order))]\n    cand_add = add_order[:min(10, len(add_order))]\n    for i in cand_rem:\n        for j in cand_add:\n            if lst[i] == '1' and lst[j] == '0':\n                new_time = cur_time - times[i] + times[j]\n                if new_time >= target_time:\n                    delta_score = scores[j] - scores[i]\n                    if delta_score < best_delta:\n                        best_delta = delta_score\n                        best_pair = (i, j)\n    if best_pair is not None:\n        i, j = best_pair\n        lst[i] = '0'\n        lst[j] = '1'\n        move_type = \"swap_1in1out_improve\"\n        return (''.join(lst), move_type)\n\n    # 3) Diversification: flip bits then repair\/trim\n    if random.random() < 0.5:\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    else:\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n\n    # Repair feasibility if needed\n    cur_time2 = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_time2 += t\n    if cur_time2 < target_time:\n        add_order2 = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order2:\n            lst[i] = '1'\n            cur_time2 += times[i]\n            if cur_time2 >= target_time:\n                break\n    else:\n        rem_order2 = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n        for i in rem_order2:\n            if cur_time2 - times[i] >= target_time:\n                lst[i] = '0'\n                cur_time2 -= times[i]\n    return (''.join(lst), move_type)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair and final trim\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    lst = list(solution)\n\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n\n    # Remove a few high score-per-time ones\n    rem_sorted = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    k_remove = min(len(rem_sorted), 1 + (n \/\/ 10))\n    for i in rem_sorted[:k_remove]:\n        lst[i] = '0'\n\n    # Add a few high time-per-score zeros\n    add_sorted = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n    k_add = min(len(add_sorted), 2 + (n \/\/ 12))\n    for j in add_sorted[:k_add]:\n        lst[j] = '1'\n\n    # Repair to meet time if needed\n    cur_t = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_t += t\n    if cur_t < target_time:\n        add_order = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order:\n            lst[i] = '1'\n            cur_t += times[i]\n            if cur_t >= target_time:\n                break\n\n    # Trim to reduce score while keeping feasibility\n    rem_order = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= target_time:\n            lst[i] = '0'\n            cur_t -= times[i]\n\n    return ''.join(lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"SA","Tiempo":0.00001558}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate representation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Objective: minimize total_score subject to total_time >= target_time\n    if total_time >= target_time:\n        return float(total_score)\n    # Penalty for infeasibility: calibrated linear penalty\n    max_spm = 0.0\n    for s, t in zip(scores, times):\n        ratio = s \/ t\n        if ratio > max_spm:\n            max_spm = ratio\n    M = max_spm + 1e-3\n    deficit = target_time - total_time\n    return float(total_score + M * deficit)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def totals(sol_list):\n        tt = 0\n        ts = 0\n        for b, s, t in zip(sol_list, scores, times):\n            if b == '1':\n                tt += t\n                ts += s\n        return tt, ts\n\n    lst = list(solution)\n    cur_time, cur_score = totals(lst)\n\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n\n    # Priorities\n    rem_order = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    add_order = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n\n    move_type = \"random\"\n\n    if cur_time < target_time:\n        # Infeasible: greedily add by best time-per-score until feasible\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                cur_score += scores[i]\n                if cur_time >= target_time:\n                    move_type = \"add_greedy_repair\"\n                    break\n        # Fallback random add if still infeasible\n        if cur_time < target_time and zeros_idx:\n            j = random.choice(zeros_idx)\n            if lst[j] == '0':\n                lst[j] = '1'\n                move_type = \"add_random_fallback\"\n        return (''.join(lst), move_type)\n\n    # Feasible: try to reduce score while keeping time >= target\n    # 1) Remove with slack\n    for i in rem_order:\n        if cur_time - times[i] >= target_time:\n            lst[i] = '0'\n            move_type = \"remove_slack\"\n            return (''.join(lst), move_type)\n\n    # 2) 1-in-1-out swaps\n    best_pair = None\n    best_delta = 0  # want negative\n    cand_rem = rem_order[:min(8, len(rem_order))]\n    cand_add = add_order[:min(10, len(add_order))]\n    for i in cand_rem:\n        for j in cand_add:\n            if lst[i] == '1' and lst[j] == '0':\n                new_time = cur_time - times[i] + times[j]\n                if new_time >= target_time:\n                    delta_score = scores[j] - scores[i]\n                    if delta_score < best_delta:\n                        best_delta = delta_score\n                        best_pair = (i, j)\n    if best_pair is not None:\n        i, j = best_pair\n        lst[i] = '0'\n        lst[j] = '1'\n        move_type = \"swap_1in1out_improve\"\n        return (''.join(lst), move_type)\n\n    # 3) Diversification: flip bits then repair\/trim\n    if random.random() < 0.5:\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    else:\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n\n    # Repair feasibility if needed\n    cur_time2 = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_time2 += t\n    if cur_time2 < target_time:\n        add_order2 = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order2:\n            lst[i] = '1'\n            cur_time2 += times[i]\n            if cur_time2 >= target_time:\n                break\n    else:\n        rem_order2 = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n        for i in rem_order2:\n            if cur_time2 - times[i] >= target_time:\n                lst[i] = '0'\n                cur_time2 -= times[i]\n    return (''.join(lst), move_type)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair and final trim\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    lst = list(solution)\n\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n\n    # Remove a few high score-per-time ones\n    rem_sorted = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    k_remove = min(len(rem_sorted), 1 + (n \/\/ 10))\n    for i in rem_sorted[:k_remove]:\n        lst[i] = '0'\n\n    # Add a few high time-per-score zeros\n    add_sorted = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n    k_add = min(len(add_sorted), 2 + (n \/\/ 12))\n    for j in add_sorted[:k_add]:\n        lst[j] = '1'\n\n    # Repair to meet time if needed\n    cur_t = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_t += t\n    if cur_t < target_time:\n        add_order = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order:\n            lst[i] = '1'\n            cur_t += times[i]\n            if cur_t >= target_time:\n                break\n\n    # Trim to reduce score while keeping feasibility\n    rem_order = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= target_time:\n            lst[i] = '0'\n            cur_t -= times[i]\n\n    return ''.join(lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"ILS","Tiempo":0.00000608}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; index 1..24 -> bit i-1; '1' means friend visits attraction i","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate representation\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return float(10**9)\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n    # Compute totals\n    total_time = 0\n    total_score = 0\n    for bit, s, t in zip(solution, scores, times):\n        if bit == '1':\n            total_time += t\n            total_score += s\n    # Objective: minimize total_score subject to total_time >= target_time\n    if total_time >= target_time:\n        return float(total_score)\n    # Penalty for infeasibility: calibrated linear penalty\n    max_spm = 0.0\n    for s, t in zip(scores, times):\n        ratio = s \/ t\n        if ratio > max_spm:\n            max_spm = ratio\n    M = max_spm + 1e-3\n    deficit = target_time - total_time\n    return float(total_score + M * deficit)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid base\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    def totals(sol_list):\n        tt = 0\n        ts = 0\n        for b, s, t in zip(sol_list, scores, times):\n            if b == '1':\n                tt += t\n                ts += s\n        return tt, ts\n\n    lst = list(solution)\n    cur_time, cur_score = totals(lst)\n\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n\n    # Priorities\n    rem_order = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    add_order = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n\n    move_type = \"random\"\n\n    if cur_time < target_time:\n        # Infeasible: greedily add by best time-per-score until feasible\n        for i in add_order:\n            if lst[i] == '0':\n                lst[i] = '1'\n                cur_time += times[i]\n                cur_score += scores[i]\n                if cur_time >= target_time:\n                    move_type = \"add_greedy_repair\"\n                    break\n        # Fallback random add if still infeasible\n        if cur_time < target_time and zeros_idx:\n            j = random.choice(zeros_idx)\n            if lst[j] == '0':\n                lst[j] = '1'\n                move_type = \"add_random_fallback\"\n        return (''.join(lst), move_type)\n\n    # Feasible: try to reduce score while keeping time >= target\n    # 1) Remove with slack\n    for i in rem_order:\n        if cur_time - times[i] >= target_time:\n            lst[i] = '0'\n            move_type = \"remove_slack\"\n            return (''.join(lst), move_type)\n\n    # 2) 1-in-1-out swaps\n    best_pair = None\n    best_delta = 0  # want negative\n    cand_rem = rem_order[:min(8, len(rem_order))]\n    cand_add = add_order[:min(10, len(add_order))]\n    for i in cand_rem:\n        for j in cand_add:\n            if lst[i] == '1' and lst[j] == '0':\n                new_time = cur_time - times[i] + times[j]\n                if new_time >= target_time:\n                    delta_score = scores[j] - scores[i]\n                    if delta_score < best_delta:\n                        best_delta = delta_score\n                        best_pair = (i, j)\n    if best_pair is not None:\n        i, j = best_pair\n        lst[i] = '0'\n        lst[j] = '1'\n        move_type = \"swap_1in1out_improve\"\n        return (''.join(lst), move_type)\n\n    # 3) Diversification: flip bits then repair\/trim\n    if random.random() < 0.5:\n        idx = random.randrange(n)\n        lst[idx] = '1' if lst[idx] == '0' else '0'\n        move_type = \"flip_1bit\"\n    else:\n        i, j = random.sample(range(n), 2)\n        lst[i] = '1' if lst[i] == '0' else '0'\n        lst[j] = '1' if lst[j] == '0' else '0'\n        move_type = \"flip_2bits\"\n\n    # Repair feasibility if needed\n    cur_time2 = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_time2 += t\n    if cur_time2 < target_time:\n        add_order2 = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order2:\n            lst[i] = '1'\n            cur_time2 += times[i]\n            if cur_time2 >= target_time:\n                break\n    else:\n        rem_order2 = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n        for i in rem_order2:\n            if cur_time2 - times[i] >= target_time:\n                lst[i] = '0'\n                cur_time2 -= times[i]\n    return (''.join(lst), move_type)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger shake with feasibility repair and final trim\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = '0' * n\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    target_time = 670\n\n    lst = list(solution)\n\n    ones_idx = [i for i, b in enumerate(lst) if b == '1']\n    zeros_idx = [i for i, b in enumerate(lst) if b == '0']\n\n    # Remove a few high score-per-time ones\n    rem_sorted = sorted(ones_idx, key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    k_remove = min(len(rem_sorted), 1 + (n \/\/ 10))\n    for i in rem_sorted[:k_remove]:\n        lst[i] = '0'\n\n    # Add a few high time-per-score zeros\n    add_sorted = sorted(zeros_idx, key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n    k_add = min(len(add_sorted), 2 + (n \/\/ 12))\n    for j in add_sorted[:k_add]:\n        lst[j] = '1'\n\n    # Repair to meet time if needed\n    cur_t = 0\n    for b, t in zip(lst, times):\n        if b == '1':\n            cur_t += t\n    if cur_t < target_time:\n        add_order = sorted([i for i in range(n) if lst[i] == '0'], key=lambda i: (times[i] \/ max(1, scores[i]), times[i], -scores[i]), reverse=True)\n        for i in add_order:\n            lst[i] = '1'\n            cur_t += times[i]\n            if cur_t >= target_time:\n                break\n\n    # Trim to reduce score while keeping feasibility\n    rem_order = sorted([i for i in range(n) if lst[i] == '1'], key=lambda i: (scores[i] \/ times[i], scores[i], -times[i]), reverse=True)\n    for i in rem_order:\n        if lst[i] == '1' and cur_t - times[i] >= target_time:\n            lst[i] = '0'\n            cur_t -= times[i]\n\n    return ''.join(lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[0,1,2,3,5,7,9,10,11,13,14,15,16,17,18,19,20,21,22,23],"Valor Optimo":269,"Metaheuristica":"TS","Tiempo":0.0000054101}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"BIN_STR_LEN_24.Each position i in {1..24} indicates inclusion(1)\/exclusion(0) of item i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (weights, values) and capacity\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize solution to 24-length binary string\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    if len(s) < 24:\n        s = s + '0'*(24-len(s))\n    elif len(s) > 24:\n        s = s[:24]\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    if total_w <= capacity:\n        # Minimize cost: use negative value for maximization\n        return -float(total_v)\n    else:\n        # Heavy penalty if infeasible (cost must be large and positive)\n        overweight = total_w - capacity\n        # Penalize proportional to overweight and forego any value benefit\n        return 1e6 + overweight*1e4 + (24 - total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure binary string normalization\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return (s, \"noop\")\n\n    s_list = list(s)\n    move = None\n\n    if random.random() < 0.7 or n == 1:\n        # Single bit flip\n        i = random.randrange(n)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = \"flip_1bit\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        s_list[j] = '1' if s_list[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Strong perturbation: flip about 20% of bits (at least 1)\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return s\n    k = max(1, int(0.2 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flip_idxs = idxs[:k]\n    s_list = list(s)\n    for i in flip_idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00002073}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"BIN_STR_LEN_24.Each position i in {1..24} indicates inclusion(1)\/exclusion(0) of item i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (weights, values) and capacity\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize solution to 24-length binary string\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    if len(s) < 24:\n        s = s + '0'*(24-len(s))\n    elif len(s) > 24:\n        s = s[:24]\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    if total_w <= capacity:\n        # Minimize cost: use negative value for maximization\n        return -float(total_v)\n    else:\n        # Heavy penalty if infeasible (cost must be large and positive)\n        overweight = total_w - capacity\n        # Penalize proportional to overweight and forego any value benefit\n        return 1e6 + overweight*1e4 + (24 - total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure binary string normalization\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return (s, \"noop\")\n\n    s_list = list(s)\n    move = None\n\n    if random.random() < 0.7 or n == 1:\n        # Single bit flip\n        i = random.randrange(n)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = \"flip_1bit\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        s_list[j] = '1' if s_list[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Strong perturbation: flip about 20% of bits (at least 1)\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return s\n    k = max(1, int(0.2 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flip_idxs = idxs[:k]\n    s_list = list(s)\n    for i in flip_idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000582}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"BIN_STR_LEN_24.Each position i in {1..24} indicates inclusion(1)\/exclusion(0) of item i.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (weights, values) and capacity\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize solution to 24-length binary string\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    if len(s) < 24:\n        s = s + '0'*(24-len(s))\n    elif len(s) > 24:\n        s = s[:24]\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    if total_w <= capacity:\n        # Minimize cost: use negative value for maximization\n        return -float(total_v)\n    else:\n        # Heavy penalty if infeasible (cost must be large and positive)\n        overweight = total_w - capacity\n        # Penalize proportional to overweight and forego any value benefit\n        return 1e6 + overweight*1e4 + (24 - total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure binary string normalization\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return (s, \"noop\")\n\n    s_list = list(s)\n    move = None\n\n    if random.random() < 0.7 or n == 1:\n        # Single bit flip\n        i = random.randrange(n)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        move = \"flip_1bit\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n        s_list[j] = '1' if s_list[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    neighbour = ''.join(s_list)\n    return (neighbour, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Strong perturbation: flip about 20% of bits (at least 1)\n    s = ''.join(ch if ch in ('0','1') else '0' for ch in solution)\n    n = len(s)\n    if n == 0:\n        return s\n    k = max(1, int(0.2 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    flip_idxs = idxs[:k]\n    s_list = list(s)\n    for i in flip_idxs:\n        s_list[i] = '1' if s_list[i] == '0' else '0'\n    return ''.join(s_list)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000369}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string (positions 1..24). '1' means the item is included; '0' means excluded.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize to 24-length binary string; penalize invalid chars\n    if not isinstance(solution, str):\n        return 1e5  # hard penalty for invalid type\n    s = solution\n    # truncate\/pad\n    if len(s) < 24:\n        s = s + '0' * (24 - len(s))\n    elif len(s) > 24:\n        s = s[:24]\n    invalid = sum(ch not in ('0', '1') for ch in s)\n    if invalid > 0:\n        return 1e4 + 10.0 * invalid  # deterministic penalty keeping scale reasonable\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Adaptive, comparable penalty for infeasibility\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        overweight = total_w - capacity\n        lambda_pen = 100.0  # keeps penalties on the order of values\n        return -float(total_v) + lambda_pen * overweight\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data and helpers embedded to allow local repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        # Drop worst by value\/weight ratio, then by lower value\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n    bits = list(s)\n\n    r = random.random()\n    move = \"flip_1bit\"\n    if r < 0.5:\n        # Single bit flip\n        i = random.randrange(n)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        move = \"flip_1bit\"\n    elif r < 0.8:\n        # 1-0 exchange: turn off a low-ratio selected item and turn on a high-ratio unselected item\n        selected = [i for i, b in enumerate(bits) if b == '1']\n        unselected = [i for i, b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            on_i = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            bits[off_i] = '0'\n            bits[on_i] = '1'\n            move = \"exchange_1_1\"\n        else:\n            i = random.randrange(n)\n            bits[i] = '1' if bits[i] == '0' else '0'\n            move = \"flip_1bit_fallback\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        bits[j] = '1' if bits[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return (cand, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n\n    # Structured multi-bit perturbation: flip ~25% of bits\n    k = max(1, n \/\/ 4)\n    idx = list(range(n))\n    random.shuffle(idx)\n    bits = list(s)\n    for i in idx[:k]:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return cand\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000148001}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string (positions 1..24). '1' means the item is included; '0' means excluded.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize to 24-length binary string; penalize invalid chars\n    if not isinstance(solution, str):\n        return 1e5  # hard penalty for invalid type\n    s = solution\n    # truncate\/pad\n    if len(s) < 24:\n        s = s + '0' * (24 - len(s))\n    elif len(s) > 24:\n        s = s[:24]\n    invalid = sum(ch not in ('0', '1') for ch in s)\n    if invalid > 0:\n        return 1e4 + 10.0 * invalid  # deterministic penalty keeping scale reasonable\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Adaptive, comparable penalty for infeasibility\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        overweight = total_w - capacity\n        lambda_pen = 100.0  # keeps penalties on the order of values\n        return -float(total_v) + lambda_pen * overweight\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data and helpers embedded to allow local repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        # Drop worst by value\/weight ratio, then by lower value\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n    bits = list(s)\n\n    r = random.random()\n    move = \"flip_1bit\"\n    if r < 0.5:\n        # Single bit flip\n        i = random.randrange(n)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        move = \"flip_1bit\"\n    elif r < 0.8:\n        # 1-0 exchange: turn off a low-ratio selected item and turn on a high-ratio unselected item\n        selected = [i for i, b in enumerate(bits) if b == '1']\n        unselected = [i for i, b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            on_i = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            bits[off_i] = '0'\n            bits[on_i] = '1'\n            move = \"exchange_1_1\"\n        else:\n            i = random.randrange(n)\n            bits[i] = '1' if bits[i] == '0' else '0'\n            move = \"flip_1bit_fallback\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        bits[j] = '1' if bits[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return (cand, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n\n    # Structured multi-bit perturbation: flip ~25% of bits\n    k = max(1, n \/\/ 4)\n    idx = list(range(n))\n    random.shuffle(idx)\n    bits = list(s)\n    for i in idx[:k]:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return cand\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000421}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string (positions 1..24). '1' means the item is included; '0' means excluded.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Normalize to 24-length binary string; penalize invalid chars\n    if not isinstance(solution, str):\n        return 1e5  # hard penalty for invalid type\n    s = solution\n    # truncate\/pad\n    if len(s) < 24:\n        s = s + '0' * (24 - len(s))\n    elif len(s) > 24:\n        s = s[:24]\n    invalid = sum(ch not in ('0', '1') for ch in s)\n    if invalid > 0:\n        return 1e4 + 10.0 * invalid  # deterministic penalty keeping scale reasonable\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Adaptive, comparable penalty for infeasibility\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        overweight = total_w - capacity\n        lambda_pen = 100.0  # keeps penalties on the order of values\n        return -float(total_v) + lambda_pen * overweight\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data and helpers embedded to allow local repair\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        # Drop worst by value\/weight ratio, then by lower value\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n    bits = list(s)\n\n    r = random.random()\n    move = \"flip_1bit\"\n    if r < 0.5:\n        # Single bit flip\n        i = random.randrange(n)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        move = \"flip_1bit\"\n    elif r < 0.8:\n        # 1-0 exchange: turn off a low-ratio selected item and turn on a high-ratio unselected item\n        selected = [i for i, b in enumerate(bits) if b == '1']\n        unselected = [i for i, b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            on_i = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            bits[off_i] = '0'\n            bits[on_i] = '1'\n            move = \"exchange_1_1\"\n        else:\n            i = random.randrange(n)\n            bits[i] = '1' if bits[i] == '0' else '0'\n            move = \"flip_1bit_fallback\"\n    else:\n        # Flip two distinct bits\n        i, j = random.sample(range(n), k=2)\n        bits[i] = '1' if bits[i] == '0' else '0'\n        bits[j] = '1' if bits[j] == '0' else '0'\n        move = \"flip_2bits\"\n\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return (cand, move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    def normalize_24(s: str) -> str:\n        s = ''.join(ch if ch in ('0','1') else '0' for ch in (s if isinstance(s, str) else ''))\n        if len(s) < 24:\n            s = s + '0' * (24 - len(s))\n        elif len(s) > 24:\n            s = s[:24]\n        return s\n\n    def repair_capacity(s: str) -> str:\n        bits = list(s)\n        sel = [i for i, ch in enumerate(bits) if ch == '1']\n        total_w = sum(weights[i] for i in sel)\n        if total_w <= cap:\n            return s\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n        for i in order:\n            if total_w <= cap:\n                break\n            bits[i] = '0'\n            total_w -= weights[i]\n        return ''.join(bits)\n\n    s = normalize_24(solution)\n    n = 24\n\n    # Structured multi-bit perturbation: flip ~25% of bits\n    k = max(1, n \/\/ 4)\n    idx = list(range(n))\n    random.shuffle(idx)\n    bits = list(s)\n    for i in idx[:k]:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    cand = ''.join(bits)\n    cand = repair_capacity(cand)\n    return cand\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.000002981}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Strict validation: exact length and charset\n    if not isinstance(solution, str):\n        return 1e9\n    if len(solution) != 24:\n        return 1e9\n    if any(ch not in ('0','1') for ch in solution):\n        return 1e9\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Feasible: return negative value (lower is better). Infeasible: hard penalty.\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        # Hard penalty to dominate any feasible score\n        return 1e8 + float(total_w - capacity)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Normalize and validate; if invalid, start from empty feasible solution\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    bits = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def add_if_fits(bits_list, idx):\n        if bits_list[idx] == '1':\n            return False\n        w = total_weight(bits_list)\n        if w + weights[idx] <= cap:\n            bits_list[idx] = '1'\n            return True\n        return False\n\n    def drop_until_fits(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return False\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        # Drop worst by (value\/weight, value, weight desc)\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        changed = False\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    n = 24\n    move = \"flip\"\n    r = random.random()\n\n    # Compute current weight once\n    cur_w = total_weight(bits)\n\n    if r < 0.4:\n        # Add-best-by-ratio if fits\n        cand = max(range(n), key=lambda i: (values[i] \/ max(1, weights[i]), values[i]) if bits[i] == '0' else (-1e9, -1e9))\n        if add_if_fits(bits, cand):\n            move = \"add_best_ratio\"\n        else:\n            # Try dropping worst then add\n            drop_until_fits(bits)\n            if add_if_fits(bits, cand):\n                move = \"drop_then_add\"\n            else:\n                # No change possible, fallback to do-nothing feasible return\n                return (''.join(bits), \"noop\")\n    elif r < 0.8:\n        # Exchange 1-1: drop worst add best by ratio with feasibility check\n        selected = [i for i,b in enumerate(bits) if b == '1']\n        unselected = [i for i,b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n            on_i  = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            # Perform if it fits\n            new_w = cur_w - weights[off_i] + weights[on_i]\n            if new_w <= cap:\n                bits[off_i] = '0'\n                bits[on_i]  = '1'\n                move = \"exchange_1_1\"\n            else:\n                # Try drop more until fits after swap attempt\n                bits[off_i] = '0'\n                if total_weight(bits) + weights[on_i] <= cap:\n                    bits[on_i] = '1'\n                    move = \"drop_more_then_add\"\n                else:\n                    move = \"drop_only\"\n        else:\n            return (''.join(bits), \"noop\")\n    else:\n        # Toggle ultra-light items first (w<=3) guided by ratio\n        ul_idx = [i for i,w in enumerate(weights) if w <= 3]\n        if ul_idx:\n            # Prefer adding best ultra-light if fits; otherwise remove worst ultra-light\n            addables = [i for i in ul_idx if bits[i] == '0' and cur_w + weights[i] <= cap]\n            if addables:\n                on_i = max(addables, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n                bits[on_i] = '1'\n                move = \"add_ultralight\"\n            else:\n                selected_ul = [i for i in ul_idx if bits[i] == '1']\n                if selected_ul:\n                    off_i = min(selected_ul, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n                    bits[off_i] = '0'\n                    move = \"remove_ultralight\"\n                else:\n                    return (''.join(bits), \"noop\")\n        else:\n            return (''.join(bits), \"noop\")\n\n    # Ensure feasibility\n    drop_until_fits(bits)\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Validate base\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        base = ['0'] * 24\n    else:\n        base = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def repair(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return bits_list\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n        return bits_list\n\n    n = 24\n    k = max(2, min(4, n \/\/ 6))  # flip\/exchange 2..4 bits\n\n    # Build candidate by performing k exchanges biased by ratio\n    bits = base[:]\n\n    # Try to add top-k unselected by ratio\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    ranked_add = sorted(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]), reverse=True)\n    adds = ranked_add[:k]\n    for i in adds:\n        bits[i] = '1'\n\n    # Drop until fit preferring worst items\n    bits = repair(bits)\n\n    # Randomize a couple of further toggles within feasibility\n    attempts = 6\n    for _ in range(attempts):\n        i = random.randrange(n)\n        if bits[i] == '1':\n            # Try swapping out i for a better ratio j\n            candidates = [j for j in range(n) if bits[j] == '0']\n            if not candidates:\n                continue\n            j = max(candidates, key=lambda idx: (values[idx] \/ max(1, weights[idx]), values[idx]))\n            new_w = total_weight(bits) - weights[i] + weights[j]\n            if new_w <= cap:\n                bits[i] = '0'\n                bits[j] = '1'\n        else:\n            # Try adding if fits\n            if total_weight(bits) + weights[i] <= cap:\n                bits[i] = '1'\n    bits = repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000015161}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Strict validation: exact length and charset\n    if not isinstance(solution, str):\n        return 1e9\n    if len(solution) != 24:\n        return 1e9\n    if any(ch not in ('0','1') for ch in solution):\n        return 1e9\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Feasible: return negative value (lower is better). Infeasible: hard penalty.\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        # Hard penalty to dominate any feasible score\n        return 1e8 + float(total_w - capacity)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Normalize and validate; if invalid, start from empty feasible solution\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    bits = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def add_if_fits(bits_list, idx):\n        if bits_list[idx] == '1':\n            return False\n        w = total_weight(bits_list)\n        if w + weights[idx] <= cap:\n            bits_list[idx] = '1'\n            return True\n        return False\n\n    def drop_until_fits(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return False\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        # Drop worst by (value\/weight, value, weight desc)\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        changed = False\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    n = 24\n    move = \"flip\"\n    r = random.random()\n\n    # Compute current weight once\n    cur_w = total_weight(bits)\n\n    if r < 0.4:\n        # Add-best-by-ratio if fits\n        cand = max(range(n), key=lambda i: (values[i] \/ max(1, weights[i]), values[i]) if bits[i] == '0' else (-1e9, -1e9))\n        if add_if_fits(bits, cand):\n            move = \"add_best_ratio\"\n        else:\n            # Try dropping worst then add\n            drop_until_fits(bits)\n            if add_if_fits(bits, cand):\n                move = \"drop_then_add\"\n            else:\n                # No change possible, fallback to do-nothing feasible return\n                return (''.join(bits), \"noop\")\n    elif r < 0.8:\n        # Exchange 1-1: drop worst add best by ratio with feasibility check\n        selected = [i for i,b in enumerate(bits) if b == '1']\n        unselected = [i for i,b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n            on_i  = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            # Perform if it fits\n            new_w = cur_w - weights[off_i] + weights[on_i]\n            if new_w <= cap:\n                bits[off_i] = '0'\n                bits[on_i]  = '1'\n                move = \"exchange_1_1\"\n            else:\n                # Try drop more until fits after swap attempt\n                bits[off_i] = '0'\n                if total_weight(bits) + weights[on_i] <= cap:\n                    bits[on_i] = '1'\n                    move = \"drop_more_then_add\"\n                else:\n                    move = \"drop_only\"\n        else:\n            return (''.join(bits), \"noop\")\n    else:\n        # Toggle ultra-light items first (w<=3) guided by ratio\n        ul_idx = [i for i,w in enumerate(weights) if w <= 3]\n        if ul_idx:\n            # Prefer adding best ultra-light if fits; otherwise remove worst ultra-light\n            addables = [i for i in ul_idx if bits[i] == '0' and cur_w + weights[i] <= cap]\n            if addables:\n                on_i = max(addables, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n                bits[on_i] = '1'\n                move = \"add_ultralight\"\n            else:\n                selected_ul = [i for i in ul_idx if bits[i] == '1']\n                if selected_ul:\n                    off_i = min(selected_ul, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n                    bits[off_i] = '0'\n                    move = \"remove_ultralight\"\n                else:\n                    return (''.join(bits), \"noop\")\n        else:\n            return (''.join(bits), \"noop\")\n\n    # Ensure feasibility\n    drop_until_fits(bits)\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Validate base\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        base = ['0'] * 24\n    else:\n        base = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def repair(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return bits_list\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n        return bits_list\n\n    n = 24\n    k = max(2, min(4, n \/\/ 6))  # flip\/exchange 2..4 bits\n\n    # Build candidate by performing k exchanges biased by ratio\n    bits = base[:]\n\n    # Try to add top-k unselected by ratio\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    ranked_add = sorted(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]), reverse=True)\n    adds = ranked_add[:k]\n    for i in adds:\n        bits[i] = '1'\n\n    # Drop until fit preferring worst items\n    bits = repair(bits)\n\n    # Randomize a couple of further toggles within feasibility\n    attempts = 6\n    for _ in range(attempts):\n        i = random.randrange(n)\n        if bits[i] == '1':\n            # Try swapping out i for a better ratio j\n            candidates = [j for j in range(n) if bits[j] == '0']\n            if not candidates:\n                continue\n            j = max(candidates, key=lambda idx: (values[idx] \/ max(1, weights[idx]), values[idx]))\n            new_w = total_weight(bits) - weights[i] + weights[j]\n            if new_w <= cap:\n                bits[i] = '0'\n                bits[j] = '1'\n        else:\n            # Try adding if fits\n            if total_weight(bits) + weights[i] <= cap:\n                bits[i] = '1'\n    bits = repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000441}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000'","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n\n    # Strict validation: exact length and charset\n    if not isinstance(solution, str):\n        return 1e9\n    if len(solution) != 24:\n        return 1e9\n    if any(ch not in ('0','1') for ch in solution):\n        return 1e9\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n\n    # Feasible: return negative value (lower is better). Infeasible: hard penalty.\n    if total_w <= capacity:\n        return -float(total_v)\n    else:\n        # Hard penalty to dominate any feasible score\n        return 1e8 + float(total_w - capacity)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Normalize and validate; if invalid, start from empty feasible solution\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    bits = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def add_if_fits(bits_list, idx):\n        if bits_list[idx] == '1':\n            return False\n        w = total_weight(bits_list)\n        if w + weights[idx] <= cap:\n            bits_list[idx] = '1'\n            return True\n        return False\n\n    def drop_until_fits(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return False\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        # Drop worst by (value\/weight, value, weight desc)\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        changed = False\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    n = 24\n    move = \"flip\"\n    r = random.random()\n\n    # Compute current weight once\n    cur_w = total_weight(bits)\n\n    if r < 0.4:\n        # Add-best-by-ratio if fits\n        cand = max(range(n), key=lambda i: (values[i] \/ max(1, weights[i]), values[i]) if bits[i] == '0' else (-1e9, -1e9))\n        if add_if_fits(bits, cand):\n            move = \"add_best_ratio\"\n        else:\n            # Try dropping worst then add\n            drop_until_fits(bits)\n            if add_if_fits(bits, cand):\n                move = \"drop_then_add\"\n            else:\n                # No change possible, fallback to do-nothing feasible return\n                return (''.join(bits), \"noop\")\n    elif r < 0.8:\n        # Exchange 1-1: drop worst add best by ratio with feasibility check\n        selected = [i for i,b in enumerate(bits) if b == '1']\n        unselected = [i for i,b in enumerate(bits) if b == '0']\n        if selected and unselected:\n            off_i = min(selected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n            on_i  = max(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n            # Perform if it fits\n            new_w = cur_w - weights[off_i] + weights[on_i]\n            if new_w <= cap:\n                bits[off_i] = '0'\n                bits[on_i]  = '1'\n                move = \"exchange_1_1\"\n            else:\n                # Try drop more until fits after swap attempt\n                bits[off_i] = '0'\n                if total_weight(bits) + weights[on_i] <= cap:\n                    bits[on_i] = '1'\n                    move = \"drop_more_then_add\"\n                else:\n                    move = \"drop_only\"\n        else:\n            return (''.join(bits), \"noop\")\n    else:\n        # Toggle ultra-light items first (w<=3) guided by ratio\n        ul_idx = [i for i,w in enumerate(weights) if w <= 3]\n        if ul_idx:\n            # Prefer adding best ultra-light if fits; otherwise remove worst ultra-light\n            addables = [i for i in ul_idx if bits[i] == '0' and cur_w + weights[i] <= cap]\n            if addables:\n                on_i = max(addables, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]))\n                bits[on_i] = '1'\n                move = \"add_ultralight\"\n            else:\n                selected_ul = [i for i in ul_idx if bits[i] == '1']\n                if selected_ul:\n                    off_i = min(selected_ul, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n                    bits[off_i] = '0'\n                    move = \"remove_ultralight\"\n                else:\n                    return (''.join(bits), \"noop\")\n        else:\n            return (''.join(bits), \"noop\")\n\n    # Ensure feasibility\n    drop_until_fits(bits)\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    cap = 9\n\n    # Validate base\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        base = ['0'] * 24\n    else:\n        base = list(solution)\n\n    def total_weight(bits_list):\n        return sum(weights[i] for i,b in enumerate(bits_list) if b == '1')\n\n    def repair(bits_list):\n        w = total_weight(bits_list)\n        if w <= cap:\n            return bits_list\n        sel = [i for i,b in enumerate(bits_list) if b == '1']\n        order = sorted(sel, key=lambda i: (values[i] \/ max(1, weights[i]), values[i], -weights[i]))\n        for i in order:\n            if w <= cap:\n                break\n            bits_list[i] = '0'\n            w -= weights[i]\n        return bits_list\n\n    n = 24\n    k = max(2, min(4, n \/\/ 6))  # flip\/exchange 2..4 bits\n\n    # Build candidate by performing k exchanges biased by ratio\n    bits = base[:]\n\n    # Try to add top-k unselected by ratio\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    ranked_add = sorted(unselected, key=lambda i: (values[i] \/ max(1, weights[i]), values[i]), reverse=True)\n    adds = ranked_add[:k]\n    for i in adds:\n        bits[i] = '1'\n\n    # Drop until fit preferring worst items\n    bits = repair(bits)\n\n    # Randomize a couple of further toggles within feasibility\n    attempts = 6\n    for _ in range(attempts):\n        i = random.randrange(n)\n        if bits[i] == '1':\n            # Try swapping out i for a better ratio j\n            candidates = [j for j in range(n) if bits[j] == '0']\n            if not candidates:\n                continue\n            j = max(candidates, key=lambda idx: (values[idx] \/ max(1, weights[idx]), values[idx]))\n            new_w = total_weight(bits) - weights[i] + weights[j]\n            if new_w <= cap:\n                bits[i] = '0'\n                bits[j] = '1'\n        else:\n            # Try adding if fits\n            if total_weight(bits) + weights[i] <= cap:\n                bits[i] = '1'\n    bits = repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000292}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000' encodes items [4,8,18]. Length must be exactly 24.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Strict validation\n    if not isinstance(solution, str):\n        return 1_000_000.0\n    if len(solution) != n:\n        return 1_000_000.0\n    if any(ch not in ('0','1') for ch in solution):\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n            if total_w > capacity:\n                # Early exit overweight\n                excess = total_w - capacity\n                return 1_000_000.0 + float(excess) * 100.0\n    # Feasible: return negative value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Validate or initialize to feasible empty solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    # Precompute helpers\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def cur_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def cur_value(bl):\n        return sum(values[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        # If overweight, drop items with minimal value loss per weight until feasible\n        w = cur_weight(bl)\n        if w <= capacity:\n            return False\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        # Score: value loss per weight recovered, tie by higher weight then lower value\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        changed = False\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    # Ensure starting feasibility (do not return yet; we will perform a modifying move)\n    repair(bits)\n    w0 = cur_weight(bits)\n\n    # Candidate move strategies; guarantee at least one change\n    move = \"noop\"\n\n    # Strategy A: add best-ratio item that fits\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if unselected:\n        best_add = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        if w0 + weights[best_add] <= capacity:\n            bits[best_add] = '1'\n            move = \"add_best_ratio\"\n            return (''.join(bits), move)\n\n    # Strategy B: 1-1 exchange: drop worst by ratio, add best by ratio if fits\n    idx_on = [i for i,b in enumerate(bits) if b == '1']\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if idx_on and unselected:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        new_w = w0 - weights[worst_on] + weights[best_off]\n        if new_w <= capacity and (values[best_off] > values[worst_on]):\n            bits[worst_on] = '0'\n            bits[best_off] = '1'\n            move = \"swap_1_1\"\n            return (''.join(bits), move)\n\n    # Strategy C: 2-for-1 or 1-for-2 bounded exchanges\n    if unselected and len(idx_on) >= 2:\n        # Try dropping up to 2 worst to add best\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        # pick two worst currently on\n        worst_pair = sorted(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))[:2]\n        drop_w = sum(weights[i] for i in worst_pair)\n        if w0 - drop_w + weights[best_off] <= capacity and values[best_off] > sum(values[i] for i in worst_pair):\n            for i in worst_pair:\n                bits[i] = '0'\n            bits[best_off] = '1'\n            move = \"swap_2_1\"\n            return (''.join(bits), move)\n\n    if len(unselected) >= 2 and idx_on:\n        # Try drop worst_on and add two best offs\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_two = sorted(unselected, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True)[:2]\n        add_w = sum(weights[i] for i in best_two)\n        if w0 - weights[worst_on] + add_w <= capacity and sum(values[i] for i in best_two) > values[worst_on]:\n            bits[worst_on] = '0'\n            for i in best_two:\n                bits[i] = '1'\n            move = \"swap_1_2\"\n            return (''.join(bits), move)\n\n    # Strategy D: if no constructive move, remove the worst item to diversify (if any on)\n    if idx_on:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        bits[worst_on] = '0'\n        move = \"drop_worst\"\n        return (''.join(bits), move)\n\n    # Fallback: flip best feasible bit (should not occur often)\n    unselected = [i for i in range(n) if bits[i] == '0']\n    if unselected:\n        # Choose the lightest highest-value that fits alone\n        cand = sorted(unselected, key=lambda i: (-values[i], weights[i], -ratio[i]))\n        for i in cand:\n            if weights[i] <= capacity:\n                bits[i] = '1'\n                move = \"fallback_add\"\n                break\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Base normalization\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def total_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        w = total_weight(bl)\n        if w <= capacity:\n            return\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n\n    # Strength-controlled random flips then repair\n    k = 3\n    idx = list(range(n))\n    random.shuffle(idx)\n    flips = idx[:k]\n    for i in flips:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Try to greedily add a couple of high-ratio items if room remains\n    repair(bits)\n    w = total_weight(bits)\n    candidates = [i for i in range(n) if bits[i] == '0']\n    for i in sorted(candidates, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True):\n        if w + weights[i] <= capacity:\n            bits[i] = '1'\n            w += weights[i]\n        if w == capacity:\n            break\n\n    repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001125123}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000' encodes items [4,8,18]. Length must be exactly 24.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Strict validation\n    if not isinstance(solution, str):\n        return 1_000_000.0\n    if len(solution) != n:\n        return 1_000_000.0\n    if any(ch not in ('0','1') for ch in solution):\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n            if total_w > capacity:\n                # Early exit overweight\n                excess = total_w - capacity\n                return 1_000_000.0 + float(excess) * 100.0\n    # Feasible: return negative value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Validate or initialize to feasible empty solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    # Precompute helpers\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def cur_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def cur_value(bl):\n        return sum(values[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        # If overweight, drop items with minimal value loss per weight until feasible\n        w = cur_weight(bl)\n        if w <= capacity:\n            return False\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        # Score: value loss per weight recovered, tie by higher weight then lower value\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        changed = False\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    # Ensure starting feasibility (do not return yet; we will perform a modifying move)\n    repair(bits)\n    w0 = cur_weight(bits)\n\n    # Candidate move strategies; guarantee at least one change\n    move = \"noop\"\n\n    # Strategy A: add best-ratio item that fits\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if unselected:\n        best_add = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        if w0 + weights[best_add] <= capacity:\n            bits[best_add] = '1'\n            move = \"add_best_ratio\"\n            return (''.join(bits), move)\n\n    # Strategy B: 1-1 exchange: drop worst by ratio, add best by ratio if fits\n    idx_on = [i for i,b in enumerate(bits) if b == '1']\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if idx_on and unselected:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        new_w = w0 - weights[worst_on] + weights[best_off]\n        if new_w <= capacity and (values[best_off] > values[worst_on]):\n            bits[worst_on] = '0'\n            bits[best_off] = '1'\n            move = \"swap_1_1\"\n            return (''.join(bits), move)\n\n    # Strategy C: 2-for-1 or 1-for-2 bounded exchanges\n    if unselected and len(idx_on) >= 2:\n        # Try dropping up to 2 worst to add best\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        # pick two worst currently on\n        worst_pair = sorted(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))[:2]\n        drop_w = sum(weights[i] for i in worst_pair)\n        if w0 - drop_w + weights[best_off] <= capacity and values[best_off] > sum(values[i] for i in worst_pair):\n            for i in worst_pair:\n                bits[i] = '0'\n            bits[best_off] = '1'\n            move = \"swap_2_1\"\n            return (''.join(bits), move)\n\n    if len(unselected) >= 2 and idx_on:\n        # Try drop worst_on and add two best offs\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_two = sorted(unselected, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True)[:2]\n        add_w = sum(weights[i] for i in best_two)\n        if w0 - weights[worst_on] + add_w <= capacity and sum(values[i] for i in best_two) > values[worst_on]:\n            bits[worst_on] = '0'\n            for i in best_two:\n                bits[i] = '1'\n            move = \"swap_1_2\"\n            return (''.join(bits), move)\n\n    # Strategy D: if no constructive move, remove the worst item to diversify (if any on)\n    if idx_on:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        bits[worst_on] = '0'\n        move = \"drop_worst\"\n        return (''.join(bits), move)\n\n    # Fallback: flip best feasible bit (should not occur often)\n    unselected = [i for i in range(n) if bits[i] == '0']\n    if unselected:\n        # Choose the lightest highest-value that fits alone\n        cand = sorted(unselected, key=lambda i: (-values[i], weights[i], -ratio[i]))\n        for i in cand:\n            if weights[i] <= capacity:\n                bits[i] = '1'\n                move = \"fallback_add\"\n                break\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Base normalization\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def total_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        w = total_weight(bl)\n        if w <= capacity:\n            return\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n\n    # Strength-controlled random flips then repair\n    k = 3\n    idx = list(range(n))\n    random.shuffle(idx)\n    flips = idx[:k]\n    for i in flips:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Try to greedily add a couple of high-ratio items if room remains\n    repair(bits)\n    w = total_weight(bits)\n    candidates = [i for i in range(n) if bits[i] == '0']\n    for i in sorted(candidates, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True):\n        if w + weights[i] <= capacity:\n            bits[i] = '1'\n            w += weights[i]\n        if w == capacity:\n            break\n\n    repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001311096}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"24-bit binary string over {0,1}, index i (1-based) set to '1' iff item i is included. Example: '000100010000000001000000' encodes items [4,8,18]. Length must be exactly 24.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Strict validation\n    if not isinstance(solution, str):\n        return 1_000_000.0\n    if len(solution) != n:\n        return 1_000_000.0\n    if any(ch not in ('0','1') for ch in solution):\n        return 1_000_000.0\n\n    total_w = 0\n    total_v = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_w += weights[i]\n            total_v += values[i]\n            if total_w > capacity:\n                # Early exit overweight\n                excess = total_w - capacity\n                return 1_000_000.0 + float(excess) * 100.0\n    # Feasible: return negative value for maximization\n    return -float(total_v)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Validate or initialize to feasible empty solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    # Precompute helpers\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def cur_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def cur_value(bl):\n        return sum(values[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        # If overweight, drop items with minimal value loss per weight until feasible\n        w = cur_weight(bl)\n        if w <= capacity:\n            return False\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        # Score: value loss per weight recovered, tie by higher weight then lower value\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        changed = False\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n            changed = True\n        return changed\n\n    # Ensure starting feasibility (do not return yet; we will perform a modifying move)\n    repair(bits)\n    w0 = cur_weight(bits)\n\n    # Candidate move strategies; guarantee at least one change\n    move = \"noop\"\n\n    # Strategy A: add best-ratio item that fits\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if unselected:\n        best_add = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        if w0 + weights[best_add] <= capacity:\n            bits[best_add] = '1'\n            move = \"add_best_ratio\"\n            return (''.join(bits), move)\n\n    # Strategy B: 1-1 exchange: drop worst by ratio, add best by ratio if fits\n    idx_on = [i for i,b in enumerate(bits) if b == '1']\n    unselected = [i for i,b in enumerate(bits) if b == '0']\n    if idx_on and unselected:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        new_w = w0 - weights[worst_on] + weights[best_off]\n        if new_w <= capacity and (values[best_off] > values[worst_on]):\n            bits[worst_on] = '0'\n            bits[best_off] = '1'\n            move = \"swap_1_1\"\n            return (''.join(bits), move)\n\n    # Strategy C: 2-for-1 or 1-for-2 bounded exchanges\n    if unselected and len(idx_on) >= 2:\n        # Try dropping up to 2 worst to add best\n        best_off = max(unselected, key=lambda i: (ratio[i], values[i], -weights[i]))\n        # pick two worst currently on\n        worst_pair = sorted(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))[:2]\n        drop_w = sum(weights[i] for i in worst_pair)\n        if w0 - drop_w + weights[best_off] <= capacity and values[best_off] > sum(values[i] for i in worst_pair):\n            for i in worst_pair:\n                bits[i] = '0'\n            bits[best_off] = '1'\n            move = \"swap_2_1\"\n            return (''.join(bits), move)\n\n    if len(unselected) >= 2 and idx_on:\n        # Try drop worst_on and add two best offs\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        best_two = sorted(unselected, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True)[:2]\n        add_w = sum(weights[i] for i in best_two)\n        if w0 - weights[worst_on] + add_w <= capacity and sum(values[i] for i in best_two) > values[worst_on]:\n            bits[worst_on] = '0'\n            for i in best_two:\n                bits[i] = '1'\n            move = \"swap_1_2\"\n            return (''.join(bits), move)\n\n    # Strategy D: if no constructive move, remove the worst item to diversify (if any on)\n    if idx_on:\n        worst_on = min(idx_on, key=lambda i: (ratio[i], values[i], -weights[i]))\n        bits[worst_on] = '0'\n        move = \"drop_worst\"\n        return (''.join(bits), move)\n\n    # Fallback: flip best feasible bit (should not occur often)\n    unselected = [i for i in range(n) if bits[i] == '0']\n    if unselected:\n        # Choose the lightest highest-value that fits alone\n        cand = sorted(unselected, key=lambda i: (-values[i], weights[i], -ratio[i]))\n        for i in cand:\n            if weights[i] <= capacity:\n                bits[i] = '1'\n                move = \"fallback_add\"\n                break\n    return (''.join(bits), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = 24\n\n    # Base normalization\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        bits = ['0'] * n\n    else:\n        bits = list(solution)\n\n    ratio = [values[i] \/ weights[i] for i in range(n)]\n\n    def total_weight(bl):\n        return sum(weights[i] for i,b in enumerate(bl) if b == '1')\n\n    def repair(bl):\n        w = total_weight(bl)\n        if w <= capacity:\n            return\n        idx_on = [i for i,b in enumerate(bl) if b == '1']\n        order = sorted(idx_on, key=lambda i: (values[i]\/weights[i], -weights[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            bl[i] = '0'\n            w -= weights[i]\n\n    # Strength-controlled random flips then repair\n    k = 3\n    idx = list(range(n))\n    random.shuffle(idx)\n    flips = idx[:k]\n    for i in flips:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Try to greedily add a couple of high-ratio items if room remains\n    repair(bits)\n    w = total_weight(bits)\n    candidates = [i for i in range(n) if bits[i] == '0']\n    for i in sorted(candidates, key=lambda i: (ratio[i], values[i], -weights[i]), reverse=True):\n        if w + weights[i] <= capacity:\n            bits[i] = '1'\n            w += weights[i]\n        if w == capacity:\n            break\n\n    repair(bits)\n    return ''.join(bits)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0012516739}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Parse binary string to selections\n    sel = [1 if c == '1' else 0 for c in solution.strip()]\n    if len(sel) != len(costs):\n        return float('inf')\n\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Heuristic: lower score is better; maximize value via negative; penalize infeasible\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1_000_000.0 + 1_000.0 * over - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defines the neighbor move type; does not return the neighbor solution per required signature\n    # A single random bit flip is the intended neighbor operator\n    _ = solution  # argument acknowledged to satisfy interface\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k bits (k in {2,3}) to escape local optima\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = 2 if n < 3 else random.choice([2, 3])\n    idxs = random.sample(range(n), k=min(k, n))\n    bits = list(solution)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00002135}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Parse binary string to selections\n    sel = [1 if c == '1' else 0 for c in solution.strip()]\n    if len(sel) != len(costs):\n        return float('inf')\n\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Heuristic: lower score is better; maximize value via negative; penalize infeasible\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1_000_000.0 + 1_000.0 * over - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defines the neighbor move type; does not return the neighbor solution per required signature\n    # A single random bit flip is the intended neighbor operator\n    _ = solution  # argument acknowledged to satisfy interface\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k bits (k in {2,3}) to escape local optima\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = 2 if n < 3 else random.choice([2, 3])\n    idxs = random.sample(range(n), k=min(k, n))\n    bits = list(solution)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000488}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    # Parse binary string to selections\n    sel = [1 if c == '1' else 0 for c in solution.strip()]\n    if len(sel) != len(costs):\n        return float('inf')\n\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Heuristic: lower score is better; maximize value via negative; penalize infeasible\n    if total_cost <= budget:\n        return -float(total_value)\n    else:\n        over = total_cost - budget\n        return 1_000_000.0 + 1_000.0 * over - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defines the neighbor move type; does not return the neighbor solution per required signature\n    # A single random bit flip is the intended neighbor operator\n    _ = solution  # argument acknowledged to satisfy interface\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str):\n    # Randomly flip k bits (k in {2,3}) to escape local optima\n    n = len(solution)\n    if n == 0:\n        return solution\n    k = 2 if n < 3 else random.choice([2, 3])\n    idxs = random.sample(range(n), k=min(k, n))\n    bits = list(solution)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000269}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Scaled penalty to guide back to feasibility while preserving gradient by value\n    return 10000.0 * over + 100.0 - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This function reports the neighborhood move type per required signature.\n    # Neighbor operators considered by the search: single flip, double flip, and swap(1->0,0->1)\n    _ = solution\n    move_types = [\n        (\"flip\", \"single_bit\"),\n        (\"flip\", \"double_bit\"),\n        (\"swap\", \"one_one_zero_zero\")\n    ]\n    return random.choice(move_types)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits (k in {3,4,5}); then repair if over budget by dropping worst density items.\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n\n    n = len(solution)\n    bits = list(solution)\n    k = 3 if n < 5 else random.choice([3, 4, 5])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k=k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    candidate = ''.join(bits)\n\n    # Embedded problem data for repair\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def cost_value(sel_str):\n        sel = [1 if c == '1' else 0 for c in sel_str]\n        total_cost = sum(c for c, s in zip(costs, sel) if s)\n        total_value = sum(v for v, s in zip(values, sel) if s)\n        return total_cost, total_value\n\n    total_cost, _ = cost_value(candidate)\n    if total_cost <= budget:\n        return candidate\n\n    # Repair: iteratively drop selected items with lowest value density until feasible\n    sel = [1 if c == '1' else 0 for c in candidate]\n    items = list(range(n))\n    densities = [(i, values[i] \/ costs[i] if costs[i] > 0 else 0.0) for i in items]\n\n    while True:\n        total_cost = sum(costs[i] for i in items if sel[i])\n        if total_cost <= budget:\n            break\n        # find worst density among selected items\n        worst_idx = None\n        worst_density = float('inf')\n        for i, d in densities:\n            if sel[i] and d < worst_density:\n                worst_density = d\n                worst_idx = i\n        if worst_idx is None:\n            break\n        sel[worst_idx] = 0\n\n    return ''.join('1' if x else '0' for x in sel)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000147601}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Scaled penalty to guide back to feasibility while preserving gradient by value\n    return 10000.0 * over + 100.0 - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This function reports the neighborhood move type per required signature.\n    # Neighbor operators considered by the search: single flip, double flip, and swap(1->0,0->1)\n    _ = solution\n    move_types = [\n        (\"flip\", \"single_bit\"),\n        (\"flip\", \"double_bit\"),\n        (\"swap\", \"one_one_zero_zero\")\n    ]\n    return random.choice(move_types)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits (k in {3,4,5}); then repair if over budget by dropping worst density items.\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n\n    n = len(solution)\n    bits = list(solution)\n    k = 3 if n < 5 else random.choice([3, 4, 5])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k=k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    candidate = ''.join(bits)\n\n    # Embedded problem data for repair\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def cost_value(sel_str):\n        sel = [1 if c == '1' else 0 for c in sel_str]\n        total_cost = sum(c for c, s in zip(costs, sel) if s)\n        total_value = sum(v for v, s in zip(values, sel) if s)\n        return total_cost, total_value\n\n    total_cost, _ = cost_value(candidate)\n    if total_cost <= budget:\n        return candidate\n\n    # Repair: iteratively drop selected items with lowest value density until feasible\n    sel = [1 if c == '1' else 0 for c in candidate]\n    items = list(range(n))\n    densities = [(i, values[i] \/ costs[i] if costs[i] > 0 else 0.0) for i in items]\n\n    while True:\n        total_cost = sum(costs[i] for i in items if sel[i])\n        if total_cost <= budget:\n            break\n        # find worst density among selected items\n        worst_idx = None\n        worst_density = float('inf')\n        for i, d in densities:\n            if sel[i] and d < worst_density:\n                worst_density = d\n                worst_idx = i\n        if worst_idx is None:\n            break\n        sel[worst_idx] = 0\n\n    return ''.join('1' if x else '0' for x in sel)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000436}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions.\n    if total_cost <= budget:\n        return -float(total_value)\n    over = total_cost - budget\n    # Scaled penalty to guide back to feasibility while preserving gradient by value\n    return 10000.0 * over + 100.0 - float(total_value)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This function reports the neighborhood move type per required signature.\n    # Neighbor operators considered by the search: single flip, double flip, and swap(1->0,0->1)\n    _ = solution\n    move_types = [\n        (\"flip\", \"single_bit\"),\n        (\"flip\", \"double_bit\"),\n        (\"swap\", \"one_one_zero_zero\")\n    ]\n    return random.choice(move_types)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits (k in {3,4,5}); then repair if over budget by dropping worst density items.\n    if not isinstance(solution, str) or len(solution) == 0:\n        return solution\n\n    n = len(solution)\n    bits = list(solution)\n    k = 3 if n < 5 else random.choice([3, 4, 5])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k=k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    candidate = ''.join(bits)\n\n    # Embedded problem data for repair\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def cost_value(sel_str):\n        sel = [1 if c == '1' else 0 for c in sel_str]\n        total_cost = sum(c for c, s in zip(costs, sel) if s)\n        total_value = sum(v for v, s in zip(values, sel) if s)\n        return total_cost, total_value\n\n    total_cost, _ = cost_value(candidate)\n    if total_cost <= budget:\n        return candidate\n\n    # Repair: iteratively drop selected items with lowest value density until feasible\n    sel = [1 if c == '1' else 0 for c in candidate]\n    items = list(range(n))\n    densities = [(i, values[i] \/ costs[i] if costs[i] > 0 else 0.0) for i in items]\n\n    while True:\n        total_cost = sum(costs[i] for i in items if sel[i])\n        if total_cost <= budget:\n            break\n        # find worst density among selected items\n        worst_idx = None\n        worst_density = float('inf')\n        for i, d in densities:\n            if sel[i] and d < worst_density:\n                worst_density = d\n                worst_idx = i\n        if worst_idx is None:\n            break\n        sel[worst_idx] = 0\n\n    return ''.join('1' if x else '0' for x in sel)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000314}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions with adaptive penalty.\n    if total_cost <= budget:\n        return -float(total_value)\n\n    over = total_cost - budget\n    # Adaptive penalty scale around value magnitudes\n    alpha = 100.0\n    base_penalty = 1000.0\n    return base_penalty + alpha * float(over) - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid 24-bit binary string; if not, create a random feasible start\n    def make_random_feasible(n=24):\n        costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        budget = 90\n        bits = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        solution = make_random_feasible(24)\n\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n\n    def total_cost(bits_list):\n        return sum(costs[i] for i, b in enumerate(bits_list) if b == '1')\n\n    def total_value(bits_list):\n        return sum(values[i] for i, b in enumerate(bits_list) if b == '1')\n\n    current_cost = total_cost(bits)\n\n    # Select move type\n    r = random.random()\n    move_label = 'flip_single_cost_aware'\n\n    if r < 0.4:\n        # Cost-aware add if affordable; else drop a random 1\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        densities = sorted(zeros, key=lambda i: (values[i] \/ costs[i]), reverse=True)\n        applied = False\n        for j in densities:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                applied = True\n                move_label = 'add_single_affordable'\n                break\n        if not applied:\n            if ones:\n                i = random.choice(ones)\n                bits[i] = '0'\n                move_label = 'drop_single'\n            else:\n                # nothing selected; add best density even if over, then repair by dropping one expensive\n                if zeros:\n                    j = densities[0]\n                    bits[j] = '1'\n                    move_label = 'add_then_repair'\n                    # repair: drop worst density selected until feasible\n                    while total_cost(bits) > budget:\n                        sel = [k for k, b in enumerate(bits) if b == '1']\n                        if not sel:\n                            break\n                        worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n                        bits[worst] = '0'\n    elif r < 0.8:\n        # Swap-in-out: try to add a 0-bit item and drop a 1-bit item to remain feasible with best gain\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        random.shuffle(zeros)\n        best_delta = None\n        best_pair = None\n        for j in zeros[:min(len(zeros), 8)]:  # limit tries for speed\n            # if can add directly, do it\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n            for i in ones:\n                new_cost = current_cost - costs[i] + costs[j]\n                if new_cost <= budget:\n                    delta = values[j] - values[i]\n                    if (best_delta is None) or (delta > best_delta):\n                        best_delta = delta\n                        best_pair = (i, j)\n        else:\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_in_out_best_delta'\n            else:\n                # fallback: drop a random 1 if exists\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_fallback'\n                else:\n                    # or add cheapest if feasible\n                    zeros_sorted = sorted(zeros, key=lambda k: costs[k])\n                    for k in zeros_sorted:\n                        if current_cost + costs[k] <= budget:\n                            bits[k] = '1'\n                            move_label = 'add_cheapest'\n                            break\n    else:\n        # Double flip: drop one selected and add one unselected with best value-density feasible\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            bits[i] = '0'\n            current_cost2 = current_cost - costs[i]\n            # add best density that fits\n            zeros_sorted = sorted(zeros, key=lambda j: (values[j]\/costs[j]), reverse=True)\n            added = False\n            for j in zeros_sorted:\n                if current_cost2 + costs[j] <= budget:\n                    bits[j] = '1'\n                    added = True\n                    break\n            move_label = 'double_flip_drop_add' if added else 'double_flip_drop_only'\n        else:\n            # fallback: single add if feasible\n            zeros = [j for j, b in enumerate(bits) if b == '0']\n            zeros_sorted = sorted(zeros, key=lambda j: costs[j])\n            for j in zeros_sorted:\n                if current_cost + costs[j] <= budget:\n                    bits[j] = '1'\n                    move_label = 'fallback_add_single'\n                    break\n\n    neighbour = ''.join(bits)\n    # Final guard: ensure feasibility; if infeasible, repair by dropping worst density until feasible\n    if sum(costs[i] for i, b in enumerate(bits) if b == '1') > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        while sum(costs[i] for i in sel) > budget and sel:\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n            sel.remove(worst)\n        neighbour = ''.join(bits)\n        move_label = move_label + '_repaired'\n\n    return neighbour, move_label\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits then greedy repair by dropping lowest value-density until feasible\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        # If invalid, initialize to all zeros as neutral start\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k random bits (3..6)\n    k = min(max(3, n \/\/ 8), 6)\n    k = random.choice([k, k+1, min(k+2, 6)])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    # Repair if infeasible by dropping worst value-density items\n    def total_cost(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    if total_cost(bits) > budget:\n        while total_cost(bits) > budget:\n            sel = [i for i, b in enumerate(bits) if b == '1']\n            if not sel:\n                break\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000152399}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions with adaptive penalty.\n    if total_cost <= budget:\n        return -float(total_value)\n\n    over = total_cost - budget\n    # Adaptive penalty scale around value magnitudes\n    alpha = 100.0\n    base_penalty = 1000.0\n    return base_penalty + alpha * float(over) - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid 24-bit binary string; if not, create a random feasible start\n    def make_random_feasible(n=24):\n        costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        budget = 90\n        bits = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        solution = make_random_feasible(24)\n\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n\n    def total_cost(bits_list):\n        return sum(costs[i] for i, b in enumerate(bits_list) if b == '1')\n\n    def total_value(bits_list):\n        return sum(values[i] for i, b in enumerate(bits_list) if b == '1')\n\n    current_cost = total_cost(bits)\n\n    # Select move type\n    r = random.random()\n    move_label = 'flip_single_cost_aware'\n\n    if r < 0.4:\n        # Cost-aware add if affordable; else drop a random 1\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        densities = sorted(zeros, key=lambda i: (values[i] \/ costs[i]), reverse=True)\n        applied = False\n        for j in densities:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                applied = True\n                move_label = 'add_single_affordable'\n                break\n        if not applied:\n            if ones:\n                i = random.choice(ones)\n                bits[i] = '0'\n                move_label = 'drop_single'\n            else:\n                # nothing selected; add best density even if over, then repair by dropping one expensive\n                if zeros:\n                    j = densities[0]\n                    bits[j] = '1'\n                    move_label = 'add_then_repair'\n                    # repair: drop worst density selected until feasible\n                    while total_cost(bits) > budget:\n                        sel = [k for k, b in enumerate(bits) if b == '1']\n                        if not sel:\n                            break\n                        worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n                        bits[worst] = '0'\n    elif r < 0.8:\n        # Swap-in-out: try to add a 0-bit item and drop a 1-bit item to remain feasible with best gain\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        random.shuffle(zeros)\n        best_delta = None\n        best_pair = None\n        for j in zeros[:min(len(zeros), 8)]:  # limit tries for speed\n            # if can add directly, do it\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n            for i in ones:\n                new_cost = current_cost - costs[i] + costs[j]\n                if new_cost <= budget:\n                    delta = values[j] - values[i]\n                    if (best_delta is None) or (delta > best_delta):\n                        best_delta = delta\n                        best_pair = (i, j)\n        else:\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_in_out_best_delta'\n            else:\n                # fallback: drop a random 1 if exists\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_fallback'\n                else:\n                    # or add cheapest if feasible\n                    zeros_sorted = sorted(zeros, key=lambda k: costs[k])\n                    for k in zeros_sorted:\n                        if current_cost + costs[k] <= budget:\n                            bits[k] = '1'\n                            move_label = 'add_cheapest'\n                            break\n    else:\n        # Double flip: drop one selected and add one unselected with best value-density feasible\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            bits[i] = '0'\n            current_cost2 = current_cost - costs[i]\n            # add best density that fits\n            zeros_sorted = sorted(zeros, key=lambda j: (values[j]\/costs[j]), reverse=True)\n            added = False\n            for j in zeros_sorted:\n                if current_cost2 + costs[j] <= budget:\n                    bits[j] = '1'\n                    added = True\n                    break\n            move_label = 'double_flip_drop_add' if added else 'double_flip_drop_only'\n        else:\n            # fallback: single add if feasible\n            zeros = [j for j, b in enumerate(bits) if b == '0']\n            zeros_sorted = sorted(zeros, key=lambda j: costs[j])\n            for j in zeros_sorted:\n                if current_cost + costs[j] <= budget:\n                    bits[j] = '1'\n                    move_label = 'fallback_add_single'\n                    break\n\n    neighbour = ''.join(bits)\n    # Final guard: ensure feasibility; if infeasible, repair by dropping worst density until feasible\n    if sum(costs[i] for i, b in enumerate(bits) if b == '1') > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        while sum(costs[i] for i in sel) > budget and sel:\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n            sel.remove(worst)\n        neighbour = ''.join(bits)\n        move_label = move_label + '_repaired'\n\n    return neighbour, move_label\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits then greedy repair by dropping lowest value-density until feasible\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        # If invalid, initialize to all zeros as neutral start\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k random bits (3..6)\n    k = min(max(3, n \/\/ 8), 6)\n    k = random.choice([k, k+1, min(k+2, 6)])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    # Repair if infeasible by dropping worst value-density items\n    def total_cost(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    if total_cost(bits) > budget:\n        while total_cost(bits) > budget:\n            sel = [i for i, b in enumerate(bits) if b == '1']\n            if not sel:\n                break\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0000046}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return float('inf')\n    if not re.fullmatch(r'[01]{24}', solution):\n        return float('inf')\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better. Maximize value via negative score; penalize infeasible solutions with adaptive penalty.\n    if total_cost <= budget:\n        return -float(total_value)\n\n    over = total_cost - budget\n    # Adaptive penalty scale around value magnitudes\n    alpha = 100.0\n    base_penalty = 1000.0\n    return base_penalty + alpha * float(over) - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure valid 24-bit binary string; if not, create a random feasible start\n    def make_random_feasible(n=24):\n        costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n        budget = 90\n        bits = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        solution = make_random_feasible(24)\n\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n\n    def total_cost(bits_list):\n        return sum(costs[i] for i, b in enumerate(bits_list) if b == '1')\n\n    def total_value(bits_list):\n        return sum(values[i] for i, b in enumerate(bits_list) if b == '1')\n\n    current_cost = total_cost(bits)\n\n    # Select move type\n    r = random.random()\n    move_label = 'flip_single_cost_aware'\n\n    if r < 0.4:\n        # Cost-aware add if affordable; else drop a random 1\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        densities = sorted(zeros, key=lambda i: (values[i] \/ costs[i]), reverse=True)\n        applied = False\n        for j in densities:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                applied = True\n                move_label = 'add_single_affordable'\n                break\n        if not applied:\n            if ones:\n                i = random.choice(ones)\n                bits[i] = '0'\n                move_label = 'drop_single'\n            else:\n                # nothing selected; add best density even if over, then repair by dropping one expensive\n                if zeros:\n                    j = densities[0]\n                    bits[j] = '1'\n                    move_label = 'add_then_repair'\n                    # repair: drop worst density selected until feasible\n                    while total_cost(bits) > budget:\n                        sel = [k for k, b in enumerate(bits) if b == '1']\n                        if not sel:\n                            break\n                        worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n                        bits[worst] = '0'\n    elif r < 0.8:\n        # Swap-in-out: try to add a 0-bit item and drop a 1-bit item to remain feasible with best gain\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        random.shuffle(zeros)\n        best_delta = None\n        best_pair = None\n        for j in zeros[:min(len(zeros), 8)]:  # limit tries for speed\n            # if can add directly, do it\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n            for i in ones:\n                new_cost = current_cost - costs[i] + costs[j]\n                if new_cost <= budget:\n                    delta = values[j] - values[i]\n                    if (best_delta is None) or (delta > best_delta):\n                        best_delta = delta\n                        best_pair = (i, j)\n        else:\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_in_out_best_delta'\n            else:\n                # fallback: drop a random 1 if exists\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_fallback'\n                else:\n                    # or add cheapest if feasible\n                    zeros_sorted = sorted(zeros, key=lambda k: costs[k])\n                    for k in zeros_sorted:\n                        if current_cost + costs[k] <= budget:\n                            bits[k] = '1'\n                            move_label = 'add_cheapest'\n                            break\n    else:\n        # Double flip: drop one selected and add one unselected with best value-density feasible\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        if ones and zeros:\n            i = random.choice(ones)\n            bits[i] = '0'\n            current_cost2 = current_cost - costs[i]\n            # add best density that fits\n            zeros_sorted = sorted(zeros, key=lambda j: (values[j]\/costs[j]), reverse=True)\n            added = False\n            for j in zeros_sorted:\n                if current_cost2 + costs[j] <= budget:\n                    bits[j] = '1'\n                    added = True\n                    break\n            move_label = 'double_flip_drop_add' if added else 'double_flip_drop_only'\n        else:\n            # fallback: single add if feasible\n            zeros = [j for j, b in enumerate(bits) if b == '0']\n            zeros_sorted = sorted(zeros, key=lambda j: costs[j])\n            for j in zeros_sorted:\n                if current_cost + costs[j] <= budget:\n                    bits[j] = '1'\n                    move_label = 'fallback_add_single'\n                    break\n\n    neighbour = ''.join(bits)\n    # Final guard: ensure feasibility; if infeasible, repair by dropping worst density until feasible\n    if sum(costs[i] for i, b in enumerate(bits) if b == '1') > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        while sum(costs[i] for i in sel) > budget and sel:\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n            sel.remove(worst)\n        neighbour = ''.join(bits)\n        move_label = move_label + '_repaired'\n\n    return neighbour, move_label\n","Perturbacion":"import random\nfrom typing import List\n\n\ndef perturb_solution(solution: str) -> str:\n    # Strong perturbation: flip k bits then greedy repair by dropping lowest value-density until feasible\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        # If invalid, initialize to all zeros as neutral start\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k random bits (3..6)\n    k = min(max(3, n \/\/ 8), 6)\n    k = random.choice([k, k+1, min(k+2, 6)])\n    k = min(k, n)\n\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        bits[i] = '1' if bits[i] == '0' else '0'\n\n    # Repair if infeasible by dropping worst value-density items\n    def total_cost(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    if total_cost(bits) > budget:\n        while total_cost(bits) > budget:\n            sel = [i for i, b in enumerate(bits) if b == '1']\n            if not sel:\n                break\n            worst = min(sel, key=lambda k: (values[k] \/ costs[k]))\n            bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000322}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom functools import lru_cache\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return 1e12\n    if not re.fullmatch(r\"[01]{24}\", solution):\n        return 1e12\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better: maximize value via negative score\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Infeasible: linear penalty on budget violation with mild shaping, minus value to preserve gradient\n    over = float(total_cost - budget)\n    lambda_pen = 12.0  # tuned to be > typical value gain per cheapest item\n    return lambda_pen * over - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> tuple[str, str]:\n    # Problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Greedy density-based feasible initializer\n    def greedy_feasible() -> str:\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        bits = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    # Validate\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = greedy_feasible()\n\n    bits = list(solution)\n\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    def total_value_bits(bl):\n        return sum(values[i] for i, b in enumerate(bl) if b == '1')\n\n    current_cost = total_cost_bits(bits)\n\n    r = random.random()\n    move_label = 'noop'\n\n    # Move set: add, drop, 1-out-1-in swap, limited 2-exchange\n    if r < 0.35:\n        # Add best affordable by density\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        zeros.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        for j in zeros:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_best_affordable'\n                break\n        if move_label == 'noop':\n            # Drop worst density to open space\n            ones = [i for i, b in enumerate(bits) if b == '1']\n            if ones:\n                worst = min(ones, key=lambda i: (values[i]\/costs[i], -costs[i]))\n                bits[worst] = '0'\n                move_label = 'drop_worst_density'\n    elif r < 0.7:\n        # Best improving feasible swap (1-out,1-in)\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        best_delta = None\n        best_pair = None\n        for j in zeros:\n            cj = costs[j]\n            vj = values[j]\n            if current_cost + cj <= budget:\n                # direct add if fits\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n        else:\n            for i in ones:\n                ci = costs[i]\n                vi = values[i]\n                for j in zeros:\n                    new_cost = current_cost - ci + costs[j]\n                    if new_cost <= budget:\n                        delta = values[j] - vi\n                        if (best_delta is None) or (delta > best_delta):\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_1out_1in_best'\n            else:\n                # fallback: drop a random selected if any\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_random_fallback'\n    else:\n        # Limited 2-exchange: try remove up to 2 and add up to 2 greedily\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        # Randomly pick a candidate to drop, then refill by best density\n        dropped = []\n        if ones:\n            i = random.choice(ones)\n            bits[i] = '0'\n            dropped.append(i)\n        if len(ones) > 1 and random.random() < 0.5:\n            others = [x for x in ones if x != dropped[0]]\n            i2 = random.choice(others)\n            bits[i2] = '0'\n            dropped.append(i2)\n        move_label = f'drop_{len(dropped)}'\n        # Refill by density while feasible\n        current_cost2 = total_cost_bits(bits)\n        zeros_now = [j for j, b in enumerate(bits) if b == '0']\n        zeros_now.sort(key=lambda j: (values[j]\/costs[j], values[j]), reverse=True)\n        added = 0\n        for j in zeros_now:\n            if current_cost2 + costs[j] <= budget:\n                bits[j] = '1'\n                current_cost2 += costs[j]\n                added += 1\n                if added >= 2:\n                    break\n        move_label = move_label + f'_add_{added}'\n\n    # Final repair to ensure feasibility\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n        move_label = move_label + '_repaired'\n\n    neighbour = ''.join(bits)\n    return neighbour, move_label\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Validate\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k bits (3..6), biased to low-density indices for drops and high-density for adds\n    densities = [(i, (values[i]\/costs[i])) for i in range(n)]\n    densities.sort(key=lambda x: x[1])\n    low_density = [i for i, _ in densities[:max(3, n\/\/6)]]\n    high_density = [i for i, _ in densities[-max(3, n\/\/6):]]\n\n    k = random.choice([3,4,5,6])\n    idxs = set()\n    # Prefer flipping some low-density selected bits to 0\n    selected = [i for i, b in enumerate(bits) if b == '1']\n    random.shuffle(selected)\n    for i in selected:\n        if i in low_density:\n            idxs.add(i)\n            if len(idxs) >= k:\n                break\n    # Fill remaining flips randomly\n    while len(idxs) < k:\n        idxs.add(random.randrange(n))\n\n    for i in idxs:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Repair by dropping worst density until feasible\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000143}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom functools import lru_cache\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return 1e12\n    if not re.fullmatch(r\"[01]{24}\", solution):\n        return 1e12\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better: maximize value via negative score\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Infeasible: linear penalty on budget violation with mild shaping, minus value to preserve gradient\n    over = float(total_cost - budget)\n    lambda_pen = 12.0  # tuned to be > typical value gain per cheapest item\n    return lambda_pen * over - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> tuple[str, str]:\n    # Problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Greedy density-based feasible initializer\n    def greedy_feasible() -> str:\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        bits = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    # Validate\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = greedy_feasible()\n\n    bits = list(solution)\n\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    def total_value_bits(bl):\n        return sum(values[i] for i, b in enumerate(bl) if b == '1')\n\n    current_cost = total_cost_bits(bits)\n\n    r = random.random()\n    move_label = 'noop'\n\n    # Move set: add, drop, 1-out-1-in swap, limited 2-exchange\n    if r < 0.35:\n        # Add best affordable by density\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        zeros.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        for j in zeros:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_best_affordable'\n                break\n        if move_label == 'noop':\n            # Drop worst density to open space\n            ones = [i for i, b in enumerate(bits) if b == '1']\n            if ones:\n                worst = min(ones, key=lambda i: (values[i]\/costs[i], -costs[i]))\n                bits[worst] = '0'\n                move_label = 'drop_worst_density'\n    elif r < 0.7:\n        # Best improving feasible swap (1-out,1-in)\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        best_delta = None\n        best_pair = None\n        for j in zeros:\n            cj = costs[j]\n            vj = values[j]\n            if current_cost + cj <= budget:\n                # direct add if fits\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n        else:\n            for i in ones:\n                ci = costs[i]\n                vi = values[i]\n                for j in zeros:\n                    new_cost = current_cost - ci + costs[j]\n                    if new_cost <= budget:\n                        delta = values[j] - vi\n                        if (best_delta is None) or (delta > best_delta):\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_1out_1in_best'\n            else:\n                # fallback: drop a random selected if any\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_random_fallback'\n    else:\n        # Limited 2-exchange: try remove up to 2 and add up to 2 greedily\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        # Randomly pick a candidate to drop, then refill by best density\n        dropped = []\n        if ones:\n            i = random.choice(ones)\n            bits[i] = '0'\n            dropped.append(i)\n        if len(ones) > 1 and random.random() < 0.5:\n            others = [x for x in ones if x != dropped[0]]\n            i2 = random.choice(others)\n            bits[i2] = '0'\n            dropped.append(i2)\n        move_label = f'drop_{len(dropped)}'\n        # Refill by density while feasible\n        current_cost2 = total_cost_bits(bits)\n        zeros_now = [j for j, b in enumerate(bits) if b == '0']\n        zeros_now.sort(key=lambda j: (values[j]\/costs[j], values[j]), reverse=True)\n        added = 0\n        for j in zeros_now:\n            if current_cost2 + costs[j] <= budget:\n                bits[j] = '1'\n                current_cost2 += costs[j]\n                added += 1\n                if added >= 2:\n                    break\n        move_label = move_label + f'_add_{added}'\n\n    # Final repair to ensure feasibility\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n        move_label = move_label + '_repaired'\n\n    neighbour = ''.join(bits)\n    return neighbour, move_label\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Validate\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k bits (3..6), biased to low-density indices for drops and high-density for adds\n    densities = [(i, (values[i]\/costs[i])) for i in range(n)]\n    densities.sort(key=lambda x: x[1])\n    low_density = [i for i, _ in densities[:max(3, n\/\/6)]]\n    high_density = [i for i, _ in densities[-max(3, n\/\/6):]]\n\n    k = random.choice([3,4,5,6])\n    idxs = set()\n    # Prefer flipping some low-density selected bits to 0\n    selected = [i for i, b in enumerate(bits) if b == '1']\n    random.shuffle(selected)\n    for i in selected:\n        if i in low_density:\n            idxs.add(i)\n            if len(idxs) >= k:\n                break\n    # Fill remaining flips randomly\n    while len(idxs) < k:\n        idxs.add(random.randrange(n))\n\n    for i in idxs:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Repair by dropping worst density until feasible\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000425}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"BIN_STR_24","Evaluacion":"import re\nfrom functools import lru_cache\nfrom typing import Union\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate input type and format\n    if not isinstance(solution, str):\n        return 1e12\n    if not re.fullmatch(r\"[01]{24}\", solution):\n        return 1e12\n\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    sel = [1 if c == '1' else 0 for c in solution]\n    total_cost = sum(c for c, s in zip(costs, sel) if s)\n    total_value = sum(v for v, s in zip(values, sel) if s)\n\n    # Lower score is better: maximize value via negative score\n    if total_cost <= budget:\n        return -float(total_value)\n\n    # Infeasible: linear penalty on budget violation with mild shaping, minus value to preserve gradient\n    over = float(total_cost - budget)\n    lambda_pen = 12.0  # tuned to be > typical value gain per cheapest item\n    return lambda_pen * over - float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> tuple[str, str]:\n    # Problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    # Greedy density-based feasible initializer\n    def greedy_feasible() -> str:\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        bits = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total + costs[i] <= budget:\n                bits[i] = '1'\n                total += costs[i]\n        return ''.join(bits)\n\n    # Validate\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = greedy_feasible()\n\n    bits = list(solution)\n\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    def total_value_bits(bl):\n        return sum(values[i] for i, b in enumerate(bl) if b == '1')\n\n    current_cost = total_cost_bits(bits)\n\n    r = random.random()\n    move_label = 'noop'\n\n    # Move set: add, drop, 1-out-1-in swap, limited 2-exchange\n    if r < 0.35:\n        # Add best affordable by density\n        zeros = [i for i, b in enumerate(bits) if b == '0']\n        zeros.sort(key=lambda i: (values[i]\/costs[i], values[i]), reverse=True)\n        for j in zeros:\n            if current_cost + costs[j] <= budget:\n                bits[j] = '1'\n                move_label = 'add_best_affordable'\n                break\n        if move_label == 'noop':\n            # Drop worst density to open space\n            ones = [i for i, b in enumerate(bits) if b == '1']\n            if ones:\n                worst = min(ones, key=lambda i: (values[i]\/costs[i], -costs[i]))\n                bits[worst] = '0'\n                move_label = 'drop_worst_density'\n    elif r < 0.7:\n        # Best improving feasible swap (1-out,1-in)\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        best_delta = None\n        best_pair = None\n        for j in zeros:\n            cj = costs[j]\n            vj = values[j]\n            if current_cost + cj <= budget:\n                # direct add if fits\n                bits[j] = '1'\n                move_label = 'add_direct'\n                break\n        else:\n            for i in ones:\n                ci = costs[i]\n                vi = values[i]\n                for j in zeros:\n                    new_cost = current_cost - ci + costs[j]\n                    if new_cost <= budget:\n                        delta = values[j] - vi\n                        if (best_delta is None) or (delta > best_delta):\n                            best_delta = delta\n                            best_pair = (i, j)\n            if best_pair is not None:\n                i, j = best_pair\n                bits[i] = '0'\n                bits[j] = '1'\n                move_label = 'swap_1out_1in_best'\n            else:\n                # fallback: drop a random selected if any\n                if ones:\n                    i = random.choice(ones)\n                    bits[i] = '0'\n                    move_label = 'drop_random_fallback'\n    else:\n        # Limited 2-exchange: try remove up to 2 and add up to 2 greedily\n        ones = [i for i, b in enumerate(bits) if b == '1']\n        zeros = [j for j, b in enumerate(bits) if b == '0']\n        # Randomly pick a candidate to drop, then refill by best density\n        dropped = []\n        if ones:\n            i = random.choice(ones)\n            bits[i] = '0'\n            dropped.append(i)\n        if len(ones) > 1 and random.random() < 0.5:\n            others = [x for x in ones if x != dropped[0]]\n            i2 = random.choice(others)\n            bits[i2] = '0'\n            dropped.append(i2)\n        move_label = f'drop_{len(dropped)}'\n        # Refill by density while feasible\n        current_cost2 = total_cost_bits(bits)\n        zeros_now = [j for j, b in enumerate(bits) if b == '0']\n        zeros_now.sort(key=lambda j: (values[j]\/costs[j], values[j]), reverse=True)\n        added = 0\n        for j in zeros_now:\n            if current_cost2 + costs[j] <= budget:\n                bits[j] = '1'\n                current_cost2 += costs[j]\n                added += 1\n                if added >= 2:\n                    break\n        move_label = move_label + f'_add_{added}'\n\n    # Final repair to ensure feasibility\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n        move_label = move_label + '_repaired'\n\n    neighbour = ''.join(bits)\n    return neighbour, move_label\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Validate\n    if not isinstance(solution, str) or len(solution) != 24 or any(c not in '01' for c in solution):\n        solution = '0' * 24\n\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    bits = list(solution)\n    n = len(bits)\n\n    # Flip k bits (3..6), biased to low-density indices for drops and high-density for adds\n    densities = [(i, (values[i]\/costs[i])) for i in range(n)]\n    densities.sort(key=lambda x: x[1])\n    low_density = [i for i, _ in densities[:max(3, n\/\/6)]]\n    high_density = [i for i, _ in densities[-max(3, n\/\/6):]]\n\n    k = random.choice([3,4,5,6])\n    idxs = set()\n    # Prefer flipping some low-density selected bits to 0\n    selected = [i for i, b in enumerate(bits) if b == '1']\n    random.shuffle(selected)\n    for i in selected:\n        if i in low_density:\n            idxs.add(i)\n            if len(idxs) >= k:\n                break\n    # Fill remaining flips randomly\n    while len(idxs) < k:\n        idxs.add(random.randrange(n))\n\n    for i in idxs:\n        bits[i] = '0' if bits[i] == '1' else '1'\n\n    # Repair by dropping worst density until feasible\n    def total_cost_bits(bl):\n        return sum(costs[i] for i, b in enumerate(bl) if b == '1')\n\n    while total_cost_bits(bits) > budget:\n        sel = [i for i, b in enumerate(bits) if b == '1']\n        if not sel:\n            break\n        worst = min(sel, key=lambda i: (values[i]\/costs[i], -costs[i]))\n        bits[worst] = '0'\n\n    return ''.join(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000029999}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; positions 1..24 map to customers 1..24; character '1' means take offer, '0' means skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    if total_gallons > capacity:\n        # Penalize infeasibility (minimization perspective)\n        overflow = total_gallons - capacity\n        return 1000.0 + overflow * overflow\n    # Feasible: return negative revenue to convert max->min\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor move: flip a single random bit (metadata only returned per required signature)\n    # This function intentionally returns movement descriptors to satisfy the strict signature.\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-bit flip with feasibility bias: try to keep within capacity\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        # produce a random feasible-ish solution\n        base = ['0'] * 24\n        idxs = list(range(24))\n        random.shuffle(idxs)\n        # embed data locally\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        cap = 9\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= cap and random.random() < 0.5:\n                base[i] = '1'\n                used += gallons[i]\n        return ''.join(base)\n    s = list(solution)\n    n_flips = random.randint(1, 3)\n    idxs = list(range(len(s)))\n    random.shuffle(idxs)\n    for i in idxs[:n_flips]:\n        s[i] = '1' if s[i] == '0' else '0'\n    # Repair if infeasible\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    cap = 9\n    # While over capacity, greedily drop lowest value density items among selected\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    def total_gal(ss):\n        return sum(g for c,g in zip(ss, gallons) if c == '1')\n    if total_gal(s) > cap:\n        selected = [i for i,c in enumerate(s) if c == '1']\n        # compute density (value per gallon; items with gallon>cap considered very poor)\n        dens = [(i, (values[i] \/ gallons[i]) if gallons[i] > 0 else 0.0) for i in selected]\n        # remove lowest density first\n        dens.sort(key=lambda x: x[1])\n        for i,_ in dens:\n            s[i] = '0'\n            if total_gal(s) <= cap:\n                break\n    return ''.join(s)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000165701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; positions 1..24 map to customers 1..24; character '1' means take offer, '0' means skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    if total_gallons > capacity:\n        # Penalize infeasibility (minimization perspective)\n        overflow = total_gallons - capacity\n        return 1000.0 + overflow * overflow\n    # Feasible: return negative revenue to convert max->min\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor move: flip a single random bit (metadata only returned per required signature)\n    # This function intentionally returns movement descriptors to satisfy the strict signature.\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-bit flip with feasibility bias: try to keep within capacity\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        # produce a random feasible-ish solution\n        base = ['0'] * 24\n        idxs = list(range(24))\n        random.shuffle(idxs)\n        # embed data locally\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        cap = 9\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= cap and random.random() < 0.5:\n                base[i] = '1'\n                used += gallons[i]\n        return ''.join(base)\n    s = list(solution)\n    n_flips = random.randint(1, 3)\n    idxs = list(range(len(s)))\n    random.shuffle(idxs)\n    for i in idxs[:n_flips]:\n        s[i] = '1' if s[i] == '0' else '0'\n    # Repair if infeasible\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    cap = 9\n    # While over capacity, greedily drop lowest value density items among selected\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    def total_gal(ss):\n        return sum(g for c,g in zip(ss, gallons) if c == '1')\n    if total_gal(s) > cap:\n        selected = [i for i,c in enumerate(s) if c == '1']\n        # compute density (value per gallon; items with gallon>cap considered very poor)\n        dens = [(i, (values[i] \/ gallons[i]) if gallons[i] > 0 else 0.0) for i in selected]\n        # remove lowest density first\n        dens.sort(key=lambda x: x[1])\n        for i,_ in dens:\n            s[i] = '0'\n            if total_gal(s) <= cap:\n                break\n    return ''.join(s)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000418}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; positions 1..24 map to customers 1..24; character '1' means take offer, '0' means skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    if total_gallons > capacity:\n        # Penalize infeasibility (minimization perspective)\n        overflow = total_gallons - capacity\n        return 1000.0 + overflow * overflow\n    # Feasible: return negative revenue to convert max->min\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighbor move: flip a single random bit (metadata only returned per required signature)\n    # This function intentionally returns movement descriptors to satisfy the strict signature.\n    return (\"flip\", \"single_bit\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Random multi-bit flip with feasibility bias: try to keep within capacity\n    if not isinstance(solution, str) or any(c not in '01' for c in solution) or len(solution) != 24:\n        # produce a random feasible-ish solution\n        base = ['0'] * 24\n        idxs = list(range(24))\n        random.shuffle(idxs)\n        # embed data locally\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        cap = 9\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= cap and random.random() < 0.5:\n                base[i] = '1'\n                used += gallons[i]\n        return ''.join(base)\n    s = list(solution)\n    n_flips = random.randint(1, 3)\n    idxs = list(range(len(s)))\n    random.shuffle(idxs)\n    for i in idxs[:n_flips]:\n        s[i] = '1' if s[i] == '0' else '0'\n    # Repair if infeasible\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    cap = 9\n    # While over capacity, greedily drop lowest value density items among selected\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    def total_gal(ss):\n        return sum(g for c,g in zip(ss, gallons) if c == '1')\n    if total_gal(s) > cap:\n        selected = [i for i,c in enumerate(s) if c == '1']\n        # compute density (value per gallon; items with gallon>cap considered very poor)\n        dens = [(i, (values[i] \/ gallons[i]) if gallons[i] > 0 else 0.0) for i in selected]\n        # remove lowest density first\n        dens.sort(key=lambda x: x[1])\n        for i,_ in dens:\n            s[i] = '0'\n            if total_gal(s) <= cap:\n                break\n    return ''.join(s)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000027999}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip. Example: '000100010000000001000000' selects customers {4,8,18}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict validation\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    # Compute totals\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    # Feasibility penalty: strictly dominate any feasible score\n    penalty_base = 1 + sum(values)  # 283\n    if total_gallons > capacity:\n        overflow = total_gallons - capacity\n        return penalty_base + (10**6) * overflow\n    # Feasible: convert max revenue to min cost\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value density until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        sol = random_feasible()\n    else:\n        sol = solution\n\n    move_choice = random.random()\n    s = list(sol)\n\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit\")\n    elif move_choice < 0.7:\n        # Swap: remove one selected, add one unselected if fits best\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used = sum(g for b, g in zip(s, gallons) if b == '1')\n            room = capacity - used\n            # choose best density that fits\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                i_in = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_in] = '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Add\/remove biased by feasibility\n        used = sum(g for b, g in zip(s, gallons) if b == '1')\n        if used < capacity and any(b == '0' for b in s):\n            # try to add best fitting item\n            room = capacity - used\n            cands = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if cands:\n                i_add = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_fit\")\n        else:\n            # remove worst density item to free space\n            sel = [i for i, b in enumerate(s) if b == '1']\n            if sel:\n                i_rem = min(sel, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value-per-gallon until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    s = solution if is_valid_str(solution) else random_feasible()\n    s = list(s)\n    # Adaptive k: 2..4 random flips\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    s = ''.join(s)\n    # Always repair to feasibility basin\n    s = repair_feasible(s)\n    # Intensify by attempting a greedy add if room remains\n    used = sum(g for b, g in zip(s, gallons) if b == '1')\n    room = capacity - used\n    if room > 0:\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if zeros:\n            i_best = max(zeros, key=lambda i: (values[i] \/ gallons[i]))\n            s = list(s)\n            s[i_best] = '1'\n            s = ''.join(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00001984}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip. Example: '000100010000000001000000' selects customers {4,8,18}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict validation\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    # Compute totals\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    # Feasibility penalty: strictly dominate any feasible score\n    penalty_base = 1 + sum(values)  # 283\n    if total_gallons > capacity:\n        overflow = total_gallons - capacity\n        return penalty_base + (10**6) * overflow\n    # Feasible: convert max revenue to min cost\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value density until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        sol = random_feasible()\n    else:\n        sol = solution\n\n    move_choice = random.random()\n    s = list(sol)\n\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit\")\n    elif move_choice < 0.7:\n        # Swap: remove one selected, add one unselected if fits best\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used = sum(g for b, g in zip(s, gallons) if b == '1')\n            room = capacity - used\n            # choose best density that fits\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                i_in = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_in] = '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Add\/remove biased by feasibility\n        used = sum(g for b, g in zip(s, gallons) if b == '1')\n        if used < capacity and any(b == '0' for b in s):\n            # try to add best fitting item\n            room = capacity - used\n            cands = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if cands:\n                i_add = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_fit\")\n        else:\n            # remove worst density item to free space\n            sel = [i for i, b in enumerate(s) if b == '1']\n            if sel:\n                i_rem = min(sel, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value-per-gallon until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    s = solution if is_valid_str(solution) else random_feasible()\n    s = list(s)\n    # Adaptive k: 2..4 random flips\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    s = ''.join(s)\n    # Always repair to feasibility basin\n    s = repair_feasible(s)\n    # Intensify by attempting a greedy add if room remains\n    used = sum(g for b, g in zip(s, gallons) if b == '1')\n    room = capacity - used\n    if room > 0:\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if zeros:\n            i_best = max(zeros, key=lambda i: (values[i] \/ gallons[i]))\n            s = list(s)\n            s[i_best] = '1'\n            s = ''.join(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000469}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip. Example: '000100010000000001000000' selects customers {4,8,18}.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict validation\n    if not isinstance(solution, str):\n        return float('inf')\n    n = 24\n    if len(solution) != n or any(c not in '01' for c in solution):\n        return float('inf')\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n    # Compute totals\n    total_value = 0\n    total_gallons = 0\n    for i, c in enumerate(solution):\n        if c == '1':\n            total_value += values[i]\n            total_gallons += gallons[i]\n    # Feasibility penalty: strictly dominate any feasible score\n    penalty_base = 1 + sum(values)  # 283\n    if total_gallons > capacity:\n        overflow = total_gallons - capacity\n        return penalty_base + (10**6) * overflow\n    # Feasible: convert max revenue to min cost\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value density until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        sol = random_feasible()\n    else:\n        sol = solution\n\n    move_choice = random.random()\n    s = list(sol)\n\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit\")\n    elif move_choice < 0.7:\n        # Swap: remove one selected, add one unselected if fits best\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used = sum(g for b, g in zip(s, gallons) if b == '1')\n            room = capacity - used\n            # choose best density that fits\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                i_in = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_in] = '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Add\/remove biased by feasibility\n        used = sum(g for b, g in zip(s, gallons) if b == '1')\n        if used < capacity and any(b == '0' for b in s):\n            # try to add best fitting item\n            room = capacity - used\n            cands = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if cands:\n                i_add = max(cands, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_fit\")\n        else:\n            # remove worst density item to free space\n            sel = [i for i, b in enumerate(s) if b == '1']\n            if sel:\n                i_rem = min(sel, key=lambda i: (values[i] \/ gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def repair_feasible(s):\n        s = list(s)\n        w = sum(g for b, g in zip(s, gallons) if b == '1')\n        if w <= capacity:\n            return ''.join(s)\n        # Drop lowest value-per-gallon until feasible\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        s = ['0'] * n\n        idxs = list(range(n))\n        random.shuffle(idxs)\n        used = 0\n        for i in idxs:\n            if used + gallons[i] <= capacity and random.random() < 0.5:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    s = solution if is_valid_str(solution) else random_feasible()\n    s = list(s)\n    # Adaptive k: 2..4 random flips\n    k = random.randint(2, 4)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    s = ''.join(s)\n    # Always repair to feasibility basin\n    s = repair_feasible(s)\n    # Intensify by attempting a greedy add if room remains\n    used = sum(g for b, g in zip(s, gallons) if b == '1')\n    room = capacity - used\n    if room > 0:\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if zeros:\n            i_best = max(zeros, key=lambda i: (values[i] \/ gallons[i]))\n            s = list(s)\n            s[i_best] = '1'\n            s = ''.join(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000285}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict, self-contained evaluator. Feasible solutions return negative revenue (minimize); infeasible return large penalty.\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        n = 24\n        if len(solution) != n or any(c not in '01' for c in solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def value_of(s):\n        return sum(v for b, v in zip(s, values) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Drop by lowest value-per-gallon, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        # Diverse constructive starts: choose among several heuristics\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            # sort by value density desc\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            # sort by value desc\n            key = lambda i: (values[i], -(gallons[i]))\n        else:\n            # randomized greedy with alpha\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        # Greedy fill according to key\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n\n    # Ensure baseline feasibility; if infeasible, repair\n    if weight_of(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of(s)\n    move_choice = random.random()\n\n    if move_choice < 0.4:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.75:\n        # 1-out 1-in exchange preserving feasibility\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                # try multiple scoring rules\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Greedy add or targeted remove to move along tight capacity boundary\n        if used < capacity:\n            room = capacity - used\n            zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if zeros:\n                i_add = max(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_density\")\n        else:\n            # remove worst density to free space\n            ones = [i for i, b in enumerate(s) if b == '1']\n            if ones:\n                i_rem = min(ones, key=lambda i: (values[i] \/ gallons[i], -gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        # construct a minimal feasible baseline\n        feas = ['0'] * n\n        # try best single item that fits\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    # Ruin: flip k bits (biased to 2-3)\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    # Repair to feasibility and then refill greedily\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000146701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict, self-contained evaluator. Feasible solutions return negative revenue (minimize); infeasible return large penalty.\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        n = 24\n        if len(solution) != n or any(c not in '01' for c in solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def value_of(s):\n        return sum(v for b, v in zip(s, values) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Drop by lowest value-per-gallon, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        # Diverse constructive starts: choose among several heuristics\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            # sort by value density desc\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            # sort by value desc\n            key = lambda i: (values[i], -(gallons[i]))\n        else:\n            # randomized greedy with alpha\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        # Greedy fill according to key\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n\n    # Ensure baseline feasibility; if infeasible, repair\n    if weight_of(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of(s)\n    move_choice = random.random()\n\n    if move_choice < 0.4:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.75:\n        # 1-out 1-in exchange preserving feasibility\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                # try multiple scoring rules\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Greedy add or targeted remove to move along tight capacity boundary\n        if used < capacity:\n            room = capacity - used\n            zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if zeros:\n                i_add = max(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_density\")\n        else:\n            # remove worst density to free space\n            ones = [i for i, b in enumerate(s) if b == '1']\n            if ones:\n                i_rem = min(ones, key=lambda i: (values[i] \/ gallons[i], -gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        # construct a minimal feasible baseline\n        feas = ['0'] * n\n        # try best single item that fits\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    # Ruin: flip k bits (biased to 2-3)\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    # Repair to feasibility and then refill greedily\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000461}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9; index i (1..24) maps to customer i; '1' means take offer, '0' skip.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Strict, self-contained evaluator. Feasible solutions return negative revenue (minimize); infeasible return large penalty.\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        n = 24\n        if len(solution) != n or any(c not in '01' for c in solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def value_of(s):\n        return sum(v for b, v in zip(s, values) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Drop by lowest value-per-gallon, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        # Diverse constructive starts: choose among several heuristics\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            # sort by value density desc\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            # sort by value desc\n            key = lambda i: (values[i], -(gallons[i]))\n        else:\n            # randomized greedy with alpha\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        # Greedy fill according to key\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n\n    # Ensure baseline feasibility; if infeasible, repair\n    if weight_of(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of(s)\n    move_choice = random.random()\n\n    if move_choice < 0.4:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.75:\n        # 1-out 1-in exchange preserving feasibility\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                # try multiple scoring rules\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    else:\n        # Greedy add or targeted remove to move along tight capacity boundary\n        if used < capacity:\n            room = capacity - used\n            zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n            if zeros:\n                i_add = max(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s[i_add] = '1'\n            nb = ''.join(s)\n            return nb, (\"add\", \"greedy_density\")\n        else:\n            # remove worst density to free space\n            ones = [i for i, b in enumerate(s) if b == '1']\n            if ones:\n                i_rem = min(ones, key=lambda i: (values[i] \/ gallons[i], -gallons[i]))\n                s[i_rem] = '0'\n            nb = ''.join(s)\n            return nb, (\"remove\", \"worst_density\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and len(s) == n and all(c in '01' for c in s)\n\n    def weight_of(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        # construct a minimal feasible baseline\n        feas = ['0'] * n\n        # try best single item that fits\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    # Ruin: flip k bits (biased to 2-3)\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    # Repair to feasibility and then refill greedily\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000287}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9","Evaluacion":"import math\nimport random\nimport re\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: feasible -> negative revenue (for minimization), infeasible -> large positive penalty\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        if not re.fullmatch(r\"[01]{24}\", solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\nimport re\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Remove by lowest density, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            key = lambda i: (values[i], -gallons[i])\n        else:\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n    if weight_of_s(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of_s(s)\n    move_choice = random.random()\n\n    if move_choice < 0.3:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.6:\n        # 1-out 1-in exchange\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    elif move_choice < 0.8:\n        # k-exchange: remove 1 add up to 2 greedily\n        ones = [i for i, b in enumerate(s) if b == '1']\n        zeros = [i for i, b in enumerate(s) if b == '0']\n        if ones:\n            i_out = random.choice(ones)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in zeros if gallons[i] <= room]\n            s2 = s[:]\n            while True:\n                room = capacity - sum(g for j,g in enumerate(gallons) if s2[j]=='1')\n                feas = [i for i in cands if s2[i]=='0' and gallons[i] <= room]\n                if not feas:\n                    break\n                pick = max(feas, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s2[pick] = '1'\n            nb = ''.join(s2)\n        else:\n            nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"k_exchange\", \"1to2\")\n    else:\n        # Burst flips (2..4) with repair\n        r = random.choice([2,3,4])\n        idxs = random.sample(range(n), r)\n        for i in idxs:\n            s[i] = '0' if s[i] == '1' else '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"burst\", \"r_flip_repair\")\n","Perturbacion":"import random\nimport math\nimport re\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of_s(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of_s(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        feas = ['0'] * n\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00001431}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9","Evaluacion":"import math\nimport random\nimport re\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: feasible -> negative revenue (for minimization), infeasible -> large positive penalty\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        if not re.fullmatch(r\"[01]{24}\", solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\nimport re\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Remove by lowest density, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            key = lambda i: (values[i], -gallons[i])\n        else:\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n    if weight_of_s(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of_s(s)\n    move_choice = random.random()\n\n    if move_choice < 0.3:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.6:\n        # 1-out 1-in exchange\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    elif move_choice < 0.8:\n        # k-exchange: remove 1 add up to 2 greedily\n        ones = [i for i, b in enumerate(s) if b == '1']\n        zeros = [i for i, b in enumerate(s) if b == '0']\n        if ones:\n            i_out = random.choice(ones)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in zeros if gallons[i] <= room]\n            s2 = s[:]\n            while True:\n                room = capacity - sum(g for j,g in enumerate(gallons) if s2[j]=='1')\n                feas = [i for i in cands if s2[i]=='0' and gallons[i] <= room]\n                if not feas:\n                    break\n                pick = max(feas, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s2[pick] = '1'\n            nb = ''.join(s2)\n        else:\n            nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"k_exchange\", \"1to2\")\n    else:\n        # Burst flips (2..4) with repair\n        r = random.choice([2,3,4])\n        idxs = random.sample(range(n), r)\n        for i in idxs:\n            s[i] = '0' if s[i] == '1' else '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"burst\", \"r_flip_repair\")\n","Perturbacion":"import random\nimport math\nimport re\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of_s(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of_s(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        feas = ['0'] * n\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000435}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"BIN_STR_LEN24_CAP9","Evaluacion":"import math\nimport random\nimport re\n\ndef evaluate_solution(solution):\n    # Returns numeric fitness: feasible -> negative revenue (for minimization), infeasible -> large positive penalty\n    try:\n        if not isinstance(solution, str):\n            return float('inf')\n        if not re.fullmatch(r\"[01]{24}\", solution):\n            return float('inf')\n        # Embedded problem data\n        values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n        gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n        capacity = 9\n        total_value = 0\n        total_gallons = 0\n        for bit, v, w in zip(solution, values, gallons):\n            if bit == '1':\n                total_value += v\n                total_gallons += w\n        if total_gallons > capacity:\n            overflow = total_gallons - capacity\n            return 1e12 + 1e9 * float(overflow)\n        return -float(total_value)\n    except Exception:\n        return float('inf')\n","Vecindad":"import random\nimport math\nimport re\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        # Remove by lowest density, then by higher weight, then by lower value\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def random_feasible():\n        idxs = list(range(n))\n        heur = random.random()\n        if heur < 0.33:\n            key = lambda i: (values[i] \/ gallons[i], values[i])\n        elif heur < 0.66:\n            key = lambda i: (values[i], -gallons[i])\n        else:\n            random.shuffle(idxs)\n            s = ['0'] * n\n            used = 0\n            alpha = 0.4\n            candidates = [i for i in range(n) if gallons[i] <= capacity]\n            while True:\n                room = capacity - used\n                feas = [i for i in candidates if s[i] == '0' and gallons[i] <= room]\n                if not feas:\n                    break\n                sc = sorted(feas, key=lambda i: (values[i] \/ gallons[i]), reverse=True)\n                k = max(1, int(math.ceil(alpha * len(sc))))\n                pick = random.choice(sc[:k])\n                s[pick] = '1'\n                used += gallons[pick]\n            return ''.join(s)\n        order = sorted([i for i in range(n) if gallons[i] <= capacity], key=key, reverse=True)\n        s = ['0'] * n\n        used = 0\n        for i in order:\n            if used + gallons[i] <= capacity:\n                s[i] = '1'\n                used += gallons[i]\n        return ''.join(s)\n\n    sol = solution if is_valid_str(solution) else random_feasible()\n    if weight_of_s(sol) > capacity:\n        sol = repair_feasible(sol)\n\n    s = list(sol)\n    used = weight_of_s(s)\n    move_choice = random.random()\n\n    if move_choice < 0.3:\n        # Single-bit flip then repair\n        i = random.randrange(n)\n        s[i] = '0' if s[i] == '1' else '1'\n        nb = repair_feasible(''.join(s))\n        return nb, (\"flip\", \"single_bit_repair\")\n    elif move_choice < 0.6:\n        # 1-out 1-in exchange\n        selected = [i for i, b in enumerate(s) if b == '1']\n        unselected = [i for i, b in enumerate(s) if b == '0']\n        if selected and unselected:\n            i_out = random.choice(selected)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in unselected if gallons[i] <= room]\n            if cands:\n                rule = random.random()\n                if rule < 0.5:\n                    i_in = max(cands, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                else:\n                    i_in = max(cands, key=lambda i: (values[i], -gallons[i]))\n                s[i_in] = '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"swap\", \"1out_1in\")\n    elif move_choice < 0.8:\n        # k-exchange: remove 1 add up to 2 greedily\n        ones = [i for i, b in enumerate(s) if b == '1']\n        zeros = [i for i, b in enumerate(s) if b == '0']\n        if ones:\n            i_out = random.choice(ones)\n            s[i_out] = '0'\n            used2 = used - gallons[i_out]\n            room = capacity - used2\n            cands = [i for i in zeros if gallons[i] <= room]\n            s2 = s[:]\n            while True:\n                room = capacity - sum(g for j,g in enumerate(gallons) if s2[j]=='1')\n                feas = [i for i in cands if s2[i]=='0' and gallons[i] <= room]\n                if not feas:\n                    break\n                pick = max(feas, key=lambda i: (values[i] \/ gallons[i], values[i]))\n                s2[pick] = '1'\n            nb = ''.join(s2)\n        else:\n            nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"k_exchange\", \"1to2\")\n    else:\n        # Burst flips (2..4) with repair\n        r = random.choice([2,3,4])\n        idxs = random.sample(range(n), r)\n        for i in idxs:\n            s[i] = '0' if s[i] == '1' else '1'\n        nb = ''.join(s)\n        if weight_of_s(nb) > capacity:\n            nb = repair_feasible(nb)\n        return nb, (\"burst\", \"r_flip_repair\")\n","Perturbacion":"import random\nimport math\nimport re\n\ndef perturb_solution(solution):\n    # Ruin-and-recreate perturbation with feasibility repair and greedy refill\n    n = 24\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    gallons = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 9\n\n    def is_valid_str(s):\n        return isinstance(s, str) and re.fullmatch(r\"[01]{24}\", s) is not None\n\n    def weight_of_s(s):\n        return sum(g for b, g in zip(s, gallons) if b == '1')\n\n    def repair_feasible(s):\n        s = list(s)\n        w = weight_of_s(s)\n        if w <= capacity:\n            return ''.join(s)\n        idxs = [i for i, b in enumerate(s) if b == '1']\n        order = sorted(idxs, key=lambda i: (values[i] \/ gallons[i], -gallons[i], values[i]))\n        for i in order:\n            if w <= capacity:\n                break\n            if s[i] == '1':\n                s[i] = '0'\n                w -= gallons[i]\n        return ''.join(s)\n\n    def greedy_refill(s):\n        used = weight_of_s(s)\n        room = capacity - used\n        if room <= 0:\n            return s\n        zeros = [i for i, b in enumerate(s) if b == '0' and gallons[i] <= room]\n        if not zeros:\n            return s\n        rule = random.random()\n        if rule < 0.5:\n            order = sorted(zeros, key=lambda i: (values[i] \/ gallons[i], values[i]), reverse=True)\n        else:\n            order = sorted(zeros, key=lambda i: (values[i], -gallons[i]), reverse=True)\n        s = list(s)\n        for i in order:\n            if weight_of_s(s) + gallons[i] <= capacity:\n                s[i] = '1'\n        return ''.join(s)\n\n    if not is_valid_str(solution):\n        feas = ['0'] * n\n        fits = [i for i in range(n) if gallons[i] <= capacity]\n        if fits:\n            best = max(fits, key=lambda i: values[i])\n            feas[best] = '1'\n        s = ''.join(feas)\n    else:\n        s = solution\n\n    k = random.choice([2, 2, 3, 3, 4])\n    idxs = random.sample(range(n), k)\n    s_list = list(s)\n    for i in idxs:\n        s_list[i] = '0' if s_list[i] == '1' else '1'\n    s = ''.join(s_list)\n\n    s = repair_feasible(s)\n    s = greedy_refill(s)\n    return s\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000278}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect solution as a binary string of length 24\n    # Returns lesser-is-better fitness: feasible -> negative total score; infeasible -> large penalty\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Basic validation and normalization\n    if isinstance(solution, (list, tuple)):\n        # Convert list\/tuple of 0\/1 to string\n        try:\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        except Exception:\n            return 10**9\n    if not isinstance(solution, str):\n        return 10**9\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        return 10**6 + (total_time - capacity)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # 1-bit flip neighborhood on binary string representation\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return (solution, 'binary', 'noop')\n    idx = random.randrange(n)\n    sol[idx] = 1 - sol[idx]\n    new_solution = ''.join('1' if b else '0' for b in sol)\n    return (new_solution, 'binary', '1-bit-flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flips (k in [2, max(2, n\/\/6)]) for shaking\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = max(2, n \/\/ 6)\n    k = random.randint(k_min, k_max)\n    indices = random.sample(range(n), k=min(k, n))\n    for idx in indices:\n        sol[idx] = 1 - sol[idx]\n    return ''.join('1' if b else '0' for b in sol)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000157499}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect solution as a binary string of length 24\n    # Returns lesser-is-better fitness: feasible -> negative total score; infeasible -> large penalty\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Basic validation and normalization\n    if isinstance(solution, (list, tuple)):\n        # Convert list\/tuple of 0\/1 to string\n        try:\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        except Exception:\n            return 10**9\n    if not isinstance(solution, str):\n        return 10**9\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        return 10**6 + (total_time - capacity)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # 1-bit flip neighborhood on binary string representation\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return (solution, 'binary', 'noop')\n    idx = random.randrange(n)\n    sol[idx] = 1 - sol[idx]\n    new_solution = ''.join('1' if b else '0' for b in sol)\n    return (new_solution, 'binary', '1-bit-flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flips (k in [2, max(2, n\/\/6)]) for shaking\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = max(2, n \/\/ 6)\n    k = random.randint(k_min, k_max)\n    indices = random.sample(range(n), k=min(k, n))\n    for idx in indices:\n        sol[idx] = 1 - sol[idx]\n    return ''.join('1' if b else '0' for b in sol)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0000042}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Expect solution as a binary string of length 24\n    # Returns lesser-is-better fitness: feasible -> negative total score; infeasible -> large penalty\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Basic validation and normalization\n    if isinstance(solution, (list, tuple)):\n        # Convert list\/tuple of 0\/1 to string\n        try:\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        except Exception:\n            return 10**9\n    if not isinstance(solution, str):\n        return 10**9\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        return 10**6 + (total_time - capacity)\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # 1-bit flip neighborhood on binary string representation\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return (solution, 'binary', 'noop')\n    idx = random.randrange(n)\n    sol[idx] = 1 - sol[idx]\n    new_solution = ''.join('1' if b else '0' for b in sol)\n    return (new_solution, 'binary', '1-bit-flip')\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-bit random flips (k in [2, max(2, n\/\/6)]) for shaking\n    if isinstance(solution, (list, tuple)):\n        sol = [int(bool(x)) for x in solution]\n    elif isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            raise ValueError('Invalid solution encoding')\n        sol = [1 if ch == '1' else 0 for ch in solution]\n    else:\n        raise ValueError('Unsupported solution type')\n    n = len(sol)\n    if n == 0:\n        return solution\n    k_min = 2\n    k_max = max(2, n \/\/ 6)\n    k = random.randint(k_min, k_max)\n    indices = random.sample(range(n), k=min(k, n))\n    for idx in indices:\n        sol[idx] = 1 - sol[idx]\n    return ''.join('1' if b else '0' for b in sol)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000027601}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize input to binary string\n    try:\n        if isinstance(solution, (list, tuple)):\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        elif not isinstance(solution, str):\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 10**6 + 1000*overflow\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            # Return original encoding on invalid input; caller should evaluate penalty\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\n# Returns (new_solution, movement_type)\n# NB_Type is the binary-encoded solution string\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n    n = len(bits)\n    if n == 0:\n        return (solution, 'noop')\n\n    move_type = random.random()\n    if move_type < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip')\n    elif move_type < 0.85:\n        # k-bit flip, k in {2,3}\n        k = 2 if random.random() < 0.7 else 3\n        k = min(k, n)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), f'{k}-bit-flip')\n    else:\n        # paired swap: set one 1->0 and one 0->1 when possible\n        ones = [i for i,b in enumerate(bits) if b==1]\n        zeros = [i for i,b in enumerate(bits) if b==0]\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            bits[i1] = 0\n            bits[i0] = 1\n            return (_bits_to_str(bits), 'swap-1-0')\n        # fallback to 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip-fallback')\n","Perturbacion":"import random\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\ndef perturb_solution(solution):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return solution\n    n = len(bits)\n    if n == 0:\n        return solution\n    # Flip between 3 and max(5, n\/\/6) bits to strongly shake the solution\n    k_min, k_max = 3, max(5, n\/\/6)\n    k = random.randint(k_min, min(k_max, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        bits[idx] = 1 - bits[idx]\n    return _bits_to_str(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000151099}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize input to binary string\n    try:\n        if isinstance(solution, (list, tuple)):\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        elif not isinstance(solution, str):\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 10**6 + 1000*overflow\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            # Return original encoding on invalid input; caller should evaluate penalty\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\n# Returns (new_solution, movement_type)\n# NB_Type is the binary-encoded solution string\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n    n = len(bits)\n    if n == 0:\n        return (solution, 'noop')\n\n    move_type = random.random()\n    if move_type < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip')\n    elif move_type < 0.85:\n        # k-bit flip, k in {2,3}\n        k = 2 if random.random() < 0.7 else 3\n        k = min(k, n)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), f'{k}-bit-flip')\n    else:\n        # paired swap: set one 1->0 and one 0->1 when possible\n        ones = [i for i,b in enumerate(bits) if b==1]\n        zeros = [i for i,b in enumerate(bits) if b==0]\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            bits[i1] = 0\n            bits[i0] = 1\n            return (_bits_to_str(bits), 'swap-1-0')\n        # fallback to 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip-fallback')\n","Perturbacion":"import random\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\ndef perturb_solution(solution):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return solution\n    n = len(bits)\n    if n == 0:\n        return solution\n    # Flip between 3 and max(5, n\/\/6) bits to strongly shake the solution\n    k_min, k_max = 3, max(5, n\/\/6)\n    k = random.randint(k_min, min(k_max, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        bits[idx] = 1 - bits[idx]\n    return _bits_to_str(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000433}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; position i in [1..24] is '1' iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize input to binary string\n    try:\n        if isinstance(solution, (list, tuple)):\n            solution = ''.join('1' if int(x) else '0' for x in solution)\n        elif not isinstance(solution, str):\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = len(values)\n    if len(solution) != n or any(ch not in '01' for ch in solution):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        return 10**6 + 1000*overflow\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            # Return original encoding on invalid input; caller should evaluate penalty\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\n# Returns (new_solution, movement_type)\n# NB_Type is the binary-encoded solution string\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n    n = len(bits)\n    if n == 0:\n        return (solution, 'noop')\n\n    move_type = random.random()\n    if move_type < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip')\n    elif move_type < 0.85:\n        # k-bit flip, k in {2,3}\n        k = 2 if random.random() < 0.7 else 3\n        k = min(k, n)\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), f'{k}-bit-flip')\n    else:\n        # paired swap: set one 1->0 and one 0->1 when possible\n        ones = [i for i,b in enumerate(bits) if b==1]\n        zeros = [i for i,b in enumerate(bits) if b==0]\n        if ones and zeros:\n            i1 = random.choice(ones)\n            i0 = random.choice(zeros)\n            bits[i1] = 0\n            bits[i0] = 1\n            return (_bits_to_str(bits), 'swap-1-0')\n        # fallback to 1-bit flip\n        idx = random.randrange(n)\n        bits[idx] = 1 - bits[idx]\n        return (_bits_to_str(bits), '1-bit-flip-fallback')\n","Perturbacion":"import random\n\ndef _normalize_to_bits(solution):\n    if isinstance(solution, (list, tuple)):\n        return [1 if int(x) else 0 for x in solution]\n    if isinstance(solution, str):\n        if any(ch not in '01' for ch in solution):\n            return None\n        return [1 if ch == '1' else 0 for ch in solution]\n    return None\n\ndef _bits_to_str(bits):\n    return ''.join('1' if b else '0' for b in bits)\n\ndef perturb_solution(solution):\n    bits = _normalize_to_bits(solution)\n    if bits is None:\n        return solution\n    n = len(bits)\n    if n == 0:\n        return solution\n    # Flip between 3 and max(5, n\/\/6) bits to strongly shake the solution\n    k_min, k_max = 3, max(5, n\/\/6)\n    k = random.randint(k_min, min(k_max, n))\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        bits[idx] = 1 - bits[idx]\n    return _bits_to_str(bits)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000299}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; bit i (1-indexed) = 1 iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize to 24-bit string\n    try:\n        if isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        elif isinstance(solution, str):\n            bits = solution\n        else:\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = 24\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Moderate penalty to preserve gradient while making infeasible clearly worse\n        return 1e5 + 100*overflow - 0.01*total_value\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        # Ensure feasibility (time <= capacity), then greedily refill by value\/time\n        t, v = totals(b)\n        if t > capacity:\n            # Drop lowest value density items until feasible\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)  # lowest density\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Greedy refill by value density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    # Choose move type\n    r = random.random()\n    move = ''\n    b = bits[:]\n    if r < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip'\n    elif r < 0.85:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip'\n    else:\n        # swap: drop one selected and add one unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            i_drop = min(ones, key=lambda i: values[i]\/times[i])\n            i_add  = max(zeros, key=lambda i: values[i]\/times[i])\n            b[i_drop] = 0\n            b[i_add] = 1\n            move = 'swap-density'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = '1-bit-flip-fallback'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake: drop k lowest-density selected items\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        # choose k in [2..4], but not exceeding number of ones\n        k = min(max(2, 2 + (1 if random.random() < 0.5 else 2)), len(ones))\n        ones_sorted = sorted(ones, key=lambda i: values[i]\/times[i])\n        for i in ones_sorted[:k]:\n            b[i] = 0\n\n    # Random add attempts before repair to diversify\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    for i in zeros[:min(5, len(zeros))]:\n        b[i] = 1 - b[i]\n\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0000146701}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; bit i (1-indexed) = 1 iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize to 24-bit string\n    try:\n        if isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        elif isinstance(solution, str):\n            bits = solution\n        else:\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = 24\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Moderate penalty to preserve gradient while making infeasible clearly worse\n        return 1e5 + 100*overflow - 0.01*total_value\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        # Ensure feasibility (time <= capacity), then greedily refill by value\/time\n        t, v = totals(b)\n        if t > capacity:\n            # Drop lowest value density items until feasible\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)  # lowest density\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Greedy refill by value density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    # Choose move type\n    r = random.random()\n    move = ''\n    b = bits[:]\n    if r < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip'\n    elif r < 0.85:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip'\n    else:\n        # swap: drop one selected and add one unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            i_drop = min(ones, key=lambda i: values[i]\/times[i])\n            i_add  = max(zeros, key=lambda i: values[i]\/times[i])\n            b[i_drop] = 0\n            b[i_add] = 1\n            move = 'swap-density'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = '1-bit-flip-fallback'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake: drop k lowest-density selected items\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        # choose k in [2..4], but not exceeding number of ones\n        k = min(max(2, 2 + (1 if random.random() < 0.5 else 2)), len(ones))\n        ones_sorted = sorted(ones, key=lambda i: values[i]\/times[i])\n        for i in ones_sorted[:k]:\n            b[i] = 0\n\n    # Random add attempts before repair to diversify\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    for i in zeros[:min(5, len(zeros))]:\n        b[i] = 1 - b[i]\n\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000458}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"BIN_STR_LEN_24; bit i (1-indexed) = 1 iff attraction i is selected; capacity=90 minutes.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n\n    # Normalize to 24-bit string\n    try:\n        if isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        elif isinstance(solution, str):\n            bits = solution\n        else:\n            return 10**9\n    except Exception:\n        return 10**9\n\n    n = 24\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**9\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Moderate penalty to preserve gradient while making infeasible clearly worse\n        return 1e5 + 100*overflow - 0.01*total_value\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        # Ensure feasibility (time <= capacity), then greedily refill by value\/time\n        t, v = totals(b)\n        if t > capacity:\n            # Drop lowest value density items until feasible\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)  # lowest density\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Greedy refill by value density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    # Choose move type\n    r = random.random()\n    move = ''\n    b = bits[:]\n    if r < 0.5:\n        # 1-bit flip\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip'\n    elif r < 0.85:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip'\n    else:\n        # swap: drop one selected and add one unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            i_drop = min(ones, key=lambda i: values[i]\/times[i])\n            i_add  = max(zeros, key=lambda i: values[i]\/times[i])\n            b[i_drop] = 0\n            b[i_add] = 1\n            move = 'swap-density'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = '1-bit-flip-fallback'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol):\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b):\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b):\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i]\/times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                _, idx = min(cand)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: values[i]\/times[i], reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake: drop k lowest-density selected items\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        # choose k in [2..4], but not exceeding number of ones\n        k = min(max(2, 2 + (1 if random.random() < 0.5 else 2)), len(ones))\n        ones_sorted = sorted(ones, key=lambda i: values[i]\/times[i])\n        for i in ones_sorted[:k]:\n            b[i] = 0\n\n    # Random add attempts before repair to diversify\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    for i in zeros[:min(5, len(zeros))]:\n        b[i] = 1 - b[i]\n\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0000031299}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"24-bit binary string; bit i (1-indexed) = 1 iff attraction i is selected.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Normalize input to bitstring\n    try:\n        if isinstance(solution, str):\n            bits = solution\n        elif isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        else:\n            return 10**12\n    except Exception:\n        return 10**12\n\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**12\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Feasibility-first: any infeasible solution is worse than any feasible\n        # Encode as large base + scaled overflow - small value term to break ties\n        return 1_000_000_000 + overflow * 1_000 - 0.001 * total_value\n\n    # Maximization -> return negative value for minimization-based heuristics\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by value density with random tie-breaking\n        t, v = totals(b)\n        if t > capacity:\n            # Remove lowest density items until feasible\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                # Randomized tie-break: shuffle equal densities implicitly by jitter\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Refill greedily by density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    b = bits[:]\n    move = ''\n\n    # Move selection with targeted exchanges for tight capacity\n    r = random.random()\n    if r < 0.40:\n        # 1-bit flip then repair\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip+repair'\n    elif r < 0.75:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip+repair'\n    elif r < 0.90:\n        # 1-1 exchange: drop lowest-density selected, add highest-density unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            b[drop] = 0\n            b[add] = 1\n            move = '1-1-density-swap+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n    else:\n        # 1-2 or 2-1 exchange guided by density\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and len(zeros) >= 2 and random.random() < 0.5:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add_candidates = sorted(zeros, key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)[:2]\n            b[drop] = 0\n            for j in add_candidates:\n                b[j] = 1\n            move = '1-2-exchange+repair'\n        elif len(ones) >= 2 and zeros:\n            drop_candidates = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))[:2]\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            for j in drop_candidates:\n                b[j] = 0\n            b[add] = 1\n            move = '2-1-exchange+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by density with slight randomness\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake:\n    # 1) Drop r items with lowest density among selected (r in [2,4])\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        r = min(len(ones), random.randint(2, 4))\n        ones_sorted = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n        for i in ones_sorted[:r]:\n            b[i] = 0\n    # 2) Flip up to q random zeros to ones to diversify (q in [2,5])\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    q = min(len(zeros), random.randint(2, 5))\n    for i in zeros[:q]:\n        b[i] = 1\n\n    # 3) Repair to feasibility and greedily refill\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00001354}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"24-bit binary string; bit i (1-indexed) = 1 iff attraction i is selected.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Normalize input to bitstring\n    try:\n        if isinstance(solution, str):\n            bits = solution\n        elif isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        else:\n            return 10**12\n    except Exception:\n        return 10**12\n\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**12\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Feasibility-first: any infeasible solution is worse than any feasible\n        # Encode as large base + scaled overflow - small value term to break ties\n        return 1_000_000_000 + overflow * 1_000 - 0.001 * total_value\n\n    # Maximization -> return negative value for minimization-based heuristics\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by value density with random tie-breaking\n        t, v = totals(b)\n        if t > capacity:\n            # Remove lowest density items until feasible\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                # Randomized tie-break: shuffle equal densities implicitly by jitter\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Refill greedily by density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    b = bits[:]\n    move = ''\n\n    # Move selection with targeted exchanges for tight capacity\n    r = random.random()\n    if r < 0.40:\n        # 1-bit flip then repair\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip+repair'\n    elif r < 0.75:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip+repair'\n    elif r < 0.90:\n        # 1-1 exchange: drop lowest-density selected, add highest-density unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            b[drop] = 0\n            b[add] = 1\n            move = '1-1-density-swap+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n    else:\n        # 1-2 or 2-1 exchange guided by density\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and len(zeros) >= 2 and random.random() < 0.5:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add_candidates = sorted(zeros, key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)[:2]\n            b[drop] = 0\n            for j in add_candidates:\n                b[j] = 1\n            move = '1-2-exchange+repair'\n        elif len(ones) >= 2 and zeros:\n            drop_candidates = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))[:2]\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            for j in drop_candidates:\n                b[j] = 0\n            b[add] = 1\n            move = '2-1-exchange+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by density with slight randomness\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake:\n    # 1) Drop r items with lowest density among selected (r in [2,4])\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        r = min(len(ones), random.randint(2, 4))\n        ones_sorted = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n        for i in ones_sorted[:r]:\n            b[i] = 0\n    # 2) Flip up to q random zeros to ones to diversify (q in [2,5])\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    q = min(len(zeros), random.randint(2, 5))\n    for i in zeros[:q]:\n        b[i] = 1\n\n    # 3) Repair to feasibility and greedily refill\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000419}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"24-bit binary string; bit i (1-indexed) = 1 iff attraction i is selected.","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list, tuple]):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    # Normalize input to bitstring\n    try:\n        if isinstance(solution, str):\n            bits = solution\n        elif isinstance(solution, (list, tuple)):\n            bits = ''.join('1' if int(x) else '0' for x in solution)\n        else:\n            return 10**12\n    except Exception:\n        return 10**12\n\n    if len(bits) != n or any(ch not in '01' for ch in bits):\n        return 10**12\n\n    total_time = 0\n    total_value = 0\n    for i, ch in enumerate(bits):\n        if ch == '1':\n            total_time += times[i]\n            total_value += values[i]\n\n    if total_time > capacity:\n        overflow = total_time - capacity\n        # Feasibility-first: any infeasible solution is worse than any feasible\n        # Encode as large base + scaled overflow - small value term to break ties\n        return 1_000_000_000 + overflow * 1_000 - 0.001 * total_value\n\n    # Maximization -> return negative value for minimization-based heuristics\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by value density with random tie-breaking\n        t, v = totals(b)\n        if t > capacity:\n            # Remove lowest density items until feasible\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                # Randomized tie-break: shuffle equal densities implicitly by jitter\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        # Refill greedily by density\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    bits = norm_bits(solution)\n    if bits is None:\n        return (solution, 'invalid-noop')\n\n    b = bits[:]\n    move = ''\n\n    # Move selection with targeted exchanges for tight capacity\n    r = random.random()\n    if r < 0.40:\n        # 1-bit flip then repair\n        idx = random.randrange(n)\n        b[idx] = 1 - b[idx]\n        move = '1-bit-flip+repair'\n    elif r < 0.75:\n        # 2-3 bit flip\n        k = 2 if random.random() < 0.7 else 3\n        idxs = random.sample(range(n), k)\n        for idx in idxs:\n            b[idx] = 1 - b[idx]\n        move = f'{k}-bit-flip+repair'\n    elif r < 0.90:\n        # 1-1 exchange: drop lowest-density selected, add highest-density unselected\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and zeros:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            b[drop] = 0\n            b[add] = 1\n            move = '1-1-density-swap+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n    else:\n        # 1-2 or 2-1 exchange guided by density\n        ones = [i for i in range(n) if b[i] == 1]\n        zeros = [i for i in range(n) if b[i] == 0]\n        if ones and len(zeros) >= 2 and random.random() < 0.5:\n            drop = min(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n            add_candidates = sorted(zeros, key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)[:2]\n            b[drop] = 0\n            for j in add_candidates:\n                b[j] = 1\n            move = '1-2-exchange+repair'\n        elif len(ones) >= 2 and zeros:\n            drop_candidates = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))[:2]\n            add = max(zeros, key=lambda i: (values[i] \/ times[i], random.random()))\n            for j in drop_candidates:\n                b[j] = 0\n            b[add] = 1\n            move = '2-1-exchange+repair'\n        else:\n            idx = random.randrange(n)\n            b[idx] = 1 - b[idx]\n            move = 'fallback-1-bit+repair'\n\n    b = repair(b)\n    return (bits_to_str(b), move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    capacity = 90\n    n = 24\n\n    def norm_bits(sol) -> List[int] or None:\n        if isinstance(sol, (list, tuple)):\n            try:\n                b = [1 if int(x) else 0 for x in sol]\n            except Exception:\n                return None\n            return b if len(b) == n else None\n        if isinstance(sol, str) and len(sol) == n and set(sol) <= {'0','1'}:\n            return [1 if c == '1' else 0 for c in sol]\n        return None\n\n    def bits_to_str(b: List[int]) -> str:\n        return ''.join('1' if x else '0' for x in b)\n\n    def totals(b: List[int]):\n        t = 0\n        v = 0\n        for i, bit in enumerate(b):\n            if bit:\n                t += times[i]\n                v += values[i]\n        return t, v\n\n    def repair(b: List[int]) -> List[int]:\n        # Make feasible, then greedily refill by density with slight randomness\n        t, v = totals(b)\n        if t > capacity:\n            while t > capacity:\n                cand = [(values[i] \/ times[i], i) for i in range(n) if b[i] == 1]\n                if not cand:\n                    break\n                jittered = [(d + random.random()*1e-9, i) for d, i in cand]\n                _, idx = min(jittered)\n                b[idx] = 0\n                t -= times[idx]\n                v -= values[idx]\n        zeros = [i for i in range(n) if b[i] == 0]\n        zeros.sort(key=lambda i: (values[i] \/ times[i], random.random()), reverse=True)\n        for i in zeros:\n            if t + times[i] <= capacity:\n                b[i] = 1\n                t += times[i]\n                v += values[i]\n        return b\n\n    b = norm_bits(solution)\n    if b is None:\n        return solution\n\n    # Large-neighborhood shake:\n    # 1) Drop r items with lowest density among selected (r in [2,4])\n    ones = [i for i in range(n) if b[i] == 1]\n    if ones:\n        r = min(len(ones), random.randint(2, 4))\n        ones_sorted = sorted(ones, key=lambda i: (values[i] \/ times[i], random.random()))\n        for i in ones_sorted[:r]:\n            b[i] = 0\n    # 2) Flip up to q random zeros to ones to diversify (q in [2,5])\n    zeros = [i for i in range(n) if b[i] == 0]\n    random.shuffle(zeros)\n    q = min(len(zeros), random.randint(2, 5))\n    for i in zeros[:q]:\n        b[i] = 1\n\n    # 3) Repair to feasibility and greedily refill\n    b = repair(b)\n    return bits_to_str(b)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000289}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated list of selected item indices in ascending order (e.g., \"1,2,5\").","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Parse representation: comma-separated indices\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            chosen = set()\n        else:\n            chosen = set(int(x) for x in s.split(\",\") if x.strip())\n    elif isinstance(solution, (list, set, tuple)):\n        chosen = set(int(x) for x in solution)\n    else:\n        # Unsupported type -> heavy penalty\n        return 10**12\n    # Problem data (1-indexed)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(weights)\n    # Sanitize chosen to valid range\n    chosen = {i for i in chosen if 1 <= i <= n}\n    total_w = 0\n    total_v = 0\n    for i in chosen:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    # Minimization: lesser is better. Enforce weight >= 275 via penalty.\n    capacity = 275\n    if total_w >= capacity:\n        return float(total_v)\n    # Linear penalty scaled to deficit\n    deficit = capacity - total_w\n    return float(10**6 * deficit + total_v)\n","Vecindad":"import random\n\n# Returns: (new_solution_repr, NB_Type, Movement_Type)\n# NB_Type: 'stochastic-local'\n# Movement_Type: 'flip-or-swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(weights)\n    current_set = set(i for i in current if 1 <= i <= n)\n    move_type = random.choice([\"flip\", \"swap\"]) if len(current_set) >= 1 else \"flip\"\n    if move_type == \"flip\":\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    else:  # swap: drop one (if any) and add one not in set\n        if current_set:\n            drop = random.choice(tuple(current_set))\n            current_set.remove(drop)\n        # ensure we add something (may re-add same index)\n        add = random.randint(1, n)\n        current_set.add(add)\n    new_list = sorted(current_set)\n    new_repr = \",\".join(str(x) for x in new_list)\n    return new_repr, \"stochastic-local\", \"flip-or-swap\"\n","Perturbacion":"import random\n\n# Strong perturbation for escaping local minima\n\ndef perturb_solution(solution):\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    n = 24\n    current_set = set(i for i in current if 1 <= i <= n)\n    # Apply k random flips; k sampled from 3..6\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    # Optional bias: if underweight, add random items until near-feasible\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 275\n    # Quick greedy add to push toward feasibility\n    def total_w(S):\n        return sum(weights[i-1] for i in S)\n    if total_w(current_set) < capacity:\n        # sort items not in set by weight descending to reach capacity faster\n        candidates = sorted([i for i in range(1, n+1) if i not in current_set], key=lambda i: weights[i-1], reverse=True)\n        for i in candidates:\n            if total_w(current_set) >= capacity:\n                break\n            current_set.add(i)\n    new_list = sorted(current_set)\n    return \",\".join(str(x) for x in new_list)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0006129369}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated list of selected item indices in ascending order (e.g., \"1,2,5\").","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Parse representation: comma-separated indices\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            chosen = set()\n        else:\n            chosen = set(int(x) for x in s.split(\",\") if x.strip())\n    elif isinstance(solution, (list, set, tuple)):\n        chosen = set(int(x) for x in solution)\n    else:\n        # Unsupported type -> heavy penalty\n        return 10**12\n    # Problem data (1-indexed)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(weights)\n    # Sanitize chosen to valid range\n    chosen = {i for i in chosen if 1 <= i <= n}\n    total_w = 0\n    total_v = 0\n    for i in chosen:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    # Minimization: lesser is better. Enforce weight >= 275 via penalty.\n    capacity = 275\n    if total_w >= capacity:\n        return float(total_v)\n    # Linear penalty scaled to deficit\n    deficit = capacity - total_w\n    return float(10**6 * deficit + total_v)\n","Vecindad":"import random\n\n# Returns: (new_solution_repr, NB_Type, Movement_Type)\n# NB_Type: 'stochastic-local'\n# Movement_Type: 'flip-or-swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(weights)\n    current_set = set(i for i in current if 1 <= i <= n)\n    move_type = random.choice([\"flip\", \"swap\"]) if len(current_set) >= 1 else \"flip\"\n    if move_type == \"flip\":\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    else:  # swap: drop one (if any) and add one not in set\n        if current_set:\n            drop = random.choice(tuple(current_set))\n            current_set.remove(drop)\n        # ensure we add something (may re-add same index)\n        add = random.randint(1, n)\n        current_set.add(add)\n    new_list = sorted(current_set)\n    new_repr = \",\".join(str(x) for x in new_list)\n    return new_repr, \"stochastic-local\", \"flip-or-swap\"\n","Perturbacion":"import random\n\n# Strong perturbation for escaping local minima\n\ndef perturb_solution(solution):\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    n = 24\n    current_set = set(i for i in current if 1 <= i <= n)\n    # Apply k random flips; k sampled from 3..6\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    # Optional bias: if underweight, add random items until near-feasible\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 275\n    # Quick greedy add to push toward feasibility\n    def total_w(S):\n        return sum(weights[i-1] for i in S)\n    if total_w(current_set) < capacity:\n        # sort items not in set by weight descending to reach capacity faster\n        candidates = sorted([i for i in range(1, n+1) if i not in current_set], key=lambda i: weights[i-1], reverse=True)\n        for i in candidates:\n            if total_w(current_set) >= capacity:\n                break\n            current_set.add(i)\n    new_list = sorted(current_set)\n    return \",\".join(str(x) for x in new_list)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.000744859}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated list of selected item indices in ascending order (e.g., \"1,2,5\").","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Parse representation: comma-separated indices\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            chosen = set()\n        else:\n            chosen = set(int(x) for x in s.split(\",\") if x.strip())\n    elif isinstance(solution, (list, set, tuple)):\n        chosen = set(int(x) for x in solution)\n    else:\n        # Unsupported type -> heavy penalty\n        return 10**12\n    # Problem data (1-indexed)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(weights)\n    # Sanitize chosen to valid range\n    chosen = {i for i in chosen if 1 <= i <= n}\n    total_w = 0\n    total_v = 0\n    for i in chosen:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    # Minimization: lesser is better. Enforce weight >= 275 via penalty.\n    capacity = 275\n    if total_w >= capacity:\n        return float(total_v)\n    # Linear penalty scaled to deficit\n    deficit = capacity - total_w\n    return float(10**6 * deficit + total_v)\n","Vecindad":"import random\n\n# Returns: (new_solution_repr, NB_Type, Movement_Type)\n# NB_Type: 'stochastic-local'\n# Movement_Type: 'flip-or-swap'\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(weights)\n    current_set = set(i for i in current if 1 <= i <= n)\n    move_type = random.choice([\"flip\", \"swap\"]) if len(current_set) >= 1 else \"flip\"\n    if move_type == \"flip\":\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    else:  # swap: drop one (if any) and add one not in set\n        if current_set:\n            drop = random.choice(tuple(current_set))\n            current_set.remove(drop)\n        # ensure we add something (may re-add same index)\n        add = random.randint(1, n)\n        current_set.add(add)\n    new_list = sorted(current_set)\n    new_repr = \",\".join(str(x) for x in new_list)\n    return new_repr, \"stochastic-local\", \"flip-or-swap\"\n","Perturbacion":"import random\n\n# Strong perturbation for escaping local minima\n\ndef perturb_solution(solution):\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    n = 24\n    current_set = set(i for i in current if 1 <= i <= n)\n    # Apply k random flips; k sampled from 3..6\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in current_set:\n            current_set.remove(idx)\n        else:\n            current_set.add(idx)\n    # Optional bias: if underweight, add random items until near-feasible\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    capacity = 275\n    # Quick greedy add to push toward feasibility\n    def total_w(S):\n        return sum(weights[i-1] for i in S)\n    if total_w(current_set) < capacity:\n        # sort items not in set by weight descending to reach capacity faster\n        candidates = sorted([i for i in range(1, n+1) if i not in current_set], key=lambda i: weights[i-1], reverse=True)\n        for i in candidates:\n            if total_w(current_set) >= capacity:\n                break\n            current_set.add(i)\n    new_list = sorted(current_set)\n    return \",\".join(str(x) for x in new_list)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0007383489}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Parse representation into a canonical sorted unique list of valid indices\n    if isinstance(solution, str):\n        s = solution.strip()\n        chosen = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        chosen = [int(x) for x in solution]\n    else:\n        return float(10**12)\n    # Problem data (embedded, 1-indexed externally)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(weights)\n    # Sanitize and canonicalize\n    chosen = sorted({i for i in chosen if 1 <= i <= n})\n    total_w = 0\n    total_v = 0\n    for i in chosen:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    capacity = 275\n    if total_w >= capacity:\n        return float(total_v)\n    # Adaptive penalty: quadratic on deficit to better separate near-feasible states\n    deficit = capacity - total_w\n    return float((deficit * deficit) * 1e4 + total_v)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution to a canonical set\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(weights)\n    S = set(i for i in current if 1 <= i <= n)\n    # Lightweight feasibility-aware move selection\n    total_w = sum(weights[i-1] for i in S)\n    capacity = 275\n    move_kind = None\n    if total_w < capacity:\n        # Bias towards adding weight (flip-add or swap-in)\n        if random.random() < 0.7 or len(S) == 0:\n            # flip-add a random index not necessarily outside S\n            idx = random.randint(1, n)\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_kind = \"flip\"\n        else:\n            # swap: drop one (if any) and add a different one\n            if S:\n                drop = random.choice(tuple(S))\n                S.remove(drop)\n            add = random.randint(1, n)\n            # ensure efficacy: avoid immediate re-adding the same element\n            while 'drop' in locals() and add == drop and n > 1:\n                add = random.randint(1, n)\n            S.add(add)\n            move_kind = \"swap\"\n    else:\n        # Already feasible: prefer value reduction via flips\/swaps\n        if random.random() < 0.5 or not S:\n            idx = random.randint(1, n)\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_kind = \"flip\"\n        else:\n            if S:\n                drop = random.choice(tuple(S))\n                S.remove(drop)\n            add = random.randint(1, n)\n            while 'drop' in locals() and add == drop and n > 1:\n                add = random.randint(1, n)\n            S.add(add)\n            move_kind = \"swap\"\n    new_list = sorted(S)\n    new_repr = \",\".join(str(x) for x in new_list)\n    return new_repr, \"stochastic-local\", (\"flip-or-swap\" if move_kind in (\"flip\", \"swap\") else \"flip-or-swap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong multi-flip perturbation with greedy repair toward feasibility\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    n = 24\n    S = set(i for i in current if 1 <= i <= n)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n    # k random flips (3..6)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n        else:\n            S.add(idx)\n    # Greedy repair toward feasibility by adding heavy low-value items first\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n    if total_w(S) < capacity:\n        candidates = [i for i in range(1, n+1) if i not in S]\n        # Sort by (value\/weight asc, weight desc)\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            if total_w(S) >= capacity:\n                break\n            S.add(i)\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000720939}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Parse representation into a canonical sorted unique list of valid indices\n    if isinstance(solution, str):\n        s = solution.strip()\n        chosen = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        chosen = [int(x) for x in solution]\n    else:\n        return float(10**12)\n    # Problem data (embedded, 1-indexed externally)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(weights)\n    # Sanitize and canonicalize\n    chosen = sorted({i for i in chosen if 1 <= i <= n})\n    total_w = 0\n    total_v = 0\n    for i in chosen:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    capacity = 275\n    if total_w >= capacity:\n        return float(total_v)\n    # Adaptive penalty: quadratic on deficit to better separate near-feasible states\n    deficit = capacity - total_w\n    return float((deficit * deficit) * 1e4 + total_v)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution to a canonical set\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(weights)\n    S = set(i for i in current if 1 <= i <= n)\n    # Lightweight feasibility-aware move selection\n    total_w = sum(weights[i-1] for i in S)\n    capacity = 275\n    move_kind = None\n    if total_w < capacity:\n        # Bias towards adding weight (flip-add or swap-in)\n        if random.random() < 0.7 or len(S) == 0:\n            # flip-add a random index not necessarily outside S\n            idx = random.randint(1, n)\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_kind = \"flip\"\n        else:\n            # swap: drop one (if any) and add a different one\n            if S:\n                drop = random.choice(tuple(S))\n                S.remove(drop)\n            add = random.randint(1, n)\n            # ensure efficacy: avoid immediate re-adding the same element\n            while 'drop' in locals() and add == drop and n > 1:\n                add = random.randint(1, n)\n            S.add(add)\n            move_kind = \"swap\"\n    else:\n        # Already feasible: prefer value reduction via flips\/swaps\n        if random.random() < 0.5 or not S:\n            idx = random.randint(1, n)\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_kind = \"flip\"\n        else:\n            if S:\n                drop = random.choice(tuple(S))\n                S.remove(drop)\n            add = random.randint(1, n)\n            while 'drop' in locals() and add == drop and n > 1:\n                add = random.randint(1, n)\n            S.add(add)\n            move_kind = \"swap\"\n    new_list = sorted(S)\n    new_repr = \",\".join(str(x) for x in new_list)\n    return new_repr, \"stochastic-local\", (\"flip-or-swap\" if move_kind in (\"flip\", \"swap\") else \"flip-or-swap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong multi-flip perturbation with greedy repair toward feasibility\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    n = 24\n    S = set(i for i in current if 1 <= i <= n)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n    # k random flips (3..6)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n        else:\n            S.add(idx)\n    # Greedy repair toward feasibility by adding heavy low-value items first\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n    if total_w(S) < capacity:\n        candidates = [i for i in range(1, n+1) if i not in S]\n        # Sort by (value\/weight asc, weight desc)\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            if total_w(S) >= capacity:\n                break\n            S.add(i)\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0008803799}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Parse representation into a canonical sorted unique list of valid indices\n    if isinstance(solution, str):\n        s = solution.strip()\n        chosen = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        chosen = [int(x) for x in solution]\n    else:\n        return float(10**12)\n    # Problem data (embedded, 1-indexed externally)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = len(weights)\n    # Sanitize and canonicalize\n    chosen = sorted({i for i in chosen if 1 <= i <= n})\n    total_w = 0\n    total_v = 0\n    for i in chosen:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    capacity = 275\n    if total_w >= capacity:\n        return float(total_v)\n    # Adaptive penalty: quadratic on deficit to better separate near-feasible states\n    deficit = capacity - total_w\n    return float((deficit * deficit) * 1e4 + total_v)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution to a canonical set\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    n = len(weights)\n    S = set(i for i in current if 1 <= i <= n)\n    # Lightweight feasibility-aware move selection\n    total_w = sum(weights[i-1] for i in S)\n    capacity = 275\n    move_kind = None\n    if total_w < capacity:\n        # Bias towards adding weight (flip-add or swap-in)\n        if random.random() < 0.7 or len(S) == 0:\n            # flip-add a random index not necessarily outside S\n            idx = random.randint(1, n)\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_kind = \"flip\"\n        else:\n            # swap: drop one (if any) and add a different one\n            if S:\n                drop = random.choice(tuple(S))\n                S.remove(drop)\n            add = random.randint(1, n)\n            # ensure efficacy: avoid immediate re-adding the same element\n            while 'drop' in locals() and add == drop and n > 1:\n                add = random.randint(1, n)\n            S.add(add)\n            move_kind = \"swap\"\n    else:\n        # Already feasible: prefer value reduction via flips\/swaps\n        if random.random() < 0.5 or not S:\n            idx = random.randint(1, n)\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_kind = \"flip\"\n        else:\n            if S:\n                drop = random.choice(tuple(S))\n                S.remove(drop)\n            add = random.randint(1, n)\n            while 'drop' in locals() and add == drop and n > 1:\n                add = random.randint(1, n)\n            S.add(add)\n            move_kind = \"swap\"\n    new_list = sorted(S)\n    new_repr = \",\".join(str(x) for x in new_list)\n    return new_repr, \"stochastic-local\", (\"flip-or-swap\" if move_kind in (\"flip\", \"swap\") else \"flip-or-swap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong multi-flip perturbation with greedy repair toward feasibility\n    if isinstance(solution, str):\n        s = solution.strip()\n        current = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n    elif isinstance(solution, (list, set, tuple)):\n        current = [int(x) for x in solution]\n    else:\n        current = []\n    n = 24\n    S = set(i for i in current if 1 <= i <= n)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n    # k random flips (3..6)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n        else:\n            S.add(idx)\n    # Greedy repair toward feasibility by adding heavy low-value items first\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n    if total_w(S) < capacity:\n        candidates = [i for i in range(1, n+1) if i not in S]\n        # Sort by (value\/weight asc, weight desc)\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            if total_w(S) >= capacity:\n                break\n            S.add(i)\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00086118}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Canonicalize representation -> sorted unique list of valid indices [1..24]\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            return []\n        n = 24\n        S = sorted({i for i in lst if 1 <= i <= n})\n        return S\n    S = parse(solution)\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n    total_w = 0\n    total_v = 0\n    for i in S:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    if total_w >= capacity:\n        return float(total_v)\n    # Quadratic penalty for deficit; tuned to 1e3 to preserve gradient near feasibility\n    deficit = capacity - total_w\n    return float(deficit*deficit*1e3 + total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n    S = parse(solution)\n    # Data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n    total_w = sum(weights[i-1] for i in S)\n\n    move_type = \"flip\"\n    r = random.random()\n    if total_w < capacity:\n        # Underweight: bias add heavy-low-value items\n        if r < 0.85 or not S:\n            # choose candidate minimizing value\/weight, break ties by heavier weight\n            candidates = list(range(1, n+1))\n            candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n            # flip best candidate (add if absent, else remove)\n            idx = candidates[0]\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_type = \"flip-bias-add\"\n        else:\n            # 1-1 swap: drop highest value-density item in S, add lowest density outside\n            if S:\n                drop = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                outside = [i for i in range(1, n+1) if i not in S and i != drop]\n                if outside:\n                    add = min(outside, key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n                    S.remove(drop)\n                    S.add(add)\n                    move_type = \"swap-1-1\"\n            else:\n                # fallback flip\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip-fallback\"\n    else:\n        # Feasible: aim to reduce total value while keeping feasibility\n        if r < 0.6 and S:\n            # Try greedy improving drop(s): drop items that keep weight >= capacity and reduce value\n            # Single drop priority: worst value\/weight first\n            sorted_S = sorted(S, key=lambda i: values[i-1]\/weights[i-1], reverse=True)\n            performed = False\n            cur_w = total_w\n            for i in sorted_S:\n                if cur_w - weights[i-1] >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    performed = True\n                    move_type = \"greedy-drop\"\n                    break\n            if not performed:\n                # 1-1 value-reducing swap: try replacing a high-density item with a lower-value item not in S\n                drop = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                outside = [i for i in range(1, n+1) if i not in S]\n                # prefer heavier or equal weight to retain feasibility more easily\n                outside.sort(key=lambda i: (values[i-1], values[i-1]\/weights[i-1], -weights[i-1]))\n                performed = False\n                for add in outside:\n                    new_w = total_w - weights[drop-1] + weights[add-1]\n                    if new_w >= capacity and values[add-1] <= values[drop-1]:\n                        S.remove(drop)\n                        S.add(add)\n                        move_type = \"swap-1-1-val-reduce\"\n                        performed = True\n                        break\n                if not performed:\n                    # fallback flip\n                    idx = random.randint(1, n)\n                    if idx in S:\n                        S.remove(idx)\n                    else:\n                        S.add(idx)\n                    move_type = \"flip-fallback\"\n        else:\n            # Random flip with slight bias to drop high value-density items\n            if S and random.random() < 0.7:\n                idx = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                S.remove(idx)\n                move_type = \"flip-drop-bias\"\n                # Ensure feasibility by repairing if needed\n                if sum(weights[i-1] for i in S) < capacity:\n                    # Add lowest value-density items until feasible\n                    outside = [i for i in range(1, n+1) if i not in S]\n                    outside.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n                    for add in outside:\n                        S.add(add)\n                        if sum(weights[i-1] for i in S) >= capacity:\n                            break\n                    move_type = \"flip-drop+repair\"\n            else:\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip\"\n\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr, move_type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multi-flip + greedy feasibility repair toward capacity\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n    S = parse(solution)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n    # k biased random flips (toward changing ~20-30% of set)\n    k = random.randint(5, 9)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n        else:\n            S.add(idx)\n    # Greedy feasibility repair: if underweight, add lowest density and heavy items first\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n    if total_w(S) < capacity:\n        candidates = [i for i in range(1, n+1) if i not in S]\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            S.add(i)\n            if total_w(S) >= capacity:\n                break\n    else:\n        # If overweight, attempt value reduction while keeping feasibility\n        # Drop high density items if possible\n        improved = True\n        while improved:\n            improved = False\n            cur_w = total_w(S)\n            for i in sorted(S, key=lambda j: values[j-1]\/weights[j-1], reverse=True):\n                if cur_w - weights[i-1] >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    improved = True\n                    break\n    return \",\".join(str(x) for x in sorted(S))\n","Resultados":["1,3,5,6,7,9,10,11,12,13,15,16,17,18,19,20,21,22,23,24",239.0,[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24],223.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0021611961}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Canonicalize representation -> sorted unique list of valid indices [1..24]\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            return []\n        n = 24\n        S = sorted({i for i in lst if 1 <= i <= n})\n        return S\n    S = parse(solution)\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n    total_w = 0\n    total_v = 0\n    for i in S:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    if total_w >= capacity:\n        return float(total_v)\n    # Quadratic penalty for deficit; tuned to 1e3 to preserve gradient near feasibility\n    deficit = capacity - total_w\n    return float(deficit*deficit*1e3 + total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n    S = parse(solution)\n    # Data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n    total_w = sum(weights[i-1] for i in S)\n\n    move_type = \"flip\"\n    r = random.random()\n    if total_w < capacity:\n        # Underweight: bias add heavy-low-value items\n        if r < 0.85 or not S:\n            # choose candidate minimizing value\/weight, break ties by heavier weight\n            candidates = list(range(1, n+1))\n            candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n            # flip best candidate (add if absent, else remove)\n            idx = candidates[0]\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_type = \"flip-bias-add\"\n        else:\n            # 1-1 swap: drop highest value-density item in S, add lowest density outside\n            if S:\n                drop = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                outside = [i for i in range(1, n+1) if i not in S and i != drop]\n                if outside:\n                    add = min(outside, key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n                    S.remove(drop)\n                    S.add(add)\n                    move_type = \"swap-1-1\"\n            else:\n                # fallback flip\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip-fallback\"\n    else:\n        # Feasible: aim to reduce total value while keeping feasibility\n        if r < 0.6 and S:\n            # Try greedy improving drop(s): drop items that keep weight >= capacity and reduce value\n            # Single drop priority: worst value\/weight first\n            sorted_S = sorted(S, key=lambda i: values[i-1]\/weights[i-1], reverse=True)\n            performed = False\n            cur_w = total_w\n            for i in sorted_S:\n                if cur_w - weights[i-1] >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    performed = True\n                    move_type = \"greedy-drop\"\n                    break\n            if not performed:\n                # 1-1 value-reducing swap: try replacing a high-density item with a lower-value item not in S\n                drop = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                outside = [i for i in range(1, n+1) if i not in S]\n                # prefer heavier or equal weight to retain feasibility more easily\n                outside.sort(key=lambda i: (values[i-1], values[i-1]\/weights[i-1], -weights[i-1]))\n                performed = False\n                for add in outside:\n                    new_w = total_w - weights[drop-1] + weights[add-1]\n                    if new_w >= capacity and values[add-1] <= values[drop-1]:\n                        S.remove(drop)\n                        S.add(add)\n                        move_type = \"swap-1-1-val-reduce\"\n                        performed = True\n                        break\n                if not performed:\n                    # fallback flip\n                    idx = random.randint(1, n)\n                    if idx in S:\n                        S.remove(idx)\n                    else:\n                        S.add(idx)\n                    move_type = \"flip-fallback\"\n        else:\n            # Random flip with slight bias to drop high value-density items\n            if S and random.random() < 0.7:\n                idx = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                S.remove(idx)\n                move_type = \"flip-drop-bias\"\n                # Ensure feasibility by repairing if needed\n                if sum(weights[i-1] for i in S) < capacity:\n                    # Add lowest value-density items until feasible\n                    outside = [i for i in range(1, n+1) if i not in S]\n                    outside.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n                    for add in outside:\n                        S.add(add)\n                        if sum(weights[i-1] for i in S) >= capacity:\n                            break\n                    move_type = \"flip-drop+repair\"\n            else:\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip\"\n\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr, move_type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multi-flip + greedy feasibility repair toward capacity\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n    S = parse(solution)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n    # k biased random flips (toward changing ~20-30% of set)\n    k = random.randint(5, 9)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n        else:\n            S.add(idx)\n    # Greedy feasibility repair: if underweight, add lowest density and heavy items first\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n    if total_w(S) < capacity:\n        candidates = [i for i in range(1, n+1) if i not in S]\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            S.add(i)\n            if total_w(S) >= capacity:\n                break\n    else:\n        # If overweight, attempt value reduction while keeping feasibility\n        # Drop high density items if possible\n        improved = True\n        while improved:\n            improved = False\n            cur_w = total_w(S)\n            for i in sorted(S, key=lambda j: values[j-1]\/weights[j-1], reverse=True):\n                if cur_w - weights[i-1] >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    improved = True\n                    break\n    return \",\".join(str(x) for x in sorted(S))\n","Resultados":["1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24",361210.0,"1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24",223.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.002780293}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Canonicalize representation -> sorted unique list of valid indices [1..24]\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            return []\n        n = 24\n        S = sorted({i for i in lst if 1 <= i <= n})\n        return S\n    S = parse(solution)\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n    total_w = 0\n    total_v = 0\n    for i in S:\n        total_w += weights[i-1]\n        total_v += values[i-1]\n    if total_w >= capacity:\n        return float(total_v)\n    # Quadratic penalty for deficit; tuned to 1e3 to preserve gradient near feasibility\n    deficit = capacity - total_w\n    return float(deficit*deficit*1e3 + total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n    S = parse(solution)\n    # Data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n    total_w = sum(weights[i-1] for i in S)\n\n    move_type = \"flip\"\n    r = random.random()\n    if total_w < capacity:\n        # Underweight: bias add heavy-low-value items\n        if r < 0.85 or not S:\n            # choose candidate minimizing value\/weight, break ties by heavier weight\n            candidates = list(range(1, n+1))\n            candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n            # flip best candidate (add if absent, else remove)\n            idx = candidates[0]\n            if idx in S:\n                S.remove(idx)\n            else:\n                S.add(idx)\n            move_type = \"flip-bias-add\"\n        else:\n            # 1-1 swap: drop highest value-density item in S, add lowest density outside\n            if S:\n                drop = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                outside = [i for i in range(1, n+1) if i not in S and i != drop]\n                if outside:\n                    add = min(outside, key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n                    S.remove(drop)\n                    S.add(add)\n                    move_type = \"swap-1-1\"\n            else:\n                # fallback flip\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip-fallback\"\n    else:\n        # Feasible: aim to reduce total value while keeping feasibility\n        if r < 0.6 and S:\n            # Try greedy improving drop(s): drop items that keep weight >= capacity and reduce value\n            # Single drop priority: worst value\/weight first\n            sorted_S = sorted(S, key=lambda i: values[i-1]\/weights[i-1], reverse=True)\n            performed = False\n            cur_w = total_w\n            for i in sorted_S:\n                if cur_w - weights[i-1] >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    performed = True\n                    move_type = \"greedy-drop\"\n                    break\n            if not performed:\n                # 1-1 value-reducing swap: try replacing a high-density item with a lower-value item not in S\n                drop = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                outside = [i for i in range(1, n+1) if i not in S]\n                # prefer heavier or equal weight to retain feasibility more easily\n                outside.sort(key=lambda i: (values[i-1], values[i-1]\/weights[i-1], -weights[i-1]))\n                performed = False\n                for add in outside:\n                    new_w = total_w - weights[drop-1] + weights[add-1]\n                    if new_w >= capacity and values[add-1] <= values[drop-1]:\n                        S.remove(drop)\n                        S.add(add)\n                        move_type = \"swap-1-1-val-reduce\"\n                        performed = True\n                        break\n                if not performed:\n                    # fallback flip\n                    idx = random.randint(1, n)\n                    if idx in S:\n                        S.remove(idx)\n                    else:\n                        S.add(idx)\n                    move_type = \"flip-fallback\"\n        else:\n            # Random flip with slight bias to drop high value-density items\n            if S and random.random() < 0.7:\n                idx = max(S, key=lambda i: values[i-1]\/weights[i-1])\n                S.remove(idx)\n                move_type = \"flip-drop-bias\"\n                # Ensure feasibility by repairing if needed\n                if sum(weights[i-1] for i in S) < capacity:\n                    # Add lowest value-density items until feasible\n                    outside = [i for i in range(1, n+1) if i not in S]\n                    outside.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n                    for add in outside:\n                        S.add(add)\n                        if sum(weights[i-1] for i in S) >= capacity:\n                            break\n                    move_type = \"flip-drop+repair\"\n            else:\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip\"\n\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr, move_type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: multi-flip + greedy feasibility repair toward capacity\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n    S = parse(solution)\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n    # k biased random flips (toward changing ~20-30% of set)\n    k = random.randint(5, 9)\n    for _ in range(k):\n        idx = random.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n        else:\n            S.add(idx)\n    # Greedy feasibility repair: if underweight, add lowest density and heavy items first\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n    if total_w(S) < capacity:\n        candidates = [i for i in range(1, n+1) if i not in S]\n        candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], -weights[i-1]))\n        for i in candidates:\n            S.add(i)\n            if total_w(S) >= capacity:\n                break\n    else:\n        # If overweight, attempt value reduction while keeping feasibility\n        # Drop high density items if possible\n        improved = True\n        while improved:\n            improved = False\n            cur_w = total_w(S)\n            for i in sorted(S, key=lambda j: values[j-1]\/weights[j-1], reverse=True):\n                if cur_w - weights[i-1] >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    improved = True\n                    break\n    return \",\".join(str(x) for x in sorted(S))\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001373046}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    # Parse to canonical sorted unique list of indices in [1..24]\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        S = sorted({i for i in lst if 1 <= i <= n})\n        return S\n\n    S = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n\n    total_w = 0\n    total_v = 0\n    for i in S:\n        wi = weights[i-1]\n        vi = values[i-1]\n        total_w += wi\n        total_v += vi\n\n    if total_w >= capacity:\n        return float(total_v)\n\n    deficit = capacity - total_w\n    # Quadratic penalty to strongly discourage infeasibility\n    return float(deficit * deficit * 1_000 + total_v)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust parse to a set of indices\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n\n    S = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n\n    # Precompute helpers\n    def total_w_of(T):\n        return sum(weights[i-1] for i in T)\n\n    total_w = total_w_of(S)\n\n    # Density and tie-breaking utilities\n    def density(i):\n        return values[i-1] \/ weights[i-1]\n\n    # Randomness with mild diversity: sample from top-m candidates\n    r = random.random()\n    move_type = \"flip\"\n\n    if total_w < capacity:\n        # Underweight: bias to add low density and heavy items\n        # Build ordered candidate list by (density asc, value asc, weight desc)\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n        # choose from top-m to diversify\n        m = min(6, n)\n        pool = candidates[:m]\n        # Prefer items not in S\n        outside_pool = [i for i in pool if i not in S]\n        if outside_pool:\n            idx = random.choice(outside_pool)\n            S.add(idx)\n            move_type = \"add-low-density\"\n        else:\n            # fallback: swap out highest density in S with low density outside\n            if S:\n                drop = max(S, key=density)\n                outside = [i for i in range(1, n+1) if i not in S]\n                if outside:\n                    add = min(outside, key=lambda i: (density(i), values[i-1], -weights[i-1]))\n                    S.remove(drop)\n                    S.add(add)\n                    move_type = \"swap-1-1-underweight\"\n            else:\n                # random flip as last resort\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip-fallback\"\n    else:\n        # Feasible: try to reduce total value while keeping feasibility\n        # Multi-drop greedy: attempt to drop up to k items of highest density while staying feasible\n        k = 2  # small multi-drop to escape plateaus\n        sorted_S = sorted(S, key=density, reverse=True)\n        cur_w = total_w\n        drops = []\n        for i in sorted_S:\n            if len(drops) >= k:\n                break\n            if cur_w - weights[i-1] >= capacity:\n                drops.append(i)\n                cur_w -= weights[i-1]\n        if drops:\n            for i in drops:\n                S.remove(i)\n            move_type = \"multi-drop-greedy\"\n        else:\n            # 1-1 or 1-2 swap to reduce value and keep feasibility\n            performed = False\n            if S:\n                # 1-1 swap\n                drop = max(S, key=density)\n                outside = [i for i in range(1, n+1) if i not in S]\n                outside.sort(key=lambda i: (values[i-1], density(i), -weights[i-1]))\n                for add in outside:\n                    new_w = total_w - weights[drop-1] + weights[add-1]\n                    if new_w >= capacity and values[add-1] <= values[drop-1]:\n                        S.remove(drop)\n                        S.add(add)\n                        performed = True\n                        move_type = \"swap-1-1-val-reduce\"\n                        break\n            if not performed:\n                # 1-2 swap: replace one item with two lower-value items\n                if S:\n                    drop = max(S, key=density)\n                    outside = [i for i in range(1, n+1) if i not in S]\n                    # Try combinations among top-8 low-value outside\n                    outside.sort(key=lambda i: (values[i-1], density(i), -weights[i-1]))\n                    cand = outside[:8]\n                    best_pair = None\n                    best_pair_val = math.inf\n                    for a_idx in range(len(cand)):\n                        for b_idx in range(a_idx+1, len(cand)):\n                            a = cand[a_idx]; b = cand[b_idx]\n                            new_w = total_w - weights[drop-1] + weights[a-1] + weights[b-1]\n                            new_v = values[a-1] + values[b-1]\n                            if new_w >= capacity and new_v <= values[drop-1]:\n                                if new_v < best_pair_val:\n                                    best_pair_val = new_v\n                                    best_pair = (a, b)\n                    if best_pair is not None:\n                        S.remove(drop)\n                        S.add(best_pair[0])\n                        S.add(best_pair[1])\n                        performed = True\n                        move_type = \"swap-1-2-val-reduce\"\n            if not performed:\n                # As last resort, drop the highest density item then repair to feasibility with low-density adds\n                if S:\n                    idx = max(S, key=density)\n                    S.remove(idx)\n                    move_type = \"drop-high-density+repair\"\n                    # Repair\n                    cur_w = total_w_of(S)\n                    if cur_w < capacity:\n                        outside = [i for i in range(1, n+1) if i not in S]\n                        outside.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n                        for add in outside:\n                            S.add(add)\n                            cur_w += weights[add-1]\n                            if cur_w >= capacity:\n                                break\n                else:\n                    # fallback flip\n                    idx = random.randint(1, n)\n                    if idx in S:\n                        S.remove(idx)\n                    else:\n                        S.add(idx)\n                    move_type = \"flip-fallback\"\n\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr, move_type\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n            seed_base = sum((ord(c) * (i + 1)) for i, c in enumerate(s))\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n            seed_base = sum((int(x) * (i + 3)) for i, x in enumerate(lst))\n        else:\n            lst = []\n            seed_base = 1234567\n        n = 24\n        return set(i for i in lst if 1 <= i <= n), seed_base\n\n    S, seed_base = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n\n    rng = random.Random(0x9E3779B97F4A7C15 ^ seed_base)\n\n    def density(i):\n        return values[i-1] \/ weights[i-1]\n\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n\n    # Shake: drop k highest-density items that preserve feasibility when possible; otherwise random flips\n    k = 5\n    cur_w = total_w(S)\n    # Try structured drops first\n    sorted_S = sorted(list(S), key=density, reverse=True)\n    drops_done = 0\n    for i in sorted_S:\n        if drops_done >= k:\n            break\n        if (cur_w - weights[i-1]) >= capacity:\n            S.remove(i)\n            cur_w -= weights[i-1]\n            drops_done += 1\n    # If not enough change, perform additional random flips (up to k)\n    flips = k - drops_done\n    for _ in range(flips):\n        idx = rng.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n            cur_w -= weights[idx-1]\n        else:\n            S.add(idx)\n            cur_w += weights[idx-1]\n\n    # Repair: if underweight, add lowest-density (and low value) items until feasible\n    if cur_w < capacity:\n        outside = [i for i in range(1, n+1) if i not in S]\n        outside.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n        for i in outside:\n            S.add(i)\n            cur_w += weights[i-1]\n            if cur_w >= capacity:\n                break\n    else:\n        # Value-reduction clean-up: drop any high-density items while preserving feasibility\n        improved = True\n        while improved:\n            improved = False\n            for i in sorted(list(S), key=density, reverse=True):\n                if (cur_w - weights[i-1]) >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    improved = True\n                    break\n\n    return \",\".join(str(x) for x in sorted(S))\n","Resultados":["1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24",223.0,[1,2,3,5,6,7,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24],223.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0026152669}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    # Parse to canonical sorted unique list of indices in [1..24]\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        S = sorted({i for i in lst if 1 <= i <= n})\n        return S\n\n    S = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n\n    total_w = 0\n    total_v = 0\n    for i in S:\n        wi = weights[i-1]\n        vi = values[i-1]\n        total_w += wi\n        total_v += vi\n\n    if total_w >= capacity:\n        return float(total_v)\n\n    deficit = capacity - total_w\n    # Quadratic penalty to strongly discourage infeasibility\n    return float(deficit * deficit * 1_000 + total_v)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust parse to a set of indices\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n\n    S = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n\n    # Precompute helpers\n    def total_w_of(T):\n        return sum(weights[i-1] for i in T)\n\n    total_w = total_w_of(S)\n\n    # Density and tie-breaking utilities\n    def density(i):\n        return values[i-1] \/ weights[i-1]\n\n    # Randomness with mild diversity: sample from top-m candidates\n    r = random.random()\n    move_type = \"flip\"\n\n    if total_w < capacity:\n        # Underweight: bias to add low density and heavy items\n        # Build ordered candidate list by (density asc, value asc, weight desc)\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n        # choose from top-m to diversify\n        m = min(6, n)\n        pool = candidates[:m]\n        # Prefer items not in S\n        outside_pool = [i for i in pool if i not in S]\n        if outside_pool:\n            idx = random.choice(outside_pool)\n            S.add(idx)\n            move_type = \"add-low-density\"\n        else:\n            # fallback: swap out highest density in S with low density outside\n            if S:\n                drop = max(S, key=density)\n                outside = [i for i in range(1, n+1) if i not in S]\n                if outside:\n                    add = min(outside, key=lambda i: (density(i), values[i-1], -weights[i-1]))\n                    S.remove(drop)\n                    S.add(add)\n                    move_type = \"swap-1-1-underweight\"\n            else:\n                # random flip as last resort\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip-fallback\"\n    else:\n        # Feasible: try to reduce total value while keeping feasibility\n        # Multi-drop greedy: attempt to drop up to k items of highest density while staying feasible\n        k = 2  # small multi-drop to escape plateaus\n        sorted_S = sorted(S, key=density, reverse=True)\n        cur_w = total_w\n        drops = []\n        for i in sorted_S:\n            if len(drops) >= k:\n                break\n            if cur_w - weights[i-1] >= capacity:\n                drops.append(i)\n                cur_w -= weights[i-1]\n        if drops:\n            for i in drops:\n                S.remove(i)\n            move_type = \"multi-drop-greedy\"\n        else:\n            # 1-1 or 1-2 swap to reduce value and keep feasibility\n            performed = False\n            if S:\n                # 1-1 swap\n                drop = max(S, key=density)\n                outside = [i for i in range(1, n+1) if i not in S]\n                outside.sort(key=lambda i: (values[i-1], density(i), -weights[i-1]))\n                for add in outside:\n                    new_w = total_w - weights[drop-1] + weights[add-1]\n                    if new_w >= capacity and values[add-1] <= values[drop-1]:\n                        S.remove(drop)\n                        S.add(add)\n                        performed = True\n                        move_type = \"swap-1-1-val-reduce\"\n                        break\n            if not performed:\n                # 1-2 swap: replace one item with two lower-value items\n                if S:\n                    drop = max(S, key=density)\n                    outside = [i for i in range(1, n+1) if i not in S]\n                    # Try combinations among top-8 low-value outside\n                    outside.sort(key=lambda i: (values[i-1], density(i), -weights[i-1]))\n                    cand = outside[:8]\n                    best_pair = None\n                    best_pair_val = math.inf\n                    for a_idx in range(len(cand)):\n                        for b_idx in range(a_idx+1, len(cand)):\n                            a = cand[a_idx]; b = cand[b_idx]\n                            new_w = total_w - weights[drop-1] + weights[a-1] + weights[b-1]\n                            new_v = values[a-1] + values[b-1]\n                            if new_w >= capacity and new_v <= values[drop-1]:\n                                if new_v < best_pair_val:\n                                    best_pair_val = new_v\n                                    best_pair = (a, b)\n                    if best_pair is not None:\n                        S.remove(drop)\n                        S.add(best_pair[0])\n                        S.add(best_pair[1])\n                        performed = True\n                        move_type = \"swap-1-2-val-reduce\"\n            if not performed:\n                # As last resort, drop the highest density item then repair to feasibility with low-density adds\n                if S:\n                    idx = max(S, key=density)\n                    S.remove(idx)\n                    move_type = \"drop-high-density+repair\"\n                    # Repair\n                    cur_w = total_w_of(S)\n                    if cur_w < capacity:\n                        outside = [i for i in range(1, n+1) if i not in S]\n                        outside.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n                        for add in outside:\n                            S.add(add)\n                            cur_w += weights[add-1]\n                            if cur_w >= capacity:\n                                break\n                else:\n                    # fallback flip\n                    idx = random.randint(1, n)\n                    if idx in S:\n                        S.remove(idx)\n                    else:\n                        S.add(idx)\n                    move_type = \"flip-fallback\"\n\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr, move_type\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n            seed_base = sum((ord(c) * (i + 1)) for i, c in enumerate(s))\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n            seed_base = sum((int(x) * (i + 3)) for i, x in enumerate(lst))\n        else:\n            lst = []\n            seed_base = 1234567\n        n = 24\n        return set(i for i in lst if 1 <= i <= n), seed_base\n\n    S, seed_base = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n\n    rng = random.Random(0x9E3779B97F4A7C15 ^ seed_base)\n\n    def density(i):\n        return values[i-1] \/ weights[i-1]\n\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n\n    # Shake: drop k highest-density items that preserve feasibility when possible; otherwise random flips\n    k = 5\n    cur_w = total_w(S)\n    # Try structured drops first\n    sorted_S = sorted(list(S), key=density, reverse=True)\n    drops_done = 0\n    for i in sorted_S:\n        if drops_done >= k:\n            break\n        if (cur_w - weights[i-1]) >= capacity:\n            S.remove(i)\n            cur_w -= weights[i-1]\n            drops_done += 1\n    # If not enough change, perform additional random flips (up to k)\n    flips = k - drops_done\n    for _ in range(flips):\n        idx = rng.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n            cur_w -= weights[idx-1]\n        else:\n            S.add(idx)\n            cur_w += weights[idx-1]\n\n    # Repair: if underweight, add lowest-density (and low value) items until feasible\n    if cur_w < capacity:\n        outside = [i for i in range(1, n+1) if i not in S]\n        outside.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n        for i in outside:\n            S.add(i)\n            cur_w += weights[i-1]\n            if cur_w >= capacity:\n                break\n    else:\n        # Value-reduction clean-up: drop any high-density items while preserving feasibility\n        improved = True\n        while improved:\n            improved = False\n            for i in sorted(list(S), key=density, reverse=True):\n                if (cur_w - weights[i-1]) >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    improved = True\n                    break\n\n    return \",\".join(str(x) for x in sorted(S))\n","Resultados":["1,3,5,6,7,9,10,11,12,13,15,16,17,18,19,20,21,22,23,24",239.0,"1,3,5,6,7,9,10,11,12,13,15,16,17,18,19,20,21,22,23,24",234.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0034512159}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"comma-separated ascending list of unique item indices (e.g., \"1,2,5\"). Empty set is \"\".","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    # Parse to canonical sorted unique list of indices in [1..24]\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        S = sorted({i for i in lst if 1 <= i <= n})\n        return S\n\n    S = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 275\n\n    total_w = 0\n    total_v = 0\n    for i in S:\n        wi = weights[i-1]\n        vi = values[i-1]\n        total_w += wi\n        total_v += vi\n\n    if total_w >= capacity:\n        return float(total_v)\n\n    deficit = capacity - total_w\n    # Quadratic penalty to strongly discourage infeasibility\n    return float(deficit * deficit * 1_000 + total_v)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust parse to a set of indices\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n        else:\n            lst = []\n        n = 24\n        return set(i for i in lst if 1 <= i <= n)\n\n    S = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n\n    # Precompute helpers\n    def total_w_of(T):\n        return sum(weights[i-1] for i in T)\n\n    total_w = total_w_of(S)\n\n    # Density and tie-breaking utilities\n    def density(i):\n        return values[i-1] \/ weights[i-1]\n\n    # Randomness with mild diversity: sample from top-m candidates\n    r = random.random()\n    move_type = \"flip\"\n\n    if total_w < capacity:\n        # Underweight: bias to add low density and heavy items\n        # Build ordered candidate list by (density asc, value asc, weight desc)\n        candidates = list(range(1, n+1))\n        candidates.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n        # choose from top-m to diversify\n        m = min(6, n)\n        pool = candidates[:m]\n        # Prefer items not in S\n        outside_pool = [i for i in pool if i not in S]\n        if outside_pool:\n            idx = random.choice(outside_pool)\n            S.add(idx)\n            move_type = \"add-low-density\"\n        else:\n            # fallback: swap out highest density in S with low density outside\n            if S:\n                drop = max(S, key=density)\n                outside = [i for i in range(1, n+1) if i not in S]\n                if outside:\n                    add = min(outside, key=lambda i: (density(i), values[i-1], -weights[i-1]))\n                    S.remove(drop)\n                    S.add(add)\n                    move_type = \"swap-1-1-underweight\"\n            else:\n                # random flip as last resort\n                idx = random.randint(1, n)\n                if idx in S:\n                    S.remove(idx)\n                else:\n                    S.add(idx)\n                move_type = \"flip-fallback\"\n    else:\n        # Feasible: try to reduce total value while keeping feasibility\n        # Multi-drop greedy: attempt to drop up to k items of highest density while staying feasible\n        k = 2  # small multi-drop to escape plateaus\n        sorted_S = sorted(S, key=density, reverse=True)\n        cur_w = total_w\n        drops = []\n        for i in sorted_S:\n            if len(drops) >= k:\n                break\n            if cur_w - weights[i-1] >= capacity:\n                drops.append(i)\n                cur_w -= weights[i-1]\n        if drops:\n            for i in drops:\n                S.remove(i)\n            move_type = \"multi-drop-greedy\"\n        else:\n            # 1-1 or 1-2 swap to reduce value and keep feasibility\n            performed = False\n            if S:\n                # 1-1 swap\n                drop = max(S, key=density)\n                outside = [i for i in range(1, n+1) if i not in S]\n                outside.sort(key=lambda i: (values[i-1], density(i), -weights[i-1]))\n                for add in outside:\n                    new_w = total_w - weights[drop-1] + weights[add-1]\n                    if new_w >= capacity and values[add-1] <= values[drop-1]:\n                        S.remove(drop)\n                        S.add(add)\n                        performed = True\n                        move_type = \"swap-1-1-val-reduce\"\n                        break\n            if not performed:\n                # 1-2 swap: replace one item with two lower-value items\n                if S:\n                    drop = max(S, key=density)\n                    outside = [i for i in range(1, n+1) if i not in S]\n                    # Try combinations among top-8 low-value outside\n                    outside.sort(key=lambda i: (values[i-1], density(i), -weights[i-1]))\n                    cand = outside[:8]\n                    best_pair = None\n                    best_pair_val = math.inf\n                    for a_idx in range(len(cand)):\n                        for b_idx in range(a_idx+1, len(cand)):\n                            a = cand[a_idx]; b = cand[b_idx]\n                            new_w = total_w - weights[drop-1] + weights[a-1] + weights[b-1]\n                            new_v = values[a-1] + values[b-1]\n                            if new_w >= capacity and new_v <= values[drop-1]:\n                                if new_v < best_pair_val:\n                                    best_pair_val = new_v\n                                    best_pair = (a, b)\n                    if best_pair is not None:\n                        S.remove(drop)\n                        S.add(best_pair[0])\n                        S.add(best_pair[1])\n                        performed = True\n                        move_type = \"swap-1-2-val-reduce\"\n            if not performed:\n                # As last resort, drop the highest density item then repair to feasibility with low-density adds\n                if S:\n                    idx = max(S, key=density)\n                    S.remove(idx)\n                    move_type = \"drop-high-density+repair\"\n                    # Repair\n                    cur_w = total_w_of(S)\n                    if cur_w < capacity:\n                        outside = [i for i in range(1, n+1) if i not in S]\n                        outside.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n                        for add in outside:\n                            S.add(add)\n                            cur_w += weights[add-1]\n                            if cur_w >= capacity:\n                                break\n                else:\n                    # fallback flip\n                    idx = random.randint(1, n)\n                    if idx in S:\n                        S.remove(idx)\n                    else:\n                        S.add(idx)\n                    move_type = \"flip-fallback\"\n\n    new_repr = \",\".join(str(x) for x in sorted(S))\n    return new_repr, move_type\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed\n    def parse(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            lst = [] if s == \"\" else [int(x) for x in s.split(\",\") if x.strip()]\n            seed_base = sum((ord(c) * (i + 1)) for i, c in enumerate(s))\n        elif isinstance(sol, (list, set, tuple)):\n            lst = [int(x) for x in sol]\n            seed_base = sum((int(x) * (i + 3)) for i, x in enumerate(lst))\n        else:\n            lst = []\n            seed_base = 1234567\n        n = 24\n        return set(i for i in lst if 1 <= i <= n), seed_base\n\n    S, seed_base = parse(solution)\n\n    # Embedded problem data\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    capacity = 275\n\n    rng = random.Random(0x9E3779B97F4A7C15 ^ seed_base)\n\n    def density(i):\n        return values[i-1] \/ weights[i-1]\n\n    def total_w(T):\n        return sum(weights[i-1] for i in T)\n\n    # Shake: drop k highest-density items that preserve feasibility when possible; otherwise random flips\n    k = 5\n    cur_w = total_w(S)\n    # Try structured drops first\n    sorted_S = sorted(list(S), key=density, reverse=True)\n    drops_done = 0\n    for i in sorted_S:\n        if drops_done >= k:\n            break\n        if (cur_w - weights[i-1]) >= capacity:\n            S.remove(i)\n            cur_w -= weights[i-1]\n            drops_done += 1\n    # If not enough change, perform additional random flips (up to k)\n    flips = k - drops_done\n    for _ in range(flips):\n        idx = rng.randint(1, n)\n        if idx in S:\n            S.remove(idx)\n            cur_w -= weights[idx-1]\n        else:\n            S.add(idx)\n            cur_w += weights[idx-1]\n\n    # Repair: if underweight, add lowest-density (and low value) items until feasible\n    if cur_w < capacity:\n        outside = [i for i in range(1, n+1) if i not in S]\n        outside.sort(key=lambda i: (density(i), values[i-1], -weights[i-1]))\n        for i in outside:\n            S.add(i)\n            cur_w += weights[i-1]\n            if cur_w >= capacity:\n                break\n    else:\n        # Value-reduction clean-up: drop any high-density items while preserving feasibility\n        improved = True\n        while improved:\n            improved = False\n            for i in sorted(list(S), key=density, reverse=True):\n                if (cur_w - weights[i-1]) >= capacity:\n                    S.remove(i)\n                    cur_w -= weights[i-1]\n                    improved = True\n                    break\n\n    return \",\".join(str(x) for x in sorted(S))\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0015462569}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24 \/\/ 24-bit binary string; bit i=1 means take Decoration (i+1), else 0.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (costs, points) in order 1..24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        return float('inf')\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        return float(total_points)\n    # Penalize infeasible (minimization): strong convex penalty on shortfall\n    shortfall = target_cost - total_cost\n    return float(1e6 + 1000*shortfall + total_points)\n","Vecindad":"import random\n\nrandom.seed()\n\ndef _flip_bits(sol: str, idxs):\n    s = list(sol)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    return ''.join(s)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    if not isinstance(solution, str) or len(solution) != 24:\n        # generate a random valid solution if input invalid\n        base = ''.join(random.choice('01') for _ in range(24))\n        return base, \"init_random\"\n    n = 24\n    # choose 1-3 distinct indices to flip\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    neighbour = _flip_bits(solution, idxs)\n    return neighbour, f\"bitflip_{k}\"\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Strong perturbation: flip ~20%-40% of bits, then enforce at least one '1'\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n:\n        solution = ''.join(random.choice('01') for _ in range(n))\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    s = list(solution)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    # ensure not all zeros\n    if all(ch == '0' for ch in s):\n        j = random.randrange(n)\n        s[j] = '1'\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: _flip_bits() missing 1 required positional argument: 'idxs'.  Signature def SA(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), TEMP, MIN_TEMP, cooling_factor)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000490086}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24 \/\/ 24-bit binary string; bit i=1 means take Decoration (i+1), else 0.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (costs, points) in order 1..24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        return float('inf')\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        return float(total_points)\n    # Penalize infeasible (minimization): strong convex penalty on shortfall\n    shortfall = target_cost - total_cost\n    return float(1e6 + 1000*shortfall + total_points)\n","Vecindad":"import random\n\nrandom.seed()\n\ndef _flip_bits(sol: str, idxs):\n    s = list(sol)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    return ''.join(s)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    if not isinstance(solution, str) or len(solution) != 24:\n        # generate a random valid solution if input invalid\n        base = ''.join(random.choice('01') for _ in range(24))\n        return base, \"init_random\"\n    n = 24\n    # choose 1-3 distinct indices to flip\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    neighbour = _flip_bits(solution, idxs)\n    return neighbour, f\"bitflip_{k}\"\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Strong perturbation: flip ~20%-40% of bits, then enforce at least one '1'\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n:\n        solution = ''.join(random.choice('01') for _ in range(n))\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    s = list(solution)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    # ensure not all zeros\n    if all(ch == '0' for ch in s):\n        j = random.randrange(n)\n        s[j] = '1'\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: _flip_bits() missing 1 required positional argument: 'idxs'.  Signature def ILS(solution,best_sol, best_score, generate_neighbour(),perturb_solution(), evaluate_solution(), iterations, aceptance_rate)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.000545235}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24 \/\/ 24-bit binary string; bit i=1 means take Decoration (i+1), else 0.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Embedded problem data (costs, points) in order 1..24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        return float('inf')\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        return float(total_points)\n    # Penalize infeasible (minimization): strong convex penalty on shortfall\n    shortfall = target_cost - total_cost\n    return float(1e6 + 1000*shortfall + total_points)\n","Vecindad":"import random\n\nrandom.seed()\n\ndef _flip_bits(sol: str, idxs):\n    s = list(sol)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    return ''.join(s)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    if not isinstance(solution, str) or len(solution) != 24:\n        # generate a random valid solution if input invalid\n        base = ''.join(random.choice('01') for _ in range(24))\n        return base, \"init_random\"\n    n = 24\n    # choose 1-3 distinct indices to flip\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    neighbour = _flip_bits(solution, idxs)\n    return neighbour, f\"bitflip_{k}\"\n","Perturbacion":"import random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Strong perturbation: flip ~20%-40% of bits, then enforce at least one '1'\n    n = 24\n    if not isinstance(solution, str) or len(solution) != n:\n        solution = ''.join(random.choice('01') for _ in range(n))\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    s = list(solution)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n    # ensure not all zeros\n    if all(ch == '0' for ch in s):\n        j = random.randrange(n)\n        s[j] = '1'\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: _flip_bits() missing 1 required positional argument: 'idxs'.  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.000541456}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data (costs, points) in order 1..24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        # Large finite penalty to keep search stable\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        # Feasible: minimize total_points\n        return float(total_points)\n    # Infeasible: Lagrangian penalty on budget shortfall\n    shortfall = target_cost - total_cost\n    lam = 100.0\n    return float(total_points + lam * shortfall)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i,ch in enumerate(sol) if ch == '1')\n\n    def compute_points(sol: str) -> int:\n        return sum(points[i] for i,ch in enumerate(sol) if ch == '1')\n\n    def flip(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    # Initialize\/repair invalid input with a random valid string\n    if not is_valid(solution):\n        base = ''.join(random.choice('01') for _ in range(n))\n        return base, \"init_random\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n\n    # With probability 0.6, try feasibility-aware move; else random 1-3 bit flips\n    if random.random() < 0.6:\n        s = list(curr)\n        if feasible:\n            # Try to reduce points while keeping feasibility\n            ones = [i for i,ch in enumerate(s) if ch == '1']\n            if ones:\n                # Attempt drop of a single item that preserves feasibility\n                random.shuffle(ones)\n                moved = False\n                for i in ones:\n                    if curr_cost - costs[i] >= target_cost:\n                        s[i] = '0'\n                        moved = True\n                        move = f\"drop_{i}\"\n                        break\n                if not moved and len(ones) >= 1:\n                    # Try (1,1)-swap: drop one high point item, add one low ratio item\n                    zeros = [j for j,ch in enumerate(s) if ch == '0']\n                    if zeros:\n                        # Pick drop candidate biased by high points\n                        drop = max(ones, key=lambda k: points[k])\n                        # Pick add candidate with best cost per point (low ratio); avoid division by zero\n                        def ratio(j):\n                            return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                        add = min(zeros, key=lambda j: ratio(j))\n                        new_cost = curr_cost - costs[drop] + costs[add]\n                        if new_cost >= target_cost:\n                            s[drop] = '0'; s[add] = '1'\n                            move = f\"swap_{drop}_{add}\"\n                        else:\n                            # fallback: random feasible-preserving drop-if-possible else small flip\n                            k = random.randrange(n)\n                            s[k] = '1' if s[k] == '0' else '0'\n                            move = \"fallback_flip\"\n                neighbour = ''.join(s)\n                return neighbour, move if 'move' in locals() else \"feasibility_preserve\"\n        else:\n            # Infeasible: add a low ratio item to increase cost with minimal points\n            zeros = [i for i,ch in enumerate(s) if ch == '0']\n            if zeros:\n                def ratio(j):\n                    return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                add = min(zeros, key=lambda j: ratio(j))\n                s[add] = '1'\n                return ''.join(s), f\"add_{add}\"\n            # Fallback\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Random small perturbation: flip 1-3 bits\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    neighbour = flip(curr, idxs)\n    return neighbour, f\"bitflip_{k}\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i,ch in enumerate(sol) if ch == '1')\n\n    # Start from valid or random solution\n    if not is_valid(solution):\n        solution = ''.join(random.choice('01') for _ in range(n))\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to ensure feasibility: add items with minimal points-per-cost until cost >= target\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    while compute_cost(''.join(s)) < target_cost:\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: ratio(j))\n        s[add] = '1'\n\n    return ''.join(s)\n","Resultados":["101111101111101110111111",233.0,"101111101111101110111111",233.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001617718}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data (costs, points) in order 1..24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        # Large finite penalty to keep search stable\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        # Feasible: minimize total_points\n        return float(total_points)\n    # Infeasible: Lagrangian penalty on budget shortfall\n    shortfall = target_cost - total_cost\n    lam = 100.0\n    return float(total_points + lam * shortfall)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i,ch in enumerate(sol) if ch == '1')\n\n    def compute_points(sol: str) -> int:\n        return sum(points[i] for i,ch in enumerate(sol) if ch == '1')\n\n    def flip(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    # Initialize\/repair invalid input with a random valid string\n    if not is_valid(solution):\n        base = ''.join(random.choice('01') for _ in range(n))\n        return base, \"init_random\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n\n    # With probability 0.6, try feasibility-aware move; else random 1-3 bit flips\n    if random.random() < 0.6:\n        s = list(curr)\n        if feasible:\n            # Try to reduce points while keeping feasibility\n            ones = [i for i,ch in enumerate(s) if ch == '1']\n            if ones:\n                # Attempt drop of a single item that preserves feasibility\n                random.shuffle(ones)\n                moved = False\n                for i in ones:\n                    if curr_cost - costs[i] >= target_cost:\n                        s[i] = '0'\n                        moved = True\n                        move = f\"drop_{i}\"\n                        break\n                if not moved and len(ones) >= 1:\n                    # Try (1,1)-swap: drop one high point item, add one low ratio item\n                    zeros = [j for j,ch in enumerate(s) if ch == '0']\n                    if zeros:\n                        # Pick drop candidate biased by high points\n                        drop = max(ones, key=lambda k: points[k])\n                        # Pick add candidate with best cost per point (low ratio); avoid division by zero\n                        def ratio(j):\n                            return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                        add = min(zeros, key=lambda j: ratio(j))\n                        new_cost = curr_cost - costs[drop] + costs[add]\n                        if new_cost >= target_cost:\n                            s[drop] = '0'; s[add] = '1'\n                            move = f\"swap_{drop}_{add}\"\n                        else:\n                            # fallback: random feasible-preserving drop-if-possible else small flip\n                            k = random.randrange(n)\n                            s[k] = '1' if s[k] == '0' else '0'\n                            move = \"fallback_flip\"\n                neighbour = ''.join(s)\n                return neighbour, move if 'move' in locals() else \"feasibility_preserve\"\n        else:\n            # Infeasible: add a low ratio item to increase cost with minimal points\n            zeros = [i for i,ch in enumerate(s) if ch == '0']\n            if zeros:\n                def ratio(j):\n                    return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                add = min(zeros, key=lambda j: ratio(j))\n                s[add] = '1'\n                return ''.join(s), f\"add_{add}\"\n            # Fallback\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Random small perturbation: flip 1-3 bits\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    neighbour = flip(curr, idxs)\n    return neighbour, f\"bitflip_{k}\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i,ch in enumerate(sol) if ch == '1')\n\n    # Start from valid or random solution\n    if not is_valid(solution):\n        solution = ''.join(random.choice('01') for _ in range(n))\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to ensure feasibility: add items with minimal points-per-cost until cost >= target\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    while compute_cost(''.join(s)) < target_cost:\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: ratio(j))\n        s[add] = '1'\n\n    return ''.join(s)\n","Resultados":["111011101011101111111111",146167.0,"111011101111111110111111",223.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.002663949}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data (costs, points) in order 1..24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        # Large finite penalty to keep search stable\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        # Feasible: minimize total_points\n        return float(total_points)\n    # Infeasible: Lagrangian penalty on budget shortfall\n    shortfall = target_cost - total_cost\n    lam = 100.0\n    return float(total_points + lam * shortfall)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    # Embedded problem data\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i,ch in enumerate(sol) if ch == '1')\n\n    def compute_points(sol: str) -> int:\n        return sum(points[i] for i,ch in enumerate(sol) if ch == '1')\n\n    def flip(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    # Initialize\/repair invalid input with a random valid string\n    if not is_valid(solution):\n        base = ''.join(random.choice('01') for _ in range(n))\n        return base, \"init_random\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n\n    # With probability 0.6, try feasibility-aware move; else random 1-3 bit flips\n    if random.random() < 0.6:\n        s = list(curr)\n        if feasible:\n            # Try to reduce points while keeping feasibility\n            ones = [i for i,ch in enumerate(s) if ch == '1']\n            if ones:\n                # Attempt drop of a single item that preserves feasibility\n                random.shuffle(ones)\n                moved = False\n                for i in ones:\n                    if curr_cost - costs[i] >= target_cost:\n                        s[i] = '0'\n                        moved = True\n                        move = f\"drop_{i}\"\n                        break\n                if not moved and len(ones) >= 1:\n                    # Try (1,1)-swap: drop one high point item, add one low ratio item\n                    zeros = [j for j,ch in enumerate(s) if ch == '0']\n                    if zeros:\n                        # Pick drop candidate biased by high points\n                        drop = max(ones, key=lambda k: points[k])\n                        # Pick add candidate with best cost per point (low ratio); avoid division by zero\n                        def ratio(j):\n                            return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                        add = min(zeros, key=lambda j: ratio(j))\n                        new_cost = curr_cost - costs[drop] + costs[add]\n                        if new_cost >= target_cost:\n                            s[drop] = '0'; s[add] = '1'\n                            move = f\"swap_{drop}_{add}\"\n                        else:\n                            # fallback: random feasible-preserving drop-if-possible else small flip\n                            k = random.randrange(n)\n                            s[k] = '1' if s[k] == '0' else '0'\n                            move = \"fallback_flip\"\n                neighbour = ''.join(s)\n                return neighbour, move if 'move' in locals() else \"feasibility_preserve\"\n        else:\n            # Infeasible: add a low ratio item to increase cost with minimal points\n            zeros = [i for i,ch in enumerate(s) if ch == '0']\n            if zeros:\n                def ratio(j):\n                    return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                add = min(zeros, key=lambda j: ratio(j))\n                s[add] = '1'\n                return ''.join(s), f\"add_{add}\"\n            # Fallback\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Random small perturbation: flip 1-3 bits\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    neighbour = flip(curr, idxs)\n    return neighbour, f\"bitflip_{k}\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i,ch in enumerate(sol) if ch == '1')\n\n    # Start from valid or random solution\n    if not is_valid(solution):\n        solution = ''.join(random.choice('01') for _ in range(n))\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to ensure feasibility: add items with minimal points-per-cost until cost >= target\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    while compute_cost(''.join(s)) < target_cost:\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: ratio(j))\n        s[add] = '1'\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0012484241}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data (1..24)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        return float(total_points)  # minimize points\n    shortfall = target_cost - total_cost\n    lam = 100.0  # penalty per dollar shortfall\n    return float(total_points + lam * shortfall)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def flip_indices(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    # Initialize\/repair invalid input with a greedy feasible seed\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n        return solution, \"init_greedy\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n    s = list(curr)\n\n    # Feasibility-aware moves with 0.65 probability\n    if random.random() < 0.65:\n        if feasible:\n            # Try drop moves that preserve feasibility, biased by high points first\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones.sort(key=lambda i: points[i], reverse=True)\n                for i in ones:\n                    if curr_cost - costs[i] >= target_cost:\n                        s[i] = '0'\n                        return ''.join(s), f\"drop_keep_feasible_{i}\"\n                # Try (1,1)-swap: drop high-point add low-ratio keeping feasibility\n                zeros = [j for j, ch in enumerate(s) if ch == '0']\n                if zeros:\n                    drop = ones[0]\n                    add = min(zeros, key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n                    new_cost = curr_cost - costs[drop] + costs[add]\n                    if new_cost >= target_cost:\n                        s[drop] = '0'; s[add] = '1'\n                        return ''.join(s), f\"swap_{drop}_{add}\"\n            # Fallback small flip\n            k = random.choice([1, 2])\n            idxs = random.sample(range(n), k)\n            return flip_indices(curr, idxs), f\"bitflip_feasible_{k}\"\n        else:\n            # Infeasible: add an item with minimal points-per-cost\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                add = min(zeros, key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n                s[add] = '1'\n                return ''.join(s), f\"add_for_budget_{add}\"\n            # Fallback: force-add random\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Random perturbative flips (1-3 bits)\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    return flip_indices(curr, idxs), f\"bitflip_{k}\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    # Start from a valid solution or a greedy feasible seed\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Greedy repair to enforce feasibility (add low ratio items)\n    def compute_cost(sol_list):\n        return sum(costs[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    while compute_cost(s) < target_cost:\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: ratio(j))\n        s[add] = '1'\n\n    return ''.join(s)\n","Resultados":["101011101111101111111111",234.0,"101011101111101111111111",234.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001502237}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data (1..24)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        return float(total_points)  # minimize points\n    shortfall = target_cost - total_cost\n    lam = 100.0  # penalty per dollar shortfall\n    return float(total_points + lam * shortfall)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def flip_indices(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    # Initialize\/repair invalid input with a greedy feasible seed\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n        return solution, \"init_greedy\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n    s = list(curr)\n\n    # Feasibility-aware moves with 0.65 probability\n    if random.random() < 0.65:\n        if feasible:\n            # Try drop moves that preserve feasibility, biased by high points first\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones.sort(key=lambda i: points[i], reverse=True)\n                for i in ones:\n                    if curr_cost - costs[i] >= target_cost:\n                        s[i] = '0'\n                        return ''.join(s), f\"drop_keep_feasible_{i}\"\n                # Try (1,1)-swap: drop high-point add low-ratio keeping feasibility\n                zeros = [j for j, ch in enumerate(s) if ch == '0']\n                if zeros:\n                    drop = ones[0]\n                    add = min(zeros, key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n                    new_cost = curr_cost - costs[drop] + costs[add]\n                    if new_cost >= target_cost:\n                        s[drop] = '0'; s[add] = '1'\n                        return ''.join(s), f\"swap_{drop}_{add}\"\n            # Fallback small flip\n            k = random.choice([1, 2])\n            idxs = random.sample(range(n), k)\n            return flip_indices(curr, idxs), f\"bitflip_feasible_{k}\"\n        else:\n            # Infeasible: add an item with minimal points-per-cost\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                add = min(zeros, key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n                s[add] = '1'\n                return ''.join(s), f\"add_for_budget_{add}\"\n            # Fallback: force-add random\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Random perturbative flips (1-3 bits)\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    return flip_indices(curr, idxs), f\"bitflip_{k}\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    # Start from a valid solution or a greedy feasible seed\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Greedy repair to enforce feasibility (add low ratio items)\n    def compute_cost(sol_list):\n        return sum(costs[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    while compute_cost(s) < target_cost:\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: ratio(j))\n        s[add] = '1'\n\n    return ''.join(s)\n","Resultados":["101011101111101111111111",239.0,"111011101111111110111111",223.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.002487518}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data (1..24)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != 24 or any(ch not in '01' for ch in solution):\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        return float(total_points)  # minimize points\n    shortfall = target_cost - total_cost\n    lam = 100.0  # penalty per dollar shortfall\n    return float(total_points + lam * shortfall)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def flip_indices(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    # Initialize\/repair invalid input with a greedy feasible seed\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n        return solution, \"init_greedy\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n    s = list(curr)\n\n    # Feasibility-aware moves with 0.65 probability\n    if random.random() < 0.65:\n        if feasible:\n            # Try drop moves that preserve feasibility, biased by high points first\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones.sort(key=lambda i: points[i], reverse=True)\n                for i in ones:\n                    if curr_cost - costs[i] >= target_cost:\n                        s[i] = '0'\n                        return ''.join(s), f\"drop_keep_feasible_{i}\"\n                # Try (1,1)-swap: drop high-point add low-ratio keeping feasibility\n                zeros = [j for j, ch in enumerate(s) if ch == '0']\n                if zeros:\n                    drop = ones[0]\n                    add = min(zeros, key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n                    new_cost = curr_cost - costs[drop] + costs[add]\n                    if new_cost >= target_cost:\n                        s[drop] = '0'; s[add] = '1'\n                        return ''.join(s), f\"swap_{drop}_{add}\"\n            # Fallback small flip\n            k = random.choice([1, 2])\n            idxs = random.sample(range(n), k)\n            return flip_indices(curr, idxs), f\"bitflip_feasible_{k}\"\n        else:\n            # Infeasible: add an item with minimal points-per-cost\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                add = min(zeros, key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n                s[add] = '1'\n                return ''.join(s), f\"add_for_budget_{add}\"\n            # Fallback: force-add random\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Random perturbative flips (1-3 bits)\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    return flip_indices(curr, idxs), f\"bitflip_{k}\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    # Start from a valid solution or a greedy feasible seed\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (points[j]\/costs[j]) if points[j] > 0 else 0.0)\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Greedy repair to enforce feasibility (add low ratio items)\n    def compute_cost(sol_list):\n        return sum(costs[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    while compute_cost(s) < target_cost:\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: ratio(j))\n        s[add] = '1'\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0010110909}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24; index i in [1..24]; bit '1' selects decoration i, '0' skips.","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data (1..24)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    n = 24\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        score = float(total_points)\n        # Validation guards (no raise, but can be used if debugging)\n        # assert score == float(total_points)\n        return score\n    shortfall = target_cost - total_cost\n    lam = 100.0  # penalty per dollar shortfall\n    score = float(total_points + lam * shortfall)\n    # assert score >= float(total_points + lam * shortfall)\n    return score\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def compute_points(sol: str) -> int:\n        return sum(points[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def flip_indices(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    def greedy_feasible_seed():\n        # Add by increasing points-per-cost (tie-break: larger cost first)\n        order = sorted(range(n), key=lambda j: ((points[j]\/costs[j]) if points[j] > 0 else 0.0, -costs[j]))\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        # Post-fill drop phase: remove highest-point items while staying feasible\n        changed = True\n        while changed:\n            changed = False\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            ones.sort(key=lambda i: points[i], reverse=True)\n            for i in ones:\n                if total - costs[i] >= target_cost:\n                    s[i] = '0'\n                    total -= costs[i]\n                    changed = True\n                    break\n        return ''.join(s)\n\n    # Initialize\/repair invalid input\n    if not is_valid(solution):\n        repaired = greedy_feasible_seed()\n        return repaired, \"init_greedy_repair\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n    s = list(curr)\n\n    # Prefer feasibility-preserving moves\n    if random.random() < 0.9:\n        if feasible:\n            # Candidate drop moves: try top-k by points and choose best feasible drop\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda i: points[i], reverse=True)\n                best_drop = None\n                best_drop_pts = -1\n                for i in ones_sorted[:min(8, len(ones_sorted))]:\n                    if curr_cost - costs[i] >= target_cost:\n                        if points[i] > best_drop_pts:\n                            best_drop = i\n                            best_drop_pts = points[i]\n                if best_drop is not None:\n                    s2 = s.copy()\n                    s2[best_drop] = '0'\n                    return ''.join(s2), f\"drop_keep_feasible_{best_drop}\"\n            # Try bounded swaps among candidate sets\n            zeros = [j for j, ch in enumerate(s) if ch == '0']\n            if ones and zeros:\n                cand_drops = sorted(ones, key=lambda i: points[i], reverse=True)[:min(6, len(ones))]\n                # adds by low ratio (tie-break larger cost)\n                def ratio(j):\n                    return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                cand_adds = sorted(zeros, key=lambda j: (ratio(j), -costs[j]))[:min(8, len(zeros))]\n                best_move = None\n                best_delta_pts = math.inf\n                # (1,1) swaps\n                for i in cand_drops:\n                    for j in cand_adds:\n                        new_cost = curr_cost - costs[i] + costs[j]\n                        if new_cost >= target_cost:\n                            delta_pts = points[j] - points[i]\n                            if delta_pts < best_delta_pts:\n                                best_delta_pts = delta_pts\n                                best_move = ([(i, 0), (j, 1)], f\"swap_1_1_{i}_{j}\")\n                # (2,1) and (1,2) limited samples\n                if len(cand_drops) >= 2:\n                    for (i1, i2) in random.sample([(a, b) for idx, a in enumerate(cand_drops) for b in cand_drops[idx+1:]], k=min(6, max(1, len(cand_drops)*(len(cand_drops)-1)\/\/2))):\n                        for j in cand_adds:\n                            new_cost = curr_cost - (costs[i1] + costs[i2]) + costs[j]\n                            if new_cost >= target_cost:\n                                delta_pts = points[j] - (points[i1] + points[i2])\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i1, 0), (i2, 0), (j, 1)], f\"swap_2_1_{i1}_{i2}_{j}\")\n                if len(cand_adds) >= 2:\n                    for i in cand_drops:\n                        for (j1, j2) in random.sample([(a, b) for idx, a in enumerate(cand_adds) for b in cand_adds[idx+1:]], k=min(6, max(1, len(cand_adds)*(len(cand_adds)-1)\/\/2))):\n                            new_cost = curr_cost - costs[i] + (costs[j1] + costs[j2])\n                            if new_cost >= target_cost:\n                                delta_pts = (points[j1] + points[j2]) - points[i]\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i, 0), (j1, 1), (j2, 1)], f\"swap_1_2_{i}_{j1}_{j2}\")\n                # (2,2)\n                if len(cand_drops) >= 2 and len(cand_adds) >= 2:\n                    for (i1, i2) in random.sample([(a, b) for idx, a in enumerate(cand_drops) for b in cand_drops[idx+1:]], k=min(6, max(1, len(cand_drops)*(len(cand_drops)-1)\/\/2))):\n                        for (j1, j2) in random.sample([(a, b) for idx, a in enumerate(cand_adds) for b in cand_adds[idx+1:]], k=min(6, max(1, len(cand_adds)*(len(cand_adds)-1)\/\/2))):\n                            new_cost = curr_cost - (costs[i1] + costs[i2]) + (costs[j1] + costs[j2])\n                            if new_cost >= target_cost:\n                                delta_pts = (points[j1] + points[j2]) - (points[i1] + points[i2])\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i1, 0), (i2, 0), (j1, 1), (j2, 1)], f\"swap_2_2_{i1}_{i2}_{j1}_{j2}\")\n                if best_move is not None:\n                    s2 = s.copy()\n                    for idx, val in best_move[0]:\n                        s2[idx] = '1' if val == 1 else '0'\n                    return ''.join(s2), best_move[1]\n            # Fallback small random flip (keep mostly feasible by biasing to drop+add)\n            idxs = random.sample(range(n), k=2)\n            return flip_indices(curr, idxs), f\"bitflip_feasible_2_{idxs[0]}_{idxs[1]}\"\n        else:\n            # Infeasible: add by minimal ratio with tie-break on higher cost to reach target faster\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                add = min(zeros, key=lambda j: ((points[j]\/costs[j]) if points[j] > 0 else 0.0, -costs[j]))\n                s[add] = '1'\n                return ''.join(s), f\"add_for_budget_{add}\"\n            # Fallback: force add random bit\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Exploration: random perturbative flips (1-3 bits)\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    return flip_indices(curr, idxs), f\"bitflip_{k}_\" + '_'.join(map(str, idxs))\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost_list(sol_list):\n        return sum(costs[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    # Seed\/repair\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (ratio(j), -costs[j]))\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to feasibility: add low-ratio (tie-break higher cost)\n    while compute_cost_list(s) < target_cost:\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: (ratio(j), -costs[j]))\n        s[add] = '1'\n\n    # Post-repair cleanup: drop highest-point items while keeping feasibility\n    changed = True\n    total = compute_cost_list(s)\n    while changed:\n        changed = False\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: points[i], reverse=True)\n        for i in ones:\n            if total - costs[i] >= target_cost:\n                s[i] = '0'\n                total -= costs[i]\n                changed = True\n                break\n\n    return ''.join(s)\n","Resultados":["111011101111111110111111",223.0,"111011101111111110111111",223.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0036150811}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24; index i in [1..24]; bit '1' selects decoration i, '0' skips.","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data (1..24)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    n = 24\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        score = float(total_points)\n        # Validation guards (no raise, but can be used if debugging)\n        # assert score == float(total_points)\n        return score\n    shortfall = target_cost - total_cost\n    lam = 100.0  # penalty per dollar shortfall\n    score = float(total_points + lam * shortfall)\n    # assert score >= float(total_points + lam * shortfall)\n    return score\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def compute_points(sol: str) -> int:\n        return sum(points[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def flip_indices(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    def greedy_feasible_seed():\n        # Add by increasing points-per-cost (tie-break: larger cost first)\n        order = sorted(range(n), key=lambda j: ((points[j]\/costs[j]) if points[j] > 0 else 0.0, -costs[j]))\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        # Post-fill drop phase: remove highest-point items while staying feasible\n        changed = True\n        while changed:\n            changed = False\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            ones.sort(key=lambda i: points[i], reverse=True)\n            for i in ones:\n                if total - costs[i] >= target_cost:\n                    s[i] = '0'\n                    total -= costs[i]\n                    changed = True\n                    break\n        return ''.join(s)\n\n    # Initialize\/repair invalid input\n    if not is_valid(solution):\n        repaired = greedy_feasible_seed()\n        return repaired, \"init_greedy_repair\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n    s = list(curr)\n\n    # Prefer feasibility-preserving moves\n    if random.random() < 0.9:\n        if feasible:\n            # Candidate drop moves: try top-k by points and choose best feasible drop\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda i: points[i], reverse=True)\n                best_drop = None\n                best_drop_pts = -1\n                for i in ones_sorted[:min(8, len(ones_sorted))]:\n                    if curr_cost - costs[i] >= target_cost:\n                        if points[i] > best_drop_pts:\n                            best_drop = i\n                            best_drop_pts = points[i]\n                if best_drop is not None:\n                    s2 = s.copy()\n                    s2[best_drop] = '0'\n                    return ''.join(s2), f\"drop_keep_feasible_{best_drop}\"\n            # Try bounded swaps among candidate sets\n            zeros = [j for j, ch in enumerate(s) if ch == '0']\n            if ones and zeros:\n                cand_drops = sorted(ones, key=lambda i: points[i], reverse=True)[:min(6, len(ones))]\n                # adds by low ratio (tie-break larger cost)\n                def ratio(j):\n                    return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                cand_adds = sorted(zeros, key=lambda j: (ratio(j), -costs[j]))[:min(8, len(zeros))]\n                best_move = None\n                best_delta_pts = math.inf\n                # (1,1) swaps\n                for i in cand_drops:\n                    for j in cand_adds:\n                        new_cost = curr_cost - costs[i] + costs[j]\n                        if new_cost >= target_cost:\n                            delta_pts = points[j] - points[i]\n                            if delta_pts < best_delta_pts:\n                                best_delta_pts = delta_pts\n                                best_move = ([(i, 0), (j, 1)], f\"swap_1_1_{i}_{j}\")\n                # (2,1) and (1,2) limited samples\n                if len(cand_drops) >= 2:\n                    for (i1, i2) in random.sample([(a, b) for idx, a in enumerate(cand_drops) for b in cand_drops[idx+1:]], k=min(6, max(1, len(cand_drops)*(len(cand_drops)-1)\/\/2))):\n                        for j in cand_adds:\n                            new_cost = curr_cost - (costs[i1] + costs[i2]) + costs[j]\n                            if new_cost >= target_cost:\n                                delta_pts = points[j] - (points[i1] + points[i2])\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i1, 0), (i2, 0), (j, 1)], f\"swap_2_1_{i1}_{i2}_{j}\")\n                if len(cand_adds) >= 2:\n                    for i in cand_drops:\n                        for (j1, j2) in random.sample([(a, b) for idx, a in enumerate(cand_adds) for b in cand_adds[idx+1:]], k=min(6, max(1, len(cand_adds)*(len(cand_adds)-1)\/\/2))):\n                            new_cost = curr_cost - costs[i] + (costs[j1] + costs[j2])\n                            if new_cost >= target_cost:\n                                delta_pts = (points[j1] + points[j2]) - points[i]\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i, 0), (j1, 1), (j2, 1)], f\"swap_1_2_{i}_{j1}_{j2}\")\n                # (2,2)\n                if len(cand_drops) >= 2 and len(cand_adds) >= 2:\n                    for (i1, i2) in random.sample([(a, b) for idx, a in enumerate(cand_drops) for b in cand_drops[idx+1:]], k=min(6, max(1, len(cand_drops)*(len(cand_drops)-1)\/\/2))):\n                        for (j1, j2) in random.sample([(a, b) for idx, a in enumerate(cand_adds) for b in cand_adds[idx+1:]], k=min(6, max(1, len(cand_adds)*(len(cand_adds)-1)\/\/2))):\n                            new_cost = curr_cost - (costs[i1] + costs[i2]) + (costs[j1] + costs[j2])\n                            if new_cost >= target_cost:\n                                delta_pts = (points[j1] + points[j2]) - (points[i1] + points[i2])\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i1, 0), (i2, 0), (j1, 1), (j2, 1)], f\"swap_2_2_{i1}_{i2}_{j1}_{j2}\")\n                if best_move is not None:\n                    s2 = s.copy()\n                    for idx, val in best_move[0]:\n                        s2[idx] = '1' if val == 1 else '0'\n                    return ''.join(s2), best_move[1]\n            # Fallback small random flip (keep mostly feasible by biasing to drop+add)\n            idxs = random.sample(range(n), k=2)\n            return flip_indices(curr, idxs), f\"bitflip_feasible_2_{idxs[0]}_{idxs[1]}\"\n        else:\n            # Infeasible: add by minimal ratio with tie-break on higher cost to reach target faster\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                add = min(zeros, key=lambda j: ((points[j]\/costs[j]) if points[j] > 0 else 0.0, -costs[j]))\n                s[add] = '1'\n                return ''.join(s), f\"add_for_budget_{add}\"\n            # Fallback: force add random bit\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Exploration: random perturbative flips (1-3 bits)\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    return flip_indices(curr, idxs), f\"bitflip_{k}_\" + '_'.join(map(str, idxs))\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost_list(sol_list):\n        return sum(costs[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    # Seed\/repair\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (ratio(j), -costs[j]))\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to feasibility: add low-ratio (tie-break higher cost)\n    while compute_cost_list(s) < target_cost:\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: (ratio(j), -costs[j]))\n        s[add] = '1'\n\n    # Post-repair cleanup: drop highest-point items while keeping feasibility\n    changed = True\n    total = compute_cost_list(s)\n    while changed:\n        changed = False\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: points[i], reverse=True)\n        for i in ones:\n            if total - costs[i] >= target_cost:\n                s[i] = '0'\n                total -= costs[i]\n                changed = True\n                break\n\n    return ''.join(s)\n","Resultados":["111011101110111111111111",234.0,"111011101111111110111111",223.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0054753131}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"BIN_STR_LEN_24; index i in [1..24]; bit '1' selects decoration i, '0' skips.","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data (1..24)\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n    n = 24\n    # Validate input\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        return float(1e9)\n    total_cost = 0\n    total_points = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_cost += costs[i]\n            total_points += points[i]\n    if total_cost >= target_cost:\n        score = float(total_points)\n        # Validation guards (no raise, but can be used if debugging)\n        # assert score == float(total_points)\n        return score\n    shortfall = target_cost - total_cost\n    lam = 100.0  # penalty per dollar shortfall\n    score = float(total_points + lam * shortfall)\n    # assert score >= float(total_points + lam * shortfall)\n    return score\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_str, movement_label)\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost(sol: str) -> int:\n        return sum(costs[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def compute_points(sol: str) -> int:\n        return sum(points[i] for i, ch in enumerate(sol) if ch == '1')\n\n    def flip_indices(sol: str, idxs):\n        s = list(sol)\n        for i in idxs:\n            s[i] = '1' if s[i] == '0' else '0'\n        return ''.join(s)\n\n    def greedy_feasible_seed():\n        # Add by increasing points-per-cost (tie-break: larger cost first)\n        order = sorted(range(n), key=lambda j: ((points[j]\/costs[j]) if points[j] > 0 else 0.0, -costs[j]))\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        # Post-fill drop phase: remove highest-point items while staying feasible\n        changed = True\n        while changed:\n            changed = False\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            ones.sort(key=lambda i: points[i], reverse=True)\n            for i in ones:\n                if total - costs[i] >= target_cost:\n                    s[i] = '0'\n                    total -= costs[i]\n                    changed = True\n                    break\n        return ''.join(s)\n\n    # Initialize\/repair invalid input\n    if not is_valid(solution):\n        repaired = greedy_feasible_seed()\n        return repaired, \"init_greedy_repair\"\n\n    curr = solution\n    curr_cost = compute_cost(curr)\n    feasible = curr_cost >= target_cost\n    s = list(curr)\n\n    # Prefer feasibility-preserving moves\n    if random.random() < 0.9:\n        if feasible:\n            # Candidate drop moves: try top-k by points and choose best feasible drop\n            ones = [i for i, ch in enumerate(s) if ch == '1']\n            if ones:\n                ones_sorted = sorted(ones, key=lambda i: points[i], reverse=True)\n                best_drop = None\n                best_drop_pts = -1\n                for i in ones_sorted[:min(8, len(ones_sorted))]:\n                    if curr_cost - costs[i] >= target_cost:\n                        if points[i] > best_drop_pts:\n                            best_drop = i\n                            best_drop_pts = points[i]\n                if best_drop is not None:\n                    s2 = s.copy()\n                    s2[best_drop] = '0'\n                    return ''.join(s2), f\"drop_keep_feasible_{best_drop}\"\n            # Try bounded swaps among candidate sets\n            zeros = [j for j, ch in enumerate(s) if ch == '0']\n            if ones and zeros:\n                cand_drops = sorted(ones, key=lambda i: points[i], reverse=True)[:min(6, len(ones))]\n                # adds by low ratio (tie-break larger cost)\n                def ratio(j):\n                    return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n                cand_adds = sorted(zeros, key=lambda j: (ratio(j), -costs[j]))[:min(8, len(zeros))]\n                best_move = None\n                best_delta_pts = math.inf\n                # (1,1) swaps\n                for i in cand_drops:\n                    for j in cand_adds:\n                        new_cost = curr_cost - costs[i] + costs[j]\n                        if new_cost >= target_cost:\n                            delta_pts = points[j] - points[i]\n                            if delta_pts < best_delta_pts:\n                                best_delta_pts = delta_pts\n                                best_move = ([(i, 0), (j, 1)], f\"swap_1_1_{i}_{j}\")\n                # (2,1) and (1,2) limited samples\n                if len(cand_drops) >= 2:\n                    for (i1, i2) in random.sample([(a, b) for idx, a in enumerate(cand_drops) for b in cand_drops[idx+1:]], k=min(6, max(1, len(cand_drops)*(len(cand_drops)-1)\/\/2))):\n                        for j in cand_adds:\n                            new_cost = curr_cost - (costs[i1] + costs[i2]) + costs[j]\n                            if new_cost >= target_cost:\n                                delta_pts = points[j] - (points[i1] + points[i2])\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i1, 0), (i2, 0), (j, 1)], f\"swap_2_1_{i1}_{i2}_{j}\")\n                if len(cand_adds) >= 2:\n                    for i in cand_drops:\n                        for (j1, j2) in random.sample([(a, b) for idx, a in enumerate(cand_adds) for b in cand_adds[idx+1:]], k=min(6, max(1, len(cand_adds)*(len(cand_adds)-1)\/\/2))):\n                            new_cost = curr_cost - costs[i] + (costs[j1] + costs[j2])\n                            if new_cost >= target_cost:\n                                delta_pts = (points[j1] + points[j2]) - points[i]\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i, 0), (j1, 1), (j2, 1)], f\"swap_1_2_{i}_{j1}_{j2}\")\n                # (2,2)\n                if len(cand_drops) >= 2 and len(cand_adds) >= 2:\n                    for (i1, i2) in random.sample([(a, b) for idx, a in enumerate(cand_drops) for b in cand_drops[idx+1:]], k=min(6, max(1, len(cand_drops)*(len(cand_drops)-1)\/\/2))):\n                        for (j1, j2) in random.sample([(a, b) for idx, a in enumerate(cand_adds) for b in cand_adds[idx+1:]], k=min(6, max(1, len(cand_adds)*(len(cand_adds)-1)\/\/2))):\n                            new_cost = curr_cost - (costs[i1] + costs[i2]) + (costs[j1] + costs[j2])\n                            if new_cost >= target_cost:\n                                delta_pts = (points[j1] + points[j2]) - (points[i1] + points[i2])\n                                if delta_pts < best_delta_pts:\n                                    best_delta_pts = delta_pts\n                                    best_move = ([(i1, 0), (i2, 0), (j1, 1), (j2, 1)], f\"swap_2_2_{i1}_{i2}_{j1}_{j2}\")\n                if best_move is not None:\n                    s2 = s.copy()\n                    for idx, val in best_move[0]:\n                        s2[idx] = '1' if val == 1 else '0'\n                    return ''.join(s2), best_move[1]\n            # Fallback small random flip (keep mostly feasible by biasing to drop+add)\n            idxs = random.sample(range(n), k=2)\n            return flip_indices(curr, idxs), f\"bitflip_feasible_2_{idxs[0]}_{idxs[1]}\"\n        else:\n            # Infeasible: add by minimal ratio with tie-break on higher cost to reach target faster\n            zeros = [i for i, ch in enumerate(s) if ch == '0']\n            if zeros:\n                add = min(zeros, key=lambda j: ((points[j]\/costs[j]) if points[j] > 0 else 0.0, -costs[j]))\n                s[add] = '1'\n                return ''.join(s), f\"add_for_budget_{add}\"\n            # Fallback: force add random bit\n            k = random.randrange(n)\n            s[k] = '1'\n            return ''.join(s), \"add_fallback\"\n\n    # Exploration: random perturbative flips (1-3 bits)\n    k = random.choice([1, 2, 3])\n    idxs = random.sample(range(n), k)\n    return flip_indices(curr, idxs), f\"bitflip_{k}_\" + '_'.join(map(str, idxs))\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    n = 24\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    points = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    target_cost = 2750\n\n    def is_valid(sol: str) -> bool:\n        return isinstance(sol, str) and len(sol) == n and all(c in '01' for c in sol)\n\n    def compute_cost_list(sol_list):\n        return sum(costs[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    def ratio(j):\n        return (points[j]\/costs[j]) if points[j] > 0 else 0.0\n\n    # Seed\/repair\n    if not is_valid(solution):\n        order = sorted(range(n), key=lambda j: (ratio(j), -costs[j]))\n        s = ['0'] * n\n        total = 0\n        for j in order:\n            if total >= target_cost:\n                break\n            s[j] = '1'\n            total += costs[j]\n        solution = ''.join(s)\n\n    s = list(solution)\n    # Heavy perturbation: flip 20%-40% of bits\n    frac = random.uniform(0.2, 0.4)\n    k = max(1, int(round(frac * n)))\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to feasibility: add low-ratio (tie-break higher cost)\n    while compute_cost_list(s) < target_cost:\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        if not zeros:\n            break\n        add = min(zeros, key=lambda j: (ratio(j), -costs[j]))\n        s[add] = '1'\n\n    # Post-repair cleanup: drop highest-point items while keeping feasibility\n    changed = True\n    total = compute_cost_list(s)\n    while changed:\n        changed = False\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        ones.sort(key=lambda i: points[i], reverse=True)\n        for i in ones:\n            if total - costs[i] >= target_cost:\n                s[i] = '0'\n                total -= costs[i]\n                changed = True\n                break\n\n    return ''.join(s)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001744609}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} indicates taking offer i (1-indexed) if and only if char i == '1'.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Penalize infeasibility strongly (minimization)\n    deficit = required - total_gal\n    penalty_per_gallon = 100000.0\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    s = list(solution)\n\n    # Single-bit flip neighborhood\n    i = random.randrange(n)\n    s[i] = '1' if s[i] == '0' else '0'\n\n    neighbor = ''.join(s)\n    return neighbor, (\"BITFLIP\", \"SINGLE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: str):\n    # Multi-bit perturbation + greedy feasibility repair\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    s = list(solution)\n\n    # Randomly flip k bits\n    k = random.randint(2, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to ensure feasibility (>= 275 gallons)\n    def gallons(sel: List[str]) -> int:\n        return sum(offers[i][1] for i,ch in enumerate(sel) if ch == '1')\n\n    def cost(sel: List[str]) -> int:\n        return sum(offers[i][0] for i,ch in enumerate(sel) if ch == '1')\n\n    # If infeasible, add offers by best cost-per-gallon ascending\n    g_now = gallons(s)\n    if g_now < 275:\n        order = sorted(range(n), key=lambda i: offers[i][0]\/offers[i][1])\n        for i in order:\n            if s[i] == '0':\n                s[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= 275:\n                    break\n    # If feasible, try pruning expensive items while maintaining feasibility\n    if gallons(s) >= 275:\n        # Sort currently selected by worst cost-per-gallon first and try dropping\n        selected = [i for i,ch in enumerate(s) if ch == '1']\n        order_drop = sorted(selected, key=lambda i: offers[i][0]\/offers[i][1], reverse=True)\n        for i in order_drop:\n            s[i] = '0'\n            if gallons(s) < 275:\n                s[i] = '1'  # revert\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0004254751}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} indicates taking offer i (1-indexed) if and only if char i == '1'.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Penalize infeasibility strongly (minimization)\n    deficit = required - total_gal\n    penalty_per_gallon = 100000.0\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    s = list(solution)\n\n    # Single-bit flip neighborhood\n    i = random.randrange(n)\n    s[i] = '1' if s[i] == '0' else '0'\n\n    neighbor = ''.join(s)\n    return neighbor, (\"BITFLIP\", \"SINGLE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: str):\n    # Multi-bit perturbation + greedy feasibility repair\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    s = list(solution)\n\n    # Randomly flip k bits\n    k = random.randint(2, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to ensure feasibility (>= 275 gallons)\n    def gallons(sel: List[str]) -> int:\n        return sum(offers[i][1] for i,ch in enumerate(sel) if ch == '1')\n\n    def cost(sel: List[str]) -> int:\n        return sum(offers[i][0] for i,ch in enumerate(sel) if ch == '1')\n\n    # If infeasible, add offers by best cost-per-gallon ascending\n    g_now = gallons(s)\n    if g_now < 275:\n        order = sorted(range(n), key=lambda i: offers[i][0]\/offers[i][1])\n        for i in order:\n            if s[i] == '0':\n                s[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= 275:\n                    break\n    # If feasible, try pruning expensive items while maintaining feasibility\n    if gallons(s) >= 275:\n        # Sort currently selected by worst cost-per-gallon first and try dropping\n        selected = [i for i,ch in enumerate(s) if ch == '1']\n        order_drop = sorted(selected, key=lambda i: offers[i][0]\/offers[i][1], reverse=True)\n        for i in order_drop:\n            s[i] = '0'\n            if gallons(s) < 275:\n                s[i] = '1'  # revert\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.000713308}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} indicates taking offer i (1-indexed) if and only if char i == '1'.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Penalize infeasibility strongly (minimization)\n    deficit = required - total_gal\n    penalty_per_gallon = 100000.0\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution: str) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    s = list(solution)\n\n    # Single-bit flip neighborhood\n    i = random.randrange(n)\n    s[i] = '1' if s[i] == '0' else '0'\n\n    neighbor = ''.join(s)\n    return neighbor, (\"BITFLIP\", \"SINGLE\")\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: str):\n    # Multi-bit perturbation + greedy feasibility repair\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    s = list(solution)\n\n    # Randomly flip k bits\n    k = random.randint(2, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        s[i] = '1' if s[i] == '0' else '0'\n\n    # Repair to ensure feasibility (>= 275 gallons)\n    def gallons(sel: List[str]) -> int:\n        return sum(offers[i][1] for i,ch in enumerate(sel) if ch == '1')\n\n    def cost(sel: List[str]) -> int:\n        return sum(offers[i][0] for i,ch in enumerate(sel) if ch == '1')\n\n    # If infeasible, add offers by best cost-per-gallon ascending\n    g_now = gallons(s)\n    if g_now < 275:\n        order = sorted(range(n), key=lambda i: offers[i][0]\/offers[i][1])\n        for i in order:\n            if s[i] == '0':\n                s[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= 275:\n                    break\n    # If feasible, try pruning expensive items while maintaining feasibility\n    if gallons(s) >= 275:\n        # Sort currently selected by worst cost-per-gallon first and try dropping\n        selected = [i for i,ch in enumerate(s) if ch == '1']\n        order_drop = sorted(selected, key=lambda i: offers[i][0]\/offers[i][1], reverse=True)\n        for i in order_drop:\n            s[i] = '0'\n            if gallons(s) < 275:\n                s[i] = '1'  # revert\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0006647271}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} indicates taking offer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Penalize infeasibility (minimization); 283 = max_total_cost+1 to ensure feasibility dominates\n    deficit = required - total_gal\n    penalty_per_gallon = 283.0\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    def gallons(sel):\n        return sum(offers[i][1] for i,ch in enumerate(sel) if ch == '1')\n\n    def repair_to_feasible(sel_list):\n        # Greedy add by best cost-per-gallon until feasible\n        req = 275\n        g_now = gallons(sel_list)\n        if g_now >= req:\n            return sel_list\n        order = sorted(range(n), key=lambda i: offers[i][0] \/ offers[i][1])\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= req:\n                    break\n        return sel_list\n\n    s = list(solution)\n\n    move_choice = random.random()\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"BITFLIP\", \"SINGLE\")\n    elif move_choice < 0.75:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"BITFLIP\", \"DOUBLE\")\n    else:\n        # Swap: add then drop (feasibility-preserving preference)\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        if zeros and ones:\n            i = random.choice(zeros)\n            j = random.choice(ones)\n            s[i] = '1'\n            s[j] = '0'\n        else:\n            # fallback single flip\n            k = random.randrange(n)\n            s[k] = '1' if s[k] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"SWAP\", \"ADD_DROP\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i,ch in enumerate(sel_list) if ch == '1')\n\n    def cost(sel_list):\n        return sum(offers[i][0] for i,ch in enumerate(sel_list) if ch == '1')\n\n    def repair_to_feasible(sel_list):\n        req = 275\n        g_now = gallons(sel_list)\n        if g_now >= req:\n            return sel_list\n        order = sorted(range(n), key=lambda i: offers[i][0] \/ offers[i][1])\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= req:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        # Try dropping worst cost-per-gallon while staying feasible\n        req = 275\n        def cpg(i):\n            c,g = offers[i]\n            return c \/ g\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i,ch in enumerate(sel_list) if ch == '1']\n            order_drop = sorted(selected, key=cpg, reverse=True)\n            for i in order_drop:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= req:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n            # loop again if any improvement\n        return sel_list\n\n    s = list(solution)\n\n    # Ruin: flip k bits (k in [3,6]) with bias towards turning off expensive items\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        # probabilistically turn off currently selected expensive items\n        if s[i] == '1':\n            s[i] = '0'\n        else:\n            s[i] = '1'\n\n    # Recreate: repair feasibility then prune\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: solution must be a binary string","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000757598}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} indicates taking offer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Penalize infeasibility (minimization); 283 = max_total_cost+1 to ensure feasibility dominates\n    deficit = required - total_gal\n    penalty_per_gallon = 283.0\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    def gallons(sel):\n        return sum(offers[i][1] for i,ch in enumerate(sel) if ch == '1')\n\n    def repair_to_feasible(sel_list):\n        # Greedy add by best cost-per-gallon until feasible\n        req = 275\n        g_now = gallons(sel_list)\n        if g_now >= req:\n            return sel_list\n        order = sorted(range(n), key=lambda i: offers[i][0] \/ offers[i][1])\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= req:\n                    break\n        return sel_list\n\n    s = list(solution)\n\n    move_choice = random.random()\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"BITFLIP\", \"SINGLE\")\n    elif move_choice < 0.75:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"BITFLIP\", \"DOUBLE\")\n    else:\n        # Swap: add then drop (feasibility-preserving preference)\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        if zeros and ones:\n            i = random.choice(zeros)\n            j = random.choice(ones)\n            s[i] = '1'\n            s[j] = '0'\n        else:\n            # fallback single flip\n            k = random.randrange(n)\n            s[k] = '1' if s[k] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"SWAP\", \"ADD_DROP\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i,ch in enumerate(sel_list) if ch == '1')\n\n    def cost(sel_list):\n        return sum(offers[i][0] for i,ch in enumerate(sel_list) if ch == '1')\n\n    def repair_to_feasible(sel_list):\n        req = 275\n        g_now = gallons(sel_list)\n        if g_now >= req:\n            return sel_list\n        order = sorted(range(n), key=lambda i: offers[i][0] \/ offers[i][1])\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= req:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        # Try dropping worst cost-per-gallon while staying feasible\n        req = 275\n        def cpg(i):\n            c,g = offers[i]\n            return c \/ g\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i,ch in enumerate(sel_list) if ch == '1']\n            order_drop = sorted(selected, key=cpg, reverse=True)\n            for i in order_drop:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= req:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n            # loop again if any improvement\n        return sel_list\n\n    s = list(solution)\n\n    # Ruin: flip k bits (k in [3,6]) with bias towards turning off expensive items\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        # probabilistically turn off currently selected expensive items\n        if s[i] == '1':\n            s[i] = '0'\n        else:\n            s[i] = '1'\n\n    # Recreate: repair feasibility then prune\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: solution must be a binary string","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0009989419}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} indicates taking offer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Penalize infeasibility (minimization); 283 = max_total_cost+1 to ensure feasibility dominates\n    deficit = required - total_gal\n    penalty_per_gallon = 283.0\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    def gallons(sel):\n        return sum(offers[i][1] for i,ch in enumerate(sel) if ch == '1')\n\n    def repair_to_feasible(sel_list):\n        # Greedy add by best cost-per-gallon until feasible\n        req = 275\n        g_now = gallons(sel_list)\n        if g_now >= req:\n            return sel_list\n        order = sorted(range(n), key=lambda i: offers[i][0] \/ offers[i][1])\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= req:\n                    break\n        return sel_list\n\n    s = list(solution)\n\n    move_choice = random.random()\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"BITFLIP\", \"SINGLE\")\n    elif move_choice < 0.75:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"BITFLIP\", \"DOUBLE\")\n    else:\n        # Swap: add then drop (feasibility-preserving preference)\n        zeros = [i for i,ch in enumerate(s) if ch == '0']\n        ones = [i for i,ch in enumerate(s) if ch == '1']\n        if zeros and ones:\n            i = random.choice(zeros)\n            j = random.choice(ones)\n            s[i] = '1'\n            s[j] = '0'\n        else:\n            # fallback single flip\n            k = random.randrange(n)\n            s[k] = '1' if s[k] == '0' else '0'\n        s = repair_to_feasible(s)\n        neighbor = ''.join(s)\n        return neighbor, (\"SWAP\", \"ADD_DROP\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i,ch in enumerate(sel_list) if ch == '1')\n\n    def cost(sel_list):\n        return sum(offers[i][0] for i,ch in enumerate(sel_list) if ch == '1')\n\n    def repair_to_feasible(sel_list):\n        req = 275\n        g_now = gallons(sel_list)\n        if g_now >= req:\n            return sel_list\n        order = sorted(range(n), key=lambda i: offers[i][0] \/ offers[i][1])\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= req:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        # Try dropping worst cost-per-gallon while staying feasible\n        req = 275\n        def cpg(i):\n            c,g = offers[i]\n            return c \/ g\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i,ch in enumerate(sel_list) if ch == '1']\n            order_drop = sorted(selected, key=cpg, reverse=True)\n            for i in order_drop:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= req:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n            # loop again if any improvement\n        return sel_list\n\n    s = list(solution)\n\n    # Ruin: flip k bits (k in [3,6]) with bias towards turning off expensive items\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        # probabilistically turn off currently selected expensive items\n        if s[i] == '1':\n            s[i] = '0'\n        else:\n            s[i] = '1'\n\n    # Recreate: repair feasibility then prune\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: solution must be a binary string","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.000964311}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} selects customer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Compute dominating penalty per gallon based on max possible total cost\n    max_total_cost = sum(c for c, _ in offers)\n    penalty_per_gallon = float(max_total_cost + 1)\n    deficit = required - total_gal\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    required = 275\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i, ch in enumerate(sel_list) if ch == '1')\n\n    def cpg(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(sel_list):\n        # Greedy add by best cost-per-gallon until feasible (bounded by n additions)\n        g_now = gallons(sel_list)\n        if g_now >= required:\n            return sel_list\n        order = sorted(range(n), key=lambda i: cpg(i))\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= required:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        # Iteratively drop worst cost-per-gallon while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i, ch in enumerate(sel_list) if ch == '1']\n            if not selected:\n                break\n            drop_order = sorted(selected, key=lambda i: cpg(i), reverse=True)\n            for i in drop_order:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= required:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n            # stop if no improvement\n        return sel_list\n\n    s = list(solution)\n\n    move_choice = random.random()\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        move = (\"BITFLIP\", \"SINGLE\")\n    elif move_choice < 0.75:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        move = (\"BITFLIP\", \"DOUBLE\")\n    else:\n        # Swap add\/drop\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        if zeros and ones:\n            i = random.choice(zeros)\n            j = random.choice(ones)\n            s[i] = '1'\n            s[j] = '0'\n            move = (\"SWAP\", \"ADD_DROP\")\n        else:\n            k = random.randrange(n)\n            s[k] = '1' if s[k] == '0' else '0'\n            move = (\"BITFLIP\", \"FALLBACK\")\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n    neighbor = ''.join(s)\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i, ch in enumerate(sel_list) if ch == '1')\n\n    def cpg(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(sel_list):\n        g_now = gallons(sel_list)\n        if g_now >= required:\n            return sel_list\n        order = sorted(range(n), key=lambda i: cpg(i))\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= required:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i, ch in enumerate(sel_list) if ch == '1']\n            if not selected:\n                break\n            drop_order = sorted(selected, key=lambda i: cpg(i), reverse=True)\n            for i in drop_order:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= required:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n        return sel_list\n\n    s = list(solution)\n\n    # Ruin: flip k bits (biased towards turning off currently selected ones)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        if s[i] == '1':\n            s[i] = '0'\n        else:\n            s[i] = '1'\n\n    # Recreate: repair feasibility then prune for cost\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: solution must be a binary string","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.00088966}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} selects customer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Compute dominating penalty per gallon based on max possible total cost\n    max_total_cost = sum(c for c, _ in offers)\n    penalty_per_gallon = float(max_total_cost + 1)\n    deficit = required - total_gal\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    required = 275\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i, ch in enumerate(sel_list) if ch == '1')\n\n    def cpg(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(sel_list):\n        # Greedy add by best cost-per-gallon until feasible (bounded by n additions)\n        g_now = gallons(sel_list)\n        if g_now >= required:\n            return sel_list\n        order = sorted(range(n), key=lambda i: cpg(i))\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= required:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        # Iteratively drop worst cost-per-gallon while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i, ch in enumerate(sel_list) if ch == '1']\n            if not selected:\n                break\n            drop_order = sorted(selected, key=lambda i: cpg(i), reverse=True)\n            for i in drop_order:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= required:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n            # stop if no improvement\n        return sel_list\n\n    s = list(solution)\n\n    move_choice = random.random()\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        move = (\"BITFLIP\", \"SINGLE\")\n    elif move_choice < 0.75:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        move = (\"BITFLIP\", \"DOUBLE\")\n    else:\n        # Swap add\/drop\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        if zeros and ones:\n            i = random.choice(zeros)\n            j = random.choice(ones)\n            s[i] = '1'\n            s[j] = '0'\n            move = (\"SWAP\", \"ADD_DROP\")\n        else:\n            k = random.randrange(n)\n            s[k] = '1' if s[k] == '0' else '0'\n            move = (\"BITFLIP\", \"FALLBACK\")\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n    neighbor = ''.join(s)\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i, ch in enumerate(sel_list) if ch == '1')\n\n    def cpg(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(sel_list):\n        g_now = gallons(sel_list)\n        if g_now >= required:\n            return sel_list\n        order = sorted(range(n), key=lambda i: cpg(i))\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= required:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i, ch in enumerate(sel_list) if ch == '1']\n            if not selected:\n                break\n            drop_order = sorted(selected, key=lambda i: cpg(i), reverse=True)\n            for i in drop_order:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= required:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n        return sel_list\n\n    s = list(solution)\n\n    # Ruin: flip k bits (biased towards turning off currently selected ones)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        if s[i] == '1':\n            s[i] = '0'\n        else:\n            s[i] = '1'\n\n    # Recreate: repair feasibility then prune for cost\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: solution must be a binary string","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0010787031}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} selects customer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Validate representation\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Compute dominating penalty per gallon based on max possible total cost\n    max_total_cost = sum(c for c, _ in offers)\n    penalty_per_gallon = float(max_total_cost + 1)\n    deficit = required - total_gal\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    required = 275\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i, ch in enumerate(sel_list) if ch == '1')\n\n    def cpg(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(sel_list):\n        # Greedy add by best cost-per-gallon until feasible (bounded by n additions)\n        g_now = gallons(sel_list)\n        if g_now >= required:\n            return sel_list\n        order = sorted(range(n), key=lambda i: cpg(i))\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= required:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        # Iteratively drop worst cost-per-gallon while keeping feasibility\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i, ch in enumerate(sel_list) if ch == '1']\n            if not selected:\n                break\n            drop_order = sorted(selected, key=lambda i: cpg(i), reverse=True)\n            for i in drop_order:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= required:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n            # stop if no improvement\n        return sel_list\n\n    s = list(solution)\n\n    move_choice = random.random()\n    if move_choice < 0.4:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i] == '0' else '0'\n        move = (\"BITFLIP\", \"SINGLE\")\n    elif move_choice < 0.75:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i] == '0' else '0'\n        s[j] = '1' if s[j] == '0' else '0'\n        move = (\"BITFLIP\", \"DOUBLE\")\n    else:\n        # Swap add\/drop\n        zeros = [i for i, ch in enumerate(s) if ch == '0']\n        ones = [i for i, ch in enumerate(s) if ch == '1']\n        if zeros and ones:\n            i = random.choice(zeros)\n            j = random.choice(ones)\n            s[i] = '1'\n            s[j] = '0'\n            move = (\"SWAP\", \"ADD_DROP\")\n        else:\n            k = random.randrange(n)\n            s[k] = '1' if s[k] == '0' else '0'\n            move = (\"BITFLIP\", \"FALLBACK\")\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n    neighbor = ''.join(s)\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def gallons(sel_list):\n        return sum(offers[i][1] for i, ch in enumerate(sel_list) if ch == '1')\n\n    def cpg(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(sel_list):\n        g_now = gallons(sel_list)\n        if g_now >= required:\n            return sel_list\n        order = sorted(range(n), key=lambda i: cpg(i))\n        for i in order:\n            if sel_list[i] == '0':\n                sel_list[i] = '1'\n                g_now += offers[i][1]\n                if g_now >= required:\n                    break\n        return sel_list\n\n    def prune_to_improve(sel_list):\n        improved = True\n        while improved:\n            improved = False\n            selected = [i for i, ch in enumerate(sel_list) if ch == '1']\n            if not selected:\n                break\n            drop_order = sorted(selected, key=lambda i: cpg(i), reverse=True)\n            for i in drop_order:\n                sel_list[i] = '0'\n                if gallons(sel_list) >= required:\n                    improved = True\n                else:\n                    sel_list[i] = '1'\n        return sel_list\n\n    s = list(solution)\n\n    # Ruin: flip k bits (biased towards turning off currently selected ones)\n    k = random.randint(3, 6)\n    idxs = random.sample(range(n), k)\n    for i in idxs:\n        if s[i] == '1':\n            s[i] = '0'\n        else:\n            s[i] = '1'\n\n    # Recreate: repair feasibility then prune for cost\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: solution must be a binary string","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001038592}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} selects customer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Normalize and validate representation\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Strong feasibility penalty per missing gallon\n    max_total_cost = sum(c for c, _ in offers)\n    penalty_per_gallon = float(max_total_cost + 1)\n    deficit = required - total_gal\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    # Normalize and validate\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def gallons_bits(bits: List[str]) -> int:\n        return sum(offers[i][1] for i, ch in enumerate(bits) if ch == '1')\n\n    def cost_per_gal(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(bits: List[str]) -> List[str]:\n        total_g = sum(offers[i][1] for i,ch in enumerate(bits) if ch=='1')\n        if total_g >= required:\n            return bits\n        order = sorted(range(n), key=lambda i: cost_per_gal(i))\n        for i in order:\n            if bits[i] == '0':\n                bits[i] = '1'\n                total_g += offers[i][1]\n                if total_g >= required:\n                    break\n        # Given data, feasibility must be achievable\n        if total_g < required:\n            raise RuntimeError('repair failed to reach feasibility')\n        return bits\n\n    def prune_to_improve(bits: List[str]) -> List[str]:\n        # Drop worst c\/g while maintaining feasibility, maintaining running gallons\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        total_g = sum(offers[i][1] for i in sel)\n        # sort selected by decreasing cost-per-gallon\n        for i in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True):\n            g_i = offers[i][1]\n            if total_g - g_i >= required:\n                bits[i] = '0'\n                total_g -= g_i\n        return bits\n\n    def local_exchange(bits: List[str]) -> None:\n        # Try a limited number of improving exchanges (1-1 and 2-1)\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        nos = [i for i,ch in enumerate(bits) if ch=='0']\n        total_g = sum(offers[i][1] for i in sel)\n        total_c = sum(offers[i][0] for i in sel)\n        # 1-1 exchange: drop one, add one, keep feasible and reduce cost\n        improved = True\n        iters = 0\n        while improved and iters < 8:\n            improved = False\n            iters += 1\n            for j in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True)[:5]:\n                for k in sorted(nos, key=lambda i: cost_per_gal(i))[:5]:\n                    new_g = total_g - offers[j][1] + offers[k][1]\n                    if new_g >= required:\n                        new_c = total_c - offers[j][0] + offers[k][0]\n                        if new_c < total_c:\n                            bits[j] = '0'; bits[k] = '1'\n                            total_g = new_g; total_c = new_c\n                            sel.remove(j); sel.append(k)\n                            nos.remove(k); nos.append(j)\n                            improved = True\n                            break\n                if improved:\n                    break\n        return None\n\n    s = list(solution)\n\n    r = random.random()\n    if r < 0.35:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i]=='0' else '0'\n        move = (\"BITFLIP\", \"SINGLE\")\n    elif r < 0.65:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i]=='0' else '0'\n        s[j] = '1' if s[j]=='0' else '0'\n        move = (\"BITFLIP\", \"DOUBLE\")\n    elif r < 0.85:\n        # Block flip (3-6 bits)\n        k = random.randint(3,6)\n        for i in random.sample(range(n), k):\n            s[i] = '1' if s[i]=='0' else '0'\n        move = (\"BITFLIP\", \"BLOCK\")\n    else:\n        # Swap add\/drop if possible\n        zeros = [i for i,ch in enumerate(s) if ch=='0']\n        ones = [i for i,ch in enumerate(s) if ch=='1']\n        if zeros and ones:\n            i = random.choice(zeros); j = random.choice(ones)\n            s[i] = '1'; s[j] = '0'\n            move = (\"SWAP\", \"ADD_DROP\")\n        else:\n            k = random.randrange(n)\n            s[k] = '1' if s[k]=='0' else '0'\n            move = (\"BITFLIP\", \"FALLBACK\")\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n    local_exchange(s)\n    neighbor = ''.join(s)\n    return neighbor, move\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Normalize and validate\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def cost_per_gal(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(bits: List[str]) -> List[str]:\n        total_g = sum(offers[i][1] for i,ch in enumerate(bits) if ch=='1')\n        if total_g >= required:\n            return bits\n        order = sorted(range(n), key=lambda i: cost_per_gal(i))\n        for i in order:\n            if bits[i] == '0':\n                bits[i] = '1'\n                total_g += offers[i][1]\n                if total_g >= required:\n                    break\n        if total_g < required:\n            raise RuntimeError('repair failed to reach feasibility')\n        return bits\n\n    def prune_to_improve(bits: List[str]) -> List[str]:\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        total_g = sum(offers[i][1] for i in sel)\n        for i in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True):\n            g_i = offers[i][1]\n            if total_g - g_i >= required:\n                bits[i] = '0'\n                total_g -= g_i\n        return bits\n\n    s = list(solution)\n\n    # Ruin: flip k bits (adaptive strength)\n    k = random.randint(4, 8)\n    for i in random.sample(range(n), k):\n        s[i] = '1' if s[i]=='0' else '0'\n\n    # Optional biased cleanup: drop a few worst c\/g with small probability\n    if random.random() < 0.5:\n        ones = [i for i,ch in enumerate(s) if ch=='1']\n        for i in sorted(ones, key=lambda i: cost_per_gal(i), reverse=True)[:2]:\n            s[i] = '0'\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.0012185341}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} selects customer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Normalize and validate representation\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Strong feasibility penalty per missing gallon\n    max_total_cost = sum(c for c, _ in offers)\n    penalty_per_gallon = float(max_total_cost + 1)\n    deficit = required - total_gal\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    # Normalize and validate\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def gallons_bits(bits: List[str]) -> int:\n        return sum(offers[i][1] for i, ch in enumerate(bits) if ch == '1')\n\n    def cost_per_gal(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(bits: List[str]) -> List[str]:\n        total_g = sum(offers[i][1] for i,ch in enumerate(bits) if ch=='1')\n        if total_g >= required:\n            return bits\n        order = sorted(range(n), key=lambda i: cost_per_gal(i))\n        for i in order:\n            if bits[i] == '0':\n                bits[i] = '1'\n                total_g += offers[i][1]\n                if total_g >= required:\n                    break\n        # Given data, feasibility must be achievable\n        if total_g < required:\n            raise RuntimeError('repair failed to reach feasibility')\n        return bits\n\n    def prune_to_improve(bits: List[str]) -> List[str]:\n        # Drop worst c\/g while maintaining feasibility, maintaining running gallons\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        total_g = sum(offers[i][1] for i in sel)\n        # sort selected by decreasing cost-per-gallon\n        for i in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True):\n            g_i = offers[i][1]\n            if total_g - g_i >= required:\n                bits[i] = '0'\n                total_g -= g_i\n        return bits\n\n    def local_exchange(bits: List[str]) -> None:\n        # Try a limited number of improving exchanges (1-1 and 2-1)\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        nos = [i for i,ch in enumerate(bits) if ch=='0']\n        total_g = sum(offers[i][1] for i in sel)\n        total_c = sum(offers[i][0] for i in sel)\n        # 1-1 exchange: drop one, add one, keep feasible and reduce cost\n        improved = True\n        iters = 0\n        while improved and iters < 8:\n            improved = False\n            iters += 1\n            for j in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True)[:5]:\n                for k in sorted(nos, key=lambda i: cost_per_gal(i))[:5]:\n                    new_g = total_g - offers[j][1] + offers[k][1]\n                    if new_g >= required:\n                        new_c = total_c - offers[j][0] + offers[k][0]\n                        if new_c < total_c:\n                            bits[j] = '0'; bits[k] = '1'\n                            total_g = new_g; total_c = new_c\n                            sel.remove(j); sel.append(k)\n                            nos.remove(k); nos.append(j)\n                            improved = True\n                            break\n                if improved:\n                    break\n        return None\n\n    s = list(solution)\n\n    r = random.random()\n    if r < 0.35:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i]=='0' else '0'\n        move = (\"BITFLIP\", \"SINGLE\")\n    elif r < 0.65:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i]=='0' else '0'\n        s[j] = '1' if s[j]=='0' else '0'\n        move = (\"BITFLIP\", \"DOUBLE\")\n    elif r < 0.85:\n        # Block flip (3-6 bits)\n        k = random.randint(3,6)\n        for i in random.sample(range(n), k):\n            s[i] = '1' if s[i]=='0' else '0'\n        move = (\"BITFLIP\", \"BLOCK\")\n    else:\n        # Swap add\/drop if possible\n        zeros = [i for i,ch in enumerate(s) if ch=='0']\n        ones = [i for i,ch in enumerate(s) if ch=='1']\n        if zeros and ones:\n            i = random.choice(zeros); j = random.choice(ones)\n            s[i] = '1'; s[j] = '0'\n            move = (\"SWAP\", \"ADD_DROP\")\n        else:\n            k = random.randrange(n)\n            s[k] = '1' if s[k]=='0' else '0'\n            move = (\"BITFLIP\", \"FALLBACK\")\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n    local_exchange(s)\n    neighbor = ''.join(s)\n    return neighbor, move\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Normalize and validate\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def cost_per_gal(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(bits: List[str]) -> List[str]:\n        total_g = sum(offers[i][1] for i,ch in enumerate(bits) if ch=='1')\n        if total_g >= required:\n            return bits\n        order = sorted(range(n), key=lambda i: cost_per_gal(i))\n        for i in order:\n            if bits[i] == '0':\n                bits[i] = '1'\n                total_g += offers[i][1]\n                if total_g >= required:\n                    break\n        if total_g < required:\n            raise RuntimeError('repair failed to reach feasibility')\n        return bits\n\n    def prune_to_improve(bits: List[str]) -> List[str]:\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        total_g = sum(offers[i][1] for i in sel)\n        for i in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True):\n            g_i = offers[i][1]\n            if total_g - g_i >= required:\n                bits[i] = '0'\n                total_g -= g_i\n        return bits\n\n    s = list(solution)\n\n    # Ruin: flip k bits (adaptive strength)\n    k = random.randint(4, 8)\n    for i in random.sample(range(n), k):\n        s[i] = '1' if s[i]=='0' else '0'\n\n    # Optional biased cleanup: drop a few worst c\/g with small probability\n    if random.random() < 0.5:\n        ones = [i for i,ch in enumerate(s) if ch=='1']\n        for i in sorted(ones, key=lambda i: cost_per_gal(i), reverse=True)[:2]:\n            s[i] = '0'\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.001436607}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24; bit i in {0,1} selects customer i (1-indexed) iff char i == '1'.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution) -> float:\n    # Normalize and validate representation\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = 24\n    if len(solution) != n:\n        raise ValueError('solution length must be 24')\n\n    # Embedded problem data: (price, gallons) for customers 1..24\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n\n    total_cost = 0\n    total_gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            c, g = offers[i]\n            total_cost += c\n            total_gal += g\n\n    required = 275\n    if total_gal >= required:\n        return float(total_cost)\n    # Strong feasibility penalty per missing gallon\n    max_total_cost = sum(c for c, _ in offers)\n    penalty_per_gallon = float(max_total_cost + 1)\n    deficit = required - total_gal\n    return float(total_cost) + penalty_per_gallon * float(deficit)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    # Normalize and validate\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def gallons_bits(bits: List[str]) -> int:\n        return sum(offers[i][1] for i, ch in enumerate(bits) if ch == '1')\n\n    def cost_per_gal(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(bits: List[str]) -> List[str]:\n        total_g = sum(offers[i][1] for i,ch in enumerate(bits) if ch=='1')\n        if total_g >= required:\n            return bits\n        order = sorted(range(n), key=lambda i: cost_per_gal(i))\n        for i in order:\n            if bits[i] == '0':\n                bits[i] = '1'\n                total_g += offers[i][1]\n                if total_g >= required:\n                    break\n        # Given data, feasibility must be achievable\n        if total_g < required:\n            raise RuntimeError('repair failed to reach feasibility')\n        return bits\n\n    def prune_to_improve(bits: List[str]) -> List[str]:\n        # Drop worst c\/g while maintaining feasibility, maintaining running gallons\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        total_g = sum(offers[i][1] for i in sel)\n        # sort selected by decreasing cost-per-gallon\n        for i in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True):\n            g_i = offers[i][1]\n            if total_g - g_i >= required:\n                bits[i] = '0'\n                total_g -= g_i\n        return bits\n\n    def local_exchange(bits: List[str]) -> None:\n        # Try a limited number of improving exchanges (1-1 and 2-1)\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        nos = [i for i,ch in enumerate(bits) if ch=='0']\n        total_g = sum(offers[i][1] for i in sel)\n        total_c = sum(offers[i][0] for i in sel)\n        # 1-1 exchange: drop one, add one, keep feasible and reduce cost\n        improved = True\n        iters = 0\n        while improved and iters < 8:\n            improved = False\n            iters += 1\n            for j in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True)[:5]:\n                for k in sorted(nos, key=lambda i: cost_per_gal(i))[:5]:\n                    new_g = total_g - offers[j][1] + offers[k][1]\n                    if new_g >= required:\n                        new_c = total_c - offers[j][0] + offers[k][0]\n                        if new_c < total_c:\n                            bits[j] = '0'; bits[k] = '1'\n                            total_g = new_g; total_c = new_c\n                            sel.remove(j); sel.append(k)\n                            nos.remove(k); nos.append(j)\n                            improved = True\n                            break\n                if improved:\n                    break\n        return None\n\n    s = list(solution)\n\n    r = random.random()\n    if r < 0.35:\n        # Single-bit flip\n        i = random.randrange(n)\n        s[i] = '1' if s[i]=='0' else '0'\n        move = (\"BITFLIP\", \"SINGLE\")\n    elif r < 0.65:\n        # Two-bit flip\n        i, j = random.sample(range(n), 2)\n        s[i] = '1' if s[i]=='0' else '0'\n        s[j] = '1' if s[j]=='0' else '0'\n        move = (\"BITFLIP\", \"DOUBLE\")\n    elif r < 0.85:\n        # Block flip (3-6 bits)\n        k = random.randint(3,6)\n        for i in random.sample(range(n), k):\n            s[i] = '1' if s[i]=='0' else '0'\n        move = (\"BITFLIP\", \"BLOCK\")\n    else:\n        # Swap add\/drop if possible\n        zeros = [i for i,ch in enumerate(s) if ch=='0']\n        ones = [i for i,ch in enumerate(s) if ch=='1']\n        if zeros and ones:\n            i = random.choice(zeros); j = random.choice(ones)\n            s[i] = '1'; s[j] = '0'\n            move = (\"SWAP\", \"ADD_DROP\")\n        else:\n            k = random.randrange(n)\n            s[k] = '1' if s[k]=='0' else '0'\n            move = (\"BITFLIP\", \"FALLBACK\")\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n    local_exchange(s)\n    neighbor = ''.join(s)\n    return neighbor, move\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution):\n    # Normalize and validate\n    solution = str(solution).strip()\n    if not isinstance(solution, str) or any(ch not in '01' for ch in solution):\n        raise ValueError('solution must be a binary string')\n    n = len(solution)\n    if n != 24:\n        raise ValueError('solution length must be 24')\n\n    offers: List[Tuple[int,int]] = [\n        (15,11),(5,2),(9,24),(20,3),(5,15),(16,9),(4,12),(18,1),\n        (14,21),(13,19),(11,22),(6,22),(24,9),(5,1),(6,13),(22,16),\n        (23,21),(21,5),(14,6),(1,10),(1,13),(11,8),(1,12),(17,9)\n    ]\n    required = 275\n\n    def cost_per_gal(i: int) -> float:\n        c, g = offers[i]\n        return c \/ g\n\n    def repair_to_feasible(bits: List[str]) -> List[str]:\n        total_g = sum(offers[i][1] for i,ch in enumerate(bits) if ch=='1')\n        if total_g >= required:\n            return bits\n        order = sorted(range(n), key=lambda i: cost_per_gal(i))\n        for i in order:\n            if bits[i] == '0':\n                bits[i] = '1'\n                total_g += offers[i][1]\n                if total_g >= required:\n                    break\n        if total_g < required:\n            raise RuntimeError('repair failed to reach feasibility')\n        return bits\n\n    def prune_to_improve(bits: List[str]) -> List[str]:\n        sel = [i for i,ch in enumerate(bits) if ch=='1']\n        total_g = sum(offers[i][1] for i in sel)\n        for i in sorted(sel, key=lambda i: cost_per_gal(i), reverse=True):\n            g_i = offers[i][1]\n            if total_g - g_i >= required:\n                bits[i] = '0'\n                total_g -= g_i\n        return bits\n\n    s = list(solution)\n\n    # Ruin: flip k bits (adaptive strength)\n    k = random.randint(4, 8)\n    for i in random.sample(range(n), k):\n        s[i] = '1' if s[i]=='0' else '0'\n\n    # Optional biased cleanup: drop a few worst c\/g with small probability\n    if random.random() < 0.5:\n        ones = [i for i,ch in enumerate(s) if ch=='1']\n        for i in sorted(ones, key=lambda i: cost_per_gal(i), reverse=True)[:2]:\n            s[i] = '0'\n\n    s = repair_to_feasible(s)\n    s = prune_to_improve(s)\n\n    return ''.join(s)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type List cannot be instantiated; use list() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0014128371}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: binary string length 24, '1' means friend visits the attraction\n    # Objective: minimize total score with time >= 2750 minutes\n    # Returns fitness (lower is better). Infeasible solutions are penalized.\n    if not isinstance(solution, str):\n        return 10**12\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return 10**12\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times =  [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    total_score = 0\n    total_time = 0\n    for i,ch in enumerate(solution):\n        if ch == '1':\n            total_score += scores[i]\n            total_time += times[i]\n    required_time = 2750\n    if total_time >= required_time:\n        return float(total_score)\n    # Penalize infeasible: large base penalty + proportional to shortfall\n    shortfall = required_time - total_time\n    return 1_000_000.0 + 1_000.0*shortfall + float(total_score)","Vecindad":"import random\n\n# Returns (neighbour_solution, movement_type)\n# Annotation retained per spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str) or len(solution) != 24:\n        # Generate a random valid solution if input invalid\n        base = ''.join(random.choice('01') for _ in range(24))\n        # Ensure feasibility likelihood by biasing to 1s\n        solution = base\n    # Single bit flip neighbour\n    idx = random.randrange(24)\n    lst = list(solution)\n    lst[idx] = '1' if lst[idx] == '0' else '0'\n    neighbour = ''.join(lst)\n    return neighbour, \"BIT_FLIP_1\"","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong perturbation: flip k random bits (k in [2,6])\n    if not isinstance(solution, str) or len(solution) != 24:\n        solution = ''.join(random.choice('01') for _ in range(24))\n    k = random.randint(2,6)\n    idxs = random.sample(range(24), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)","Resultados":["111111111111110111111111",1040276.0,"111111111111110111111111",1040276.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000716679}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: binary string length 24, '1' means friend visits the attraction\n    # Objective: minimize total score with time >= 2750 minutes\n    # Returns fitness (lower is better). Infeasible solutions are penalized.\n    if not isinstance(solution, str):\n        return 10**12\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return 10**12\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times =  [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    total_score = 0\n    total_time = 0\n    for i,ch in enumerate(solution):\n        if ch == '1':\n            total_score += scores[i]\n            total_time += times[i]\n    required_time = 2750\n    if total_time >= required_time:\n        return float(total_score)\n    # Penalize infeasible: large base penalty + proportional to shortfall\n    shortfall = required_time - total_time\n    return 1_000_000.0 + 1_000.0*shortfall + float(total_score)","Vecindad":"import random\n\n# Returns (neighbour_solution, movement_type)\n# Annotation retained per spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str) or len(solution) != 24:\n        # Generate a random valid solution if input invalid\n        base = ''.join(random.choice('01') for _ in range(24))\n        # Ensure feasibility likelihood by biasing to 1s\n        solution = base\n    # Single bit flip neighbour\n    idx = random.randrange(24)\n    lst = list(solution)\n    lst[idx] = '1' if lst[idx] == '0' else '0'\n    neighbour = ''.join(lst)\n    return neighbour, \"BIT_FLIP_1\"","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong perturbation: flip k random bits (k in [2,6])\n    if not isinstance(solution, str) or len(solution) != 24:\n        solution = ''.join(random.choice('01') for _ in range(24))\n    k = random.randint(2,6)\n    idxs = random.sample(range(24), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)","Resultados":["010100100111101010000100",2190170.0,"111001101111110010110010",1740161.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.000667667}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: binary string length 24, '1' means friend visits the attraction\n    # Objective: minimize total score with time >= 2750 minutes\n    # Returns fitness (lower is better). Infeasible solutions are penalized.\n    if not isinstance(solution, str):\n        return 10**12\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return 10**12\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times =  [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    total_score = 0\n    total_time = 0\n    for i,ch in enumerate(solution):\n        if ch == '1':\n            total_score += scores[i]\n            total_time += times[i]\n    required_time = 2750\n    if total_time >= required_time:\n        return float(total_score)\n    # Penalize infeasible: large base penalty + proportional to shortfall\n    shortfall = required_time - total_time\n    return 1_000_000.0 + 1_000.0*shortfall + float(total_score)","Vecindad":"import random\n\n# Returns (neighbour_solution, movement_type)\n# Annotation retained per spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, str) or len(solution) != 24:\n        # Generate a random valid solution if input invalid\n        base = ''.join(random.choice('01') for _ in range(24))\n        # Ensure feasibility likelihood by biasing to 1s\n        solution = base\n    # Single bit flip neighbour\n    idx = random.randrange(24)\n    lst = list(solution)\n    lst[idx] = '1' if lst[idx] == '0' else '0'\n    neighbour = ''.join(lst)\n    return neighbour, \"BIT_FLIP_1\"","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong perturbation: flip k random bits (k in [2,6])\n    if not isinstance(solution, str) or len(solution) != 24:\n        solution = ''.join(random.choice('01') for _ in range(24))\n    k = random.randint(2,6)\n    idxs = random.sample(range(24), k)\n    lst = list(solution)\n    for i in idxs:\n        lst[i] = '1' if lst[i] == '0' else '0'\n    return ''.join(lst)","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.0003746451}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; bit i == '1' means friend visits attraction i+1; feasibility: sum(times[bit==1]) >= 2750","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: binary string length 24, '1' means friend visits the attraction\n    # Objective: minimize total score with total time >= 2750 minutes\n    # Returns numeric fitness (lower is better). Infeasible solutions are penalized lexicographically by violation first.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    # Validate\n    if not isinstance(solution, str):\n        return 1e15\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return 1e15\n    total_score = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_score += scores[i]\n            total_time += times[i]\n    if total_time >= required_time:\n        return float(total_score)\n    shortfall = required_time - total_time\n    # Lexicographic penalty: any violation dominates score; 1e6 per minute ensures that\n    return float(shortfall) * 1_000_000.0 + float(total_score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor using excluded-set capacity (sum of excluded times <= 90)\n    # If input invalid, construct a feasible solution near the boundary first.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    n = 24\n    def construct_feasible():\n        # Start with all 1s and flip down by best score\/time until time == 2750\n        included = [1]*n\n        total_time = sum(times)\n        if total_time < required_time:\n            return ''.join('1' if b==1 else '0' for b in included)\n        # Greedily exclude items with highest score\/time while respecting boundary\n        items = list(range(n))\n        items.sort(key=lambda i: (scores[i]\/times[i], scores[i]), reverse=True)\n        for i in items:\n            if total_time - times[i] >= required_time:\n                included[i] = 0\n                total_time -= times[i]\n            if total_time == required_time:\n                break\n        return ''.join('1' if b==1 else '0' for b in included)\n    # Ensure valid base solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    # Repair if infeasible: include items until time >= required_time\n    lst = list(solution)\n    total_time = sum(times[i] for i,ch in enumerate(lst) if ch=='1')\n    if total_time < required_time:\n        # Add lowest score\/time ratio items first\n        candidates = [i for i,ch in enumerate(lst) if ch=='0']\n        candidates.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in candidates:\n            lst[i] = '1'\n            total_time += times[i]\n            if total_time >= required_time:\n                break\n    # Maintain excluded capacity view\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    excluded_time = sum(times[i] for i in excluded)\n    # If excluded time > 90, include back some excluded (repair)\n    if excluded_time > 90:\n        # Include back the worst value-per-time excluded first (minimize score loss of including)\n        excluded.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in excluded:\n            lst[i] = '1'\n            excluded_time -= times[i]\n            if excluded_time <= 90:\n                break\n    # Now perform a capacity-feasible move\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    included = [i for i,ch in enumerate(lst) if ch=='1']\n    excluded_time = sum(times[i] for i in excluded)\n    cap = 90\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.4 and included:\n        # Try to exclude one included item if capacity allows\n        i = random.choice(included)\n        if excluded_time + times[i] <= cap:\n            lst[i] = '0'\n            move_type = \"EXCLUDE_ONE\"\n        else:\n            move_type = \"FAILED_EXCLUDE\"\n    elif r < 0.8 and excluded:\n        # Include one excluded item back (always feasible)\n        i = random.choice(excluded)\n        lst[i] = '1'\n        move_type = \"INCLUDE_ONE\"\n    else:\n        # Try a swap: include one excluded j and exclude one included i to keep capacity\n        if excluded and included:\n            j = random.choice(excluded)\n            need = max(0, excluded_time - cap + times[j])  # we must free at least this much time by excluding from included\n            # choose i with times[i] >= need (prefer low score\/time to minimize damage to objective)\n            feasibles = [i for i in included if times[i] >= need]\n            if feasibles:\n                feasibles.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n                i = feasibles[0]\n                lst[j] = '1'\n                lst[i] = '0'\n                move_type = \"SWAP_INCL_EXCL\"\n            else:\n                move_type = \"FAILED_SWAP\"\n    neighbour = ''.join(lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, feasibility-preserving perturbation under excluded capacity view (sum excluded times <= 90)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    n = 24\n    # Validate and quick repair to feasibility (as in NB)\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        # Construct a feasible boundary solution: all 1s then drop until boundary\n        included = [1]*n\n        total_time = sum(times)\n        items = list(range(n))\n        items.sort(key=lambda i: (scores[i]\/times[i], scores[i]), reverse=True)\n        for i in items:\n            if total_time - times[i] >= required_time:\n                included[i] = 0\n                total_time -= times[i]\n            if total_time == required_time:\n                break\n        solution = ''.join('1' if b==1 else '0' for b in included)\n    lst = list(solution)\n    # Ensure feasibility first\n    total_time = sum(times[i] for i,ch in enumerate(lst) if ch=='1')\n    if total_time < required_time:\n        zeros = [i for i,ch in enumerate(lst) if ch=='0']\n        zeros.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in zeros:\n            lst[i] = '1'\n            total_time += times[i]\n            if total_time >= required_time:\n                break\n    # Excluded capacity\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    included = [i for i,ch in enumerate(lst) if ch=='1']\n    excluded_time = sum(times[i] for i in excluded)\n    cap = 90\n    if excluded_time > cap:\n        # repair by including back some excluded\n        excluded.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in excluded:\n            lst[i] = '1'\n            excluded_time -= times[i]\n            if excluded_time <= cap:\n                break\n    # Apply K random feasible moves\n    K = random.randint(3, 6)\n    for _ in range(K):\n        excluded = [i for i,ch in enumerate(lst) if ch=='0']\n        included = [i for i,ch in enumerate(lst) if ch=='1']\n        excluded_time = sum(times[i] for i in excluded)\n        cap = 90\n        move_done = False\n        # with 50% chance, try exclude one included if capacity allows\n        if included and random.random() < 0.5:\n            i = random.choice(included)\n            if excluded_time + times[i] <= cap:\n                lst[i] = '0'\n                move_done = True\n        if not move_done and excluded:\n            # try include one excluded and exclude one included to keep within capacity\n            j = random.choice(excluded)\n            need = max(0, excluded_time - cap + times[j])\n            feasibles = [i for i in included if times[i] >= need]\n            if feasibles:\n                # choose i with lowest score\/time to minimize damage\n                i = min(feasibles, key=lambda x: (scores[x]\/times[x], scores[x]))\n                lst[j] = '1'\n                lst[i] = '0'\n                move_done = True\n        if not move_done and excluded:\n            # fallback: include one excluded (always feasible w.r.t. original constraint)\n            j = random.choice(excluded)\n            lst[j] = '1'\n    return ''.join(lst)\n","Resultados":["111111111111101111011111",268.0,"101011101111101111111111",234.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.001524148}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; bit i == '1' means friend visits attraction i+1; feasibility: sum(times[bit==1]) >= 2750","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: binary string length 24, '1' means friend visits the attraction\n    # Objective: minimize total score with total time >= 2750 minutes\n    # Returns numeric fitness (lower is better). Infeasible solutions are penalized lexicographically by violation first.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    # Validate\n    if not isinstance(solution, str):\n        return 1e15\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return 1e15\n    total_score = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_score += scores[i]\n            total_time += times[i]\n    if total_time >= required_time:\n        return float(total_score)\n    shortfall = required_time - total_time\n    # Lexicographic penalty: any violation dominates score; 1e6 per minute ensures that\n    return float(shortfall) * 1_000_000.0 + float(total_score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor using excluded-set capacity (sum of excluded times <= 90)\n    # If input invalid, construct a feasible solution near the boundary first.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    n = 24\n    def construct_feasible():\n        # Start with all 1s and flip down by best score\/time until time == 2750\n        included = [1]*n\n        total_time = sum(times)\n        if total_time < required_time:\n            return ''.join('1' if b==1 else '0' for b in included)\n        # Greedily exclude items with highest score\/time while respecting boundary\n        items = list(range(n))\n        items.sort(key=lambda i: (scores[i]\/times[i], scores[i]), reverse=True)\n        for i in items:\n            if total_time - times[i] >= required_time:\n                included[i] = 0\n                total_time -= times[i]\n            if total_time == required_time:\n                break\n        return ''.join('1' if b==1 else '0' for b in included)\n    # Ensure valid base solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    # Repair if infeasible: include items until time >= required_time\n    lst = list(solution)\n    total_time = sum(times[i] for i,ch in enumerate(lst) if ch=='1')\n    if total_time < required_time:\n        # Add lowest score\/time ratio items first\n        candidates = [i for i,ch in enumerate(lst) if ch=='0']\n        candidates.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in candidates:\n            lst[i] = '1'\n            total_time += times[i]\n            if total_time >= required_time:\n                break\n    # Maintain excluded capacity view\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    excluded_time = sum(times[i] for i in excluded)\n    # If excluded time > 90, include back some excluded (repair)\n    if excluded_time > 90:\n        # Include back the worst value-per-time excluded first (minimize score loss of including)\n        excluded.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in excluded:\n            lst[i] = '1'\n            excluded_time -= times[i]\n            if excluded_time <= 90:\n                break\n    # Now perform a capacity-feasible move\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    included = [i for i,ch in enumerate(lst) if ch=='1']\n    excluded_time = sum(times[i] for i in excluded)\n    cap = 90\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.4 and included:\n        # Try to exclude one included item if capacity allows\n        i = random.choice(included)\n        if excluded_time + times[i] <= cap:\n            lst[i] = '0'\n            move_type = \"EXCLUDE_ONE\"\n        else:\n            move_type = \"FAILED_EXCLUDE\"\n    elif r < 0.8 and excluded:\n        # Include one excluded item back (always feasible)\n        i = random.choice(excluded)\n        lst[i] = '1'\n        move_type = \"INCLUDE_ONE\"\n    else:\n        # Try a swap: include one excluded j and exclude one included i to keep capacity\n        if excluded and included:\n            j = random.choice(excluded)\n            need = max(0, excluded_time - cap + times[j])  # we must free at least this much time by excluding from included\n            # choose i with times[i] >= need (prefer low score\/time to minimize damage to objective)\n            feasibles = [i for i in included if times[i] >= need]\n            if feasibles:\n                feasibles.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n                i = feasibles[0]\n                lst[j] = '1'\n                lst[i] = '0'\n                move_type = \"SWAP_INCL_EXCL\"\n            else:\n                move_type = \"FAILED_SWAP\"\n    neighbour = ''.join(lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, feasibility-preserving perturbation under excluded capacity view (sum excluded times <= 90)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    n = 24\n    # Validate and quick repair to feasibility (as in NB)\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        # Construct a feasible boundary solution: all 1s then drop until boundary\n        included = [1]*n\n        total_time = sum(times)\n        items = list(range(n))\n        items.sort(key=lambda i: (scores[i]\/times[i], scores[i]), reverse=True)\n        for i in items:\n            if total_time - times[i] >= required_time:\n                included[i] = 0\n                total_time -= times[i]\n            if total_time == required_time:\n                break\n        solution = ''.join('1' if b==1 else '0' for b in included)\n    lst = list(solution)\n    # Ensure feasibility first\n    total_time = sum(times[i] for i,ch in enumerate(lst) if ch=='1')\n    if total_time < required_time:\n        zeros = [i for i,ch in enumerate(lst) if ch=='0']\n        zeros.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in zeros:\n            lst[i] = '1'\n            total_time += times[i]\n            if total_time >= required_time:\n                break\n    # Excluded capacity\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    included = [i for i,ch in enumerate(lst) if ch=='1']\n    excluded_time = sum(times[i] for i in excluded)\n    cap = 90\n    if excluded_time > cap:\n        # repair by including back some excluded\n        excluded.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in excluded:\n            lst[i] = '1'\n            excluded_time -= times[i]\n            if excluded_time <= cap:\n                break\n    # Apply K random feasible moves\n    K = random.randint(3, 6)\n    for _ in range(K):\n        excluded = [i for i,ch in enumerate(lst) if ch=='0']\n        included = [i for i,ch in enumerate(lst) if ch=='1']\n        excluded_time = sum(times[i] for i in excluded)\n        cap = 90\n        move_done = False\n        # with 50% chance, try exclude one included if capacity allows\n        if included and random.random() < 0.5:\n            i = random.choice(included)\n            if excluded_time + times[i] <= cap:\n                lst[i] = '0'\n                move_done = True\n        if not move_done and excluded:\n            # try include one excluded and exclude one included to keep within capacity\n            j = random.choice(excluded)\n            need = max(0, excluded_time - cap + times[j])\n            feasibles = [i for i in included if times[i] >= need]\n            if feasibles:\n                # choose i with lowest score\/time to minimize damage\n                i = min(feasibles, key=lambda x: (scores[x]\/times[x], scores[x]))\n                lst[j] = '1'\n                lst[i] = '0'\n                move_done = True\n        if not move_done and excluded:\n            # fallback: include one excluded (always feasible w.r.t. original constraint)\n            j = random.choice(excluded)\n            lst[j] = '1'\n    return ''.join(lst)\n","Resultados":["111111111111111111111110",239.0,111011101111111110111111,239.0],"Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00252744}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_LEN_24; bit i == '1' means friend visits attraction i+1; feasibility: sum(times[bit==1]) >= 2750","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # solution: binary string length 24, '1' means friend visits the attraction\n    # Objective: minimize total score with total time >= 2750 minutes\n    # Returns numeric fitness (lower is better). Infeasible solutions are penalized lexicographically by violation first.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    # Validate\n    if not isinstance(solution, str):\n        return 1e15\n    if len(solution) != 24 or any(c not in '01' for c in solution):\n        return 1e15\n    total_score = 0\n    total_time = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_score += scores[i]\n            total_time += times[i]\n    if total_time >= required_time:\n        return float(total_score)\n    shortfall = required_time - total_time\n    # Lexicographic penalty: any violation dominates score; 1e6 per minute ensures that\n    return float(shortfall) * 1_000_000.0 + float(total_score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Feasibility-preserving neighbor using excluded-set capacity (sum of excluded times <= 90)\n    # If input invalid, construct a feasible solution near the boundary first.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    n = 24\n    def construct_feasible():\n        # Start with all 1s and flip down by best score\/time until time == 2750\n        included = [1]*n\n        total_time = sum(times)\n        if total_time < required_time:\n            return ''.join('1' if b==1 else '0' for b in included)\n        # Greedily exclude items with highest score\/time while respecting boundary\n        items = list(range(n))\n        items.sort(key=lambda i: (scores[i]\/times[i], scores[i]), reverse=True)\n        for i in items:\n            if total_time - times[i] >= required_time:\n                included[i] = 0\n                total_time -= times[i]\n            if total_time == required_time:\n                break\n        return ''.join('1' if b==1 else '0' for b in included)\n    # Ensure valid base solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    # Repair if infeasible: include items until time >= required_time\n    lst = list(solution)\n    total_time = sum(times[i] for i,ch in enumerate(lst) if ch=='1')\n    if total_time < required_time:\n        # Add lowest score\/time ratio items first\n        candidates = [i for i,ch in enumerate(lst) if ch=='0']\n        candidates.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in candidates:\n            lst[i] = '1'\n            total_time += times[i]\n            if total_time >= required_time:\n                break\n    # Maintain excluded capacity view\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    excluded_time = sum(times[i] for i in excluded)\n    # If excluded time > 90, include back some excluded (repair)\n    if excluded_time > 90:\n        # Include back the worst value-per-time excluded first (minimize score loss of including)\n        excluded.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in excluded:\n            lst[i] = '1'\n            excluded_time -= times[i]\n            if excluded_time <= 90:\n                break\n    # Now perform a capacity-feasible move\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    included = [i for i,ch in enumerate(lst) if ch=='1']\n    excluded_time = sum(times[i] for i in excluded)\n    cap = 90\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.4 and included:\n        # Try to exclude one included item if capacity allows\n        i = random.choice(included)\n        if excluded_time + times[i] <= cap:\n            lst[i] = '0'\n            move_type = \"EXCLUDE_ONE\"\n        else:\n            move_type = \"FAILED_EXCLUDE\"\n    elif r < 0.8 and excluded:\n        # Include one excluded item back (always feasible)\n        i = random.choice(excluded)\n        lst[i] = '1'\n        move_type = \"INCLUDE_ONE\"\n    else:\n        # Try a swap: include one excluded j and exclude one included i to keep capacity\n        if excluded and included:\n            j = random.choice(excluded)\n            need = max(0, excluded_time - cap + times[j])  # we must free at least this much time by excluding from included\n            # choose i with times[i] >= need (prefer low score\/time to minimize damage to objective)\n            feasibles = [i for i in included if times[i] >= need]\n            if feasibles:\n                feasibles.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n                i = feasibles[0]\n                lst[j] = '1'\n                lst[i] = '0'\n                move_type = \"SWAP_INCL_EXCL\"\n            else:\n                move_type = \"FAILED_SWAP\"\n    neighbour = ''.join(lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, feasibility-preserving perturbation under excluded capacity view (sum excluded times <= 90)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    required_time = 2750\n    n = 24\n    # Validate and quick repair to feasibility (as in NB)\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        # Construct a feasible boundary solution: all 1s then drop until boundary\n        included = [1]*n\n        total_time = sum(times)\n        items = list(range(n))\n        items.sort(key=lambda i: (scores[i]\/times[i], scores[i]), reverse=True)\n        for i in items:\n            if total_time - times[i] >= required_time:\n                included[i] = 0\n                total_time -= times[i]\n            if total_time == required_time:\n                break\n        solution = ''.join('1' if b==1 else '0' for b in included)\n    lst = list(solution)\n    # Ensure feasibility first\n    total_time = sum(times[i] for i,ch in enumerate(lst) if ch=='1')\n    if total_time < required_time:\n        zeros = [i for i,ch in enumerate(lst) if ch=='0']\n        zeros.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in zeros:\n            lst[i] = '1'\n            total_time += times[i]\n            if total_time >= required_time:\n                break\n    # Excluded capacity\n    excluded = [i for i,ch in enumerate(lst) if ch=='0']\n    included = [i for i,ch in enumerate(lst) if ch=='1']\n    excluded_time = sum(times[i] for i in excluded)\n    cap = 90\n    if excluded_time > cap:\n        # repair by including back some excluded\n        excluded.sort(key=lambda i: (scores[i]\/times[i], scores[i]))\n        for i in excluded:\n            lst[i] = '1'\n            excluded_time -= times[i]\n            if excluded_time <= cap:\n                break\n    # Apply K random feasible moves\n    K = random.randint(3, 6)\n    for _ in range(K):\n        excluded = [i for i,ch in enumerate(lst) if ch=='0']\n        included = [i for i,ch in enumerate(lst) if ch=='1']\n        excluded_time = sum(times[i] for i in excluded)\n        cap = 90\n        move_done = False\n        # with 50% chance, try exclude one included if capacity allows\n        if included and random.random() < 0.5:\n            i = random.choice(included)\n            if excluded_time + times[i] <= cap:\n                lst[i] = '0'\n                move_done = True\n        if not move_done and excluded:\n            # try include one excluded and exclude one included to keep within capacity\n            j = random.choice(excluded)\n            need = max(0, excluded_time - cap + times[j])\n            feasibles = [i for i in included if times[i] >= need]\n            if feasibles:\n                # choose i with lowest score\/time to minimize damage\n                i = min(feasibles, key=lambda x: (scores[x]\/times[x], scores[x]))\n                lst[j] = '1'\n                lst[i] = '0'\n                move_done = True\n        if not move_done and excluded:\n            # fallback: include one excluded (always feasible w.r.t. original constraint)\n            j = random.choice(excluded)\n            lst[j] = '1'\n    return ''.join(lst)\n","Resultados":"Failed to run target heuristic: too many values to unpack (expected 2).  Signature def TS(solution,best_sol, best_score, generate_neighbour(), evaluate_solution(), iterations, taboo_list_size, taboo_duration)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001444757}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_EXCLUSION_LEN_24; bit i == '1' means friend EXCLUDES attraction (i+1). Constraint enforced in search: sum(times[bit==1]) <= 90 minutes. Included set (zeros) is what the friend visits. Objective: minimize sum(scores of INCLUDED).","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string, '1' = EXCLUDED, capacity: sum(excluded times) <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap_excl_time = 90\n    n = 24\n    # Validation\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 1e15\n    excl_time = 0\n    excl_score = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            excl_time += times[i]\n            excl_score += scores[i]\n    # Capacity violation => heavy penalty; lexicographic via large scale\n    if excl_time > cap_excl_time:\n        return float((excl_time - cap_excl_time) * 1_000_000 + (sum(scores) - excl_score))\n    included_score = sum(scores) - excl_score\n    return float(included_score)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Exclusion-space neighbor under capacity: sum(excluded times) <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap = 90\n    n = 24\n\n    def construct_feasible():\n        # Start with empty exclusion, then greedily add high-score items fitting in remaining capacity\n        # Primary key: score descending; tie-breaker: score\/time descending then shorter time\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i]), -times[i]), reverse=True)\n        excl = [0]*n\n        rem = cap\n        for i in idx:\n            if times[i] <= rem:\n                excl[i] = 1\n                rem -= times[i]\n        return ''.join('1' if b==1 else '0' for b in excl)\n\n    # Validate\/repair input\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    lst = [1 if c=='1' else 0 for c in solution]\n    excl_time = sum(times[i] for i,b in enumerate(lst) if b==1)\n    # If capacity violated, repair by dropping lowest-value exclusions first (by score then ratio)\n    if excl_time > cap:\n        ones = [i for i,b in enumerate(lst) if b==1]\n        ones.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i])), reverse=False)\n        for i in ones:\n            if excl_time <= cap:\n                break\n            lst[i] = 0\n            excl_time -= times[i]\n    # Sets\n    excluded = [i for i,b in enumerate(lst) if b==1]\n    included = [i for i,b in enumerate(lst) if b==0]\n\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.4:\n        # Try add-one-exclusion: pick included j that fits\n        candidates = [j for j in included if excl_time + times[j] <= cap]\n        if candidates:\n            # Bias toward higher score for exclusion (reduces objective most)\n            j = max(candidates, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            lst[j] = 1\n            move_type = \"ADD_EXCLUSION\"\n        else:\n            move_type = \"FAILED_ADD\"\n    elif r < 0.8:\n        # Drop-one-exclusion: remove a currently excluded i (prefer low-score first to diversify)\n        if excluded:\n            i = min(excluded, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            lst[i] = 0\n            move_type = \"DROP_EXCLUSION\"\n        else:\n            move_type = \"FAILED_DROP\"\n    else:\n        # Swap-exclusion: include j (currently included) and drop i (currently excluded) with time feasibility\n        if excluded and included:\n            j = max(included, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            need = excl_time + times[j] - cap\n            # choose i with times[i] >= need; among feasibles, drop lowest-score to keep quality\n            feas = [i for i in excluded if times[i] >= max(0, need)]\n            if feas:\n                i = min(feas, key=lambda x: (scores[x], times[x]))\n                lst[j] = 1\n                lst[i] = 0\n                move_type = \"SWAP_EXCLUSION\"\n            else:\n                move_type = \"FAILED_SWAP\"\n        else:\n            move_type = \"FAILED_SWAP_EMPTY\"\n\n    neighbour = ''.join('1' if b==1 else '0' for b in lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger exclusion-space shake while preserving capacity <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap = 90\n    n = 24\n\n    def construct_feasible():\n        # Greedy-max score packing under 90-minute capacity\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i]), -times[i]), reverse=True)\n        excl = [0]*n\n        rem = cap\n        for i in idx:\n            if times[i] <= rem:\n                excl[i] = 1\n                rem -= times[i]\n        return ''.join('1' if b==1 else '0' for b in excl)\n\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n\n    lst = [1 if c=='1' else 0 for c in solution]\n    excl_time = sum(times[i] for i,b in enumerate(lst) if b==1)\n    # Repair if needed\n    if excl_time > cap:\n        ones = [i for i,b in enumerate(lst) if b==1]\n        ones.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i])))\n        for i in ones:\n            if excl_time <= cap:\n                break\n            lst[i] = 0\n            excl_time -= times[i]\n\n    # Apply K random feasible mutations\n    K = random.randint(3, 6)\n    for _ in range(K):\n        # 50%: try add; 30%: swap; 20%: drop\n        p = random.random()\n        if p < 0.5:\n            included = [i for i,b in enumerate(lst) if b==0]\n            candidates = [j for j in included if excl_time + times[j] <= cap]\n            if candidates:\n                j = random.choice(candidates)\n                lst[j] = 1\n                excl_time += times[j]\n        elif p < 0.8:\n            excluded = [i for i,b in enumerate(lst) if b==1]\n            included = [i for i,b in enumerate(lst) if b==0]\n            if excluded and included:\n                j = random.choice(included)\n                need = excl_time + times[j] - cap\n                feas = [i for i in excluded if times[i] >= max(0, need)]\n                if feas:\n                    i = random.choice(feas)\n                    lst[i] = 0\n                    excl_time -= times[i]\n                    lst[j] = 1\n                    excl_time += times[j]\n        else:\n            excluded = [i for i,b in enumerate(lst) if b==1]\n            if excluded:\n                i = random.choice(excluded)\n                lst[i] = 0\n                excl_time -= times[i]\n\n    return ''.join('1' if b==1 else '0' for b in lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000016}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_EXCLUSION_LEN_24; bit i == '1' means friend EXCLUDES attraction (i+1). Constraint enforced in search: sum(times[bit==1]) <= 90 minutes. Included set (zeros) is what the friend visits. Objective: minimize sum(scores of INCLUDED).","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string, '1' = EXCLUDED, capacity: sum(excluded times) <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap_excl_time = 90\n    n = 24\n    # Validation\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 1e15\n    excl_time = 0\n    excl_score = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            excl_time += times[i]\n            excl_score += scores[i]\n    # Capacity violation => heavy penalty; lexicographic via large scale\n    if excl_time > cap_excl_time:\n        return float((excl_time - cap_excl_time) * 1_000_000 + (sum(scores) - excl_score))\n    included_score = sum(scores) - excl_score\n    return float(included_score)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Exclusion-space neighbor under capacity: sum(excluded times) <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap = 90\n    n = 24\n\n    def construct_feasible():\n        # Start with empty exclusion, then greedily add high-score items fitting in remaining capacity\n        # Primary key: score descending; tie-breaker: score\/time descending then shorter time\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i]), -times[i]), reverse=True)\n        excl = [0]*n\n        rem = cap\n        for i in idx:\n            if times[i] <= rem:\n                excl[i] = 1\n                rem -= times[i]\n        return ''.join('1' if b==1 else '0' for b in excl)\n\n    # Validate\/repair input\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    lst = [1 if c=='1' else 0 for c in solution]\n    excl_time = sum(times[i] for i,b in enumerate(lst) if b==1)\n    # If capacity violated, repair by dropping lowest-value exclusions first (by score then ratio)\n    if excl_time > cap:\n        ones = [i for i,b in enumerate(lst) if b==1]\n        ones.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i])), reverse=False)\n        for i in ones:\n            if excl_time <= cap:\n                break\n            lst[i] = 0\n            excl_time -= times[i]\n    # Sets\n    excluded = [i for i,b in enumerate(lst) if b==1]\n    included = [i for i,b in enumerate(lst) if b==0]\n\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.4:\n        # Try add-one-exclusion: pick included j that fits\n        candidates = [j for j in included if excl_time + times[j] <= cap]\n        if candidates:\n            # Bias toward higher score for exclusion (reduces objective most)\n            j = max(candidates, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            lst[j] = 1\n            move_type = \"ADD_EXCLUSION\"\n        else:\n            move_type = \"FAILED_ADD\"\n    elif r < 0.8:\n        # Drop-one-exclusion: remove a currently excluded i (prefer low-score first to diversify)\n        if excluded:\n            i = min(excluded, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            lst[i] = 0\n            move_type = \"DROP_EXCLUSION\"\n        else:\n            move_type = \"FAILED_DROP\"\n    else:\n        # Swap-exclusion: include j (currently included) and drop i (currently excluded) with time feasibility\n        if excluded and included:\n            j = max(included, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            need = excl_time + times[j] - cap\n            # choose i with times[i] >= need; among feasibles, drop lowest-score to keep quality\n            feas = [i for i in excluded if times[i] >= max(0, need)]\n            if feas:\n                i = min(feas, key=lambda x: (scores[x], times[x]))\n                lst[j] = 1\n                lst[i] = 0\n                move_type = \"SWAP_EXCLUSION\"\n            else:\n                move_type = \"FAILED_SWAP\"\n        else:\n            move_type = \"FAILED_SWAP_EMPTY\"\n\n    neighbour = ''.join('1' if b==1 else '0' for b in lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger exclusion-space shake while preserving capacity <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap = 90\n    n = 24\n\n    def construct_feasible():\n        # Greedy-max score packing under 90-minute capacity\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i]), -times[i]), reverse=True)\n        excl = [0]*n\n        rem = cap\n        for i in idx:\n            if times[i] <= rem:\n                excl[i] = 1\n                rem -= times[i]\n        return ''.join('1' if b==1 else '0' for b in excl)\n\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n\n    lst = [1 if c=='1' else 0 for c in solution]\n    excl_time = sum(times[i] for i,b in enumerate(lst) if b==1)\n    # Repair if needed\n    if excl_time > cap:\n        ones = [i for i,b in enumerate(lst) if b==1]\n        ones.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i])))\n        for i in ones:\n            if excl_time <= cap:\n                break\n            lst[i] = 0\n            excl_time -= times[i]\n\n    # Apply K random feasible mutations\n    K = random.randint(3, 6)\n    for _ in range(K):\n        # 50%: try add; 30%: swap; 20%: drop\n        p = random.random()\n        if p < 0.5:\n            included = [i for i,b in enumerate(lst) if b==0]\n            candidates = [j for j in included if excl_time + times[j] <= cap]\n            if candidates:\n                j = random.choice(candidates)\n                lst[j] = 1\n                excl_time += times[j]\n        elif p < 0.8:\n            excluded = [i for i,b in enumerate(lst) if b==1]\n            included = [i for i,b in enumerate(lst) if b==0]\n            if excluded and included:\n                j = random.choice(included)\n                need = excl_time + times[j] - cap\n                feas = [i for i in excluded if times[i] >= max(0, need)]\n                if feas:\n                    i = random.choice(feas)\n                    lst[i] = 0\n                    excl_time -= times[i]\n                    lst[j] = 1\n                    excl_time += times[j]\n        else:\n            excluded = [i for i,b in enumerate(lst) if b==1]\n            if excluded:\n                i = random.choice(excluded)\n                lst[i] = 0\n                excl_time -= times[i]\n\n    return ''.join('1' if b==1 else '0' for b in lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.00000404}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"BIN_STR_EXCLUSION_LEN_24; bit i == '1' means friend EXCLUDES attraction (i+1). Constraint enforced in search: sum(times[bit==1]) <= 90 minutes. Included set (zeros) is what the friend visits. Objective: minimize sum(scores of INCLUDED).","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit binary string, '1' = EXCLUDED, capacity: sum(excluded times) <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap_excl_time = 90\n    n = 24\n    # Validation\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 1e15\n    excl_time = 0\n    excl_score = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            excl_time += times[i]\n            excl_score += scores[i]\n    # Capacity violation => heavy penalty; lexicographic via large scale\n    if excl_time > cap_excl_time:\n        return float((excl_time - cap_excl_time) * 1_000_000 + (sum(scores) - excl_score))\n    included_score = sum(scores) - excl_score\n    return float(included_score)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Exclusion-space neighbor under capacity: sum(excluded times) <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap = 90\n    n = 24\n\n    def construct_feasible():\n        # Start with empty exclusion, then greedily add high-score items fitting in remaining capacity\n        # Primary key: score descending; tie-breaker: score\/time descending then shorter time\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i]), -times[i]), reverse=True)\n        excl = [0]*n\n        rem = cap\n        for i in idx:\n            if times[i] <= rem:\n                excl[i] = 1\n                rem -= times[i]\n        return ''.join('1' if b==1 else '0' for b in excl)\n\n    # Validate\/repair input\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    lst = [1 if c=='1' else 0 for c in solution]\n    excl_time = sum(times[i] for i,b in enumerate(lst) if b==1)\n    # If capacity violated, repair by dropping lowest-value exclusions first (by score then ratio)\n    if excl_time > cap:\n        ones = [i for i,b in enumerate(lst) if b==1]\n        ones.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i])), reverse=False)\n        for i in ones:\n            if excl_time <= cap:\n                break\n            lst[i] = 0\n            excl_time -= times[i]\n    # Sets\n    excluded = [i for i,b in enumerate(lst) if b==1]\n    included = [i for i,b in enumerate(lst) if b==0]\n\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.4:\n        # Try add-one-exclusion: pick included j that fits\n        candidates = [j for j in included if excl_time + times[j] <= cap]\n        if candidates:\n            # Bias toward higher score for exclusion (reduces objective most)\n            j = max(candidates, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            lst[j] = 1\n            move_type = \"ADD_EXCLUSION\"\n        else:\n            move_type = \"FAILED_ADD\"\n    elif r < 0.8:\n        # Drop-one-exclusion: remove a currently excluded i (prefer low-score first to diversify)\n        if excluded:\n            i = min(excluded, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            lst[i] = 0\n            move_type = \"DROP_EXCLUSION\"\n        else:\n            move_type = \"FAILED_DROP\"\n    else:\n        # Swap-exclusion: include j (currently included) and drop i (currently excluded) with time feasibility\n        if excluded and included:\n            j = max(included, key=lambda x: (scores[x], scores[x]\/max(1,times[x])))\n            need = excl_time + times[j] - cap\n            # choose i with times[i] >= need; among feasibles, drop lowest-score to keep quality\n            feas = [i for i in excluded if times[i] >= max(0, need)]\n            if feas:\n                i = min(feas, key=lambda x: (scores[x], times[x]))\n                lst[j] = 1\n                lst[i] = 0\n                move_type = \"SWAP_EXCLUSION\"\n            else:\n                move_type = \"FAILED_SWAP\"\n        else:\n            move_type = \"FAILED_SWAP_EMPTY\"\n\n    neighbour = ''.join('1' if b==1 else '0' for b in lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Stronger exclusion-space shake while preserving capacity <= 90\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    cap = 90\n    n = 24\n\n    def construct_feasible():\n        # Greedy-max score packing under 90-minute capacity\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i]), -times[i]), reverse=True)\n        excl = [0]*n\n        rem = cap\n        for i in idx:\n            if times[i] <= rem:\n                excl[i] = 1\n                rem -= times[i]\n        return ''.join('1' if b==1 else '0' for b in excl)\n\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n\n    lst = [1 if c=='1' else 0 for c in solution]\n    excl_time = sum(times[i] for i,b in enumerate(lst) if b==1)\n    # Repair if needed\n    if excl_time > cap:\n        ones = [i for i,b in enumerate(lst) if b==1]\n        ones.sort(key=lambda i: (scores[i], scores[i]\/max(1,times[i])))\n        for i in ones:\n            if excl_time <= cap:\n                break\n            lst[i] = 0\n            excl_time -= times[i]\n\n    # Apply K random feasible mutations\n    K = random.randint(3, 6)\n    for _ in range(K):\n        # 50%: try add; 30%: swap; 20%: drop\n        p = random.random()\n        if p < 0.5:\n            included = [i for i,b in enumerate(lst) if b==0]\n            candidates = [j for j in included if excl_time + times[j] <= cap]\n            if candidates:\n                j = random.choice(candidates)\n                lst[j] = 1\n                excl_time += times[j]\n        elif p < 0.8:\n            excluded = [i for i,b in enumerate(lst) if b==1]\n            included = [i for i,b in enumerate(lst) if b==0]\n            if excluded and included:\n                j = random.choice(included)\n                need = excl_time + times[j] - cap\n                feas = [i for i in excluded if times[i] >= max(0, need)]\n                if feas:\n                    i = random.choice(feas)\n                    lst[i] = 0\n                    excl_time -= times[i]\n                    lst[j] = 1\n                    excl_time += times[j]\n        else:\n            excluded = [i for i,b in enumerate(lst) if b==1]\n            if excluded:\n                i = random.choice(excluded)\n                lst[i] = 0\n                excl_time -= times[i]\n\n    return ''.join('1' if b==1 else '0' for b in lst)\n","Resultados":"Failed to load SAMPLE_SOL: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers (<unknown>, line 1)","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.00000287}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"24-bit binary string; bit i == '1' means the friend VISITS attraction (i+1). Objective: minimize total score of visited items subject to total visited time >= 2750 minutes. Solutions must be exactly 24 characters over {'0','1'}.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit string; '1' means VISITED. Minimize sum(scores[1s]) with constraint sum(times[1s]) >= 2750.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n    # Validate\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 1e15\n    total_time = 0\n    total_score = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_score += scores[i]\n    if total_time < req_time:\n        # Heavy lexicographic penalty prioritizing feasibility\n        return float((req_time - total_time) * 1_000_000 + total_score)\n    return float(total_score)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Inclusion-space neighbor. Ensures 24-bit validity; repairs to meet time >= 2750 when needed.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n\n    def construct_feasible():\n        # Greedy: add lowest score-per-time first until time >= req_time\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        sel = [0]*n\n        t = 0\n        for i in idx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        # If still short due to some pathology (shouldn't), continue adding by time desc\n        jdx = [i for i in range(n) if sel[i] == 0]\n        jdx.sort(key=lambda i: (-times[i], scores[i]))\n        for i in jdx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        return ''.join('1' if b==1 else '0' for b in sel)\n\n    def repair_to_feasible(lst):\n        # If time < req_time, greedily add low score-per-time items not yet selected\n        t = sum(times[i] for i,b in enumerate(lst) if b==1)\n        if t >= req_time:\n            return lst\n        idx = [i for i in range(n) if lst[i] == 0]\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        for i in idx:\n            if t >= req_time:\n                break\n            lst[i] = 1\n            t += times[i]\n        return lst\n\n    # Validate or build starting point\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    lst = [1 if c=='1' else 0 for c in solution]\n    # Optional quick repair if invalid time\n    lst = repair_to_feasible(lst)\n\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.35:\n        # Single flip: choose index to flip; if results in infeasible, repair by adding\n        i = random.randrange(n)\n        lst[i] = 1 - lst[i]\n        move_type = \"FLIP\"\n        lst = repair_to_feasible(lst)\n    elif r < 0.7:\n        # Drop-one then repair (tends to reduce score while keeping feasibility)\n        ones = [i for i,b in enumerate(lst) if b==1]\n        if ones:\n            i = random.choice(ones)\n            lst[i] = 0\n            move_type = \"DROP_REPAIR\"\n            lst = repair_to_feasible(lst)\n        else:\n            move_type = \"DROP_FAILED\"\n    else:\n        # Swap: drop one visited and add one unvisited chosen by low score-per-time\n        ones = [i for i,b in enumerate(lst) if b==1]\n        zeros = [i for i,b in enumerate(lst) if b==0]\n        if ones and zeros:\n            i = random.choice(ones)\n            lst[i] = 0\n            # Add back one with best (lowest) score-per-time to regain feasibility\n            zeros2 = [j for j in range(n) if lst[j]==0]\n            zeros2.sort(key=lambda j: (scores[j]\/max(1, times[j]), scores[j], -times[j]))\n            t = sum(times[k] for k,b in enumerate(lst) if b==1)\n            added = False\n            for j in zeros2:\n                lst[j] = 1\n                t += times[j]\n                added = True\n                if t >= req_time:\n                    break\n            if not added:\n                # fallback: undo\n                lst[i] = 1\n                move_type = \"SWAP_FAILED\"\n            else:\n                move_type = \"SWAP\"\n        else:\n            move_type = \"SWAP_FAILED_EMPTY\"\n\n    neighbour = ''.join('1' if b==1 else '0' for b in lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong shake in inclusion space with feasibility repair (time >= 2750)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n\n    def construct_feasible():\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        sel = [0]*n\n        t = 0\n        for i in idx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        if t < req_time:\n            jdx = [i for i in range(n) if sel[i]==0]\n            jdx.sort(key=lambda i: (-times[i], scores[i]))\n            for i in jdx:\n                if t >= req_time:\n                    break\n                sel[i] = 1\n                t += times[i]\n        return ''.join('1' if b==1 else '0' for b in sel)\n\n    def repair_to_feasible(lst):\n        t = sum(times[i] for i,b in enumerate(lst) if b==1)\n        if t >= req_time:\n            return lst\n        idx = [i for i in range(n) if lst[i]==0]\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        for i in idx:\n            if t >= req_time:\n                break\n            lst[i] = 1\n            t += times[i]\n        return lst\n\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n\n    lst = [1 if c=='1' else 0 for c in solution]\n    # Phase 1: random drops\n    K_drop = random.randint(2, 6)\n    ones = [i for i,b in enumerate(lst) if b==1]\n    random.shuffle(ones)\n    for i in ones[:K_drop]:\n        lst[i] = 0\n    # Phase 2: repair by adding low score-per-time items\n    lst = repair_to_feasible(lst)\n    # Phase 3: a few random swaps to diversify while controlling score\n    K_swap = random.randint(1, 3)\n    for _ in range(K_swap):\n        ones = [i for i,b in enumerate(lst) if b==1]\n        zeros = [i for i,b in enumerate(lst) if b==0]\n        if not ones or not zeros:\n            break\n        i = random.choice(ones)\n        lst[i] = 0\n        # Add a low score-per-time zero\n        zeros.sort(key=lambda j: (scores[j]\/max(1, times[j]), scores[j], -times[j]))\n        t = sum(times[k] for k,b in enumerate(lst) if b==1)\n        added = False\n        for j in zeros:\n            if lst[j]==0:\n                lst[j] = 1\n                t += times[j]\n                added = True\n                if t >= req_time:\n                    break\n        if not added:\n            lst[i] = 1  # revert if failed\n    return ''.join('1' if b==1 else '0' for b in lst)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"SA","Tiempo":0.000916741}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"24-bit binary string; bit i == '1' means the friend VISITS attraction (i+1). Objective: minimize total score of visited items subject to total visited time >= 2750 minutes. Solutions must be exactly 24 characters over {'0','1'}.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit string; '1' means VISITED. Minimize sum(scores[1s]) with constraint sum(times[1s]) >= 2750.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n    # Validate\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 1e15\n    total_time = 0\n    total_score = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_score += scores[i]\n    if total_time < req_time:\n        # Heavy lexicographic penalty prioritizing feasibility\n        return float((req_time - total_time) * 1_000_000 + total_score)\n    return float(total_score)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Inclusion-space neighbor. Ensures 24-bit validity; repairs to meet time >= 2750 when needed.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n\n    def construct_feasible():\n        # Greedy: add lowest score-per-time first until time >= req_time\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        sel = [0]*n\n        t = 0\n        for i in idx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        # If still short due to some pathology (shouldn't), continue adding by time desc\n        jdx = [i for i in range(n) if sel[i] == 0]\n        jdx.sort(key=lambda i: (-times[i], scores[i]))\n        for i in jdx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        return ''.join('1' if b==1 else '0' for b in sel)\n\n    def repair_to_feasible(lst):\n        # If time < req_time, greedily add low score-per-time items not yet selected\n        t = sum(times[i] for i,b in enumerate(lst) if b==1)\n        if t >= req_time:\n            return lst\n        idx = [i for i in range(n) if lst[i] == 0]\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        for i in idx:\n            if t >= req_time:\n                break\n            lst[i] = 1\n            t += times[i]\n        return lst\n\n    # Validate or build starting point\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    lst = [1 if c=='1' else 0 for c in solution]\n    # Optional quick repair if invalid time\n    lst = repair_to_feasible(lst)\n\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.35:\n        # Single flip: choose index to flip; if results in infeasible, repair by adding\n        i = random.randrange(n)\n        lst[i] = 1 - lst[i]\n        move_type = \"FLIP\"\n        lst = repair_to_feasible(lst)\n    elif r < 0.7:\n        # Drop-one then repair (tends to reduce score while keeping feasibility)\n        ones = [i for i,b in enumerate(lst) if b==1]\n        if ones:\n            i = random.choice(ones)\n            lst[i] = 0\n            move_type = \"DROP_REPAIR\"\n            lst = repair_to_feasible(lst)\n        else:\n            move_type = \"DROP_FAILED\"\n    else:\n        # Swap: drop one visited and add one unvisited chosen by low score-per-time\n        ones = [i for i,b in enumerate(lst) if b==1]\n        zeros = [i for i,b in enumerate(lst) if b==0]\n        if ones and zeros:\n            i = random.choice(ones)\n            lst[i] = 0\n            # Add back one with best (lowest) score-per-time to regain feasibility\n            zeros2 = [j for j in range(n) if lst[j]==0]\n            zeros2.sort(key=lambda j: (scores[j]\/max(1, times[j]), scores[j], -times[j]))\n            t = sum(times[k] for k,b in enumerate(lst) if b==1)\n            added = False\n            for j in zeros2:\n                lst[j] = 1\n                t += times[j]\n                added = True\n                if t >= req_time:\n                    break\n            if not added:\n                # fallback: undo\n                lst[i] = 1\n                move_type = \"SWAP_FAILED\"\n            else:\n                move_type = \"SWAP\"\n        else:\n            move_type = \"SWAP_FAILED_EMPTY\"\n\n    neighbour = ''.join('1' if b==1 else '0' for b in lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong shake in inclusion space with feasibility repair (time >= 2750)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n\n    def construct_feasible():\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        sel = [0]*n\n        t = 0\n        for i in idx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        if t < req_time:\n            jdx = [i for i in range(n) if sel[i]==0]\n            jdx.sort(key=lambda i: (-times[i], scores[i]))\n            for i in jdx:\n                if t >= req_time:\n                    break\n                sel[i] = 1\n                t += times[i]\n        return ''.join('1' if b==1 else '0' for b in sel)\n\n    def repair_to_feasible(lst):\n        t = sum(times[i] for i,b in enumerate(lst) if b==1)\n        if t >= req_time:\n            return lst\n        idx = [i for i in range(n) if lst[i]==0]\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        for i in idx:\n            if t >= req_time:\n                break\n            lst[i] = 1\n            t += times[i]\n        return lst\n\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n\n    lst = [1 if c=='1' else 0 for c in solution]\n    # Phase 1: random drops\n    K_drop = random.randint(2, 6)\n    ones = [i for i,b in enumerate(lst) if b==1]\n    random.shuffle(ones)\n    for i in ones[:K_drop]:\n        lst[i] = 0\n    # Phase 2: repair by adding low score-per-time items\n    lst = repair_to_feasible(lst)\n    # Phase 3: a few random swaps to diversify while controlling score\n    K_swap = random.randint(1, 3)\n    for _ in range(K_swap):\n        ones = [i for i,b in enumerate(lst) if b==1]\n        zeros = [i for i,b in enumerate(lst) if b==0]\n        if not ones or not zeros:\n            break\n        i = random.choice(ones)\n        lst[i] = 0\n        # Add a low score-per-time zero\n        zeros.sort(key=lambda j: (scores[j]\/max(1, times[j]), scores[j], -times[j]))\n        t = sum(times[k] for k,b in enumerate(lst) if b==1)\n        added = False\n        for j in zeros:\n            if lst[j]==0:\n                lst[j] = 1\n                t += times[j]\n                added = True\n                if t >= req_time:\n                    break\n        if not added:\n            lst[i] = 1  # revert if failed\n    return ''.join('1' if b==1 else '0' for b in lst)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"ILS","Tiempo":0.0012885451}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"24-bit binary string; bit i == '1' means the friend VISITS attraction (i+1). Objective: minimize total score of visited items subject to total visited time >= 2750 minutes. Solutions must be exactly 24 characters over {'0','1'}.","Evaluacion":"import math\nfrom typing import Tuple\n\ndef evaluate_solution(solution):\n    # Representation: 24-bit string; '1' means VISITED. Minimize sum(scores[1s]) with constraint sum(times[1s]) >= 2750.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n    # Validate\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        return 1e15\n    total_time = 0\n    total_score = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            total_time += times[i]\n            total_score += scores[i]\n    if total_time < req_time:\n        # Heavy lexicographic penalty prioritizing feasibility\n        return float((req_time - total_time) * 1_000_000 + total_score)\n    return float(total_score)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Inclusion-space neighbor. Ensures 24-bit validity; repairs to meet time >= 2750 when needed.\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n\n    def construct_feasible():\n        # Greedy: add lowest score-per-time first until time >= req_time\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        sel = [0]*n\n        t = 0\n        for i in idx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        # If still short due to some pathology (shouldn't), continue adding by time desc\n        jdx = [i for i in range(n) if sel[i] == 0]\n        jdx.sort(key=lambda i: (-times[i], scores[i]))\n        for i in jdx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        return ''.join('1' if b==1 else '0' for b in sel)\n\n    def repair_to_feasible(lst):\n        # If time < req_time, greedily add low score-per-time items not yet selected\n        t = sum(times[i] for i,b in enumerate(lst) if b==1)\n        if t >= req_time:\n            return lst\n        idx = [i for i in range(n) if lst[i] == 0]\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        for i in idx:\n            if t >= req_time:\n                break\n            lst[i] = 1\n            t += times[i]\n        return lst\n\n    # Validate or build starting point\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n    lst = [1 if c=='1' else 0 for c in solution]\n    # Optional quick repair if invalid time\n    lst = repair_to_feasible(lst)\n\n    move_type = \"NO_MOVE\"\n    r = random.random()\n    if r < 0.35:\n        # Single flip: choose index to flip; if results in infeasible, repair by adding\n        i = random.randrange(n)\n        lst[i] = 1 - lst[i]\n        move_type = \"FLIP\"\n        lst = repair_to_feasible(lst)\n    elif r < 0.7:\n        # Drop-one then repair (tends to reduce score while keeping feasibility)\n        ones = [i for i,b in enumerate(lst) if b==1]\n        if ones:\n            i = random.choice(ones)\n            lst[i] = 0\n            move_type = \"DROP_REPAIR\"\n            lst = repair_to_feasible(lst)\n        else:\n            move_type = \"DROP_FAILED\"\n    else:\n        # Swap: drop one visited and add one unvisited chosen by low score-per-time\n        ones = [i for i,b in enumerate(lst) if b==1]\n        zeros = [i for i,b in enumerate(lst) if b==0]\n        if ones and zeros:\n            i = random.choice(ones)\n            lst[i] = 0\n            # Add back one with best (lowest) score-per-time to regain feasibility\n            zeros2 = [j for j in range(n) if lst[j]==0]\n            zeros2.sort(key=lambda j: (scores[j]\/max(1, times[j]), scores[j], -times[j]))\n            t = sum(times[k] for k,b in enumerate(lst) if b==1)\n            added = False\n            for j in zeros2:\n                lst[j] = 1\n                t += times[j]\n                added = True\n                if t >= req_time:\n                    break\n            if not added:\n                # fallback: undo\n                lst[i] = 1\n                move_type = \"SWAP_FAILED\"\n            else:\n                move_type = \"SWAP\"\n        else:\n            move_type = \"SWAP_FAILED_EMPTY\"\n\n    neighbour = ''.join('1' if b==1 else '0' for b in lst)\n    return neighbour, move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong shake in inclusion space with feasibility repair (time >= 2750)\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n    req_time = 2750\n\n    def construct_feasible():\n        idx = list(range(n))\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        sel = [0]*n\n        t = 0\n        for i in idx:\n            if t >= req_time:\n                break\n            sel[i] = 1\n            t += times[i]\n        if t < req_time:\n            jdx = [i for i in range(n) if sel[i]==0]\n            jdx.sort(key=lambda i: (-times[i], scores[i]))\n            for i in jdx:\n                if t >= req_time:\n                    break\n                sel[i] = 1\n                t += times[i]\n        return ''.join('1' if b==1 else '0' for b in sel)\n\n    def repair_to_feasible(lst):\n        t = sum(times[i] for i,b in enumerate(lst) if b==1)\n        if t >= req_time:\n            return lst\n        idx = [i for i in range(n) if lst[i]==0]\n        idx.sort(key=lambda i: (scores[i]\/max(1, times[i]), scores[i], -times[i]))\n        for i in idx:\n            if t >= req_time:\n                break\n            lst[i] = 1\n            t += times[i]\n        return lst\n\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        solution = construct_feasible()\n\n    lst = [1 if c=='1' else 0 for c in solution]\n    # Phase 1: random drops\n    K_drop = random.randint(2, 6)\n    ones = [i for i,b in enumerate(lst) if b==1]\n    random.shuffle(ones)\n    for i in ones[:K_drop]:\n        lst[i] = 0\n    # Phase 2: repair by adding low score-per-time items\n    lst = repair_to_feasible(lst)\n    # Phase 3: a few random swaps to diversify while controlling score\n    K_swap = random.randint(1, 3)\n    for _ in range(K_swap):\n        ones = [i for i,b in enumerate(lst) if b==1]\n        zeros = [i for i,b in enumerate(lst) if b==0]\n        if not ones or not zeros:\n            break\n        i = random.choice(ones)\n        lst[i] = 0\n        # Add a low score-per-time zero\n        zeros.sort(key=lambda j: (scores[j]\/max(1, times[j]), scores[j], -times[j]))\n        t = sum(times[k] for k,b in enumerate(lst) if b==1)\n        added = False\n        for j in zeros:\n            if lst[j]==0:\n                lst[j] = 1\n                t += times[j]\n                added = True\n                if t >= req_time:\n                    break\n        if not added:\n            lst[i] = 1  # revert if failed\n    return ''.join('1' if b==1 else '0' for b in lst)\n","Resultados":"Failed to evaluate SAMPLE_SOL with EVAL_CODE: Type Tuple cannot be instantiated; use tuple() instead","Solucion":[3,7,17],"Valor Optimo":59,"Metaheuristica":"TS","Tiempo":0.001259895}
