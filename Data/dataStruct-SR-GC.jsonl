{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_parties_with_exes_inverted", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": {"x1": "domain: 1..6; meaning: party assigned to friend 1", "x2": "domain: 1..6; meaning: party assigned to friend 2", "x3": "domain: 1..6; meaning: party assigned to friend 3", "x4": "domain: 1..6; meaning: party assigned to friend 4", "x5": "domain: 1..6; meaning: party assigned to friend 5", "x6": "domain: 1..6; meaning: party assigned to friend 6", "p": "domain: 1..6; meaning: total number of parties (to minimize)"}, "DATA_ROLES": {"n_friends": "SCALAR; number of friends (agents indexed 1..n_friends)", "relationships": "LIST; undirected pairs [i,j] that dated (i<j)", "known_random_solution": "LIST; example assignment of parties in friend-index order", "expected_result": "SCALAR; expected value of objective for known_random_solution", "evaluation_function": "SCALAR; expression or callable (as string) to compute objective from a candidate solution"}, "DATA": {"n_friends": 6, "relationships": [[1, 3], [1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [4, 6]], "known_random_solution": [1, 2, 1, 2, 1, 2], "expected_result": 2, "evaluation_function": "lambda solution: max(solution)"}, "OBJECTIVE": {"sense": "minimize", "expression": "p"}, "CONSTRAINTS": ["1 <= x1 <= 6", "1 <= x2 <= 6", "1 <= x3 <= 6", "1 <= x4 <= 6", "1 <= x5 <= 6", "1 <= x6 <= 6", "x1 integer", "x2 integer", "x3 integer", "x4 integer", "x5 integer", "x6 integer", "p integer", "p == max(x1,x2,x3,x4,x5,x6)", "x1 != x2", "x2 != x3", "x3 != x6", "x4 != x5", "x5 != x6"], "SOLUTION_FORMAT": {"type": "comma-separated list of 6 integers", "description": "party for friend1,friend2,friend3,friend4,friend5,friend6 using integer labels 1..p"}}, "FuncionDeCarga": "def Transform(input):\n    import re, ast\n    s = input if isinstance(input, str) else str(input)\n    m = re.search(r\"NoNodes\\s*=\\s*(\\d+)\", s)\n    n = int(m.group(1)) if m else None\n    m = re.search(r\"solution\\s*=\\s*(\\[[^\\]]*\\])\", s)\n    sol = ast.literal_eval(m.group(1)) if m else []\n    m = re.search(r\"score\\s*=\\s*([^,)\\s]+)\", s)\n    if not m:\n        m = re.search(r\"score\\s*=\\s*([^,)]*)\", s)\n    score = ast.literal_eval(m.group(1)) if m else None\n    adj_list = []\n    idx = s.find(\"adj=\")\n    if idx != -1:\n        start = s.find(\"[\", idx)\n        if start != -1:\n            i = start\n            depth = 0\n            end = -1\n            while i < len(s):\n                if s[i] == \"[\":\n                    depth += 1\n                elif s[i] == \"]\":\n                    depth -= 1\n                    if depth == 0:\n                        end = i\n                        break\n                i += 1\n            if end != -1:\n                adj_text = s[start:end+1]\n                adj_text2 = adj_text.replace(\"{\", \"[\").replace(\"}\", \"]\")\n                adj_list = ast.literal_eval(adj_text2)\n    rels = set()\n    for i, neigh in enumerate(adj_list):\n        for j in neigh:\n            a = i + 1\n            b = int(j) + 1\n            if a < b:\n                rels.add((a, b))\n            elif b < a:\n                rels.add((b, a))\n    relationships = [list(x) for x in sorted(rels)]\n    return {\n        'n_friends': n,\n        'relationships': relationships,\n        'known_random_solution': sol,\n        'expected_result': score,\n        'evaluation_function': \"lambda x,relationships: sum(1 for i,j in relationships if x[i-1] != x[j-1])\"\n    }"}
{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_parties_with_exes_standard", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": {"x1": "1..6, integer, party assigned to friend 1", "x2": "1..6, integer, party assigned to friend 2", "x3": "1..6, integer, party assigned to friend 3", "x4": "1..6, integer, party assigned to friend 4", "x5": "1..6, integer, party assigned to friend 5", "x6": "1..6, integer, party assigned to friend 6", "p_max": "1..6, integer, maximum party index used (objective variable representing number of parties)"}, "DATA_ROLES": {"n_friends": "SCALAR, total number of friends", "ex_pairs": "LIST, pairs of friend indices indicating past romantic relationships (must sit in different parties)"}, "DATA": {"n_friends": 6, "ex_pairs": [[1, 2], [2, 3], [3, 6], [4, 5], [5, 6]]}, "OBJECTIVE": {"sense": "minimize", "expression": "p_max"}, "CONSTRAINTS": ["x1 != x2", "x2 != x3", "x3 != x6", "x4 != x5", "x5 != x6", "for i in {1..6}: 1 <= xi <= p_max", "1 <= p_max <= n_friends", "for i in {1..6}: xi integer", "p_max integer"], "SOLUTION_FORMAT": {"type": "list_of_integers", "description": "Comma-separated list of length 6 specifying party indices for friends 1..6. Each value is an integer in 1..p_max. Example: \"1,2,1,2,1,2\""}}, "FuncionDeCarga": "def Transform(input):\n    import re, ast\n    # support either an object with attributes or a string representation like the example\n    if hasattr(input, \"NoNodes\") and hasattr(input, \"solution\") and hasattr(input, \"adj\"):\n        n = input.NoNodes\n        sol = list(input.solution)\n        adj = [list(a) for a in input.adj]\n    else:\n        s = str(input).strip()\n        # extract inside parentheses if class-like \"InstanciaPruebaGC(...)\" or accept a bare dict-like string\n        if \"(\" in s and s.rstrip().endswith(\")\"):\n            inner = s[s.find(\"(\") + 1 : s.rfind(\")\")]\n        else:\n            inner = s\n        # convert set braces to list brackets so ast.literal_eval can parse\n        inner = inner.replace(\"{\", \"[\").replace(\"}\", \"]\")\n        # turn \"key=\" into quoted keys \"key\":\n        inner = re.sub(r'([A-Za-z_]\\w*)\\s*=', r'\"\\1\":', inner)\n        data = ast.literal_eval(\"{\" + inner + \"}\") if not inner.strip().startswith(\"{\") else ast.literal_eval(inner)\n        n = data.get(\"NoNodes\") or data.get(\"NoNodes\".lower()) or data.get(\"n\") or 0\n        sol = list(data.get(\"solution\") or data.get(\"Solution\") or [])\n        adj = [list(a) for a in (data.get(\"adj\") or data.get(\"Adj\") or [])]\n    # build list of pairs (i,j) with i<j where nodes sat in different parties\n    ex_pairs = []\n    for i, nbrs in enumerate(adj):\n        for j in nbrs:\n            try:\n                j = int(j)\n            except:\n                continue\n            if i < j and i < len(sol) and j < len(sol) and sol[i] != sol[j]:\n                ex_pairs.append([i, j])\n    return {\"n_friends\": n, \"ex_pairs\": ex_pairs}"}
{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_student_groups_inverted", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": ["G1,G2,G3,G4,G5,G6 : integer domain 1..K : group index for student i (Gi âˆˆ {1..K})", "K : integer domain 1..6 : total number of groups (to be minimized)"], "DATA_ROLES": {"n": {"name": "number_of_students", "indexing": "SCALAR", "meaning": "total number of students"}, "edges": {"name": "friend_pairs", "indexing": "LIST", "meaning": "undirected pairs (i,j) with friendship relation"}, "known_random_solution": {"name": "candidate_assignment", "indexing": "LIST", "meaning": "proposed group indices for students 1..n"}, "expected_result_from_solution": {"name": "expected_K_for_candidate", "indexing": "SCALAR", "meaning": "expected number of groups used by the candidate assignment"}}, "DATA": {"n": 6, "edges": [[1, 3], [1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [4, 6]], "known_random_solution": [1, 2, 1, 2, 1, 2], "expected_result_from_solution": 2}, "OBJECTIVE": {"sense": "minimize", "expression": "K"}, "CONSTRAINTS": ["1 <= G1 <= K; G1 integer", "1 <= G2 <= K; G2 integer", "1 <= G3 <= K; G3 integer", "1 <= G4 <= K; G4 integer", "1 <= G5 <= K; G5 integer", "1 <= G6 <= K; G6 integer", "1 <= K <= 6; K integer", "K >= G1; K >= G2; K >= G3; K >= G4; K >= G5; K >= G6", "G1 != G2", "G2 != G3", "G3 != G6", "G4 != G5", "G5 != G6", "G1 = 1"], "SOLUTION_FORMAT": {"type": "list_of_integers_length_6", "description": "Return comma-separated group indices [g1,g2,g3,g4,g5,g6] with groups labeled 1..K."}}, "FuncionDeCarga": "def Transform(input):\n    \"\"\"\n    Parse an instance like:\n      InstanciaPruebaGC(NoNodes=125, Noedges=1472, solution=[...], score=0, time=0, adj=[{...}, {...}, ...])\n    or an object with attributes NoNodes, solution, adj.\n    Returns dict with keys:\n      'n' -> int (number_of_students)\n      'edges' -> list of [i,j] undirected (1-based student indices, each pair once with i<j)\n      'known_random_solution' -> list (assignment for students 1..n)\n      'expected_result_from_solution' -> int (number of distinct groups in the candidate assignment)\n    Notes / limitations (brief, as code comment):\n      - Detects whether adjacency uses 0-based or 1-based indices by inspecting min value in adj.\n      - Accepts adj entries as Python sets/lists (if input is string, ast.literal_eval is used).\n    \"\"\"\n    import ast, re\n    # Helper to extract bracketed[...] substring starting at the first '[' after a key\n    def _extract_bracketed(s, key):\n        m = re.search(re.escape(key) + r'\\s*=', s)\n        if not m:\n            return None\n        i = s.find('[', m.end())\n        if i == -1:\n            return None\n        depth = 0\n        for j in range(i, len(s)):\n            if s[j] == '[':\n                depth += 1\n            elif s[j] == ']':\n                depth -= 1\n                if depth == 0:\n                    return s[i:j+1]\n        return None\n\n    # If input is an object with attributes, prefer that\n    NoNodes = None\n    solution = None\n    adj = None\n\n    # Try object-style access\n    try:\n        if hasattr(input, 'NoNodes'):\n            NoNodes = int(getattr(input, 'NoNodes'))\n        elif hasattr(input, 'NoNodes'.lower()):\n            NoNodes = int(getattr(input, 'NoNodes'.lower()))\n    except Exception:\n        NoNodes = None\n    try:\n        if hasattr(input, 'solution'):\n            solution = list(getattr(input, 'solution'))\n    except Exception:\n        solution = None\n    try:\n        if hasattr(input, 'adj'):\n            adj = getattr(input, 'adj')\n            # if adj is e.g. a tuple convert to list\n            adj = list(adj)\n    except Exception:\n        adj = None\n\n    # If any missing and input is a string, parse\n    if (NoNodes is None or solution is None or adj is None) and isinstance(input, str):\n        s = input\n        if NoNodes is None:\n            m = re.search(r'NoNodes\\s*=\\s*([0-9]+)', s)\n            if m:\n                NoNodes = int(m.group(1))\n        if solution is None:\n            sol_str = _extract_bracketed(s, 'solution')\n            if sol_str is not None:\n                try:\n                    solution = ast.literal_eval(sol_str)\n                    solution = list(solution)\n                except Exception:\n                    solution = None\n        if adj is None:\n            adj_str = _extract_bracketed(s, 'adj')\n            if adj_str is not None:\n                try:\n                    adj = ast.literal_eval(adj_str)\n                    adj = list(adj)\n                except Exception:\n                    adj = None\n\n    # Final validation\n    if NoNodes is None:\n        raise ValueError(\"Could not determine NoNodes from input\")\n    if solution is None:\n        # if no solution provided, default to empty groups (zeros) for each student\n        solution = [0] * NoNodes\n    else:\n        if len(solution) != NoNodes:\n            # If lengths mismatch, try to tolerate by trimming or padding with 0\n            if len(solution) > NoNodes:\n                solution = solution[:NoNodes]\n            else:\n                solution = solution + [0] * (NoNodes - len(solution))\n\n    if adj is None:\n        # no adjacency: empty list for each node\n        adj = [set() for _ in range(NoNodes)]\n    else:\n        # Normalize each adjacency entry to an iterable of ints\n        norm = []\n        for a in adj:\n            if a is None:\n                norm.append([])\n            elif isinstance(a, (set, list, tuple)):\n                norm.append(list(a))\n            else:\n                # single value\n                norm.append([a])\n        adj = norm\n        # If adj length differs from NoNodes, try to tolerate: trim or pad with empty\n        if len(adj) != NoNodes:\n            if len(adj) > NoNodes:\n                adj = adj[:NoNodes]\n            else:\n                adj = adj + [[] for _ in range(NoNodes - len(adj))]\n\n    # Determine indexing base of adjacency entries (0-based or 1-based)\n    all_vals = [v for neigh in adj for v in neigh if isinstance(v, int)]\n    base = None\n    if all_vals:\n        minv = min(all_vals)\n        maxv = max(all_vals)\n        if minv == 0:\n            base = 0\n        elif minv >= 1 and maxv == NoNodes:\n            base = 1\n        else:\n            # fallback: if maxv <= NoNodes-1 assume 0-based, else if maxv==NoNodes assume 1-based\n            if maxv <= NoNodes - 1:\n                base = 0\n            elif maxv == NoNodes:\n                base = 1\n            else:\n                base = 0\n    else:\n        base = 0\n\n    # Build undirected edge set (1-based node indices in output)\n    edgeset = set()\n    for i, neigh in enumerate(adj):\n        ni = i + (1 if base == 0 else 0) + 1 if False else None  # placeholder to keep terse code readable below\n    # The above line was a misguided compact attempt; replace with clear logic:\n    edgeset = set()\n    for i, neigh in enumerate(adj):\n        # source index in input numbering\n        src_in = i\n        # convert to 1-based output index for src\n        if base == 0:\n            src = src_in + 1\n        else:\n            src = src_in + 0  # if adj already 1-based, index i corresponds to student i+1? Actually if base==1, adj list likely indexed by 0..n-1 but values are 1-based. So src should be i+1 always.\n            src = src_in + 1\n        for v in neigh:\n            if not isinstance(v, int):\n                continue\n            if base == 0:\n                tgt = v + 1\n            else:\n                tgt = v  # already 1-based\n            a, b = (src, tgt) if src <= tgt else (tgt, src)\n            if a != b:\n                edgeset.add((a, b))\n\n    # Produce sorted list of edges (as lists)\n    edges = [ [a, b] for (a, b) in sorted(edgeset) ]\n\n    # Candidate assignment: ensure length n and simple ints\n    candidate = [int(x) if isinstance(x, (int,)) else int(x) if x is not None else 0 for x in solution]\n    if len(candidate) != NoNodes:\n        if len(candidate) > NoNodes:\n            candidate = candidate[:NoNodes]\n        else:\n            candidate = candidate + [0] * (NoNodes - len(candidate))\n\n    # Expected K is number of distinct groups used\n    try:\n        distinct = set(candidate)\n        expectedK = len(distinct)\n    except Exception:\n        expectedK = 0\n\n    return {'n': NoNodes, 'edges': edges, 'known_random_solution': candidate, 'expected_result_from_solution': expectedK}"}
{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_student_groups_standard", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": {"g1": {"domain": "1..6", "meaning": "group index assigned to student 1 (integer)"}, "g2": {"domain": "1..6", "meaning": "group index assigned to student 2 (integer)"}, "g3": {"domain": "1..6", "meaning": "group index assigned to student 3 (integer)"}, "g4": {"domain": "1..6", "meaning": "group index assigned to student 4 (integer)"}, "g5": {"domain": "1..6", "meaning": "group index assigned to student 5 (integer)"}, "g6": {"domain": "1..6", "meaning": "group index assigned to student 6 (integer)"}, "M": {"domain": "1..6", "meaning": "auxiliary integer variable equal to the total number of groups (max of gi)"}}, "DATA_ROLES": {"N": {"INDEXING": "SCALAR", "meaning": "number of students"}, "friend_pairs": {"INDEXING": "LIST", "meaning": "list of unordered friendship edges (1-based indices)"}}, "DATA": {"N": 6, "friend_pairs": [[1, 2], [2, 3], [3, 6], [4, 5], [5, 6]]}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION_SOLVER_COMPATIBLE": "minimize M", "NOTES": "Introduce integer auxiliary variable M with constraints M >= gi for all i and minimize M. Do not use max(...) directly."}, "CONSTRAINTS": ["g1 != g2", "g2 != g3", "g3 != g6", "g4 != g5", "g5 != g6", "1 <= g1 <= 6", "1 <= g2 <= 6", "1 <= g3 <= 6", "1 <= g4 <= 6", "1 <= g5 <= 6", "1 <= g6 <= 6", "g1 integer", "g2 integer", "g3 integer", "g4 integer", "g5 integer", "g6 integer", "M integer", "M >= g1", "M >= g2", "M >= g3", "M >= g4", "M >= g5", "M >= g6", "1 <= M <= 6"], "SOLUTION_FORMAT": {"TYPE": "LIST_OF_INTEGERS", "DESCRIPTION": "Comma-separated list of 6 integers giving group index for students 1..6. Groups are labeled by integers 1..M, where M is minimized. Example: \"1,2,1,2,1,2\""}}, "FuncionDeCarga": "def Transform(input):\n    import re, ast\n    s = input.strip()\n    # try to read NoNodes\n    m = re.search(r'NoNodes\\s*=\\s*(\\d+)', s)\n    N = int(m.group(1)) if m else None\n    # locate adj=[ ... ] block\n    m2 = re.search(r'\\badj\\s*=\\s*\\[', s)\n    if not m2:\n        # no adj found -> return minimal schema\n        return {'N': N if N is not None else 0, 'friend_pairs': []}\n    b = s.find('[', m2.start())\n    # find matching closing bracket\n    depth = 0\n    end = None\n    for i in range(b, len(s)):\n        if s[i] == '[':\n            depth += 1\n        elif s[i] == ']':\n            depth -= 1\n            if depth == 0:\n                end = i\n                break\n    if end is None:\n        raise ValueError('Could not find end of adj list')\n    adj_text = s[b:end+1]\n    # convert set-braces to list-brackets for safe literal_eval\n    adj_text_conv = adj_text.replace('{', '[').replace('}', ']')\n    adj = ast.literal_eval(adj_text_conv)\n    # ensure list-of-lists of ints\n    adj_list = []\n    for item in adj:\n        if item is None:\n            adj_list.append([])\n        else:\n            adj_list.append([int(x) for x in item])\n    if N is None:\n        N = len(adj_list)\n    # build undirected edge list (1-based indices), avoid duplicates\n    edges_set = set()\n    for i, neighs in enumerate(adj_list):\n        u = i + 1\n        for v0 in neighs:\n            v = int(v0) + 1\n            a, b = (u, v) if u <= v else (v, u)\n            edges_set.add((a, b))\n    # remove self-loops if present\n    edges = [list(e) for e in sorted(e for e in edges_set if e[0] != e[1])]\n    return {'N': N, 'friend_pairs': edges}"}
{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_taekwondo_tournament_inverted", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "room_1", "domain": "1..6", "meaning": "Room assigned to participant 1 (integer)"}, {"symbol": "room_2", "domain": "1..6", "meaning": "Room assigned to participant 2 (integer)"}, {"symbol": "room_3", "domain": "1..6", "meaning": "Room assigned to participant 3 (integer)"}, {"symbol": "room_4", "domain": "1..6", "meaning": "Room assigned to participant 4 (integer)"}, {"symbol": "room_5", "domain": "1..6", "meaning": "Room assigned to participant 5 (integer)"}, {"symbol": "room_6", "domain": "1..6", "meaning": "Room assigned to participant 6 (integer)"}, {"symbol": "R", "domain": "1..6", "meaning": "Total number of rooms (integer), objective variable (R >= room_i for all i)"}], "DATA_ROLES": {"N": {"INDEXING": "SCALAR", "MEANING": "Number of participants"}, "EDGES": {"INDEXING": "LIST", "MEANING": "List of competing pairs (undirected)"}, "KNOWN_RANDOM_SOLUTION": {"INDEXING": "LIST", "MEANING": "Provided candidate assignment of rooms for verification"}, "EXPECTED_RESULT": {"INDEXING": "SCALAR", "MEANING": "Expected number of rooms produced by KNOWN_RANDOM_SOLUTION"}}, "DATA": {"N": 6, "EDGES": [[1, 3], [1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [4, 6]], "KNOWN_RANDOM_SOLUTION": [1, 2, 1, 2, 1, 2], "EXPECTED_RESULT": 2}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION_SOLVER_COMPATIBLE": "minimize R"}, "CONSTRAINTS": ["room_1 >= 1", "room_1 <= N", "room_2 >= 1", "room_2 <= N", "room_3 >= 1", "room_3 <= N", "room_4 >= 1", "room_4 <= N", "room_5 >= 1", "room_5 <= N", "room_6 >= 1", "room_6 <= N", "R >= 1", "R <= N", "R >= room_1", "R >= room_2", "R >= room_3", "R >= room_4", "R >= room_5", "R >= room_6", "room_1 != room_2", "room_2 != room_3", "room_3 != room_6", "room_4 != room_5", "room_5 != room_6"], "SOLUTION_FORMAT": {"TYPE": "LIST", "DESCRIPTION": "Comma-separated list of integers (room for participant1,participant2,...,participant6). Example: [1,2,1,2,1,2]"}}, "FuncionDeCarga": "def Transform(input):\n    \"\"\"\n    Parse an instance string like:\n    InstanciaPruebaGC(NoNodes=125, Noedges=1472, solution=[...], adj=[{...}, {...}, ...])\n    and return a dict matching the TARGET_SCHEMA:\n      {'N': int,\n       'EDGES': list of [u,v] undirected pairs with u<v,\n       'KNOWN_RANDOM_SOLUTION': list of ints,\n       'EXPECTED_RESULT': int}\n    \"\"\"\n    import re\n\n    s = str(input)\n\n    # N\n    m = re.search(r'NoNodes\\s*=\\s*(\\d+)', s, re.IGNORECASE)\n    N = int(m.group(1)) if m else None\n\n    # solution list\n    m = re.search(r'solution\\s*=\\s*\\[([^\\]]*)\\]', s, re.IGNORECASE)\n    if m:\n        sol_nums = re.findall(r'-?\\d+', m.group(1))\n        solution = [int(x) for x in sol_nums]\n    else:\n        solution = []\n\n    # adj: find the bracketed content after 'adj='\n    adj_list = []\n    m = re.search(r'adj\\s*=\\s*\\[', s, re.IGNORECASE)\n    if m:\n        i = m.end()  # position after the '['\n        depth = 1\n        j = i\n        # find matching closing ']'\n        while j < len(s) and depth > 0:\n            if s[j] == '[':\n                depth += 1\n            elif s[j] == ']':\n                depth -= 1\n            j += 1\n        adj_content = s[i:j-1]\n        # extract each {...} block\n        idx = 0\n        while idx < len(adj_content):\n            # find next '{'\n            while idx < len(adj_content) and adj_content[idx] != '{':\n                idx += 1\n            if idx >= len(adj_content):\n                break\n            idx += 1\n            start = idx\n            # find matching '}'\n            while idx < len(adj_content) and adj_content[idx] != '}':\n                idx += 1\n            block = adj_content[start:idx]\n            idx += 1\n            nums = re.findall(r'-?\\d+', block)\n            adj_list.append([int(x) for x in nums])\n    else:\n        adj_list = []\n\n    # If adj_list length matches N, use it; otherwise attempt to infer adjacency from \"adj=\" content differently\n    if N is None and adj_list:\n        N = len(adj_list)\n\n    # build undirected edges (unique, u < v)\n    edges_set = set()\n    for u, neigh in enumerate(adj_list):\n        for v in neigh:\n            a = int(u)\n            b = int(v)\n            if a == b:\n                continue\n            if a < b:\n                edges_set.add((a, b))\n            else:\n                edges_set.add((b, a))\n    edges = [list(e) for e in sorted(edges_set)]\n\n    expected = len(set(solution))\n\n    return {'N': N, 'EDGES': edges, 'KNOWN_RANDOM_SOLUTION': solution, 'EXPECTED_RESULT': expected}"}
{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_taekwondo_tournament_standard", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "y[I,C]", "domain": "binary for I=1..NUM_PARTICIPANTS, C=1..ROOMS_UPPER_BOUND", "meaning": "1 if participant I is assigned to room C, 0 otherwise"}, {"symbol": "z[C]", "domain": "binary for C=1..ROOMS_UPPER_BOUND", "meaning": "1 if room C is used, 0 otherwise"}, {"symbol": "R", "domain": "integer 0..ROOMS_UPPER_BOUND", "meaning": "total number of rooms used (objective variable)"}], "DATA_ROLES": {"NUM_PARTICIPANTS": "SCALAR", "EDGES": "LIST", "ROOMS_UPPER_BOUND": "SCALAR", "KNOWN_RANDOM_SOLUTION": "LIST", "EXPECTED_RESULT": "SCALAR"}, "DATA": {"NUM_PARTICIPANTS": 6, "EDGES": [[1, 2], [2, 3], [3, 6], [4, 5], [5, 6]], "ROOMS_UPPER_BOUND": 2, "KNOWN_RANDOM_SOLUTION": [1, 2, 1, 2, 1, 2], "EXPECTED_RESULT": 2}, "OBJECTIVE": {"SENSE": "minimize", "EXPRESSION": "R"}, "CONSTRAINTS": ["for I in 1..NUM_PARTICIPANTS: sum_{C=1..ROOMS_UPPER_BOUND} y[I,C] == 1", "for I in 1..NUM_PARTICIPANTS for C in 1..ROOMS_UPPER_BOUND: y[I,C] <= z[C]", "for each (U,V) in EDGES for C in 1..ROOMS_UPPER_BOUND: y[U,C] + y[V,C] <= 1", "R == sum_{C=1..ROOMS_UPPER_BOUND} z[C]", "y[I,C] in {0,1} for I=1..NUM_PARTICIPANTS,C=1..ROOMS_UPPER_BOUND; z[C] in {0,1} for C=1..ROOMS_UPPER_BOUND; R integer 0..ROOMS_UPPER_BOUND"], "SOLUTION_FORMAT": {"TYPE": "list_of_integers", "DESCRIPTION": "A comma-separated list of 6 integers indicating room assignments for participants 1..6 respectively. Each integer is in 1..ROOMS_UPPER_BOUND and corresponds to the unique C where y[I,C]==1."}}, "FuncionDeCarga": "def Transform(input):\n    \"\"\"\n    Convert an InstanciaPruebaGC-like input into the target schema:\n    {'NUM_PARTICIPANTS': scalar,\n     'EDGES': list of [u,v] undirected unique edges with u<v,\n     'ROOMS_UPPER_BOUND': scalar,\n     'KNOWN_RANDOM_SOLUTION': list,\n     'EXPECTED_RESULT': scalar}\n    The function accepts:\n      - a string like \"InstanciaPruebaGC(...)\" (it will replace the class name with dict(...) and eval),\n      - a dict with keys like 'NoNodes','adj','solution','score',\n      - or an object with attributes NoNodes, adj, solution, score.\n    \"\"\"\n    # Normalize input to a mapping\n    obj = None\n    # If it's a string like the example, convert to a dict via eval after replacing the class name\n    if isinstance(input, str):\n        s = input.strip()\n        if s.startswith(\"InstanciaPruebaGC(\"):\n            s2 = \"dict(\" + s[len(\"InstanciaPruebaGC(\"):]\n            # eval is used intentionally to parse the structure (adj uses set literals)\n            obj = eval(s2)\n        else:\n            # try to eval generic literal (e.g., dict literal)\n            obj = eval(s)\n    elif isinstance(input, dict):\n        obj = input\n    else:\n        # object with attributes\n        try:\n            obj = {}\n            for k in (\"NoNodes\", \"Noedges\", \"solution\", \"score\", \"time\", \"adj\"):\n                if hasattr(input, k):\n                    obj[k] = getattr(input, k)\n        except Exception:\n            obj = input  # fallback; downstream code will handle missing pieces\n\n    # helpers to fetch values from obj whether dict or object\n    def get(k, default=None):\n        if isinstance(obj, dict):\n            return obj.get(k, default)\n        return getattr(obj, k, default)\n\n    n = get(\"NoNodes\", None)\n    adj = get(\"adj\", None)\n    solution = get(\"solution\", [])\n    score = get(\"score\", None)\n\n    # Build edge list from adjacency representation\n    edges_set = set()\n    if adj is None:\n        edges = []\n    else:\n        # adj expected to be an iterable indexed by node id (0..n-1). If it's a dict, iterate items.\n        if isinstance(adj, dict):\n            items = adj.items()\n        else:\n            # assume sequence\n            items = list(enumerate(adj))\n        for i, neigh in items:\n            # ensure neigh is iterable (set/list)\n            if neigh is None:\n                continue\n            for j in neigh:\n                try:\n                    a = int(i)\n                    b = int(j)\n                except Exception:\n                    # skip non-integer entries\n                    continue\n                if a == b:\n                    continue\n                u, v = (a, b) if a < b else (b, a)\n                edges_set.add((u, v))\n        # produce sorted list of lists for deterministic output\n        edges = [ [u, v] for (u, v) in sorted(edges_set) ]\n\n    # Rooms upper bound: use number of participants if available, else length of solution, else None\n    rooms_upper = n if n is not None else (len(solution) if solution else None)\n\n    # Ensure solution is a plain list\n    known_solution = list(solution) if solution is not None else []\n\n    output = {\n        \"NUM_PARTICIPANTS\": n,\n        \"EDGES\": edges,\n        \"ROOMS_UPPER_BOUND\": rooms_upper,\n        \"KNOWN_RANDOM_SOLUTION\": known_solution,\n        \"EXPECTED_RESULT\": score\n    }\n    return output"}
{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_textbook_inverted", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "x1", "domain": "1..K (integer)", "meaning": "color assigned to node 1"}, {"symbol": "x2", "domain": "1..K (integer)", "meaning": "color assigned to node 2"}, {"symbol": "x3", "domain": "1..K (integer)", "meaning": "color assigned to node 3"}, {"symbol": "x4", "domain": "1..K (integer)", "meaning": "color assigned to node 4"}, {"symbol": "x5", "domain": "1..K (integer)", "meaning": "color assigned to node 5"}, {"symbol": "x6", "domain": "1..K (integer)", "meaning": "color assigned to node 6"}, {"symbol": "K", "domain": "1..6 (integer)", "meaning": "upper bound on number of colors used (objective variable)"}], "DATA_ROLES": [{"name": "adjacency_edges", "indexing": "LIST", "meaning": "undirected edges listed as pairs (i,j) with 1<=i<j<=6"}, {"name": "known_solution", "indexing": "LIST", "meaning": "proposed coloring to verify; list of 6 integers, one per node"}, {"name": "expected_colors", "indexing": "SCALAR", "meaning": "expected number of colors used by the known_solution"}], "DATA": {"adjacency_edges": [[1, 3], [1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [4, 6]], "known_solution": [1, 2, 1, 2, 1, 2], "expected_colors": 2}, "OBJECTIVE": {"sense": "minimize", "expression": "minimize K"}, "CONSTRAINTS": ["x1 != x3", "x1 != x4", "x1 != x5", "x1 != x6", "x2 != x4", "x2 != x5", "x2 != x6", "x3 != x4", "x3 != x5", "x4 != x6", "1 <= x1 <= K", "1 <= x2 <= K", "1 <= x3 <= K", "1 <= x4 <= K", "1 <= x5 <= K", "1 <= x6 <= K", "x1 integer", "x2 integer", "x3 integer", "x4 integer", "x5 integer", "x6 integer", "1 <= K <= 6", "K integer", "K >= x1", "K >= x2", "K >= x3", "K >= x4", "K >= x5", "K >= x6"], "SOLUTION_FORMAT": {"type": "LIST", "description": "Comma-separated list of 6 integers representing colors for nodes 1..6, e.g. '1,2,1,2,1,2'."}}, "FuncionDeCarga": "def Transform(input):\n    # Parse an InstanciaPruebaGC-like input (string or object) and produce:\n    # {'adjacency_edges': [[i,j],...], 'known_solution': [c1..c6], 'expected_colors': k}\n    import ast\n    s = None\n    adj = None\n    solution = None\n\n    # If input is a string, try to extract 'solution=[...]' and 'adj=[...]'\n    if isinstance(input, str):\n        s = input\n        def extract_bracket_content(text, token):\n            i = text.find(token)\n            if i == -1:\n                return None\n            i = text.find('[', i)\n            if i == -1:\n                return None\n            j = i\n            depth = 0\n            while j < len(text):\n                ch = text[j]\n                if ch == '[':\n                    depth += 1\n                elif ch == ']':\n                    depth -= 1\n                    if depth == 0:\n                        return text[i:j+1]\n                j += 1\n            return None\n        sol_txt = extract_bracket_content(s, 'solution=')\n        if sol_txt is None:\n            sol_txt = extract_bracket_content(s, 'solution =')\n        adj_txt = extract_bracket_content(s, 'adj=')\n        if adj_txt is None:\n            adj_txt = extract_bracket_content(s, 'adj =')\n        try:\n            if sol_txt is not None:\n                solution = ast.literal_eval(sol_txt)\n        except Exception:\n            solution = None\n        try:\n            if adj_txt is not None:\n                adj = ast.literal_eval(adj_txt)\n        except Exception:\n            adj = None\n\n    else:\n        # input may be an object with attributes or a mapping\n        try:\n            solution = getattr(input, 'solution', None)\n        except Exception:\n            solution = None\n        try:\n            adj = getattr(input, 'adj', None)\n        except Exception:\n            adj = None\n        if solution is None:\n            try:\n                solution = input['solution']\n            except Exception:\n                pass\n        if adj is None:\n            try:\n                adj = input['adj']\n            except Exception:\n                pass\n\n    if solution is None:\n        solution = []\n    if adj is None:\n        adj = []\n\n    # Build undirected adjacency edges among nodes 1..6 (indices 0..5)\n    edges = []\n    seen = set()\n    for i in range(min(6, len(adj))):\n        nbrs = adj[i]\n        try:\n            itr = iter(nbrs)\n        except Exception:\n            continue\n        for j in nbrs:\n            # normalize to int if possible\n            if isinstance(j, bool):\n                continue\n            if not isinstance(j, int):\n                try:\n                    j = int(j)\n                except Exception:\n                    continue\n            if 0 <= j < 6:\n                a = i + 1\n                b = j + 1\n                if a == b:\n                    continue\n                if a > b:\n                    a, b = b, a\n                key = (a, b)\n                if key not in seen:\n                    seen.add(key)\n                    edges.append([a, b])\n\n    # Known solution: first 6 entries (pad zeros if necessary)\n    ks = []\n    for x in solution[:6]:\n        try:\n            ks.append(int(x))\n        except Exception:\n            ks.append(0)\n    if len(ks) < 6:\n        ks += [0] * (6 - len(ks))\n\n    expected_colors = len(set(ks))\n    return {'adjacency_edges': edges, 'known_solution': ks, 'expected_colors': expected_colors}"}
{"Instancia": "graph_coloring_hard_dataset_in_house_6_0_textbook_standard", "Tipo_de_problema": "graph_coloring", "SchemaDataClass": {"DECISION_VARIABLES": [{"symbol": "color_1", "domain": "{1..6}", "meaning": "Color assigned to node 1 (integer)"}, {"symbol": "color_2", "domain": "{1..6}", "meaning": "Color assigned to node 2 (integer)"}, {"symbol": "color_3", "domain": "{1..6}", "meaning": "Color assigned to node 3 (integer)"}, {"symbol": "color_4", "domain": "{1..6}", "meaning": "Color assigned to node 4 (integer)"}, {"symbol": "color_5", "domain": "{1..6}", "meaning": "Color assigned to node 5 (integer)"}, {"symbol": "color_6", "domain": "{1..6}", "meaning": "Color assigned to node 6 (integer)"}, {"symbol": "K", "domain": "{1..6}", "meaning": "Maximum color used across all nodes (integer). Objective minimizes K."}], "DATA_ROLES": {"NODES": {"INDEXING": "LIST", "MEANING": "List of node indices in the graph"}, "EDGES": {"INDEXING": "LIST", "MEANING": "List of undirected edges, each as a pair [i,j]"}, "KNOWN_RANDOM_SOLUTION": {"INDEXING": "LIST", "MEANING": "An example coloring to be evaluated"}, "EXPECTED_RESULT": {"INDEXING": "SCALAR", "MEANING": "Expected minimal number of colors (chromatic number)"}}, "DATA": {"NODES": [1, 2, 3, 4, 5, 6], "EDGES": [[1, 2], [2, 3], [3, 6], [4, 5], [5, 6]], "KNOWN_RANDOM_SOLUTION": [1, 2, 1, 2, 1, 2], "EXPECTED_RESULT": 2}, "OBJECTIVE": {"SENSE": "MINIMIZE", "EXPRESSION": "K", "SOLVER_COMPATIBLE_NOTE": "K must be linked to colors via constraints (see CONSTRAINTS). Objective is minimize K."}, "CONSTRAINTS": ["color_1 != color_2", "color_2 != color_3", "color_3 != color_6", "color_4 != color_5", "color_5 != color_6", "K >= color_1", "K >= color_2", "K >= color_3", "K >= color_4", "K >= color_5", "K >= color_6", "forall i in {1,2,3,4,5,6}: color_i in {1..6}"], "SOLUTION_FORMAT": {"TYPE": "LIST_OF_INTEGERS", "DESCRIPTION": "Comma-separated list of 6 integers giving colors for nodes 1..6. Additionally, critical feedback key-value pairs follow (no positive reinforcement):\\nDATA_ERROR: EXTRACTED_DATA contains malformed token '2}' and does not reliably match declared DATA_ROLES. Suggestion: remove stray characters and ensure DATA keys exactly match DATA_ROLES (NODES, EDGES, KNOWN_RANDOM_SOLUTION, EXPECTED_RESULT). Verify EDGES are list-of-pairs and EXPECTED_RESULT is scalar integer.\\nLOGIC_ERROR: Objective is ambiguous because K is not defined as the maximum over color_i in the OBJECTIVE expression. Suggest operator/change: in OBJECTIVE line replace ambiguous usage with explicit linking constraint 'K == max(color_1,color_2,color_3,color_4,color_5,color_6)' or add equality constraint 'K - max(color_1,...,color_6) == 0' (line: OBJECTIVE expression). Also clarify that pairwise inequality constraints are required exactly for edges; if using a solver that disallows '!=' use binary indicator encoding.\\nRESULTS_NOT_CONSISTENT: There is no provided EVALUATION_FUNCTION to verify the KNOWN_RANDOM_SOLUTION and assert EXPECTED_RESULT. Local solvers must provide ground truth evaluation. Provide a verifier implementable via ast_eval/dynamic compile, for example: 'def evaluate(sol, edges): return max(sol) if all(sol[i-1] != sol[j-1] for (i,j) in edges) else None' and then assert evaluate(KNOWN_RANDOM_SOLUTION, EDGES) == EXPECTED_RESULT. Ensure indexing is consistent (1-based nodes => sol indices are offset by -1). Without this explicit evaluator, optimality claims are not verifiable."}}, "FuncionDeCarga": "def Transform(input):\n    \"\"\"\n    Convert an instance of InstanciaPruebaGC-like input into target schema:\n    Returns a dict with keys:\n      - 'NODES': list of node indices\n      - 'EDGES': list of undirected edges as [i,j] with i<j\n      - 'KNOWN_RANDOM_SOLUTION': provided solution list (or [] if absent)\n      - 'EXPECTED_RESULT': computed chromatic value (greedy upper bound or number of colors\n                           in provided valid solution)\n    The function accepts either:\n      - an object with attributes NoNodes, solution, adj\n      - a dict with keys 'NoNodes','solution','adj'\n      - a string containing \"NoNodes=...\", \"solution=[...]\" and \"adj=[...]\" (Python literal)\n    \"\"\"\n    import ast, re\n\n    # Helpers to extract from string\n    def _extract_list_literal(s, name):\n        m = re.search(r'%s\\s*=\\s*(\\[[^\\]]*\\])' % re.escape(name), s, re.S)\n        return ast.literal_eval(m.group(1)) if m else None\n\n    adj = None\n    sol = None\n    n = None\n\n    # If string, try to parse literals\n    if isinstance(input, str):\n        s = input\n        m = re.search(r'NoNodes\\s*=\\s*([0-9]+)', s)\n        if m:\n            n = int(m.group(1))\n        sol = _extract_list_literal(s, 'solution')\n        # Extract adj which may contain sets/dicts; allow nested braces by finding 'adj=' and the matching bracket\n        m2 = re.search(r'adj\\s*=\\s*(\\[(?:.|\\n)*\\])', s, re.S)\n        if m2:\n            try:\n                adj = ast.literal_eval(m2.group(1))\n            except Exception:\n                adj = None\n    else:\n        # object or dict\n        if hasattr(input, 'NoNodes'):\n            n = getattr(input, 'NoNodes')\n        if hasattr(input, 'solution'):\n            sol = getattr(input, 'solution')\n        if hasattr(input, 'adj'):\n            adj = getattr(input, 'adj')\n        if isinstance(input, dict):\n            if n is None:\n                n = input.get('NoNodes', input.get('noNodes', input.get('nodes', None)))\n            if sol is None:\n                sol = input.get('solution', input.get('solution', None))\n            if adj is None:\n                adj = input.get('adj', input.get('adjacency', None))\n\n    # Fallbacks\n    if adj is None:\n        adj = []\n    if n is None:\n        # infer from adjacency length if possible\n        try:\n            n = len(adj)\n        except Exception:\n            n = 0\n    if sol is None:\n        sol = []\n\n    # Normalize adjacency: allow list of sets, lists, tuples\n    edges_set = set()\n    for i, nbrs in enumerate(adj):\n        if nbrs is None:\n            continue\n        # If inner is something like a dict (from input), try to iterate keys\n        try:\n            for j in nbrs:\n                try:\n                    jj = int(j)\n                except Exception:\n                    continue\n                if jj == i:\n                    continue\n                a, b = (i, jj) if i < jj else (jj, i)\n                edges_set.add((a, b))\n        except Exception:\n            # skip malformed row\n            continue\n\n    edges = [[a, b] for a, b in sorted(edges_set)]\n    nodes = list(range(0, int(n) if n is not None else 0))\n\n    # Determine EXPECTED_RESULT:\n    # 1) If provided solution is valid (length matches and no adjacent equal colors), return its number of distinct colors.\n    # 2) Otherwise compute a deterministic greedy coloring (upper bound) and return the number of colors used.\n    expected = None\n    try:\n        if isinstance(sol, (list, tuple)) and len(sol) == len(nodes) and len(nodes) > 0:\n            valid = True\n            for a, b in edges_set:\n                if sol[a] == sol[b]:\n                    valid = False\n                    break\n            if valid:\n                expected = len(set(sol))\n    except Exception:\n        expected = None\n\n    if expected is None:\n        # greedy coloring\n        n0 = len(nodes)\n        coloring = [None] * n0\n        adj_list = [set() for _ in range(n0)]\n        for a, b in edges_set:\n            if 0 <= a < n0 and 0 <= b < n0:\n                adj_list[a].add(b)\n                adj_list[b].add(a)\n        for v in range(n0):\n            used = set()\n            for u in adj_list[v]:\n                if coloring[u] is not None:\n                    used.add(coloring[u])\n            c = 0\n            while c in used:\n                c += 1\n            coloring[v] = c\n        expected = max(coloring) + 1 if n0 > 0 else 0\n\n    return {\n        'NODES': nodes,\n        'EDGES': edges,\n        'KNOWN_RANDOM_SOLUTION': list(sol),\n        'EXPECTED_RESULT': int(expected)\n    }"}
