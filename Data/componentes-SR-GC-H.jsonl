{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9: solution[i-1] = color of vertex i, with contiguous labels {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Objective = k + PEN_EDGE * (#edge conflicts).\n    # Representation: list of 9 positive ints; ci is color of vertex i (1-indexed vertices).\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**4\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Base objective (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, movement_type)\n    # Neighborhood includes: conflict-driven recolor, color-swap, and Kempe-chain swap.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def neighbors_of(i):\n        # 0-indexed\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def recolor_move(sol):\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Pick vertex: highest conflict count (ties random); if none, pick random\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        palette = list(range(1, k+1))\n        # Allow k+1 only if conflicts>0 and with small probability\n        if total > 0 and random.random() < 0.05:\n            palette.append(k+1)\n        # Choose color minimizing local conflicts\n        best_colors = []\n        best_val = None\n        for col in palette:\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n        s = normalize_labels(s)\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol):\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            return s, \"NOOP\"\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c == a else a if c == b else c for c in s]\n        s = normalize_labels(s)\n        return s, \"SWAP_TWO_COLORS\"\n\n    def kempe_chain_move(sol):\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return s, \"NOOP\"\n        # Prefer a conflicting vertex if exists\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(candidates)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        # pick a different color b\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return s, \"NOOP\"\n        b = random.choice(choices)\n        # Build subgraph induced by colors {a,b} and find component containing u\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] in allowed:\n                comp.append(x)\n                for (p,q) in edges:\n                    y = q-1 if p-1 == x else p-1 if q-1 == x else None\n                    if y is None:\n                        continue\n                    if not visited[y] and s[y] in allowed:\n                        visited[y] = True\n                        dq.append(y)\n        # Swap colors a<->b within comp\n        for idx in comp:\n            s[idx] = b if s[idx] == a else a\n        s = normalize_labels(s)\n        return s, \"KEMPE_CHAIN_SWAP\"\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"INVALID_INPUT\")\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return (solution, \"INVALID_INPUT\")\n    except Exception:\n        return (solution, \"INVALID_INPUT\")\n\n    # Decide move type based on conflicts\n    _, tot = conflicts_by_vertex(solution)\n    r = random.random()\n    if tot == 0:\n        # When feasible, avoid increasing palette; prefer neutral diversification\n        if r < 0.6:\n            return swap_two_colors(solution)\n        elif r < 0.9:\n            return kempe_chain_move(solution)\n        else:\n            return recolor_move(solution)\n    else:\n        # When infeasible, prioritize conflict resolution\n        if r < 0.65:\n            return recolor_move(solution)\n        elif r < 0.85:\n            return kempe_chain_move(solution)\n        else:\n            return swap_two_colors(solution)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: (a) if feasible, attempt merge-two-colors then greedy repair; (b) else, multi-kick recolors of top-conflict vertices; normalize at end.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def greedy_repair(sol, max_iters=60):\n        s = list(sol)\n        k = compute_k(s)\n        for _ in range(max_iters):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            # pick a vertex involved in conflict\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            i = random.choice(conflicted)\n            # choose best color in current palette 1..k\n            best_colors = []\n            best_val = None\n            for col in range(1, k+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        s = normalize_labels(s)\n        return s\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return solution\n    except Exception:\n        return solution\n\n    s = normalize_labels(list(solution))\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt to reduce palette via merging two colors, then repair\n        a, b = random.sample(range(1, k+1), 2)\n        # Merge b into a\n        s = [a if c == b else c for c in s]\n        s = normalize_labels(s)\n        s = greedy_repair(s, max_iters=100)\n        return s\n\n    # Otherwise, perform multi-kick recolors focusing on high-conflict vertices\n    steps = 5\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        # choose a color that minimizes local conflicts within current k (do not add new color here)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, k+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = normalize_labels(s)\n    s = greedy_repair(s, max_iters=60)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9 where solution[i-1] is the color (positive int) assigned to vertex i; labels normalized to contiguous {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Objective = k + PEN_EDGE * (#edge conflicts).\n    # Representation: list of 9 positive ints; ci is color of vertex i (1-indexed vertices).\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**5\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks and normalization to contiguous labels\n    try:\n        s = [int(x) for x in solution]\n        if any(x < 1 for x in s):\n            return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Normalize labels to enforce contiguity {1..k}\n    mapping = {}\n    nxt = 1\n    sn = []\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sn.append(mapping[c])\n\n    # Base objective (k)\n    k = 0\n    for x in sn:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sn[u-1] == sn[v-1]:\n            conflicts += 1\n\n    fitness = float(k) + PEN_EDGE * float(conflicts)\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns: (new_solution_list, movement_type_str)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def recolor_move(sol):\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Pick vertex: highest conflict count (ties random); if none, pick random\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        palette = list(range(1, k+1))\n        # Choose color minimizing local conflicts; allow k+1 only if infeasible and no feasible color exists\n        best_colors = []\n        best_val = None\n        for col in palette:\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if total > 0 and (not best_colors or best_val > 0):\n            # Consider introducing k+1 only if all current colors cause conflicts\n            # and we are in an infeasible state\n            new_col = k + 1\n            best_colors.append(new_col)\n        # pick one different color for sure\n        if best_colors:\n            # Avoid no-op\n            choices = [c for c in best_colors if c != s[i]]\n            if not choices:\n                # fallback: force a different color within 1..max(k,2)\n                choices = list(range(1, max(2, k+1)))\n                choices = [c for c in choices if c != s[i]]\n            s[i] = random.choice(choices)\n        s = normalize_labels(s)\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol):\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            # fallback to recolor\n            return recolor_move(s)\n        # retry to ensure change\n        for _ in range(5):\n            a, b = random.sample(range(1, k+1), 2)\n            if a == b:\n                continue\n            t = [b if c == a else a if c == b else c for c in s]\n            if t != s:\n                s = normalize_labels(t)\n                return s, \"SWAP_TWO_COLORS\"\n        # fallback\n        return recolor_move(s)\n\n    def kempe_chain_move(sol):\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(candidates)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return recolor_move(s)\n        b = random.choice(choices)\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] not in allowed:\n                continue\n            comp.append(x)\n            # enqueue neighbors having allowed colors only\n            for (p,q) in edges:\n                if p-1 == x:\n                    y = q-1\n                elif q-1 == x:\n                    y = p-1\n                else:\n                    continue\n                if not visited[y] and s[y] in allowed:\n                    visited[y] = True\n                    dq.append(y)\n        t = list(s)\n        for idx in comp:\n            t[idx] = b if t[idx] == a else a\n        t = normalize_labels(t)\n        if t != s:\n            return t, \"KEMPE_CHAIN_SWAP\"\n        # fallback\n        return recolor_move(s)\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (list(solution), \"INVALID_INPUT\")\n    try:\n        s0 = [int(x) for x in solution]\n        if any(x < 1 for x in s0):\n            return (s0, \"INVALID_INPUT\")\n    except Exception:\n        return (list(solution), \"INVALID_INPUT\")\n\n    s0 = normalize_labels(s0)\n    # Decide move type based on conflicts with guaranteed change\n    _, tot = conflicts_by_vertex(s0)\n    r = random.random()\n    if tot == 0:\n        if r < 0.55:\n            return kempe_chain_move(s0)\n        elif r < 0.85:\n            return swap_two_colors(s0)\n        else:\n            return recolor_move(s0)\n    else:\n        if r < 0.7:\n            return recolor_move(s0)\n        elif r < 0.9:\n            return kempe_chain_move(s0)\n        else:\n            return swap_two_colors(s0)\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong perturbation with color merge when feasible and conflict-driven repair\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def greedy_repair(sol, max_iters=100):\n        s = list(sol)\n        k = compute_k(s)\n        for _ in range(max_iters):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            i = random.choice(conflicted)\n            # choose best color in 1..k\n            best_colors = []\n            best_val = None\n            for col in range(1, k+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        return normalize_labels(s)\n\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        return list(solution)\n    try:\n        s = [int(x) for x in solution]\n        if any(x < 1 for x in s):\n            return list(solution)\n    except Exception:\n        return list(solution)\n\n    s = normalize_labels(s)\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt merge of two colors followed by greedy repair\n        a, b = random.sample(range(1, k+1), 2)\n        s = [a if c == b else c for c in s]\n        s = normalize_labels(s)\n        s = greedy_repair(s, max_iters=150)\n        return s\n\n    # Otherwise, multi-kick recolors of high-conflict vertices\n    steps = 6\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, k+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = normalize_labels(s)\n    s = greedy_repair(s, max_iters=120)\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9. solution[i-1] is the positive integer color assigned to vertex i (1-indexed). Labels may be non-contiguous during search; evaluator normalizes to contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Graph and penalties embedded locally (no globals per constraints)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    PEN_EDGE = 10**6\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n\n    # Ensure all entries are integers >=1; reject non-integers\n    s = []\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n        s.append(x)\n\n    # Normalize labels to contiguous {1..k}\n    mapping = {}\n    nxt = 1\n    sn = []\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sn.append(mapping[c])\n\n    # Compute k (max label after normalization)\n    k = 0\n    for x in sn:\n        if x > k:\n            k = x\n    if k == 0:\n        return int(HARD_PEN)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sn[u-1] == sn[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized\n    fitness = k + PEN_EDGE * conflicts\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns: (new_solution_list, move_type_str). Guarantees a changed solution when input is valid.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def neighbors_of(i: int) -> List[int]:\n        res = []\n        for (u, v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def compute_k(sol: List[int]) -> int:\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol: List[int]):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    # Validate input; if invalid, create a trivial changed solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback: generate a simple 2-color alternating pattern to ensure change\n        base = [1 if i % 2 == 0 else 2 for i in range(9)]\n        return (base, \"FALLBACK_INIT\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            base = [1 if i % 2 == 0 else 2 for i in range(9)]\n            return (base, \"FALLBACK_INIT\")\n\n    s0 = list(solution)\n\n    def recolor_move(sol: List[int]) -> Tuple[List[int], str]:\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Choose vertex: prefer highest conflicts; break ties randomly\n        if total > 0:\n            maxc = max(cnt)\n            cand = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(cand)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        # Evaluate colors 1..max(k, 2) to diversify; avoid no-op\n        palette = list(range(1, max(k, 2)+1))\n        if s[i] in palette and len(palette) > 1:\n            palette.remove(s[i])\n        best_colors = []\n        best_val = None\n        for col in palette:\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n        else:\n            s[i] = (s[i] % max(2, k)) + 1\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol: List[int]) -> Tuple[List[int], str]:\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        for _ in range(5):\n            a, b = random.sample(range(1, k+1), 2)\n            if a == b:\n                continue\n            t = [b if c == a else a if c == b else c for c in s]\n            if t != s:\n                return t, \"SWAP_TWO_COLORS\"\n        return recolor_move(s)\n\n    def kempe_chain_move(sol: List[int]) -> Tuple[List[int], str]:\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            cand = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(cand)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return recolor_move(s)\n        b = random.choice(choices)\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] not in allowed:\n                continue\n            comp.append(x)\n            for (p, q) in edges:\n                if p-1 == x:\n                    y = q-1\n                elif q-1 == x:\n                    y = p-1\n                else:\n                    continue\n                if not visited[y] and s[y] in allowed:\n                    visited[y] = True\n                    dq.append(y)\n        t = list(s)\n        for idx in comp:\n            t[idx] = b if t[idx] == a else a\n        if t != s:\n            return t, \"KEMPE_CHAIN_SWAP\"\n        return recolor_move(s)\n\n    def drop_color_move(sol: List[int]) -> Tuple[List[int], str]:\n        # Try to eliminate the smallest color class by greedy recoloring\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        # Count class sizes\n        sizes = {c: 0 for c in range(1, k+1)}\n        for c in s:\n            if c in sizes:\n                sizes[c] += 1\n        target = min(sizes, key=lambda c: sizes[c])\n        verts = [i for i, c in enumerate(s) if c == target]\n        palette = [c for c in range(1, k+1) if c != target]\n        random.shuffle(verts)\n        success = True\n        for i in verts:\n            # choose color minimizing local conflicts\n            best_colors = []\n            best_val = None\n            for col in palette:\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if not best_colors:\n                success = False\n                break\n            s[i] = random.choice(best_colors)\n        if success:\n            # Do not renormalize here; evaluator will compact labels.\n            # But replace any remaining 'target' color if any remained (safety)\n            s = [c if c != target else ((c % (k-1)) + 1) for c in s]\n            return s, \"DROP_COLOR\"\n        else:\n            return recolor_move(sol)\n\n    # Decide move based on conflict status\n    _, tot = conflicts_by_vertex(s0)\n    r = random.random()\n    if tot == 0:\n        if r < 0.45:\n            return drop_color_move(s0)\n        elif r < 0.8:\n            return kempe_chain_move(s0)\n        elif r < 0.95:\n            return swap_two_colors(s0)\n        else:\n            return recolor_move(s0)\n    else:\n        if r < 0.6:\n            return recolor_move(s0)\n        elif r < 0.85:\n            return kempe_chain_move(s0)\n        else:\n            return swap_two_colors(s0)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Strong perturbation: try color merge if feasible; otherwise conflict-driven multi-recolor + brief repair\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def neighbors_of(i: int):\n        res = []\n        for (u, v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def compute_k(sol: List[int]) -> int:\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol: List[int]):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def greedy_repair(sol: List[int], steps: int = 150) -> List[int]:\n        s = list(sol)\n        for _ in range(steps):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            if not conflicted:\n                break\n            i = random.choice(conflicted)\n            k = compute_k(s)\n            best_colors = []\n            best_val = None\n            for col in range(1, max(2, k)+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        return s\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback randomized 3-color init\n        return [random.randint(1, 3) for _ in range(9)]\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return [random.randint(1, 3) for _ in range(9)]\n\n    s = list(solution)\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt merge of two random colors, then repair\n        if k == 2:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(range(1, k+1), 2)\n        s = [a if c == b else c for c in s]\n        s = greedy_repair(s, steps=200)\n        return s\n\n    # Otherwise, kick multiple high-conflict vertices then repair\n    steps = 6\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, max(2, k)+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = greedy_repair(s, steps=180)\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Number of used groups (colors)\n    num_groups = len(set(solution))\n\n    # Heavy penalty for conflicts; lower is better\n    # Add tiny tie-breaker to slightly prefer lower max color label after compaction\n    max_label = max(solution)\n    return num_groups + conflicts * 1_000_000 + max_label * 1e-9\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"NoMove\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"NoMove\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Identify conflicts\n    conflicts = set()\n    for u, v in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    # DSATUR-like target selection: maximize number of distinct neighbor colors (prioritize conflicted)\n    candidates = list(conflicts) if conflicts else list(range(1, 10))\n    best_set = -1\n    target = random.choice(candidates)\n    for i in candidates:\n        neigh_colors = {new_sol[j-1] for j in adj[i]}\n        val = (len(neigh_colors), sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1]))\n        if val > (best_set, -1):\n            best_set = val[0]\n            target = i\n\n    palette = sorted(set(new_sol))\n    max_color = max(palette)\n\n    # Try improved move-set:\n    # 1) Attempt greedy recolor avoiding neighbor colors using existing palette only\n    neighbor_colors = {new_sol[j-1] for j in adj[target]}\n    feasible = [c for c in palette if c not in neighbor_colors]\n    move_type = (\"NB_Recolor\", \"One-Vertex\")\n\n    if feasible:\n        new_color = random.choice(feasible)\n        if new_color != new_sol[target-1]:\n            new_sol[target-1] = new_color\n            new_sol = compact_colors(new_sol)\n            return (new_sol, move_type)\n\n    # 2) Kempe chain swap between current color a and random color b from palette\n    a = new_sol[target-1]\n    b_choices = [c for c in palette if c != a]\n    if b_choices:\n        b = random.choice(b_choices)\n        # Build Kempe chain containing target with colors {a,b}\n        stack = [target]\n        visited = set([target])\n        chain = set([target])\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (a, b):\n                    visited.add(v)\n                    stack.append(v)\n                    chain.add(v)\n        # Swap colors a<->b on chain\n        for v in chain:\n            c = new_sol[v-1]\n            new_sol[v-1] = a if c == b else (b if c == a else c)\n        new_sol = compact_colors(new_sol)\n        return (new_sol, (\"NB_KempeSwap\", \"Two-Color-Chain\"))\n\n    # 3) As last resort, allow introducing a new color (rare)\n    if random.random() < 0.1:\n        new_sol[target-1] = max_color + 1\n        new_sol = compact_colors(new_sol)\n        return (new_sol, (\"NB_Recolor\", \"NewColor\"))\n\n    # No change possible (should be rare)\n    return (solution[:], (\"NB_NoOp\", \"Stall\"))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return it unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Strategy: perform r randomized moves mixing recolors and Kempe swaps\n    r = random.randint(2, 4)\n    for _ in range(r):\n        target = random.randint(1, 9)\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        neighbor_colors = {new_sol[j-1] for j in adj[target]}\n        feasible = [c for c in palette if c not in neighbor_colors]\n        move_roll = random.random()\n        if feasible and move_roll < 0.5:\n            # Greedy recolor to feasible color\n            new_color = random.choice(feasible)\n            new_sol[target-1] = new_color\n        elif len(palette) >= 2 and move_roll < 0.9:\n            # Kempe chain swap between two random colors\n            a = new_sol[target-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                stack = [target]\n                visited = set([target])\n                chain = set([target])\n                while stack:\n                    u = stack.pop()\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (a, b):\n                            visited.add(v)\n                            stack.append(v)\n                            chain.add(v)\n                for v in chain:\n                    c = new_sol[v-1]\n                    new_sol[v-1] = a if c == b else (b if c == a else c)\n        else:\n            # Introduce or attempt to remove a color via recolor\n            if random.random() < 0.5:\n                new_sol[target-1] = max_color + 1\n            else:\n                # Try recolor target to the smallest feasible color\n                for c in range(1, max_color + 1):\n                    if c not in neighbor_colors:\n                        new_sol[target-1] = c\n                        break\n        # Compact after each micro-perturb to stabilize labels\n        new_sol = compact_colors(new_sol)\n\n    return new_sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Compact labels to ensure label-invariant evaluation\n    relabel = {}\n    next_label = 1\n    compacted = solution[:]\n    for i in range(len(compacted)):\n        c = compacted[i]\n        if c not in relabel:\n            relabel[c] = next_label\n            next_label += 1\n        compacted[i] = relabel[c]\n\n    # Number of used groups (colors)\n    num_groups = len(relabel)\n\n    # Heavy penalty for conflicts; lower is better\n    return num_groups + conflicts * 1_000_000","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"NoMove\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"NoMove\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    new_sol = solution[:]\n\n    # Identify conflicts\n    conflicts_vertices = set()\n    for u, v in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n\n    palette = sorted(set(new_sol))\n    max_color = max(palette)\n\n    # Helper: attempt recolor of a single vertex to minimize conflicts using existing palette\n    def min_conflict_recolor(sol, v):\n        current = sol[v-1]\n        neigh_colors = {sol[j-1] for j in adj[v]}\n        best_c = current\n        best_conf = math.inf\n        for c in palette:\n            if c == current:\n                # evaluate keeping color too\n                pass\n            # compute local conflicts at v\n            local_conf = 0\n            for u in adj[v]:\n                if (c == sol[u-1]) and u != v:\n                    local_conf += 1\n            if local_conf < best_conf:\n                best_conf = local_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        if best_c != current:\n            sol[v-1] = best_c\n        return sol\n\n    # If there are conflicts, prioritize conflicted vertices\n    if conflicts_vertices:\n        # DSATUR-like selection with correct tie handling\n        target = None\n        best_key = (-1, -1)\n        for i in conflicts_vertices:\n            neigh_colors = {new_sol[j-1] for j in adj[i]}\n            local_conf = sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1])\n            key = (len(neigh_colors), local_conf)\n            if key > best_key:\n                best_key = key\n                target = i\n        # Try min-conflict recolor within existing palette first\n        trial = new_sol[:]\n        trial = min_conflict_recolor(trial, target)\n        if trial != new_sol:\n            return (compact_colors(trial), (\"NB_Recolor\", \"Min-Conflict\"))\n        # Kempe chain swap between two colors a and b to break conflicts\n        a = new_sol[target-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            # bias b towards most frequent neighbor color\n            neighbor_colors = [new_sol[j-1] for j in adj[target]]\n            freq = {}\n            for c in neighbor_colors:\n                freq[c] = freq.get(c, 0) + 1\n            b_choices.sort(key=lambda c: freq.get(c, 0), reverse=True)\n            b = b_choices[0]\n            stack = [target]\n            visited = {target}\n            chain = {target}\n            while stack:\n                u = stack.pop()\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (a, b):\n                        visited.add(v)\n                        stack.append(v)\n                        chain.add(v)\n            swapped = new_sol[:]\n            for v in chain:\n                c = swapped[v-1]\n                swapped[v-1] = a if c == b else (b if c == a else c)\n            return (compact_colors(swapped), (\"NB_KempeSwap\", \"Two-Color-Chain\"))\n        # As a last resort, introduce a new color with small probability\n        if random.random() < 0.1:\n            trial = new_sol[:]\n            trial[target-1] = max_color + 1\n            return (compact_colors(trial), (\"NB_Recolor\", \"NewColor\"))\n        return (new_sol[:], (\"NB_NoOp\", \"Stall\"))\n\n    # No conflicts: attempt explicit color elimination\n    # Select the smallest color class\n    color_to_vertices = {}\n    for i, c in enumerate(new_sol, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    smallest_color = min(color_to_vertices.keys(), key=lambda c: len(color_to_vertices[c]))\n\n    # Try to recolor all vertices of this class into existing palette without introducing a new color\n    target_vertices = color_to_vertices[smallest_color][:]\n    trial = new_sol[:]\n    success = True\n    # order by decreasing degree to be safer\n    target_vertices.sort(key=lambda v: len(adj[v]), reverse=True)\n    for v in target_vertices:\n        current = trial[v-1]\n        neigh_colors = {trial[j-1] for j in adj[v]}\n        feasible = [c for c in palette if c != current and c not in neigh_colors]\n        if not feasible:\n            success = False\n            break\n        # choose the color minimizing new potential conflicts (here zero by feasibility)\n        trial[v-1] = feasible[0]\n    if success:\n        return (compact_colors(trial), (\"ColorElim\", \"GreedyRecolorClass\"))\n\n    # If elimination failed, attempt a Kempe swap focused on freeing the smallest color\n    anchor = random.choice(target_vertices)\n    a = new_sol[anchor-1]\n    other_colors = [c for c in palette if c != a]\n    if other_colors:\n        # choose b maximizing adjacency interference with a\n        def interference(b):\n            count = 0\n            for u in color_to_vertices.get(a, []):\n                for w in adj[u]:\n                    if new_sol[w-1] == b:\n                        count += 1\n            return count\n        b = max(other_colors, key=interference)\n        stack = [anchor]\n        visited = {anchor}\n        chain = {anchor}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (a, b):\n                    visited.add(v)\n                    stack.append(v)\n                    chain.add(v)\n        swapped = new_sol[:]\n        for v in chain:\n            c = swapped[v-1]\n            swapped[v-1] = a if c == b else (b if c == a else c)\n        return (compact_colors(swapped), (\"NB_KempeSwap\", \"ClassFocused\"))\n\n    # Fallback: swap colors of two non-adjacent vertices to diversify\n    v1 = random.randint(1, 9)\n    non_adj = [i for i in range(1, 10) if i != v1 and i not in adj[v1]]\n    if non_adj:\n        v2 = random.choice(non_adj)\n        trial = new_sol[:]\n        trial[v1-1], trial[v2-1] = trial[v2-1], trial[v1-1]\n        return (compact_colors(trial), (\"PairSwap\", \"VertexSwap\"))\n\n    return (new_sol[:], (\"NB_NoOp\", \"Stall\"))","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return it unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Perform r randomized macro-moves mixing recolors and Kempe swaps\n    r = random.randint(2, 4)\n    for _ in range(r):\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        target = random.randint(1, 9)\n        neighbor_colors = {new_sol[j-1] for j in adj[target]}\n        move_roll = random.random()\n        if move_roll < 0.45:\n            # Greedy feasible recolor if possible\n            feasible = [c for c in palette if c not in neighbor_colors]\n            if feasible:\n                new_sol[target-1] = random.choice(feasible)\n        elif move_roll < 0.9 and len(palette) >= 2:\n            # Kempe chain swap between two random colors containing target\n            a = new_sol[target-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                stack = [target]\n                visited = {target}\n                chain = {target}\n                while stack:\n                    u = stack.pop()\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (a, b):\n                            visited.add(v)\n                            stack.append(v)\n                            chain.add(v)\n                for v in chain:\n                    c = new_sol[v-1]\n                    new_sol[v-1] = a if c == b else (b if c == a else c)\n        else:\n            # Introduce or attempt to collapse colors\n            if random.random() < 0.5:\n                new_sol[target-1] = max_color + 1\n            else:\n                # Try recoloring to smallest feasible color\n                for c in range(1, max_color + 1):\n                    if c not in neighbor_colors:\n                        new_sol[target-1] = c\n                        break\n        new_sol = compact_colors(new_sol)\n\n    return new_sol","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate type\/shape\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Compact labels to 1..k to keep evaluation invariant to relabeling\n    relabel = {}\n    next_label = 1\n    for i in range(len(solution)):\n        c = solution[i]\n        if c not in relabel:\n            relabel[c] = next_label\n            next_label += 1\n    k = len(relabel)\n\n    # Lexicographic objective: minimize conflicts first, then number of groups\n    # Lower is better\n    return conflicts * 1_000_000 + k\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"Shape\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"Value\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    degree = {i: len(adj[i]) for i in range(1, 10)}\n\n    def compact(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    cur = solution[:]\n\n    # Helper: pick conflicted vertex with tie-breaking (sat_deg, deg, local_conf)\n    def select_conflicted_vertex(sol):\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if not conflicts_vertices:\n            return None\n        best = None\n        best_key = (-1, -1, math.inf)\n        for i in conflicts_vertices:\n            neigh_colors = {sol[j-1] for j in adj[i]}\n            local_conf = sum(1 for j in adj[i] if sol[j-1] == sol[i-1])\n            key = (len(neigh_colors), degree[i], -local_conf)\n            if key > best_key:\n                best_key = key\n                best = i\n        return best\n\n    # Attempt recolor of vertex to reduce conflicts\n    def min_conflict_recolor(sol, v):\n        palette = sorted(set(sol))\n        current = sol[v-1]\n        best_c = current\n        best_local = math.inf\n        for c in palette:\n            local = 0\n            for u in adj[v]:\n                if c == sol[u-1]:\n                    local += 1\n            if local < best_local or (local == best_local and c < best_c):\n                best_local = local\n                best_c = c\n        if best_c != current:\n            sol[v-1] = best_c\n        return sol\n\n    # Kempe chain swap between colors a and b wrt anchor vertex v\n    def kempe_swap(sol, v, a, b):\n        stack = [v]\n        visited = {v}\n        chain = {v}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in visited and sol[w-1] in (a, b):\n                    visited.add(w)\n                    stack.append(w)\n                    chain.add(w)\n        out = sol[:]\n        for w in chain:\n            cw = out[w-1]\n            out[w-1] = a if cw == b else (b if cw == a else cw)\n        return out\n\n    K = 6  # retry budget to avoid NoOp\n    start_conf = count_conflicts(cur)\n\n    for _ in range(K):\n        palette = sorted(set(cur))\n        max_color = max(palette)\n        v = select_conflicted_vertex(cur)\n        if v is not None:\n            # 1) Min-conflict recolor within palette\n            trial = min_conflict_recolor(cur[:], v)\n            if trial != cur:\n                return (compact(trial), (\"NB_Recolor\", \"MinConflict\"))\n            # 2) Kempe swap with most frequent neighbor color\n            neigh_cols = [cur[u-1] for u in adj[v]]\n            if neigh_cols:\n                freq = {}\n                for c in neigh_cols:\n                    freq[c] = freq.get(c, 0) + 1\n                b = max(freq.keys(), key=lambda c: freq[c])\n                a = cur[v-1]\n                if b != a:\n                    swapped = kempe_swap(cur, v, a, b)\n                    if count_conflicts(swapped) <= start_conf:\n                        return (compact(swapped), (\"NB_KempeSwap\", \"ConflictNonWorsening\"))\n            # 3) Temporary new color for v (escape), then compact\n            temp = cur[:]\n            temp[v-1] = max_color + 1\n            return (compact(temp), (\"NB_Recolor\", \"NewColorEscape\"))\n        else:\n            # No conflicts: try to eliminate a color class\n            color_to_vertices = {}\n            for i, c in enumerate(cur, start=1):\n                color_to_vertices.setdefault(c, []).append(i)\n            # smallest class first\n            target_color = min(color_to_vertices.keys(), key=lambda c: len(color_to_vertices[c]))\n            vertices = sorted(color_to_vertices[target_color], key=lambda x: -degree[x])\n            trial = cur[:]\n            success = True\n            for u in vertices:\n                neigh_colors = {trial[w-1] for w in adj[u]}\n                # feasible colors excluding current target_color\n                feas = [c for c in palette if c != target_color and c not in neigh_colors]\n                if not feas:\n                    success = False\n                    break\n                # choose smallest color id (deterministic and compact)\n                trial[u-1] = min(feas)\n            if success:\n                return (compact(trial), (\"ColorElim\", \"GreedyMerge\"))\n            # If merge failed, do a diversification Kempe swap between two random colors\n            if len(palette) >= 2:\n                a = random.choice(palette)\n                b = random.choice([c for c in palette if c != a])\n                anchor = random.choice(color_to_vertices.get(a, [1]))\n                swapped = kempe_swap(cur, anchor, a, b)\n                if swapped != cur:\n                    return (compact(swapped), (\"NB_KempeSwap\", \"Diversify\"))\n            # Last resort: recolor random vertex to a feasible existing color\n            u = random.randint(1, 9)\n            neigh_colors = {cur[w-1] for w in adj[u]}\n            feas = [c for c in palette if c not in neigh_colors]\n            if feas:\n                trial = cur[:]\n                trial[u-1] = random.choice(feas)\n                if trial != cur:\n                    return (compact(trial), (\"NB_Recolor\", \"FeasibleRandom\"))\n            # Fallback color swap (global)\n            if len(palette) >= 2:\n                a, b = palette[0], palette[-1]\n                trial = [a if x == b else (b if x == a else x) for x in cur]\n                if trial != cur:\n                    return (compact(trial), (\"ColorSwap\", \"GlobalAB\"))\n\n    # If all else fails, return a deterministic no-op copy (should be rare)\n    return (cur[:], (\"NB_NoOp\", \"RetryBudgetExhausted\"))\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    def kempe_swap(sol, v, a, b):\n        stack = [v]\n        visited = {v}\n        chain = {v}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in visited and sol[w-1] in (a, b):\n                    visited.add(w)\n                    stack.append(w)\n                    chain.add(w)\n        out = sol[:]\n        for w in chain:\n            cw = out[w-1]\n            out[w-1] = a if cw == b else (b if cw == a else cw)\n        return out\n\n    new_sol = solution[:]\n\n    # Apply L randomized macro-moves\n    L = 3 + (sum(1 for _ in set(new_sol)) % 2)  # 3 or 4 steps depending on palette size parity\n    for _ in range(L):\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        v = random.randint(1, 9)\n        roll = random.random()\n        if roll < 0.4:\n            # Greedy feasible recolor if possible\n            neigh_colors = {new_sol[w-1] for w in adj[v]}\n            feas = [c for c in palette if c not in neigh_colors]\n            if feas:\n                new_sol[v-1] = random.choice(feas)\n        elif roll < 0.85 and len(palette) >= 2:\n            # Kempe chain swap around v\n            a = new_sol[v-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                new_sol = kempe_swap(new_sol, v, a, b)\n        else:\n            # Temporary new color or collapse to smallest available color\n            if random.random() < 0.5:\n                new_sol[v-1] = max_color + 1\n            else:\n                neigh_colors = {new_sol[w-1] for w in adj[v]}\n                for c in range(1, max_color + 1):\n                    if c not in neigh_colors:\n                        new_sol[v-1] = c\n                        break\n        new_sol = compact(new_sol)\n\n    return new_sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] of length 9; solution[i] is color (1-based) for vertex i+1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute score\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Adaptive penalty within reasonable scale for annealing\n    penalty_lambda = 500\n    return K + penalty_lambda * conflicts\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Prepare working copy\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency and degree\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    degree = [len(adj[i]) for i in range(n)]\n    # Conflict counts and saturation degrees\n    conflict_count = [0] * n\n    neighbor_color_sets = []\n    for i in range(n):\n        ncols = set(sol[j] for j in adj[i])\n        neighbor_color_sets.append(ncols)\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    K = max(sol)\n    # Select target vertex\n    if any(c > 0 for c in conflict_count):\n        # prioritize by conflicts, then degree, then saturation size\n        order = sorted(range(n), key=lambda i: (conflict_count[i], degree[i], len(neighbor_color_sets[i])), reverse=True)\n        idx = order[0]\n    else:\n        # No conflicts: try reduce K by modifying a vertex using color K, else random\n        max_color_vertices = [i for i, c in enumerate(sol) if c == K]\n        if max_color_vertices:\n            idx = random.choice(max_color_vertices)\n        else:\n            idx = random.randrange(n)\n    # Feasible colors: avoid neighbors' colors and current color\n    forbidden = neighbor_color_sets[idx]\n    current_color = sol[idx]\n    # When conflict-free, disallow increasing K in neighbor move\n    palette_max = K\n    candidates = [c for c in range(1, palette_max + 1) if c != current_color and c not in forbidden]\n    if not candidates:\n        # If no strictly feasible color, allow a random change within 1..K to diversify (may introduce conflicts)\n        alt = [c for c in range(1, palette_max + 1) if c != current_color]\n        if alt:\n            new_color = random.choice(alt)\n        else:\n            new_color = current_color\n    else:\n        new_color = random.choice(candidates)\n    new_sol = list(sol)\n    new_sol[idx] = new_color\n    return new_sol, \"Recolor\", (\"Conflict-Driven\" if conflict_count[idx] > 0 else \"K-Reduction-Biased\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution (Kempe chain swap or multi-vertex recolor targeting max color)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    K = max(sol)\n    mode = random.random()\n    if mode < 0.5 and K >= 2:\n        # Kempe-chain swap between two random used colors\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        # BFS within subgraph induced by colors {c1, c2}\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = [seed]\n        while q:\n            i = q.pop()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        # Swap colors on component\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    else:\n        # Multi-vertex recolor focusing on vertices with max color K\n        targets = [i for i, c in enumerate(sol) if c == K]\n        if not targets:\n            targets = random.sample(range(n), k=min(3, n))\n        m = min(len(targets), max(2, len(targets)\/\/2))\n        chosen = random.sample(targets, m)\n        for idx in chosen:\n            neighbor_colors = set(sol[j] for j in adj[idx])\n            choices = [c for c in range(1, K) if c not in neighbor_colors]\n            if not choices:\n                # fallback allow any color <= K (may introduce conflicts)\n                choices = [c for c in range(1, K+1) if c != sol[idx]]\n            if choices:\n                sol[idx] = random.choice(choices)\n        return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] length 9; solution[i] is color (1-based) for vertex i+1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (embedded)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate solution\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts and K\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    # Lexicographic-like composite: conflicts dominate, then K\n    penalty_lambda = 1000\n    score = conflicts * penalty_lambda + K\n    return int(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, meta_dict)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Initialize\/validate solution\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Compute neighbor color sets and conflict counts\n    neighbor_colors = [set(sol[j] for j in adj[i]) for i in range(n)]\n    conflict_count = [0] * n\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        if sol[u0] == sol[v0]:\n            conflict_count[u0] += 1\n            conflict_count[v0] += 1\n    K = max(sol) if sol else 1\n    # DSATUR-like priority with conflict emphasis\n    saturation = [len(neighbor_colors[i]) for i in range(n)]\n    degree = [len(adj[i]) for i in range(n)]\n    order = list(range(n))\n    order.sort(key=lambda i: (conflict_count[i] > 0, conflict_count[i], saturation[i], degree[i]), reverse=True)\n    # Try up to 3 candidate vertices to avoid no-move cases\n    chosen_idx = None\n    new_color = None\n    move_type = \"recolor\"\n    for idx in order[:3]:\n        forbid = neighbor_colors[idx]\n        cur = sol[idx]\n        # Allow K+1 with small probability when conflicts exist\n        allow_expand = (any(c > 0 for c in conflict_count) and random.random() < 0.1)\n        palette_max = K + (1 if allow_expand else 0)\n        candidates = [c for c in range(1, palette_max + 1) if c != cur and c not in forbid]\n        if candidates:\n            chosen_idx = idx\n            new_color = random.choice(candidates)\n            break\n    if chosen_idx is None:\n        # Fallback: random vertex recolor within 1..max(K,2)\n        idx = random.randrange(n)\n        palette_max = max(K, 2)\n        alt = [c for c in range(1, palette_max + 1) if c != sol[idx]]\n        if alt:\n            chosen_idx = idx\n            new_color = random.choice(alt)\n        else:\n            return sol, {\"move\": \"noop\"}\n    new_sol = list(sol)\n    new_sol[chosen_idx] = new_color\n    meta = {\"move\": move_type, \"idx\": chosen_idx, \"from\": sol[chosen_idx], \"to\": new_color}\n    return new_sol, meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Kempe-chain swap or multi-vertex recolor focusing on max color\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    K = max(sol) if sol else 1\n    if random.random() < 0.5 and K >= 2:\n        # Kempe-chain swap between two used colors\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        # pick seed among vertices with color c1 or c2\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = deque([seed])\n        while q:\n            i = q.popleft()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    else:\n        # Recolor a subset of vertices with max color K or incident to conflicts\n        conflict = [0] * n\n        for (u, v) in E:\n            u0, v0 = u - 1, v - 1\n            if sol[u0] == sol[v0]:\n                conflict[u0] += 1\n                conflict[v0] += 1\n        targets = [i for i, c in enumerate(sol) if c == K]\n        if not targets:\n            targets = [i for i, cc in enumerate(conflict) if cc > 0]\n        if not targets:\n            targets = list(range(n))\n        k = max(2, min(4, len(targets)))\n        chosen = random.sample(targets, min(k, len(targets)))\n        for idx in chosen:\n            neigh_cols = set(sol[j] for j in adj[idx])\n            choices = [c for c in range(1, max(2, K) + 1) if c != sol[idx] and c not in neigh_cols]\n            if not choices:\n                # Allow temporary K+1 to diversify\n                choices = [c for c in range(1, K + 2) if c != sol[idx]]\n            sol[idx] = random.choice(choices)\n        return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] length 9; solution[i] is color (1-based) for vertex i+1","Evaluacion":"import random\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate solution\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(c, int) and c >= 1 for c in solution)):\n        return 10**9\n    # Compute conflicts and K\n    conflicts = sum(1 for (u, v) in E if solution[u-1] == solution[v-1])\n    K = max(solution)\n    # Lexicographic dominance via large scalarization (conflicts dominate, then K)\n    return conflicts * 10**9 + K\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    sol = list(solution) if isinstance(solution, list) and len(solution) == n else [random.randint(1, 3) for _ in range(n)]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v); adj[v].append(u)\n    K = max(sol)\n    # Compute conflicts\n    conflict = [0] * n\n    for (u, v) in E:\n        u -= 1; v -= 1\n        if sol[u] == sol[v]:\n            conflict[u] += 1; conflict[v] += 1\n    total_conflicts = sum(conflict) \/\/ 2\n    # If conflict-free, attempt K reduction by recoloring a K-colored vertex to [1..K-1]\n    if total_conflicts == 0:\n        ks = [i for i, c in enumerate(sol) if c == K]\n        random.shuffle(ks)\n        for idx in ks:\n            forbid = {sol[j] for j in adj[idx]}\n            candidates = [c for c in range(1, K) if c not in forbid]\n            if candidates:\n                new_sol = sol[:]\n                new_sol[idx] = random.choice(candidates)\n                move = \"K-reduce\" if max(new_sol) < K else \"recolor\"\n                return new_sol, (\"1-vertex\", move)\n    # Conflict-directed recolor: prioritize vertices with conflicts, then higher saturation and degree\n    sat = [len({sol[j] for j in adj[i]}) for i in range(n)]\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (conflict[i], sat[i], deg[i]), reverse=True)\n    for idx in order[:3]:\n        forbid = {sol[j] for j in adj[idx]}\n        cur = sol[idx]\n        candidates = [c for c in range(1, K + 1) if c != cur and c not in forbid]\n        if candidates:\n            new_sol = sol[:]\n            new_sol[idx] = random.choice(candidates)\n            return new_sol, (\"1-vertex\", \"recolor\")\n    # Fallback random recolor within current palette to ensure a move\n    idx = random.randrange(n)\n    alt = [c for c in range(1, max(K, 2) + 1) if c != sol[idx]]\n    if alt:\n        new_sol = sol[:]\n        new_sol[idx] = random.choice(alt)\n        return new_sol, (\"fallback\", \"recolor\")\n    return sol, (\"noop\", \"noop\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Kempe-chain swap or multi-vertex recolor focusing on high colors\/conflicts\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    sol = list(solution) if isinstance(solution, list) and len(solution) == n else [random.randint(1, 3) for _ in range(n)]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v); adj[v].append(u)\n    K = max(sol)\n    # With 60% chance perform Kempe-chain swap between two used colors\n    if random.random() < 0.6 and K >= 2:\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = deque([seed])\n        while q:\n            i = q.popleft()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    # Otherwise, recolor a subset biased to max color and conflicted vertices\n    conflict = [0] * n\n    for (u, v) in E:\n        u -= 1; v -= 1\n        if sol[u] == sol[v]:\n            conflict[u] += 1; conflict[v] += 1\n    targets = [i for i, c in enumerate(sol) if c == K]\n    if not targets:\n        targets = [i for i, cc in enumerate(conflict) if cc > 0] or list(range(n))\n    m = max(2, min(4, len(targets)))\n    chosen = random.sample(targets, m)\n    for idx in chosen:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        palette_max = max(2, K)\n        choices = [c for c in range(1, palette_max + 1) if c != sol[idx] and c not in neigh_cols]\n        if not choices:\n            # allow temporary expansion to diversify\n            choices = [c for c in range(1, K + 2) if c != sol[idx]]\n        sol[idx] = random.choice(choices)\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","Evaluacion":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","Vecindad":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a legal neighbouring solution (list[int])\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    cur = deepcopy(solution)\n    if not isinstance(cur, list) or len(cur) != n:\n        # Create a quick feasible fallback by greedy coloring\n        order = list(range(n))\n        random.shuffle(order)\n        cur = [1]*n\n        for i in order:\n            used = {cur[j] for j in adj[i]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[i] = c\n    maxc = max(cur)\n\n    def kempe_chain_swap(sol, v_idx, color_a, color_b):\n        # BFS on subgraph induced by colors {a,b}, swap in connected component containing v_idx\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (color_a, color_b) and y not in seen:\n                    if any(True for _ in [0]):\n                        seen.add(y)\n                        q.append(y)\n        # Swap colors in component\n        for x in seen:\n            if sol[x] == color_a:\n                sol[x] = color_b\n            elif sol[x] == color_b:\n                sol[x] = color_a\n        return sol\n\n    move_type = random.random()\n    new_sol = deepcopy(cur)\n\n    if move_type < 0.5:\n        # Single-vertex feasible recolor with smallest available color\n        i = random.randrange(n)\n        used = {new_sol[j] for j in adj[i]}\n        candidates = [c for c in range(1, max(new_sol)) if c not in used]\n        if not candidates:\n            candidates = [c for c in range(1, max(new_sol)+1) if c not in used]\n        if candidates:\n            new_sol[i] = random.choice(candidates)\n        else:\n            # Try Kempe swap to free a color\n            target_color = new_sol[i]\n            alt = random.choice([c for c in range(1, max(new_sol)+1) if c != target_color] or [target_color])\n            new_sol = kempe_chain_swap(new_sol, i, target_color, alt)\n    else:\n        # Kempe-chain swap between two colors touching a random vertex\n        v = random.randrange(n)\n        neigh_colors = list({new_sol[u] for u in adj[v]})\n        if len(neigh_colors) >= 1:\n            a = new_sol[v]\n            b = random.choice(neigh_colors)\n            if a != b:\n                new_sol = kempe_chain_swap(new_sol, v, a, b)\n        else:\n            # Fallback to single recolor if isolated (unlikely here)\n            used = {new_sol[j] for j in adj[v]}\n            candidates = [c for c in range(1, max(new_sol)) if c not in used] or [c for c in range(1, max(new_sol)+1) if c not in used] or [max(new_sol)]\n            new_sol[v] = random.choice(candidates)\n\n    # Ensure feasibility by repairing if needed\n    def repair(sol):\n        sol = normalize_colors(sol)\n        for (u, v) in E:\n            u -= 1; v -= 1\n            if sol[u] == sol[v]:\n                # Recolor u greedily\n                used = {sol[w] for w in adj[u]}\n                c = 1\n                while c in used:\n                    c += 1\n                sol[u] = c\n        return normalize_colors(sol)\n\n    new_sol = repair(new_sol)\n    new_sol = normalize_colors(new_sol)\n    return new_sol\n","Perturbacion":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: a few Kempe-chain swaps and attempt to reduce highest color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    cur = deepcopy(solution)\n    if not isinstance(cur, list) or len(cur) != n:\n        # Greedy fallback\n        cur = [1]*n\n        for i in range(n):\n            used = {cur[j] for j in adj[i]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[i] = c\n\n    def kempe_component(sol, v_idx, color_a, color_b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (color_a, color_b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, color_a, color_b):\n        for x in comp:\n            if sol[x] == color_a:\n                sol[x] = color_b\n            elif sol[x] == color_b:\n                sol[x] = color_a\n        return sol\n\n    # Apply 2-3 Kempe-chain swaps\n    t = random.randint(2, 3)\n    for _ in range(t):\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        if not neigh_colors:\n            continue\n        b = random.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        cur = kempe_swap(cur, comp, a, b)\n\n    # Attempt to eliminate the highest color class by greedy recolor\n    cur = normalize_colors(cur)\n    maxc = max(cur)\n    highest = [i for i, c in enumerate(cur) if c == maxc]\n    random.shuffle(highest)\n    for i in highest:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, maxc) if c not in used]\n        if candidates:\n            cur[i] = random.choice(candidates)\n    cur = normalize_colors(cur)\n\n    # Final quick repair to ensure feasibility\n    for (u, v) in E:\n        u -= 1; v -= 1\n        if cur[u] == cur[v]:\n            used = {cur[w] for w in adj[u]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[u] = c\n    return normalize_colors(cur)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","Evaluacion":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","Vecindad":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_description)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            # pick vertex with max saturation, tie-break on degree\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def kempe_chain_swap(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        for x in seen:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible(sol):\n        # Loop until all conflicts resolved. Introduce new color only if unavoidable.\n        changed = True\n        nloc = len(sol)\n        while changed:\n            changed = False\n            for u in range(nloc):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        # recolor vertex with higher degree; tiebreak on larger color id\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        cap = max(sol)\n                        c = 1\n                        while c in used and c <= cap:\n                            c += 1\n                        if c > cap:\n                            c = cap + 1\n                        if sol[pick] != c:\n                            sol[pick] = c\n                            changed = True\n        return sol\n\n    def recolor_vertex(sol, i):\n        used = {sol[j] for j in adj[i]}\n        cap = max(sol)\n        feasible = [c for c in range(1, cap+1) if c not in used]\n        if feasible:\n            # least-constraining color heuristic\n            def lc_cost(c):\n                cost = 0\n                for j in adj[i]:\n                    nbr_used = {sol[k] for k in adj[j] if k != i}\n                    if c in nbr_used:\n                        cost += 1\n                return cost\n            best_c = min(feasible, key=lc_cost)\n            sol[i] = best_c\n            return sol, \"recolor\"\n        # unavoidable: allow a new color\n        sol[i] = cap + 1\n        return sol, \"recolor_new\"\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n else dsatur_init()\n\n    move_r = random.random()\n    if move_r < 0.5:\n        # Single-vertex recolor attempt\n        i = random.randrange(n)\n        new_sol = cur[:]\n        new_sol, mtype = recolor_vertex(new_sol, i)\n        new_sol = repair_feasible(new_sol)\n        return new_sol, mtype\n    else:\n        # Kempe-chain swap around a random vertex and a neighbor color\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        new_sol = cur[:]\n        mtype = \"kempe_noop\"\n        if neigh_colors:\n            b = random.choice(neigh_colors)\n            if a != b:\n                before_cap = max(new_sol)\n                new_sol = kempe_chain_swap(new_sol, v, a, b)\n                # small acceptance filter: avoid k inflation\n                if max(new_sol) > before_cap:\n                    # revert with small probability to maintain diversity\n                    if random.random() < 0.2:\n                        pass\n                    else:\n                        new_sol = cur[:]\n                else:\n                    mtype = \"kempe\"\n        new_sol = repair_feasible(new_sol)\n        return new_sol, mtype\n","Perturbacion":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple Kempe-chain swaps and targeted reduction of highest color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def kempe_component(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, a, b):\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible(sol):\n        changed = True\n        nloc = len(sol)\n        while changed:\n            changed = False\n            for u in range(nloc):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        cap = max(sol)\n                        c = 1\n                        while c in used and c <= cap:\n                            c += 1\n                        if c > cap:\n                            c = cap + 1\n                        if sol[pick] != c:\n                            sol[pick] = c\n                            changed = True\n        return sol\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n else dsatur_init()\n\n    # Apply several Kempe swaps\n    t = random.randint(2, 4)\n    for _ in range(t):\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        if not neigh_colors:\n            continue\n        b = random.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        cur = kempe_swap(cur, comp, a, b)\n\n    # Attempt to eliminate the highest color class\n    cap = max(cur)\n    top_vertices = [i for i, c in enumerate(cur) if c == cap]\n    random.shuffle(top_vertices)\n    for i in top_vertices:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, cap) if c not in used]\n        if candidates:\n            cur[i] = random.choice(candidates)\n\n    cur = repair_feasible(cur)\n    return cur\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] length=9; 1-based color indices. solution[i-1] is color of vertex i. Domain: integers >=1.","Evaluacion":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 10**6\n    CONFLICT_WEIGHT = 1000\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # graded penalty to provide guidance in infeasible region\n        return PENALTY_BASE + conflicts * CONFLICT_WEIGHT + max(solution)\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","Vecindad":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_description)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def is_feasible(sol):\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n\n    def kempe_component(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, a, b):\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible_cap(sol, cap):\n        # Try to fix conflicts without introducing new colors; if impossible, return None\n        changed = True\n        while changed:\n            changed = False\n            for u in range(n):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        # attempt to recolor the more constrained vertex within [1..cap]\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        new_color = None\n                        for c in range(1, cap+1):\n                            if c not in used:\n                                new_color = c\n                                break\n                        if new_color is None:\n                            return None\n                        if sol[pick] != new_color:\n                            sol[pick] = new_color\n                            changed = True\n        return sol\n\n    def greedy_recolor_class_under_cap(sol, target_color, cap):\n        # Try to recolor all vertices of target_color into colors in [1..cap] excluding target_color\n        verts = [i for i,c in enumerate(sol) if c == target_color]\n        # DSATUR-like order: by number of distinct neighbor colors\n        order = sorted(verts, key=lambda i: len({sol[j] for j in adj[i]}), reverse=True)\n        new_sol = sol[:]\n        for i in order:\n            used = {new_sol[j] for j in adj[i]}\n            candidates = [c for c in range(1, cap+1) if c != target_color and c not in used]\n            if not candidates:\n                return None\n            # least-constraining choice\n            def lc_cost(c):\n                cost = 0\n                for j in adj[i]:\n                    nbr_used = {new_sol[k] for k in adj[j] if k != i}\n                    if c in nbr_used:\n                        cost += 1\n                return cost\n            new_sol[i] = min(candidates, key=lc_cost)\n        return new_sol\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution) else dsatur_init()\n    if not is_feasible(cur):\n        cur = dsatur_init()\n    current_k = max(cur)\n\n    # Define a sequence of neighborhood attempts prioritized by k-reduction\n    # 1) COLOR_MERGE: try to eliminate highest color class\n    top_color = current_k\n    merged = greedy_recolor_class_under_cap(cur, top_color, current_k - 1) if current_k > 1 else None\n    if merged is not None and is_feasible(merged):\n        return merged, \"COLOR_MERGE\"\n\n    # 2) TARGETED_KEMPE around a vertex in the highest color class\n    top_vertices = [i for i,c in enumerate(cur) if c == top_color]\n    if top_vertices:\n        v = random.choice(top_vertices)\n        a = cur[v]\n        neigh_cols = list({cur[u] for u in adj[v] if cur[u] != a})\n        random.shuffle(neigh_cols)\n        for b in neigh_cols:\n            trial = cur[:]\n            comp = kempe_component(trial, v, a, b)\n            trial = kempe_swap(trial, comp, a, b)\n            if max(trial) <= current_k:\n                fixed = repair_feasible_cap(trial[:], current_k)\n                if fixed is not None and is_feasible(fixed):\n                    return fixed, \"TARGETED_KEMPE\"\n\n    # 3) RECOLOR a random vertex to a different feasible color within cap\n    i = random.randrange(n)\n    used = {cur[j] for j in adj[i]}\n    candidates = [c for c in range(1, current_k+1) if c != cur[i] and c not in used]\n    random.shuffle(candidates)\n    for c in candidates:\n        trial = cur[:]\n        trial[i] = c\n        fixed = repair_feasible_cap(trial, current_k)\n        if fixed is not None and is_feasible(fixed):\n            return fixed, \"RECOLOR\"\n\n    # 4) PAIRWISE_COLOR_SWAP of two color classes to unlock structures\n    if current_k >= 2:\n        a, b = random.sample(range(1, current_k+1), 2)\n        trial = cur[:]\n        for idx, val in enumerate(trial):\n            if val == a:\n                trial[idx] = b\n            elif val == b:\n                trial[idx] = a\n        fixed = repair_feasible_cap(trial, current_k)\n        if fixed is not None and is_feasible(fixed):\n            return fixed, \"PAIRWISE_COLOR_SWAP\"\n\n    # Fallback: return current solution (already feasible)\n    return cur[:], \"NOOP\"\n","Perturbacion":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Deterministic w.r.t input: use local RNG seeded by hash of the solution tuple\n    rng = random.Random(hash(tuple(solution)) if isinstance(solution, list) else 0)\n\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def is_feasible(sol):\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n\n    def kempe_component(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, a, b):\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible_cap(sol, cap):\n        # Try to fix conflicts without introducing new colors; if impossible, return None\n        changed = True\n        while changed:\n            changed = False\n            for u in range(n):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        used = {sol[w] for w in adj[u]}\n                        new_color = None\n                        for c in range(1, cap+1):\n                            if c not in used:\n                                new_color = c\n                                break\n                        if new_color is None:\n                            return None\n                        if sol[u] != new_color:\n                            sol[u] = new_color\n                            changed = True\n        return sol\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution) else dsatur_init()\n    if not is_feasible(cur):\n        cur = dsatur_init()\n    cap = max(cur)\n\n    # Apply several deterministic Kempe swaps using local RNG, keeping cap\n    t = rng.randint(2, 5)\n    for _ in range(t):\n        v = rng.randrange(n)\n        a = cur[v]\n        neigh_colors = [cur[u] for u in adj[v] if cur[u] != a]\n        if not neigh_colors:\n            continue\n        b = rng.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        trial = kempe_swap(cur[:], comp, a, b)\n        if max(trial) <= cap:\n            fixed = repair_feasible_cap(trial, cap)\n            if fixed is not None and is_feasible(fixed):\n                cur = fixed\n\n    # Shuffle color classes by a deterministic permutation\n    perm = list(range(1, cap+1))\n    rng.shuffle(perm)\n    relabel = {i+1: perm[i] for i in range(cap)}\n    cur = [relabel[c] for c in cur]\n\n    # Try to reduce usage of the highest color by greedy recoloring within cap\n    top = cap\n    idxs = [i for i,c in enumerate(cur) if c == top]\n    rng.shuffle(idxs)\n    for i in idxs:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, cap) if c not in used]\n        if candidates:\n            cur[i] = rng.choice(candidates)\n    fixed = repair_feasible_cap(cur[:], cap)\n    if fixed is not None and is_feasible(fixed):\n        return fixed\n    # Fallback to feasible original under cap\n    return cur if is_feasible(cur) else dsatur_init()\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better. Feasibility strongly enforced; objective = number of colors when feasible\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        # heavy penalty, but preserve gradient with magnitude proportional to size error\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count issues\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness\n    fitness = 0\n    # Penalize structural\/type issues strongly\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    # Penalize violations very strongly\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        # Feasible: objective is the number of colors\n        fitness = k_used\n    else:\n        # Infeasible: add small pressure to reduce colors while repairing\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random, math\n\n\ndef _normalize_colors(sol):\n    # Relabel colors to a compact 1..k to stabilize k_used\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        c = c if isinstance(c, int) and c >= 1 else 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Single-node recolor favoring diversification within current palette; robust to malformed inputs\n    n = 9\n    base = list(solution)[:n] if isinstance(solution, (list, tuple)) else [1]*n\n    if len(base) < n:\n        base = base + [1]*(n - len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n    colors = _normalize_colors(colors)\n\n    max_c = max(colors) if colors else 1\n    idx = random.randrange(0, n)\n    current_color = colors[idx]\n\n    # Candidate colors within current palette; allow +1 with small probability to diversify\n    allow_new = (random.random() < 0.15)\n    max_try = max_c + (1 if allow_new else 0)\n    candidates = [c for c in range(1, max_try + 1) if c != current_color]\n    if not candidates:\n        candidates = [1 if current_color != 1 else 2]\n    new_color = random.choice(candidates)\n\n    neighbor = colors[:]\n    neighbor[idx] = new_color\n    neighbor = _normalize_colors(neighbor)\n\n    return (neighbor, \"single-recolor\")\n","Perturbacion":"import random, math\n\n\ndef _normalize_colors(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        c = c if isinstance(c, int) and c >= 1 else 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    # Stronger shake using multi-recolor and optional color swap (Kempe-style light)\n    n = 9\n    base = list(solution)[:n] if isinstance(solution, (list, tuple)) else [1]*n\n    if len(base) < n:\n        base = base + [1]*(n - len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n    colors = _normalize_colors(colors)\n\n    max_c = max(colors) if colors else 1\n\n    # Randomly recolor k nodes\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        # Allow introduction of at most one new color during perturbation\n        allow_new = (random.random() < 0.5)\n        max_try = max_c + (1 if allow_new else 0)\n        cand = [c for c in range(1, max_try + 1) if c != colors[idx]]\n        if cand:\n            colors[idx] = random.choice(cand)\n    colors = _normalize_colors(colors)\n\n    # Optional swap two existing colors to escape symmetry basins\n    max_c = max(colors) if colors else 1\n    if max_c >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, max_c + 1), 2)\n        for i in range(n):\n            if colors[i] == a:\n                colors[i] = b\n            elif colors[i] == b:\n                colors[i] = a\n        colors = _normalize_colors(colors)\n\n    return colors\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better. Feasibility strongly enforced; objective = number of colors when feasible\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count issues\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Mixed neighborhood: single-node recolor (conflict-minimizing), Kempe-chain swap, non-edge vertex color swap\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Coerce to valid length-9 positive-int list\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u,v in edges:\n            if sol[u] == sol[v]:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol):\n        kmax = max(sol) if sol else 1\n        i = random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        # With small probability, allow a new color\n        if random.random() < 0.1:\n            candidates.append(kmax+1)\n        best = None\n        best_conf = None\n        # Evaluate local conflicts at i only for speed\n        neigh = adj[i]\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best = c\n            elif conf == best_conf and random.random() < 0.5:\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out), \"single-recolor\"\n\n    def kempe_swap(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return recolor_min_conflict(sol)\n        a,b = random.sample(range(1, kmax+1), 2)\n        # pick a start vertex with color a or b\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return recolor_min_conflict(sol)\n        s = random.choice(cand)\n        target_colors = {a,b}\n        visited = [False]*n\n        comp = []\n        dq = deque([s])\n        visited[s] = True\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and sol[v] in target_colors:\n                    visited[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out), \"kempe-swap\"\n\n    def vertex_color_swap(sol):\n        # swap colors of two non-adjacent vertices\n        non_edges = []\n        is_adj = [[False]*n for _ in range(n)]\n        for u,v in edges:\n            is_adj[u][v] = True\n            is_adj[v][u] = True\n        for i in range(n):\n            for j in range(i+1, n):\n                if not is_adj[i][j]:\n                    non_edges.append((i,j))\n        if not non_edges:\n            return recolor_min_conflict(sol)\n        i,j = random.choice(non_edges)\n        out = sol[:]\n        out[i], out[j] = out[j], out[i]\n        return normalize(out), \"vertex-swap\"\n\n    colors = normalize(colors)\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb, mtype = recolor_min_conflict(colors)\n    elif move_pick < 0.8:\n        nb, mtype = kempe_swap(colors)\n    else:\n        nb, mtype = vertex_color_swap(colors)\n\n    # Final safety: enforce ints >=1 and length n\n    nb = [int(c) if isinstance(c,int) and c>=1 else 1 for c in nb[:n]]\n    return (nb, mtype)\n","Perturbacion":"import random, math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple conflict-minimizing recolors + Kempe swaps; returns a valid solution list\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def recolor_min_conflict_once(sol, allow_new_prob=0.2):\n        kmax = max(sol) if sol else 1\n        i = random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        if random.random() < allow_new_prob:\n            candidates.append(kmax+1)\n        neigh = adj[i]\n        best = None\n        best_conf = None\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best = c\n            elif conf == best_conf and random.random() < 0.5:\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out)\n\n    def kempe_swap_once(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return sol[:]\n        a,b = random.sample(range(1, kmax+1), 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return sol[:]\n        s = random.choice(cand)\n        target = {a,b}\n        seen = [False]*n\n        dq = deque([s])\n        seen[s] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in target:\n                    seen[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out)\n\n    colors = normalize(colors)\n\n    # Multi-node recolors\n    r = random.randint(2, 4)\n    for _ in range(r):\n        colors = recolor_min_conflict_once(colors, allow_new_prob=0.3)\n\n    # One or two Kempe swaps\n    s = 1 + (1 if random.random() < 0.5 else 0)\n    for _ in range(s):\n        colors = kempe_swap_once(colors)\n\n    # Final safety\n    colors = [int(c) if isinstance(c,int) and c>=1 else 1 for c in colors[:n]]\n    return colors\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better. Strict feasibility priority via large base multiplier\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n\n    # Type\/length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Entry validation\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness (lexicographic via large multiplier)\n    B = 10000  # >> maximum possible k\n    fitness = violations * B + k_used\n\n    # Add input-quality penalties (kept smaller than B but significant if many)\n    fitness += non_int * 1000\n    fitness += non_pos * 500\n\n    return int(fitness)\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, movement_type_str)\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Coerce to a valid list of length n with positive ints\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_edges(sol):\n        return [(u,v) for (u,v) in edges if sol[u] == sol[v]]\n\n    def vertex_conflicts(sol, i):\n        return sum(1 for j in adj[i] if sol[j] == sol[i])\n\n    def recolor_conflicting_vertex(sol):\n        # Pick among conflicting vertices (biased), choose color minimizing local conflicts\n        conflicts = [i for i in range(n) if vertex_conflicts(sol, i) > 0]\n        if not conflicts:\n            # fallback: any vertex\n            i = random.randrange(n)\n        else:\n            i = random.choice(conflicts)\n        kmax = max(sol) if sol else 1\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        # With small probability, allow a new color\n        if random.random() < 0.05:\n            candidates.append(kmax+1)\n        neigh = adj[i]\n        best = None\n        best_conf = None\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best = c\n        out = sol[:]\n        out[i] = best if best is not None else current\n        return normalize(out), \"single-recolor\"\n\n    def kempe_swap_guided(sol):\n        # Select color pair involved in conflicts to increase effectiveness\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return recolor_conflicting_vertex(sol)\n        # Build conflict counts per pair\n        pair_counts = {}\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                # same-color conflict; encourage moves using this color and its neighbors' colors\n                cu = sol[u]\n                for w in adj[u] + adj[v]:\n                    cw = sol[w]\n                    if cw != cu:\n                        a,b = sorted((cu, cw))\n                        pair_counts[(a,b)] = pair_counts.get((a,b), 0) + 1\n        if pair_counts:\n            # Weighted random choice\n            items = list(pair_counts.items())\n            total = sum(cnt for _, cnt in items)\n            r = random.uniform(0, total)\n            acc = 0.0\n            a,b = 1,2\n            for (pair, cnt) in items:\n                acc += cnt\n                if r <= acc:\n                    a,b = pair\n                    break\n        else:\n            a,b = random.sample(range(1, kmax+1), 2)\n        # pick a start vertex with color a or b\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return recolor_conflicting_vertex(sol)\n        s = random.choice(cand)\n        target = {a,b}\n        visited = [False]*n\n        dq = deque([s])\n        visited[s] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and sol[v] in target:\n                    visited[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out), \"kempe-swap\"\n\n    def vertex_color_swap_preserve_k(sol):\n        # Swap colors of two non-adjacent vertices; preserve current k and avoid increasing conflicts\n        kmax = max(sol) if sol else 1\n        is_adj = [[False]*n for _ in range(n)]\n        for u,v in edges:\n            is_adj[u][v] = True\n            is_adj[v][u] = True\n        non_edges = [(i,j) for i in range(n) for j in range(i+1,n) if not is_adj[i][j]]\n        if not non_edges:\n            return recolor_conflicting_vertex(sol)\n        i,j = random.choice(non_edges)\n        out = sol[:]\n        out[i], out[j] = out[j], out[i]\n        out = normalize(out)\n        if max(out) > kmax:\n            return sol[:], \"noop\"\n        # Simple conflict check around affected vertices\n        def vconf(s, p):\n            return sum(1 for t in adj[p] if s[t] == s[p])\n        if vconf(out, i) + vconf(out, j) <= vconf(sol, i) + vconf(sol, j):\n            return out, \"vertex-swap\"\n        else:\n            return sol[:], \"noop\"\n\n    colors = normalize(colors)\n\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb, mtype = recolor_conflicting_vertex(colors)\n    elif move_pick < 0.85:\n        nb, mtype = kempe_swap_guided(colors)\n    else:\n        nb, mtype = vertex_color_swap_preserve_k(colors)\n\n    nb = [int(c) if isinstance(c,int) and c>=1 else 1 for c in nb[:n]]\n    return (nb, mtype)\n","Perturbacion":"import random, math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake combining multiple recolors and Kempe swaps; returns normalized valid list\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def recolor_once(sol, allow_new_prob=0.15):\n        kmax = max(sol) if sol else 1\n        # Prefer conflicting vertices\n        conflicts = [i for i in range(n) if any(sol[i] == sol[j] for j in adj[i])]\n        i = random.choice(conflicts) if conflicts else random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        if random.random() < allow_new_prob:\n            candidates.append(kmax+1)\n        best, best_conf = current, None\n        neigh = adj[i]\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out)\n\n    def kempe_once(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return sol[:]\n        a,b = random.sample(range(1, kmax+1), 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return sol[:]\n        s = random.choice(cand)\n        target = {a,b}\n        seen = [False]*n\n        dq = deque([s])\n        seen[s] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in target:\n                    seen[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out)\n\n    colors = normalize(colors)\n\n    # Apply multiple recolors\n    r = random.randint(2, 4)\n    for _ in range(r):\n        colors = recolor_once(colors, allow_new_prob=0.25)\n\n    # Apply one or two Kempe swaps\n    s = 1 + (1 if random.random() < 0.5 else 0)\n    for _ in range(s):\n        colors = kempe_once(colors)\n\n    colors = [int(c) if isinstance(c,int) and c>=1 else 1 for c in colors[:n]]\n    return colors\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality. Lower is better.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + float(abs(len(colors)-n))\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact clique number (lower bound)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision check: is graph k-colorable for smaller k?\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k):\n        col = {i: 0 for i in range(1, n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1, k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1, n+1) if col[u] == 0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    # penalties\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution_encoded, meta_str)\n    meta_str examples: 'Local\/Recolor', 'Local\/Swap', 'Local\/Kempe'\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def greedy_init():\n        # DSATUR-like greedy\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x]))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return colors\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = greedy_init()\n    else:\n        colors = [max(1, int(x)) for x in colors]\n\n    k = max(colors)\n\n    # Helper: list conflicts and max-color vertices\n    conflicts = []\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts.append((u,v))\n    max_color_vertices = [i for i in range(1,n+1) if colors[i-1] == k]\n\n    move_type = None\n\n    r = random.random()\n    new = colors[:]\n\n    if conflicts and r < 0.5:\n        # Conflict-driven recolor\n        u,v = random.choice(conflicts)\n        u = random.choice([u,v])\n        used = set(new[w-1] for w in adj[u])\n        # Prefer smallest feasible color; if none, pick random other color\n        c = 1\n        chosen = None\n        while c <= k:\n            if c not in used:\n                chosen = c\n                break\n            c += 1\n        if chosen is None:\n            # allow temporary new color with small prob; else random different\n            palette_max = k + (1 if random.random() < 0.1 else 0)\n            cand = list(range(1, palette_max+1))\n            cand = [x for x in cand if x != new[u-1]]\n            chosen = random.choice(cand)\n        new[u-1] = chosen\n        move_type = 'Local\/Recolor'\n    elif max_color_vertices and r < 0.8:\n        # Color swap between max color and a random other color to promote shrinking\n        c1 = k\n        other_colors = [c for c in range(1, k) if c != c1]\n        if other_colors:\n            c2 = random.choice(other_colors)\n            for i in range(n):\n                if new[i] == c1:\n                    new[i] = c2\n                elif new[i] == c2:\n                    new[i] = c1\n            move_type = 'Local\/Swap'\n        else:\n            # fallback recolor a max-color vertex to best feasible\n            u = random.choice(max_color_vertices)\n            used = set(new[w-1] for w in adj[u])\n            feasible = [c for c in range(1, k) if c not in used]\n            if feasible:\n                new[u-1] = random.choice(feasible)\n            else:\n                new[u-1] = random.randint(1, k)\n            move_type = 'Local\/Recolor'\n    else:\n        # Kempe-chain style flip between two colors on a random vertex\n        u = random.randrange(1, n+1)\n        cu = new[u-1]\n        alt_colors = [c for c in range(1, max(k,2)+1) if c != cu]\n        c2 = random.choice(alt_colors)\n        # BFS on subgraph induced by colors {cu, c2}\n        from collections import deque\n        Q = deque([u])\n        visited = set([u])\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if new[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        for x in visited:\n            new[x-1] = c2 if new[x-1] == cu else cu\n        move_type = 'Local\/Kempe'\n\n    # Normalize colors to keep them as positive ints and compact if desired (optional)\n    # Ensure at least 1..max present; leave gaps as-is to avoid invalidating acceptance logic\n    return (encode(new), move_type or 'Local\/Recolor')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: multi-vertex recolor + color-class swap + 1-2 Kempe flips\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def greedy_init():\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x]))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return colors\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = greedy_init()\n    else:\n        colors = [max(1, int(x)) for x in colors]\n\n    k = max(colors)\n    new = colors[:]\n\n    # 1) Randomly reassign m vertices, biasing towards max color class to encourage shrink\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        u = i+1\n        used = set(new[v-1] for v in adj[u])\n        palette = list(range(1, max(2, k) + 1))\n        # Prefer colors not used by neighbors\n        feasible = [c for c in palette if c not in used]\n        if feasible:\n            new[i] = random.choice(feasible)\n        else:\n            # fallback: random different color\n            cand = [c for c in palette if c != new[i]]\n            new[i] = random.choice(cand) if cand else new[i]\n\n    # 2) Swap two random color classes\n    if k >= 2:\n        c1, c2 = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if new[i] == c1:\n                new[i] = c2\n            elif new[i] == c2:\n                new[i] = c1\n\n    # 3) Do 1-2 Kempe-chain flips between random color pairs\n    from collections import deque\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        u = random.randrange(1, n+1)\n        cu = new[u-1]\n        alt_colors = [c for c in range(1, max(2, max(new))) if c != cu]\n        if not alt_colors:\n            continue\n        c2 = random.choice(alt_colors)\n        Q = deque([u])\n        visited = set([u])\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if new[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        for x in visited:\n            new[x-1] = c2 if new[x-1] == cu else cu\n\n    return encode(new)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Static evaluator. Lower is better.\n    Score structure prioritization:\n    1) conflicts_count (primary feasibility) -> weight 1_000_000\n    2) k (max color) -> weight 1_000\n    3) tie-breakers for feasible solutions:\n       - number of vertices using max color -> weight 10\n       - total sum of colors (after canonicalization) -> weight 0.001\n    Representation: CSV of 9 positive integers within [1..9]. Colors are canonicalized\n    by order-of-first-appearance before scoring to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        \"\"\"Relabel colors to 1..m by order of first appearance.\"\"\"\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + float(abs(len(cols) - n))\n    # domain checks: integers within [1..n]\n    for x in cols:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1 or x > n:\n            return 7_000_000.0\n\n    cols = canonicalize(cols)\n\n    # compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    k_hat = max(cols) if cols else 0\n    cnt_k = sum(1 for x in cols if x == k_hat) if k_hat > 0 else 0\n    ssum = sum(cols)\n\n    if conflicts > 0:\n        score = conflicts * 1_000_000.0 + k_hat * 1_000.0 + float(ssum) * 0.001\n    else:\n        score = k_hat * 1_000.0 + cnt_k * 10.0 + float(ssum) * 0.001\n\n    return float(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (encoded_solution, meta_str)\n    Neighbourhood is constraint-aware and does NOT increase palette size.\n    Moves:\n    - Targeted recolor of a vertex (prefer max-color vertices) using least-constraining color.\n    - Kempe chain flip biased toward (k, c<k) pairs to reduce max-color usage.\n    - If conflicts exist, prioritize resolving them with LCV recolor.\n    All outputs are canonicalized to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols: List[int]) -> str:\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def greedy_init() -> List[int]:\n        # DSATUR-like greedy with deterministic ties by degree then index\n        colors = [0] * n\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        uncolored = set(range(1, n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x], -x))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return canonicalize(colors)\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = greedy_init()\n    else:\n        cols = canonicalize([max(1, int(x)) for x in cols])\n\n    k = max(cols)\n\n    def conflict_edges(colors: List[int]) -> List[Tuple[int, int]]:\n        res = []\n        for (u, v) in edges:\n            if colors[u-1] == colors[v-1]:\n                res.append((u, v))\n        return res\n\n    def lcv_color(u: int, colors: List[int], palette_max: int) -> int:\n        # least-constraining color among feasible 1..palette_max\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            return colors[u-1]\n        # score by how many neighbors would forbid that color for their neighbors (approx: neighbor degree with that color)\n        best_c = None\n        best_score = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                if colors[v-1] == 0:\n                    continue\n                # if v had c, it would conflict; approximate constraint via degree\n                if c not in set(colors[w-1] for w in adj[v]):\n                    impact += 1\n            key = (impact, -c)\n            if best_c is None or key > best_score:\n                best_c = c\n                best_score = key\n        return best_c if best_c is not None else feas[0]\n\n    def kempe_flip(colors: List[int], u: int, c2: int) -> List[int]:\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        Q = deque([u])\n        visited = {u}\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    new = cols[:]\n    confs = conflict_edges(new)\n    meta = 'Local\/Recolor'\n\n    r = random.random()\n    if confs:\n        # Resolve a conflict by recoloring one endpoint with LCV, no palette growth\n        u, v = random.choice(confs)\n        pick = u if random.random() < 0.5 else v\n        c = lcv_color(pick, new, k)\n        new[pick-1] = c\n        meta = 'Local\/Recolor-ConflictLCV'\n    else:\n        # Target max-color pressure moves\n        max_vertices = [i for i in range(1, n+1) if new[i-1] == k]\n        if max_vertices and r < 0.7:\n            u = random.choice(max_vertices)\n            # try direct feasible recolor to <k using LCV\n            used = set(new[v-1] for v in adj[u])\n            feas = [c for c in range(1, k) if c not in used]\n            if feas:\n                # choose LCV among feas\n                best = None\n                best_key = None\n                for c in feas:\n                    impact = 0\n                    for w in adj[u]:\n                        if c in set(new[z-1] for z in adj[w]):\n                            impact += 1\n                    key = (-(impact), -c)\n                    if best is None or key > best_key:\n                        best = c\n                        best_key = key\n                new[u-1] = best\n                meta = 'Local\/Recolor-MaxDrop'\n            else:\n                # attempt Kempe with a lower color that may free u\n                c2 = random.choice([c for c in range(1, k)])\n                flipped = kempe_flip(new, u, c2)\n                # if flip reduces number of max-color vertices or keeps same but reduces adjacency conflicts, accept\n                before = sum(1 for x in new if x == k)\n                after = sum(1 for x in flipped if x == k)\n                if after <= before:\n                    new = flipped\n                    meta = 'Local\/Kempe(k,c)'\n                else:\n                    # fallback: Kempe around random vertex with pair (k, c2)\n                    w = random.randrange(1, n+1)\n                    c2 = random.choice([c for c in range(1, max(k, 2)) if c != new[w-1]])\n                    new = kempe_flip(new, w, c2)\n                    meta = 'Local\/Kempe-Fallback'\n        else:\n            # General Kempe flip biased to involve k when possible\n            if k >= 2 and random.random() < 0.8:\n                u = random.choice(range(1, n+1))\n                cu = new[u-1]\n                pool = [c for c in range(1, k + 0) if c != cu] if cu != k else [c for c in range(1, k) if c != cu]\n                pool = pool if pool else [c for c in range(1, max(k, 2)) if c != cu]\n                c2 = random.choice(pool)\n                new = kempe_flip(new, u, c2)\n                meta = 'Local\/Kempe-Biased'\n            else:\n                # small recolor anywhere using LCV\n                u = random.randrange(1, n+1)\n                new[u-1] = lcv_color(u, new, k)\n                meta = 'Local\/Recolor-LCV'\n\n    new = canonicalize(new)\n    # Do not increase palette\n    if max(new) > k:\n        # repair by remapping any color >k down to closest in [1..k]\n        mapping = {}\n        nxt = 1\n        for c in sorted(set(new)):\n            if nxt > k:\n                mapping[c] = k\n            else:\n                mapping[c] = nxt\n                nxt += 1\n        new = [mapping[c] for c in new]\n        new = canonicalize(new)\n    return (encode(new), meta)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong diversification without increasing palette size.\n    Sequence (depth randomized):\n    - Perform s in {2..4} Kempe flips involving color k and random c<k when possible.\n    - Randomly recolor m in {1..3} vertices with LCV within palette 1..k.\n    Returns (encoded_solution, meta_str)\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols: List[int]) -> str:\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def lcv_color(u: int, colors: List[int], palette_max: int) -> int:\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            # keep color if no feasible alternative\n            return colors[u-1]\n        # pick least constraining (approx.)\n        best = None\n        best_key = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                if c in set(colors[w-1] for w in adj[v]):\n                    impact += 1\n            key = (-impact, -c)\n            if best is None or key > best_key:\n                best = c\n                best_key = key\n        return best\n\n    def kempe_flip(colors: List[int], u: int, c2: int) -> List[int]:\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        Q = deque([u])\n        visited = {u}\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # simple fallback: 1..n cyclic\n        cols = [((i % 3) + 1) for i in range(n)]\n    cols = canonicalize(cols)\n    k = max(cols)\n\n    new = cols[:]\n\n    # s Kempe flips involving k when possible\n    s = random.randint(2, 4)\n    for _ in range(s):\n        u = random.randrange(1, n + 1)\n        cu = new[u-1]\n        if k >= 2 and (cu == k or random.random() < 0.7):\n            pool = [c for c in range(1, k) if c != cu]\n            if pool:\n                c2 = random.choice(pool)\n            else:\n                # fallback to any other color\n                pool = [c for c in range(1, max(k, 2)) if c != cu]\n                c2 = random.choice(pool)\n        else:\n            pool = [c for c in range(1, max(k, 2)) if c != cu]\n            c2 = random.choice(pool)\n        new = kempe_flip(new, u, c2)\n\n    # m random LCV recolors within 1..k\n    m = random.randint(1, 3)\n    idxs = random.sample(range(1, n + 1), m)\n    for u in idxs:\n        new[u-1] = lcv_color(u, new, k)\n\n    new = canonicalize(new)\n    if max(new) > k:\n        # enforce palette cap\n        uniq = sorted(set(new))\n        relabel = {c: i + 1 for i, c in enumerate(uniq[:k])}\n        for c in uniq[k:]:\n            relabel[c] = k\n        new = [relabel[c] for c in new]\n        new = canonicalize(new)\n    return (encode(new), 'Perturb\/KempeLCV')\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Static evaluator. Lower is better.\n    Score structure prioritization:\n    1) conflicts_count (primary feasibility) -> weight 1_000_000\n    2) k (max color) -> weight 1_000\n    3) tie-breakers for feasible solutions:\n       - number of vertices using max color -> weight 10\n       - total sum of colors (after canonicalization) -> weight 0.001\n    Representation: CSV of 9 positive integers within [1..9]. Colors are canonicalized\n    by order-of-first-appearance before scoring to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + float(abs(len(cols) - n))\n    for x in cols:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1 or x > n:\n            return 7_000_000.0\n\n    cols = canonicalize(cols)\n\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    k_hat = max(cols) if cols else 0\n    cnt_k = sum(1 for x in cols if x == k_hat) if k_hat > 0 else 0\n    ssum = sum(cols)\n\n    if conflicts > 0:\n        score = conflicts * 1_000_000.0 + k_hat * 1_000.0 + float(ssum) * 0.001\n    else:\n        score = k_hat * 1_000.0 + cnt_k * 10.0 + float(ssum) * 0.001\n\n    return float(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (encoded_solution, meta_str)\n    Neighbourhood is constraint-aware and does NOT increase palette size.\n    Moves:\n    - Targeted recolor of a vertex (prefer max-color vertices) using least-constraining color.\n    - Kempe chain flip between two existing colors (feasibility-aware when possible).\n    If conflicts exist, prioritize resolving them with LCV recolor.\n    All outputs are canonicalized to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def dsatur_init():\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        uncolored = set(range(1, n+1))\n        sat = {u: set() for u in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat[x]), degrees[x], -x))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat[v].add(c)\n        return canonicalize([max(1, x) for x in colors])\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = dsatur_init()\n    else:\n        cols = canonicalize([int(x) for x in cols])\n\n    k = max(cols)\n\n    def conflicts_list(colors):\n        res = []\n        for (u, v) in edges:\n            if colors[u-1] == colors[v-1]:\n                res.append((u, v))\n        return res\n\n    def lcv_color(u, colors, palette_max):\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max+1) if c not in used]\n        if not feas:\n            return colors[u-1]\n        # approximate least-constraining: pick color that appears least among neighbors' neighborhoods\n        best_c = None\n        best_key = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                nbr_colors = set(colors[w-1] for w in adj[v])\n                if c in nbr_colors:\n                    impact += 1\n            key = (-(impact), -c)\n            if best_c is None or key > best_key:\n                best_c = c\n                best_key = key\n        return best_c\n\n    def kempe_flip(colors, u, c2):\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        stack = [u]\n        visited = set([u])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    stack.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    new = cols[:]\n    confs = conflicts_list(new)\n    meta = 'Local\/Recolor'\n\n    r = random.random()\n    if confs:\n        # Resolve a conflict by recoloring one endpoint with LCV, no palette growth\n        u, v = random.choice(confs)\n        pick = u if random.random() < 0.5 else v\n        c = lcv_color(pick, new, k)\n        new[pick-1] = c\n        meta = 'Local\/Recolor-ConflictLCV'\n    else:\n        max_vertices = [i for i in range(1, n+1) if new[i-1] == k]\n        if max_vertices and r < 0.7 and k > 1:\n            u = random.choice(max_vertices)\n            used = set(new[v-1] for v in adj[u])\n            feas = [c for c in range(1, k) if c not in used]\n            if feas:\n                # choose LCV among feasible < k\n                best = None\n                best_key = None\n                for c in feas:\n                    impact = 0\n                    for w in adj[u]:\n                        nbr_colors = set(new[z-1] for z in adj[w])\n                        if c in nbr_colors:\n                            impact += 1\n                    key = (-(impact), -c)\n                    if best is None or key > best_key:\n                        best = c\n                        best_key = key\n                new[u-1] = best\n                meta = 'Local\/Recolor-MaxDrop'\n            else:\n                # Kempe with a lower color to try to free u\n                pool = [c for c in range(1, k) if c != new[u-1]]\n                if pool:\n                    c2 = random.choice(pool)\n                    flipped = kempe_flip(new, u, c2)\n                    new = flipped\n                    meta = 'Local\/Kempe(k,c)'\n                else:\n                    # fallback small recolor anywhere using LCV\n                    w = random.randrange(1, n+1)\n                    new[w-1] = lcv_color(w, new, k)\n                    meta = 'Local\/Recolor-LCV'\n        else:\n            # General Kempe flip between existing colors\n            if k >= 2 and random.random() < 0.8:\n                u = random.randrange(1, n+1)\n                cu = new[u-1]\n                pool = [c for c in range(1, k+1) if c != cu]\n                c2 = random.choice(pool)\n                new = kempe_flip(new, u, c2)\n                meta = 'Local\/Kempe'\n            else:\n                u = random.randrange(1, n+1)\n                new[u-1] = lcv_color(u, new, k)\n                meta = 'Local\/Recolor-LCV'\n\n    new = canonicalize(new)\n    if max(new) > k:\n        # enforce palette cap strictly (should not happen by construction)\n        uniq = sorted(set(new))\n        relabel = {c: i+1 for i, c in enumerate(uniq[:k])}\n        for c in uniq[k:]:\n            relabel[c] = k\n        new = [relabel[c] for c in new]\n        new = canonicalize(new)\n\n    return (encode(new), meta)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong diversification without increasing palette size.\n    Sequence:\n    - Perform s in {2..4} Kempe flips involving existing colors.\n    - Randomly recolor m in {1..3} vertices with LCV within palette 1..k.\n    Returns (encoded_solution, meta_str)\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def lcv_color(u, colors, palette_max):\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            return colors[u-1]\n        best = None\n        best_key = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                nbr_colors = set(colors[w-1] for w in adj[v])\n                if c in nbr_colors:\n                    impact += 1\n            key = (-(impact), -c)\n            if best is None or key > best_key:\n                best = c\n                best_key = key\n        return best\n\n    def kempe_flip(colors, u, c2):\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        stack = [u]\n        visited = set([u])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    stack.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = [1,1,2,3,2,3,4,2,4]  # feasible seed\n    cols = canonicalize(cols)\n    k = max(cols) if cols else 1\n\n    new = cols[:]\n\n    # s Kempe flips between existing colors\n    s = random.randint(2, 4)\n    for _ in range(s):\n        u = random.randrange(1, n + 1)\n        cu = new[u-1]\n        pool = [c for c in range(1, k+1) if c != cu]\n        if not pool:\n            continue\n        c2 = random.choice(pool)\n        new = kempe_flip(new, u, c2)\n\n    # m random LCV recolors within 1..k\n    m = random.randint(1, 3)\n    idxs = random.sample(range(1, n + 1), m)\n    for u in idxs:\n        new[u-1] = lcv_color(u, new, k)\n\n    new = canonicalize(new)\n    if max(new) > k:\n        uniq = sorted(set(new))\n        relabel = {c: i + 1 for i, c in enumerate(uniq[:k])}\n        for c in uniq[k:]:\n            relabel[c] = k\n        new = [relabel[c] for c in new]\n        new = canonicalize(new)\n\n    return (encode(new), 'Perturb\/KempeLCV')\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph and parameters (embedded; no globals)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000.0\n    PENALTY_VIOLATION = 1_000_000.0  # ensure feasibility prioritized over color count\n    PENALTY_VALUE = 100.0\n\n    # Coerce\n    try:\n        seq = list(solution)\n    except Exception:\n        return PENALTY_INVALID\n    if len(seq) != n:\n        return math.fsum([PENALTY_INVALID, abs(len(seq) - n) * PENALTY_VALUE])\n\n    colors = [1]*n\n    invalid_values = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        if isinstance(v, bool):\n            x = 0\n        if x < 1:\n            invalid_values += 1\n            x = 1\n        colors[i] = x\n\n    max_color = max(colors) if colors else 1\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return math.fsum([\n            PENALTY_INVALID,\n            invalid_values * PENALTY_VALUE,\n            violations * PENALTY_VIOLATION,\n            float(max_color)\n        ])\n\n    return float(max_color)\n\n# Optional: Simulated Annealing core for integrators expecting a ready heuristic\n# Note: Uses injected generate_neighbour and evaluate_solution callables.\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    curr = list(currentSolution)\n    curr_score = float(evaluate_solution(curr))\n    if best is None:\n        best = list(curr)\n        best_score = curr_score\n    T = float(temp)\n    stagnation = 0\n    while T > float(minTemp):\n        neigh_tuple = generate_neighbour(curr)\n        # Expect (new_solution, NB_Type, Movement_Type)\n        if isinstance(neigh_tuple, tuple) and len(neigh_tuple) >= 1:\n            candidate = list(neigh_tuple[0])\n        else:\n            candidate = list(curr)\n        cand_score = float(evaluate_solution(candidate))\n        delta = cand_score - curr_score\n        accept = False\n        if delta <= 0:\n            accept = True\n        else:\n            # Metropolis criterion\n            try:\n                prob = math.exp(-delta \/ max(T, 1e-12))\n            except OverflowError:\n                prob = 0.0\n            if random.random() < prob:\n                accept = True\n        if accept:\n            curr = candidate\n            curr_score = cand_score\n            stagnation = 0\n            if curr_score < best_score:\n                best = list(curr)\n                best_score = curr_score\n        else:\n            stagnation += 1\n        # Simple cooling with occasional reheat on stagnation\n        T *= float(cooling_factor)\n        if stagnation > 200:\n            T = max(T * 1.5, temp * 0.5)\n            stagnation = 0\n    return {\"current\": curr, \"currentScore\": curr_score, \"best\": best, \"bestScore\": best_score}\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-directed recoloring with color-reduction pressure\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Coerce to valid list length 9, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    max_c = max(curr) if curr else 1\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n            total_conflicts += 1\n\n    neigh = curr[:]\n\n    if total_conflicts > 0:\n        # Pick a most-conflicted vertex\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == max(conflicts)]\n        v = random.choice(cand_vertices)\n        # Try smallest feasible color in [1, max_c]\n        neighbor_colors = {curr[u] for u in adj[v]}\n        chosen = None\n        for color in range(1, max_c+0):  # attempt 1..(max_c-1) first to bias reduction\n            if color == curr[v]:\n                continue\n            if color not in neighbor_colors:\n                chosen = color\n                break\n        if chosen is None:\n            # Try any color in 1..max_c\n            for color in range(1, max_c+1):\n                if color != curr[v] and color not in neighbor_colors:\n                    chosen = color\n                    break\n        if chosen is None:\n            # If all colors conflict, pick the one minimizing conflicts (still within 1..max_c)\n            best_c = curr[v]\n            best_cnt = len(adj[v]) + 1\n            for color in range(1, max_c+1):\n                if color == curr[v]:\n                    continue\n                cnt = 0\n                for u in adj[v]:\n                    if curr[u] == color:\n                        cnt += 1\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = color\n            chosen = best_c\n        neigh[v] = chosen\n        return (neigh, \"ConflictDirected\", \"SingleVertexRecolor\")\n    else:\n        # Feasible: try to eliminate highest color class\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n        # Try recoloring any of them to [1..max_c-1]\n        moved = False\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color not in neighbor_colors:\n                    neigh[v] = color\n                    moved = True\n                    break\n            if moved:\n                break\n        if moved:\n            return (neigh, \"ColorReduction\", \"TargetHighestClass\")\n        # If cannot reduce, perform a diversification recolor that maintains max_c\n        v = random.randrange(n)\n        neighbor_colors = {curr[u] for u in adj[v]}\n        options = [c for c in range(1, max_c+1) if c != curr[v] and c not in neighbor_colors]\n        if options:\n            neigh[v] = random.choice(options)\n            return (neigh, \"Diversify\", \"FeasibleRecolor\")\n        # fallback: swap labels of two lower colors to reshuffle\n        if max_c >= 2:\n            a, b = 1, 2\n            if max_c > 2:\n                a = random.randint(1, max_c-1)\n                b = random.randint(1, max_c-1)\n                if a == b:\n                    b = max(1, (a % (max_c-1)) + 1)\n            for i in range(n):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, \"LabelSwap\", \"ColorSwap\")\n        return (neigh, \"NoOp\", \"Identity\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Shake: recolor k vertices among the most conflicted; allow colors up to current max\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    max_c = max(curr) if curr else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    order = list(range(n))\n    order.sort(key=lambda i: conflicts[i], reverse=True)\n    k = min(4, max(2, n \/\/ 4))  # choose 2..4 vertices\n    idxs = order[:k]\n\n    out = curr[:]\n    for i in idxs:\n        # assign a random color within existing range to avoid unnecessary color increases\n        out[i] = random.randint(1, max_c)\n        if out[i] < 1:\n            out[i] = 1\n    return out\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000.0\n    PENALTY_VIOLATION = 1_000_000.0\n    PENALTY_VALUE = 100.0\n\n    # Coerce to integer list of length n\n    try:\n        seq = list(solution)\n    except Exception:\n        return PENALTY_INVALID\n    if len(seq) != n:\n        return math.fsum([PENALTY_INVALID, abs(len(seq) - n) * PENALTY_VALUE])\n\n    colors = [1]*n\n    invalid_values = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        if isinstance(v, bool):\n            x = 0\n        if x < 1:\n            invalid_values += 1\n            x = 1\n        colors[i] = x\n\n    max_color = max(colors) if colors else 1\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        # strong feasibility pressure; include max_color as tie breaker\n        return math.fsum([\n            PENALTY_INVALID,\n            invalid_values * PENALTY_VALUE,\n            (violations ** 2) * PENALTY_VIOLATION,\n            float(max_color)\n        ])\n\n    return float(max_color)\n","Vecindad":"import random\nimport math\n\n# Returns: (new_solution, NB_Type, Movement_Type)\n# Signature annotation kept as required by integrator spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Coerce to valid list length n, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Current max color\n    max_c = max(curr) if curr else 1\n\n    # Compute conflicts\n    conflicts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n            total_conflicts += 1\n\n    neigh = curr[:]\n\n    if total_conflicts > 0:\n        # Conflict-directed recolor with Kempe-chain escape\n        worst = max(conflicts)\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == worst]\n        v = random.choice(cand_vertices)\n        neighbor_colors = {curr[u] for u in adj[v]}\n        # Phase 1: try smallest feasible color in 1..max_c excluding current color\n        for color in range(1, max_c+1):\n            if color != curr[v] and color not in neighbor_colors:\n                neigh[v] = color\n                return (neigh, \"ConflictDirected\", \"SingleVertexRecolor\")\n        # Phase 2: Kempe-chain swap with a conflicting neighbor color\n        # pick a color t present in neighbors; swap colors curr[v] <-> t in the connected component containing v\n        if neighbor_colors:\n            t = random.choice(list(neighbor_colors))\n            a = curr[v]\n            # BFS on subgraph induced by colors {a, t}\n            visited = [False]*n\n            queue = [v]\n            visited[v] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                if curr[x] == a or curr[x] == t:\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and (curr[y] == a or curr[y] == t):\n                            visited[y] = True\n                            queue.append(y)\n            # Swap colors on this component\n            alt = curr[:]\n            for x in comp:\n                alt[x] = t if curr[x] == a else a\n            # Accept if it reduces conflicts or keeps same but changes structure\n            def count_conf(sol):\n                c = 0\n                for (uu, vv) in edges:\n                    if sol[uu-1] == sol[vv-1]:\n                        c += 1\n                return c\n            if count_conf(alt) <= total_conflicts:\n                return (alt, \"Kempe\", \"TwoColorSwap\")\n        # Fallback: randomized recolor within 1..max_c minimizing local conflicts\n        best_color = curr[v]\n        best_cnt = len(adj[v]) + 1\n        for color in range(1, max_c+1):\n            if color == curr[v]:\n                continue\n            cnt = 0\n            for u in adj[v]:\n                if curr[u] == color:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_color = color\n        neigh[v] = best_color\n        return (neigh, \"ConflictDirected\", \"MinLocalConf\")\n    else:\n        # Feasible: attempt color reduction from highest class\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color not in neighbor_colors:\n                    neigh[v] = color\n                    return (neigh, \"ColorReduction\", \"LowerRecolor\")\n        # If cannot reduce max color, try relabeling two lower colors to diversify\n        if max_c >= 2:\n            a = random.randint(1, max(1, max_c-1))\n            b = random.randint(1, max(1, max_c-1))\n            if a == b:\n                b = (a % max(1, max_c-1)) + 1\n            for i in range(n):\n                if curr[i] == a:\n                    neigh[i] = b\n                elif curr[i] == b:\n                    neigh[i] = a\n            return (neigh, \"Diversify\", \"ColorRelabel\")\n        return (neigh, \"NoOp\", \"Identity\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    order = list(range(n))\n    order.sort(key=lambda i: conflicts[i], reverse=True)\n    k = min(4, max(2, n \/\/ 4))\n    idxs = order[:k]\n\n    max_c = max(curr) if curr else 1\n    out = curr[:]\n    for i in idxs:\n        out[i] = random.randint(1, max_c)\n        if out[i] < 1:\n            out[i] = 1\n    return out\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges_1based = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Precompute 0-based edges once\n    edges = [(u-1, v-1) for (u, v) in edges_1based]\n    # Calibrated penalties\n    BASE_INVALID = 1_000_000.0\n    VIOLATION_W = 10_000.0\n    MAXVIO_W = 100.0\n\n    # Coerce to list\n    try:\n        seq = list(solution)\n    except Exception:\n        return BASE_INVALID\n\n    if len(seq) != n:\n        return BASE_INVALID + VIOLATION_W * float(abs(len(seq) - n))\n\n    # Parse and validate strictly positive integers\n    colors = [0] * n\n    invalids = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        # Reject booleans and non-positive\n        if isinstance(v, bool) or x <= 0:\n            invalids += 1\n            continue\n        colors[i] = x\n\n    if invalids > 0:\n        return BASE_INVALID + VIOLATION_W * float(invalids)\n\n    max_color = max(colors) if colors else 1\n\n    # Count constraint violations\n    violations = 0\n    vertex_conf = [0] * n\n    for (u, v) in edges:\n        if colors[u] == colors[v]:\n            violations += 1\n            vertex_conf[u] += 1\n            vertex_conf[v] += 1\n\n    if violations > 0:\n        # Linear violation cost + tie-breakers\n        max_vertex_conf = max(vertex_conf) if vertex_conf else 0\n        return math.fsum([\n            BASE_INVALID,\n            VIOLATION_W * float(violations),\n            MAXVIO_W * float(max_vertex_conf),\n            1e-3 * float(max_color)\n        ])\n\n    # Feasible: minimize K=max_color with light tie-break on sum of colors\n    return float(max_color) + 1e-3 * float(sum(colors))\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges_1based = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1based]\n\n    # Coerce to valid list of length n with min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1] * n\n    if len(curr) < n:\n        curr = curr + [1] * (n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conf(sol: List[int]) -> Tuple[int, List[int]]:\n        vc = [0] * n\n        tot = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                tot += 1\n                vc[u] += 1\n                vc[v] += 1\n        return tot, vc\n\n    def max_color_of(sol: List[int]) -> int:\n        return max(sol) if sol else 1\n\n    total_conf, conflicts = count_conf(curr)\n    max_c = max_color_of(curr)\n\n    neigh = curr[:]\n\n    if total_conf > 0:\n        # Conflict-directed move: choose vertex with highest conflicts\n        worst = max(conflicts)\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == worst]\n        v = random.choice(cand_vertices)\n        neighbor_colors = {curr[u] for u in adj[v]}\n\n        # Try best recolor minimizing resulting total conflicts; prefer not increasing max color\n        best_sol = None\n        best_score = (math.inf, math.inf)  # (total_conflicts, max_color)\n        for color in range(1, max_c + 1):\n            if color == curr[v]:\n                continue\n            if color in neighbor_colors:\n                continue\n            trial = curr[:]\n            trial[v] = color\n            tc, _ = count_conf(trial)\n            mc = max_color_of(trial)\n            sc = (tc, mc)\n            if sc < best_score:\n                best_score = sc\n                best_sol = trial\n        if best_sol is not None:\n            # Ensure length\n            if len(best_sol) != n:\n                best_sol = best_sol[:n] + [1] * max(0, n - len(best_sol))\n            return (best_sol, \"ConflictDirected\", \"SingleVertexRecolor\")\n\n        # Kempe-chain swap with a conflicting neighbor color (tie-breakers: conflicts, reduce max-color load)\n        if neighbor_colors:\n            t = random.choice(list(neighbor_colors))\n            a = curr[v]\n            visited = [False] * n\n            queue = [v]\n            visited[v] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                if curr[x] == a or curr[x] == t:\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and (curr[y] == a or curr[y] == t):\n                            visited[y] = True\n                            queue.append(y)\n            alt = curr[:]\n            for x in comp:\n                alt[x] = t if curr[x] == a else a\n            tc_alt, _ = count_conf(alt)\n            if tc_alt <= total_conf:\n                # Prefer swaps that reduce max color or reduce count of max-color vertices\n                mc_curr = max_c\n                mc_alt = max_color_of(alt)\n                if mc_alt < mc_curr:\n                    if len(alt) != n:\n                        alt = alt[:n] + [1] * max(0, n - len(alt))\n                    return (alt, \"Kempe\", \"TwoColorSwap\")\n                else:\n                    # Count vertices in max color class before\/after\n                    cnt_curr = sum(1 for x in curr if x == mc_curr)\n                    cnt_alt = sum(1 for x in alt if x == mc_alt)\n                    if cnt_alt <= cnt_curr:\n                        if len(alt) != n:\n                            alt = alt[:n] + [1] * max(0, n - len(alt))\n                        return (alt, \"Kempe\", \"TwoColorSwap\")\n        \n        # Fallback: randomized recolor within 1..max_c minimizing local conflicts\n        best_color = curr[v]\n        best_cnt = len(adj[v]) + 1\n        for color in range(1, max_c + 1):\n            if color == curr[v]:\n                continue\n            cnt = 0\n            for u in adj[v]:\n                if curr[u] == color:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_color = color\n        neigh[v] = best_color\n        if len(neigh) != n:\n            neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n        return (neigh, \"ConflictDirected\", \"MinLocalConf\")\n    else:\n        # Feasible: attempt color reduction from highest class, evaluate all candidates\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n\n        best_move = None\n        best_after = (math.inf, math.inf, math.inf)  # (max_color, sum_colors, vertex_degree)\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color in neighbor_colors:\n                    continue\n                trial = curr[:]\n                trial[v] = color\n                # Feasibility preserved by construction; evaluate tie-breakers\n                mc = max_color_of(trial)\n                sc = sum(trial)\n                deg = len(adj[v])\n                key = (mc, sc, -deg)  # prefer lowering max color, then lower sum, then higher-degree moves\n                if key < best_after:\n                    best_after = key\n                    best_move = trial\n        if best_move is not None and max_color_of(best_move) <= max_c:\n            if len(best_move) != n:\n                best_move = best_move[:n] + [1] * max(0, n - len(best_move))\n            return (best_move, \"ColorReduction\", \"LowerRecolor\")\n\n        # Diversification: color relabel including max color; occasional 3-cycle relabel\n        neigh = curr[:]\n        if max_c >= 2:\n            if random.random() < 0.25 and max_c >= 3:\n                # 3-cycle relabel among three distinct colors\n                a, b, c = random.sample(range(1, max_c + 1), 3)\n                for i in range(n):\n                    if neigh[i] == a:\n                        neigh[i] = b\n                    elif neigh[i] == b:\n                        neigh[i] = c\n                    elif neigh[i] == c:\n                        neigh[i] = a\n                if len(neigh) != n:\n                    neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n                return (neigh, \"Diversify\", \"Relabel3Cycle\")\n            else:\n                a, b = random.sample(range(1, max_c + 1), 2)\n                for i in range(n):\n                    if neigh[i] == a:\n                        neigh[i] = b\n                    elif neigh[i] == b:\n                        neigh[i] = a\n                if len(neigh) != n:\n                    neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n                return (neigh, \"Diversify\", \"ColorRelabel\")\n        # No change possible\n        if len(neigh) != n:\n            neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n        return (neigh, \"NoOp\", \"Identity\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges_1based = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1based]\n\n    # Coerce to valid list length n, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1] * n\n    if len(curr) < n:\n        curr = curr + [1] * (n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    def max_color_of(sol):\n        return max(sol) if sol else 1\n\n    # Choose number of perturb operations\n    ops = random.randint(2, 4)\n    out = curr[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    for _ in range(ops):\n        choice = random.random()\n        max_c = max_color_of(out)\n        if choice < 0.5:\n            # Random vertex recolor within [1..max_c]\n            i = random.randrange(n)\n            new_c = random.randint(1, max(1, max_c))\n            out[i] = new_c if new_c >= 1 else 1\n        elif choice < 0.8:\n            # Kempe-chain swap seeded at random vertex and neighbor color (if exists)\n            v = random.randrange(n)\n            if adj[v]:\n                neighbor_colors = {out[u] for u in adj[v]}\n                if neighbor_colors:\n                    a = out[v]\n                    t = random.choice(list(neighbor_colors))\n                    visited = [False] * n\n                    stack = [v]\n                    visited[v] = True\n                    comp = []\n                    while stack:\n                        x = stack.pop()\n                        if out[x] == a or out[x] == t:\n                            comp.append(x)\n                            for y in adj[x]:\n                                if not visited[y] and (out[y] == a or out[y] == t):\n                                    visited[y] = True\n                                    stack.append(y)\n                    for x in comp:\n                        out[x] = t if out[x] == a else a\n        else:\n            # Color relabel (swap two colors or 3-cycle if >=3 colors)\n            if max_c >= 3 and random.random() < 0.4:\n                a, b, c = random.sample(range(1, max_c + 1), 3)\n                for i in range(n):\n                    if out[i] == a:\n                        out[i] = b\n                    elif out[i] == b:\n                        out[i] = c\n                    elif out[i] == c:\n                        out[i] = a\n            elif max_c >= 2:\n                a, b = random.sample(range(1, max_c + 1), 2)\n                for i in range(n):\n                    if out[i] == a:\n                        out[i] = b\n                    elif out[i] == b:\n                        out[i] = a\n\n    # Ensure output integrity\n    if len(out) != n:\n        out = out[:n] + [1] * max(0, n - len(out))\n    for i in range(n):\n        try:\n            x = int(out[i])\n        except Exception:\n            x = 1\n        if isinstance(out[i], bool) or x < 1:\n            x = 1\n        out[i] = x\n\n    return out\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci >= 1 denotes the color of vertex i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Canonical, lexicographic evaluation: minimize conflicts first, then number of colors\n    # Fitness = conflicts*W + k_used, with W >> n to dominate by conflicts while keeping gradient within infeasible region\n    W = 1000\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to remove symmetry: map first-appearance order to 1..k\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors used\n    k_used = len(set(canonical))\n\n    return conflicts * W + k_used\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor; when feasible, attempt color reduction from highest color\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def canonicalize(sol):\n        mapping = {}\n        next_label = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            res.append(mapping[c])\n        return res\n\n    sol = canonicalize(sanitize(solution))\n\n    # Compute conflicts\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n\n    move_desc = \"\"\n\n    if conflicts:\n        # Pick a conflicted vertex and try a legal color among existing palette\n        v = random.choice(list(conflicts))\n        neighbor_colors = {sol[w] for w in adj[v]}\n        palette = sorted(set(sol))\n        legal = [c for c in palette if c not in neighbor_colors and c != sol[v]]\n        if legal:\n            new_color = random.choice(legal)\n            nb = sol.copy()\n            nb[v] = new_color\n            move_desc = f\"conflict-recolor-v{v+1}-to-{new_color}\"\n            return canonicalize(nb), move_desc\n        else:\n            # No legal among current colors: pick color minimizing new conflicts; very small chance to introduce new color\n            allow_new = (random.random() < 0.02)\n            candidate_colors = palette.copy()\n            if allow_new:\n                candidate_colors.append(max(palette)+1)\n            best_c = sol[v]\n            best_delta = 10**9\n            for c in candidate_colors:\n                if c == sol[v]:\n                    continue\n                # conflicts introduced if any neighbor has color c\n                delta = sum(1 for w in adj[v] if sol[w] == c) - sum(1 for w in adj[v] if sol[w] == sol[v])\n                if delta < best_delta:\n                    best_delta = delta\n                    best_c = c\n            nb = sol.copy()\n            nb[v] = best_c\n            move_desc = f\"conflict-min-recolor-v{v+1}-to-{best_c}\"\n            return canonicalize(nb), move_desc\n    else:\n        # Feasible: try to reduce number of colors by moving a vertex from the highest color down\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return sol, \"noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        random.shuffle(vertices_max)\n        # Try for each vertex in max color to move to lowest legal color\n        for v in vertices_max:\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol.copy()\n                nb[v] = new_color\n                move_desc = f\"reduce-k-move-v{v+1}-to-{new_color}\"\n                return canonicalize(nb), move_desc\n        # If moving a single vertex fails, attempt swapping this vertex with a lower color (may open paths)\n        v = random.choice(vertices_max)\n        lower_colors = [c for c in palette if c < max_color]\n        if lower_colors:\n            swap_color = random.choice(lower_colors)\n            nb = sol.copy()\n            nb[v] = swap_color\n            move_desc = f\"swap-attempt-v{v+1}-to-{swap_color}\"\n            return canonicalize(nb), move_desc\n        return sol, \"noop\"\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Color-merge perturbation + greedy repair, then canonicalize\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 3) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def canonicalize(sol):\n        mapping = {}\n        next_label = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            res.append(mapping[c])\n        return res\n\n    sol = canonicalize(sanitize(solution))\n\n    palette = sorted(set(sol))\n    if len(palette) < 2:\n        return sol\n\n    # Pick two distinct colors a (keep) and b (merge into a)\n    a, b = random.sample(palette, 2)\n    keep, drop = (a, b)\n    pert = [keep if c == drop else c for c in sol]\n\n    # Greedy repair: process conflicted vertices; try smallest legal color, else introduce a new color with low probability\n    def repair(conf):\n        changed = True\n        while changed:\n            changed = False\n            for (u, v) in edges:\n                if conf[u-1] == conf[v-1]:\n                    # Choose one endpoint to recolor (higher degree heuristic)\n                    cand = u-1 if len(adj[u-1]) >= len(adj[v-1]) else v-1\n                    neighbor_colors = {conf[w] for w in adj[cand]}\n                    palette_local = sorted(set(conf))\n                    legal = [c for c in palette_local if c not in neighbor_colors]\n                    if legal:\n                        # prefer smallest legal\n                        conf[cand] = legal[0]\n                    else:\n                        # very rarely introduce a new color to break deadlock\n                        if random.random() < 0.05:\n                            conf[cand] = max(palette_local) + 1\n                        else:\n                            # fallback: recolor to color minimizing conflicts\n                            best_c = conf[cand]\n                            best_cnt = len(adj[cand]) + 1\n                            for c in palette_local:\n                                cnt = sum(1 for w in adj[cand] if conf[w] == c)\n                                if cnt < best_cnt:\n                                    best_cnt = cnt\n                                    best_c = c\n                            conf[cand] = best_c\n                    changed = True\n        return conf\n\n    pert = repair(pert)\n\n    # Optional random extra recolors to diversify\n    steps = random.randint(1, 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette_local = sorted(set(pert))\n        legal = [c for c in palette_local if c not in neighbor_colors]\n        if legal:\n            pert[i] = random.choice(legal)\n\n    return canonicalize(pert)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci>=1 denotes the color of vertex i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Problem data (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to normalize symmetry\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors\n    k_used = len(set(canonical))\n\n    # Scalarized objective: W = |E|+1 = 22 to strictly dominate k with conflicts\n    W = 22\n    return conflicts * W + k_used\n","Vecindad":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def conflicts_of_vertex(sol, v):\n        c = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == c)\n\n    def saturation_degree(sol, v):\n        return len({sol[w] for w in adj[v]})\n\n    def kempe_swap(sol, v, target_color):\n        # Perform Kempe chain swap on colors a=sol[v] and b=target_color in the connected component containing v\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        in_component = []\n        while q:\n            x = q.popleft()\n            in_component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in in_component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    palette = sorted(set(sol))\n    move_desc = \"noop\"\n\n    if conflicted:\n        # Choose vertex by (conflicts, saturation, degree)\n        def score(v):\n            return (conflicts_of_vertex(sol, v), saturation_degree(sol, v), len(adj[v]))\n        v = max(conflicted, key=score)\n        neighbor_colors = {sol[w] for w in adj[v]}\n        legal = [c for c in palette if c != sol[v] and c not in neighbor_colors]\n        if legal:\n            new_color = min(legal)\n            nb = sol[:]\n            nb[v] = new_color\n            return nb, f\"conflict-recolor-v{v+1}-to-{new_color}\"\n        else:\n            # Try Kempe swap with color minimizing post-conflicts at v (no new colors)\n            best_nb = sol[:]\n            best_val = conflicts_of_vertex(sol, v)\n            best_c = sol[v]\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                cand = kempe_swap(sol, v, c)\n                val = sum(1 for w in adj[v] if cand[w] == cand[v])\n                if val < best_val:\n                    best_val = val\n                    best_nb = cand\n                    best_c = c\n            if best_c != sol[v]:\n                return best_nb, f\"kempe-swap-v{v+1}-with-{best_c}\"\n            # Fallback: recolor to color with minimum conflicts (still within palette)\n            best_c = sol[v]\n            best_cnt = len(adj[v]) + 1\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                cnt = sum(1 for w in adj[v] if sol[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            nb = sol[:]\n            nb[v] = best_c\n            return nb, f\"min-conflict-recolor-v{v+1}-to-{best_c}\"\n    else:\n        # Feasible: attempt to reduce k by moving from max color using recolor or Kempe swap\n        if len(palette) <= 1:\n            return sol, \"noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        random.shuffle(vertices_max)\n        # Try direct recolor to lower legal color\n        for v in vertices_max:\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol[:]\n                nb[v] = new_color\n                return nb, f\"reduce-k-recolor-v{v+1}-to-{new_color}\"\n        # Try Kempe swap with a lower color to free v\n        for v in vertices_max:\n            for target in sorted(c for c in palette if c < max_color):\n                cand = kempe_swap(sol, v, target)\n                # If v now takes target and remains feasible, accept\n                feas = True\n                for w in adj[v]:\n                    if cand[w] == cand[v]:\n                        feas = False\n                        break\n                if feas:\n                    return cand, f\"reduce-k-kempe-v{v+1}-with-{target}\"\n        # As last resort, attempt swapping one vertex color down (may require later repair)\n        v = random.choice(vertices_max)\n        target = random.choice([c for c in palette if c < max_color])\n        nb = sol[:]\n        nb[v] = target\n        return nb, f\"reduce-k-swap-attempt-v{v+1}-to-{target}\"\n","Perturbacion":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 4) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def kempe_swap(sol, v, target_color):\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        component = []\n        while q:\n            x = q.popleft()\n            component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n    palette = sorted(set(sol))\n    if len(palette) < 2:\n        return sol[:]\n\n    # Perform a sequence of Kempe-chain perturbations to diversify without increasing k\n    steps = random.randint(2, 4)\n    pert = sol[:]\n    for _ in range(steps):\n        palette = sorted(set(pert))\n        v = random.randrange(n)\n        # choose a target color from current palette (different from v's color)\n        choices = [c for c in palette if c != pert[v]]\n        if not choices:\n            continue\n        t = random.choice(choices)\n        cand = kempe_swap(pert, v, t)\n        pert = cand\n\n    # Light greedy fixes for any introduced conflicts (no new colors)\n    for _ in range(n):  # bounded repairs\n        conflicted = []\n        for (u,v) in edges:\n            if pert[u-1] == pert[v-1]:\n                conflicted.append(u-1)\n                conflicted.append(v-1)\n        if not conflicted:\n            break\n        i = max(set(conflicted), key=lambda x: len([w for w in adj[x] if pert[w]==pert[x]]))\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette = sorted(set(pert))\n        legal = [c for c in palette if c != pert[i] and c not in neighbor_colors]\n        if legal:\n            pert[i] = min(legal)\n        else:\n            # fallback: choose color minimizing equal-colored neighbors, still within palette\n            best_c = pert[i]\n            best_cnt = len(adj[i]) + 1\n            for c in palette:\n                if c == pert[i]:\n                    continue\n                cnt = sum(1 for w in adj[i] if pert[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            pert[i] = best_c\n\n    return pert\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of length 9 with positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci is the color of vertex i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to normalize symmetry\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors used\n    k_used = len(set(canonical))\n\n    # Scalarized objective: dominate k by conflicts\n    # |E| = 21, W = 22 ensures any conflict is worse than any k change\n    W = 22\n    return conflicts * W + k_used\n","Vecindad":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicts_of_vertex(sol, v):\n        c = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == c)\n\n    def saturation_degree(sol, v):\n        return len({sol[w] for w in adj[v]})\n\n    def kempe_swap(sol, v, target_color):\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:], []\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        component = []\n        while q:\n            x = q.popleft()\n            component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in component:\n            out[x] = b if sol[x] == a else a\n        return out, component\n\n    sol = sanitize(solution)\n\n    # Determine phase by current conflicts\n    total_conflicts = count_conflicts(sol)\n    palette = sorted(set(sol))\n\n    if total_conflicts > 0:\n        # Conflict-reduction phase: choose vertex with deterministic tie-breaking\n        conflicted = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        if not conflicted:\n            return sol[:], \"conflict-phase-but-none\"\n\n        def score(v):\n            # higher is worse -> target to fix: conflicts, saturation, degree, then -index\n            return (\n                conflicts_of_vertex(sol, v),\n                saturation_degree(sol, v),\n                len(adj[v]),\n                -v\n            )\n        v = max(conflicted, key=score)\n\n        # Try recolor to existing palette that strictly reduces conflicts at v\n        neighbor_colors = {sol[w] for w in adj[v]}\n        best_sol = None\n        best_local = conflicts_of_vertex(sol, v)\n        best_color = sol[v]\n        for c in palette:\n            if c == sol[v]:\n                continue\n            if c in neighbor_colors:\n                continue\n            cand = sol[:]\n            cand[v] = c\n            local = conflicts_of_vertex(cand, v)\n            if local < best_local:\n                best_local = local\n                best_sol = cand\n                best_color = c\n        if best_sol is not None:\n            return best_sol, f\"conflict-recolor-v{v+1}-to-{best_color}\"\n\n        # Try Kempe swap that reduces total conflicts (strictly)\n        best_nb = None\n        best_cnt = total_conflicts\n        best_c = None\n        for c in palette:\n            if c == sol[v]:\n                continue\n            cand, comp = kempe_swap(sol, v, c)\n            cand_cnt = count_conflicts(cand)\n            if cand_cnt < best_cnt:\n                best_cnt = cand_cnt\n                best_nb = cand\n                best_c = c\n        if best_nb is not None:\n            return best_nb, f\"conflict-kempe-v{v+1}-with-{best_c}\"\n\n        # If no improving move found, return identity to signal stall\n        return sol[:], \"conflict-stall\"\n\n    else:\n        # Feasible phase: Try to reduce the number of colors without creating conflicts\n        if len(palette) <= 1:\n            return sol[:], \"feasible-noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        # Try direct recolor for any max-color vertex to a lower legal color\n        for v in sorted(vertices_max):\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol[:]\n                nb[v] = new_color\n                # Ensure still feasible globally\n                ok = True\n                for (u,w) in edges:\n                    if nb[u-1] == nb[w-1]:\n                        ok = False\n                        break\n                if ok:\n                    return nb, f\"reduce-k-recolor-v{v+1}-to-{new_color}\"\n        # Try Kempe swap with a lower color that keeps feasibility\n        for v in sorted(vertices_max):\n            for target in [c for c in palette if c < max_color]:\n                cand, comp = kempe_swap(sol, v, target)\n                # Verify feasibility for entire solution\n                ok = True\n                for (u,w) in edges:\n                    if cand[u-1] == cand[w-1]:\n                        ok = False\n                        break\n                if ok:\n                    return cand, f\"reduce-k-kempe-v{v+1}-with-{target}\"\n        # No feasible k-reducing move found\n        return sol[:], \"feasible-noop\"\n","Perturbacion":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 4) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def kempe_swap(sol, v, target_color):\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        component = []\n        while q:\n            x = q.popleft()\n            component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n    pert = sol[:]\n\n    # Perform 2-4 Kempe-chain swaps using existing palette to diversify\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        palette = sorted(set(pert))\n        if len(palette) < 2:\n            break\n        v = random.randrange(n)\n        choices = [c for c in palette if c != pert[v]]\n        if not choices:\n            continue\n        t = random.choice(choices)\n        cand = kempe_swap(pert, v, t)\n        pert = cand\n\n    # Light repairs without introducing new colors\n    for _ in range(n):  # bounded passes\n        conflicted = []\n        for (u,v) in edges:\n            if pert[u-1] == pert[v-1]:\n                conflicted.append(u-1)\n                conflicted.append(v-1)\n        if not conflicted:\n            break\n        i = max(set(conflicted), key=lambda x: sum(1 for w in adj[x] if pert[w]==pert[x]))\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette = sorted(set(pert))\n        legal = [c for c in palette if c != pert[i] and c not in neighbor_colors]\n        if legal:\n            pert[i] = min(legal)\n        else:\n            # fallback: color minimizing equal-colored neighbors, still within palette\n            best_c = pert[i]\n            best_cnt = len(adj[i]) + 1\n            for c in palette:\n                if c == pert[i]:\n                    continue\n                cnt = sum(1 for w in adj[i] if pert[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            pert[i] = best_c\n\n    return pert\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS;c[i] in {1,...,k} for vertex i (1-indexed). Labels contiguous {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Constants and graph definition (1-indexed vertices)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    HARD_PEN = 10**9\n    PEN_GAP = 2000.0\n    PEN_EDGE = 100.0\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        fitness += PEN_GAP\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local bind\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return float(fitness)\n","Vecindad":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _conflicts_of_vertex(sol, v):\n    c = sol[v-1]\n    cnt = 0\n    for nb in _adj[v]:\n        if sol[nb-1] == c:\n            cnt += 1\n    return cnt\n\ndef _total_conflicts(sol):\n    cnt = 0\n    for (u, v) in _EDGES:\n        if sol[u-1] == sol[v-1]:\n            cnt += 1\n    return cnt\n\ndef _kempe_swap(sol, color_a, color_b, start_v):\n    # BFS on subgraph induced by colors {a,b}, swap within the connected component containing start_v\n    n = len(sol)\n    if start_v < 1 or start_v > n:\n        return sol[:]\n    if sol[start_v-1] not in (color_a, color_b):\n        return sol[:]\n    target_set = {color_a, color_b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target_set:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        cv = out[v-1]\n        if cv == color_a:\n            out[v-1] = color_b\n        elif cv == color_b:\n            out[v-1] = color_a\n    return out\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _saturation(sol):\n    # returns list of (v, saturation_degree)\n    sat = []\n    for v in range(1, 10):\n        neigh_colors = set(sol[nb-1] for nb in _adj[v])\n        sat.append((v, len(neigh_colors)))\n    return sat\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input\")\n    sol = solution[:]\n    colors = list(sorted(set(sol)))\n    k = max(colors)\n\n    move_choices = [\"recolor_best\", \"kempe\", \"class_swap\", \"dsatur_recolor\"]\n    move = random.choices(move_choices, weights=[4, 3, 1, 2], k=1)[0]\n\n    if move == \"recolor_best\":\n        v = random.randrange(1, 10)\n        current = sol[v-1]\n        best_score = None\n        best_colors = []\n        for c in colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            score = _conflicts_of_vertex(tmp, v)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        return (sol, \"recolor_best\")\n\n    if move == \"kempe\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a start vertex that has color a or b\n            candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n            if candidates:\n                v0 = random.choice(candidates)\n                neigh = _kempe_swap(sol, a, b, v0)\n                return (neigh, f\"kempe({a},{b})\")\n        return (sol, \"kempe_noop\")\n\n    if move == \"class_swap\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            neigh = sol[:]\n            for i in range(9):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, f\"class_swap({a},{b})\")\n        return (sol, \"class_swap_noop\")\n\n    # dsatur_recolor\n    sat = _saturation(sol)\n    max_sat = max(s for _, s in sat)\n    candidates = [v for v, s in sat if s == max_sat]\n    v = random.choice(candidates)\n    current = sol[v-1]\n    neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n    # Prefer existing colors not in neighbor_colors\n    feasible = [c for c in colors if c != current and c not in neighbor_colors]\n    if feasible:\n        sol[v-1] = random.choice(feasible)\n    else:\n        # If none feasible, try any different existing color to mix\n        alt = [c for c in colors if c != current]\n        if alt:\n            sol[v-1] = random.choice(alt)\n    return (sol, \"dsatur_recolor\")\n","Perturbacion":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _vertex_conflicts(sol, v):\n    c = sol[v-1]\n    return sum(1 for nb in _adj[v] if sol[nb-1] == c)\n\ndef _total_conflicts(sol):\n    return sum(1 for (u, v) in _EDGES if sol[u-1] == sol[v-1])\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _kempe_component_swap(sol):\n    colors = list(sorted(set(sol)))\n    if len(colors) < 2:\n        return sol[:]\n    a, b = random.sample(colors, 2)\n    # choose a start vertex carrying color a or b\n    candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n    if not candidates:\n        return sol[:]\n    start_v = random.choice(candidates)\n    target = {a, b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        out[v-1] = a if out[v-1] == b else (b if out[v-1] == a else out[v-1])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n\n    # Identify high-conflict vertices\n    conflicts = [(v, _vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, c in conflicts[:m]]\n\n    colors = list(sorted(set(sol)))\n    max_colors = max(colors) + 1  # allow slight expansion during perturbation\n\n    # Greedy recolor targets using limited palette 1..max_colors\n    for v in targets:\n        neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n        # Prefer existing colors not used by neighbors\n        feasible = [c for c in range(1, max_colors+0) if c in colors and c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: choose color minimizing immediate conflicts (including possibly new color)\n            best_c = None\n            best_val = None\n            for c in range(1, max_colors+1):\n                val = sum(1 for nb in _adj[v] if (sol[nb-1] == c))\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            sol[v-1] = best_c if best_c is not None else sol[v-1]\n        # keep colors list updated\n        colors = list(sorted(set(sol)))\n\n    # Apply a Kempe swap to further diversify\n    sol = _kempe_component_swap(sol)\n\n    # Normalize labels to contiguous 1..k' to avoid gap penalties\n    sol = _relabel_contiguous(sol)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors first\n        try_colors = list(colors)\n        random.shuffle(try_colors)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = vertex_conflicts(tmp, v)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                # fallback: pick any other color if exists\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        # Prefer existing colors not in neighbor set\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: pick color minimizing immediate equal-neighbor count\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\n# Required signature line (informational): def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize global delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors plus possible new color k+1 with small probability\n        k = max(sol)\n        try_colors = list(colors)\n        if random.random() < 0.15:\n            try_colors.append(k + 1)\n        random.shuffle(try_colors)\n        base_conf = total_conflicts(sol)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = total_conflicts(tmp)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice([u, v]) if random.random() < 0.7 else random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return ([1,2,3,1,2,3,2,1,3], \"repair\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_incident_conflicts(sol, u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v-1] == color:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol, prefer_conflict=True):\n        # Choose vertex\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if prefer_conflict and conflicts_vertices:\n            u = random.choice(list(conflicts_vertices))\n        else:\n            u = random.randint(1, 9)\n        used = set(sol)\n        current = sol[u-1]\n        candidates = list(used)\n        # Try to stay within current colors; if impossible, allow new color\n        best_color = current\n        best_score = 10**9\n        for c in candidates:\n            if c == current:\n                continue\n            score = count_incident_conflicts(sol, u, c)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        if best_score == 0:\n            sol[u-1] = best_color\n            return sol, \"recolor-minconflict\"\n        # No conflict-free among existing colors; optionally introduce a new color\n        if random.random() < 0.5:\n            new_color = max(used) + 1\n            sol[u-1] = new_color\n            return sol, \"recolor-newcolor\"\n        else:\n            sol[u-1] = best_color\n            return sol, \"recolor-leastconflict\"\n\n    def kempe_chain_swap(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        # Choose a second color from neighbors or existing colors\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                # Nothing to swap\n                return recolor_min_conflict(sol, prefer_conflict=False)\n            cv = random.choice([c for c in used if c != cu])\n        # Build Kempe chain component of colors cu and cv containing u\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        component = []\n        while stack:\n            x = stack.pop()\n            component.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        # Swap colors cu <-> cv in the component\n        for x in component:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol, \"kempe-swap\"\n\n    def merge_move(sol):\n        # Attempt to reduce number of colors by moving a vertex from a rare color to another feasible color\n        used = list(set(sol))\n        if len(used) <= 1:\n            return recolor_min_conflict(sol, prefer_conflict=False)\n        color_counts = {c: 0 for c in used}\n        for c in sol:\n            color_counts[c] += 1\n        src = min(color_counts, key=lambda c: color_counts[c])\n        # Pick a vertex with color src\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        u = random.choice(verts)\n        # Try to assign a different existing color\n        dests = [c for c in used if c != src]\n        random.shuffle(dests)\n        for c in dests:\n            if all(sol[v-1] != c for v in adj[u]):\n                sol[u-1] = c\n                return sol, \"merge-move\"\n        # Fallback to min-conflict among dests\n        best_c = None\n        best_score = 10**9\n        for c in dests:\n            sc = count_incident_conflicts(sol, u, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c is not None and best_c != sol[u-1]:\n            sol[u-1] = best_c\n            return sol, \"merge-minconflict\"\n        return recolor_min_conflict(sol, prefer_conflict=False)\n\n    # Decide operator adaptively\n    # If conflicts exist, prioritize fixing them; else use structural moves\n    has_conflict = False\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            has_conflict = True\n            break\n\n    r = random.random()\n    if has_conflict:\n        if r < 0.7:\n            ns, mt = recolor_min_conflict(s[:], prefer_conflict=True)\n            return (ns, mt)\n        else:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n    else:\n        if r < 0.5:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n        else:\n            ns, mt = merge_move(s[:])\n            return (ns, mt)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap_once(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                return sol\n            cv = random.choice([c for c in used if c != cu])\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol\n\n    def random_recolor(sol):\n        u = random.randint(1, 9)\n        used = set(sol)\n        neighbor_colors = {sol[v-1] for v in adj[u]}\n        candidates = [c for c in used if c != sol[u-1] and c not in neighbor_colors]\n        if candidates:\n            sol[u-1] = random.choice(candidates)\n            return sol\n        # Allow introducing a new color with small probability to escape traps\n        if random.random() < 0.3:\n            sol[u-1] = max(used) + 1\n            return sol\n        # Else pick least-conflict among existing\n        best_c = sol[u-1]\n        best_score = 10**9\n        for c in used:\n            if c == sol[u-1]:\n                continue\n            score = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    score += 1\n            if score < best_score:\n                best_score = score\n                best_c = c\n        sol[u-1] = best_c\n        return sol\n\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.6:\n            s = kempe_swap_once(s)\n        else:\n            s = random_recolor(s)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        # never happens, guard\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict(sol):\n        # Choose a conflicted vertex (lowest index for determinism)\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = bad[0]\n        current = sol[u-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_score = 10**9\n        # Try only existing colors; do not introduce new colors during repair\n        for c in used:\n            if c == current:\n                continue\n            # Count incident conflicts if u recolored to c\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        # No improvement possible with existing colors; pick least-conflict anyway (no new color)\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        # Find smallest color class\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        src = min(colors, key=lambda c: counts[c])\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        dest_colors = [c for c in colors if c != src]\n        # Try each vertex deterministically\n        for u in sorted(verts):\n            neighbor_colors = {sol[v-1] for v in adj[u]}\n            for dc in dest_colors:\n                if dc not in neighbor_colors:\n                    sol[u-1] = dc\n                    sol = compress_colors(sol)\n                    return sol, True\n        return sol, False\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors targeting smallest class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        c1 = min(colors, key=lambda c: counts[c])\n        # pick c2 as the color most adjacent to c1 vertices to encourage elimination\n        border_counts = {c: 0 for c in colors}\n        for i, c in enumerate(sol, start=1):\n            if c != c1:\n                continue\n            for v in adj[i]:\n                border_counts[sol[v-1]] += 1\n        candidate_c2 = [c for c in colors if c != c1]\n        if not candidate_c2:\n            return sol, False\n        c2 = max(candidate_c2, key=lambda c: border_counts.get(c, 0))\n        # choose start vertex within c1 deterministically (lowest index)\n        starts = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not starts:\n            return sol, False\n        u0 = starts[0]\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        # Swap colors in component; preserves feasibility if input feasible\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        sol = compress_colors(sol)\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        # Try to reduce k via merge; if not, do a kempe swap\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; preserves feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        # pick a random start vertex and a second color different from its color\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def minconflict_recolor_step(sol):\n        # choose a conflicted vertex and recolor to least-conflict existing color\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        if not bad:\n            return sol\n        u = min(bad)\n        current = sol[u-1]\n        used = list(set(sol))\n        best = current\n        best_sc = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_sc:\n                best_sc = sc\n                best = c\n        sol[u-1] = best\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        # Random color permutation to diversify (structure-preserving)\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            if conflict_count(s) == 0:\n                break\n            s = minconflict_recolor_step(s)\n        s = compress_colors(s)\n        return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict_with_new(sol):\n        # Choose a conflicted vertex; break ties randomly\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = random.choice(bad)\n        current = sol[u-1]\n        used = sorted(set(sol))\n        # Evaluate existing colors\n        best_c = current\n        best_score = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_score > 0:\n            # Allow a temporary new color to break conflicts fast\n            new_color = max(used) + 1\n            # Check incident conflicts if using new color (always 0 by construction)\n            sol[u-1] = new_color\n            return sol, True\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class; iterate multiple moves\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        improved = False\n        changed = True\n        while changed:\n            changed = False\n            colors = sorted(set(sol))\n            if len(colors) <= 1:\n                break\n            # Find smallest color class\n            counts = {c: 0 for c in colors}\n            for c in sol:\n                counts[c] += 1\n            src = min(colors, key=lambda c: counts[c])\n            verts = [i+1 for i, c in enumerate(sol) if c == src]\n            dest_colors = [c for c in colors if c != src]\n            random.shuffle(verts)\n            # Try move each vertex to any compatible destination color\n            for u in verts:\n                neighbor_colors = {sol[v-1] for v in adj[u]}\n                # Order destination colors by minimal conflicts potential\n                dest_colors_sorted = sorted(dest_colors, key=lambda dc: sum(1 for v in adj[u] if sol[v-1] == dc))\n                moved = False\n                for dc in dest_colors_sorted:\n                    if dc not in neighbor_colors:\n                        sol[u-1] = dc\n                        changed = True\n                        improved = True\n                        moved = True\n                        break\n                if moved:\n                    continue\n            # If source color emptied, compress and continue\n            if all(c != src for c in sol):\n                sol = compress_colors(sol)\n        # Final attempt: if still same k, try a focused Kempe swap between src and best dest\n        return sol, improved\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors; randomized start to avoid cycling\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        c1 = random.choice(colors)\n        c2_choices = [c for c in colors if c != c1]\n        if not c2_choices:\n            return sol, False\n        c2 = random.choice(c2_choices)\n        # choose start vertex among those with color c1 maximizing boundary degree\n        c1_vertices = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not c1_vertices:\n            return sol, False\n        def boundary_deg(u):\n            return sum(1 for v in adj[u] if sol[v-1] == c2)\n        best_bd = max(boundary_deg(u) for u in c1_vertices)\n        candidates = [u for u in c1_vertices if boundary_deg(u) == best_bd]\n        u0 = random.choice(candidates)\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict_with_new(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            ns = compress_colors(ns)\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        if swapped:\n            ns = compress_colors(ns)\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; aims to preserve feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def random_recolor_break_sym(sol):\n        # Occasionally move a vertex to a new color to diversify\n        i = random.randint(1, 9)\n        used = set(sol)\n        new_c = max(used) + 1\n        sol[i-1] = new_c\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        # Perform a few Kempe swaps and optional random recolor, then compress\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        if random.random() < 0.25:\n            s = random_recolor_break_sym(s)\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation: min-conflict recolors and compression\n        for _ in range(6):\n            if conflict_count(s) == 0:\n                break\n            # pick conflicted vertex with random tie-breaking\n            bad = set()\n            for u, v in edges:\n                if s[u-1] == s[v-1]:\n                    bad.add(u)\n                    bad.add(v)\n            if not bad:\n                break\n            u = random.choice(list(bad))\n            current = s[u-1]\n            used = list(set(s))\n            # try existing colors first\n            best = current\n            best_sc = 10**9\n            for c in used:\n                if c == current:\n                    continue\n                sc = 0\n                for v in adj[u]:\n                    if s[v-1] == c:\n                        sc += 1\n                if sc < best_sc:\n                    best_sc = sc\n                    best = c\n            if best_sc > 0:\n                # allow new color to break conflicts\n                best = max(used) + 1\n            s[u-1] = best\n        s = compress_colors(s)\n        return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where position i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Strategy: prioritize conflict resolution via best-improvement recolor; otherwise color-pair swap.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a trivial repaired solution if invalid\n        repaired = [1]*n\n        return (repaired, \"Repair\", \"ResetToOnes\")\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [max(1, int(c) if isinstance(c, int) else 1) for c in solution]\n            return (repaired, \"Repair\", \"Sanitize\")\n    K = max(solution)\n    # Build adjacency and conflict info\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    conflicts_vertices = []\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts_vertices.append(u)\n            conflicts_vertices.append(v)\n    conflicts_vertices = list(set(conflicts_vertices))\n    # Helper: evaluate delta conflicts for coloring vertex i with color col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n    # Attempt 1: if conflicts exist, best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        v = random.choice(conflicts_vertices)\n        current_col = solution[v-1]\n        best_col = current_col\n        best_delta = 0\n        # Restrict palette to 1..K (no drift)\n        for col in range(1, K+1):\n            if col == current_col:\n                continue\n            d = conflict_delta(solution, v, col)\n            if d < best_delta or (d == best_delta and random.random() < 0.5):\n                best_delta = d\n                best_col = col\n        neigh = solution[:]\n        if best_col != current_col:\n            neigh[v-1] = best_col\n            return (neigh, \"Single-Vertex-Recolor\", \"BestImprovement\")\n        # fallback: random recolor different color in [1..K]\n        candidate = [c for c in range(1, K+1) if c != current_col]\n        if not candidate:\n            candidate = [1 if current_col != 1 else 2]\n        neigh[v-1] = random.choice(candidate)\n        if neigh != solution:\n            return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    # Attempt 2: color swap between two colors (Kempe-like color class swap)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = solution[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != solution:\n            return (neigh, \"ColorClassSwap\", \"PairSwap\")\n    # Attempt 3: directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(solution, start=1) if col == K]\n    if verts_K:\n        v = random.choice(verts_K)\n        neigh = solution[:]\n        # Try smallest feasible color in [1..K-1]\n        forbidden = {solution[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh[v-1] = col\n                if neigh != solution:\n                    return (neigh, \"ReduceK\", \"GreedyFeasible\")\n    # Final fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    current_col = solution[idx]\n    cand = [c for c in range(1, K+1) if c != current_col]\n    if not cand:\n        cand = [1 if current_col != 1 else 2]\n    neigh = solution[:]\n    neigh[idx] = random.choice(cand)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomFallback\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor subset of vertices + attempt color compaction (reduce K without using K+1)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n    s = solution[:]\n    K = max(s)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    # Compute degrees and conflicts\n    deg = {i: len(adj[i]) for i in adj}\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u); conflicted.add(v)\n    # Kick parameters\n    steps = max(3, n \/\/ 3)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    # Bias toward higher degree vertices\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n    # Random recolors within [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n    # Targeted reduction: try to recolor vertices of color K into [1..K-1]\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n    # Color compaction: renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c:i+1 for i,c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [1 if (not isinstance(c, int) or c < 1) else c for c in solution]\n            return (repaired, (\"Repair\", \"Sanitize\"))\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict list\n    conflicts_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n    conflicts_vertices = list(conflicts_vertices)\n\n    # Helper: conflict delta for recoloring vertex i to new_col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n\n    # 1) Best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        best_move = None\n        best_delta = math.inf\n        for v in conflicts_vertices:\n            cur = s[v-1]\n            for col in range(1, K+1):\n                if col == cur:\n                    continue\n                d = conflict_delta(s, v, col)\n                if d < best_delta or (d == best_delta and random.random() < 0.5):\n                    best_delta = d\n                    best_move = (v, col)\n        if best_move is not None and best_delta < 0:\n            v, col = best_move\n            neigh = s[:]\n            neigh[v-1] = col\n            return (neigh, (\"Single-Vertex-Recolor\", \"BestImprovement\"))\n        # fallback random recolor on a conflicted vertex\n        v = random.choice(conflicts_vertices)\n        cur = s[v-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(palette)\n        if neigh != s:\n            return (neigh, (\"Single-Vertex-Recolor\", \"RandomRecolorConflicted\"))\n\n    # 2) Color-class swap between two colors (Kempe-like)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"PairSwap\"))\n\n    # 3) Directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                if neigh != s:\n                    return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n\n    # 4) Fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    cur = s[idx]\n    palette = [c for c in range(1, K+1) if c != cur]\n    if not palette:\n        palette = [1 if cur != 1 else 2]\n    neigh = s[:]\n    neigh[idx] = random.choice(palette)\n    return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallback\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex recolors + targeted K-compaction\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency and degree\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    deg = {i: len(adj[i]) for i in adj}\n\n    # Conflicted set\n    conflicted = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    # Kick parameters (adaptive to conflicts)\n    base_steps = max(3, n \/\/ 3)\n    steps = base_steps + (len(conflicted) \/\/ 2)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n\n    # Random weighted recolors using existing palette [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0.0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n\n    # Targeted K-reduction and compaction\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        random.shuffle(verts_K)\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n\n    # Cache graph structures on first call to avoid rebuild overhead\n    if not hasattr(generate_neighbour, \"_E\"):\n        E = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        generate_neighbour._E = tuple(E)\n        generate_neighbour._adj = {k: tuple(sorted(vs)) for k, vs in adj.items()}\n        generate_neighbour._deg = {k: len(vs) for k, vs in adj.items()}\n    E = generate_neighbour._E\n    adj = generate_neighbour._adj\n\n    s = solution[:]\n    K = max(s)\n\n    # Conflict bookkeeping\n    conflict_count = [0]*(n+1)\n    conflicted_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            conflicted_vertices.add(u)\n            conflicted_vertices.add(v)\n\n    # Helper: compute conflicts if vertex i is recolored to col\n    def conflicts_if(i, col):\n        cnt = 0\n        for nb in adj[i]:\n            if s[nb-1] == col:\n                cnt += 1\n        return cnt\n\n    # Helper: Kempe-chain swap of two colors c1,c2 restricted to the component containing start vertex v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        target = sol[v-1]\n        other = c2 if target == c1 else c1\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # If there are conflicts, apply min-conflicts or Kempe-chain guided move\n    if conflicted_vertices:\n        # Choose vertex with maximum conflict degree (tie-break by higher graph degree)\n        mx = -1\n        pick = None\n        for v in conflicted_vertices:\n            key = (conflict_count[v], len(adj[v]))\n            if key > (mx, -1) if pick is None else key > (conflict_count[pick], len(adj[pick])):\n                mx = conflict_count[v]\n                pick = v\n        v = pick\n        cur = s[v-1]\n        # Palette is existing colors 1..K\n        palette = list(range(1, K+1))\n        # Min-conflicts recolor with least-used tie-break to aid K reduction\n        usage = {c: 0 for c in palette}\n        for col in s:\n            usage[col] = usage.get(col, 0) + 1\n        best_cols = []\n        best_conf = math.inf\n        for col in palette:\n            if col == cur:\n                continue\n            cval = conflicts_if(v, col)\n            if cval < best_conf:\n                best_conf = cval\n                best_cols = [col]\n            elif cval == best_conf:\n                best_cols.append(col)\n        if best_cols and best_conf <= conflict_count[v]:\n            # choose least-used among best\n            best_cols.sort(key=lambda c: (usage.get(c, 0), c))\n            neigh = s[:]\n            neigh[v-1] = best_cols[0]\n            return (neigh, (\"Single-Vertex-Recolor\", \"MinConflicts\"))\n        # Try Kempe-chain between current color and a conflicting neighbor color\n        nb_colors = {s[nb-1] for nb in adj[v] if s[nb-1] == cur or nb in conflicted_vertices}\n        # If none, try any neighbor colors\n        if not nb_colors:\n            nb_colors = {s[nb-1] for nb in adj[v]}\n        for c2 in nb_colors:\n            if c2 == cur:\n                continue\n            neigh = kempe_swap_on_component(s, v, cur, c2)\n            # Accept if reduces conflicts\n            new_conf = 0\n            for (u, w) in E:\n                if neigh[u-1] == neigh[w-1]:\n                    new_conf += 1\n            old_conf = len(conflicted_vertices)\n            if new_conf < old_conf:\n                return (neigh, (\"KempeSwap\", \"ConflictReducing\"))\n        # Fallback random min-conflicts recolor\n        candidates = [c for c in palette if c != cur]\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(candidates)\n        return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallbackConflicted\"))\n\n    # If no conflicts, attempt K reduction\n    # 1) Greedy recolor vertices of max color into lower feasible colors\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n    # 2) Kempe-chain between color K and a lower color to free a K-vertex\n    if verts_K:\n        target_v = random.choice(verts_K)\n        for c2 in range(1, K):\n            neigh = kempe_swap_on_component(s, target_v, K, c2)\n            # If target_v changed color, we reduced K usage potentially\n            if neigh[target_v-1] != K:\n                return (neigh, (\"ReduceK\", \"KempeSwapK\"))\n    # 3) Color-class swap between K and a random lower color (may help compaction)\n    if K > 1:\n        c2 = random.randrange(1, K)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == K:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = K\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"KWithLower\"))\n    # 4) Plateau diversification: recolor vertex with largest degree to least-used lower color\n    usage = {c: 0 for c in range(1, K+1)}\n    for col in s:\n        usage[col] = usage.get(col, 0) + 1\n    idx = max(range(1, n+1), key=lambda i: len(adj[i]))\n    candidates = list(range(1, K+1))\n    candidates.sort(key=lambda c: (usage.get(c, 0), c))\n    if s[idx-1] == candidates[0] and len(candidates) > 1:\n        tgt = candidates[1]\n    else:\n        tgt = candidates[0]\n    neigh = s[:]\n    neigh[idx-1] = tgt\n    return (neigh, (\"Diversification\", \"LeastUsedColor\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex Kempe-chain kicks, class shuffle, and ejection chains targeting max color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [1]*n\n\n    # Static graph (embedded)\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    s = solution[:]\n    K = max(s)\n\n    # Helper: compute conflicts\n    def conflicts(sol):\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    # Kempe swap on component for colors c1,c2 starting at v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # 1) Multi-vertex Kempe-chain kicks\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(1, n+1)\n        if K == 1:\n            break\n        c1 = s[v-1]\n        c2 = random.randrange(1, K+1)\n        while c2 == c1 and K > 1:\n            c2 = random.randrange(1, K+1)\n        s = kempe_swap_on_component(s, v, c1, c2)\n\n    # 2) Color-class shuffle: pick a random color class and remap into [1..K-1] if possible\n    if K > 1:\n        cls = random.randrange(1, K+1)\n        tgt = random.randrange(1, K)\n        if tgt != cls:\n            for i, col in enumerate(s):\n                if col == cls:\n                    s[i] = tgt\n\n    # 3) Ejection chains (length 2\u20134) targeting max-color vertices\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    chain_len = random.randint(2, 4)\n    for _ in range(chain_len):\n        if not verts_K:\n            break\n        v = random.choice(verts_K)\n        forbidden = {s[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, K) if c not in forbidden] if K > 1 else [1]\n        if not candidates:\n            # if no feasible lower color, push a neighbor to another color to create room\n            nb = random.choice(list(adj[v]))\n            nb_forbidden = {s[u-1] for u in adj[nb]}\n            palette = [c for c in range(1, K+1) if c not in nb_forbidden]\n            if palette:\n                s[nb-1] = random.choice(palette)\n        else:\n            s[v-1] = random.choice(candidates)\n        K = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n\n    # Post-perturb compaction: greedily push down any remaining max colors\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED. solution is a list of 9 positive ints; however, I\/O is tolerant and also accepts a whitespace-separated string of 9 ints. Objective: minimize max color used (k).","Evaluacion":"from typing import List, Tuple\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # soft penalty weight per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    # validate entries\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = compact(arr)\n\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        # simple fallback shape\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list for efficiency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # identify conflicting vertices\n    conflicting = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicting.add(u-1)\n            conflicting.add(v-1)\n\n    # pick a vertex: prioritize conflicts\n    if conflicting:\n        v = random.choice(list(conflicting))\n    else:\n        v = random.randrange(n)\n\n    # candidate colors: colors used in neighborhood plus ones present, maybe exploratory new color\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n    candidates = sorted(present_colors.union(neigh_colors))\n\n    # allow exploratory new color only if currently conflicting\n    if conflicting and random.random() < 0.2:\n        candidates.append(current_max + 1)\n\n    # scoring: number of conflicts if v is colored with c\n    def conflicts_if(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = [(conflicts_if(v, c, sol), c) for c in candidates]\n    scored.sort(key=lambda t: (t[0], random.random()))\n\n    # choose among top-min conflict colors\n    best_conf = scored[0][0]\n    pool = [c for (conf, c) in scored if conf == best_conf]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n    neighbor = compact(neighbor)\n\n    return neighbor, \"Recolor\", \"SingleVertex\"","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # random relabeling to break symmetry\n    labels = sorted(set(sol))\n    if labels:\n        shuf = labels[:]\n        random.shuffle(shuf)\n        relabel = {old: new for new, old in enumerate(shuf, start=1)}\n        sol = [relabel.get(x, x) for x in sol]\n\n    # compute conflict degree per vertex\n    def v_conflicts(idx: int, arr: List[int]) -> int:\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # choose a set of vertices with highest conflicts (or random if no conflicts)\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = random.randint(3, 5)\n    targets = [i for (sc, i) in conf_scores[:q]]\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n\n    # greedy randomized recolor for targets\n    present_colors = sorted(set(sol))\n    for v in targets:\n        # candidate colors among present plus one exploratory\n        candidates = present_colors[:]\n        candidates.append(max(present_colors) + 1 if present_colors else 1)\n        # score by local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], random.random()))\n        pick_pool = [c for conf, c in scored[:min(2, len(scored))]]\n        sol[v] = random.choice(pick_pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    arr = compact(arr)\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\n\nrandom.random  # reference to ensure import is used\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # compute conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    # choose vertex: bias towards higher conflict; if none, random vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates)\n    else:\n        v = random.randrange(n)\n\n    # allowed candidate colors: existing colors 1..current_max; allow current_max+1 only if v is conflicting\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    candidates = sorted(present_colors)\n    if conflict_counts[v] > 0:\n        # exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(current_max + 1)\n    # always consider any neighbor colors (already subset of present, but keep for completeness)\n    for c in neigh_colors:\n        if c not in candidates:\n            candidates.append(c)\n\n    # scoring for each candidate color\n    def conflicts_if(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        local_conf = conflicts_if(v, c, sol)\n        # secondary criterion: prefer smaller resulting max color\n        new_max = max(current_max if c <= current_max else c, max(sol))\n        scored.append((local_conf, new_max, random.random(), c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_local = scored[0][0]\n    pool = [t[3] for t in scored if t[0] == best_local]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\n\nrandom.randrange  # reference to ensure import is used\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # conflict score per vertex\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol))\n    if not present_colors:\n        present_colors = [1]\n\n    for v in targets:\n        candidates = present_colors[:]\n        # allow exploratory new color\n        candidates.append(max(present_colors) + 1)\n        # evaluate local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            # prefer smaller color numbers to aid compaction\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1], random.random()))\n        best_conf = scored[0][0]\n        pool = [c for (conf, c) in scored if conf == best_conf][:2]\n        sol[v] = random.choice(pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n\n    arr = compact(arr)\n    if arr is None:\n        return 10**12\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\nimport math\n\nrandom.random  # keep import referenced\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    present_colors = set(sol)\n    current_max = max(present_colors) if present_colors else 1\n\n    # choose vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates_v = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates_v)\n    else:\n        # conflict-free: try to reduce k by targeting max-color vertices first\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n        else:\n            v = random.randrange(n)\n\n    # candidate colors: 1..current_max plus possibly current_max+1 with small probability\n    candidates = list(range(1, current_max + 1))\n    if conflict_counts[v] > 0 and random.random() < 0.15:\n        candidates.append(current_max + 1)\n\n    # local scoring: (conflicts_after, new_max_color)\n    def local_conflicts(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        lc = local_conflicts(v, c, sol)\n        new_max = max(c if c > current_max else current_max, max(sol))\n        # prefer fewer conflicts, then smaller max color, then smaller color index\n        scored.append((lc, new_max, c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_conf = scored[0][0]\n    pool = [t for t in scored if t[0] == best_conf]\n    # light randomness among equally best\n    choice = random.choice(pool)\n    new_c = choice[2]\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    # compact to align with evaluation behavior\n    neighbor = compact(neighbor)\n    if neighbor is None:\n        neighbor = sol[:]\n\n    return neighbor, \"Recolor_SingleVertex\"\n","Perturbacion":"import random\nimport math\n\nrandom.randrange  # keep import referenced\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # helper to count vertex conflicts\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # select a small set of targets: prefer conflicting or max-color vertices\n    current_max = max(sol) if sol else 1\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        # no conflicts: target vertices using the maximum color to encourage k reduction\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if len(max_color_vertices) >= q:\n            targets = random.sample(max_color_vertices, k=q)\n        else:\n            others = [i for i in range(n) if i not in max_color_vertices]\n            extra = random.sample(others, k=max(0, q - len(max_color_vertices))) if others else []\n            targets = max_color_vertices + extra\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol)) if sol else [1]\n\n    # perturb by recoloring targets to low-conflict colors with slight randomness\n    for v in targets:\n        candidates = list(range(1, max(present_colors) + 1))\n        # allow exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(max(present_colors) + 1)\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1]))\n        # choose among the two best options to diversify\n        topk = [c for (cnt, c) in scored if cnt == scored[0][0]][:2]\n        sol[v] = random.choice(topk)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Check element domain\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Normalize colors to 1..k contiguous\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current = sol[:]\n    kmax = max(current) if current else 1\n\n    # Conflict counts per vertex\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    has_conflict = any(x > 0 for x in conflict_deg)\n\n    if has_conflict:\n        # Pick vertex with maximum conflict degree (tie-break by lowest index)\n        u = max(range(n), key=lambda i: (conflict_deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n    else:\n        # Attempt to reduce number of colors by moving a vertex from the highest color class\n        kmax = max(current) if current else 1\n        # Gather vertices by color\n        by_color = {c: [] for c in range(1, kmax+1)}\n        for i, c in enumerate(current):\n            by_color[c].append(i)\n\n        target_color = kmax\n        # Greedy recolor attempt for any vertex in target_color to a lower color\n        for u in by_color.get(target_color, []):\n            used = {current[v] for v in adj[u]}\n            for c in range(1, target_color):\n                if c not in used:\n                    new_sol = current[:]\n                    new_sol[u] = c\n                    # If target color becomes empty, normalize eliminates it\n                    new_sol = normalize_colors(new_sol)\n                    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n                    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"ReduceAttempt\")\n        # If not directly possible, perform a Kempe-chain swap between target_color and some lower color\n        for a in range(1, kmax):\n            if not by_color.get(target_color):\n                break\n            u = by_color[target_color][0]\n            # BFS on subgraph induced by colors {a, target_color}\n            allowed = {a, target_color}\n            visited = set()\n            comp = []\n            stack = [u]\n            while stack:\n                x = stack.pop()\n                if x in visited:\n                    continue\n                if current[x] not in allowed:\n                    continue\n                visited.add(x)\n                comp.append(x)\n                for nb in adj[x]:\n                    if current[nb] in allowed and nb not in visited:\n                        stack.append(nb)\n            new_sol = current[:]\n            for x in comp:\n                new_sol[x] = a if current[x] == target_color else target_color\n            new_sol = normalize_colors(new_sol)\n            encoded_neighbor = json.dumps({\"solution\": new_sol, \"kempe_colors\": [a, target_color]})\n            return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"KempeSwap\")\n\n        # Fallback: recolor a random vertex to the smallest feasible color (deterministic seed)\n        seed_val = 1469598103934665603\n        for x in current:\n            seed_val ^= int(x) & 0xFFFFFFFF\n            seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n        random.seed(seed_val)\n        u = random.randrange(n)\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"RecolorFallback\")\n","Perturbacion":"import random\nimport json\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Normalize colors\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2-4 vertices biased towards the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))  # largest color first\n\n    num_moves = 2 + (seed_val % 3)  # 2..4 moves\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        # Prefer within current palette\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                # pick a random existing color (may create conflicts intentionally)\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n    out = normalize_colors(out)\n    return out\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    violations = 0\n    for i, x in enumerate(solution):\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: minimize violations first, then k_used\n    # Large margin W ensures feasibility prioritized\n    W = 100000\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k (applied upon return only)\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degree and saturation degree\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: pick vertex by (conflict_deg desc, saturation desc, degree desc, index asc)\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        # choose smallest feasible color or introduce new if needed\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: try to reduce k by reassigning a vertex from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor to lower color\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                # if target color emptied, normalization will remove it\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe-chain swap between target_color and partner color that yields best k reduction potential\n    best_payload = None\n    best_tag = None\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # pick vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        # normalize for return\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"kempe_colors\": [a, target_color]}\n        best_payload = payload\n        best_tag = \"KempeSwap\"\n        # return first improved candidate (simple heuristic)\n        break\n    if best_payload is not None:\n        return (\"ENCODED_SOLUTION:\" + json.dumps(best_payload), best_tag)\n\n    # Fallback: recolor a random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize for return\n    # (keeps palette compact for evaluators\/caching)\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"changed_index\": u, \"new_color\": out[u]}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optionally apply a Kempe swap across two random colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            # find a vertex with color a to start\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # Rebuild adjacency for safety (local scope)\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    for x in solution:\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    violations = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution)) if solution else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Strong lexicographic penalty to prioritize feasibility\n    W = 10**6\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1)), \"meta\": {\"reason\": \"InvalidInputFallback\"}})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degrees and neighbor colors\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: recolor most conflicting vertex to smallest feasible color\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        # tie-break: more conflicts, higher saturation, higher degree, lower index\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"RecolorConflict\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: attempt to reduce number of colors by moving from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor from target_color to lower colors\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"ReduceGreedy\"}}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe chain swap between target_color and a lower color (first viable)\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # choose a vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"meta\": {\"kempe_colors\": [a, target_color], \"tag\": \"KempeSwap\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"KempeSwap\")\n\n    # Fallback: recolor a pseudo-random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"meta\": {\"changed_index\": u, \"new_color\": out[u], \"tag\": \"RecolorFallback\"}}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optional Kempe swap across two colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # rebuild adjacency local scope\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list]) -> float:\n    # Lower is better: feasible -> k (max color); infeasible -> large penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        # Relabel colors to 1..k in order of appearance for stability\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols, u, ca, cb):\n        # Perform A-B Kempe chain swap containing u; returns new cols\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        # Build alternating component\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        # Swap colors in the component\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # Fail fast: return input unchanged with parse_error tag\n        return (solution, 'parse_error')\n\n    colors = normalize_colors(colors)\n    kmax = max(colors)\n\n    # Identify conflicted vertices\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n\n    move_type = None\n    new_cols = colors[:]\n\n    # Move selection: prioritize conflict-driven recolor, else apply diversification moves\n    r = random.random()\n    if conf_vertices and r < 0.5:\n        # Conflict-driven recolor: pick high-degree conflicted node, recolor to smallest feasible\n        u = max(conf_vertices, key=lambda x: (len(adj[x]), random.random()))\n        used = {colors[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                new_cols[u-1] = c\n                break\n        else:\n            # Try Kempe with a random neighbor color before introducing a new color\n            if used:\n                cb = random.choice(list(used))\n                ca = colors[u-1]\n                trial = kempe_interchange(colors, u, ca, cb)\n                # If reduces conflicts or preserves k, accept\n                if len(conflicts(trial)) <= len(conf_edges):\n                    new_cols = trial\n                else:\n                    new_cols[u-1] = kmax + 1\n                    kmax = kmax + 1\n            else:\n                new_cols[u-1] = kmax + 1\n                kmax = kmax + 1\n        move_type = 'conflict_recolor'\n    elif r < 0.8:\n        # Kempe chain swap around a random vertex and random color pair\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh_colors = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh_colors:\n            # fallback to recolor smallest feasible\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols[u-1] = feas\n            move_type = 'node_recolor'\n        else:\n            cb = random.choice(neigh_colors)\n            new_cols = kempe_interchange(colors, u, ca, cb)\n            move_type = 'kempe_swap'\n    else:\n        # Pairwise color swap of two non-adjacent vertices to reduce conflicts \/ compact colors\n        attempts = 0\n        applied = False\n        while attempts < 15 and not applied:\n            i = random.randrange(1, n+1)\n            j = random.randrange(1, n+1)\n            attempts += 1\n            if i == j or j in adj[i]:\n                continue\n            ci, cj = colors[i-1], colors[j-1]\n            new_cols = colors[:]\n            new_cols[i-1], new_cols[j-1] = cj, ci\n            # Accept if conflicts do not increase\n            if len(conflicts(new_cols)) <= len(conf_edges):\n                applied = True\n                move_type = 'pair_swap'\n                break\n        if not applied:\n            # fallback: simple recolor random node to smallest feasible\n            u = random.randrange(1, n+1)\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols = colors[:]\n                new_cols[u-1] = feas\n            else:\n                new_cols = colors[:]\n                new_cols[u-1] = kmax + 1\n            move_type = 'node_recolor'\n\n    # Normalize color labels\n    new_cols = normalize_colors(new_cols)\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_cols)\n    else:\n        out = new_cols\n    return (out, move_type if move_type is not None else 'unknown')\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation using 1-2 Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # If invalid, return a simple 4-color seed known feasible for this graph\n        fallback = [1,1,1,2,3,2,3,4,4]\n        if isinstance(solution, str):\n            return ','.join(str(x) for x in fallback)\n        return fallback\n\n    colors = normalize_colors(colors)\n\n    # Apply 1-2 Kempe swaps on random vertices\/color pairs\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Recolor up to two most-conflicted vertices greedily\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n    if conf_vertices:\n        # score vertices by conflicts then degree\n        def v_score(u):\n            cdeg = sum(1 for (a, b) in conf_edges if a == u or b == u)\n            return (cdeg, len(adj[u]))\n        conf_vertices.sort(key=lambda x: v_score(x), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v-1] for v in adj[u]}\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = kmax + 1\n                kmax += 1\n\n    # Normalize \/ compact labels\n    colors = normalize_colors(colors)\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    return colors\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> k (max color); infeasible -> scaled penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 100000.0\n    if len(colors) != n:\n        return 90000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 80000.0\n        if x < 1:\n            return 70000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n    if violations > 0:\n        return 10000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def normalize_colors(cols):\n        # Compact to 1..k preserving relative order of first appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # On parse error, return input as CSV unchanged with tag\n        if isinstance(solution, str):\n            return (solution, 'parse_error')\n        if isinstance(solution, list):\n            return (to_csv(solution), 'parse_error')\n        return (\"1,1,1,2,3,2,3,4,4\", 'parse_error')\n\n    colors = normalize_colors(colors)\n\n    # Determine feasibility and current k\n    conf_edges = conflicts(colors)\n    kmax = max(colors)\n\n    move_type = 'unknown'\n    new_cols = colors[:]\n\n    if conf_edges:\n        # Conflict repair priority\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        # Pick vertex with highest conflict degree, tie-break by random\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, colors, kmax)\n        if feas is not None:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            # Try Kempe swaps over all neighbor colors, pick best (min conflicts)\n            ca = colors[u - 1]\n            neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(colors, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: introduce a new color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible: attempt color elimination from max color class\n        max_class = [i for i, c in enumerate(colors, start=1) if c == kmax]\n        random.shuffle(max_class)\n        eliminated = False\n        for u in max_class:\n            feas = smallest_feasible_color(u, colors, kmax - 1)\n            if feas is not None:\n                new_cols[u - 1] = feas\n                eliminated = True\n                move_type = 'k_reduce_recolor'\n                break\n        if not eliminated:\n            # Try Kempe-based attempt to free a color for a max-class vertex\n            if max_class:\n                u = random.choice(max_class)\n                ca = colors[u - 1]\n                neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                applied = False\n                for cb in neigh_colors:\n                    trial = kempe_interchange(colors, u, ca, cb)\n                    # After swap, try greedy recolor within 1..kmax-1\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        applied = True\n                        move_type = 'k_reduce_kempe'\n                        break\n                if not applied:\n                    # Compact: swap labels of two colors to diversify\n                    if kmax >= 2:\n                        a, b = random.sample(range(1, kmax + 1), 2)\n                        for i in range(n):\n                            if new_cols[i] == a:\n                                new_cols[i] = b\n                            elif new_cols[i] == b:\n                                new_cols[i] = a\n                        move_type = 'color_class_swap'\n\n    # Optional normalization to keep labels compact; preserve k\n    new_cols = normalize_colors(new_cols)\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n    else:\n        colors = normalize_colors(colors)\n\n    # 1-2 Kempe swaps\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n + 1)\n        ca = colors[u - 1]\n        neigh = [colors[v - 1] for v in adj[u] if colors[v - 1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Greedy repair of up to two most conflicted vertices\n    conf_edges = conflicts(colors)\n    if conf_edges:\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def v_score(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        conf_vertices.sort(key=lambda x: (v_score(x), len(adj[x])), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v - 1] for v in adj[u]}\n            placed = False\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                colors[u - 1] = kmax + 1\n                kmax += 1\n\n    colors = normalize_colors(colors)\n    return to_csv(colors)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: primary objective = minimize violations, secondary = minimize k\n    # Scalarization: score = violations*1_000_000 + k; malformed => >= 1e9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 1_000_000_000.0\n    if len(colors) != n:\n        return 1_000_000_000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 1_000_000_000.0\n        if x < 1:\n            return 1_000_000_000.0\n\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n\n    if violations > 0:\n        return float(violations * 1_000_000)\n\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def conflicts(cols: List[int]):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def saturation_degree(u: int, cols: List[int]) -> int:\n        return len({cols[v - 1] for v in adj[u]})\n\n    def smallest_feasible_color(u: int, cols: List[int], kmax: int):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # Safe fallback to a valid 4-coloring\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Neighbor generation strategy:\n    # - If infeasible: pick most critical vertex by (conflict-degree, saturation, degree) and repair\n    # - If feasible: attempt k reduction by recoloring max color class or Kempe swap\n    conf_edges = conflicts(cols)\n    kmax = max(cols)\n\n    move_type = 'unknown'\n    new_cols = cols[:]\n\n    if conf_edges:\n        # Conflict repair\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), saturation_degree(x, cols), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, cols, kmax)\n        if feas is not None and feas != cols[u - 1]:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            ca = cols[u - 1]\n            neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(cols, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: cautiously expand color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible phase: try to reduce k\n        max_class_vertices = [i for i, c in enumerate(cols, start=1) if c == kmax]\n        random.shuffle(max_class_vertices)\n        reduced = False\n        for u in max_class_vertices:\n            feas = smallest_feasible_color(u, cols, kmax - 1)\n            if feas is not None and feas != cols[u - 1]:\n                new_cols[u - 1] = feas\n                move_type = 'k_reduce_recolor'\n                reduced = True\n                break\n        if not reduced:\n            if max_class_vertices:\n                u = max(max_class_vertices, key=lambda x: (saturation_degree(x, cols), len(adj[x]), random.random()))\n                ca = cols[u - 1]\n                neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                for cb in neigh_colors:\n                    trial = kempe_interchange(cols, u, ca, cb)\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        move_type = 'k_reduce_kempe'\n                        reduced = True\n                        break\n        if not reduced:\n            # Targeted color-class swap between two colors most conflicting on boundary\n            if kmax >= 2:\n                # Score boundary conflicts for each color\n                boundary = [0]*(kmax+1)\n                for (u,v) in edges:\n                    cu, cv = cols[u-1], cols[v-1]\n                    if cu != cv:\n                        boundary[cu] += 1\n                        boundary[cv] += 1\n                a = max(range(1,kmax+1), key=lambda c: (boundary[c], random.random()))\n                b = max([c for c in range(1,kmax+1) if c!=a], key=lambda c: (boundary[c], random.random()))\n                for i in range(n):\n                    if new_cols[i] == a:\n                        new_cols[i] = b\n                    elif new_cols[i] == b:\n                        new_cols[i] = a\n                move_type = 'color_class_swap'\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed:\n    # - 2 Kempe interchanges driven by local RNG(seed=hash(colors))\n    # - Greedy recolor of up to 2 vertices from largest color class\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    def greedy_recolor(u: int, cols: List[int], max_color_cap: int) -> bool:\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, max_color_cap + 1):\n            if c not in used:\n                cols[u - 1] = c\n                return True\n        return False\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Seeded RNG from solution to keep determinism per input\n    seed = 1469598103934665603\n    for x in cols:\n        seed = (seed ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Perform up to 2 Kempe swaps\n    for _ in range(2):\n        u = rng.randrange(1, n + 1)\n        cu = cols[u - 1]\n        neigh_colors = [cols[v - 1] for v in adj[u] if cols[v - 1] != cu]\n        if not neigh_colors:\n            continue\n        cb = rng.choice(neigh_colors)\n        cols = kempe_interchange(cols, u, cu, cb)\n\n    # Recolor a small subset from the largest color class into existing colors only\n    kmax = max(cols)\n    sizes = {c: 0 for c in range(1, kmax + 1)}\n    for c in cols:\n        sizes[c] += 1\n    largest_color = max(range(1, kmax + 1), key=lambda c: (sizes.get(c,0), rng.random()))\n    candidates = [i for i, c in enumerate(cols, start=1) if c == largest_color]\n    rng.shuffle(candidates)\n    moved = 0\n    for u in candidates:\n        if greedy_recolor(u, cols, kmax):\n            moved += 1\n        if moved >= 2:\n            break\n\n    return to_csv(cols)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list[int] of length 9\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Compute conflicting vertices\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.append(u - 1)\n            conflicts.append(v - 1)\n    conflicts = list(set(conflicts))\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        if limit is None:\n            up = max_c\n        else:\n            up = limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    # Randomly choose move type: 70% recolor, 30% Kempe swap\n    if random.random() < 0.70:\n        # Conflict-driven recolor: prefer conflicting vertices\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n            nb_type = \"ConflictDriven\"\n        else:\n            i = random.randrange(n)\n            nb_type = \"RandomVertex\"\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            # choose smallest feasible to bias toward lower K\n            new[i] = min(feas)\n        else:\n            # introduce new color with small probability, else random old color different from current\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return (new, nb_type, \"ReassignOne\")\n    else:\n        # Kempe chain swap between two colors to escape local minima\n        if max_c < 2:\n            # fallback to recolor if only one color present\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else max(1, ((new[i]) % max_c) + 1)\n            return (new, \"Fallback\", \"ReassignOne\")\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return (cur[:], \"NoOp\", \"KempeNone\")\n        seed = random.choice(candidates)\n        # BFS over subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        # swap colors in this component\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return (new, \"Kempe\", f\"Swap_{c1}_{c2}\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: pick a smallest color class and greedily recolor its vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    # choose smallest non-empty class\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # number of moves: 2 to 5 depending on size\n    steps = max(2, min(5, len(vertices)))\n    random.shuffle(vertices)\n    vertices = vertices[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in vertices:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            new[v] = random.choice(feas)\n        else:\n            # with small probability introduce a new color to escape infeasibility\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # fallback: assign a random different existing color\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        else:\n            try:\n                lst = [int(float(x)) for x in list(sol)]\n            except Exception:\n                return None\n        n = 9\n        if len(lst) != n:\n            return lst  # caller will handle size penalty below\n        return lst\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns neighbor solution only (list[int] of length 9)\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n    conflicts = list(conflicts)\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        up = max_c if limit is None else limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if random.random() < 0.70:\n        # Conflict-driven recolor (prefer conflicting vertices)\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(n)\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            new[i] = min(feas)  # bias to lower K\n        else:\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return new\n    else:\n        # Kempe chain swap between two colors\n        if max_c < 2:\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else 1\n            return new\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return cur[:]\n        seed = random.choice(candidates)\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return new\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: operate on small color classes and high-conflict vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n\n    # choose smallest non-empty class (deterministic tie by color id)\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # also collect high-conflict vertices\n    conflict_count = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    # number of moves: 2 to 5 depending on availability\n    base = vertices[:]\n    rand_extra = sorted(range(n), key=lambda i: -conflict_count[i])[:3]\n    pool = list(set(base + rand_extra))\n    random.shuffle(pool)\n    steps = max(2, min(5, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible to diversify\n            new[v] = random.choice(feas)\n        else:\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9_POSITIVE (example: 1,2,3,1,2,3,1,2,3)","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Graph Coloring objective: minimize K=max(color) subject to edge constraints\n    # Lower is better. Uses soft penalties: f = K + lambda * violations + invalid_penalty\n    # No globals; all data embedded\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    LAMBDA = 10.0\n    BIG = 1_000_000.0\n\n    def _coerce_list(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple)):\n            try:\n                lst = [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n        # length normalization only for evaluation; invalid length penalized\n        return lst\n\n    lst = _coerce_list(solution)\n    if lst is None:\n        return BIG\n\n    invalid = 0\n    if len(lst) != n:\n        return BIG + 1000.0 * abs(len(lst) - n)\n\n    # sanitize values; count invalids\n    colors = []\n    max_c = 0\n    for v in lst:\n        if isinstance(v, bool):\n            invalid += 1\n            v = 1\n        try:\n            c = int(v)\n        except Exception:\n            c = 1\n            invalid += 1\n        if c < 1:\n            invalid += 1\n            c = 1\n        colors.append(c)\n        if c > max_c:\n            max_c = c\n\n    # violations\n    viol = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            viol += 1\n\n    if invalid > 0:\n        return BIG\/10.0 + invalid * 100.0 + viol * 1000.0 + float(max_c)\n\n    # soft objective while infeasible, exact K when feasible\n    if viol == 0:\n        return float(max_c)\n    else:\n        return float(max_c) + LAMBDA * float(viol)\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"Local\"}; Movement_Type in {\"Decrement\",\"Recolor\",\"Kempe\"}\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1]*n\n        # pad\/trim to n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def conflicts_of(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u - 1)\n                conf.add(v - 1)\n        return list(conf)\n\n    max_c = max(cur) if cur else 1\n\n    # Move 1: Global decrement attempt on highest color class\n    high = max_c\n    high_vertices = [i for i, c in enumerate(cur) if c == high]\n\n    def feasible_colors(sol, idx, up):\n        used = set(sol[j] for j in adj[idx])\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if high > 1 and high_vertices and random.random() < 0.5:\n        new = cur[:]\n        success_any = False\n        for v in high_vertices:\n            feas = [c for c in feasible_colors(new, v, high - 1)]\n            if feas:\n                new[v] = random.choice(feas)\n                success_any = True\n        if success_any and max(new) <= max_c - 1:\n            return new, \"Local\", \"Decrement\"\n        # fallthrough if unsuccessful\n\n    # Move 2: Conflict-driven recolor\n    conf = conflicts_of(cur)\n    new = cur[:]\n    if conf and random.random() < 0.6:\n        i = random.choice(conf)\n    else:\n        i = random.randrange(n)\n    feas = feasible_colors(new, i, max_c)\n    if feas:\n        new[i] = min(feas) if random.random() < 0.7 else random.choice(feas)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # If no feasible color within 1..max_c, allow temporary new color to force change\n    choices = list(range(1, max_c + 1))\n    if new[i] in choices and len(choices) > 1:\n        choices.remove(new[i])\n    if choices:\n        new[i] = random.choice(choices)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # last resort: introduce new color to guarantee change\n    new[i] = max_c + 1\n    if new != cur:\n        return new, \"Local\", \"Recolor\"\n\n    # Move 3: Kempe chain swap for diversification\n    if max_c >= 2:\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if candidates:\n            seed = random.choice(candidates)\n            q = deque([seed])\n            visited = [False] * n\n            visited[seed] = True\n            comp = [seed]\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        visited[v] = True\n                        q.append(v)\n                        comp.append(v)\n            new = cur[:]\n            for v in comp:\n                new[v] = c2 if new[v] == c1 else (c1 if new[v] == c2 else new[v])\n            if new != cur:\n                return new, \"Local\", \"Kempe\"\n\n    # Safety: always return a different solution\n    j = (i + 1) % n\n    new = cur[:]\n    new[j] = (cur[j] % (max_c + 1)) + 1\n    if new[j] == cur[j]:\n        new[j] = cur[j] + 1\n    return new, \"Local\", \"Recolor\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger diversification: reassign a subset prioritizing smallest color class and high-conflict vertices\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1] * n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    smallest_class_color = min(classes.keys(), key=lambda k: (len(classes[k]), k))\n\n    # conflict counts\n    conflict_count = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    pool = list(set(classes[smallest_class_color] + sorted(range(n), key=lambda i: -conflict_count[i])[:3]))\n    random.shuffle(pool)\n    steps = max(3, min(6, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]  # work copy\n\n    def feasible_colors(idx, up):\n        used = set(new[j] for j in adj[idx])\n        # allow up to current max color; occasionally allow new color to diversify\n        colors = [c for c in range(1, up + 1) if c not in used]\n        return colors\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible for diversification\n            nc = random.choice(feas)\n            new[v] = nc\n        else:\n            # introduce at most one extra color with small probability\n            if random.random() < 0.3:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # forced change within 1..max_c\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices) if choices else max_c\n\n    return new\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    # Representation enforcement\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Distinct color count and normalization check\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type in {RECOLOR, SWAP}\n    Movement_Type in {single-vertex, pair-swap}\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Basic validation and repair-init\n    if not isinstance(solution, list) or len(solution) != n:\n        base = list(range(1, n + 1))\n        return (base, \"RECOLOR\", \"repair-init\")\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n\n    if random.random() < 0.8:\n        # RECOLOR neighborhood: focus on conflicted vertices if any\n        bad = conflicted_vertices(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(n)\n        current_color = new_sol[v]\n        max_c = max(new_sol) if new_sol else 1\n        # Prefer existing palette; occasionally allow +1 to escape\n        candidates = list(range(1, max_c + (1 if random.random() < 0.2 else 0) + 1))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and c < trial[v]):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        best = normalize_palette(best)\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP neighborhood: swap colors of two distinct vertices\n        i = random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        trial = normalize_palette(trial)\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor a subset (focused on conflicts if any)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n + 1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    bad = conflicted_vertices(sol)\n    pool = bad if bad else list(range(n))\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.choice(pool)\n        # recolor using existing palette plus occasional new color\n        new_c = random.randrange(1, max_c + (1 if random.random() < 0.3 else 0) + 1)\n        if new_c < 1:\n            new_c = 1\n        sol[v] = new_c\n    sol = normalize_palette(sol)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used (with SMALL penalty if palette not normalized 1..k).\n    Infeasible: large base penalty plus conflict-gradient to preserve ordering.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED_BASE = 100_000_000\n    CONFLICT_SCALE = 1_000\n    SMALL = 10_000\n    # Representation checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED_BASE + conflicts * CONFLICT_SCALE\n    # Distinct colors and normalization\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"RECOLOR\",\"SWAP\"}; Movement_Type in {\"single-vertex\",\"pair-swap\"}.\n    Implementation focuses on conflict-driven recolor; occasional pair-swap.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Validate\/repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        # Greedy coloring seed to avoid excessive conflicts\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        for v in range(1, n+1):\n            forbidden = {sol[u-1] for u in adj[v] if sol[u-1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[v-1] = c\n        return (sol, (\"RECOLOR\", \"repair-init\"))\n    sol = solution[:]\n    # Build adjacency list and quick helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    # With high probability do recolor; else do swap\n    if random.random() < 0.85:\n        # Select target vertex (prefer conflicted)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            v = random.randrange(n)\n        v1 = v + 1\n        current_color = sol[v]\n        # Candidate colors from neighbor palette plus optional new color\n        neigh_colors = {sol[u-1] for u in adj[v1]}\n        max_c = max(sol) if sol else 1\n        candidates = sorted(neigh_colors | {current_color})\n        # Occasionally allow introducing a new color to escape traps\n        if random.random() < 0.1:\n            candidates.append(max_c + 1)\n        # Evaluate delta conflicts for each candidate color\n        best_c = current_color\n        best_delta = None\n        best_palette_growth = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            # Compute conflicts if v were color c using only neighbors\n            before = 0\n            after = 0\n            for u in adj[v1]:\n                if sol[u-1] == current_color:\n                    before += 1\n                if sol[u-1] == c:\n                    after += 1\n            delta = after - before  # aim to minimize conflicts\n            palette_growth = 1 if c > max_c else 0\n            if (best_delta is None or\n                delta < best_delta or\n                (delta == best_delta and palette_growth < best_palette_growth) or\n                (delta == best_delta and palette_growth == best_palette_growth and c < best_c)):\n                best_delta = delta\n                best_palette_growth = palette_growth\n                best_c = c\n                if best_delta < 0 and best_palette_growth == 0:\n                    pass\n        new_sol = sol[:]\n        new_sol[v] = best_c\n        return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n    else:\n        # Conflict-aware pair swap: pick one conflicted (or random) and swap with a neighbor index\n        i = random.choice(conflicted) if conflicted else random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        new_sol = sol[:]\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (new_sol, (\"SWAP\", \"pair-swap\"))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor a small set of vertices, biased to conflicts,\n    using existing palette with occasional +1 color to escape.\n    Returns a valid representation (list of 9 positive ints).\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Minimal repair if needed\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n    steps = max(3, n \/\/ 3)\n    max_c = max(sol) if sol else 1\n    for _ in range(steps):\n        v = random.choice(pool)\n        neigh = {sol[u-1] for u in adj[v+1]}\n        candidates = list(set(range(1, max_c + 1)) - neigh)\n        if not candidates or random.random() < 0.25:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used.\n    Infeasible: strong penalty dominated by conflict count with small tie-break on distinct colors.\n    Representation must be a list of 9 positive integers.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**12\n    # Validate representation\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k_used = len(set(solution))\n    if conflicts > 0:\n        # Strong ordering in infeasible space\n        return 1_000_000 * conflicts + 1_000 * k_used\n    # Feasible: minimize number of colors\n    return k_used\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    Neighbourhoods:\n      - Conflict-driven recolor of a single vertex.\n      - Kempe-chain swap between two colors on a conflicted vertex component.\n    Always normalizes palette to 1..k.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Basic repair if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        # DSATUR seed\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # select vertex with max saturation degree then max degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                neighbor_colors[u].add(c)\n        return (normalize_palette(colors), (\"RECOLOR\", \"repair-init\"))\n\n    sol = solution[:]\n\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n\n    if conflicted and random.random() < 0.35:\n        # Kempe-chain swap around a conflicted vertex\n        v = random.choice(conflicted)\n        v1 = v + 1\n        # pick a conflicting neighbor to define two colors a,b\n        neigh_conf = [u for u in adj[v1] if sol[u-1] == sol[v]]\n        if not neigh_conf:\n            # fallback to recolor\n            pass\n        else:\n            u = random.choice(neigh_conf)\n            a = sol[v]\n            # choose a different color from neighbor palette or introduce new if palette small\n            palette = sorted(set(sol))\n            # prefer a neighbor's color different from a\n            neigh_cols = [sol[w-1] for w in adj[v1] if sol[w-1] != a]\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n            else:\n                b = (max(palette) + 1) if random.random() < 0.2 else random.choice(palette)\n                if b == a:\n                    b = max(palette) + 1\n            # BFS on Kempe component containing v in subgraph induced by colors {a,b}\n            comp = set()\n            dq = deque([v1])\n            allowed = {a, b}\n            while dq:\n                x = dq.popleft()\n                if x in comp:\n                    continue\n                if sol[x-1] not in allowed:\n                    continue\n                comp.add(x)\n                for y in adj[x]:\n                    if sol[y-1] in allowed and y not in comp:\n                        dq.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x-1] == a:\n                    new_sol[x-1] = b\n                elif new_sol[x-1] == b:\n                    new_sol[x-1] = a\n            new_sol = normalize_palette(new_sol)\n            return (new_sol, (\"KEMPE\", \"component-swap\"))\n\n    # Conflict-driven recolor\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vertex_conflicts(i, sol), len(adj[i+1])))\n    else:\n        v = random.randrange(n)\n    v1 = v + 1\n    curr_c = sol[v]\n    palette = set(sol)\n    max_c = max(palette) if palette else 1\n    # Candidate colors: all existing colors, plus maybe a new one\n    candidates = list(range(1, max_c + 1))\n    if random.random() < 0.1:\n        candidates.append(max_c + 1)\n    # Evaluate delta conflicts locally\n    best_c = curr_c\n    best_score = (10**9, 10**9)  # (after_conflicts, palette_growth)\n    for c in candidates:\n        if c == curr_c and random.random() < 0.5:\n            continue\n        before = 0\n        after = 0\n        for u in adj[v1]:\n            if sol[u-1] == curr_c:\n                before += 1\n            if sol[u-1] == c:\n                after += 1\n        palette_growth = 1 if c > max_c else 0\n        score = (after, palette_growth)\n        if score < best_score or (score == best_score and c < best_c):\n            best_score = score\n            best_c = c\n    new_sol = sol[:]\n    new_sol[v] = best_c\n    new_sol = normalize_palette(new_sol)\n    return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor multiple vertices (biased to conflicts)\n    using current palette with occasional expansion, followed by normalization.\n    Returns a valid list[int] of length 9.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Repair invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n\n    steps = max(3, n \/\/ 2)\n    palette = sorted(set(sol))\n    max_c = max(palette) if palette else 1\n\n    for _ in range(steps):\n        v = random.choice(pool)\n        v1 = v + 1\n        neigh_cols = {sol[u-1] for u in adj[v1]}\n        # Prefer lower colors not in neighbors\n        candidates = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n        if not candidates or random.random() < 0.2:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n        # Optionally do a quick local descent recolor to reduce immediate conflicts\n        if random.random() < 0.5:\n            neigh_cols2 = {sol[u-1] for u in adj[v1]}\n            best_c = sol[v]\n            best_conf = sum(1 for u in adj[v1] if sol[u-1] == best_c)\n            for c in range(1, max(sol)+1):\n                if c == sol[v]:\n                    continue\n                conf = sum(1 for u in adj[v1] if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            sol[v] = best_c\n\n    sol = normalize_palette(sol)\n    return sol\n","Version":2}
