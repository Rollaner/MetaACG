{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9: solution[i-1] = color of vertex i, with contiguous labels {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Objective = k + PEN_EDGE * (#edge conflicts).\n    # Representation: list of 9 positive ints; ci is color of vertex i (1-indexed vertices).\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**4\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Base objective (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if cu == cv:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, movement_type)\n    # Neighborhood includes: conflict-driven recolor, color-swap, and Kempe-chain swap.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def neighbors_of(i):\n        # 0-indexed\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def recolor_move(sol):\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Pick vertex: highest conflict count (ties random); if none, pick random\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        palette = list(range(1, k+1))\n        # Allow k+1 only if conflicts>0 and with small probability\n        if total > 0 and random.random() < 0.05:\n            palette.append(k+1)\n        # Choose color minimizing local conflicts\n        best_colors = []\n        best_val = None\n        for col in palette:\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n        s = normalize_labels(s)\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol):\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            return s, \"NOOP\"\n        a, b = random.sample(range(1, k+1), 2)\n        s = [b if c == a else a if c == b else c for c in s]\n        s = normalize_labels(s)\n        return s, \"SWAP_TWO_COLORS\"\n\n    def kempe_chain_move(sol):\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return s, \"NOOP\"\n        # Prefer a conflicting vertex if exists\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(candidates)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        # pick a different color b\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return s, \"NOOP\"\n        b = random.choice(choices)\n        # Build subgraph induced by colors {a,b} and find component containing u\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] in allowed:\n                comp.append(x)\n                for (p,q) in edges:\n                    y = q-1 if p-1 == x else p-1 if q-1 == x else None\n                    if y is None:\n                        continue\n                    if not visited[y] and s[y] in allowed:\n                        visited[y] = True\n                        dq.append(y)\n        # Swap colors a<->b within comp\n        for idx in comp:\n            s[idx] = b if s[idx] == a else a\n        s = normalize_labels(s)\n        return s, \"KEMPE_CHAIN_SWAP\"\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"INVALID_INPUT\")\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return (solution, \"INVALID_INPUT\")\n    except Exception:\n        return (solution, \"INVALID_INPUT\")\n\n    # Decide move type based on conflicts\n    _, tot = conflicts_by_vertex(solution)\n    r = random.random()\n    if tot == 0:\n        # When feasible, avoid increasing palette; prefer neutral diversification\n        if r < 0.6:\n            return swap_two_colors(solution)\n        elif r < 0.9:\n            return kempe_chain_move(solution)\n        else:\n            return recolor_move(solution)\n    else:\n        # When infeasible, prioritize conflict resolution\n        if r < 0.65:\n            return recolor_move(solution)\n        elif r < 0.85:\n            return kempe_chain_move(solution)\n        else:\n            return swap_two_colors(solution)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: (a) if feasible, attempt merge-two-colors then greedy repair; (b) else, multi-kick recolors of top-conflict vertices; normalize at end.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def greedy_repair(sol, max_iters=60):\n        s = list(sol)\n        k = compute_k(s)\n        for _ in range(max_iters):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            # pick a vertex involved in conflict\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            i = random.choice(conflicted)\n            # choose best color in current palette 1..k\n            best_colors = []\n            best_val = None\n            for col in range(1, k+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        s = normalize_labels(s)\n        return s\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    try:\n        for x in solution:\n            if int(x) != x or x < 1:\n                return solution\n    except Exception:\n        return solution\n\n    s = normalize_labels(list(solution))\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt to reduce palette via merging two colors, then repair\n        a, b = random.sample(range(1, k+1), 2)\n        # Merge b into a\n        s = [a if c == b else c for c in s]\n        s = normalize_labels(s)\n        s = greedy_repair(s, max_iters=100)\n        return s\n\n    # Otherwise, perform multi-kick recolors focusing on high-conflict vertices\n    steps = 5\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        # choose a color that minimizes local conflicts within current k (do not add new color here)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, k+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = normalize_labels(s)\n    s = greedy_repair(s, max_iters=60)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9 where solution[i-1] is the color (positive int) assigned to vertex i; labels normalized to contiguous {1,...,k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Objective = k + PEN_EDGE * (#edge conflicts).\n    # Representation: list of 9 positive ints; ci is color of vertex i (1-indexed vertices).\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**9\n    PEN_EDGE = 10**5\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    # Value checks and normalization to contiguous labels\n    try:\n        s = [int(x) for x in solution]\n        if any(x < 1 for x in s):\n            return float(HARD_PEN)\n    except Exception:\n        return float(HARD_PEN)\n\n    # Normalize labels to enforce contiguity {1..k}\n    mapping = {}\n    nxt = 1\n    sn = []\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sn.append(mapping[c])\n\n    # Base objective (k)\n    k = 0\n    for x in sn:\n        if x > k:\n            k = x\n    if k == 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sn[u-1] == sn[v-1]:\n            conflicts += 1\n\n    fitness = float(k) + PEN_EDGE * float(conflicts)\n    return float(fitness)\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns: (new_solution_list, movement_type_str)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def recolor_move(sol):\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Pick vertex: highest conflict count (ties random); if none, pick random\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(candidates)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        palette = list(range(1, k+1))\n        # Choose color minimizing local conflicts; allow k+1 only if infeasible and no feasible color exists\n        best_colors = []\n        best_val = None\n        for col in palette:\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if total > 0 and (not best_colors or best_val > 0):\n            # Consider introducing k+1 only if all current colors cause conflicts\n            # and we are in an infeasible state\n            new_col = k + 1\n            best_colors.append(new_col)\n        # pick one different color for sure\n        if best_colors:\n            # Avoid no-op\n            choices = [c for c in best_colors if c != s[i]]\n            if not choices:\n                # fallback: force a different color within 1..max(k,2)\n                choices = list(range(1, max(2, k+1)))\n                choices = [c for c in choices if c != s[i]]\n            s[i] = random.choice(choices)\n        s = normalize_labels(s)\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol):\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            # fallback to recolor\n            return recolor_move(s)\n        # retry to ensure change\n        for _ in range(5):\n            a, b = random.sample(range(1, k+1), 2)\n            if a == b:\n                continue\n            t = [b if c == a else a if c == b else c for c in s]\n            if t != s:\n                s = normalize_labels(t)\n                return s, \"SWAP_TWO_COLORS\"\n        # fallback\n        return recolor_move(s)\n\n    def kempe_chain_move(sol):\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            candidates = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(candidates)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return recolor_move(s)\n        b = random.choice(choices)\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] not in allowed:\n                continue\n            comp.append(x)\n            # enqueue neighbors having allowed colors only\n            for (p,q) in edges:\n                if p-1 == x:\n                    y = q-1\n                elif q-1 == x:\n                    y = p-1\n                else:\n                    continue\n                if not visited[y] and s[y] in allowed:\n                    visited[y] = True\n                    dq.append(y)\n        t = list(s)\n        for idx in comp:\n            t[idx] = b if t[idx] == a else a\n        t = normalize_labels(t)\n        if t != s:\n            return t, \"KEMPE_CHAIN_SWAP\"\n        # fallback\n        return recolor_move(s)\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (list(solution), \"INVALID_INPUT\")\n    try:\n        s0 = [int(x) for x in solution]\n        if any(x < 1 for x in s0):\n            return (s0, \"INVALID_INPUT\")\n    except Exception:\n        return (list(solution), \"INVALID_INPUT\")\n\n    s0 = normalize_labels(s0)\n    # Decide move type based on conflicts with guaranteed change\n    _, tot = conflicts_by_vertex(s0)\n    r = random.random()\n    if tot == 0:\n        if r < 0.55:\n            return kempe_chain_move(s0)\n        elif r < 0.85:\n            return swap_two_colors(s0)\n        else:\n            return recolor_move(s0)\n    else:\n        if r < 0.7:\n            return recolor_move(s0)\n        elif r < 0.9:\n            return kempe_chain_move(s0)\n        else:\n            return swap_two_colors(s0)\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Strong perturbation with color merge when feasible and conflict-driven repair\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def normalize_labels(sol):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def compute_k(sol):\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def neighbors_of(i):\n        res = []\n        for (u,v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def conflicts_by_vertex(sol):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def greedy_repair(sol, max_iters=100):\n        s = list(sol)\n        k = compute_k(s)\n        for _ in range(max_iters):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            i = random.choice(conflicted)\n            # choose best color in 1..k\n            best_colors = []\n            best_val = None\n            for col in range(1, k+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        return normalize_labels(s)\n\n    # Validate and normalize\n    if not isinstance(solution, list) or len(solution) != 9:\n        return list(solution)\n    try:\n        s = [int(x) for x in solution]\n        if any(x < 1 for x in s):\n            return list(solution)\n    except Exception:\n        return list(solution)\n\n    s = normalize_labels(s)\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt merge of two colors followed by greedy repair\n        a, b = random.sample(range(1, k+1), 2)\n        s = [a if c == b else c for c in s]\n        s = normalize_labels(s)\n        s = greedy_repair(s, max_iters=150)\n        return s\n\n    # Otherwise, multi-kick recolors of high-conflict vertices\n    steps = 6\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, k+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = normalize_labels(s)\n    s = greedy_repair(s, max_iters=120)\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"List[int] of length 9. solution[i-1] is the positive integer color assigned to vertex i (1-indexed). Labels may be non-contiguous during search; evaluator normalizes to contiguous {1..k}.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Graph and penalties embedded locally (no globals per constraints)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    HARD_PEN = 10**12\n    PEN_EDGE = 10**6\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return int(HARD_PEN)\n    if len(solution) != 9:\n        return int(HARD_PEN)\n\n    # Ensure all entries are integers >=1; reject non-integers\n    s = []\n    for x in solution:\n        if not isinstance(x, int):\n            return int(HARD_PEN)\n        if x < 1:\n            return int(HARD_PEN)\n        s.append(x)\n\n    # Normalize labels to contiguous {1..k}\n    mapping = {}\n    nxt = 1\n    sn = []\n    for c in s:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n        sn.append(mapping[c])\n\n    # Compute k (max label after normalization)\n    k = 0\n    for x in sn:\n        if x > k:\n            k = x\n    if k == 0:\n        return int(HARD_PEN)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if sn[u-1] == sn[v-1]:\n            conflicts += 1\n\n    # Objective: minimize k; conflicts heavily penalized\n    fitness = k + PEN_EDGE * conflicts\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> tuple:\n    # Returns: (new_solution_list, move_type_str). Guarantees a changed solution when input is valid.\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def neighbors_of(i: int) -> List[int]:\n        res = []\n        for (u, v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def compute_k(sol: List[int]) -> int:\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol: List[int]):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    # Validate input; if invalid, create a trivial changed solution\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback: generate a simple 2-color alternating pattern to ensure change\n        base = [1 if i % 2 == 0 else 2 for i in range(9)]\n        return (base, \"FALLBACK_INIT\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            base = [1 if i % 2 == 0 else 2 for i in range(9)]\n            return (base, \"FALLBACK_INIT\")\n\n    s0 = list(solution)\n\n    def recolor_move(sol: List[int]) -> Tuple[List[int], str]:\n        s = list(sol)\n        cnt, total = conflicts_by_vertex(s)\n        n = len(s)\n        # Choose vertex: prefer highest conflicts; break ties randomly\n        if total > 0:\n            maxc = max(cnt)\n            cand = [i for i in range(n) if cnt[i] == maxc]\n            i = random.choice(cand)\n        else:\n            i = random.randrange(n)\n        k = compute_k(s)\n        # Evaluate colors 1..max(k, 2) to diversify; avoid no-op\n        palette = list(range(1, max(k, 2)+1))\n        if s[i] in palette and len(palette) > 1:\n            palette.remove(s[i])\n        best_colors = []\n        best_val = None\n        for col in palette:\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n        else:\n            s[i] = (s[i] % max(2, k)) + 1\n        return s, \"RECOLOR_ONE\"\n\n    def swap_two_colors(sol: List[int]) -> Tuple[List[int], str]:\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        for _ in range(5):\n            a, b = random.sample(range(1, k+1), 2)\n            if a == b:\n                continue\n            t = [b if c == a else a if c == b else c for c in s]\n            if t != s:\n                return t, \"SWAP_TWO_COLORS\"\n        return recolor_move(s)\n\n    def kempe_chain_move(sol: List[int]) -> Tuple[List[int], str]:\n        s = list(sol)\n        n = len(s)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        cnt, total = conflicts_by_vertex(s)\n        if total > 0:\n            maxc = max(cnt)\n            cand = [i for i in range(n) if cnt[i] == maxc]\n            u = random.choice(cand)\n        else:\n            u = random.randrange(n)\n        a = s[u]\n        choices = [col for col in range(1, k+1) if col != a]\n        if not choices:\n            return recolor_move(s)\n        b = random.choice(choices)\n        allowed = {a, b}\n        visited = [False]*n\n        comp = []\n        dq = deque([u])\n        visited[u] = True\n        while dq:\n            x = dq.popleft()\n            if s[x] not in allowed:\n                continue\n            comp.append(x)\n            for (p, q) in edges:\n                if p-1 == x:\n                    y = q-1\n                elif q-1 == x:\n                    y = p-1\n                else:\n                    continue\n                if not visited[y] and s[y] in allowed:\n                    visited[y] = True\n                    dq.append(y)\n        t = list(s)\n        for idx in comp:\n            t[idx] = b if t[idx] == a else a\n        if t != s:\n            return t, \"KEMPE_CHAIN_SWAP\"\n        return recolor_move(s)\n\n    def drop_color_move(sol: List[int]) -> Tuple[List[int], str]:\n        # Try to eliminate the smallest color class by greedy recoloring\n        s = list(sol)\n        k = compute_k(s)\n        if k < 2:\n            return recolor_move(s)\n        # Count class sizes\n        sizes = {c: 0 for c in range(1, k+1)}\n        for c in s:\n            if c in sizes:\n                sizes[c] += 1\n        target = min(sizes, key=lambda c: sizes[c])\n        verts = [i for i, c in enumerate(s) if c == target]\n        palette = [c for c in range(1, k+1) if c != target]\n        random.shuffle(verts)\n        success = True\n        for i in verts:\n            # choose color minimizing local conflicts\n            best_colors = []\n            best_val = None\n            for col in palette:\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if not best_colors:\n                success = False\n                break\n            s[i] = random.choice(best_colors)\n        if success:\n            # Do not renormalize here; evaluator will compact labels.\n            # But replace any remaining 'target' color if any remained (safety)\n            s = [c if c != target else ((c % (k-1)) + 1) for c in s]\n            return s, \"DROP_COLOR\"\n        else:\n            return recolor_move(sol)\n\n    # Decide move based on conflict status\n    _, tot = conflicts_by_vertex(s0)\n    r = random.random()\n    if tot == 0:\n        if r < 0.45:\n            return drop_color_move(s0)\n        elif r < 0.8:\n            return kempe_chain_move(s0)\n        elif r < 0.95:\n            return swap_two_colors(s0)\n        else:\n            return recolor_move(s0)\n    else:\n        if r < 0.6:\n            return recolor_move(s0)\n        elif r < 0.85:\n            return kempe_chain_move(s0)\n        else:\n            return swap_two_colors(s0)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Strong perturbation: try color merge if feasible; otherwise conflict-driven multi-recolor + brief repair\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def neighbors_of(i: int):\n        res = []\n        for (u, v) in edges:\n            if u-1 == i:\n                res.append(v-1)\n            elif v-1 == i:\n                res.append(u-1)\n        return res\n\n    def compute_k(sol: List[int]) -> int:\n        m = 0\n        for x in sol:\n            if x > m:\n                m = x\n        return m\n\n    def conflicts_by_vertex(sol: List[int]):\n        n = len(sol)\n        cnt = [0]*n\n        total = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt[u-1] += 1\n                cnt[v-1] += 1\n                total += 1\n        return cnt, total\n\n    def greedy_repair(sol: List[int], steps: int = 150) -> List[int]:\n        s = list(sol)\n        for _ in range(steps):\n            cnt, total = conflicts_by_vertex(s)\n            if total == 0:\n                break\n            conflicted = [i for i in range(len(s)) if cnt[i] > 0]\n            if not conflicted:\n                break\n            i = random.choice(conflicted)\n            k = compute_k(s)\n            best_colors = []\n            best_val = None\n            for col in range(1, max(2, k)+1):\n                if col == s[i]:\n                    continue\n                loc = 0\n                for j in neighbors_of(i):\n                    if s[j] == col:\n                        loc += 1\n                if best_val is None or loc < best_val:\n                    best_val = loc\n                    best_colors = [col]\n                elif loc == best_val:\n                    best_colors.append(col)\n            if best_colors:\n                s[i] = random.choice(best_colors)\n        return s\n\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Fallback randomized 3-color init\n        return [random.randint(1, 3) for _ in range(9)]\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return [random.randint(1, 3) for _ in range(9)]\n\n    s = list(solution)\n    k = compute_k(s)\n    _, total_conf = conflicts_by_vertex(s)\n\n    if total_conf == 0 and k >= 2:\n        # Attempt merge of two random colors, then repair\n        if k == 2:\n            a, b = 1, 2\n        else:\n            a, b = random.sample(range(1, k+1), 2)\n        s = [a if c == b else c for c in s]\n        s = greedy_repair(s, steps=200)\n        return s\n\n    # Otherwise, kick multiple high-conflict vertices then repair\n    steps = 6\n    for _ in range(steps):\n        cnt, total_conf = conflicts_by_vertex(s)\n        if total_conf == 0:\n            break\n        maxc = max(cnt)\n        cand = [i for i in range(len(s)) if cnt[i] == maxc]\n        i = random.choice(cand)\n        k = compute_k(s)\n        best_colors = []\n        best_val = None\n        for col in range(1, max(2, k)+1):\n            if col == s[i]:\n                continue\n            loc = 0\n            for j in neighbors_of(i):\n                if s[j] == col:\n                    loc += 1\n            if best_val is None or loc < best_val:\n                best_val = loc\n                best_colors = [col]\n            elif loc == best_val:\n                best_colors.append(col)\n        if best_colors:\n            s[i] = random.choice(best_colors)\n    s = greedy_repair(s, steps=180)\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Number of used groups (colors)\n    num_groups = len(set(solution))\n\n    # Heavy penalty for conflicts; lower is better\n    # Add tiny tie-breaker to slightly prefer lower max color label after compaction\n    max_label = max(solution)\n    return num_groups + conflicts * 1_000_000 + max_label * 1e-9\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"NoMove\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"NoMove\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Identify conflicts\n    conflicts = set()\n    for u, v in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    # DSATUR-like target selection: maximize number of distinct neighbor colors (prioritize conflicted)\n    candidates = list(conflicts) if conflicts else list(range(1, 10))\n    best_set = -1\n    target = random.choice(candidates)\n    for i in candidates:\n        neigh_colors = {new_sol[j-1] for j in adj[i]}\n        val = (len(neigh_colors), sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1]))\n        if val > (best_set, -1):\n            best_set = val[0]\n            target = i\n\n    palette = sorted(set(new_sol))\n    max_color = max(palette)\n\n    # Try improved move-set:\n    # 1) Attempt greedy recolor avoiding neighbor colors using existing palette only\n    neighbor_colors = {new_sol[j-1] for j in adj[target]}\n    feasible = [c for c in palette if c not in neighbor_colors]\n    move_type = (\"NB_Recolor\", \"One-Vertex\")\n\n    if feasible:\n        new_color = random.choice(feasible)\n        if new_color != new_sol[target-1]:\n            new_sol[target-1] = new_color\n            new_sol = compact_colors(new_sol)\n            return (new_sol, move_type)\n\n    # 2) Kempe chain swap between current color a and random color b from palette\n    a = new_sol[target-1]\n    b_choices = [c for c in palette if c != a]\n    if b_choices:\n        b = random.choice(b_choices)\n        # Build Kempe chain containing target with colors {a,b}\n        stack = [target]\n        visited = set([target])\n        chain = set([target])\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (a, b):\n                    visited.add(v)\n                    stack.append(v)\n                    chain.add(v)\n        # Swap colors a<->b on chain\n        for v in chain:\n            c = new_sol[v-1]\n            new_sol[v-1] = a if c == b else (b if c == a else c)\n        new_sol = compact_colors(new_sol)\n        return (new_sol, (\"NB_KempeSwap\", \"Two-Color-Chain\"))\n\n    # 3) As last resort, allow introducing a new color (rare)\n    if random.random() < 0.1:\n        new_sol[target-1] = max_color + 1\n        new_sol = compact_colors(new_sol)\n        return (new_sol, (\"NB_Recolor\", \"NewColor\"))\n\n    # No change possible (should be rare)\n    return (solution[:], (\"NB_NoOp\", \"Stall\"))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return it unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Strategy: perform r randomized moves mixing recolors and Kempe swaps\n    r = random.randint(2, 4)\n    for _ in range(r):\n        target = random.randint(1, 9)\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        neighbor_colors = {new_sol[j-1] for j in adj[target]}\n        feasible = [c for c in palette if c not in neighbor_colors]\n        move_roll = random.random()\n        if feasible and move_roll < 0.5:\n            # Greedy recolor to feasible color\n            new_color = random.choice(feasible)\n            new_sol[target-1] = new_color\n        elif len(palette) >= 2 and move_roll < 0.9:\n            # Kempe chain swap between two random colors\n            a = new_sol[target-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                stack = [target]\n                visited = set([target])\n                chain = set([target])\n                while stack:\n                    u = stack.pop()\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (a, b):\n                            visited.add(v)\n                            stack.append(v)\n                            chain.add(v)\n                for v in chain:\n                    c = new_sol[v-1]\n                    new_sol[v-1] = a if c == b else (b if c == a else c)\n        else:\n            # Introduce or attempt to remove a color via recolor\n            if random.random() < 0.5:\n                new_sol[target-1] = max_color + 1\n            else:\n                # Try recolor target to the smallest feasible color\n                for c in range(1, max_color + 1):\n                    if c not in neighbor_colors:\n                        new_sol[target-1] = c\n                        break\n        # Compact after each micro-perturb to stabilize labels\n        new_sol = compact_colors(new_sol)\n\n    return new_sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Compact labels to ensure label-invariant evaluation\n    relabel = {}\n    next_label = 1\n    compacted = solution[:]\n    for i in range(len(compacted)):\n        c = compacted[i]\n        if c not in relabel:\n            relabel[c] = next_label\n            next_label += 1\n        compacted[i] = relabel[c]\n\n    # Number of used groups (colors)\n    num_groups = len(relabel)\n\n    # Heavy penalty for conflicts; lower is better\n    return num_groups + conflicts * 1_000_000","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"NoMove\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"NoMove\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    new_sol = solution[:]\n\n    # Identify conflicts\n    conflicts_vertices = set()\n    for u, v in edges:\n        if new_sol[u-1] == new_sol[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n\n    palette = sorted(set(new_sol))\n    max_color = max(palette)\n\n    # Helper: attempt recolor of a single vertex to minimize conflicts using existing palette\n    def min_conflict_recolor(sol, v):\n        current = sol[v-1]\n        neigh_colors = {sol[j-1] for j in adj[v]}\n        best_c = current\n        best_conf = math.inf\n        for c in palette:\n            if c == current:\n                # evaluate keeping color too\n                pass\n            # compute local conflicts at v\n            local_conf = 0\n            for u in adj[v]:\n                if (c == sol[u-1]) and u != v:\n                    local_conf += 1\n            if local_conf < best_conf:\n                best_conf = local_conf\n                best_c = c\n                if best_conf == 0:\n                    break\n        if best_c != current:\n            sol[v-1] = best_c\n        return sol\n\n    # If there are conflicts, prioritize conflicted vertices\n    if conflicts_vertices:\n        # DSATUR-like selection with correct tie handling\n        target = None\n        best_key = (-1, -1)\n        for i in conflicts_vertices:\n            neigh_colors = {new_sol[j-1] for j in adj[i]}\n            local_conf = sum(1 for j in adj[i] if new_sol[j-1] == new_sol[i-1])\n            key = (len(neigh_colors), local_conf)\n            if key > best_key:\n                best_key = key\n                target = i\n        # Try min-conflict recolor within existing palette first\n        trial = new_sol[:]\n        trial = min_conflict_recolor(trial, target)\n        if trial != new_sol:\n            return (compact_colors(trial), (\"NB_Recolor\", \"Min-Conflict\"))\n        # Kempe chain swap between two colors a and b to break conflicts\n        a = new_sol[target-1]\n        b_choices = [c for c in palette if c != a]\n        if b_choices:\n            # bias b towards most frequent neighbor color\n            neighbor_colors = [new_sol[j-1] for j in adj[target]]\n            freq = {}\n            for c in neighbor_colors:\n                freq[c] = freq.get(c, 0) + 1\n            b_choices.sort(key=lambda c: freq.get(c, 0), reverse=True)\n            b = b_choices[0]\n            stack = [target]\n            visited = {target}\n            chain = {target}\n            while stack:\n                u = stack.pop()\n                for v in adj[u]:\n                    if v not in visited and new_sol[v-1] in (a, b):\n                        visited.add(v)\n                        stack.append(v)\n                        chain.add(v)\n            swapped = new_sol[:]\n            for v in chain:\n                c = swapped[v-1]\n                swapped[v-1] = a if c == b else (b if c == a else c)\n            return (compact_colors(swapped), (\"NB_KempeSwap\", \"Two-Color-Chain\"))\n        # As a last resort, introduce a new color with small probability\n        if random.random() < 0.1:\n            trial = new_sol[:]\n            trial[target-1] = max_color + 1\n            return (compact_colors(trial), (\"NB_Recolor\", \"NewColor\"))\n        return (new_sol[:], (\"NB_NoOp\", \"Stall\"))\n\n    # No conflicts: attempt explicit color elimination\n    # Select the smallest color class\n    color_to_vertices = {}\n    for i, c in enumerate(new_sol, start=1):\n        color_to_vertices.setdefault(c, []).append(i)\n    smallest_color = min(color_to_vertices.keys(), key=lambda c: len(color_to_vertices[c]))\n\n    # Try to recolor all vertices of this class into existing palette without introducing a new color\n    target_vertices = color_to_vertices[smallest_color][:]\n    trial = new_sol[:]\n    success = True\n    # order by decreasing degree to be safer\n    target_vertices.sort(key=lambda v: len(adj[v]), reverse=True)\n    for v in target_vertices:\n        current = trial[v-1]\n        neigh_colors = {trial[j-1] for j in adj[v]}\n        feasible = [c for c in palette if c != current and c not in neigh_colors]\n        if not feasible:\n            success = False\n            break\n        # choose the color minimizing new potential conflicts (here zero by feasibility)\n        trial[v-1] = feasible[0]\n    if success:\n        return (compact_colors(trial), (\"ColorElim\", \"GreedyRecolorClass\"))\n\n    # If elimination failed, attempt a Kempe swap focused on freeing the smallest color\n    anchor = random.choice(target_vertices)\n    a = new_sol[anchor-1]\n    other_colors = [c for c in palette if c != a]\n    if other_colors:\n        # choose b maximizing adjacency interference with a\n        def interference(b):\n            count = 0\n            for u in color_to_vertices.get(a, []):\n                for w in adj[u]:\n                    if new_sol[w-1] == b:\n                        count += 1\n            return count\n        b = max(other_colors, key=interference)\n        stack = [anchor]\n        visited = {anchor}\n        chain = {anchor}\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in visited and new_sol[v-1] in (a, b):\n                    visited.add(v)\n                    stack.append(v)\n                    chain.add(v)\n        swapped = new_sol[:]\n        for v in chain:\n            c = swapped[v-1]\n            swapped[v-1] = a if c == b else (b if c == a else c)\n        return (compact_colors(swapped), (\"NB_KempeSwap\", \"ClassFocused\"))\n\n    # Fallback: swap colors of two non-adjacent vertices to diversify\n    v1 = random.randint(1, 9)\n    non_adj = [i for i in range(1, 10) if i != v1 and i not in adj[v1]]\n    if non_adj:\n        v2 = random.choice(non_adj)\n        trial = new_sol[:]\n        trial[v1-1], trial[v2-1] = trial[v2-1], trial[v1-1]\n        return (compact_colors(trial), (\"PairSwap\", \"VertexSwap\"))\n\n    return (new_sol[:], (\"NB_NoOp\", \"Stall\"))","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return it unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_colors(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    new_sol = solution[:]\n\n    # Perform r randomized macro-moves mixing recolors and Kempe swaps\n    r = random.randint(2, 4)\n    for _ in range(r):\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        target = random.randint(1, 9)\n        neighbor_colors = {new_sol[j-1] for j in adj[target]}\n        move_roll = random.random()\n        if move_roll < 0.45:\n            # Greedy feasible recolor if possible\n            feasible = [c for c in palette if c not in neighbor_colors]\n            if feasible:\n                new_sol[target-1] = random.choice(feasible)\n        elif move_roll < 0.9 and len(palette) >= 2:\n            # Kempe chain swap between two random colors containing target\n            a = new_sol[target-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                stack = [target]\n                visited = {target}\n                chain = {target}\n                while stack:\n                    u = stack.pop()\n                    for v in adj[u]:\n                        if v not in visited and new_sol[v-1] in (a, b):\n                            visited.add(v)\n                            stack.append(v)\n                            chain.add(v)\n                for v in chain:\n                    c = new_sol[v-1]\n                    new_sol[v-1] = a if c == b else (b if c == a else c)\n        else:\n            # Introduce or attempt to collapse colors\n            if random.random() < 0.5:\n                new_sol[target-1] = max_color + 1\n            else:\n                # Try recoloring to smallest feasible color\n                for c in range(1, max_color + 1):\n                    if c not in neighbor_colors:\n                        new_sol[target-1] = c\n                        break\n        new_sol = compact_colors(new_sol)\n\n    return new_sol","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    LARGE = 10**12\n    # Validate type\/shape\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Compact labels to 1..k to keep evaluation invariant to relabeling\n    relabel = {}\n    next_label = 1\n    for i in range(len(solution)):\n        c = solution[i]\n        if c not in relabel:\n            relabel[c] = next_label\n            next_label += 1\n    k = len(relabel)\n\n    # Lexicographic objective: minimize conflicts first, then number of groups\n    # Lower is better\n    return conflicts * 1_000_000 + k\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, (\"NB_Invalid\", \"Shape\"))\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return (solution, (\"NB_Invalid\", \"Value\"))\n\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    degree = {i: len(adj[i]) for i in range(1, 10)}\n\n    def compact(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    cur = solution[:]\n\n    # Helper: pick conflicted vertex with tie-breaking (sat_deg, deg, local_conf)\n    def select_conflicted_vertex(sol):\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if not conflicts_vertices:\n            return None\n        best = None\n        best_key = (-1, -1, math.inf)\n        for i in conflicts_vertices:\n            neigh_colors = {sol[j-1] for j in adj[i]}\n            local_conf = sum(1 for j in adj[i] if sol[j-1] == sol[i-1])\n            key = (len(neigh_colors), degree[i], -local_conf)\n            if key > best_key:\n                best_key = key\n                best = i\n        return best\n\n    # Attempt recolor of vertex to reduce conflicts\n    def min_conflict_recolor(sol, v):\n        palette = sorted(set(sol))\n        current = sol[v-1]\n        best_c = current\n        best_local = math.inf\n        for c in palette:\n            local = 0\n            for u in adj[v]:\n                if c == sol[u-1]:\n                    local += 1\n            if local < best_local or (local == best_local and c < best_c):\n                best_local = local\n                best_c = c\n        if best_c != current:\n            sol[v-1] = best_c\n        return sol\n\n    # Kempe chain swap between colors a and b wrt anchor vertex v\n    def kempe_swap(sol, v, a, b):\n        stack = [v]\n        visited = {v}\n        chain = {v}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in visited and sol[w-1] in (a, b):\n                    visited.add(w)\n                    stack.append(w)\n                    chain.add(w)\n        out = sol[:]\n        for w in chain:\n            cw = out[w-1]\n            out[w-1] = a if cw == b else (b if cw == a else cw)\n        return out\n\n    K = 6  # retry budget to avoid NoOp\n    start_conf = count_conflicts(cur)\n\n    for _ in range(K):\n        palette = sorted(set(cur))\n        max_color = max(palette)\n        v = select_conflicted_vertex(cur)\n        if v is not None:\n            # 1) Min-conflict recolor within palette\n            trial = min_conflict_recolor(cur[:], v)\n            if trial != cur:\n                return (compact(trial), (\"NB_Recolor\", \"MinConflict\"))\n            # 2) Kempe swap with most frequent neighbor color\n            neigh_cols = [cur[u-1] for u in adj[v]]\n            if neigh_cols:\n                freq = {}\n                for c in neigh_cols:\n                    freq[c] = freq.get(c, 0) + 1\n                b = max(freq.keys(), key=lambda c: freq[c])\n                a = cur[v-1]\n                if b != a:\n                    swapped = kempe_swap(cur, v, a, b)\n                    if count_conflicts(swapped) <= start_conf:\n                        return (compact(swapped), (\"NB_KempeSwap\", \"ConflictNonWorsening\"))\n            # 3) Temporary new color for v (escape), then compact\n            temp = cur[:]\n            temp[v-1] = max_color + 1\n            return (compact(temp), (\"NB_Recolor\", \"NewColorEscape\"))\n        else:\n            # No conflicts: try to eliminate a color class\n            color_to_vertices = {}\n            for i, c in enumerate(cur, start=1):\n                color_to_vertices.setdefault(c, []).append(i)\n            # smallest class first\n            target_color = min(color_to_vertices.keys(), key=lambda c: len(color_to_vertices[c]))\n            vertices = sorted(color_to_vertices[target_color], key=lambda x: -degree[x])\n            trial = cur[:]\n            success = True\n            for u in vertices:\n                neigh_colors = {trial[w-1] for w in adj[u]}\n                # feasible colors excluding current target_color\n                feas = [c for c in palette if c != target_color and c not in neigh_colors]\n                if not feas:\n                    success = False\n                    break\n                # choose smallest color id (deterministic and compact)\n                trial[u-1] = min(feas)\n            if success:\n                return (compact(trial), (\"ColorElim\", \"GreedyMerge\"))\n            # If merge failed, do a diversification Kempe swap between two random colors\n            if len(palette) >= 2:\n                a = random.choice(palette)\n                b = random.choice([c for c in palette if c != a])\n                anchor = random.choice(color_to_vertices.get(a, [1]))\n                swapped = kempe_swap(cur, anchor, a, b)\n                if swapped != cur:\n                    return (compact(swapped), (\"NB_KempeSwap\", \"Diversify\"))\n            # Last resort: recolor random vertex to a feasible existing color\n            u = random.randint(1, 9)\n            neigh_colors = {cur[w-1] for w in adj[u]}\n            feas = [c for c in palette if c not in neigh_colors]\n            if feas:\n                trial = cur[:]\n                trial[u-1] = random.choice(feas)\n                if trial != cur:\n                    return (compact(trial), (\"NB_Recolor\", \"FeasibleRandom\"))\n            # Fallback color swap (global)\n            if len(palette) >= 2:\n                a, b = palette[0], palette[-1]\n                trial = [a if x == b else (b if x == a else x) for x in cur]\n                if trial != cur:\n                    return (compact(trial), (\"ColorSwap\", \"GlobalAB\"))\n\n    # If all else fails, return a deterministic no-op copy (should be rare)\n    return (cur[:], (\"NB_NoOp\", \"RetryBudgetExhausted\"))\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Validate input; if invalid, return unchanged\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return solution\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact(sol):\n        relabel = {}\n        next_label = 1\n        out = sol[:]\n        for i in range(len(out)):\n            c = out[i]\n            if c not in relabel:\n                relabel[c] = next_label\n                next_label += 1\n            out[i] = relabel[c]\n        return out\n\n    def kempe_swap(sol, v, a, b):\n        stack = [v]\n        visited = {v}\n        chain = {v}\n        while stack:\n            u = stack.pop()\n            for w in adj[u]:\n                if w not in visited and sol[w-1] in (a, b):\n                    visited.add(w)\n                    stack.append(w)\n                    chain.add(w)\n        out = sol[:]\n        for w in chain:\n            cw = out[w-1]\n            out[w-1] = a if cw == b else (b if cw == a else cw)\n        return out\n\n    new_sol = solution[:]\n\n    # Apply L randomized macro-moves\n    L = 3 + (sum(1 for _ in set(new_sol)) % 2)  # 3 or 4 steps depending on palette size parity\n    for _ in range(L):\n        palette = sorted(set(new_sol))\n        max_color = max(palette)\n        v = random.randint(1, 9)\n        roll = random.random()\n        if roll < 0.4:\n            # Greedy feasible recolor if possible\n            neigh_colors = {new_sol[w-1] for w in adj[v]}\n            feas = [c for c in palette if c not in neigh_colors]\n            if feas:\n                new_sol[v-1] = random.choice(feas)\n        elif roll < 0.85 and len(palette) >= 2:\n            # Kempe chain swap around v\n            a = new_sol[v-1]\n            b_choices = [c for c in palette if c != a]\n            if b_choices:\n                b = random.choice(b_choices)\n                new_sol = kempe_swap(new_sol, v, a, b)\n        else:\n            # Temporary new color or collapse to smallest available color\n            if random.random() < 0.5:\n                new_sol[v-1] = max_color + 1\n            else:\n                neigh_colors = {new_sol[w-1] for w in adj[v]}\n                for c in range(1, max_color + 1):\n                    if c not in neigh_colors:\n                        new_sol[v-1] = c\n                        break\n        new_sol = compact(new_sol)\n\n    return new_sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] of length 9; solution[i] is color (1-based) for vertex i+1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute score\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Adaptive penalty within reasonable scale for annealing\n    penalty_lambda = 500\n    return K + penalty_lambda * conflicts\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, NB_Type, Movement_Type)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Prepare working copy\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency and degree\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    degree = [len(adj[i]) for i in range(n)]\n    # Conflict counts and saturation degrees\n    conflict_count = [0] * n\n    neighbor_color_sets = []\n    for i in range(n):\n        ncols = set(sol[j] for j in adj[i])\n        neighbor_color_sets.append(ncols)\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n    K = max(sol)\n    # Select target vertex\n    if any(c > 0 for c in conflict_count):\n        # prioritize by conflicts, then degree, then saturation size\n        order = sorted(range(n), key=lambda i: (conflict_count[i], degree[i], len(neighbor_color_sets[i])), reverse=True)\n        idx = order[0]\n    else:\n        # No conflicts: try reduce K by modifying a vertex using color K, else random\n        max_color_vertices = [i for i, c in enumerate(sol) if c == K]\n        if max_color_vertices:\n            idx = random.choice(max_color_vertices)\n        else:\n            idx = random.randrange(n)\n    # Feasible colors: avoid neighbors' colors and current color\n    forbidden = neighbor_color_sets[idx]\n    current_color = sol[idx]\n    # When conflict-free, disallow increasing K in neighbor move\n    palette_max = K\n    candidates = [c for c in range(1, palette_max + 1) if c != current_color and c not in forbidden]\n    if not candidates:\n        # If no strictly feasible color, allow a random change within 1..K to diversify (may introduce conflicts)\n        alt = [c for c in range(1, palette_max + 1) if c != current_color]\n        if alt:\n            new_color = random.choice(alt)\n        else:\n            new_color = current_color\n    else:\n        new_color = random.choice(candidates)\n    new_sol = list(sol)\n    new_sol[idx] = new_color\n    return new_sol, \"Recolor\", (\"Conflict-Driven\" if conflict_count[idx] > 0 else \"K-Reduction-Biased\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution (Kempe chain swap or multi-vertex recolor targeting max color)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    K = max(sol)\n    mode = random.random()\n    if mode < 0.5 and K >= 2:\n        # Kempe-chain swap between two random used colors\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        # BFS within subgraph induced by colors {c1, c2}\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = [seed]\n        while q:\n            i = q.pop()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        # Swap colors on component\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    else:\n        # Multi-vertex recolor focusing on vertices with max color K\n        targets = [i for i, c in enumerate(sol) if c == K]\n        if not targets:\n            targets = random.sample(range(n), k=min(3, n))\n        m = min(len(targets), max(2, len(targets)\/\/2))\n        chosen = random.sample(targets, m)\n        for idx in chosen:\n            neighbor_colors = set(sol[j] for j in adj[idx])\n            choices = [c for c in range(1, K) if c not in neighbor_colors]\n            if not choices:\n                # fallback allow any color <= K (may introduce conflicts)\n                choices = [c for c in range(1, K+1) if c != sol[idx]]\n            if choices:\n                sol[idx] = random.choice(choices)\n        return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] length 9; solution[i] is color (1-based) for vertex i+1","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (embedded)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate solution\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    # Compute conflicts and K\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    K = max(solution)\n    # Lexicographic-like composite: conflicts dominate, then K\n    penalty_lambda = 1000\n    score = conflicts * penalty_lambda + K\n    return int(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, meta_dict)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Initialize\/validate solution\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    # Compute neighbor color sets and conflict counts\n    neighbor_colors = [set(sol[j] for j in adj[i]) for i in range(n)]\n    conflict_count = [0] * n\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        if sol[u0] == sol[v0]:\n            conflict_count[u0] += 1\n            conflict_count[v0] += 1\n    K = max(sol) if sol else 1\n    # DSATUR-like priority with conflict emphasis\n    saturation = [len(neighbor_colors[i]) for i in range(n)]\n    degree = [len(adj[i]) for i in range(n)]\n    order = list(range(n))\n    order.sort(key=lambda i: (conflict_count[i] > 0, conflict_count[i], saturation[i], degree[i]), reverse=True)\n    # Try up to 3 candidate vertices to avoid no-move cases\n    chosen_idx = None\n    new_color = None\n    move_type = \"recolor\"\n    for idx in order[:3]:\n        forbid = neighbor_colors[idx]\n        cur = sol[idx]\n        # Allow K+1 with small probability when conflicts exist\n        allow_expand = (any(c > 0 for c in conflict_count) and random.random() < 0.1)\n        palette_max = K + (1 if allow_expand else 0)\n        candidates = [c for c in range(1, palette_max + 1) if c != cur and c not in forbid]\n        if candidates:\n            chosen_idx = idx\n            new_color = random.choice(candidates)\n            break\n    if chosen_idx is None:\n        # Fallback: random vertex recolor within 1..max(K,2)\n        idx = random.randrange(n)\n        palette_max = max(K, 2)\n        alt = [c for c in range(1, palette_max + 1) if c != sol[idx]]\n        if alt:\n            chosen_idx = idx\n            new_color = random.choice(alt)\n        else:\n            return sol, {\"move\": \"noop\"}\n    new_sol = list(sol)\n    new_sol[chosen_idx] = new_color\n    meta = {\"move\": move_type, \"idx\": chosen_idx, \"from\": sol[chosen_idx], \"to\": new_color}\n    return new_sol, meta\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Kempe-chain swap or multi-vertex recolor focusing on max color\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u0, v0 = u - 1, v - 1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n    K = max(sol) if sol else 1\n    if random.random() < 0.5 and K >= 2:\n        # Kempe-chain swap between two used colors\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        # pick seed among vertices with color c1 or c2\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = deque([seed])\n        while q:\n            i = q.popleft()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    else:\n        # Recolor a subset of vertices with max color K or incident to conflicts\n        conflict = [0] * n\n        for (u, v) in E:\n            u0, v0 = u - 1, v - 1\n            if sol[u0] == sol[v0]:\n                conflict[u0] += 1\n                conflict[v0] += 1\n        targets = [i for i, c in enumerate(sol) if c == K]\n        if not targets:\n            targets = [i for i, cc in enumerate(conflict) if cc > 0]\n        if not targets:\n            targets = list(range(n))\n        k = max(2, min(4, len(targets)))\n        chosen = random.sample(targets, min(k, len(targets)))\n        for idx in chosen:\n            neigh_cols = set(sol[j] for j in adj[idx])\n            choices = [c for c in range(1, max(2, K) + 1) if c != sol[idx] and c not in neigh_cols]\n            if not choices:\n                # Allow temporary K+1 to diversify\n                choices = [c for c in range(1, K + 2) if c != sol[idx]]\n            sol[idx] = random.choice(choices)\n        return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"list[int] length 9; solution[i] is color (1-based) for vertex i+1","Evaluacion":"import random\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate solution\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(c, int) and c >= 1 for c in solution)):\n        return 10**9\n    # Compute conflicts and K\n    conflicts = sum(1 for (u, v) in E if solution[u-1] == solution[v-1])\n    K = max(solution)\n    # Lexicographic dominance via large scalarization (conflicts dominate, then K)\n    return conflicts * 10**9 + K\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    sol = list(solution) if isinstance(solution, list) and len(solution) == n else [random.randint(1, 3) for _ in range(n)]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v); adj[v].append(u)\n    K = max(sol)\n    # Compute conflicts\n    conflict = [0] * n\n    for (u, v) in E:\n        u -= 1; v -= 1\n        if sol[u] == sol[v]:\n            conflict[u] += 1; conflict[v] += 1\n    total_conflicts = sum(conflict) \/\/ 2\n    # If conflict-free, attempt K reduction by recoloring a K-colored vertex to [1..K-1]\n    if total_conflicts == 0:\n        ks = [i for i, c in enumerate(sol) if c == K]\n        random.shuffle(ks)\n        for idx in ks:\n            forbid = {sol[j] for j in adj[idx]}\n            candidates = [c for c in range(1, K) if c not in forbid]\n            if candidates:\n                new_sol = sol[:]\n                new_sol[idx] = random.choice(candidates)\n                move = \"K-reduce\" if max(new_sol) < K else \"recolor\"\n                return new_sol, (\"1-vertex\", move)\n    # Conflict-directed recolor: prioritize vertices with conflicts, then higher saturation and degree\n    sat = [len({sol[j] for j in adj[i]}) for i in range(n)]\n    deg = [len(adj[i]) for i in range(n)]\n    order = sorted(range(n), key=lambda i: (conflict[i], sat[i], deg[i]), reverse=True)\n    for idx in order[:3]:\n        forbid = {sol[j] for j in adj[idx]}\n        cur = sol[idx]\n        candidates = [c for c in range(1, K + 1) if c != cur and c not in forbid]\n        if candidates:\n            new_sol = sol[:]\n            new_sol[idx] = random.choice(candidates)\n            return new_sol, (\"1-vertex\", \"recolor\")\n    # Fallback random recolor within current palette to ensure a move\n    idx = random.randrange(n)\n    alt = [c for c in range(1, max(K, 2) + 1) if c != sol[idx]]\n    if alt:\n        new_sol = sol[:]\n        new_sol[idx] = random.choice(alt)\n        return new_sol, (\"fallback\", \"recolor\")\n    return sol, (\"noop\", \"noop\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Kempe-chain swap or multi-vertex recolor focusing on high colors\/conflicts\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    sol = list(solution) if isinstance(solution, list) and len(solution) == n else [random.randint(1, 3) for _ in range(n)]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v); adj[v].append(u)\n    K = max(sol)\n    # With 60% chance perform Kempe-chain swap between two used colors\n    if random.random() < 0.6 and K >= 2:\n        used = sorted(set(sol))\n        if len(used) < 2:\n            return sol\n        c1, c2 = random.sample(used, 2)\n        nodes = [i for i, c in enumerate(sol) if c in (c1, c2)]\n        if not nodes:\n            return sol\n        seed = random.choice(nodes)\n        in_sub = set(nodes)\n        comp = set([seed])\n        q = deque([seed])\n        while q:\n            i = q.popleft()\n            for j in adj[i]:\n                if j in in_sub and j not in comp:\n                    comp.add(j)\n                    q.append(j)\n        for i in comp:\n            if sol[i] == c1:\n                sol[i] = c2\n            elif sol[i] == c2:\n                sol[i] = c1\n        return sol\n    # Otherwise, recolor a subset biased to max color and conflicted vertices\n    conflict = [0] * n\n    for (u, v) in E:\n        u -= 1; v -= 1\n        if sol[u] == sol[v]:\n            conflict[u] += 1; conflict[v] += 1\n    targets = [i for i, c in enumerate(sol) if c == K]\n    if not targets:\n        targets = [i for i, cc in enumerate(conflict) if cc > 0] or list(range(n))\n    m = max(2, min(4, len(targets)))\n    chosen = random.sample(targets, m)\n    for idx in chosen:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        palette_max = max(2, K)\n        choices = [c for c in range(1, palette_max + 1) if c != sol[idx] and c not in neigh_cols]\n        if not choices:\n            # allow temporary expansion to diversify\n            choices = [c for c in range(1, K + 2) if c != sol[idx]]\n        sol[idx] = random.choice(choices)\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","Evaluacion":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","Vecindad":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a legal neighbouring solution (list[int])\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    cur = deepcopy(solution)\n    if not isinstance(cur, list) or len(cur) != n:\n        # Create a quick feasible fallback by greedy coloring\n        order = list(range(n))\n        random.shuffle(order)\n        cur = [1]*n\n        for i in order:\n            used = {cur[j] for j in adj[i]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[i] = c\n    maxc = max(cur)\n\n    def kempe_chain_swap(sol, v_idx, color_a, color_b):\n        # BFS on subgraph induced by colors {a,b}, swap in connected component containing v_idx\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (color_a, color_b) and y not in seen:\n                    if any(True for _ in [0]):\n                        seen.add(y)\n                        q.append(y)\n        # Swap colors in component\n        for x in seen:\n            if sol[x] == color_a:\n                sol[x] = color_b\n            elif sol[x] == color_b:\n                sol[x] = color_a\n        return sol\n\n    move_type = random.random()\n    new_sol = deepcopy(cur)\n\n    if move_type < 0.5:\n        # Single-vertex feasible recolor with smallest available color\n        i = random.randrange(n)\n        used = {new_sol[j] for j in adj[i]}\n        candidates = [c for c in range(1, max(new_sol)) if c not in used]\n        if not candidates:\n            candidates = [c for c in range(1, max(new_sol)+1) if c not in used]\n        if candidates:\n            new_sol[i] = random.choice(candidates)\n        else:\n            # Try Kempe swap to free a color\n            target_color = new_sol[i]\n            alt = random.choice([c for c in range(1, max(new_sol)+1) if c != target_color] or [target_color])\n            new_sol = kempe_chain_swap(new_sol, i, target_color, alt)\n    else:\n        # Kempe-chain swap between two colors touching a random vertex\n        v = random.randrange(n)\n        neigh_colors = list({new_sol[u] for u in adj[v]})\n        if len(neigh_colors) >= 1:\n            a = new_sol[v]\n            b = random.choice(neigh_colors)\n            if a != b:\n                new_sol = kempe_chain_swap(new_sol, v, a, b)\n        else:\n            # Fallback to single recolor if isolated (unlikely here)\n            used = {new_sol[j] for j in adj[v]}\n            candidates = [c for c in range(1, max(new_sol)) if c not in used] or [c for c in range(1, max(new_sol)+1) if c not in used] or [max(new_sol)]\n            new_sol[v] = random.choice(candidates)\n\n    # Ensure feasibility by repairing if needed\n    def repair(sol):\n        sol = normalize_colors(sol)\n        for (u, v) in E:\n            u -= 1; v -= 1\n            if sol[u] == sol[v]:\n                # Recolor u greedily\n                used = {sol[w] for w in adj[u]}\n                c = 1\n                while c in used:\n                    c += 1\n                sol[u] = c\n        return normalize_colors(sol)\n\n    new_sol = repair(new_sol)\n    new_sol = normalize_colors(new_sol)\n    return new_sol\n","Perturbacion":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: a few Kempe-chain swaps and attempt to reduce highest color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    cur = deepcopy(solution)\n    if not isinstance(cur, list) or len(cur) != n:\n        # Greedy fallback\n        cur = [1]*n\n        for i in range(n):\n            used = {cur[j] for j in adj[i]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[i] = c\n\n    def kempe_component(sol, v_idx, color_a, color_b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (color_a, color_b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, color_a, color_b):\n        for x in comp:\n            if sol[x] == color_a:\n                sol[x] = color_b\n            elif sol[x] == color_b:\n                sol[x] = color_a\n        return sol\n\n    # Apply 2-3 Kempe-chain swaps\n    t = random.randint(2, 3)\n    for _ in range(t):\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        if not neigh_colors:\n            continue\n        b = random.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        cur = kempe_swap(cur, comp, a, b)\n\n    # Attempt to eliminate the highest color class by greedy recolor\n    cur = normalize_colors(cur)\n    maxc = max(cur)\n    highest = [i for i, c in enumerate(cur) if c == maxc]\n    random.shuffle(highest)\n    for i in highest:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, maxc) if c not in used]\n        if candidates:\n            cur[i] = random.choice(candidates)\n    cur = normalize_colors(cur)\n\n    # Final quick repair to ensure feasibility\n    for (u, v) in E:\n        u -= 1; v -= 1\n        if cur[u] == cur[v]:\n            used = {cur[w] for w in adj[u]}\n            c = 1\n            while c in used:\n                c += 1\n            cur[u] = c\n    return normalize_colors(cur)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] of length 9. 1-based color indices. c[i-1] is the color of vertex i. Domain: positive integers starting at 1.","Evaluacion":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY = 10**9\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY\n\n    # Feasibility check\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return PENALTY\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","Vecindad":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_description)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            # pick vertex with max saturation, tie-break on degree\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def kempe_chain_swap(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        for x in seen:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible(sol):\n        # Loop until all conflicts resolved. Introduce new color only if unavoidable.\n        changed = True\n        nloc = len(sol)\n        while changed:\n            changed = False\n            for u in range(nloc):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        # recolor vertex with higher degree; tiebreak on larger color id\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        cap = max(sol)\n                        c = 1\n                        while c in used and c <= cap:\n                            c += 1\n                        if c > cap:\n                            c = cap + 1\n                        if sol[pick] != c:\n                            sol[pick] = c\n                            changed = True\n        return sol\n\n    def recolor_vertex(sol, i):\n        used = {sol[j] for j in adj[i]}\n        cap = max(sol)\n        feasible = [c for c in range(1, cap+1) if c not in used]\n        if feasible:\n            # least-constraining color heuristic\n            def lc_cost(c):\n                cost = 0\n                for j in adj[i]:\n                    nbr_used = {sol[k] for k in adj[j] if k != i}\n                    if c in nbr_used:\n                        cost += 1\n                return cost\n            best_c = min(feasible, key=lc_cost)\n            sol[i] = best_c\n            return sol, \"recolor\"\n        # unavoidable: allow a new color\n        sol[i] = cap + 1\n        return sol, \"recolor_new\"\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n else dsatur_init()\n\n    move_r = random.random()\n    if move_r < 0.5:\n        # Single-vertex recolor attempt\n        i = random.randrange(n)\n        new_sol = cur[:]\n        new_sol, mtype = recolor_vertex(new_sol, i)\n        new_sol = repair_feasible(new_sol)\n        return new_sol, mtype\n    else:\n        # Kempe-chain swap around a random vertex and a neighbor color\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        new_sol = cur[:]\n        mtype = \"kempe_noop\"\n        if neigh_colors:\n            b = random.choice(neigh_colors)\n            if a != b:\n                before_cap = max(new_sol)\n                new_sol = kempe_chain_swap(new_sol, v, a, b)\n                # small acceptance filter: avoid k inflation\n                if max(new_sol) > before_cap:\n                    # revert with small probability to maintain diversity\n                    if random.random() < 0.2:\n                        pass\n                    else:\n                        new_sol = cur[:]\n                else:\n                    mtype = \"kempe\"\n        new_sol = repair_feasible(new_sol)\n        return new_sol, mtype\n","Perturbacion":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple Kempe-chain swaps and targeted reduction of highest color class\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def kempe_component(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, a, b):\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible(sol):\n        changed = True\n        nloc = len(sol)\n        while changed:\n            changed = False\n            for u in range(nloc):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        cap = max(sol)\n                        c = 1\n                        while c in used and c <= cap:\n                            c += 1\n                        if c > cap:\n                            c = cap + 1\n                        if sol[pick] != c:\n                            sol[pick] = c\n                            changed = True\n        return sol\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n else dsatur_init()\n\n    # Apply several Kempe swaps\n    t = random.randint(2, 4)\n    for _ in range(t):\n        v = random.randrange(n)\n        a = cur[v]\n        neigh_colors = list({cur[u] for u in adj[v] if cur[u] != a})\n        if not neigh_colors:\n            continue\n        b = random.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        cur = kempe_swap(cur, comp, a, b)\n\n    # Attempt to eliminate the highest color class\n    cap = max(cur)\n    top_vertices = [i for i, c in enumerate(cur) if c == cap]\n    random.shuffle(top_vertices)\n    for i in top_vertices:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, cap) if c not in used]\n        if candidates:\n            cur[i] = random.choice(candidates)\n\n    cur = repair_feasible(cur)\n    return cur\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"List[int] length=9; 1-based color indices. solution[i-1] is color of vertex i. Domain: integers >=1.","Evaluacion":"import math\nimport random\nfrom copy import deepcopy\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 10**6\n    CONFLICT_WEIGHT = 1000\n    # Embedded problem data\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    def normalize_colors(sol):\n        remap = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in remap:\n                remap[c] = nxt\n                nxt += 1\n            out.append(remap[c])\n        return out\n\n    # Type and shape checks\n    if not isinstance(solution, list) or len(solution) != n:\n        return PENALTY_BASE\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return PENALTY_BASE\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # graded penalty to provide guidance in infeasible region\n        return PENALTY_BASE + conflicts * CONFLICT_WEIGHT + max(solution)\n\n    sol_norm = normalize_colors(solution)\n    return max(sol_norm)\n","Vecindad":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_description)\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def is_feasible(sol):\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n\n    def kempe_component(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, a, b):\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible_cap(sol, cap):\n        # Try to fix conflicts without introducing new colors; if impossible, return None\n        changed = True\n        while changed:\n            changed = False\n            for u in range(n):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        # attempt to recolor the more constrained vertex within [1..cap]\n                        pick = u if (len(adj[u]) > len(adj[v]) or (len(adj[u]) == len(adj[v]) and sol[u] >= sol[v])) else v\n                        used = {sol[w] for w in adj[pick]}\n                        new_color = None\n                        for c in range(1, cap+1):\n                            if c not in used:\n                                new_color = c\n                                break\n                        if new_color is None:\n                            return None\n                        if sol[pick] != new_color:\n                            sol[pick] = new_color\n                            changed = True\n        return sol\n\n    def greedy_recolor_class_under_cap(sol, target_color, cap):\n        # Try to recolor all vertices of target_color into colors in [1..cap] excluding target_color\n        verts = [i for i,c in enumerate(sol) if c == target_color]\n        # DSATUR-like order: by number of distinct neighbor colors\n        order = sorted(verts, key=lambda i: len({sol[j] for j in adj[i]}), reverse=True)\n        new_sol = sol[:]\n        for i in order:\n            used = {new_sol[j] for j in adj[i]}\n            candidates = [c for c in range(1, cap+1) if c != target_color and c not in used]\n            if not candidates:\n                return None\n            # least-constraining choice\n            def lc_cost(c):\n                cost = 0\n                for j in adj[i]:\n                    nbr_used = {new_sol[k] for k in adj[j] if k != i}\n                    if c in nbr_used:\n                        cost += 1\n                return cost\n            new_sol[i] = min(candidates, key=lc_cost)\n        return new_sol\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution) else dsatur_init()\n    if not is_feasible(cur):\n        cur = dsatur_init()\n    current_k = max(cur)\n\n    # Define a sequence of neighborhood attempts prioritized by k-reduction\n    # 1) COLOR_MERGE: try to eliminate highest color class\n    top_color = current_k\n    merged = greedy_recolor_class_under_cap(cur, top_color, current_k - 1) if current_k > 1 else None\n    if merged is not None and is_feasible(merged):\n        return merged, \"COLOR_MERGE\"\n\n    # 2) TARGETED_KEMPE around a vertex in the highest color class\n    top_vertices = [i for i,c in enumerate(cur) if c == top_color]\n    if top_vertices:\n        v = random.choice(top_vertices)\n        a = cur[v]\n        neigh_cols = list({cur[u] for u in adj[v] if cur[u] != a})\n        random.shuffle(neigh_cols)\n        for b in neigh_cols:\n            trial = cur[:]\n            comp = kempe_component(trial, v, a, b)\n            trial = kempe_swap(trial, comp, a, b)\n            if max(trial) <= current_k:\n                fixed = repair_feasible_cap(trial[:], current_k)\n                if fixed is not None and is_feasible(fixed):\n                    return fixed, \"TARGETED_KEMPE\"\n\n    # 3) RECOLOR a random vertex to a different feasible color within cap\n    i = random.randrange(n)\n    used = {cur[j] for j in adj[i]}\n    candidates = [c for c in range(1, current_k+1) if c != cur[i] and c not in used]\n    random.shuffle(candidates)\n    for c in candidates:\n        trial = cur[:]\n        trial[i] = c\n        fixed = repair_feasible_cap(trial, current_k)\n        if fixed is not None and is_feasible(fixed):\n            return fixed, \"RECOLOR\"\n\n    # 4) PAIRWISE_COLOR_SWAP of two color classes to unlock structures\n    if current_k >= 2:\n        a, b = random.sample(range(1, current_k+1), 2)\n        trial = cur[:]\n        for idx, val in enumerate(trial):\n            if val == a:\n                trial[idx] = b\n            elif val == b:\n                trial[idx] = a\n        fixed = repair_feasible_cap(trial, current_k)\n        if fixed is not None and is_feasible(fixed):\n            return fixed, \"PAIRWISE_COLOR_SWAP\"\n\n    # Fallback: return current solution (already feasible)\n    return cur[:], \"NOOP\"\n","Perturbacion":"import random\nfrom copy import deepcopy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Deterministic w.r.t input: use local RNG seeded by hash of the solution tuple\n    rng = random.Random(hash(tuple(solution)) if isinstance(solution, list) else 0)\n\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dsatur_init():\n        deg = [len(adj[i]) for i in range(n)]\n        colors = [0]*n\n        sat = [0]*n\n        neigh_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [(sat[i], deg[i], i) for i in range(n) if colors[i] == 0]\n            _, _, u = max(candidates)\n            used = neigh_colors[u]\n            c = 1\n            while c in used:\n                c += 1\n            colors[u] = c\n            for v in adj[u]:\n                if colors[v] == 0:\n                    neigh_colors[v].add(c)\n                    sat[v] = len(neigh_colors[v])\n        return colors\n\n    def is_feasible(sol):\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                return False\n        return True\n\n    def kempe_component(sol, v_idx, a, b):\n        q = deque([v_idx])\n        seen = {v_idx}\n        while q:\n            x = q.popleft()\n            for y in adj[x]:\n                if sol[y] in (a, b) and y not in seen:\n                    seen.add(y)\n                    q.append(y)\n        return seen\n\n    def kempe_swap(sol, comp, a, b):\n        for x in comp:\n            if sol[x] == a:\n                sol[x] = b\n            elif sol[x] == b:\n                sol[x] = a\n        return sol\n\n    def repair_feasible_cap(sol, cap):\n        # Try to fix conflicts without introducing new colors; if impossible, return None\n        changed = True\n        while changed:\n            changed = False\n            for u in range(n):\n                for v in adj[u]:\n                    if v <= u:\n                        continue\n                    if sol[u] == sol[v]:\n                        used = {sol[w] for w in adj[u]}\n                        new_color = None\n                        for c in range(1, cap+1):\n                            if c not in used:\n                                new_color = c\n                                break\n                        if new_color is None:\n                            return None\n                        if sol[u] != new_color:\n                            sol[u] = new_color\n                            changed = True\n        return sol\n\n    cur = deepcopy(solution) if isinstance(solution, list) and len(solution) == n and all(isinstance(x, int) and x >= 1 for x in solution) else dsatur_init()\n    if not is_feasible(cur):\n        cur = dsatur_init()\n    cap = max(cur)\n\n    # Apply several deterministic Kempe swaps using local RNG, keeping cap\n    t = rng.randint(2, 5)\n    for _ in range(t):\n        v = rng.randrange(n)\n        a = cur[v]\n        neigh_colors = [cur[u] for u in adj[v] if cur[u] != a]\n        if not neigh_colors:\n            continue\n        b = rng.choice(neigh_colors)\n        comp = kempe_component(cur, v, a, b)\n        trial = kempe_swap(cur[:], comp, a, b)\n        if max(trial) <= cap:\n            fixed = repair_feasible_cap(trial, cap)\n            if fixed is not None and is_feasible(fixed):\n                cur = fixed\n\n    # Shuffle color classes by a deterministic permutation\n    perm = list(range(1, cap+1))\n    rng.shuffle(perm)\n    relabel = {i+1: perm[i] for i in range(cap)}\n    cur = [relabel[c] for c in cur]\n\n    # Try to reduce usage of the highest color by greedy recoloring within cap\n    top = cap\n    idxs = [i for i,c in enumerate(cur) if c == top]\n    rng.shuffle(idxs)\n    for i in idxs:\n        used = {cur[j] for j in adj[i]}\n        candidates = [c for c in range(1, cap) if c not in used]\n        if candidates:\n            cur[i] = rng.choice(candidates)\n    fixed = repair_feasible_cap(cur[:], cap)\n    if fixed is not None and is_feasible(fixed):\n        return fixed\n    # Fallback to feasible original under cap\n    return cur if is_feasible(cur) else dsatur_init()\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better. Feasibility strongly enforced; objective = number of colors when feasible\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        # heavy penalty, but preserve gradient with magnitude proportional to size error\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count issues\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness\n    fitness = 0\n    # Penalize structural\/type issues strongly\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    # Penalize violations very strongly\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        # Feasible: objective is the number of colors\n        fitness = k_used\n    else:\n        # Infeasible: add small pressure to reduce colors while repairing\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random, math\n\n\ndef _normalize_colors(sol):\n    # Relabel colors to a compact 1..k to stabilize k_used\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        c = c if isinstance(c, int) and c >= 1 else 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Single-node recolor favoring diversification within current palette; robust to malformed inputs\n    n = 9\n    base = list(solution)[:n] if isinstance(solution, (list, tuple)) else [1]*n\n    if len(base) < n:\n        base = base + [1]*(n - len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n    colors = _normalize_colors(colors)\n\n    max_c = max(colors) if colors else 1\n    idx = random.randrange(0, n)\n    current_color = colors[idx]\n\n    # Candidate colors within current palette; allow +1 with small probability to diversify\n    allow_new = (random.random() < 0.15)\n    max_try = max_c + (1 if allow_new else 0)\n    candidates = [c for c in range(1, max_try + 1) if c != current_color]\n    if not candidates:\n        candidates = [1 if current_color != 1 else 2]\n    new_color = random.choice(candidates)\n\n    neighbor = colors[:]\n    neighbor[idx] = new_color\n    neighbor = _normalize_colors(neighbor)\n\n    return (neighbor, \"single-recolor\")\n","Perturbacion":"import random, math\n\n\ndef _normalize_colors(sol):\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        c = c if isinstance(c, int) and c >= 1 else 1\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\n\ndef perturb_solution(solution):\n    # Stronger shake using multi-recolor and optional color swap (Kempe-style light)\n    n = 9\n    base = list(solution)[:n] if isinstance(solution, (list, tuple)) else [1]*n\n    if len(base) < n:\n        base = base + [1]*(n - len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n    colors = _normalize_colors(colors)\n\n    max_c = max(colors) if colors else 1\n\n    # Randomly recolor k nodes\n    k = random.randint(2, 4)\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        # Allow introduction of at most one new color during perturbation\n        allow_new = (random.random() < 0.5)\n        max_try = max_c + (1 if allow_new else 0)\n        cand = [c for c in range(1, max_try + 1) if c != colors[idx]]\n        if cand:\n            colors[idx] = random.choice(cand)\n    colors = _normalize_colors(colors)\n\n    # Optional swap two existing colors to escape symmetry basins\n    max_c = max(colors) if colors else 1\n    if max_c >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, max_c + 1), 2)\n        for i in range(n):\n            if colors[i] == a:\n                colors[i] = b\n            elif colors[i] == b:\n                colors[i] = a\n        colors = _normalize_colors(colors)\n\n    return colors\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Robust evaluation: lower is better. Feasibility strongly enforced; objective = number of colors when feasible\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count issues\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type)\n    # Mixed neighborhood: single-node recolor (conflict-minimizing), Kempe-chain swap, non-edge vertex color swap\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Coerce to valid length-9 positive-int list\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u,v in edges:\n            if sol[u] == sol[v]:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol):\n        kmax = max(sol) if sol else 1\n        i = random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        # With small probability, allow a new color\n        if random.random() < 0.1:\n            candidates.append(kmax+1)\n        best = None\n        best_conf = None\n        # Evaluate local conflicts at i only for speed\n        neigh = adj[i]\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best = c\n            elif conf == best_conf and random.random() < 0.5:\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out), \"single-recolor\"\n\n    def kempe_swap(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return recolor_min_conflict(sol)\n        a,b = random.sample(range(1, kmax+1), 2)\n        # pick a start vertex with color a or b\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return recolor_min_conflict(sol)\n        s = random.choice(cand)\n        target_colors = {a,b}\n        visited = [False]*n\n        comp = []\n        dq = deque([s])\n        visited[s] = True\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and sol[v] in target_colors:\n                    visited[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out), \"kempe-swap\"\n\n    def vertex_color_swap(sol):\n        # swap colors of two non-adjacent vertices\n        non_edges = []\n        is_adj = [[False]*n for _ in range(n)]\n        for u,v in edges:\n            is_adj[u][v] = True\n            is_adj[v][u] = True\n        for i in range(n):\n            for j in range(i+1, n):\n                if not is_adj[i][j]:\n                    non_edges.append((i,j))\n        if not non_edges:\n            return recolor_min_conflict(sol)\n        i,j = random.choice(non_edges)\n        out = sol[:]\n        out[i], out[j] = out[j], out[i]\n        return normalize(out), \"vertex-swap\"\n\n    colors = normalize(colors)\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb, mtype = recolor_min_conflict(colors)\n    elif move_pick < 0.8:\n        nb, mtype = kempe_swap(colors)\n    else:\n        nb, mtype = vertex_color_swap(colors)\n\n    # Final safety: enforce ints >=1 and length n\n    nb = [int(c) if isinstance(c,int) and c>=1 else 1 for c in nb[:n]]\n    return (nb, mtype)\n","Perturbacion":"import random, math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake: multiple conflict-minimizing recolors + Kempe swaps; returns a valid solution list\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def recolor_min_conflict_once(sol, allow_new_prob=0.2):\n        kmax = max(sol) if sol else 1\n        i = random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        if random.random() < allow_new_prob:\n            candidates.append(kmax+1)\n        neigh = adj[i]\n        best = None\n        best_conf = None\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best = c\n            elif conf == best_conf and random.random() < 0.5:\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out)\n\n    def kempe_swap_once(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return sol[:]\n        a,b = random.sample(range(1, kmax+1), 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return sol[:]\n        s = random.choice(cand)\n        target = {a,b}\n        seen = [False]*n\n        dq = deque([s])\n        seen[s] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in target:\n                    seen[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out)\n\n    colors = normalize(colors)\n\n    # Multi-node recolors\n    r = random.randint(2, 4)\n    for _ in range(r):\n        colors = recolor_min_conflict_once(colors, allow_new_prob=0.3)\n\n    # One or two Kempe swaps\n    s = 1 + (1 if random.random() < 0.5 else 0)\n    for _ in range(s):\n        colors = kempe_swap_once(colors)\n\n    # Final safety\n    colors = [int(c) if isinstance(c,int) and c>=1 else 1 for c in colors[:n]]\n    return colors\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST_INT_POS_LEN9","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better. Strict feasibility priority via large base multiplier\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n\n    # Type\/length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Entry validation\n    non_int = sum(1 for x in solution if not isinstance(x, int))\n    non_pos = sum(1 for x in solution if isinstance(x, int) and x < 1)\n\n    # Count edge violations\n    violations = 0\n    for (u, v) in edges:\n        cu = solution[u]\n        cv = solution[v]\n        if isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1 and cu == cv:\n            violations += 1\n\n    # Colors used\n    colors_used = {x for x in solution if isinstance(x, int) and x >= 1}\n    k_used = len(colors_used) if colors_used else 10**6\n\n    # Compose fitness (lexicographic via large multiplier)\n    B = 10000  # >> maximum possible k\n    fitness = violations * B + k_used\n\n    # Add input-quality penalties (kept smaller than B but significant if many)\n    fitness += non_int * 1000\n    fitness += non_pos * 500\n\n    return int(fitness)\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, movement_type_str)\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Coerce to a valid list of length n with positive ints\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_edges(sol):\n        return [(u,v) for (u,v) in edges if sol[u] == sol[v]]\n\n    def vertex_conflicts(sol, i):\n        return sum(1 for j in adj[i] if sol[j] == sol[i])\n\n    def recolor_conflicting_vertex(sol):\n        # Pick among conflicting vertices (biased), choose color minimizing local conflicts\n        conflicts = [i for i in range(n) if vertex_conflicts(sol, i) > 0]\n        if not conflicts:\n            # fallback: any vertex\n            i = random.randrange(n)\n        else:\n            i = random.choice(conflicts)\n        kmax = max(sol) if sol else 1\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        # With small probability, allow a new color\n        if random.random() < 0.05:\n            candidates.append(kmax+1)\n        neigh = adj[i]\n        best = None\n        best_conf = None\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best = c\n        out = sol[:]\n        out[i] = best if best is not None else current\n        return normalize(out), \"single-recolor\"\n\n    def kempe_swap_guided(sol):\n        # Select color pair involved in conflicts to increase effectiveness\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return recolor_conflicting_vertex(sol)\n        # Build conflict counts per pair\n        pair_counts = {}\n        for (u,v) in edges:\n            if sol[u] == sol[v]:\n                # same-color conflict; encourage moves using this color and its neighbors' colors\n                cu = sol[u]\n                for w in adj[u] + adj[v]:\n                    cw = sol[w]\n                    if cw != cu:\n                        a,b = sorted((cu, cw))\n                        pair_counts[(a,b)] = pair_counts.get((a,b), 0) + 1\n        if pair_counts:\n            # Weighted random choice\n            items = list(pair_counts.items())\n            total = sum(cnt for _, cnt in items)\n            r = random.uniform(0, total)\n            acc = 0.0\n            a,b = 1,2\n            for (pair, cnt) in items:\n                acc += cnt\n                if r <= acc:\n                    a,b = pair\n                    break\n        else:\n            a,b = random.sample(range(1, kmax+1), 2)\n        # pick a start vertex with color a or b\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return recolor_conflicting_vertex(sol)\n        s = random.choice(cand)\n        target = {a,b}\n        visited = [False]*n\n        dq = deque([s])\n        visited[s] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and sol[v] in target:\n                    visited[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out), \"kempe-swap\"\n\n    def vertex_color_swap_preserve_k(sol):\n        # Swap colors of two non-adjacent vertices; preserve current k and avoid increasing conflicts\n        kmax = max(sol) if sol else 1\n        is_adj = [[False]*n for _ in range(n)]\n        for u,v in edges:\n            is_adj[u][v] = True\n            is_adj[v][u] = True\n        non_edges = [(i,j) for i in range(n) for j in range(i+1,n) if not is_adj[i][j]]\n        if not non_edges:\n            return recolor_conflicting_vertex(sol)\n        i,j = random.choice(non_edges)\n        out = sol[:]\n        out[i], out[j] = out[j], out[i]\n        out = normalize(out)\n        if max(out) > kmax:\n            return sol[:], \"noop\"\n        # Simple conflict check around affected vertices\n        def vconf(s, p):\n            return sum(1 for t in adj[p] if s[t] == s[p])\n        if vconf(out, i) + vconf(out, j) <= vconf(sol, i) + vconf(sol, j):\n            return out, \"vertex-swap\"\n        else:\n            return sol[:], \"noop\"\n\n    colors = normalize(colors)\n\n    move_pick = random.random()\n    if move_pick < 0.5:\n        nb, mtype = recolor_conflicting_vertex(colors)\n    elif move_pick < 0.85:\n        nb, mtype = kempe_swap_guided(colors)\n    else:\n        nb, mtype = vertex_color_swap_preserve_k(colors)\n\n    nb = [int(c) if isinstance(c,int) and c>=1 else 1 for c in nb[:n]]\n    return (nb, mtype)\n","Perturbacion":"import random, math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Stronger shake combining multiple recolors and Kempe swaps; returns normalized valid list\n    n = 9\n    edges = [(0,3),(0,4),(0,5),(0,7),(0,8),\n             (1,4),(1,5),(1,6),(1,7),(1,8),\n             (2,3),(2,5),(2,6),\n             (3,4),(3,6),(3,7),(3,8),\n             (4,5),(4,8),\n             (5,8),\n             (6,7)]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    if not isinstance(solution, (list, tuple)):\n        base = [1]*n\n    else:\n        base = list(solution[:n])\n        if len(base) < n:\n            base += [1]*(n-len(base))\n    colors = [c if isinstance(c, int) and c >= 1 else 1 for c in base]\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def recolor_once(sol, allow_new_prob=0.15):\n        kmax = max(sol) if sol else 1\n        # Prefer conflicting vertices\n        conflicts = [i for i in range(n) if any(sol[i] == sol[j] for j in adj[i])]\n        i = random.choice(conflicts) if conflicts else random.randrange(n)\n        current = sol[i]\n        candidates = list(range(1, kmax+1))\n        if current in candidates:\n            candidates.remove(current)\n        if random.random() < allow_new_prob:\n            candidates.append(kmax+1)\n        best, best_conf = current, None\n        neigh = adj[i]\n        for c in candidates:\n            conf = sum(1 for j in neigh if sol[j] == c)\n            if best_conf is None or conf < best_conf or (conf == best_conf and random.random() < 0.5):\n                best_conf = conf\n                best = c\n        out = sol[:]\n        out[i] = best\n        return normalize(out)\n\n    def kempe_once(sol):\n        kmax = max(sol) if sol else 1\n        if kmax < 2:\n            return sol[:]\n        a,b = random.sample(range(1, kmax+1), 2)\n        cand = [i for i,c in enumerate(sol) if c == a or c == b]\n        if not cand:\n            return sol[:]\n        s = random.choice(cand)\n        target = {a,b}\n        seen = [False]*n\n        dq = deque([s])\n        seen[s] = True\n        comp = []\n        while dq:\n            u = dq.popleft()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and sol[v] in target:\n                    seen[v] = True\n                    dq.append(v)\n        out = sol[:]\n        for u in comp:\n            out[u] = b if sol[u] == a else (a if sol[u] == b else sol[u])\n        return normalize(out)\n\n    colors = normalize(colors)\n\n    # Apply multiple recolors\n    r = random.randint(2, 4)\n    for _ in range(r):\n        colors = recolor_once(colors, allow_new_prob=0.25)\n\n    # Apply one or two Kempe swaps\n    s = 1 + (1 if random.random() < 0.5 else 0)\n    for _ in range(s):\n        colors = kempe_once(colors)\n\n    colors = [int(c) if isinstance(c,int) and c>=1 else 1 for c in colors[:n]]\n    return colors\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns a numeric fitness aggregating feasibility and optimality. Lower is better.\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edge_set = set((min(u,v), max(u,v)) for (u,v) in edges)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    # Base penalties for malformed input\n    if not isinstance(colors, list):\n        return 10000000.0\n    if len(colors) != n:\n        return 9000000.0 + float(abs(len(colors)-n))\n    # domain checks\n    for x in colors:\n        if not isinstance(x, int):\n            return 8000000.0\n        if x < 1:\n            return 7000000.0\n    # feasibility check\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5000000.0 + float(violations)\n    # feasible: compute k_hat\n    k_hat = max(colors) if colors else 0\n\n    # exact clique number (lower bound)\n    def max_clique_size():\n        best = 1\n        for mask in range(1, 1<<n):\n            size = mask.bit_count()\n            if size <= best:\n                continue\n            nodes = [i+1 for i in range(n) if (mask>>i) & 1]\n            ok = True\n            for i in range(len(nodes)):\n                if not ok:\n                    break\n                ui = nodes[i]\n                for j in range(i+1, len(nodes)):\n                    vj = nodes[j]\n                    if (min(ui,vj), max(ui,vj)) not in edge_set:\n                        ok = False\n                        break\n            if ok and size > best:\n                best = size\n        return best\n\n    omega = max_clique_size()\n\n    # decision check: is graph k-colorable for smaller k?\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def k_colorable(k):\n        col = {i: 0 for i in range(1, n+1)}\n        def sat_deg(u):\n            return len(set(col[v] for v in adj[u] if col[v] != 0))\n        def available_colors(u):\n            used = set(col[v] for v in adj[u] if col[v] != 0)\n            return [c for c in range(1, k+1) if c not in used]\n        def select_node():\n            cand = [u for u in range(1, n+1) if col[u] == 0]\n            if not cand:\n                return None\n            best_u = None\n            best_key = None\n            for u in cand:\n                key = (sat_deg(u), len(adj[u]))\n                if best_u is None or key > best_key:\n                    best_u = u; best_key = key\n            return best_u\n        def backtrack():\n            u = select_node()\n            if u is None:\n                return True\n            for c in available_colors(u):\n                col[u] = c\n                ok = True\n                for v in adj[u]:\n                    if col[v] == c:\n                        ok = False\n                        break\n                if ok and backtrack():\n                    return True\n                col[u] = 0\n            return False\n        return backtrack()\n\n    # penalties\n    lb_violation = 0.0 if k_hat >= omega else (omega - k_hat) * 1000.0\n    improvable = False\n    for k in range(1, k_hat):\n        if k_colorable(k):\n            improvable = True\n            break\n    optimality_penalty = 0.0 if (not improvable and k_hat >= omega) else 100.0\n\n    return float(k_hat) + lb_violation + optimality_penalty\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution_encoded, meta_str)\n    meta_str examples: 'Local\/Recolor', 'Local\/Swap', 'Local\/Kempe'\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def greedy_init():\n        # DSATUR-like greedy\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x]))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return colors\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = greedy_init()\n    else:\n        colors = [max(1, int(x)) for x in colors]\n\n    k = max(colors)\n\n    # Helper: list conflicts and max-color vertices\n    conflicts = []\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts.append((u,v))\n    max_color_vertices = [i for i in range(1,n+1) if colors[i-1] == k]\n\n    move_type = None\n\n    r = random.random()\n    new = colors[:]\n\n    if conflicts and r < 0.5:\n        # Conflict-driven recolor\n        u,v = random.choice(conflicts)\n        u = random.choice([u,v])\n        used = set(new[w-1] for w in adj[u])\n        # Prefer smallest feasible color; if none, pick random other color\n        c = 1\n        chosen = None\n        while c <= k:\n            if c not in used:\n                chosen = c\n                break\n            c += 1\n        if chosen is None:\n            # allow temporary new color with small prob; else random different\n            palette_max = k + (1 if random.random() < 0.1 else 0)\n            cand = list(range(1, palette_max+1))\n            cand = [x for x in cand if x != new[u-1]]\n            chosen = random.choice(cand)\n        new[u-1] = chosen\n        move_type = 'Local\/Recolor'\n    elif max_color_vertices and r < 0.8:\n        # Color swap between max color and a random other color to promote shrinking\n        c1 = k\n        other_colors = [c for c in range(1, k) if c != c1]\n        if other_colors:\n            c2 = random.choice(other_colors)\n            for i in range(n):\n                if new[i] == c1:\n                    new[i] = c2\n                elif new[i] == c2:\n                    new[i] = c1\n            move_type = 'Local\/Swap'\n        else:\n            # fallback recolor a max-color vertex to best feasible\n            u = random.choice(max_color_vertices)\n            used = set(new[w-1] for w in adj[u])\n            feasible = [c for c in range(1, k) if c not in used]\n            if feasible:\n                new[u-1] = random.choice(feasible)\n            else:\n                new[u-1] = random.randint(1, k)\n            move_type = 'Local\/Recolor'\n    else:\n        # Kempe-chain style flip between two colors on a random vertex\n        u = random.randrange(1, n+1)\n        cu = new[u-1]\n        alt_colors = [c for c in range(1, max(k,2)+1) if c != cu]\n        c2 = random.choice(alt_colors)\n        # BFS on subgraph induced by colors {cu, c2}\n        from collections import deque\n        Q = deque([u])\n        visited = set([u])\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if new[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        for x in visited:\n            new[x-1] = c2 if new[x-1] == cu else cu\n        move_type = 'Local\/Kempe'\n\n    # Normalize colors to keep them as positive ints and compact if desired (optional)\n    # Ensure at least 1..max present; leave gaps as-is to avoid invalidating acceptance logic\n    return (encode(new), move_type or 'Local\/Recolor')\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: multi-vertex recolor + color-class swap + 1-2 Kempe flips\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def greedy_init():\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x]))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return colors\n\n    colors = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x,int) or x<1) for x in colors):\n        colors = greedy_init()\n    else:\n        colors = [max(1, int(x)) for x in colors]\n\n    k = max(colors)\n    new = colors[:]\n\n    # 1) Randomly reassign m vertices, biasing towards max color class to encourage shrink\n    m = random.randint(2, 4)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        u = i+1\n        used = set(new[v-1] for v in adj[u])\n        palette = list(range(1, max(2, k) + 1))\n        # Prefer colors not used by neighbors\n        feasible = [c for c in palette if c not in used]\n        if feasible:\n            new[i] = random.choice(feasible)\n        else:\n            # fallback: random different color\n            cand = [c for c in palette if c != new[i]]\n            new[i] = random.choice(cand) if cand else new[i]\n\n    # 2) Swap two random color classes\n    if k >= 2:\n        c1, c2 = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if new[i] == c1:\n                new[i] = c2\n            elif new[i] == c2:\n                new[i] = c1\n\n    # 3) Do 1-2 Kempe-chain flips between random color pairs\n    from collections import deque\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        u = random.randrange(1, n+1)\n        cu = new[u-1]\n        alt_colors = [c for c in range(1, max(2, max(new))) if c != cu]\n        if not alt_colors:\n            continue\n        c2 = random.choice(alt_colors)\n        Q = deque([u])\n        visited = set([u])\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if new[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        for x in visited:\n            new[x-1] = c2 if new[x-1] == cu else cu\n\n    return encode(new)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Evaluacion":"import math\nimport random\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Static evaluator. Lower is better.\n    Score structure prioritization:\n    1) conflicts_count (primary feasibility) -> weight 1_000_000\n    2) k (max color) -> weight 1_000\n    3) tie-breakers for feasible solutions:\n       - number of vertices using max color -> weight 10\n       - total sum of colors (after canonicalization) -> weight 0.001\n    Representation: CSV of 9 positive integers within [1..9]. Colors are canonicalized\n    by order-of-first-appearance before scoring to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        \"\"\"Relabel colors to 1..m by order of first appearance.\"\"\"\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + float(abs(len(cols) - n))\n    # domain checks: integers within [1..n]\n    for x in cols:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1 or x > n:\n            return 7_000_000.0\n\n    cols = canonicalize(cols)\n\n    # compute conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    k_hat = max(cols) if cols else 0\n    cnt_k = sum(1 for x in cols if x == k_hat) if k_hat > 0 else 0\n    ssum = sum(cols)\n\n    if conflicts > 0:\n        score = conflicts * 1_000_000.0 + k_hat * 1_000.0 + float(ssum) * 0.001\n    else:\n        score = k_hat * 1_000.0 + cnt_k * 10.0 + float(ssum) * 0.001\n\n    return float(score)\n","Vecindad":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (encoded_solution, meta_str)\n    Neighbourhood is constraint-aware and does NOT increase palette size.\n    Moves:\n    - Targeted recolor of a vertex (prefer max-color vertices) using least-constraining color.\n    - Kempe chain flip biased toward (k, c<k) pairs to reduce max-color usage.\n    - If conflicts exist, prioritize resolving them with LCV recolor.\n    All outputs are canonicalized to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols: List[int]) -> str:\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def greedy_init() -> List[int]:\n        # DSATUR-like greedy with deterministic ties by degree then index\n        colors = [0] * n\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        uncolored = set(range(1, n+1))\n        while uncolored:\n            def sat_deg(u):\n                return len(set(colors[v-1] for v in adj[u] if colors[v-1] != 0))\n            u = max(uncolored, key=lambda x: (sat_deg(x), degrees[x], -x))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n        return canonicalize(colors)\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = greedy_init()\n    else:\n        cols = canonicalize([max(1, int(x)) for x in cols])\n\n    k = max(cols)\n\n    def conflict_edges(colors: List[int]) -> List[Tuple[int, int]]:\n        res = []\n        for (u, v) in edges:\n            if colors[u-1] == colors[v-1]:\n                res.append((u, v))\n        return res\n\n    def lcv_color(u: int, colors: List[int], palette_max: int) -> int:\n        # least-constraining color among feasible 1..palette_max\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            return colors[u-1]\n        # score by how many neighbors would forbid that color for their neighbors (approx: neighbor degree with that color)\n        best_c = None\n        best_score = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                if colors[v-1] == 0:\n                    continue\n                # if v had c, it would conflict; approximate constraint via degree\n                if c not in set(colors[w-1] for w in adj[v]):\n                    impact += 1\n            key = (impact, -c)\n            if best_c is None or key > best_score:\n                best_c = c\n                best_score = key\n        return best_c if best_c is not None else feas[0]\n\n    def kempe_flip(colors: List[int], u: int, c2: int) -> List[int]:\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        Q = deque([u])\n        visited = {u}\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    new = cols[:]\n    confs = conflict_edges(new)\n    meta = 'Local\/Recolor'\n\n    r = random.random()\n    if confs:\n        # Resolve a conflict by recoloring one endpoint with LCV, no palette growth\n        u, v = random.choice(confs)\n        pick = u if random.random() < 0.5 else v\n        c = lcv_color(pick, new, k)\n        new[pick-1] = c\n        meta = 'Local\/Recolor-ConflictLCV'\n    else:\n        # Target max-color pressure moves\n        max_vertices = [i for i in range(1, n+1) if new[i-1] == k]\n        if max_vertices and r < 0.7:\n            u = random.choice(max_vertices)\n            # try direct feasible recolor to <k using LCV\n            used = set(new[v-1] for v in adj[u])\n            feas = [c for c in range(1, k) if c not in used]\n            if feas:\n                # choose LCV among feas\n                best = None\n                best_key = None\n                for c in feas:\n                    impact = 0\n                    for w in adj[u]:\n                        if c in set(new[z-1] for z in adj[w]):\n                            impact += 1\n                    key = (-(impact), -c)\n                    if best is None or key > best_key:\n                        best = c\n                        best_key = key\n                new[u-1] = best\n                meta = 'Local\/Recolor-MaxDrop'\n            else:\n                # attempt Kempe with a lower color that may free u\n                c2 = random.choice([c for c in range(1, k)])\n                flipped = kempe_flip(new, u, c2)\n                # if flip reduces number of max-color vertices or keeps same but reduces adjacency conflicts, accept\n                before = sum(1 for x in new if x == k)\n                after = sum(1 for x in flipped if x == k)\n                if after <= before:\n                    new = flipped\n                    meta = 'Local\/Kempe(k,c)'\n                else:\n                    # fallback: Kempe around random vertex with pair (k, c2)\n                    w = random.randrange(1, n+1)\n                    c2 = random.choice([c for c in range(1, max(k, 2)) if c != new[w-1]])\n                    new = kempe_flip(new, w, c2)\n                    meta = 'Local\/Kempe-Fallback'\n        else:\n            # General Kempe flip biased to involve k when possible\n            if k >= 2 and random.random() < 0.8:\n                u = random.choice(range(1, n+1))\n                cu = new[u-1]\n                pool = [c for c in range(1, k + 0) if c != cu] if cu != k else [c for c in range(1, k) if c != cu]\n                pool = pool if pool else [c for c in range(1, max(k, 2)) if c != cu]\n                c2 = random.choice(pool)\n                new = kempe_flip(new, u, c2)\n                meta = 'Local\/Kempe-Biased'\n            else:\n                # small recolor anywhere using LCV\n                u = random.randrange(1, n+1)\n                new[u-1] = lcv_color(u, new, k)\n                meta = 'Local\/Recolor-LCV'\n\n    new = canonicalize(new)\n    # Do not increase palette\n    if max(new) > k:\n        # repair by remapping any color >k down to closest in [1..k]\n        mapping = {}\n        nxt = 1\n        for c in sorted(set(new)):\n            if nxt > k:\n                mapping[c] = k\n            else:\n                mapping[c] = nxt\n                nxt += 1\n        new = [mapping[c] for c in new]\n        new = canonicalize(new)\n    return (encode(new), meta)\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong diversification without increasing palette size.\n    Sequence (depth randomized):\n    - Perform s in {2..4} Kempe flips involving color k and random c<k when possible.\n    - Randomly recolor m in {1..3} vertices with LCV within palette 1..k.\n    Returns (encoded_solution, meta_str)\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols: List[int]) -> str:\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols: List[int]) -> List[int]:\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def lcv_color(u: int, colors: List[int], palette_max: int) -> int:\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            # keep color if no feasible alternative\n            return colors[u-1]\n        # pick least constraining (approx.)\n        best = None\n        best_key = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                if c in set(colors[w-1] for w in adj[v]):\n                    impact += 1\n            key = (-impact, -c)\n            if best is None or key > best_key:\n                best = c\n                best_key = key\n        return best\n\n    def kempe_flip(colors: List[int], u: int, c2: int) -> List[int]:\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        Q = deque([u])\n        visited = {u}\n        while Q:\n            x = Q.popleft()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    Q.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # simple fallback: 1..n cyclic\n        cols = [((i % 3) + 1) for i in range(n)]\n    cols = canonicalize(cols)\n    k = max(cols)\n\n    new = cols[:]\n\n    # s Kempe flips involving k when possible\n    s = random.randint(2, 4)\n    for _ in range(s):\n        u = random.randrange(1, n + 1)\n        cu = new[u-1]\n        if k >= 2 and (cu == k or random.random() < 0.7):\n            pool = [c for c in range(1, k) if c != cu]\n            if pool:\n                c2 = random.choice(pool)\n            else:\n                # fallback to any other color\n                pool = [c for c in range(1, max(k, 2)) if c != cu]\n                c2 = random.choice(pool)\n        else:\n            pool = [c for c in range(1, max(k, 2)) if c != cu]\n            c2 = random.choice(pool)\n        new = kempe_flip(new, u, c2)\n\n    # m random LCV recolors within 1..k\n    m = random.randint(1, 3)\n    idxs = random.sample(range(1, n + 1), m)\n    for u in idxs:\n        new[u-1] = lcv_color(u, new, k)\n\n    new = canonicalize(new)\n    if max(new) > k:\n        # enforce palette cap\n        uniq = sorted(set(new))\n        relabel = {c: i + 1 for i, c in enumerate(uniq[:k])}\n        for c in uniq[k:]:\n            relabel[c] = k\n        new = [relabel[c] for c in new]\n        new = canonicalize(new)\n    return (encode(new), 'Perturb\/KempeLCV')\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Static evaluator. Lower is better.\n    Score structure prioritization:\n    1) conflicts_count (primary feasibility) -> weight 1_000_000\n    2) k (max color) -> weight 1_000\n    3) tie-breakers for feasible solutions:\n       - number of vertices using max color -> weight 10\n       - total sum of colors (after canonicalization) -> weight 0.001\n    Representation: CSV of 9 positive integers within [1..9]. Colors are canonicalized\n    by order-of-first-appearance before scoring to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    cols = parse(solution)\n    if not isinstance(cols, list):\n        return 10_000_000.0\n    if len(cols) != n:\n        return 9_000_000.0 + float(abs(len(cols) - n))\n    for x in cols:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1 or x > n:\n            return 7_000_000.0\n\n    cols = canonicalize(cols)\n\n    conflicts = 0\n    for (u, v) in edges:\n        if cols[u-1] == cols[v-1]:\n            conflicts += 1\n\n    k_hat = max(cols) if cols else 0\n    cnt_k = sum(1 for x in cols if x == k_hat) if k_hat > 0 else 0\n    ssum = sum(cols)\n\n    if conflicts > 0:\n        score = conflicts * 1_000_000.0 + k_hat * 1_000.0 + float(ssum) * 0.001\n    else:\n        score = k_hat * 1_000.0 + cnt_k * 10.0 + float(ssum) * 0.001\n\n    return float(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (encoded_solution, meta_str)\n    Neighbourhood is constraint-aware and does NOT increase palette size.\n    Moves:\n    - Targeted recolor of a vertex (prefer max-color vertices) using least-constraining color.\n    - Kempe chain flip between two existing colors (feasibility-aware when possible).\n    If conflicts exist, prioritize resolving them with LCV recolor.\n    All outputs are canonicalized to reduce symmetry.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def dsatur_init():\n        colors = [0]*n\n        degrees = {u: len(adj[u]) for u in range(1, n+1)}\n        uncolored = set(range(1, n+1))\n        sat = {u: set() for u in range(1, n+1)}\n        while uncolored:\n            u = max(uncolored, key=lambda x: (len(sat[x]), degrees[x], -x))\n            used = set(colors[v-1] for v in adj[u] if colors[v-1] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[u-1] = c\n            uncolored.remove(u)\n            for v in adj[u]:\n                if v in uncolored:\n                    sat[v].add(c)\n        return canonicalize([max(1, x) for x in colors])\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = dsatur_init()\n    else:\n        cols = canonicalize([int(x) for x in cols])\n\n    k = max(cols)\n\n    def conflicts_list(colors):\n        res = []\n        for (u, v) in edges:\n            if colors[u-1] == colors[v-1]:\n                res.append((u, v))\n        return res\n\n    def lcv_color(u, colors, palette_max):\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max+1) if c not in used]\n        if not feas:\n            return colors[u-1]\n        # approximate least-constraining: pick color that appears least among neighbors' neighborhoods\n        best_c = None\n        best_key = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                nbr_colors = set(colors[w-1] for w in adj[v])\n                if c in nbr_colors:\n                    impact += 1\n            key = (-(impact), -c)\n            if best_c is None or key > best_key:\n                best_c = c\n                best_key = key\n        return best_c\n\n    def kempe_flip(colors, u, c2):\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        stack = [u]\n        visited = set([u])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    stack.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    new = cols[:]\n    confs = conflicts_list(new)\n    meta = 'Local\/Recolor'\n\n    r = random.random()\n    if confs:\n        # Resolve a conflict by recoloring one endpoint with LCV, no palette growth\n        u, v = random.choice(confs)\n        pick = u if random.random() < 0.5 else v\n        c = lcv_color(pick, new, k)\n        new[pick-1] = c\n        meta = 'Local\/Recolor-ConflictLCV'\n    else:\n        max_vertices = [i for i in range(1, n+1) if new[i-1] == k]\n        if max_vertices and r < 0.7 and k > 1:\n            u = random.choice(max_vertices)\n            used = set(new[v-1] for v in adj[u])\n            feas = [c for c in range(1, k) if c not in used]\n            if feas:\n                # choose LCV among feasible < k\n                best = None\n                best_key = None\n                for c in feas:\n                    impact = 0\n                    for w in adj[u]:\n                        nbr_colors = set(new[z-1] for z in adj[w])\n                        if c in nbr_colors:\n                            impact += 1\n                    key = (-(impact), -c)\n                    if best is None or key > best_key:\n                        best = c\n                        best_key = key\n                new[u-1] = best\n                meta = 'Local\/Recolor-MaxDrop'\n            else:\n                # Kempe with a lower color to try to free u\n                pool = [c for c in range(1, k) if c != new[u-1]]\n                if pool:\n                    c2 = random.choice(pool)\n                    flipped = kempe_flip(new, u, c2)\n                    new = flipped\n                    meta = 'Local\/Kempe(k,c)'\n                else:\n                    # fallback small recolor anywhere using LCV\n                    w = random.randrange(1, n+1)\n                    new[w-1] = lcv_color(w, new, k)\n                    meta = 'Local\/Recolor-LCV'\n        else:\n            # General Kempe flip between existing colors\n            if k >= 2 and random.random() < 0.8:\n                u = random.randrange(1, n+1)\n                cu = new[u-1]\n                pool = [c for c in range(1, k+1) if c != cu]\n                c2 = random.choice(pool)\n                new = kempe_flip(new, u, c2)\n                meta = 'Local\/Kempe'\n            else:\n                u = random.randrange(1, n+1)\n                new[u-1] = lcv_color(u, new, k)\n                meta = 'Local\/Recolor-LCV'\n\n    new = canonicalize(new)\n    if max(new) > k:\n        # enforce palette cap strictly (should not happen by construction)\n        uniq = sorted(set(new))\n        relabel = {c: i+1 for i, c in enumerate(uniq[:k])}\n        for c in uniq[k:]:\n            relabel[c] = k\n        new = [relabel[c] for c in new]\n        new = canonicalize(new)\n\n    return (encode(new), meta)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong diversification without increasing palette size.\n    Sequence:\n    - Perform s in {2..4} Kempe flips involving existing colors.\n    - Randomly recolor m in {1..3} vertices with LCV within palette 1..k.\n    Returns (encoded_solution, meta_str)\n    \"\"\"\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    def encode(cols):\n        return ','.join(str(x) for x in cols)\n\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in cols:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def lcv_color(u, colors, palette_max):\n        used = set(colors[v-1] for v in adj[u])\n        feas = [c for c in range(1, palette_max + 1) if c not in used]\n        if not feas:\n            return colors[u-1]\n        best = None\n        best_key = None\n        for c in feas:\n            impact = 0\n            for v in adj[u]:\n                nbr_colors = set(colors[w-1] for w in adj[v])\n                if c in nbr_colors:\n                    impact += 1\n            key = (-(impact), -c)\n            if best is None or key > best_key:\n                best = c\n                best_key = key\n        return best\n\n    def kempe_flip(colors, u, c2):\n        cu = colors[u-1]\n        if cu == c2:\n            return colors[:]\n        stack = [u]\n        visited = set([u])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if colors[y-1] in (cu, c2) and y not in visited:\n                    visited.add(y)\n                    stack.append(y)\n        newc = colors[:]\n        for x in visited:\n            newc[x-1] = c2 if newc[x-1] == cu else cu\n        return newc\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = [1,1,2,3,2,3,4,2,4]  # feasible seed\n    cols = canonicalize(cols)\n    k = max(cols) if cols else 1\n\n    new = cols[:]\n\n    # s Kempe flips between existing colors\n    s = random.randint(2, 4)\n    for _ in range(s):\n        u = random.randrange(1, n + 1)\n        cu = new[u-1]\n        pool = [c for c in range(1, k+1) if c != cu]\n        if not pool:\n            continue\n        c2 = random.choice(pool)\n        new = kempe_flip(new, u, c2)\n\n    # m random LCV recolors within 1..k\n    m = random.randint(1, 3)\n    idxs = random.sample(range(1, n + 1), m)\n    for u in idxs:\n        new[u-1] = lcv_color(u, new, k)\n\n    new = canonicalize(new)\n    if max(new) > k:\n        uniq = sorted(set(new))\n        relabel = {c: i + 1 for i, c in enumerate(uniq[:k])}\n        for c in uniq[k:]:\n            relabel[c] = k\n        new = [relabel[c] for c in new]\n        new = canonicalize(new)\n\n    return (encode(new), 'Perturb\/KempeLCV')\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph and parameters (embedded; no globals)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000.0\n    PENALTY_VIOLATION = 1_000_000.0  # ensure feasibility prioritized over color count\n    PENALTY_VALUE = 100.0\n\n    # Coerce\n    try:\n        seq = list(solution)\n    except Exception:\n        return PENALTY_INVALID\n    if len(seq) != n:\n        return math.fsum([PENALTY_INVALID, abs(len(seq) - n) * PENALTY_VALUE])\n\n    colors = [1]*n\n    invalid_values = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        if isinstance(v, bool):\n            x = 0\n        if x < 1:\n            invalid_values += 1\n            x = 1\n        colors[i] = x\n\n    max_color = max(colors) if colors else 1\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return math.fsum([\n            PENALTY_INVALID,\n            invalid_values * PENALTY_VALUE,\n            violations * PENALTY_VIOLATION,\n            float(max_color)\n        ])\n\n    return float(max_color)\n\n# Optional: Simulated Annealing core for integrators expecting a ready heuristic\n# Note: Uses injected generate_neighbour and evaluate_solution callables.\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    curr = list(currentSolution)\n    curr_score = float(evaluate_solution(curr))\n    if best is None:\n        best = list(curr)\n        best_score = curr_score\n    T = float(temp)\n    stagnation = 0\n    while T > float(minTemp):\n        neigh_tuple = generate_neighbour(curr)\n        # Expect (new_solution, NB_Type, Movement_Type)\n        if isinstance(neigh_tuple, tuple) and len(neigh_tuple) >= 1:\n            candidate = list(neigh_tuple[0])\n        else:\n            candidate = list(curr)\n        cand_score = float(evaluate_solution(candidate))\n        delta = cand_score - curr_score\n        accept = False\n        if delta <= 0:\n            accept = True\n        else:\n            # Metropolis criterion\n            try:\n                prob = math.exp(-delta \/ max(T, 1e-12))\n            except OverflowError:\n                prob = 0.0\n            if random.random() < prob:\n                accept = True\n        if accept:\n            curr = candidate\n            curr_score = cand_score\n            stagnation = 0\n            if curr_score < best_score:\n                best = list(curr)\n                best_score = curr_score\n        else:\n            stagnation += 1\n        # Simple cooling with occasional reheat on stagnation\n        T *= float(cooling_factor)\n        if stagnation > 200:\n            T = max(T * 1.5, temp * 0.5)\n            stagnation = 0\n    return {\"current\": curr, \"currentScore\": curr_score, \"best\": best, \"bestScore\": best_score}\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-directed recoloring with color-reduction pressure\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Coerce to valid list length 9, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    max_c = max(curr) if curr else 1\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n            total_conflicts += 1\n\n    neigh = curr[:]\n\n    if total_conflicts > 0:\n        # Pick a most-conflicted vertex\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == max(conflicts)]\n        v = random.choice(cand_vertices)\n        # Try smallest feasible color in [1, max_c]\n        neighbor_colors = {curr[u] for u in adj[v]}\n        chosen = None\n        for color in range(1, max_c+0):  # attempt 1..(max_c-1) first to bias reduction\n            if color == curr[v]:\n                continue\n            if color not in neighbor_colors:\n                chosen = color\n                break\n        if chosen is None:\n            # Try any color in 1..max_c\n            for color in range(1, max_c+1):\n                if color != curr[v] and color not in neighbor_colors:\n                    chosen = color\n                    break\n        if chosen is None:\n            # If all colors conflict, pick the one minimizing conflicts (still within 1..max_c)\n            best_c = curr[v]\n            best_cnt = len(adj[v]) + 1\n            for color in range(1, max_c+1):\n                if color == curr[v]:\n                    continue\n                cnt = 0\n                for u in adj[v]:\n                    if curr[u] == color:\n                        cnt += 1\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = color\n            chosen = best_c\n        neigh[v] = chosen\n        return (neigh, \"ConflictDirected\", \"SingleVertexRecolor\")\n    else:\n        # Feasible: try to eliminate highest color class\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n        # Try recoloring any of them to [1..max_c-1]\n        moved = False\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color not in neighbor_colors:\n                    neigh[v] = color\n                    moved = True\n                    break\n            if moved:\n                break\n        if moved:\n            return (neigh, \"ColorReduction\", \"TargetHighestClass\")\n        # If cannot reduce, perform a diversification recolor that maintains max_c\n        v = random.randrange(n)\n        neighbor_colors = {curr[u] for u in adj[v]}\n        options = [c for c in range(1, max_c+1) if c != curr[v] and c not in neighbor_colors]\n        if options:\n            neigh[v] = random.choice(options)\n            return (neigh, \"Diversify\", \"FeasibleRecolor\")\n        # fallback: swap labels of two lower colors to reshuffle\n        if max_c >= 2:\n            a, b = 1, 2\n            if max_c > 2:\n                a = random.randint(1, max_c-1)\n                b = random.randint(1, max_c-1)\n                if a == b:\n                    b = max(1, (a % (max_c-1)) + 1)\n            for i in range(n):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, \"LabelSwap\", \"ColorSwap\")\n        return (neigh, \"NoOp\", \"Identity\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Shake: recolor k vertices among the most conflicted; allow colors up to current max\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    max_c = max(curr) if curr else 1\n\n    # Conflicts per vertex\n    conflicts = [0]*n\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    order = list(range(n))\n    order.sort(key=lambda i: conflicts[i], reverse=True)\n    k = min(4, max(2, n \/\/ 4))  # choose 2..4 vertices\n    idxs = order[:k]\n\n    out = curr[:]\n    for i in idxs:\n        # assign a random color within existing range to avoid unnecessary color increases\n        out[i] = random.randint(1, max_c)\n        if out[i] < 1:\n            out[i] = 1\n    return out\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 1_000_000.0\n    PENALTY_VIOLATION = 1_000_000.0\n    PENALTY_VALUE = 100.0\n\n    # Coerce to integer list of length n\n    try:\n        seq = list(solution)\n    except Exception:\n        return PENALTY_INVALID\n    if len(seq) != n:\n        return math.fsum([PENALTY_INVALID, abs(len(seq) - n) * PENALTY_VALUE])\n\n    colors = [1]*n\n    invalid_values = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        if isinstance(v, bool):\n            x = 0\n        if x < 1:\n            invalid_values += 1\n            x = 1\n        colors[i] = x\n\n    max_color = max(colors) if colors else 1\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        # strong feasibility pressure; include max_color as tie breaker\n        return math.fsum([\n            PENALTY_INVALID,\n            invalid_values * PENALTY_VALUE,\n            (violations ** 2) * PENALTY_VIOLATION,\n            float(max_color)\n        ])\n\n    return float(max_color)\n","Vecindad":"import random\nimport math\n\n# Returns: (new_solution, NB_Type, Movement_Type)\n# Signature annotation kept as required by integrator spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Coerce to valid list length n, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Current max color\n    max_c = max(curr) if curr else 1\n\n    # Compute conflicts\n    conflicts = [0]*n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n            total_conflicts += 1\n\n    neigh = curr[:]\n\n    if total_conflicts > 0:\n        # Conflict-directed recolor with Kempe-chain escape\n        worst = max(conflicts)\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == worst]\n        v = random.choice(cand_vertices)\n        neighbor_colors = {curr[u] for u in adj[v]}\n        # Phase 1: try smallest feasible color in 1..max_c excluding current color\n        for color in range(1, max_c+1):\n            if color != curr[v] and color not in neighbor_colors:\n                neigh[v] = color\n                return (neigh, \"ConflictDirected\", \"SingleVertexRecolor\")\n        # Phase 2: Kempe-chain swap with a conflicting neighbor color\n        # pick a color t present in neighbors; swap colors curr[v] <-> t in the connected component containing v\n        if neighbor_colors:\n            t = random.choice(list(neighbor_colors))\n            a = curr[v]\n            # BFS on subgraph induced by colors {a, t}\n            visited = [False]*n\n            queue = [v]\n            visited[v] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                if curr[x] == a or curr[x] == t:\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and (curr[y] == a or curr[y] == t):\n                            visited[y] = True\n                            queue.append(y)\n            # Swap colors on this component\n            alt = curr[:]\n            for x in comp:\n                alt[x] = t if curr[x] == a else a\n            # Accept if it reduces conflicts or keeps same but changes structure\n            def count_conf(sol):\n                c = 0\n                for (uu, vv) in edges:\n                    if sol[uu-1] == sol[vv-1]:\n                        c += 1\n                return c\n            if count_conf(alt) <= total_conflicts:\n                return (alt, \"Kempe\", \"TwoColorSwap\")\n        # Fallback: randomized recolor within 1..max_c minimizing local conflicts\n        best_color = curr[v]\n        best_cnt = len(adj[v]) + 1\n        for color in range(1, max_c+1):\n            if color == curr[v]:\n                continue\n            cnt = 0\n            for u in adj[v]:\n                if curr[u] == color:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_color = color\n        neigh[v] = best_color\n        return (neigh, \"ConflictDirected\", \"MinLocalConf\")\n    else:\n        # Feasible: attempt color reduction from highest class\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color not in neighbor_colors:\n                    neigh[v] = color\n                    return (neigh, \"ColorReduction\", \"LowerRecolor\")\n        # If cannot reduce max color, try relabeling two lower colors to diversify\n        if max_c >= 2:\n            a = random.randint(1, max(1, max_c-1))\n            b = random.randint(1, max(1, max_c-1))\n            if a == b:\n                b = (a % max(1, max_c-1)) + 1\n            for i in range(n):\n                if curr[i] == a:\n                    neigh[i] = b\n                elif curr[i] == b:\n                    neigh[i] = a\n            return (neigh, \"Diversify\", \"ColorRelabel\")\n        return (neigh, \"NoOp\", \"Identity\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1]*n\n    if len(curr) < n:\n        curr = curr + [1]*(n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Compute conflicts per vertex\n    conflicts = [0]*n\n    for (u, v) in edges:\n        if curr[u-1] == curr[v-1]:\n            conflicts[u-1] += 1\n            conflicts[v-1] += 1\n\n    order = list(range(n))\n    order.sort(key=lambda i: conflicts[i], reverse=True)\n    k = min(4, max(2, n \/\/ 4))\n    idxs = order[:k]\n\n    max_c = max(curr) if curr else 1\n    out = curr[:]\n    for i in idxs:\n        out[i] = random.randint(1, max_c)\n        if out[i] < 1:\n            out[i] = 1\n    return out\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_COLORS","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges_1based = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Precompute 0-based edges once\n    edges = [(u-1, v-1) for (u, v) in edges_1based]\n    # Calibrated penalties\n    BASE_INVALID = 1_000_000.0\n    VIOLATION_W = 10_000.0\n    MAXVIO_W = 100.0\n\n    # Coerce to list\n    try:\n        seq = list(solution)\n    except Exception:\n        return BASE_INVALID\n\n    if len(seq) != n:\n        return BASE_INVALID + VIOLATION_W * float(abs(len(seq) - n))\n\n    # Parse and validate strictly positive integers\n    colors = [0] * n\n    invalids = 0\n    for i, v in enumerate(seq):\n        try:\n            x = int(v)\n        except Exception:\n            x = 0\n        # Reject booleans and non-positive\n        if isinstance(v, bool) or x <= 0:\n            invalids += 1\n            continue\n        colors[i] = x\n\n    if invalids > 0:\n        return BASE_INVALID + VIOLATION_W * float(invalids)\n\n    max_color = max(colors) if colors else 1\n\n    # Count constraint violations\n    violations = 0\n    vertex_conf = [0] * n\n    for (u, v) in edges:\n        if colors[u] == colors[v]:\n            violations += 1\n            vertex_conf[u] += 1\n            vertex_conf[v] += 1\n\n    if violations > 0:\n        # Linear violation cost + tie-breakers\n        max_vertex_conf = max(vertex_conf) if vertex_conf else 0\n        return math.fsum([\n            BASE_INVALID,\n            VIOLATION_W * float(violations),\n            MAXVIO_W * float(max_vertex_conf),\n            1e-3 * float(max_color)\n        ])\n\n    # Feasible: minimize K=max_color with light tie-break on sum of colors\n    return float(max_color) + 1e-3 * float(sum(colors))\n","Vecindad":"import random\nimport math\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges_1based = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1based]\n\n    # Coerce to valid list of length n with min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1] * n\n    if len(curr) < n:\n        curr = curr + [1] * (n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conf(sol: List[int]) -> Tuple[int, List[int]]:\n        vc = [0] * n\n        tot = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                tot += 1\n                vc[u] += 1\n                vc[v] += 1\n        return tot, vc\n\n    def max_color_of(sol: List[int]) -> int:\n        return max(sol) if sol else 1\n\n    total_conf, conflicts = count_conf(curr)\n    max_c = max_color_of(curr)\n\n    neigh = curr[:]\n\n    if total_conf > 0:\n        # Conflict-directed move: choose vertex with highest conflicts\n        worst = max(conflicts)\n        cand_vertices = [i for i, c in enumerate(conflicts) if c == worst]\n        v = random.choice(cand_vertices)\n        neighbor_colors = {curr[u] for u in adj[v]}\n\n        # Try best recolor minimizing resulting total conflicts; prefer not increasing max color\n        best_sol = None\n        best_score = (math.inf, math.inf)  # (total_conflicts, max_color)\n        for color in range(1, max_c + 1):\n            if color == curr[v]:\n                continue\n            if color in neighbor_colors:\n                continue\n            trial = curr[:]\n            trial[v] = color\n            tc, _ = count_conf(trial)\n            mc = max_color_of(trial)\n            sc = (tc, mc)\n            if sc < best_score:\n                best_score = sc\n                best_sol = trial\n        if best_sol is not None:\n            # Ensure length\n            if len(best_sol) != n:\n                best_sol = best_sol[:n] + [1] * max(0, n - len(best_sol))\n            return (best_sol, \"ConflictDirected\", \"SingleVertexRecolor\")\n\n        # Kempe-chain swap with a conflicting neighbor color (tie-breakers: conflicts, reduce max-color load)\n        if neighbor_colors:\n            t = random.choice(list(neighbor_colors))\n            a = curr[v]\n            visited = [False] * n\n            queue = [v]\n            visited[v] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                if curr[x] == a or curr[x] == t:\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and (curr[y] == a or curr[y] == t):\n                            visited[y] = True\n                            queue.append(y)\n            alt = curr[:]\n            for x in comp:\n                alt[x] = t if curr[x] == a else a\n            tc_alt, _ = count_conf(alt)\n            if tc_alt <= total_conf:\n                # Prefer swaps that reduce max color or reduce count of max-color vertices\n                mc_curr = max_c\n                mc_alt = max_color_of(alt)\n                if mc_alt < mc_curr:\n                    if len(alt) != n:\n                        alt = alt[:n] + [1] * max(0, n - len(alt))\n                    return (alt, \"Kempe\", \"TwoColorSwap\")\n                else:\n                    # Count vertices in max color class before\/after\n                    cnt_curr = sum(1 for x in curr if x == mc_curr)\n                    cnt_alt = sum(1 for x in alt if x == mc_alt)\n                    if cnt_alt <= cnt_curr:\n                        if len(alt) != n:\n                            alt = alt[:n] + [1] * max(0, n - len(alt))\n                        return (alt, \"Kempe\", \"TwoColorSwap\")\n        \n        # Fallback: randomized recolor within 1..max_c minimizing local conflicts\n        best_color = curr[v]\n        best_cnt = len(adj[v]) + 1\n        for color in range(1, max_c + 1):\n            if color == curr[v]:\n                continue\n            cnt = 0\n            for u in adj[v]:\n                if curr[u] == color:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_color = color\n        neigh[v] = best_color\n        if len(neigh) != n:\n            neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n        return (neigh, \"ConflictDirected\", \"MinLocalConf\")\n    else:\n        # Feasible: attempt color reduction from highest class, evaluate all candidates\n        target_color = max_c\n        candidates = [i for i, c in enumerate(curr) if c == target_color]\n        random.shuffle(candidates)\n\n        best_move = None\n        best_after = (math.inf, math.inf, math.inf)  # (max_color, sum_colors, vertex_degree)\n        for v in candidates:\n            neighbor_colors = {curr[u] for u in adj[v]}\n            for color in range(1, max_c):\n                if color in neighbor_colors:\n                    continue\n                trial = curr[:]\n                trial[v] = color\n                # Feasibility preserved by construction; evaluate tie-breakers\n                mc = max_color_of(trial)\n                sc = sum(trial)\n                deg = len(adj[v])\n                key = (mc, sc, -deg)  # prefer lowering max color, then lower sum, then higher-degree moves\n                if key < best_after:\n                    best_after = key\n                    best_move = trial\n        if best_move is not None and max_color_of(best_move) <= max_c:\n            if len(best_move) != n:\n                best_move = best_move[:n] + [1] * max(0, n - len(best_move))\n            return (best_move, \"ColorReduction\", \"LowerRecolor\")\n\n        # Diversification: color relabel including max color; occasional 3-cycle relabel\n        neigh = curr[:]\n        if max_c >= 2:\n            if random.random() < 0.25 and max_c >= 3:\n                # 3-cycle relabel among three distinct colors\n                a, b, c = random.sample(range(1, max_c + 1), 3)\n                for i in range(n):\n                    if neigh[i] == a:\n                        neigh[i] = b\n                    elif neigh[i] == b:\n                        neigh[i] = c\n                    elif neigh[i] == c:\n                        neigh[i] = a\n                if len(neigh) != n:\n                    neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n                return (neigh, \"Diversify\", \"Relabel3Cycle\")\n            else:\n                a, b = random.sample(range(1, max_c + 1), 2)\n                for i in range(n):\n                    if neigh[i] == a:\n                        neigh[i] = b\n                    elif neigh[i] == b:\n                        neigh[i] = a\n                if len(neigh) != n:\n                    neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n                return (neigh, \"Diversify\", \"ColorRelabel\")\n        # No change possible\n        if len(neigh) != n:\n            neigh = neigh[:n] + [1] * max(0, n - len(neigh))\n        return (neigh, \"NoOp\", \"Identity\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges_1based = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1based]\n\n    # Coerce to valid list length n, min color 1\n    try:\n        curr = list(solution)\n    except Exception:\n        curr = [1] * n\n    if len(curr) < n:\n        curr = curr + [1] * (n - len(curr))\n    elif len(curr) > n:\n        curr = curr[:n]\n    for i, v in enumerate(curr):\n        try:\n            x = int(v)\n        except Exception:\n            x = 1\n        if isinstance(v, bool) or x < 1:\n            x = 1\n        curr[i] = x\n\n    def max_color_of(sol):\n        return max(sol) if sol else 1\n\n    # Choose number of perturb operations\n    ops = random.randint(2, 4)\n    out = curr[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    for _ in range(ops):\n        choice = random.random()\n        max_c = max_color_of(out)\n        if choice < 0.5:\n            # Random vertex recolor within [1..max_c]\n            i = random.randrange(n)\n            new_c = random.randint(1, max(1, max_c))\n            out[i] = new_c if new_c >= 1 else 1\n        elif choice < 0.8:\n            # Kempe-chain swap seeded at random vertex and neighbor color (if exists)\n            v = random.randrange(n)\n            if adj[v]:\n                neighbor_colors = {out[u] for u in adj[v]}\n                if neighbor_colors:\n                    a = out[v]\n                    t = random.choice(list(neighbor_colors))\n                    visited = [False] * n\n                    stack = [v]\n                    visited[v] = True\n                    comp = []\n                    while stack:\n                        x = stack.pop()\n                        if out[x] == a or out[x] == t:\n                            comp.append(x)\n                            for y in adj[x]:\n                                if not visited[y] and (out[y] == a or out[y] == t):\n                                    visited[y] = True\n                                    stack.append(y)\n                    for x in comp:\n                        out[x] = t if out[x] == a else a\n        else:\n            # Color relabel (swap two colors or 3-cycle if >=3 colors)\n            if max_c >= 3 and random.random() < 0.4:\n                a, b, c = random.sample(range(1, max_c + 1), 3)\n                for i in range(n):\n                    if out[i] == a:\n                        out[i] = b\n                    elif out[i] == b:\n                        out[i] = c\n                    elif out[i] == c:\n                        out[i] = a\n            elif max_c >= 2:\n                a, b = random.sample(range(1, max_c + 1), 2)\n                for i in range(n):\n                    if out[i] == a:\n                        out[i] = b\n                    elif out[i] == b:\n                        out[i] = a\n\n    # Ensure output integrity\n    if len(out) != n:\n        out = out[:n] + [1] * max(0, n - len(out))\n    for i in range(n):\n        try:\n            x = int(out[i])\n        except Exception:\n            x = 1\n        if isinstance(out[i], bool) or x < 1:\n            x = 1\n        out[i] = x\n\n    return out\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci >= 1 denotes the color of vertex i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Canonical, lexicographic evaluation: minimize conflicts first, then number of colors\n    # Fitness = conflicts*W + k_used, with W >> n to dominate by conflicts while keeping gradient within infeasible region\n    W = 1000\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to remove symmetry: map first-appearance order to 1..k\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors used\n    k_used = len(set(canonical))\n\n    return conflicts * W + k_used\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor; when feasible, attempt color reduction from highest color\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def canonicalize(sol):\n        mapping = {}\n        next_label = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            res.append(mapping[c])\n        return res\n\n    sol = canonicalize(sanitize(solution))\n\n    # Compute conflicts\n    conflicts = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n\n    move_desc = \"\"\n\n    if conflicts:\n        # Pick a conflicted vertex and try a legal color among existing palette\n        v = random.choice(list(conflicts))\n        neighbor_colors = {sol[w] for w in adj[v]}\n        palette = sorted(set(sol))\n        legal = [c for c in palette if c not in neighbor_colors and c != sol[v]]\n        if legal:\n            new_color = random.choice(legal)\n            nb = sol.copy()\n            nb[v] = new_color\n            move_desc = f\"conflict-recolor-v{v+1}-to-{new_color}\"\n            return canonicalize(nb), move_desc\n        else:\n            # No legal among current colors: pick color minimizing new conflicts; very small chance to introduce new color\n            allow_new = (random.random() < 0.02)\n            candidate_colors = palette.copy()\n            if allow_new:\n                candidate_colors.append(max(palette)+1)\n            best_c = sol[v]\n            best_delta = 10**9\n            for c in candidate_colors:\n                if c == sol[v]:\n                    continue\n                # conflicts introduced if any neighbor has color c\n                delta = sum(1 for w in adj[v] if sol[w] == c) - sum(1 for w in adj[v] if sol[w] == sol[v])\n                if delta < best_delta:\n                    best_delta = delta\n                    best_c = c\n            nb = sol.copy()\n            nb[v] = best_c\n            move_desc = f\"conflict-min-recolor-v{v+1}-to-{best_c}\"\n            return canonicalize(nb), move_desc\n    else:\n        # Feasible: try to reduce number of colors by moving a vertex from the highest color down\n        palette = sorted(set(sol))\n        if len(palette) <= 1:\n            return sol, \"noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        random.shuffle(vertices_max)\n        # Try for each vertex in max color to move to lowest legal color\n        for v in vertices_max:\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol.copy()\n                nb[v] = new_color\n                move_desc = f\"reduce-k-move-v{v+1}-to-{new_color}\"\n                return canonicalize(nb), move_desc\n        # If moving a single vertex fails, attempt swapping this vertex with a lower color (may open paths)\n        v = random.choice(vertices_max)\n        lower_colors = [c for c in palette if c < max_color]\n        if lower_colors:\n            swap_color = random.choice(lower_colors)\n            nb = sol.copy()\n            nb[v] = swap_color\n            move_desc = f\"swap-attempt-v{v+1}-to-{swap_color}\"\n            return canonicalize(nb), move_desc\n        return sol, \"noop\"\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Color-merge perturbation + greedy repair, then canonicalize\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 3) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def canonicalize(sol):\n        mapping = {}\n        next_label = 1\n        res = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            res.append(mapping[c])\n        return res\n\n    sol = canonicalize(sanitize(solution))\n\n    palette = sorted(set(sol))\n    if len(palette) < 2:\n        return sol\n\n    # Pick two distinct colors a (keep) and b (merge into a)\n    a, b = random.sample(palette, 2)\n    keep, drop = (a, b)\n    pert = [keep if c == drop else c for c in sol]\n\n    # Greedy repair: process conflicted vertices; try smallest legal color, else introduce a new color with low probability\n    def repair(conf):\n        changed = True\n        while changed:\n            changed = False\n            for (u, v) in edges:\n                if conf[u-1] == conf[v-1]:\n                    # Choose one endpoint to recolor (higher degree heuristic)\n                    cand = u-1 if len(adj[u-1]) >= len(adj[v-1]) else v-1\n                    neighbor_colors = {conf[w] for w in adj[cand]}\n                    palette_local = sorted(set(conf))\n                    legal = [c for c in palette_local if c not in neighbor_colors]\n                    if legal:\n                        # prefer smallest legal\n                        conf[cand] = legal[0]\n                    else:\n                        # very rarely introduce a new color to break deadlock\n                        if random.random() < 0.05:\n                            conf[cand] = max(palette_local) + 1\n                        else:\n                            # fallback: recolor to color minimizing conflicts\n                            best_c = conf[cand]\n                            best_cnt = len(adj[cand]) + 1\n                            for c in palette_local:\n                                cnt = sum(1 for w in adj[cand] if conf[w] == c)\n                                if cnt < best_cnt:\n                                    best_cnt = cnt\n                                    best_c = c\n                            conf[cand] = best_c\n                    changed = True\n        return conf\n\n    pert = repair(pert)\n\n    # Optional random extra recolors to diversify\n    steps = random.randint(1, 3)\n    for _ in range(steps):\n        i = random.randrange(n)\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette_local = sorted(set(pert))\n        legal = [c for c in palette_local if c not in neighbor_colors]\n        if legal:\n            pert[i] = random.choice(legal)\n\n    return canonicalize(pert)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of 9 positive integers [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci>=1 denotes the color of vertex i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Problem data (embedded)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to normalize symmetry\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors\n    k_used = len(set(canonical))\n\n    # Scalarized objective: W = |E|+1 = 22 to strictly dominate k with conflicts\n    W = 22\n    return conflicts * W + k_used\n","Vecindad":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def conflicts_of_vertex(sol, v):\n        c = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == c)\n\n    def saturation_degree(sol, v):\n        return len({sol[w] for w in adj[v]})\n\n    def kempe_swap(sol, v, target_color):\n        # Perform Kempe chain swap on colors a=sol[v] and b=target_color in the connected component containing v\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        in_component = []\n        while q:\n            x = q.popleft()\n            in_component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in in_component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    palette = sorted(set(sol))\n    move_desc = \"noop\"\n\n    if conflicted:\n        # Choose vertex by (conflicts, saturation, degree)\n        def score(v):\n            return (conflicts_of_vertex(sol, v), saturation_degree(sol, v), len(adj[v]))\n        v = max(conflicted, key=score)\n        neighbor_colors = {sol[w] for w in adj[v]}\n        legal = [c for c in palette if c != sol[v] and c not in neighbor_colors]\n        if legal:\n            new_color = min(legal)\n            nb = sol[:]\n            nb[v] = new_color\n            return nb, f\"conflict-recolor-v{v+1}-to-{new_color}\"\n        else:\n            # Try Kempe swap with color minimizing post-conflicts at v (no new colors)\n            best_nb = sol[:]\n            best_val = conflicts_of_vertex(sol, v)\n            best_c = sol[v]\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                cand = kempe_swap(sol, v, c)\n                val = sum(1 for w in adj[v] if cand[w] == cand[v])\n                if val < best_val:\n                    best_val = val\n                    best_nb = cand\n                    best_c = c\n            if best_c != sol[v]:\n                return best_nb, f\"kempe-swap-v{v+1}-with-{best_c}\"\n            # Fallback: recolor to color with minimum conflicts (still within palette)\n            best_c = sol[v]\n            best_cnt = len(adj[v]) + 1\n            for c in palette:\n                if c == sol[v]:\n                    continue\n                cnt = sum(1 for w in adj[v] if sol[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            nb = sol[:]\n            nb[v] = best_c\n            return nb, f\"min-conflict-recolor-v{v+1}-to-{best_c}\"\n    else:\n        # Feasible: attempt to reduce k by moving from max color using recolor or Kempe swap\n        if len(palette) <= 1:\n            return sol, \"noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        random.shuffle(vertices_max)\n        # Try direct recolor to lower legal color\n        for v in vertices_max:\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol[:]\n                nb[v] = new_color\n                return nb, f\"reduce-k-recolor-v{v+1}-to-{new_color}\"\n        # Try Kempe swap with a lower color to free v\n        for v in vertices_max:\n            for target in sorted(c for c in palette if c < max_color):\n                cand = kempe_swap(sol, v, target)\n                # If v now takes target and remains feasible, accept\n                feas = True\n                for w in adj[v]:\n                    if cand[w] == cand[v]:\n                        feas = False\n                        break\n                if feas:\n                    return cand, f\"reduce-k-kempe-v{v+1}-with-{target}\"\n        # As last resort, attempt swapping one vertex color down (may require later repair)\n        v = random.choice(vertices_max)\n        target = random.choice([c for c in palette if c < max_color])\n        nb = sol[:]\n        nb[v] = target\n        return nb, f\"reduce-k-swap-attempt-v{v+1}-to-{target}\"\n","Perturbacion":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 4) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def kempe_swap(sol, v, target_color):\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        component = []\n        while q:\n            x = q.popleft()\n            component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n    palette = sorted(set(sol))\n    if len(palette) < 2:\n        return sol[:]\n\n    # Perform a sequence of Kempe-chain perturbations to diversify without increasing k\n    steps = random.randint(2, 4)\n    pert = sol[:]\n    for _ in range(steps):\n        palette = sorted(set(pert))\n        v = random.randrange(n)\n        # choose a target color from current palette (different from v's color)\n        choices = [c for c in palette if c != pert[v]]\n        if not choices:\n            continue\n        t = random.choice(choices)\n        cand = kempe_swap(pert, v, t)\n        pert = cand\n\n    # Light greedy fixes for any introduced conflicts (no new colors)\n    for _ in range(n):  # bounded repairs\n        conflicted = []\n        for (u,v) in edges:\n            if pert[u-1] == pert[v-1]:\n                conflicted.append(u-1)\n                conflicted.append(v-1)\n        if not conflicted:\n            break\n        i = max(set(conflicted), key=lambda x: len([w for w in adj[x] if pert[w]==pert[x]]))\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette = sorted(set(pert))\n        legal = [c for c in palette if c != pert[i] and c not in neighbor_colors]\n        if legal:\n            pert[i] = min(legal)\n        else:\n            # fallback: choose color minimizing equal-colored neighbors, still within palette\n            best_c = pert[i]\n            best_cnt = len(adj[i]) + 1\n            for c in palette:\n                if c == pert[i]:\n                    continue\n                cnt = sum(1 for w in adj[i] if pert[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            pert[i] = best_c\n\n    return pert\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"List of length 9 with positive integers: [c1,c2,c3,c4,c5,c6,c7,c8,c9], where ci is the color of vertex i (1-based).","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n\n    # Canonicalize labels to normalize symmetry\n    mapping = {}\n    next_label = 1\n    canonical = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        canonical.append(mapping[c])\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if canonical[u - 1] == canonical[v - 1]:\n            conflicts += 1\n\n    # Number of colors used\n    k_used = len(set(canonical))\n\n    # Scalarized objective: dominate k by conflicts\n    # |E| = 21, W = 22 ensures any conflict is worse than any k change\n    W = 22\n    return conflicts * W + k_used\n","Vecindad":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [1]*n\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicts_of_vertex(sol, v):\n        c = sol[v]\n        return sum(1 for w in adj[v] if sol[w] == c)\n\n    def saturation_degree(sol, v):\n        return len({sol[w] for w in adj[v]})\n\n    def kempe_swap(sol, v, target_color):\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:], []\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        component = []\n        while q:\n            x = q.popleft()\n            component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in component:\n            out[x] = b if sol[x] == a else a\n        return out, component\n\n    sol = sanitize(solution)\n\n    # Determine phase by current conflicts\n    total_conflicts = count_conflicts(sol)\n    palette = sorted(set(sol))\n\n    if total_conflicts > 0:\n        # Conflict-reduction phase: choose vertex with deterministic tie-breaking\n        conflicted = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        if not conflicted:\n            return sol[:], \"conflict-phase-but-none\"\n\n        def score(v):\n            # higher is worse -> target to fix: conflicts, saturation, degree, then -index\n            return (\n                conflicts_of_vertex(sol, v),\n                saturation_degree(sol, v),\n                len(adj[v]),\n                -v\n            )\n        v = max(conflicted, key=score)\n\n        # Try recolor to existing palette that strictly reduces conflicts at v\n        neighbor_colors = {sol[w] for w in adj[v]}\n        best_sol = None\n        best_local = conflicts_of_vertex(sol, v)\n        best_color = sol[v]\n        for c in palette:\n            if c == sol[v]:\n                continue\n            if c in neighbor_colors:\n                continue\n            cand = sol[:]\n            cand[v] = c\n            local = conflicts_of_vertex(cand, v)\n            if local < best_local:\n                best_local = local\n                best_sol = cand\n                best_color = c\n        if best_sol is not None:\n            return best_sol, f\"conflict-recolor-v{v+1}-to-{best_color}\"\n\n        # Try Kempe swap that reduces total conflicts (strictly)\n        best_nb = None\n        best_cnt = total_conflicts\n        best_c = None\n        for c in palette:\n            if c == sol[v]:\n                continue\n            cand, comp = kempe_swap(sol, v, c)\n            cand_cnt = count_conflicts(cand)\n            if cand_cnt < best_cnt:\n                best_cnt = cand_cnt\n                best_nb = cand\n                best_c = c\n        if best_nb is not None:\n            return best_nb, f\"conflict-kempe-v{v+1}-with-{best_c}\"\n\n        # If no improving move found, return identity to signal stall\n        return sol[:], \"conflict-stall\"\n\n    else:\n        # Feasible phase: Try to reduce the number of colors without creating conflicts\n        if len(palette) <= 1:\n            return sol[:], \"feasible-noop\"\n        max_color = max(palette)\n        vertices_max = [i for i,c in enumerate(sol) if c == max_color]\n        # Try direct recolor for any max-color vertex to a lower legal color\n        for v in sorted(vertices_max):\n            neighbor_colors = {sol[w] for w in adj[v]}\n            legal_lower = [c for c in palette if c < max_color and c not in neighbor_colors]\n            if legal_lower:\n                new_color = min(legal_lower)\n                nb = sol[:]\n                nb[v] = new_color\n                # Ensure still feasible globally\n                ok = True\n                for (u,w) in edges:\n                    if nb[u-1] == nb[w-1]:\n                        ok = False\n                        break\n                if ok:\n                    return nb, f\"reduce-k-recolor-v{v+1}-to-{new_color}\"\n        # Try Kempe swap with a lower color that keeps feasibility\n        for v in sorted(vertices_max):\n            for target in [c for c in palette if c < max_color]:\n                cand, comp = kempe_swap(sol, v, target)\n                # Verify feasibility for entire solution\n                ok = True\n                for (u,w) in edges:\n                    if cand[u-1] == cand[w-1]:\n                        ok = False\n                        break\n                if ok:\n                    return cand, f\"reduce-k-kempe-v{v+1}-with-{target}\"\n        # No feasible k-reducing move found\n        return sol[:], \"feasible-noop\"\n","Perturbacion":"import math\nimport random\nimport copy\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def sanitize(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return [random.randint(1, 4) for _ in range(n)]\n        out = []\n        for c in sol:\n            out.append(c if isinstance(c, int) and c >= 1 else 1)\n        return out\n\n    def kempe_swap(sol, v, target_color):\n        a = sol[v]\n        b = target_color\n        if a == b:\n            return sol[:]\n        comp_colors = {a, b}\n        visited = [False]*n\n        q = deque([v])\n        visited[v] = True\n        component = []\n        while q:\n            x = q.popleft()\n            component.append(x)\n            for nb in adj[x]:\n                if not visited[nb] and sol[nb] in comp_colors:\n                    visited[nb] = True\n                    q.append(nb)\n        out = sol[:]\n        for x in component:\n            out[x] = b if sol[x] == a else a\n        return out\n\n    sol = sanitize(solution)\n    pert = sol[:]\n\n    # Perform 2-4 Kempe-chain swaps using existing palette to diversify\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        palette = sorted(set(pert))\n        if len(palette) < 2:\n            break\n        v = random.randrange(n)\n        choices = [c for c in palette if c != pert[v]]\n        if not choices:\n            continue\n        t = random.choice(choices)\n        cand = kempe_swap(pert, v, t)\n        pert = cand\n\n    # Light repairs without introducing new colors\n    for _ in range(n):  # bounded passes\n        conflicted = []\n        for (u,v) in edges:\n            if pert[u-1] == pert[v-1]:\n                conflicted.append(u-1)\n                conflicted.append(v-1)\n        if not conflicted:\n            break\n        i = max(set(conflicted), key=lambda x: sum(1 for w in adj[x] if pert[w]==pert[x]))\n        neighbor_colors = {pert[w] for w in adj[i]}\n        palette = sorted(set(pert))\n        legal = [c for c in palette if c != pert[i] and c not in neighbor_colors]\n        if legal:\n            pert[i] = min(legal)\n        else:\n            # fallback: color minimizing equal-colored neighbors, still within palette\n            best_c = pert[i]\n            best_cnt = len(adj[i]) + 1\n            for c in palette:\n                if c == pert[i]:\n                    continue\n                cnt = sum(1 for w in adj[i] if pert[w] == c)\n                if cnt < best_cnt:\n                    best_cnt = cnt\n                    best_c = c\n            pert[i] = best_c\n\n    return pert\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS;c[i] in {1,...,k} for vertex i (1-indexed). Labels contiguous {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Constants and graph definition (1-indexed vertices)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    HARD_PEN = 10**9\n    PEN_GAP = 2000.0\n    PEN_EDGE = 100.0\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    fitness = float(k)\n\n    # Contiguity penalty: labels must be exactly {1..k}\n    if set(solution) != set(range(1, k + 1)):\n        fitness += PEN_GAP\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local bind\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n\n    return float(fitness)\n","Vecindad":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _conflicts_of_vertex(sol, v):\n    c = sol[v-1]\n    cnt = 0\n    for nb in _adj[v]:\n        if sol[nb-1] == c:\n            cnt += 1\n    return cnt\n\ndef _total_conflicts(sol):\n    cnt = 0\n    for (u, v) in _EDGES:\n        if sol[u-1] == sol[v-1]:\n            cnt += 1\n    return cnt\n\ndef _kempe_swap(sol, color_a, color_b, start_v):\n    # BFS on subgraph induced by colors {a,b}, swap within the connected component containing start_v\n    n = len(sol)\n    if start_v < 1 or start_v > n:\n        return sol[:]\n    if sol[start_v-1] not in (color_a, color_b):\n        return sol[:]\n    target_set = {color_a, color_b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target_set:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        cv = out[v-1]\n        if cv == color_a:\n            out[v-1] = color_b\n        elif cv == color_b:\n            out[v-1] = color_a\n    return out\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _saturation(sol):\n    # returns list of (v, saturation_degree)\n    sat = []\n    for v in range(1, 10):\n        neigh_colors = set(sol[nb-1] for nb in _adj[v])\n        sat.append((v, len(neigh_colors)))\n    return sat\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, move_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input\")\n    sol = solution[:]\n    colors = list(sorted(set(sol)))\n    k = max(colors)\n\n    move_choices = [\"recolor_best\", \"kempe\", \"class_swap\", \"dsatur_recolor\"]\n    move = random.choices(move_choices, weights=[4, 3, 1, 2], k=1)[0]\n\n    if move == \"recolor_best\":\n        v = random.randrange(1, 10)\n        current = sol[v-1]\n        best_score = None\n        best_colors = []\n        for c in colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            score = _conflicts_of_vertex(tmp, v)\n            if best_score is None or score < best_score:\n                best_score = score\n                best_colors = [c]\n            elif score == best_score:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        return (sol, \"recolor_best\")\n\n    if move == \"kempe\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            # pick a start vertex that has color a or b\n            candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n            if candidates:\n                v0 = random.choice(candidates)\n                neigh = _kempe_swap(sol, a, b, v0)\n                return (neigh, f\"kempe({a},{b})\")\n        return (sol, \"kempe_noop\")\n\n    if move == \"class_swap\":\n        if len(colors) >= 2:\n            a, b = random.sample(colors, 2)\n            neigh = sol[:]\n            for i in range(9):\n                if neigh[i] == a:\n                    neigh[i] = b\n                elif neigh[i] == b:\n                    neigh[i] = a\n            return (neigh, f\"class_swap({a},{b})\")\n        return (sol, \"class_swap_noop\")\n\n    # dsatur_recolor\n    sat = _saturation(sol)\n    max_sat = max(s for _, s in sat)\n    candidates = [v for v, s in sat if s == max_sat]\n    v = random.choice(candidates)\n    current = sol[v-1]\n    neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n    # Prefer existing colors not in neighbor_colors\n    feasible = [c for c in colors if c != current and c not in neighbor_colors]\n    if feasible:\n        sol[v-1] = random.choice(feasible)\n    else:\n        # If none feasible, try any different existing color to mix\n        alt = [c for c in colors if c != current]\n        if alt:\n            sol[v-1] = random.choice(alt)\n    return (sol, \"dsatur_recolor\")\n","Perturbacion":"import random\n\n# Graph constants (1-indexed)\n_EDGES = (\n    (1,2),(1,3),(1,7),(1,9),\n    (2,6),(2,9),\n    (3,4),(3,5),(3,7),\n    (4,5),(4,6),\n    (5,6),(5,8),\n    (6,7),(6,8),\n    (7,9),\n    (8,9)\n)\n\n_adj = {i: set() for i in range(1, 10)}\nfor (u, v) in _EDGES:\n    _adj[u].add(v)\n    _adj[v].add(u)\n\ndef _vertex_conflicts(sol, v):\n    c = sol[v-1]\n    return sum(1 for nb in _adj[v] if sol[nb-1] == c)\n\ndef _total_conflicts(sol):\n    return sum(1 for (u, v) in _EDGES if sol[u-1] == sol[v-1])\n\ndef _relabel_contiguous(sol):\n    mapping = {}\n    next_label = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n        out.append(mapping[c])\n    return out\n\ndef _kempe_component_swap(sol):\n    colors = list(sorted(set(sol)))\n    if len(colors) < 2:\n        return sol[:]\n    a, b = random.sample(colors, 2)\n    # choose a start vertex carrying color a or b\n    candidates = [v for v in range(1, 10) if sol[v-1] in (a, b)]\n    if not candidates:\n        return sol[:]\n    start_v = random.choice(candidates)\n    target = {a, b}\n    visited = set([start_v])\n    stack = [start_v]\n    while stack:\n        v = stack.pop()\n        for nb in _adj[v]:\n            if nb not in visited and sol[nb-1] in target:\n                visited.add(nb)\n                stack.append(nb)\n    out = sol[:]\n    for v in visited:\n        out[v-1] = a if out[v-1] == b else (b if out[v-1] == a else out[v-1])\n    return out\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    sol = solution[:]\n\n    # Identify high-conflict vertices\n    conflicts = [(v, _vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, c in conflicts[:m]]\n\n    colors = list(sorted(set(sol)))\n    max_colors = max(colors) + 1  # allow slight expansion during perturbation\n\n    # Greedy recolor targets using limited palette 1..max_colors\n    for v in targets:\n        neighbor_colors = set(sol[nb-1] for nb in _adj[v])\n        # Prefer existing colors not used by neighbors\n        feasible = [c for c in range(1, max_colors+0) if c in colors and c not in neighbor_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: choose color minimizing immediate conflicts (including possibly new color)\n            best_c = None\n            best_val = None\n            for c in range(1, max_colors+1):\n                val = sum(1 for nb in _adj[v] if (sol[nb-1] == c))\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            sol[v-1] = best_c if best_c is not None else sol[v-1]\n        # keep colors list updated\n        colors = list(sorted(set(sol)))\n\n    # Apply a Kempe swap to further diversify\n    sol = _kempe_component_swap(sol)\n\n    # Normalize labels to contiguous 1..k' to avoid gap penalties\n    sol = _relabel_contiguous(sol)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors first\n        try_colors = list(colors)\n        random.shuffle(try_colors)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = vertex_conflicts(tmp, v)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                # fallback: pick any other color if exists\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        # Prefer existing colors not in neighbor set\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            # fallback: pick color minimizing immediate equal-neighbor count\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"LIST_INT_LEN_9_COLORS; solution is a Python list of 9 positive integers [c1..c9] with contiguous labels {1..k}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph constants (1-indexed)\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n\n    HARD_PEN = 10**12  # infeasibility barrier\n    GAP_PEN = 10**9    # non-contiguous labels barrier\n\n    # Type and length checks\n    if not isinstance(solution, list):\n        return float(HARD_PEN)\n    if len(solution) != 9:\n        return float(HARD_PEN)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(HARD_PEN)\n\n    k = max(solution)\n    if k <= 0:\n        return float(HARD_PEN)\n\n    # Edge conflicts\n    conflicts = 0\n    sol = solution  # local alias\n    for (u, v) in EDGES:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n\n    # Enforce contiguity strictly via penalty if labels not exactly {1..k}\n    contig_ok = (set(sol) == set(range(1, k + 1)))\n\n    # Lexicographic objective: minimize conflicts first, then k\n    cost = conflicts * HARD_PEN + float(k)\n    if not contig_ok:\n        cost += GAP_PEN\n\n    return float(cost)\n","Vecindad":"import random\n\n# Required signature line (informational): def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_list, move_type_string)\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    # Build adjacency\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Defensive: validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return (solution, \"invalid_input\")\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def total_conflicts(sol_list):\n        return sum(1 for (u, v) in EDGES if sol_list[u-1] == sol_list[v-1])\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_swap(sol_list, color_a, color_b, start_v):\n        if sol_list[start_v-1] not in (color_a, color_b):\n            return sol_list[:]\n        target = {color_a, color_b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == color_a:\n                out[v-1] = color_b\n            elif cv == color_b:\n                out[v-1] = color_a\n        return out\n\n    colors = sorted(set(sol))\n\n    # Select move type with bias towards targeted improvements\n    move_choices = (\"recolor_delta\", \"targeted_kempe\", \"class_swap\")\n    weights = (5, 3, 1)\n    move = random.choices(move_choices, weights=weights, k=1)[0]\n\n    if move == \"recolor_delta\":\n        # Pick a vertex with highest conflict; recolor to minimize global delta conflicts\n        conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n        max_c = max(c for _, c in conflicts)\n        cand_vs = [v for v, c in conflicts if c == max_c]\n        v = random.choice(cand_vs)\n        current = sol[v-1]\n        best_val = None\n        best_colors = []\n        # Try existing colors plus possible new color k+1 with small probability\n        k = max(sol)\n        try_colors = list(colors)\n        if random.random() < 0.15:\n            try_colors.append(k + 1)\n        random.shuffle(try_colors)\n        base_conf = total_conflicts(sol)\n        for c in try_colors:\n            if c == current:\n                continue\n            tmp = sol[:]\n            tmp[v-1] = c\n            val = total_conflicts(tmp)\n            if best_val is None or val < best_val:\n                best_val = val\n                best_colors = [c]\n            elif val == best_val:\n                best_colors.append(c)\n        if best_colors:\n            sol[v-1] = random.choice(best_colors)\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"recolor_delta\")\n\n    if move == \"targeted_kempe\":\n        # Pick a conflicted edge and perform Kempe swap on its endpoint colors\n        conflicted = [(u, v) for (u, v) in EDGES if sol[u-1] == sol[v-1]]\n        if conflicted:\n            u, v = random.choice(conflicted)\n            a = sol[u-1]\n            # Choose a neighbor color of u that differs from a if possible\n            nb_colors = list({sol[w-1] for w in adj[u] if sol[w-1] != a})\n            if nb_colors:\n                b = random.choice(nb_colors)\n            else:\n                others = [c for c in colors if c != a]\n                if not others:\n                    neigh = relabel_contiguous(sol)\n                    return (neigh, \"kempe_noop\")\n                b = random.choice(others)\n            candidates = [x for x in range(1, 10) if sol[x-1] in (a, b)]\n            start_v = random.choice([u, v]) if random.random() < 0.7 else random.choice(candidates)\n            neigh = kempe_swap(sol, a, b, start_v)\n            neigh = relabel_contiguous(neigh)\n            return (neigh, f\"kempe({a},{b})\")\n        else:\n            # If no conflicts, try merging colors by recoloring a small class\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                neigh = [ (b if x == a else x) for x in sol ]\n                neigh = relabel_contiguous(neigh)\n                return (neigh, f\"merge_color({a}->{b})\")\n            neigh = relabel_contiguous(sol)\n            return (neigh, \"kempe_noop\")\n\n    # class_swap: swap two existing color labels\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        neigh = [ (b if x == a else (a if x == b else x)) for x in sol ]\n        neigh = relabel_contiguous(neigh)\n        return (neigh, f\"class_swap({a},{b})\")\n    else:\n        neigh = relabel_contiguous(sol)\n        return (neigh, \"class_swap_noop\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem constants embedded locally\n    EDGES = (\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    )\n    adj = {i: set() for i in range(1, 10)}\n    for (u, v) in EDGES:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n\n    sol = solution[:]\n\n    def relabel_contiguous(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for c in sol_list:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(sol_list, v):\n        c = sol_list[v-1]\n        return sum(1 for nb in adj[v] if sol_list[nb-1] == c)\n\n    def kempe_component_swap(sol_list):\n        colors = sorted(set(sol_list))\n        if len(colors) < 2:\n            return sol_list[:]\n        a, b = random.sample(colors, 2)\n        # choose a start vertex carrying a or b\n        candidates = [v for v in range(1, 10) if sol_list[v-1] in (a, b)]\n        if not candidates:\n            return sol_list[:]\n        start_v = random.choice(candidates)\n        target = {a, b}\n        visited = {start_v}\n        stack = [start_v]\n        while stack:\n            v = stack.pop()\n            for nb in adj[v]:\n                if nb not in visited and sol_list[nb-1] in target:\n                    visited.add(nb)\n                    stack.append(nb)\n        out = sol_list[:]\n        for v in visited:\n            cv = out[v-1]\n            if cv == a:\n                out[v-1] = b\n            elif cv == b:\n                out[v-1] = a\n        return out\n\n    # 1) Recolor a subset of high-conflict vertices\n    conflicts = [(v, vertex_conflicts(sol, v)) for v in range(1, 10)]\n    conflicts.sort(key=lambda x: x[1], reverse=True)\n    m = max(3, len(sol)\/\/2)\n    targets = [v for v, _ in conflicts[:m]]\n\n    colors = sorted(set(sol))\n    # allow temporary introduction of one new color to escape traps\n    max_color = (max(colors) if colors else 1) + 1\n\n    for v in targets:\n        nb_colors = {sol[nb-1] for nb in adj[v]}\n        feasible = [c for c in colors if c not in nb_colors]\n        if feasible:\n            sol[v-1] = random.choice(feasible)\n        else:\n            best_c = None\n            best_val = None\n            for c in list(colors) + [max_color]:\n                val = sum(1 for nb in adj[v] if sol[nb-1] == c)\n                if best_val is None or val < best_val:\n                    best_val = val\n                    best_c = c\n            if best_c is not None:\n                sol[v-1] = best_c\n        colors = sorted(set(sol))\n\n    # 2) Apply a Kempe component swap for diversification\n    sol = kempe_component_swap(sol)\n\n    # 3) Normalize labels to contiguous {1..k'}\n    sol = relabel_contiguous(sol)\n\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return ([1,2,3,1,2,3,2,1,3], \"repair\")\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_incident_conflicts(sol, u, color):\n        cnt = 0\n        for v in adj[u]:\n            if sol[v-1] == color:\n                cnt += 1\n        return cnt\n\n    def recolor_min_conflict(sol, prefer_conflict=True):\n        # Choose vertex\n        conflicts_vertices = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts_vertices.add(u)\n                conflicts_vertices.add(v)\n        if prefer_conflict and conflicts_vertices:\n            u = random.choice(list(conflicts_vertices))\n        else:\n            u = random.randint(1, 9)\n        used = set(sol)\n        current = sol[u-1]\n        candidates = list(used)\n        # Try to stay within current colors; if impossible, allow new color\n        best_color = current\n        best_score = 10**9\n        for c in candidates:\n            if c == current:\n                continue\n            score = count_incident_conflicts(sol, u, c)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        if best_score == 0:\n            sol[u-1] = best_color\n            return sol, \"recolor-minconflict\"\n        # No conflict-free among existing colors; optionally introduce a new color\n        if random.random() < 0.5:\n            new_color = max(used) + 1\n            sol[u-1] = new_color\n            return sol, \"recolor-newcolor\"\n        else:\n            sol[u-1] = best_color\n            return sol, \"recolor-leastconflict\"\n\n    def kempe_chain_swap(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        # Choose a second color from neighbors or existing colors\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                # Nothing to swap\n                return recolor_min_conflict(sol, prefer_conflict=False)\n            cv = random.choice([c for c in used if c != cu])\n        # Build Kempe chain component of colors cu and cv containing u\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        component = []\n        while stack:\n            x = stack.pop()\n            component.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        # Swap colors cu <-> cv in the component\n        for x in component:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol, \"kempe-swap\"\n\n    def merge_move(sol):\n        # Attempt to reduce number of colors by moving a vertex from a rare color to another feasible color\n        used = list(set(sol))\n        if len(used) <= 1:\n            return recolor_min_conflict(sol, prefer_conflict=False)\n        color_counts = {c: 0 for c in used}\n        for c in sol:\n            color_counts[c] += 1\n        src = min(color_counts, key=lambda c: color_counts[c])\n        # Pick a vertex with color src\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        u = random.choice(verts)\n        # Try to assign a different existing color\n        dests = [c for c in used if c != src]\n        random.shuffle(dests)\n        for c in dests:\n            if all(sol[v-1] != c for v in adj[u]):\n                sol[u-1] = c\n                return sol, \"merge-move\"\n        # Fallback to min-conflict among dests\n        best_c = None\n        best_score = 10**9\n        for c in dests:\n            sc = count_incident_conflicts(sol, u, c)\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c is not None and best_c != sol[u-1]:\n            sol[u-1] = best_c\n            return sol, \"merge-minconflict\"\n        return recolor_min_conflict(sol, prefer_conflict=False)\n\n    # Decide operator adaptively\n    # If conflicts exist, prioritize fixing them; else use structural moves\n    has_conflict = False\n    for u, v in edges:\n        if s[u-1] == s[v-1]:\n            has_conflict = True\n            break\n\n    r = random.random()\n    if has_conflict:\n        if r < 0.7:\n            ns, mt = recolor_min_conflict(s[:], prefer_conflict=True)\n            return (ns, mt)\n        else:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n    else:\n        if r < 0.5:\n            ns, mt = kempe_chain_swap(s[:])\n            return (ns, mt)\n        else:\n            ns, mt = merge_move(s[:])\n            return (ns, mt)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return [1,2,3,1,2,3,2,1,3]\n    s = solution[:]\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def kempe_swap_once(sol):\n        u = random.randint(1, 9)\n        cu = sol[u-1]\n        neighbor_colors = {sol[v-1] for v in adj[u] if sol[v-1] != cu}\n        if neighbor_colors:\n            cv = random.choice(list(neighbor_colors))\n        else:\n            used = list(set(sol))\n            if len(used) == 1:\n                return sol\n            cv = random.choice([c for c in used if c != cu])\n        colors = {cu, cv}\n        stack = [u]\n        visited = set([u])\n        comp = []\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in colors:\n                    visited.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == cu:\n                sol[x-1] = cv\n            elif sol[x-1] == cv:\n                sol[x-1] = cu\n        return sol\n\n    def random_recolor(sol):\n        u = random.randint(1, 9)\n        used = set(sol)\n        neighbor_colors = {sol[v-1] for v in adj[u]}\n        candidates = [c for c in used if c != sol[u-1] and c not in neighbor_colors]\n        if candidates:\n            sol[u-1] = random.choice(candidates)\n            return sol\n        # Allow introducing a new color with small probability to escape traps\n        if random.random() < 0.3:\n            sol[u-1] = max(used) + 1\n            return sol\n        # Else pick least-conflict among existing\n        best_c = sol[u-1]\n        best_score = 10**9\n        for c in used:\n            if c == sol[u-1]:\n                continue\n            score = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    score += 1\n            if score < best_score:\n                best_score = score\n                best_c = c\n        sol[u-1] = best_c\n        return sol\n\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if random.random() < 0.6:\n            s = kempe_swap_once(s)\n        else:\n            s = random_recolor(s)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        # never happens, guard\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict(sol):\n        # Choose a conflicted vertex (lowest index for determinism)\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = bad[0]\n        current = sol[u-1]\n        used = sorted(set(sol))\n        best_c = current\n        best_score = 10**9\n        # Try only existing colors; do not introduce new colors during repair\n        for c in used:\n            if c == current:\n                continue\n            # Count incident conflicts if u recolored to c\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        # No improvement possible with existing colors; pick least-conflict anyway (no new color)\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        # Find smallest color class\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        src = min(colors, key=lambda c: counts[c])\n        verts = [i+1 for i, c in enumerate(sol) if c == src]\n        dest_colors = [c for c in colors if c != src]\n        # Try each vertex deterministically\n        for u in sorted(verts):\n            neighbor_colors = {sol[v-1] for v in adj[u]}\n            for dc in dest_colors:\n                if dc not in neighbor_colors:\n                    sol[u-1] = dc\n                    sol = compress_colors(sol)\n                    return sol, True\n        return sol, False\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors targeting smallest class\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        counts = {c: 0 for c in colors}\n        for c in sol:\n            counts[c] += 1\n        c1 = min(colors, key=lambda c: counts[c])\n        # pick c2 as the color most adjacent to c1 vertices to encourage elimination\n        border_counts = {c: 0 for c in colors}\n        for i, c in enumerate(sol, start=1):\n            if c != c1:\n                continue\n            for v in adj[i]:\n                border_counts[sol[v-1]] += 1\n        candidate_c2 = [c for c in colors if c != c1]\n        if not candidate_c2:\n            return sol, False\n        c2 = max(candidate_c2, key=lambda c: border_counts.get(c, 0))\n        # choose start vertex within c1 deterministically (lowest index)\n        starts = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not starts:\n            return sol, False\n        u0 = starts[0]\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        # Swap colors in component; preserves feasibility if input feasible\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        sol = compress_colors(sol)\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        # Try to reduce k via merge; if not, do a kempe swap\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; preserves feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        # pick a random start vertex and a second color different from its color\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def minconflict_recolor_step(sol):\n        # choose a conflicted vertex and recolor to least-conflict existing color\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        if not bad:\n            return sol\n        u = min(bad)\n        current = sol[u-1]\n        used = list(set(sol))\n        best = current\n        best_sc = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_sc:\n                best_sc = sc\n                best = c\n        sol[u-1] = best\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        # Random color permutation to diversify (structure-preserving)\n        colors = sorted(set(s))\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation\n        steps = random.randint(3, 6)\n        for _ in range(steps):\n            if conflict_count(s) == 0:\n                break\n            s = minconflict_recolor_step(s)\n        s = compress_colors(s)\n        return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = 10**9\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts < 0:\n        conflicts = 0\n    num_groups = len(set(solution))\n    return num_groups + conflicts * 100000\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"repair\",\"feasible\"}\n    Movement_Type in {\"recolor-minconflict\",\"merge-elim\",\"kempe-swap\",\"repair-reset\"}\n    \"\"\"\n    # Defensive check and fallback feasible reset\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return (default_solution(), (\"repair\", \"repair-reset\"))\n\n    s = solution[:]\n\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def vertices_in_conflict(sol):\n        bad = set()\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u)\n                bad.add(v)\n        return sorted(bad)\n\n    def recolor_minconflict_with_new(sol):\n        # Choose a conflicted vertex; break ties randomly\n        bad = vertices_in_conflict(sol)\n        if not bad:\n            return sol, False\n        u = random.choice(bad)\n        current = sol[u-1]\n        used = sorted(set(sol))\n        # Evaluate existing colors\n        best_c = current\n        best_score = 10**9\n        for c in used:\n            if c == current:\n                continue\n            sc = 0\n            for v in adj[u]:\n                if sol[v-1] == c:\n                    sc += 1\n            if sc < best_score:\n                best_score = sc\n                best_c = c\n        if best_score > 0:\n            # Allow a temporary new color to break conflicts fast\n            new_color = max(used) + 1\n            # Check incident conflicts if using new color (always 0 by construction)\n            sol[u-1] = new_color\n            return sol, True\n        if best_c != current:\n            sol[u-1] = best_c\n            return sol, True\n        return sol, False\n\n    def try_merge_elimination(sol):\n        # Attempt to reduce k by moving vertices from the smallest color class; iterate multiple moves\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        improved = False\n        changed = True\n        while changed:\n            changed = False\n            colors = sorted(set(sol))\n            if len(colors) <= 1:\n                break\n            # Find smallest color class\n            counts = {c: 0 for c in colors}\n            for c in sol:\n                counts[c] += 1\n            src = min(colors, key=lambda c: counts[c])\n            verts = [i+1 for i, c in enumerate(sol) if c == src]\n            dest_colors = [c for c in colors if c != src]\n            random.shuffle(verts)\n            # Try move each vertex to any compatible destination color\n            for u in verts:\n                neighbor_colors = {sol[v-1] for v in adj[u]}\n                # Order destination colors by minimal conflicts potential\n                dest_colors_sorted = sorted(dest_colors, key=lambda dc: sum(1 for v in adj[u] if sol[v-1] == dc))\n                moved = False\n                for dc in dest_colors_sorted:\n                    if dc not in neighbor_colors:\n                        sol[u-1] = dc\n                        changed = True\n                        improved = True\n                        moved = True\n                        break\n                if moved:\n                    continue\n            # If source color emptied, compress and continue\n            if all(c != src for c in sol):\n                sol = compress_colors(sol)\n        # Final attempt: if still same k, try a focused Kempe swap between src and best dest\n        return sol, improved\n\n    def kempe_swap(sol):\n        # Kempe chain swap between two colors; randomized start to avoid cycling\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol, False\n        c1 = random.choice(colors)\n        c2_choices = [c for c in colors if c != c1]\n        if not c2_choices:\n            return sol, False\n        c2 = random.choice(c2_choices)\n        # choose start vertex among those with color c1 maximizing boundary degree\n        c1_vertices = [i for i, c in enumerate(sol, start=1) if c == c1]\n        if not c1_vertices:\n            return sol, False\n        def boundary_deg(u):\n            return sum(1 for v in adj[u] if sol[v-1] == c2)\n        best_bd = max(boundary_deg(u) for u in c1_vertices)\n        candidates = [u for u in c1_vertices if boundary_deg(u) == best_bd]\n        u0 = random.choice(candidates)\n        # Build Kempe component for colors {c1, c2} containing u0\n        comp = []\n        stack = [u0]\n        seen = {u0}\n        color_set = {c1, c2}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol, True\n\n    # Main logic: repair if conflicts, else feasibility-preserving improvement\n    if count_conflicts(s) > 0:\n        ns, changed = recolor_minconflict_with_new(s[:])\n        ns = compress_colors(ns)\n        return (ns, (\"repair\", \"recolor-minconflict\"))\n    else:\n        ns, merged = try_merge_elimination(s[:])\n        if merged:\n            ns = compress_colors(ns)\n            return (ns, (\"feasible\", \"merge-elim\"))\n        ns, swapped = kempe_swap(s[:])\n        if swapped:\n            ns = compress_colors(ns)\n        return (ns, (\"feasible\", \"kempe-swap\"))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed solution; aims to preserve feasibility if input is feasible\n    def default_solution():\n        return [1, 2, 3, 1, 2, 3, 2, 1, 3]\n    if (not isinstance(solution, list) or len(solution) != 9 or\n        any((not isinstance(c, int) or c <= 0) for c in solution)):\n        return default_solution()\n\n    s = solution[:]\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = {i: set() for i in range(1, 10)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap_once(sol):\n        colors = list(set(sol))\n        if len(colors) <= 1:\n            return sol\n        u = random.randint(1, 9)\n        c1 = sol[u-1]\n        other_colors = [c for c in colors if c != c1]\n        if not other_colors:\n            return sol\n        c2 = random.choice(other_colors)\n        color_set = {c1, c2}\n        comp = []\n        stack = [u]\n        seen = {u}\n        while stack:\n            x = stack.pop()\n            comp.append(x)\n            for y in adj[x]:\n                if y not in seen and sol[y-1] in color_set:\n                    seen.add(y)\n                    stack.append(y)\n        for x in comp:\n            if sol[x-1] == c1:\n                sol[x-1] = c2\n            elif sol[x-1] == c2:\n                sol[x-1] = c1\n        return sol\n\n    def random_recolor_break_sym(sol):\n        # Occasionally move a vertex to a new color to diversify\n        i = random.randint(1, 9)\n        used = set(sol)\n        new_c = max(used) + 1\n        sol[i-1] = new_c\n        return sol\n\n    feas = (conflict_count(s) == 0)\n    if feas:\n        # Perform a few Kempe swaps and optional random recolor, then compress\n        steps = random.randint(2, 4)\n        for _ in range(steps):\n            s = kempe_swap_once(s)\n        if random.random() < 0.25:\n            s = random_recolor_break_sym(s)\n        s = compress_colors(s)\n        return s\n    else:\n        # Repair-oriented perturbation: min-conflict recolors and compression\n        for _ in range(6):\n            if conflict_count(s) == 0:\n                break\n            # pick conflicted vertex with random tie-breaking\n            bad = set()\n            for u, v in edges:\n                if s[u-1] == s[v-1]:\n                    bad.add(u)\n                    bad.add(v)\n            if not bad:\n                break\n            u = random.choice(list(bad))\n            current = s[u-1]\n            used = list(set(s))\n            # try existing colors first\n            best = current\n            best_sc = 10**9\n            for c in used:\n                if c == current:\n                    continue\n                sc = 0\n                for v in adj[u]:\n                    if s[v-1] == c:\n                        sc += 1\n                if sc < best_sc:\n                    best_sc = sc\n                    best = c\n            if best_sc > 0:\n                # allow new color to break conflicts\n                best = max(used) + 1\n            s[u-1] = best\n        s = compress_colors(s)\n        return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where position i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Strategy: prioritize conflict resolution via best-improvement recolor; otherwise color-pair swap.\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        # Create a trivial repaired solution if invalid\n        repaired = [1]*n\n        return (repaired, \"Repair\", \"ResetToOnes\")\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [max(1, int(c) if isinstance(c, int) else 1) for c in solution]\n            return (repaired, \"Repair\", \"Sanitize\")\n    K = max(solution)\n    # Build adjacency and conflict info\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    conflicts_vertices = []\n    for (u,v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts_vertices.append(u)\n            conflicts_vertices.append(v)\n    conflicts_vertices = list(set(conflicts_vertices))\n    # Helper: evaluate delta conflicts for coloring vertex i with color col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n    # Attempt 1: if conflicts exist, best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        v = random.choice(conflicts_vertices)\n        current_col = solution[v-1]\n        best_col = current_col\n        best_delta = 0\n        # Restrict palette to 1..K (no drift)\n        for col in range(1, K+1):\n            if col == current_col:\n                continue\n            d = conflict_delta(solution, v, col)\n            if d < best_delta or (d == best_delta and random.random() < 0.5):\n                best_delta = d\n                best_col = col\n        neigh = solution[:]\n        if best_col != current_col:\n            neigh[v-1] = best_col\n            return (neigh, \"Single-Vertex-Recolor\", \"BestImprovement\")\n        # fallback: random recolor different color in [1..K]\n        candidate = [c for c in range(1, K+1) if c != current_col]\n        if not candidate:\n            candidate = [1 if current_col != 1 else 2]\n        neigh[v-1] = random.choice(candidate)\n        if neigh != solution:\n            return (neigh, \"Single-Vertex-Recolor\", \"RandomRecolor\")\n    # Attempt 2: color swap between two colors (Kempe-like color class swap)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = solution[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != solution:\n            return (neigh, \"ColorClassSwap\", \"PairSwap\")\n    # Attempt 3: directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(solution, start=1) if col == K]\n    if verts_K:\n        v = random.choice(verts_K)\n        neigh = solution[:]\n        # Try smallest feasible color in [1..K-1]\n        forbidden = {solution[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh[v-1] = col\n                if neigh != solution:\n                    return (neigh, \"ReduceK\", \"GreedyFeasible\")\n    # Final fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    current_col = solution[idx]\n    cand = [c for c in range(1, K+1) if c != current_col]\n    if not cand:\n        cand = [1 if current_col != 1 else 2]\n    neigh = solution[:]\n    neigh[idx] = random.choice(cand)\n    return (neigh, \"Single-Vertex-Recolor\", \"RandomFallback\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor subset of vertices + attempt color compaction (reduce K without using K+1)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n    s = solution[:]\n    K = max(s)\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in E:\n        adj[u].add(v); adj[v].add(u)\n    # Compute degrees and conflicts\n    deg = {i: len(adj[i]) for i in adj}\n    conflicted = set()\n    for (u,v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u); conflicted.add(v)\n    # Kick parameters\n    steps = max(3, n \/\/ 3)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    # Bias toward higher degree vertices\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n    # Random recolors within [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n    # Targeted reduction: try to recolor vertices of color K into [1..K-1]\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n    # Color compaction: renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c:i+1 for i,c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    # Validate and repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            repaired = [1 if (not isinstance(c, int) or c < 1) else c for c in solution]\n            return (repaired, (\"Repair\", \"Sanitize\"))\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict list\n    conflicts_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicts_vertices.add(u)\n            conflicts_vertices.add(v)\n    conflicts_vertices = list(conflicts_vertices)\n\n    # Helper: conflict delta for recoloring vertex i to new_col\n    def conflict_delta(sol, i, new_col):\n        old = sol[i-1]\n        if new_col == old:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            nb_col = sol[nb-1]\n            if nb_col == old:\n                delta -= 1\n            if nb_col == new_col:\n                delta += 1\n        return delta\n\n    # 1) Best-improvement recolor a conflicted vertex within [1..K]\n    if conflicts_vertices:\n        best_move = None\n        best_delta = math.inf\n        for v in conflicts_vertices:\n            cur = s[v-1]\n            for col in range(1, K+1):\n                if col == cur:\n                    continue\n                d = conflict_delta(s, v, col)\n                if d < best_delta or (d == best_delta and random.random() < 0.5):\n                    best_delta = d\n                    best_move = (v, col)\n        if best_move is not None and best_delta < 0:\n            v, col = best_move\n            neigh = s[:]\n            neigh[v-1] = col\n            return (neigh, (\"Single-Vertex-Recolor\", \"BestImprovement\"))\n        # fallback random recolor on a conflicted vertex\n        v = random.choice(conflicts_vertices)\n        cur = s[v-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(palette)\n        if neigh != s:\n            return (neigh, (\"Single-Vertex-Recolor\", \"RandomRecolorConflicted\"))\n\n    # 2) Color-class swap between two colors (Kempe-like)\n    colors = list(range(1, K+1))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == c1:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = c1\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"PairSwap\"))\n\n    # 3) Directed K-reduction on a random vertex of max color\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                if neigh != s:\n                    return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n\n    # 4) Fallback: random single-vertex recolor within [1..K]\n    idx = random.randrange(n)\n    cur = s[idx]\n    palette = [c for c in range(1, K+1) if c != cur]\n    if not palette:\n        palette = [1 if cur != 1 else 2]\n    neigh = s[:]\n    neigh[idx] = random.choice(palette)\n    return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallback\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex recolors + targeted K-compaction\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return [1]*n\n\n    s = solution[:]\n    K = max(s)\n\n    # Build adjacency and degree\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n    deg = {i: len(adj[i]) for i in adj}\n\n    # Conflicted set\n    conflicted = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflicted.add(u)\n            conflicted.add(v)\n\n    # Kick parameters (adaptive to conflicts)\n    base_steps = max(3, n \/\/ 3)\n    steps = base_steps + (len(conflicted) \/\/ 2)\n    candidates = list(conflicted) if conflicted else list(range(1, n+1))\n    weights = [deg[i] for i in candidates]\n    total_w = sum(weights) if weights else 1\n\n    # Random weighted recolors using existing palette [1..K]\n    for _ in range(steps):\n        r = random.uniform(0, total_w)\n        acc = 0.0\n        pick = candidates[-1]\n        for i, w in zip(candidates, weights):\n            acc += w\n            if r <= acc:\n                pick = i\n                break\n        cur = s[pick-1]\n        palette = [c for c in range(1, K+1) if c != cur]\n        if not palette:\n            palette = [1 if cur != 1 else 2]\n        s[pick-1] = random.choice(palette)\n\n    # Targeted K-reduction and compaction\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        random.shuffle(verts_K)\n        for v in verts_K:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"LIST_INT_COLORS length=9; Python list of 9 positive integers where index i corresponds to vertex i+1.","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize: conflicts*1000 + K, lower is better\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return 10**9\n    K = max(solution)\n    conflicts = 0\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    return conflicts * 1000 + K\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        repaired = [1]*n\n        return (repaired, (\"Repair\", \"ResetToOnes\"))\n\n    # Cache graph structures on first call to avoid rebuild overhead\n    if not hasattr(generate_neighbour, \"_E\"):\n        E = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        adj = {i: set() for i in range(1, n+1)}\n        for (u, v) in E:\n            adj[u].add(v)\n            adj[v].add(u)\n        generate_neighbour._E = tuple(E)\n        generate_neighbour._adj = {k: tuple(sorted(vs)) for k, vs in adj.items()}\n        generate_neighbour._deg = {k: len(vs) for k, vs in adj.items()}\n    E = generate_neighbour._E\n    adj = generate_neighbour._adj\n\n    s = solution[:]\n    K = max(s)\n\n    # Conflict bookkeeping\n    conflict_count = [0]*(n+1)\n    conflicted_vertices = set()\n    for (u, v) in E:\n        if s[u-1] == s[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            conflicted_vertices.add(u)\n            conflicted_vertices.add(v)\n\n    # Helper: compute conflicts if vertex i is recolored to col\n    def conflicts_if(i, col):\n        cnt = 0\n        for nb in adj[i]:\n            if s[nb-1] == col:\n                cnt += 1\n        return cnt\n\n    # Helper: Kempe-chain swap of two colors c1,c2 restricted to the component containing start vertex v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        target = sol[v-1]\n        other = c2 if target == c1 else c1\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # If there are conflicts, apply min-conflicts or Kempe-chain guided move\n    if conflicted_vertices:\n        # Choose vertex with maximum conflict degree (tie-break by higher graph degree)\n        mx = -1\n        pick = None\n        for v in conflicted_vertices:\n            key = (conflict_count[v], len(adj[v]))\n            if key > (mx, -1) if pick is None else key > (conflict_count[pick], len(adj[pick])):\n                mx = conflict_count[v]\n                pick = v\n        v = pick\n        cur = s[v-1]\n        # Palette is existing colors 1..K\n        palette = list(range(1, K+1))\n        # Min-conflicts recolor with least-used tie-break to aid K reduction\n        usage = {c: 0 for c in palette}\n        for col in s:\n            usage[col] = usage.get(col, 0) + 1\n        best_cols = []\n        best_conf = math.inf\n        for col in palette:\n            if col == cur:\n                continue\n            cval = conflicts_if(v, col)\n            if cval < best_conf:\n                best_conf = cval\n                best_cols = [col]\n            elif cval == best_conf:\n                best_cols.append(col)\n        if best_cols and best_conf <= conflict_count[v]:\n            # choose least-used among best\n            best_cols.sort(key=lambda c: (usage.get(c, 0), c))\n            neigh = s[:]\n            neigh[v-1] = best_cols[0]\n            return (neigh, (\"Single-Vertex-Recolor\", \"MinConflicts\"))\n        # Try Kempe-chain between current color and a conflicting neighbor color\n        nb_colors = {s[nb-1] for nb in adj[v] if s[nb-1] == cur or nb in conflicted_vertices}\n        # If none, try any neighbor colors\n        if not nb_colors:\n            nb_colors = {s[nb-1] for nb in adj[v]}\n        for c2 in nb_colors:\n            if c2 == cur:\n                continue\n            neigh = kempe_swap_on_component(s, v, cur, c2)\n            # Accept if reduces conflicts\n            new_conf = 0\n            for (u, w) in E:\n                if neigh[u-1] == neigh[w-1]:\n                    new_conf += 1\n            old_conf = len(conflicted_vertices)\n            if new_conf < old_conf:\n                return (neigh, (\"KempeSwap\", \"ConflictReducing\"))\n        # Fallback random min-conflicts recolor\n        candidates = [c for c in palette if c != cur]\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        neigh = s[:]\n        neigh[v-1] = random.choice(candidates)\n        return (neigh, (\"Single-Vertex-Recolor\", \"RandomFallbackConflicted\"))\n\n    # If no conflicts, attempt K reduction\n    # 1) Greedy recolor vertices of max color into lower feasible colors\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    random.shuffle(verts_K)\n    for v in verts_K:\n        forbidden = {s[u-1] for u in adj[v]}\n        for col in range(1, K):\n            if col not in forbidden:\n                neigh = s[:]\n                neigh[v-1] = col\n                return (neigh, (\"ReduceK\", \"GreedyFeasible\"))\n    # 2) Kempe-chain between color K and a lower color to free a K-vertex\n    if verts_K:\n        target_v = random.choice(verts_K)\n        for c2 in range(1, K):\n            neigh = kempe_swap_on_component(s, target_v, K, c2)\n            # If target_v changed color, we reduced K usage potentially\n            if neigh[target_v-1] != K:\n                return (neigh, (\"ReduceK\", \"KempeSwapK\"))\n    # 3) Color-class swap between K and a random lower color (may help compaction)\n    if K > 1:\n        c2 = random.randrange(1, K)\n        neigh = s[:]\n        for i, col in enumerate(neigh):\n            if col == K:\n                neigh[i] = c2\n            elif col == c2:\n                neigh[i] = K\n        if neigh != s:\n            return (neigh, (\"ColorClassSwap\", \"KWithLower\"))\n    # 4) Plateau diversification: recolor vertex with largest degree to least-used lower color\n    usage = {c: 0 for c in range(1, K+1)}\n    for col in s:\n        usage[col] = usage.get(col, 0) + 1\n    idx = max(range(1, n+1), key=lambda i: len(adj[i]))\n    candidates = list(range(1, K+1))\n    candidates.sort(key=lambda c: (usage.get(c, 0), c))\n    if s[idx-1] == candidates[0] and len(candidates) > 1:\n        tgt = candidates[1]\n    else:\n        tgt = candidates[0]\n    neigh = s[:]\n    neigh[idx-1] = tgt\n    return (neigh, (\"Diversification\", \"LeastUsedColor\"))\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: multi-vertex Kempe-chain kicks, class shuffle, and ejection chains targeting max color\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        return [1]*n\n\n    # Static graph (embedded)\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    s = solution[:]\n    K = max(s)\n\n    # Helper: compute conflicts\n    def conflicts(sol):\n        cnt = 0\n        for (u, v) in E:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    # Kempe swap on component for colors c1,c2 starting at v\n    def kempe_swap_on_component(sol, v, c1, c2):\n        if sol[v-1] not in (c1, c2):\n            return sol\n        stack = [v]\n        visited = set()\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if sol[x-1] not in (c1, c2):\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if sol[nb-1] in (c1, c2):\n                    stack.append(nb)\n        if not comp:\n            return sol\n        new_sol = sol[:]\n        for x in comp:\n            new_sol[x-1] = c1 if sol[x-1] == c2 else c2\n        return new_sol\n\n    # 1) Multi-vertex Kempe-chain kicks\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.randrange(1, n+1)\n        if K == 1:\n            break\n        c1 = s[v-1]\n        c2 = random.randrange(1, K+1)\n        while c2 == c1 and K > 1:\n            c2 = random.randrange(1, K+1)\n        s = kempe_swap_on_component(s, v, c1, c2)\n\n    # 2) Color-class shuffle: pick a random color class and remap into [1..K-1] if possible\n    if K > 1:\n        cls = random.randrange(1, K+1)\n        tgt = random.randrange(1, K)\n        if tgt != cls:\n            for i, col in enumerate(s):\n                if col == cls:\n                    s[i] = tgt\n\n    # 3) Ejection chains (length 2\u20134) targeting max-color vertices\n    K = max(s)\n    verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n    chain_len = random.randint(2, 4)\n    for _ in range(chain_len):\n        if not verts_K:\n            break\n        v = random.choice(verts_K)\n        forbidden = {s[u-1] for u in adj[v]}\n        candidates = [c for c in range(1, K) if c not in forbidden] if K > 1 else [1]\n        if not candidates:\n            # if no feasible lower color, push a neighbor to another color to create room\n            nb = random.choice(list(adj[v]))\n            nb_forbidden = {s[u-1] for u in adj[nb]}\n            palette = [c for c in range(1, K+1) if c not in nb_forbidden]\n            if palette:\n                s[nb-1] = random.choice(palette)\n        else:\n            s[v-1] = random.choice(candidates)\n        K = max(s)\n        verts_K = [i for i, col in enumerate(s, start=1) if col == K]\n\n    # Post-perturb compaction: greedily push down any remaining max colors\n    changed = True\n    while changed:\n        changed = False\n        Kcur = max(s)\n        verts = [i for i, col in enumerate(s, start=1) if col == Kcur]\n        for v in verts:\n            forbidden = {s[u-1] for u in adj[v]}\n            for col in range(1, Kcur):\n                if col not in forbidden:\n                    s[v-1] = col\n                    changed = True\n                    break\n\n    # Renumber colors to eliminate gaps\n    used = sorted(set(s))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    s = [remap[c] for c in s]\n\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_1_BASED. solution is a list of 9 positive ints; however, I\/O is tolerant and also accepts a whitespace-separated string of 9 ints. Objective: minimize max color used (k).","Evaluacion":"from typing import List, Tuple\nimport math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # soft penalty weight per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    # validate entries\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = compact(arr)\n\n    # count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score","Vecindad":"from typing import List, Tuple\nimport random\n\nrandom.seed()\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        # simple fallback shape\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list for efficiency\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # identify conflicting vertices\n    conflicting = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicting.add(u-1)\n            conflicting.add(v-1)\n\n    # pick a vertex: prioritize conflicts\n    if conflicting:\n        v = random.choice(list(conflicting))\n    else:\n        v = random.randrange(n)\n\n    # candidate colors: colors used in neighborhood plus ones present, maybe exploratory new color\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n    candidates = sorted(present_colors.union(neigh_colors))\n\n    # allow exploratory new color only if currently conflicting\n    if conflicting and random.random() < 0.2:\n        candidates.append(current_max + 1)\n\n    # scoring: number of conflicts if v is colored with c\n    def conflicts_if(v_idx: int, color: int, arr: List[int]) -> int:\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = [(conflicts_if(v, c, sol), c) for c in candidates]\n    scored.sort(key=lambda t: (t[0], random.random()))\n\n    # choose among top-min conflict colors\n    best_conf = scored[0][0]\n    pool = [c for (conf, c) in scored if conf == best_conf]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n    neighbor = compact(neighbor)\n\n    return neighbor, \"Recolor\", \"SingleVertex\"","Perturbacion":"from typing import List\nimport random\n\nrandom.seed()\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors: List[int]) -> List[int]:\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # random relabeling to break symmetry\n    labels = sorted(set(sol))\n    if labels:\n        shuf = labels[:]\n        random.shuffle(shuf)\n        relabel = {old: new for new, old in enumerate(shuf, start=1)}\n        sol = [relabel.get(x, x) for x in sol]\n\n    # compute conflict degree per vertex\n    def v_conflicts(idx: int, arr: List[int]) -> int:\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # choose a set of vertices with highest conflicts (or random if no conflicts)\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = random.randint(3, 5)\n    targets = [i for (sc, i) in conf_scores[:q]]\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n\n    # greedy randomized recolor for targets\n    present_colors = sorted(set(sol))\n    for v in targets:\n        # candidate colors among present plus one exploratory\n        candidates = present_colors[:]\n        candidates.append(max(present_colors) + 1 if present_colors else 1)\n        # score by local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], random.random()))\n        pick_pool = [c for conf, c in scored[:min(2, len(scored))]]\n        sol[v] = random.choice(pick_pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    # compact colors to 1..m to ensure invariant objective comparison\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n    for x in arr:\n        if not isinstance(x, int) or x < 1:\n            return 10**12\n\n    arr = compact(arr)\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\n\nrandom.random  # reference to ensure import is used\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # compute conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    # choose vertex: bias towards higher conflict; if none, random vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates)\n    else:\n        v = random.randrange(n)\n\n    # allowed candidate colors: existing colors 1..current_max; allow current_max+1 only if v is conflicting\n    present_colors = set(c for c in sol if isinstance(c, int) and c >= 1)\n    if not present_colors:\n        present_colors = {1}\n    current_max = max(present_colors)\n\n    neigh_colors = {sol[w] for w in adj[v] if isinstance(sol[w], int) and sol[w] >= 1}\n    candidates = sorted(present_colors)\n    if conflict_counts[v] > 0:\n        # exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(current_max + 1)\n    # always consider any neighbor colors (already subset of present, but keep for completeness)\n    for c in neigh_colors:\n        if c not in candidates:\n            candidates.append(c)\n\n    # scoring for each candidate color\n    def conflicts_if(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        local_conf = conflicts_if(v, c, sol)\n        # secondary criterion: prefer smaller resulting max color\n        new_max = max(current_max if c <= current_max else c, max(sol))\n        scored.append((local_conf, new_max, random.random(), c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_local = scored[0][0]\n    pool = [t[3] for t in scored if t[0] == best_local]\n    if sol[v] in pool and len(pool) > 1:\n        pool.remove(sol[v])\n    new_c = random.choice(pool)\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    return neighbor, \"Recolor\", \"SingleVertex\"\n","Perturbacion":"import random\n\nrandom.randrange  # reference to ensure import is used\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # conflict score per vertex\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        targets = random.sample(range(n), k=q)\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol))\n    if not present_colors:\n        present_colors = [1]\n\n    for v in targets:\n        candidates = present_colors[:]\n        # allow exploratory new color\n        candidates.append(max(present_colors) + 1)\n        # evaluate local conflicts\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            # prefer smaller color numbers to aid compaction\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1], random.random()))\n        best_conf = scored[0][0]\n        pool = [c for (conf, c) in scored if conf == best_conf][:2]\n        sol[v] = random.choice(pool)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_1BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n    n = 9\n    ALPHA = 1000  # penalty per conflicting edge\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    arr = parse(solution)\n    if not isinstance(arr, list) or len(arr) != n:\n        return 10**12\n\n    arr = compact(arr)\n    if arr is None:\n        return 10**12\n\n    conflicts = 0\n    for (u, v) in E:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n\n    k = max(arr)\n    score = k + ALPHA * conflicts\n    return score\n","Vecindad":"import random\nimport math\n\nrandom.random  # keep import referenced\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # conflict count per vertex\n    conflict_counts = [0]*n\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflict_counts[u-1] += 1\n            conflict_counts[v-1] += 1\n\n    present_colors = set(sol)\n    current_max = max(present_colors) if present_colors else 1\n\n    # choose vertex\n    if any(conflict_counts):\n        max_conf = max(conflict_counts)\n        candidates_v = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        v = random.choice(candidates_v)\n    else:\n        # conflict-free: try to reduce k by targeting max-color vertices first\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if max_color_vertices:\n            v = random.choice(max_color_vertices)\n        else:\n            v = random.randrange(n)\n\n    # candidate colors: 1..current_max plus possibly current_max+1 with small probability\n    candidates = list(range(1, current_max + 1))\n    if conflict_counts[v] > 0 and random.random() < 0.15:\n        candidates.append(current_max + 1)\n\n    # local scoring: (conflicts_after, new_max_color)\n    def local_conflicts(v_idx, color, arr):\n        cnt = 0\n        for w in adj[v_idx]:\n            if arr[w] == color:\n                cnt += 1\n        return cnt\n\n    scored = []\n    for c in candidates:\n        lc = local_conflicts(v, c, sol)\n        new_max = max(c if c > current_max else current_max, max(sol))\n        # prefer fewer conflicts, then smaller max color, then smaller color index\n        scored.append((lc, new_max, c))\n\n    scored.sort(key=lambda t: (t[0], t[1], t[2]))\n    best_conf = scored[0][0]\n    pool = [t for t in scored if t[0] == best_conf]\n    # light randomness among equally best\n    choice = random.choice(pool)\n    new_c = choice[2]\n\n    neighbor = sol[:]\n    neighbor[v] = new_c\n\n    # compact to align with evaluation behavior\n    neighbor = compact(neighbor)\n    if neighbor is None:\n        neighbor = sol[:]\n\n    return neighbor, \"Recolor_SingleVertex\"\n","Perturbacion":"import random\nimport math\n\nrandom.randrange  # keep import referenced\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    E = [(1,2),(1,3),(1,7),(1,9),(2,6),(2,9),(3,4),(3,5),(3,7),(4,5),(4,6),(5,6),(5,8),(6,7),(6,8),(7,9),(8,9)]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol[:]\n        if isinstance(sol, str):\n            parts = sol.strip().replace(',', ' ').split()\n            try:\n                vals = [int(x) for x in parts]\n            except Exception:\n                return None\n            return vals\n        return None\n\n    def compact(colors):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in colors:\n            if not isinstance(c, int) or c < 1:\n                return None\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    sol = parse(solution)\n    if not isinstance(sol, list) or len(sol) != n:\n        sol = [((i % 3) + 1) for i in range(n)]\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n\n    # adjacency list\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        ui = u - 1\n        vi = v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    # helper to count vertex conflicts\n    def v_conflicts(idx, arr):\n        c = arr[idx]\n        return sum(1 for w in adj[idx] if arr[w] == c)\n\n    # select a small set of targets: prefer conflicting or max-color vertices\n    current_max = max(sol) if sol else 1\n    conf_scores = [(v_conflicts(i, sol), i) for i in range(n)]\n    conf_scores.sort(reverse=True)\n    q = 4 if n >= 4 else max(1, n\/\/2)\n    if conf_scores[0][0] == 0:\n        # no conflicts: target vertices using the maximum color to encourage k reduction\n        max_color_vertices = [i for i, c in enumerate(sol) if c == current_max]\n        if len(max_color_vertices) >= q:\n            targets = random.sample(max_color_vertices, k=q)\n        else:\n            others = [i for i in range(n) if i not in max_color_vertices]\n            extra = random.sample(others, k=max(0, q - len(max_color_vertices))) if others else []\n            targets = max_color_vertices + extra\n    else:\n        targets = [i for (_, i) in conf_scores[:q]]\n\n    present_colors = sorted(set(sol)) if sol else [1]\n\n    # perturb by recoloring targets to low-conflict colors with slight randomness\n    for v in targets:\n        candidates = list(range(1, max(present_colors) + 1))\n        # allow exploratory new color with small probability\n        if random.random() < 0.2:\n            candidates.append(max(present_colors) + 1)\n        scored = []\n        for c in candidates:\n            cnt = 0\n            for w in adj[v]:\n                if sol[w] == c:\n                    cnt += 1\n            scored.append((cnt, c))\n        scored.sort(key=lambda t: (t[0], t[1]))\n        # choose among the two best options to diversify\n        topk = [c for (cnt, c) in scored if cnt == scored[0][0]][:2]\n        sol[v] = random.choice(topk)\n        present_colors = sorted(set(sol))\n\n    sol = compact(sol)\n    if sol is None:\n        sol = [((i % 3) + 1) for i in range(n)]\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Check element domain\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Count violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","Vecindad":"import random\nimport json\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    sol = list(solution)\n\n    # Normalize colors to 1..k contiguous\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    current = sol[:]\n    kmax = max(current) if current else 1\n\n    # Conflict counts per vertex\n    conflict_deg = [0]*n\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    has_conflict = any(x > 0 for x in conflict_deg)\n\n    if has_conflict:\n        # Pick vertex with maximum conflict degree (tie-break by lowest index)\n        u = max(range(n), key=lambda i: (conflict_deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"Recolor\")\n    else:\n        # Attempt to reduce number of colors by moving a vertex from the highest color class\n        kmax = max(current) if current else 1\n        # Gather vertices by color\n        by_color = {c: [] for c in range(1, kmax+1)}\n        for i, c in enumerate(current):\n            by_color[c].append(i)\n\n        target_color = kmax\n        # Greedy recolor attempt for any vertex in target_color to a lower color\n        for u in by_color.get(target_color, []):\n            used = {current[v] for v in adj[u]}\n            for c in range(1, target_color):\n                if c not in used:\n                    new_sol = current[:]\n                    new_sol[u] = c\n                    # If target color becomes empty, normalize eliminates it\n                    new_sol = normalize_colors(new_sol)\n                    encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n                    return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"ReduceAttempt\")\n        # If not directly possible, perform a Kempe-chain swap between target_color and some lower color\n        for a in range(1, kmax):\n            if not by_color.get(target_color):\n                break\n            u = by_color[target_color][0]\n            # BFS on subgraph induced by colors {a, target_color}\n            allowed = {a, target_color}\n            visited = set()\n            comp = []\n            stack = [u]\n            while stack:\n                x = stack.pop()\n                if x in visited:\n                    continue\n                if current[x] not in allowed:\n                    continue\n                visited.add(x)\n                comp.append(x)\n                for nb in adj[x]:\n                    if current[nb] in allowed and nb not in visited:\n                        stack.append(nb)\n            new_sol = current[:]\n            for x in comp:\n                new_sol[x] = a if current[x] == target_color else target_color\n            new_sol = normalize_colors(new_sol)\n            encoded_neighbor = json.dumps({\"solution\": new_sol, \"kempe_colors\": [a, target_color]})\n            return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"KempeSwap\")\n\n        # Fallback: recolor a random vertex to the smallest feasible color (deterministic seed)\n        seed_val = 1469598103934665603\n        for x in current:\n            seed_val ^= int(x) & 0xFFFFFFFF\n            seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n        random.seed(seed_val)\n        u = random.randrange(n)\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        encoded_neighbor = json.dumps({\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]})\n        return (\"ENCODED_SOLUTION:\" + encoded_neighbor, \"RecolorFallback\")\n","Perturbacion":"import random\nimport json\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = list(solution)\n\n    # Normalize colors\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            c1 = c if (isinstance(c, int) and c >= 1) else 1\n            if c1 not in mapping:\n                mapping[c1] = next_c\n                next_c += 1\n            out.append(mapping[c1])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2-4 vertices biased towards the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))  # largest color first\n\n    num_moves = 2 + (seed_val % 3)  # 2..4 moves\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        # Prefer within current palette\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                # pick a random existing color (may create conflicts intentionally)\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n    out = normalize_colors(out)\n    return out\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    violations = 0\n    for i, x in enumerate(solution):\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution))\n    if k_used == 0:\n        k_used = 10**6\n\n    # Lexicographic objective: minimize violations first, then k_used\n    # Large margin W ensures feasibility prioritized\n    W = 100000\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1))})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k (applied upon return only)\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degree and saturation degree\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: pick vertex by (conflict_deg desc, saturation desc, degree desc, index asc)\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        # choose smallest feasible color or introduce new if needed\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: try to reduce k by reassigning a vertex from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor to lower color\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                # if target color emptied, normalization will remove it\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"changed_index\": u, \"new_color\": new_sol[u]}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe-chain swap between target_color and partner color that yields best k reduction potential\n    best_payload = None\n    best_tag = None\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # pick vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        # normalize for return\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"kempe_colors\": [a, target_color]}\n        best_payload = payload\n        best_tag = \"KempeSwap\"\n        # return first improved candidate (simple heuristic)\n        break\n    if best_payload is not None:\n        return (\"ENCODED_SOLUTION:\" + json.dumps(best_payload), best_tag)\n\n    # Fallback: recolor a random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize for return\n    # (keeps palette compact for evaluators\/caching)\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"changed_index\": u, \"new_color\": out[u]}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optionally apply a Kempe swap across two random colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            # find a vertex with color a to start\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # Rebuild adjacency for safety (local scope)\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_COLOR_LIST_LEN9","Evaluacion":"import math\nimport json\n\ndef evaluate_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Domain and shape checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Validate entries and count violations\n    invalid_entries = 0\n    for x in solution:\n        if not (isinstance(x, int) and x >= 1):\n            invalid_entries += 1\n    if invalid_entries > 0:\n        return 10**9 + invalid_entries * 10**7\n\n    violations = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set(solution)) if solution else 0\n    if k_used == 0:\n        k_used = 10**6\n\n    # Strong lexicographic penalty to prioritize feasibility\n    W = 10**6\n    fitness = violations * W + k_used\n    return fitness\n","Vecindad":"import json\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        encoded = json.dumps({\"solution\": list(range(1, n+1)), \"meta\": {\"reason\": \"InvalidInputFallback\"}})\n        return (\"ENCODED_SOLUTION:\" + encoded, \"InvalidInputFallback\")\n\n    current = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Helper: normalize colors to contiguous 1..k\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Conflict degrees and neighbor colors\n    colors_at_nb = [set() for _ in range(n)]\n    conflict_deg = [0]*n\n    for u in range(n):\n        for v in adj[u]:\n            colors_at_nb[u].add(current[v])\n    for (u, v) in edges0:\n        if current[u] == current[v]:\n            conflict_deg[u] += 1\n            conflict_deg[v] += 1\n\n    kmax = max(current) if current else 1\n\n    # If conflicts exist: recolor most conflicting vertex to smallest feasible color\n    if any(cd > 0 for cd in conflict_deg):\n        deg = [len(adj[i]) for i in range(n)]\n        sat = [len(colors_at_nb[i]) for i in range(n)]\n        # tie-break: more conflicts, higher saturation, higher degree, lower index\n        u = max(range(n), key=lambda i: (conflict_deg[i], sat[i], deg[i], -i))\n        used = {current[v] for v in adj[u]}\n        new_color = None\n        for c in range(1, kmax+1):\n            if c not in used:\n                new_color = c\n                break\n        if new_color is None:\n            new_color = kmax + 1\n        new_sol = current[:]\n        new_sol[u] = new_color\n        new_sol = normalize_colors(new_sol)\n        payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"RecolorConflict\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorConflict\")\n\n    # No conflicts: attempt to reduce number of colors by moving from highest color\n    by_color = {}\n    for i, c in enumerate(current):\n        by_color.setdefault(c, []).append(i)\n    target_color = max(by_color.keys()) if by_color else 1\n\n    # Attempt greedy recolor from target_color to lower colors\n    for u in list(by_color.get(target_color, [])):\n        used = {current[v] for v in adj[u]}\n        for c in range(1, target_color):\n            if c not in used:\n                new_sol = current[:]\n                new_sol[u] = c\n                new_sol = normalize_colors(new_sol)\n                payload = {\"solution\": new_sol, \"meta\": {\"changed_index\": u, \"new_color\": new_sol[u], \"tag\": \"ReduceGreedy\"}}\n                return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"ReduceGreedy\")\n\n    # Kempe chain swap between target_color and a lower color (first viable)\n    for a in range(1, target_color):\n        if not by_color.get(target_color):\n            break\n        # choose a vertex in target color with highest saturation\n        sat_scores = []\n        for u in by_color[target_color]:\n            sat_u = len({current[v] for v in adj[u]})\n            sat_scores.append((sat_u, -len(adj[u]), u))\n        u = max(sat_scores)[2]\n        allowed = {a, target_color}\n        visited = set()\n        comp = []\n        stack = [u]\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if current[x] not in allowed:\n                continue\n            visited.add(x)\n            comp.append(x)\n            for nb in adj[x]:\n                if current[nb] in allowed and nb not in visited:\n                    stack.append(nb)\n        trial = current[:]\n        for x in comp:\n            trial[x] = a if current[x] == target_color else target_color\n        trial_norm = normalize_colors(trial)\n        payload = {\"solution\": trial_norm, \"meta\": {\"kempe_colors\": [a, target_color], \"tag\": \"KempeSwap\"}}\n        return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"KempeSwap\")\n\n    # Fallback: recolor a pseudo-random vertex to smallest feasible color (deterministic seed)\n    seed_val = 1469598103934665603\n    for x in current:\n        seed_val ^= int(x) & 0xFFFFFFFF\n        seed_val = (seed_val * 1099511628211) & ((1<<64)-1)\n    random.seed(seed_val)\n    u = random.randrange(n)\n    used = {current[v] for v in adj[u]}\n    new_color = None\n    for c in range(1, kmax+1):\n        if c not in used:\n            new_color = c\n            break\n    if new_color is None:\n        new_color = kmax\n    new_sol = current[:]\n    new_sol[u] = new_color\n    # normalize\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in new_sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    payload = {\"solution\": out, \"meta\": {\"changed_index\": u, \"new_color\": out[u], \"tag\": \"RecolorFallback\"}}\n    return (\"ENCODED_SOLUTION:\" + json.dumps(payload), \"RecolorFallback\")\n","Perturbacion":"import json\nimport random\n\ndef perturb_solution(solution):\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Fallback for invalid input\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return list(range(1, n+1))\n\n    sol = [c if (isinstance(c, int) and c >= 1) else 1 for c in solution]\n\n    # Normalize colors (contiguous) helper\n    def normalize_colors(sol_in):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol_in:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    sol = normalize_colors(sol)\n\n    # Build adjacency\n    adj = {i: set() for i in range(n)}\n    for u, v in edges0:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Deterministic seed derived from solution content\n    seed_val = 7809847782465536322\n    for x in sol:\n        seed_val = (seed_val * 6364136223846793005 + int(x) + 1) & ((1<<64)-1)\n    random.seed(seed_val)\n\n    kmax = max(sol) if sol else 1\n\n    # Choose 2..4 vertices biased to the largest color class\n    counts = {}\n    for c in sol:\n        counts[c] = counts.get(c, 0) + 1\n    largest_color = max(counts, key=lambda c: counts[c]) if counts else 1\n    indices = list(range(n))\n    indices.sort(key=lambda i: (sol[i] != largest_color, i))\n\n    num_moves = 2 + (seed_val % 3)  # 2..4\n    to_change = indices[:num_moves]\n\n    out = sol[:]\n    cur_k = kmax\n    introduced_new = False\n\n    # Burst of recolors with occasional new color introduction to escape basins\n    for u in to_change:\n        used = {out[v] for v in adj[u]}\n        candidates = [c for c in range(1, cur_k+1) if c not in used]\n        if candidates:\n            newc = random.choice(candidates)\n        else:\n            if not introduced_new:\n                newc = cur_k + 1\n                introduced_new = True\n                cur_k = newc\n            else:\n                pool = [c for c in range(1, cur_k+1)]\n                newc = random.choice(pool)\n        out[u] = newc\n\n    # Optional Kempe swap across two colors if available\n    if cur_k >= 2:\n        a = 1 + (seed_val % cur_k)\n        b = 1 + ((seed_val \/\/ 7) % cur_k)\n        if a != b:\n            allowed = {a, b}\n            start = None\n            for i, c in enumerate(out):\n                if c == a:\n                    start = i\n                    break\n            if start is not None:\n                visited = set()\n                comp = []\n                stack = [start]\n                # rebuild adjacency local scope\n                adj2 = {i: set() for i in range(n)}\n                for u, v in edges0:\n                    adj2[u].add(v)\n                    adj2[v].add(u)\n                while stack:\n                    x = stack.pop()\n                    if x in visited:\n                        continue\n                    if out[x] not in allowed:\n                        continue\n                    visited.add(x)\n                    comp.append(x)\n                    for nb in adj2[x]:\n                        if out[nb] in allowed and nb not in visited:\n                            stack.append(nb)\n                for x in comp:\n                    out[x] = a if out[x] == b else (b if out[x] == a else out[x])\n\n    out = normalize_colors(out)\n    return out\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, list]) -> float:\n    # Lower is better: feasible -> k (max color); infeasible -> large penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 10_000_000.0\n    if len(colors) != n:\n        return 9_000_000.0 + abs(len(colors)-n)\n    for x in colors:\n        if not isinstance(x, int):\n            return 8_000_000.0\n        if x < 1:\n            return 7_000_000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n    if violations > 0:\n        return 5_000_000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbour_solution, Movement_Type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        # Relabel colors to 1..k in order of appearance for stability\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols, u, ca, cb):\n        # Perform A-B Kempe chain swap containing u; returns new cols\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        # Build alternating component\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        # Swap colors in the component\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # Fail fast: return input unchanged with parse_error tag\n        return (solution, 'parse_error')\n\n    colors = normalize_colors(colors)\n    kmax = max(colors)\n\n    # Identify conflicted vertices\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n\n    move_type = None\n    new_cols = colors[:]\n\n    # Move selection: prioritize conflict-driven recolor, else apply diversification moves\n    r = random.random()\n    if conf_vertices and r < 0.5:\n        # Conflict-driven recolor: pick high-degree conflicted node, recolor to smallest feasible\n        u = max(conf_vertices, key=lambda x: (len(adj[x]), random.random()))\n        used = {colors[v-1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                new_cols[u-1] = c\n                break\n        else:\n            # Try Kempe with a random neighbor color before introducing a new color\n            if used:\n                cb = random.choice(list(used))\n                ca = colors[u-1]\n                trial = kempe_interchange(colors, u, ca, cb)\n                # If reduces conflicts or preserves k, accept\n                if len(conflicts(trial)) <= len(conf_edges):\n                    new_cols = trial\n                else:\n                    new_cols[u-1] = kmax + 1\n                    kmax = kmax + 1\n            else:\n                new_cols[u-1] = kmax + 1\n                kmax = kmax + 1\n        move_type = 'conflict_recolor'\n    elif r < 0.8:\n        # Kempe chain swap around a random vertex and random color pair\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh_colors = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh_colors:\n            # fallback to recolor smallest feasible\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols[u-1] = feas\n            move_type = 'node_recolor'\n        else:\n            cb = random.choice(neigh_colors)\n            new_cols = kempe_interchange(colors, u, ca, cb)\n            move_type = 'kempe_swap'\n    else:\n        # Pairwise color swap of two non-adjacent vertices to reduce conflicts \/ compact colors\n        attempts = 0\n        applied = False\n        while attempts < 15 and not applied:\n            i = random.randrange(1, n+1)\n            j = random.randrange(1, n+1)\n            attempts += 1\n            if i == j or j in adj[i]:\n                continue\n            ci, cj = colors[i-1], colors[j-1]\n            new_cols = colors[:]\n            new_cols[i-1], new_cols[j-1] = cj, ci\n            # Accept if conflicts do not increase\n            if len(conflicts(new_cols)) <= len(conf_edges):\n                applied = True\n                move_type = 'pair_swap'\n                break\n        if not applied:\n            # fallback: simple recolor random node to smallest feasible\n            u = random.randrange(1, n+1)\n            feas = smallest_feasible_color(u, colors, kmax)\n            if feas is not None:\n                new_cols = colors[:]\n                new_cols[u-1] = feas\n            else:\n                new_cols = colors[:]\n                new_cols[u-1] = kmax + 1\n            move_type = 'node_recolor'\n\n    # Normalize color labels\n    new_cols = normalize_colors(new_cols)\n\n    if kind == 'str':\n        out = ','.join(str(x) for x in new_cols)\n    else:\n        out = new_cols\n    return (out, move_type if move_type is not None else 'unknown')\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation using 1-2 Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts], 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u-1] == cols[v-1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u-1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x-1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y-1] in (ca, cb) and target[y-1] != target[x-1]:\n                    stack.append(y)\n        for x in visited:\n            target[x-1] = ca if target[x-1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # If invalid, return a simple 4-color seed known feasible for this graph\n        fallback = [1,1,1,2,3,2,3,4,4]\n        if isinstance(solution, str):\n            return ','.join(str(x) for x in fallback)\n        return fallback\n\n    colors = normalize_colors(colors)\n\n    # Apply 1-2 Kempe swaps on random vertices\/color pairs\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n+1)\n        ca = colors[u-1]\n        neigh = [colors[v-1] for v in adj[u] if colors[v-1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Recolor up to two most-conflicted vertices greedily\n    conf_edges = conflicts(colors)\n    conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n    if conf_vertices:\n        # score vertices by conflicts then degree\n        def v_score(u):\n            cdeg = sum(1 for (a, b) in conf_edges if a == u or b == u)\n            return (cdeg, len(adj[u]))\n        conf_vertices.sort(key=lambda x: v_score(x), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v-1] for v in adj[u]}\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u-1] = c\n                    break\n            else:\n                colors[u-1] = kmax + 1\n                kmax += 1\n\n    # Normalize \/ compact labels\n    colors = normalize_colors(colors)\n\n    if kind == 'str':\n        return ','.join(str(x) for x in colors)\n    return colors\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better: feasible -> k (max color); infeasible -> scaled penalty + violations\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n\n    # Malformed input penalties\n    if not isinstance(colors, list):\n        return 100000.0\n    if len(colors) != n:\n        return 90000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 80000.0\n        if x < 1:\n            return 70000.0\n\n    # Count edge conflicts\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n    if violations > 0:\n        return 10000.0 + float(violations)\n\n    # Feasible: score equals number of colors used\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def smallest_feasible_color(u, cols, kmax):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def normalize_colors(cols):\n        # Compact to 1..k preserving relative order of first appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        # On parse error, return input as CSV unchanged with tag\n        if isinstance(solution, str):\n            return (solution, 'parse_error')\n        if isinstance(solution, list):\n            return (to_csv(solution), 'parse_error')\n        return (\"1,1,1,2,3,2,3,4,4\", 'parse_error')\n\n    colors = normalize_colors(colors)\n\n    # Determine feasibility and current k\n    conf_edges = conflicts(colors)\n    kmax = max(colors)\n\n    move_type = 'unknown'\n    new_cols = colors[:]\n\n    if conf_edges:\n        # Conflict repair priority\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        # Pick vertex with highest conflict degree, tie-break by random\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, colors, kmax)\n        if feas is not None:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            # Try Kempe swaps over all neighbor colors, pick best (min conflicts)\n            ca = colors[u - 1]\n            neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(colors, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: introduce a new color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible: attempt color elimination from max color class\n        max_class = [i for i, c in enumerate(colors, start=1) if c == kmax]\n        random.shuffle(max_class)\n        eliminated = False\n        for u in max_class:\n            feas = smallest_feasible_color(u, colors, kmax - 1)\n            if feas is not None:\n                new_cols[u - 1] = feas\n                eliminated = True\n                move_type = 'k_reduce_recolor'\n                break\n        if not eliminated:\n            # Try Kempe-based attempt to free a color for a max-class vertex\n            if max_class:\n                u = random.choice(max_class)\n                ca = colors[u - 1]\n                neigh_colors = list({colors[v - 1] for v in adj[u] if colors[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                applied = False\n                for cb in neigh_colors:\n                    trial = kempe_interchange(colors, u, ca, cb)\n                    # After swap, try greedy recolor within 1..kmax-1\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        applied = True\n                        move_type = 'k_reduce_kempe'\n                        break\n                if not applied:\n                    # Compact: swap labels of two colors to diversify\n                    if kmax >= 2:\n                        a, b = random.sample(range(1, kmax + 1), 2)\n                        for i in range(n):\n                            if new_cols[i] == a:\n                                new_cols[i] = b\n                            elif new_cols[i] == b:\n                                new_cols[i] = a\n                        move_type = 'color_class_swap'\n\n    # Optional normalization to keep labels compact; preserve k\n    new_cols = normalize_colors(new_cols)\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: Kempe swaps + greedy repairs + normalization\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols):\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return sol, 'list'\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                vals = [int(p) for p in parts]\n                return vals, 'str'\n            except Exception:\n                return None, None\n        return None, None\n\n    def normalize_colors(cols):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(cols):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def kempe_interchange(cols, u, ca, cb):\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    colors, kind = parse(solution)\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(x, int) or x < 1) for x in colors):\n        colors = [1,1,1,2,3,2,3,4,4]\n    else:\n        colors = normalize_colors(colors)\n\n    # 1-2 Kempe swaps\n    num_swaps = 1 + int(random.random() < 0.5)\n    for _ in range(num_swaps):\n        u = random.randrange(1, n + 1)\n        ca = colors[u - 1]\n        neigh = [colors[v - 1] for v in adj[u] if colors[v - 1] != ca]\n        if not neigh:\n            continue\n        cb = random.choice(neigh)\n        colors = kempe_interchange(colors, u, ca, cb)\n\n    # Greedy repair of up to two most conflicted vertices\n    conf_edges = conflicts(colors)\n    if conf_edges:\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def v_score(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        conf_vertices.sort(key=lambda x: (v_score(x), len(adj[x])), reverse=True)\n        take = conf_vertices[:2]\n        kmax = max(colors)\n        for u in take:\n            used = {colors[v - 1] for v in adj[u]}\n            placed = False\n            for c in range(1, kmax + 1):\n                if c not in used:\n                    colors[u - 1] = c\n                    placed = True\n                    break\n            if not placed:\n                colors[u - 1] = kmax + 1\n                kmax += 1\n\n    colors = normalize_colors(colors)\n    return to_csv(colors)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV9_INT","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution) -> float:\n    # Robust evaluator: primary objective = minimize violations, secondary = minimize k\n    # Scalarization: score = violations*1_000_000 + k; malformed => >= 1e9\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    colors = parse(solution)\n    if not isinstance(colors, list):\n        return 1_000_000_000.0\n    if len(colors) != n:\n        return 1_000_000_000.0 + float(abs(len(colors) - n))\n    for x in colors:\n        if not isinstance(x, int):\n            return 1_000_000_000.0\n        if x < 1:\n            return 1_000_000_000.0\n\n    violations = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            violations += 1\n\n    if violations > 0:\n        return float(violations * 1_000_000)\n\n    k_hat = max(colors) if colors else 0\n    return float(k_hat)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_as_CSV, move_type)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def conflicts(cols: List[int]):\n        return [(u, v) for (u, v) in edges if cols[u - 1] == cols[v - 1]]\n\n    def saturation_degree(u: int, cols: List[int]) -> int:\n        return len({cols[v - 1] for v in adj[u]})\n\n    def smallest_feasible_color(u: int, cols: List[int], kmax: int):\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, kmax + 1):\n            if c not in used:\n                return c\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        # Safe fallback to a valid 4-coloring\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Neighbor generation strategy:\n    # - If infeasible: pick most critical vertex by (conflict-degree, saturation, degree) and repair\n    # - If feasible: attempt k reduction by recoloring max color class or Kempe swap\n    conf_edges = conflicts(cols)\n    kmax = max(cols)\n\n    move_type = 'unknown'\n    new_cols = cols[:]\n\n    if conf_edges:\n        # Conflict repair\n        conf_vertices = list({u for (u, v) in conf_edges} | {v for (u, v) in conf_edges})\n        def cdeg(u):\n            return sum(1 for (a, b) in conf_edges if a == u or b == u)\n        u = max(conf_vertices, key=lambda x: (cdeg(x), saturation_degree(x, cols), len(adj[x]), random.random()))\n        feas = smallest_feasible_color(u, cols, kmax)\n        if feas is not None and feas != cols[u - 1]:\n            new_cols[u - 1] = feas\n            move_type = 'repair_recolor'\n        else:\n            ca = cols[u - 1]\n            neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n            best_cols = None\n            best_conf = None\n            for cb in neigh_colors:\n                trial = kempe_interchange(cols, u, ca, cb)\n                c = len(conflicts(trial))\n                if best_conf is None or c < best_conf:\n                    best_conf = c\n                    best_cols = trial\n            if best_cols is not None and best_conf <= len(conf_edges):\n                new_cols = best_cols\n                move_type = 'repair_kempe'\n            else:\n                # Last resort: cautiously expand color\n                new_cols[u - 1] = kmax + 1\n                move_type = 'repair_expand'\n    else:\n        # Feasible phase: try to reduce k\n        max_class_vertices = [i for i, c in enumerate(cols, start=1) if c == kmax]\n        random.shuffle(max_class_vertices)\n        reduced = False\n        for u in max_class_vertices:\n            feas = smallest_feasible_color(u, cols, kmax - 1)\n            if feas is not None and feas != cols[u - 1]:\n                new_cols[u - 1] = feas\n                move_type = 'k_reduce_recolor'\n                reduced = True\n                break\n        if not reduced:\n            if max_class_vertices:\n                u = max(max_class_vertices, key=lambda x: (saturation_degree(x, cols), len(adj[x]), random.random()))\n                ca = cols[u - 1]\n                neigh_colors = list({cols[v - 1] for v in adj[u] if cols[v - 1] != ca})\n                random.shuffle(neigh_colors)\n                for cb in neigh_colors:\n                    trial = kempe_interchange(cols, u, ca, cb)\n                    feas = smallest_feasible_color(u, trial, kmax - 1)\n                    if feas is not None:\n                        trial[u - 1] = feas\n                        new_cols = trial\n                        move_type = 'k_reduce_kempe'\n                        reduced = True\n                        break\n        if not reduced:\n            # Targeted color-class swap between two colors most conflicting on boundary\n            if kmax >= 2:\n                # Score boundary conflicts for each color\n                boundary = [0]*(kmax+1)\n                for (u,v) in edges:\n                    cu, cv = cols[u-1], cols[v-1]\n                    if cu != cv:\n                        boundary[cu] += 1\n                        boundary[cv] += 1\n                a = max(range(1,kmax+1), key=lambda c: (boundary[c], random.random()))\n                b = max([c for c in range(1,kmax+1) if c!=a], key=lambda c: (boundary[c], random.random()))\n                for i in range(n):\n                    if new_cols[i] == a:\n                        new_cols[i] = b\n                    elif new_cols[i] == b:\n                        new_cols[i] = a\n                move_type = 'color_class_swap'\n\n    return (to_csv(new_cols), move_type)\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution):\n    # Deterministic strong perturbation based on solution-derived seed:\n    # - 2 Kempe interchanges driven by local RNG(seed=hash(colors))\n    # - Greedy recolor of up to 2 vertices from largest color class\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def to_csv(cols: List[int]) -> str:\n        return \",\".join(str(x) for x in cols)\n\n    def parse(sol: Union[str, List[int]]):\n        if isinstance(sol, list):\n            return sol\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',')]\n            if len(parts) != n:\n                return None\n            try:\n                vals = [int(p) for p in parts]\n                return vals\n            except Exception:\n                return None\n        return None\n\n    def kempe_interchange(cols: List[int], u: int, ca: int, cb: int) -> List[int]:\n        if cols[u - 1] not in (ca, cb):\n            return cols[:]\n        target = cols[:]\n        stack = [u]\n        visited = set()\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            if target[x - 1] not in (ca, cb):\n                continue\n            visited.add(x)\n            for y in adj[x]:\n                if y not in visited and target[y - 1] in (ca, cb) and target[y - 1] != target[x - 1]:\n                    stack.append(y)\n        for x in visited:\n            target[x - 1] = ca if target[x - 1] == cb else cb\n        return target\n\n    def greedy_recolor(u: int, cols: List[int], max_color_cap: int) -> bool:\n        used = {cols[v - 1] for v in adj[u]}\n        for c in range(1, max_color_cap + 1):\n            if c not in used:\n                cols[u - 1] = c\n                return True\n        return False\n\n    cols = parse(solution)\n    if not isinstance(cols, list) or len(cols) != n or any((not isinstance(x, int) or x < 1) for x in cols):\n        cols = [1,1,1,2,3,2,3,4,4]\n\n    # Seeded RNG from solution to keep determinism per input\n    seed = 1469598103934665603\n    for x in cols:\n        seed = (seed ^ (x + 0x9e3779b97f4a7c15)) * 1099511628211 & ((1<<64)-1)\n    rng = random.Random(seed)\n\n    # Perform up to 2 Kempe swaps\n    for _ in range(2):\n        u = rng.randrange(1, n + 1)\n        cu = cols[u - 1]\n        neigh_colors = [cols[v - 1] for v in adj[u] if cols[v - 1] != cu]\n        if not neigh_colors:\n            continue\n        cb = rng.choice(neigh_colors)\n        cols = kempe_interchange(cols, u, cu, cb)\n\n    # Recolor a small subset from the largest color class into existing colors only\n    kmax = max(cols)\n    sizes = {c: 0 for c in range(1, kmax + 1)}\n    for c in cols:\n        sizes[c] += 1\n    largest_color = max(range(1, kmax + 1), key=lambda c: (sizes.get(c,0), rng.random()))\n    candidates = [i for i, c in enumerate(cols, start=1) if c == largest_color]\n    rng.shuffle(candidates)\n    moved = 0\n    for u in candidates:\n        if greedy_recolor(u, cols, kmax):\n            moved += 1\n        if moved >= 2:\n            break\n\n    return to_csv(cols)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                return [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        try:\n            return [int(float(x)) for x in list(sol)]\n        except Exception:\n            return None\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Accepts list\/tuple or CSV string; returns a Python list[int] of length 9\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return (cur, \"NoOp\", \"Empty\")\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Compute conflicting vertices\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.append(u - 1)\n            conflicts.append(v - 1)\n    conflicts = list(set(conflicts))\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        if limit is None:\n            up = max_c\n        else:\n            up = limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    # Randomly choose move type: 70% recolor, 30% Kempe swap\n    if random.random() < 0.70:\n        # Conflict-driven recolor: prefer conflicting vertices\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n            nb_type = \"ConflictDriven\"\n        else:\n            i = random.randrange(n)\n            nb_type = \"RandomVertex\"\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            # choose smallest feasible to bias toward lower K\n            new[i] = min(feas)\n        else:\n            # introduce new color with small probability, else random old color different from current\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return (new, nb_type, \"ReassignOne\")\n    else:\n        # Kempe chain swap between two colors to escape local minima\n        if max_c < 2:\n            # fallback to recolor if only one color present\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else max(1, ((new[i]) % max_c) + 1)\n            return (new, \"Fallback\", \"ReassignOne\")\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        # pick a seed vertex that has color c1 or c2\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return (cur[:], \"NoOp\", \"KempeNone\")\n        seed = random.choice(candidates)\n        # BFS over subgraph induced by colors c1 and c2\n        from collections import deque\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        # swap colors in this component\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return (new, \"Kempe\", f\"Swap_{c1}_{c2}\")\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: pick a smallest color class and greedily recolor its vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    # choose smallest non-empty class\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # number of moves: 2 to 5 depending on size\n    steps = max(2, min(5, len(vertices)))\n    random.shuffle(vertices)\n    vertices = vertices[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in vertices:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            new[v] = random.choice(feas)\n        else:\n            # with small probability introduce a new color to escape infeasibility\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # fallback: assign a random different existing color\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_POSITIVE_CSV","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Coerce solution into list of ints length 9\n    def _coerce(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        else:\n            try:\n                lst = [int(float(x)) for x in list(sol)]\n            except Exception:\n                return None\n        n = 9\n        if len(lst) != n:\n            return lst  # caller will handle size penalty below\n        return lst\n\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    PENALTY_INVALID = 1_000_000\n    PENALTY_VIOLATION = 1_000\n    PENALTY_VALUE = 100\n\n    sol_list = _coerce(solution)\n    if sol_list is None:\n        return PENALTY_INVALID\n    if len(sol_list) != n:\n        return PENALTY_INVALID + abs(len(sol_list) - n) * PENALTY_VALUE\n\n    max_color = 0\n    invalid_values = 0\n    coerced = []\n    for v in sol_list:\n        if isinstance(v, bool):\n            invalid_values += 1\n            coerced.append(0)\n            continue\n        try:\n            c = int(v)\n        except Exception:\n            c = 0\n            invalid_values += 1\n        if c < 1:\n            invalid_values += 1\n        coerced.append(c)\n        if c > max_color:\n            max_color = c\n\n    violations = 0\n    for (u, v) in edges:\n        cu = coerced[u - 1]\n        cv = coerced[v - 1]\n        if cu == cv and cu > 0:\n            violations += 1\n\n    if invalid_values > 0 or violations > 0:\n        return (\n            PENALTY_INVALID\n            + invalid_values * PENALTY_VALUE\n            + violations * PENALTY_VIOLATION\n            + max_color\n        )\n\n    return max_color\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns neighbor solution only (list[int] of length 9)\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        # pad or trim to 9 to be safe\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in edges:\n        if cur[u - 1] == cur[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n    conflicts = list(conflicts)\n\n    def feasible_colors(idx, limit=None):\n        used = set(cur[j] for j in adj[idx])\n        up = max_c if limit is None else limit\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if random.random() < 0.70:\n        # Conflict-driven recolor (prefer conflicting vertices)\n        if conflicts and random.random() < 0.8:\n            i = random.choice(conflicts)\n        else:\n            i = random.randrange(n)\n        new = cur[:]\n        feas = feasible_colors(i, limit=max_c)\n        if feas:\n            new[i] = min(feas)  # bias to lower K\n        else:\n            if random.random() < 0.10:\n                new[i] = max_c + 1\n            else:\n                choices = list(range(1, max_c + 1))\n                if len(choices) > 1 and new[i] in choices:\n                    choices.remove(new[i])\n                new[i] = random.choice(choices)\n        return new\n    else:\n        # Kempe chain swap between two colors\n        if max_c < 2:\n            i = random.randrange(n)\n            new = cur[:]\n            new[i] = max_c + 1 if random.random() < 0.1 else 1\n            return new\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if not candidates:\n            return cur[:]\n        seed = random.choice(candidates)\n        q = deque([seed])\n        visited = [False] * n\n        visited[seed] = True\n        comp = [seed]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and cur[v] in (c1, c2):\n                    visited[v] = True\n                    q.append(v)\n                    comp.append(v)\n        new = cur[:]\n        for v in comp:\n            if new[v] == c1:\n                new[v] = c2\n            elif new[v] == c2:\n                new[v] = c1\n        return new\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Focused perturbation: operate on small color classes and high-conflict vertices\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip()!='']\n            lst = [max(1, int(float(p.strip()))) for p in parts]\n        else:\n            lst = [max(1, int(float(x))) for x in list(sol)]\n        n = 9\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    cur = _coerce_to_list(solution)\n    if n == 0:\n        return cur\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n    # build color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n\n    # choose smallest non-empty class (deterministic tie by color id)\n    smallest_class = min(classes.items(), key=lambda kv: (len(kv[1]), kv[0]))[0]\n    vertices = classes[smallest_class][:]\n\n    # also collect high-conflict vertices\n    conflict_count = [0]*n\n    for (u, v) in edges:\n        ui, vi = u-1, v-1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    # number of moves: 2 to 5 depending on availability\n    base = vertices[:]\n    rand_extra = sorted(range(n), key=lambda i: -conflict_count[i])[:3]\n    pool = list(set(base + rand_extra))\n    random.shuffle(pool)\n    steps = max(2, min(5, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]\n\n    def feasible_colors(idx, limit):\n        used = set(new[j] for j in adj[idx])\n        return [c for c in range(1, limit + 1) if c not in used]\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible to diversify\n            new[v] = random.choice(feas)\n        else:\n            if random.random() < 0.25:\n                max_c += 1\n                new[v] = max_c\n            else:\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices)\n\n    return new\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9_POSITIVE (example: 1,2,3,1,2,3,1,2,3)","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Graph Coloring objective: minimize K=max(color) subject to edge constraints\n    # Lower is better. Uses soft penalties: f = K + lambda * violations + invalid_penalty\n    # No globals; all data embedded\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    LAMBDA = 10.0\n    BIG = 1_000_000.0\n\n    def _coerce_list(sol):\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            try:\n                lst = [int(float(p.strip())) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple)):\n            try:\n                lst = [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n        # length normalization only for evaluation; invalid length penalized\n        return lst\n\n    lst = _coerce_list(solution)\n    if lst is None:\n        return BIG\n\n    invalid = 0\n    if len(lst) != n:\n        return BIG + 1000.0 * abs(len(lst) - n)\n\n    # sanitize values; count invalids\n    colors = []\n    max_c = 0\n    for v in lst:\n        if isinstance(v, bool):\n            invalid += 1\n            v = 1\n        try:\n            c = int(v)\n        except Exception:\n            c = 1\n            invalid += 1\n        if c < 1:\n            invalid += 1\n            c = 1\n        colors.append(c)\n        if c > max_c:\n            max_c = c\n\n    # violations\n    viol = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            viol += 1\n\n    if invalid > 0:\n        return BIG\/10.0 + invalid * 100.0 + viol * 1000.0 + float(max_c)\n\n    # soft objective while infeasible, exact K when feasible\n    if viol == 0:\n        return float(max_c)\n    else:\n        return float(max_c) + LAMBDA * float(viol)\n","Vecindad":"import random, math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # NB_Type in {\"Local\"}; Movement_Type in {\"Decrement\",\"Recolor\",\"Kempe\"}\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1]*n\n        # pad\/trim to n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    def conflicts_of(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u - 1)\n                conf.add(v - 1)\n        return list(conf)\n\n    max_c = max(cur) if cur else 1\n\n    # Move 1: Global decrement attempt on highest color class\n    high = max_c\n    high_vertices = [i for i, c in enumerate(cur) if c == high]\n\n    def feasible_colors(sol, idx, up):\n        used = set(sol[j] for j in adj[idx])\n        return [c for c in range(1, up + 1) if c not in used]\n\n    if high > 1 and high_vertices and random.random() < 0.5:\n        new = cur[:]\n        success_any = False\n        for v in high_vertices:\n            feas = [c for c in feasible_colors(new, v, high - 1)]\n            if feas:\n                new[v] = random.choice(feas)\n                success_any = True\n        if success_any and max(new) <= max_c - 1:\n            return new, \"Local\", \"Decrement\"\n        # fallthrough if unsuccessful\n\n    # Move 2: Conflict-driven recolor\n    conf = conflicts_of(cur)\n    new = cur[:]\n    if conf and random.random() < 0.6:\n        i = random.choice(conf)\n    else:\n        i = random.randrange(n)\n    feas = feasible_colors(new, i, max_c)\n    if feas:\n        new[i] = min(feas) if random.random() < 0.7 else random.choice(feas)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # If no feasible color within 1..max_c, allow temporary new color to force change\n    choices = list(range(1, max_c + 1))\n    if new[i] in choices and len(choices) > 1:\n        choices.remove(new[i])\n    if choices:\n        new[i] = random.choice(choices)\n        if new != cur:\n            return new, \"Local\", \"Recolor\"\n    # last resort: introduce new color to guarantee change\n    new[i] = max_c + 1\n    if new != cur:\n        return new, \"Local\", \"Recolor\"\n\n    # Move 3: Kempe chain swap for diversification\n    if max_c >= 2:\n        c1, c2 = random.sample(range(1, max_c + 1), 2)\n        candidates = [i for i in range(n) if cur[i] in (c1, c2)]\n        if candidates:\n            seed = random.choice(candidates)\n            q = deque([seed])\n            visited = [False] * n\n            visited[seed] = True\n            comp = [seed]\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        visited[v] = True\n                        q.append(v)\n                        comp.append(v)\n            new = cur[:]\n            for v in comp:\n                new[v] = c2 if new[v] == c1 else (c1 if new[v] == c2 else new[v])\n            if new != cur:\n                return new, \"Local\", \"Kempe\"\n\n    # Safety: always return a different solution\n    j = (i + 1) % n\n    new = cur[:]\n    new[j] = (cur[j] % (max_c + 1)) + 1\n    if new[j] == cur[j]:\n        new[j] = cur[j] + 1\n    return new, \"Local\", \"Recolor\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    # Stronger diversification: reassign a subset prioritizing smallest color class and high-conflict vertices\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def _coerce_to_list(sol):\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s.startswith('[') and s.endswith(']'):\n                s = s[1:-1]\n            parts = [p for p in s.replace('\\n', ',').split(',') if p.strip() != '']\n            lst = []\n            for p in parts:\n                try:\n                    lst.append(max(1, int(float(p.strip()))))\n                except Exception:\n                    lst.append(1)\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for x in sol:\n                try:\n                    lst.append(max(1, int(x)))\n                except Exception:\n                    lst.append(1)\n        else:\n            lst = [1] * n\n        if len(lst) < n:\n            lst = lst + [1] * (n - len(lst))\n        elif len(lst) > n:\n            lst = lst[:n]\n        return lst\n\n    cur = _coerce_to_list(solution)\n\n    # adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        adj[ui].append(vi)\n        adj[vi].append(ui)\n\n    max_c = max(cur) if cur else 1\n\n    # color classes\n    classes = {}\n    for i, c in enumerate(cur):\n        classes.setdefault(c, []).append(i)\n    smallest_class_color = min(classes.keys(), key=lambda k: (len(classes[k]), k))\n\n    # conflict counts\n    conflict_count = [0] * n\n    for (u, v) in edges:\n        ui, vi = u - 1, v - 1\n        if cur[ui] == cur[vi]:\n            conflict_count[ui] += 1\n            conflict_count[vi] += 1\n\n    pool = list(set(classes[smallest_class_color] + sorted(range(n), key=lambda i: -conflict_count[i])[:3]))\n    random.shuffle(pool)\n    steps = max(3, min(6, len(pool)))\n    pool = pool[:steps]\n\n    new = cur[:]  # work copy\n\n    def feasible_colors(idx, up):\n        used = set(new[j] for j in adj[idx])\n        # allow up to current max color; occasionally allow new color to diversify\n        colors = [c for c in range(1, up + 1) if c not in used]\n        return colors\n\n    for v in pool:\n        feas = feasible_colors(v, max_c)\n        if feas:\n            # random feasible for diversification\n            nc = random.choice(feas)\n            new[v] = nc\n        else:\n            # introduce at most one extra color with small probability\n            if random.random() < 0.3:\n                max_c += 1\n                new[v] = max_c\n            else:\n                # forced change within 1..max_c\n                choices = list(range(1, max_c + 1))\n                if new[v] in choices and len(choices) > 1:\n                    choices.remove(new[v])\n                new[v] = random.choice(choices) if choices else max_c\n\n    return new\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lower is better. Feasible solutions return the number of colors used.\n    # Infeasible solutions return large penalties.\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED = 100_000_000\n    SMALL = 10_000\n    # Representation enforcement\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED + conflicts\n    # Distinct color count and normalization check\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    NB_Type in {RECOLOR, SWAP}\n    Movement_Type in {single-vertex, pair-swap}\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Basic validation and repair-init\n    if not isinstance(solution, list) or len(solution) != n:\n        base = list(range(1, n + 1))\n        return (base, \"RECOLOR\", \"repair-init\")\n\n    def conflicts_of(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    new_sol = solution[:]\n\n    if random.random() < 0.8:\n        # RECOLOR neighborhood: focus on conflicted vertices if any\n        bad = conflicted_vertices(new_sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            v = random.randrange(n)\n        current_color = new_sol[v]\n        max_c = max(new_sol) if new_sol else 1\n        # Prefer existing palette; occasionally allow +1 to escape\n        candidates = list(range(1, max_c + (1 if random.random() < 0.2 else 0) + 1))\n        random.shuffle(candidates)\n        best = None\n        best_conf = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            trial = new_sol[:]\n            trial[v] = c\n            conf = conflicts_of(trial)\n            if best is None or conf < best_conf or (conf == best_conf and c < trial[v]):\n                best = trial\n                best_conf = conf\n                if best_conf == 0:\n                    break\n        if best is None:\n            best = new_sol\n        best = normalize_palette(best)\n        return (best, \"RECOLOR\", \"single-vertex\")\n    else:\n        # SWAP neighborhood: swap colors of two distinct vertices\n        i = random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        trial = new_sol[:]\n        trial[i], trial[j] = trial[j], trial[i]\n        trial = normalize_palette(trial)\n        return (trial, \"SWAP\", \"pair-swap\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but bounded kick: recolor a subset (focused on conflicts if any)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    def conflicted_vertices(sol):\n        bad = set()\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u-1)\n                bad.add(v-1)\n        return list(bad)\n    def normalize_palette(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n + 1))\n    else:\n        sol = solution[:]\n    max_c = max(sol) if sol else 1\n    bad = conflicted_vertices(sol)\n    pool = bad if bad else list(range(n))\n    steps = max(3, n \/\/ 3)\n    for _ in range(steps):\n        v = random.choice(pool)\n        # recolor using existing palette plus occasional new color\n        new_c = random.randrange(1, max_c + (1 if random.random() < 0.3 else 0) + 1)\n        if new_c < 1:\n            new_c = 1\n        sol[v] = new_c\n    sol = normalize_palette(sol)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used (with SMALL penalty if palette not normalized 1..k).\n    Infeasible: large base penalty plus conflict-gradient to preserve ordering.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 1_000_000_000\n    MED_BASE = 100_000_000\n    CONFLICT_SCALE = 1_000\n    SMALL = 10_000\n    # Representation checks\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        return MED_BASE + conflicts * CONFLICT_SCALE\n    # Distinct colors and normalization\n    distinct = sorted(set(solution))\n    k_used = len(distinct)\n    normalized_ok = (distinct == list(range(1, k_used + 1)))\n    fitness = k_used\n    if not normalized_ok:\n        fitness += SMALL\n    return fitness\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    NB_Type in {\"RECOLOR\",\"SWAP\"}; Movement_Type in {\"single-vertex\",\"pair-swap\"}.\n    Implementation focuses on conflict-driven recolor; occasional pair-swap.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Validate\/repair minimal\n    if not isinstance(solution, list) or len(solution) != n:\n        # Greedy coloring seed to avoid excessive conflicts\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        for v in range(1, n+1):\n            forbidden = {sol[u-1] for u in adj[v] if sol[u-1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[v-1] = c\n        return (sol, (\"RECOLOR\", \"repair-init\"))\n    sol = solution[:]\n    # Build adjacency list and quick helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    # With high probability do recolor; else do swap\n    if random.random() < 0.85:\n        # Select target vertex (prefer conflicted)\n        if conflicted:\n            v = random.choice(conflicted)\n        else:\n            v = random.randrange(n)\n        v1 = v + 1\n        current_color = sol[v]\n        # Candidate colors from neighbor palette plus optional new color\n        neigh_colors = {sol[u-1] for u in adj[v1]}\n        max_c = max(sol) if sol else 1\n        candidates = sorted(neigh_colors | {current_color})\n        # Occasionally allow introducing a new color to escape traps\n        if random.random() < 0.1:\n            candidates.append(max_c + 1)\n        # Evaluate delta conflicts for each candidate color\n        best_c = current_color\n        best_delta = None\n        best_palette_growth = None\n        for c in candidates:\n            if c == current_color and random.random() < 0.5:\n                continue\n            # Compute conflicts if v were color c using only neighbors\n            before = 0\n            after = 0\n            for u in adj[v1]:\n                if sol[u-1] == current_color:\n                    before += 1\n                if sol[u-1] == c:\n                    after += 1\n            delta = after - before  # aim to minimize conflicts\n            palette_growth = 1 if c > max_c else 0\n            if (best_delta is None or\n                delta < best_delta or\n                (delta == best_delta and palette_growth < best_palette_growth) or\n                (delta == best_delta and palette_growth == best_palette_growth and c < best_c)):\n                best_delta = delta\n                best_palette_growth = palette_growth\n                best_c = c\n                if best_delta < 0 and best_palette_growth == 0:\n                    pass\n        new_sol = sol[:]\n        new_sol[v] = best_c\n        return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n    else:\n        # Conflict-aware pair swap: pick one conflicted (or random) and swap with a neighbor index\n        i = random.choice(conflicted) if conflicted else random.randrange(n)\n        j = random.randrange(n - 1)\n        if j >= i:\n            j += 1\n        new_sol = sol[:]\n        new_sol[i], new_sol[j] = new_sol[j], new_sol[i]\n        return (new_sol, (\"SWAP\", \"pair-swap\"))\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor a small set of vertices, biased to conflicts,\n    using existing palette with occasional +1 color to escape.\n    Returns a valid representation (list of 9 positive ints).\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    # Minimal repair if needed\n    if not isinstance(solution, list) or len(solution) != n:\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n    # Helpers\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n    def vertex_conflicts(v_idx, s):\n        v = v_idx + 1\n        c = s[v_idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n    steps = max(3, n \/\/ 3)\n    max_c = max(sol) if sol else 1\n    for _ in range(steps):\n        v = random.choice(pool)\n        neigh = {sol[u-1] for u in adj[v+1]}\n        candidates = list(set(range(1, max_c + 1)) - neigh)\n        if not candidates or random.random() < 0.25:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"LIST_INT_9_COLORS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns scalar cost (lower is better).\n    Feasible: number of colors used.\n    Infeasible: strong penalty dominated by conflict count with small tie-break on distinct colors.\n    Representation must be a list of 9 positive integers.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n    BIG = 10**12\n    # Validate representation\n    if not isinstance(solution, list):\n        return BIG\n    if len(solution) != n:\n        return BIG\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return BIG\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Distinct colors\n    k_used = len(set(solution))\n    if conflicts > 0:\n        # Strong ordering in infeasible space\n        return 1_000_000 * conflicts + 1_000 * k_used\n    # Feasible: minimize number of colors\n    return k_used\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    Neighbourhoods:\n      - Conflict-driven recolor of a single vertex.\n      - Kempe-chain swap between two colors on a conflicted vertex component.\n    Always normalizes palette to 1..k.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Basic repair if invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        # DSATUR seed\n        adj = {i: [] for i in range(1, n+1)}\n        for (u, v) in edges:\n            adj[u].append(v); adj[v].append(u)\n        colors = [0]*n\n        sat_deg = [0]*n\n        uncolored = set(range(1, n+1))\n        neighbor_colors = {i: set() for i in range(1, n+1)}\n        while uncolored:\n            # select vertex with max saturation degree then max degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                neighbor_colors[u].add(c)\n        return (normalize_palette(colors), (\"RECOLOR\", \"repair-init\"))\n\n    sol = solution[:]\n\n    # Build adjacency list\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        cnt = 0\n        for u in adj[v]:\n            if s[u-1] == c:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n\n    if conflicted and random.random() < 0.35:\n        # Kempe-chain swap around a conflicted vertex\n        v = random.choice(conflicted)\n        v1 = v + 1\n        # pick a conflicting neighbor to define two colors a,b\n        neigh_conf = [u for u in adj[v1] if sol[u-1] == sol[v]]\n        if not neigh_conf:\n            # fallback to recolor\n            pass\n        else:\n            u = random.choice(neigh_conf)\n            a = sol[v]\n            # choose a different color from neighbor palette or introduce new if palette small\n            palette = sorted(set(sol))\n            # prefer a neighbor's color different from a\n            neigh_cols = [sol[w-1] for w in adj[v1] if sol[w-1] != a]\n            if neigh_cols:\n                b = random.choice(neigh_cols)\n            else:\n                b = (max(palette) + 1) if random.random() < 0.2 else random.choice(palette)\n                if b == a:\n                    b = max(palette) + 1\n            # BFS on Kempe component containing v in subgraph induced by colors {a,b}\n            comp = set()\n            dq = deque([v1])\n            allowed = {a, b}\n            while dq:\n                x = dq.popleft()\n                if x in comp:\n                    continue\n                if sol[x-1] not in allowed:\n                    continue\n                comp.add(x)\n                for y in adj[x]:\n                    if sol[y-1] in allowed and y not in comp:\n                        dq.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x-1] == a:\n                    new_sol[x-1] = b\n                elif new_sol[x-1] == b:\n                    new_sol[x-1] = a\n            new_sol = normalize_palette(new_sol)\n            return (new_sol, (\"KEMPE\", \"component-swap\"))\n\n    # Conflict-driven recolor\n    if conflicted:\n        v = max(conflicted, key=lambda i: (vertex_conflicts(i, sol), len(adj[i+1])))\n    else:\n        v = random.randrange(n)\n    v1 = v + 1\n    curr_c = sol[v]\n    palette = set(sol)\n    max_c = max(palette) if palette else 1\n    # Candidate colors: all existing colors, plus maybe a new one\n    candidates = list(range(1, max_c + 1))\n    if random.random() < 0.1:\n        candidates.append(max_c + 1)\n    # Evaluate delta conflicts locally\n    best_c = curr_c\n    best_score = (10**9, 10**9)  # (after_conflicts, palette_growth)\n    for c in candidates:\n        if c == curr_c and random.random() < 0.5:\n            continue\n        before = 0\n        after = 0\n        for u in adj[v1]:\n            if sol[u-1] == curr_c:\n                before += 1\n            if sol[u-1] == c:\n                after += 1\n        palette_growth = 1 if c > max_c else 0\n        score = (after, palette_growth)\n        if score < best_score or (score == best_score and c < best_c):\n            best_score = score\n            best_c = c\n    new_sol = sol[:]\n    new_sol[v] = best_c\n    new_sol = normalize_palette(new_sol)\n    return (new_sol, (\"RECOLOR\", \"single-vertex\"))\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong but bounded perturbation: recolor multiple vertices (biased to conflicts)\n    using current palette with occasional expansion, followed by normalization.\n    Returns a valid list[int] of length 9.\n    \"\"\"\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    n = 9\n\n    def normalize_palette(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Repair invalid\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c < 1) for c in solution):\n        sol = list(range(1, n+1))\n    else:\n        sol = solution[:]\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    def vertex_conflicts(idx, s):\n        v = idx + 1\n        c = s[idx]\n        return sum(1 for u in adj[v] if s[u-1] == c)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, sol) > 0]\n    pool = conflicted if conflicted else list(range(n))\n\n    steps = max(3, n \/\/ 2)\n    palette = sorted(set(sol))\n    max_c = max(palette) if palette else 1\n\n    for _ in range(steps):\n        v = random.choice(pool)\n        v1 = v + 1\n        neigh_cols = {sol[u-1] for u in adj[v1]}\n        # Prefer lower colors not in neighbors\n        candidates = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n        if not candidates or random.random() < 0.2:\n            candidates.append(max_c + 1)\n        sol[v] = random.choice(candidates)\n        # Optionally do a quick local descent recolor to reduce immediate conflicts\n        if random.random() < 0.5:\n            neigh_cols2 = {sol[u-1] for u in adj[v1]}\n            best_c = sol[v]\n            best_conf = sum(1 for u in adj[v1] if sol[u-1] == best_c)\n            for c in range(1, max(sol)+1):\n                if c == sol[v]:\n                    continue\n                conf = sum(1 for u in adj[v1] if sol[u-1] == c)\n                if conf < best_conf:\n                    best_conf = conf\n                    best_c = c\n            sol[v] = best_c\n\n    sol = normalize_palette(sol)\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"CSV_INT_LEN9. A string of 9 positive integers separated by commas representing colors for vertices 1..9. Example: \"1,2,3,1,2,3,2,1,3\". Also accepted at runtime by code: JSON array string \"[1,2,3,1,2,3,2,1,3]\" or a Python list [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    # Normalize solution to a list of 9 positive ints\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    HARD_PEN = 10**9\n    PEN_GAP = 10**5\n    PEN_EDGE = 10**4\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        return float(HARD_PEN)\n    k = max(arr)\n    if k <= 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: labels must equal {1..k}\n    used = set(arr)\n    if used != set(range(1, k+1)):\n        fitness += PEN_GAP\n    # Edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef _conflicting_vertices(arr, edges):\n    bad = set()\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            bad.add(u)\n            bad.add(v)\n    return list(bad)\n\ndef _min_conflict_color(vertex, arr, adj, k, rng):\n    # choose color in 1..k minimizing conflicts; break ties randomly\n    counts = [0]*(k+1)\n    for nb in adj[vertex]:\n        c = arr[nb-1]\n        if c <= k:\n            counts[c] += 1\n    best = None\n    best_colors = []\n    for c in range(1, k+1):\n        val = counts[c]\n        if best is None or val < best:\n            best = val\n            best_colors = [c]\n        elif val == best:\n            best_colors.append(c)\n    if not best_colors:\n        return arr[vertex-1]\n    # avoid no-op if possible\n    choices = [c for c in best_colors if c != arr[vertex-1]]\n    if choices:\n        return rng.choice(choices)\n    return rng.choice(best_colors)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        # simple deterministic seed: repeating 1..3\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    bad_vertices = _conflicting_vertices(arr, edges)\n    move_choice = rng.random()\n    nbr = list(arr)\n    nb_type = \"LocalChange\"\n    mv_type = \"RecolorMinConflicts\"\n\n    if bad_vertices and move_choice < 0.6:\n        # Min-conflicts recolor on a conflicting vertex\n        v = rng.choice(bad_vertices)\n        new_c = _min_conflict_color(v, nbr, adj, k, rng)\n        nbr[v-1] = new_c\n        nb_type = \"ConflictDriven\"\n        mv_type = \"RecolorMinConflicts\"\n    elif move_choice < 0.8 and k >= 2:\n        # Try swapping two color labels globally (may reduce conflicts without changing k)\n        c1, c2 = rng.sample(range(1, k+1), 2)\n        nbr = [c2 if x == c1 else (c1 if x == c2 else x) for x in nbr]\n        nb_type = \"LabelSwap\"\n        mv_type = \"SwapTwoColors\"\n    elif move_choice < 0.95 and k >= 2:\n        # Merge a sparse color into another to encourage k reduction; relabel for contiguity\n        labels = list(range(1, k+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n        # relabel contiguously only for color-set changes\n        mapping = {}\n        next_label = 1\n        rel = []\n        for x in nbr:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            rel.append(mapping[x])\n        nbr = rel\n        nb_type = \"LabelMerge\"\n        mv_type = \"MergeColors\"\n    else:\n        # Controlled exploration: occasionally add a new color to a conflicting vertex (if any), else random\n        target_idx = (rng.choice(bad_vertices) if bad_vertices else rng.randrange(1,10))\n        nbr[target_idx-1] = k + 1\n        # relabel not needed; k+1 is contiguous by construction\n        nb_type = \"Exploration\"\n        mv_type = \"AddColor\"\n\n    return (nbr, nb_type, mv_type)\n","Perturbacion":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef perturb_solution(solution):\n    # Strong shake: recolor conflicting vertices and diversify labels; ensure contiguity at end.\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    nbr = list(arr)\n    # 1) Targeted recolors on up to 3 vertices (prefer conflicts)\n    conflicting = []\n    for (u,v) in edges:\n        if nbr[u-1] == nbr[v-1]:\n            conflicting.append(u)\n            conflicting.append(v)\n    pool = list({*conflicting, *list(range(1,10))})\n    rng.shuffle(pool)\n    for v in pool[:3]:\n        new_c = rng.randint(1, max(1, k))\n        nbr[v-1] = new_c\n    # 2) With 50%: random permutation of color labels (keeps k)\n    if rng.random() < 0.5:\n        labels = list(range(1, max(nbr)+1))\n        perm = labels[:]\n        rng.shuffle(perm)\n        mp = {labels[i]: perm[i] for i in range(len(labels))}\n        nbr = [mp[x] for x in nbr]\n    # 3) With 35%: merge one color into another\n    if rng.random() < 0.35 and max(nbr) >= 2:\n        labels = list(range(1, max(nbr)+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n    # 4) With 25%: add a new color to a random vertex\n    if rng.random() < 0.25:\n        idx = rng.randrange(9)\n        nbr[idx] = max(nbr) + 1\n    # Relabel to ensure contiguous labels\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in nbr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"CSV_INT_LEN9","Evaluacion":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    # Normalize solution to a list of 9 positive ints\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef evaluate_solution(solution):\n    # Fitness = k + penalties for edge conflicts and non-contiguous labels. Lower is better.\n    HARD_PEN = 10**9\n    PEN_GAP = 5*10**4\n    PEN_EDGE = 10**4\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        return float(HARD_PEN)\n    k = max(arr)\n    if k <= 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    # Contiguity penalty: labels must equal {1..k}\n    used = set(arr)\n    if used != set(range(1, k+1)):\n        fitness += PEN_GAP\n    # Edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef _conflicting_vertices(arr, edges):\n    bad = set()\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            bad.add(u)\n            bad.add(v)\n    return list(bad)\n\ndef _min_conflict_color(vertex, arr, adj, k, rng):\n    # choose color in 1..k minimizing conflicts; break ties randomly\n    counts = [0]*(k+1)\n    for nb in adj[vertex]:\n        c = arr[nb-1]\n        if c <= k:\n            counts[c] += 1\n    best = None\n    best_colors = []\n    for c in range(1, k+1):\n        val = counts[c]\n        if best is None or val < best:\n            best = val\n            best_colors = [c]\n        elif val == best:\n            best_colors.append(c)\n    if not best_colors:\n        return arr[vertex-1]\n    choices = [c for c in best_colors if c != arr[vertex-1]]\n    if choices:\n        return rng.choice(choices)\n    return rng.choice(best_colors)\n\ndef _normalize_labels(arr):\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        # deterministic seed pattern 1..3 repeating\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    bad_vertices = _conflicting_vertices(arr, edges)\n    move_choice = rng.random()\n    nbr = list(arr)\n    nb_type = \"LocalChange\"\n    mv_type = \"RecolorMinConflicts\"\n\n    if bad_vertices and move_choice < 0.6:\n        # Min-conflicts recolor on a conflicting vertex\n        v = rng.choice(bad_vertices)\n        new_c = _min_conflict_color(v, nbr, adj, k, rng)\n        nbr[v-1] = new_c\n        nb_type = \"ConflictDriven\"\n        mv_type = \"RecolorMinConflicts\"\n    elif move_choice < 0.8 and k >= 2:\n        # Swap two color labels globally\n        c1, c2 = rng.sample(range(1, k+1), 2)\n        nbr = [c2 if x == c1 else (c1 if x == c2 else x) for x in nbr]\n        nb_type = \"LabelSwap\"\n        mv_type = \"SwapTwoColors\"\n    elif move_choice < 0.95 and k >= 2:\n        # Merge a sparse color into another; then normalize\n        labels = list(range(1, k+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n        nbr = _normalize_labels(nbr)\n        nb_type = \"LabelMerge\"\n        mv_type = \"MergeColors\"\n    else:\n        # Exploration: add a new color to a conflicting vertex if any, else random vertex\n        idx = (rng.choice(bad_vertices) - 1) if bad_vertices else rng.randrange(9)\n        nbr[idx] = k + 1\n        nb_type = \"Exploration\"\n        mv_type = \"AddColor\"\n\n    return (nbr, nb_type, mv_type)\n","Perturbacion":"import math\nimport random\nimport json\nimport re\n\ndef _parse_solution_any(solution):\n    if isinstance(solution, list):\n        vals = solution\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                vals = json.loads(s)\n            except Exception:\n                return None\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip()!='']\n            try:\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n    else:\n        return None\n    if not isinstance(vals, list) or len(vals) != 9:\n        return None\n    try:\n        out = [int(x) for x in vals]\n    except Exception:\n        return None\n    for x in out:\n        if not isinstance(x, int) or x < 1:\n            return None\n    return out\n\ndef _build_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\ndef _normalize_labels(arr):\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n\ndef perturb_solution(solution):\n    # Strong shake with guaranteed valid output and contiguous labels\n    rng = random.Random()\n    arr = _parse_solution_any(solution)\n    if arr is None:\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _build_adj()\n    k = max(arr)\n    nbr = list(arr)\n\n    # Step 1: recolor up to 3 vertices (prefer from conflicts if present)\n    conflicting = []\n    for (u,v) in edges:\n        if nbr[u-1] == nbr[v-1]:\n            conflicting.append(u)\n            conflicting.append(v)\n    pool = list({*conflicting, *list(range(1,10))})\n    rng.shuffle(pool)\n    for v in pool[:3]:\n        # choose a color in current range to diversify without inflating k too much\n        new_c = rng.randint(1, max(1, k))\n        nbr[v-1] = new_c\n\n    # Step 2: with 50% probability, permute color labels (keeps k)\n    if rng.random() < 0.5:\n        labels = list(range(1, max(nbr)+1))\n        perm = labels[:]\n        rng.shuffle(perm)\n        mp = {labels[i]: perm[i] for i in range(len(labels))}\n        nbr = [mp[x] for x in nbr]\n\n    # Step 3: with 35% probability, merge one color into another\n    if rng.random() < 0.35 and max(nbr) >= 2:\n        labels = list(range(1, max(nbr)+1))\n        src, dst = rng.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n\n    # Step 4: with 20% probability, add a new color to a random vertex\n    if rng.random() < 0.20:\n        idx = rng.randrange(9)\n        nbr[idx] = max(nbr) + 1\n\n    # Normalize to contiguous labels\n    nbr = _normalize_labels(nbr)\n    return nbr\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_standard","Representacion":"CSV_INT_LEN9","Evaluacion":"import math\nimport random\nimport json\nimport re\n\ndef _parse_csv_len9(solution):\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                arr = json.loads(s)\n            except Exception:\n                return None\n            if not isinstance(arr, list) or len(arr) != 9:\n                return None\n            try:\n                out = [int(x) for x in arr]\n            except Exception:\n                return None\n            for x in out:\n                if x < 1:\n                    return None\n            return out\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        if len(parts) != 9:\n            return None\n        try:\n            out = [int(p) for p in parts]\n        except Exception:\n            return None\n        for x in out:\n            if x < 1:\n                return None\n        return out\n    elif isinstance(solution, list):\n        if len(solution) != 9:\n            return None\n        try:\n            out = [int(x) for x in solution]\n        except Exception:\n            return None\n        for x in out:\n            if x < 1:\n                return None\n        return out\n    return None\n\n\ndef evaluate_solution(solution):\n    HARD_PEN = 10**9\n    PEN_GAP = 5*10**4\n    PEN_EDGE = 10**4\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    arr = _parse_csv_len9(solution)\n    if arr is None:\n        return float(HARD_PEN)\n    k = max(arr)\n    if k <= 0:\n        return float(HARD_PEN)\n    fitness = float(k)\n    used = set(arr)\n    if used != set(range(1, k+1)):\n        fitness += PEN_GAP\n    conflicts = 0\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            conflicts += 1\n    fitness += PEN_EDGE * conflicts\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport json\nimport re\n\ndef _parse_csv_len9(solution):\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                arr = json.loads(s)\n            except Exception:\n                return None\n            if not isinstance(arr, list) or len(arr) != 9:\n                return None\n            try:\n                out = [int(x) for x in arr]\n            except Exception:\n                return None\n            for x in out:\n                if x < 1:\n                    return None\n            return out\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        if len(parts) != 9:\n            return None\n        try:\n            out = [int(p) for p in parts]\n        except Exception:\n            return None\n        for x in out:\n            if x < 1:\n                return None\n        return out\n    elif isinstance(solution, list):\n        if len(solution) != 9:\n            return None\n        try:\n            out = [int(x) for x in solution]\n        except Exception:\n            return None\n        for x in out:\n            if x < 1:\n                return None\n        return out\n    return None\n\n\ndef _edges_and_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\n\ndef _normalize_labels(arr):\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n\n\ndef _conflicting_vertices(arr, edges):\n    bad = set()\n    for (u,v) in edges:\n        if arr[u-1] == arr[v-1]:\n            bad.add(u)\n            bad.add(v)\n    return list(bad)\n\n\ndef _min_conflict_color(vertex, arr, adj, k):\n    counts = [0]*(k+1)\n    for nb in adj[vertex]:\n        c = arr[nb-1]\n        if c <= k:\n            counts[c] += 1\n    best = None\n    best_colors = []\n    for c in range(1, k+1):\n        val = counts[c]\n        if best is None or val < best:\n            best = val\n            best_colors = [c]\n        elif val == best:\n            best_colors.append(c)\n    if not best_colors:\n        return arr[vertex-1]\n    choices = [c for c in best_colors if c != arr[vertex-1]]\n    if choices:\n        return random.choice(choices)\n    return random.choice(best_colors)\n\n\ndef _to_csv(arr):\n    return ','.join(str(x) for x in arr)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    arr = _parse_csv_len9(solution)\n    nb_type = \"LocalChange\"\n    mv_type = \"RecolorMinConflicts\"\n    if arr is None:\n        # deterministic fallback pattern 1..3 repeating\n        arr = [((i % 3) + 1) for i in range(9)]\n        nb_type = \"InitFallback\"\n        mv_type = \"SeedPattern\"\n    edges, adj = _edges_and_adj()\n    k = max(arr)\n    bad_vertices = _conflicting_vertices(arr, edges)\n\n    move_choice = random.random()\n    nbr = list(arr)\n\n    if bad_vertices and move_choice < 0.6:\n        v = random.choice(bad_vertices)\n        new_c = _min_conflict_color(v, nbr, adj, k)\n        nbr[v-1] = new_c\n        nb_type = \"ConflictDriven\"\n        mv_type = \"RecolorMinConflicts\"\n    elif move_choice < 0.8 and k >= 2:\n        c1, c2 = random.sample(range(1, k+1), 2)\n        nbr = [c2 if x == c1 else (c1 if x == c2 else x) for x in nbr]\n        nb_type = \"LabelSwap\"\n        mv_type = \"SwapTwoColors\"\n    elif move_choice < 0.95 and k >= 2:\n        labels = list(range(1, k+1))\n        src, dst = random.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n        nbr = _normalize_labels(nbr)\n        nb_type = \"LabelMerge\"\n        mv_type = \"MergeColors\"\n    else:\n        if bad_vertices:\n            idx = random.choice(bad_vertices) - 1\n            nbr[idx] = k + 1\n            nb_type = \"Exploration\"\n            mv_type = \"AddColorOnConflict\"\n        else:\n            # Kempe-like swap on two colors around a random vertex to diversify without increasing k\n            v = random.randrange(1,10)\n            if k >= 2:\n                c1, c2 = random.sample(range(1, k+1), 2)\n                # swap c1<->c2 on connected component induced by {c1,c2} reachable from v\n                target_colors = {c1, c2}\n                visited = set()\n                stack = [v]\n                while stack:\n                    u = stack.pop()\n                    if u in visited:\n                        continue\n                    visited.add(u)\n                    if nbr[u-1] in target_colors:\n                        for w in adj[u]:\n                            if w not in visited and nbr[w-1] in target_colors:\n                                stack.append(w)\n                for u in visited:\n                    if nbr[u-1] == c1:\n                        nbr[u-1] = c2\n                    elif nbr[u-1] == c2:\n                        nbr[u-1] = c1\n                nb_type = \"KempeChain\"\n                mv_type = \"SwapTwoColorsComponent\"\n            else:\n                # fallback recolor\n                v = random.randrange(9)\n                nbr[v] = 1\n                nb_type = \"LocalChange\"\n                mv_type = \"RecolorFallback\"\n\n    return (_to_csv(nbr), nb_type, mv_type)\n","Perturbacion":"import math\nimport random\nimport json\nimport re\n\ndef _parse_csv_len9(solution):\n    if isinstance(solution, str):\n        s = solution.strip()\n        if s.startswith('[') and s.endswith(']'):\n            try:\n                arr = json.loads(s)\n            except Exception:\n                return None\n            if not isinstance(arr, list) or len(arr) != 9:\n                return None\n            try:\n                out = [int(x) for x in arr]\n            except Exception:\n                return None\n            for x in out:\n                if x < 1:\n                    return None\n            return out\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        if len(parts) != 9:\n            return None\n        try:\n            out = [int(p) for p in parts]\n        except Exception:\n            return None\n        for x in out:\n            if x < 1:\n                return None\n        return out\n    elif isinstance(solution, list):\n        if len(solution) != 9:\n            return None\n        try:\n            out = [int(x) for x in solution]\n        except Exception:\n            return None\n        for x in out:\n            if x < 1:\n                return None\n        return out\n    return None\n\n\ndef _edges_and_adj():\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1,10)}\n    for u,v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return edges, adj\n\n\ndef _normalize_labels(arr):\n    mapping = {}\n    next_label = 1\n    rel = []\n    for x in arr:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        rel.append(mapping[x])\n    return rel\n\n\ndef perturb_solution(solution):\n    arr = _parse_csv_len9(solution)\n    if arr is None:\n        arr = [((i % 3) + 1) for i in range(9)]\n    edges, adj = _edges_and_adj()\n    k = max(arr)\n    nbr = list(arr)\n\n    # Step 1: recolor up to 3 vertices (prefer conflicts)\n    conflicting = []\n    for (u,v) in edges:\n        if nbr[u-1] == nbr[v-1]:\n            conflicting.append(u)\n            conflicting.append(v)\n    pool = list({*conflicting, *list(range(1,10))})\n    random.shuffle(pool)\n    for v in pool[:3]:\n        new_c = random.randint(1, max(1, k))\n        nbr[v-1] = new_c\n\n    # Step 2: with 50% probability, permute labels\n    if random.random() < 0.5:\n        labels = list(range(1, max(nbr)+1))\n        perm = labels[:]\n        random.shuffle(perm)\n        mp = {labels[i]: perm[i] for i in range(len(labels))}\n        nbr = [mp[x] for x in nbr]\n\n    # Step 3: with 35% probability, merge a color into another\n    if random.random() < 0.35 and max(nbr) >= 2:\n        labels = list(range(1, max(nbr)+1))\n        src, dst = random.sample(labels, 2)\n        nbr = [dst if x == src else x for x in nbr]\n\n    # Step 4: with 20% probability, add a new color only if conflicts remain\n    if random.random() < 0.20:\n        has_conflict = False\n        for (u,v) in edges:\n            if nbr[u-1] == nbr[v-1]:\n                has_conflict = True\n                break\n        if has_conflict:\n            idx = random.randrange(9)\n            nbr[idx] = max(nbr) + 1\n\n    nbr = _normalize_labels(nbr)\n    return ','.join(str(x) for x in nbr)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LENGTH_9_POSITIVE. Solution is a list [x1,...,x9] of positive integers for students 1..9 (1-indexed).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    LARGE = int(math.pow(10, 6))\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return LARGE\n    # Embedded graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    num_groups = len(set(solution))\n    # Heavy penalty for conflicts; lower is better\n    return num_groups + conflicts * 1000\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        solution = [random.randint(1, 3) for _ in range(9)]\n    sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: color class sizes\n    cls_sizes = {}\n    for c in sol:\n        cls_sizes[c] = cls_sizes.get(c, 0) + 1\n\n    # Pick a random vertex\n    idx = random.randrange(9)\n    current_color = sol[idx]\n    current_colors = sorted(set(sol))\n\n    # Compute current conflicts at idx\n    cur_conf_at_idx = 0\n    for nb in adj[idx]:\n        if sol[nb] == current_color:\n            cur_conf_at_idx += 1\n\n    # Candidate palette: prefer existing colors; allow new color rarely if conflicted and no improving move\n    candidate_colors = list(current_colors)\n    # Exclude current color\n    candidate_colors = [c for c in candidate_colors if c != current_color]\n\n    # Evaluate candidates: minimize (conflicts_at_idx_after, resulting_num_colors, random_tiebreak)\n    best_c = None\n    best_key = None\n    for c in candidate_colors:\n        conf = 0\n        for nb in adj[idx]:\n            if sol[nb] == c:\n                conf += 1\n        # Simulate resulting number of colors: if we move away from a singleton class, it may reduce k\n        resulting_colors = set(sol)\n        if cls_sizes.get(current_color, 0) == 1:\n            # Moving away deletes current_color from palette\n            if c not in resulting_colors or c == current_color:\n                pass\n            resulting_k = len(resulting_colors) - 1\n        else:\n            # No deletion; ensure c is in palette (it is by construction)\n            resulting_k = len(resulting_colors)\n        key = (conf, resulting_k, random.random())\n        if best_key is None or key < best_key:\n            best_key = key\n            best_c = c\n\n    # If no candidate or no improvement possible and currently conflicted, optionally introduce a new color\n    if best_c is None or (cur_conf_at_idx > 0 and best_key is not None and best_key[0] >= cur_conf_at_idx and random.random() < 0.1):\n        new_color = max(current_colors) + 1\n        best_c = new_color\n\n    neighbor = sol[:]\n    neighbor[idx] = best_c\n\n    # Normalize colors to 1..k in stable order\n    mapping = {}\n    next_label = 1\n    for c in neighbor:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    neighbor = [mapping[c] for c in neighbor]\n\n    return neighbor, \"SingleNodeRecolor\", \"BestImprovingLocal\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # Simple multi-recolor shake\n        for _ in range(random.randint(2, 5)):\n            i = random.randrange(9)\n            palette = list(range(1, max(colors) + 2))\n            palette = [c for c in palette if c != sol[i]]\n            sol[i] = random.choice(palette)\n    else:\n        # Perform 1..3 Kempe-chain swaps on random color pairs\n        for _ in range(random.randint(1, 3)):\n            colors = sorted(set(sol))\n            if len(colors) < 2:\n                break\n            a, b = random.sample(colors, 2)\n            # Choose a start vertex with color in {a,b}\n            candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n            if not candidates:\n                continue\n            start = random.choice(candidates)\n            # BFS over subgraph induced by colors {a,b}\n            visited = [False]*9\n            q = deque([start])\n            visited[start] = True\n            component = [start]\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited[v] and (sol[v] == a or sol[v] == b):\n                        visited[v] = True\n                        q.append(v)\n                        component.append(v)\n            # Swap colors a<->b on this component\n            for v in component:\n                sol[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        # Small random recolors to diversify\n        for _ in range(random.randint(1, 3)):\n            i = random.randrange(9)\n            palette = list(range(1, max(sol) + 1))\n            if random.random() < 0.2:\n                palette.append(max(palette) + 1)\n            palette = [c for c in palette if c != sol[i]]\n            if palette:\n                sol[i] = random.choice(palette)\n\n    # Normalize colors to 1..k\n    mapping = {}\n    next_label = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_label\n            next_label += 1\n    sol = [mapping[c] for c in sol]\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LENGTH_9_POSITIVE. Each solution is a list of 9 positive integers [x1,...,x9] for students 1..9 (1-indexed).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Large penalty baseline\n    LARGE = int(math.pow(10, 6))\n\n    # Basic validation: list of length 9, positive integers, and bounded labels\n    if not isinstance(solution, list) or len(solution) != 9:\n        return LARGE\n    for c in solution:\n        if not isinstance(c, int) or c <= 0 or c > 9:\n            return LARGE\n\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts with early exit to save time if very infeasible\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n            if conflicts >= 3:  # fast-exit threshold\n                break\n\n    # Compute number of groups\n    num_groups = len(set(solution))\n\n    # Adaptive penalty: scale conflicts relative to palette size to balance phases\n    # Conflicts dominate, but allow SA to explore near-feasible moves\n    penalty = 500  # fixed strong penalty per conflict\n\n    return num_groups + conflicts * penalty","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Validate or initialize fallback\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: compute conflicts per vertex\n    def vertex_conflicts(i, arr):\n        c = 0\n        for nb in adj[i]:\n            if arr[nb] == arr[i]:\n                c += 1\n        return c\n\n    # DSATUR-like priority: vertices with conflicts first, then by saturated degree\n    colors = set(sol)\n    sat_deg = []\n    for i in range(9):\n        sat_colors = set(sol[nb] for nb in adj[i])\n        sat_deg.append(len(sat_colors))\n\n    conflicted = [i for i in range(9) if vertex_conflicts(i, sol) > 0]\n    if conflicted:\n        candidates = conflicted\n    else:\n        # No conflicts: try to reduce k by moving a vertex from the smallest color class\n        cls_sizes = {}\n        for c in sol:\n            cls_sizes[c] = cls_sizes.get(c, 0) + 1\n        smallest_class = min(cls_sizes, key=lambda c: (cls_sizes[c], c))\n        candidates = [i for i, c in enumerate(sol) if c == smallest_class]\n\n    # Pick the highest priority index (break ties by higher saturated degree, then random)\n    best_i = max(candidates, key=lambda i: (vertex_conflicts(i, sol), sat_deg[i], random.random()))\n\n    current_color = sol[best_i]\n    palette = sorted(set(sol))\n\n    # Evaluate recoloring options\n    def conflicts_if_color(i, color):\n        cnt = 0\n        for nb in adj[i]:\n            if sol[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Candidate colors are current palette excluding current color; allow new color only to resolve conflicts when no neutral option exists\n    candidate_colors = [c for c in palette if c != current_color]\n\n    # Tie-breakers: prefer reducing conflicts, then reducing k if moving from singleton class, then random\n    cls_sizes = {}\n    for c in sol:\n        cls_sizes[c] = cls_sizes.get(c, 0) + 1\n\n    best_color = None\n    best_key = None\n    cur_conf = vertex_conflicts(best_i, sol)\n    for c in candidate_colors:\n        conf = conflicts_if_color(best_i, c)\n        # Predict resulting k\n        resulting_k = len(palette) - (1 if cls_sizes[current_color] == 1 else 0)\n        key = (conf, resulting_k, random.random())\n        if best_key is None or key < best_key:\n            best_key = key\n            best_color = c\n\n    # If still conflicted and no candidate reduces conflicts, allow introducing a new color as a last resort\n    if cur_conf > 0 and (best_key is None or best_key[0] >= cur_conf):\n        new_color = (max(palette) if palette else 0) + 1\n        best_color = new_color\n\n    neighbor = sol[:]\n    neighbor[best_i] = best_color\n\n    # Normalize labels to 1..k in first-appearance order to contain palette growth\n    mapping = {}\n    nxt = 1\n    for c in neighbor:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    neighbor = [mapping[c] for c in neighbor]\n\n    return neighbor","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Validate or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_swap(arr, a, b):\n        # Choose a start vertex with color a or b\n        candidates = [i for i, c in enumerate(arr) if c == a or c == b]\n        if not candidates:\n            return arr\n        start = random.choice(candidates)\n        # BFS over subgraph induced by colors {a,b}\n        visited = [False]*9\n        q = deque([start])\n        visited[start] = True\n        component = [start]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and (arr[v] == a or arr[v] == b):\n                    visited[v] = True\n                    q.append(v)\n                    component.append(v)\n        # Swap colors a <-> b on this component\n        for v in component:\n            arr[v] = a if arr[v] == b else (b if arr[v] == a else arr[v])\n        return arr\n\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # Shake by random recolors within bounded palette\n        for _ in range(random.randint(2, 5)):\n            i = random.randrange(9)\n            palette = list(range(1, max(colors) + 2)) if colors else [1,2,3]\n            if sol[i] in palette:\n                palette.remove(sol[i])\n            sol[i] = random.choice(palette)\n    else:\n        # 1..3 Kempe-chain swaps on random color pairs\n        for _ in range(random.randint(1, 3)):\n            colors = sorted(set(sol))\n            if len(colors) < 2:\n                break\n            a, b = random.sample(colors, 2)\n            sol = kempe_chain_swap(sol, a, b)\n        # Small random recolors to diversify while keeping palette bounded\n        for _ in range(random.randint(1, 3)):\n            i = random.randrange(9)\n            palette = list(range(1, max(sol) + 1))\n            if sol[i] in palette:\n                palette.remove(sol[i])\n            if random.random() < 0.2:\n                palette.append(max(palette) + 1)\n            if palette:\n                sol[i] = random.choice(palette)\n\n    # Normalize colors to 1..k\n    mapping = {}\n    nxt = 1\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nxt\n            nxt += 1\n    sol = [mapping[c] for c in sol]\n    return sol","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"LIST_INT_LENGTH_9_POSITIVE. A solution is a Python list of 9 positive integers [x1,...,x9] assigning a group label to each student 1..9. Labels are normalized to consecutive integers starting at 1.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n\n    # Embedded graph (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n\n    # Count conflicts exactly (no early exit)\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n\n    # Number of used groups\n    k = len(set(solution))\n\n    # Lexicographic scoring: conflicts dominate group count\n    W = 1000  # >> 9 ensures feasibility prioritized\n    return conflicts * W + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure a valid working copy or initialize\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n\n    # Graph data (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    # Build adjacency list (0-indexed)\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def vertex_conflicts(i, arr):\n        c = 0\n        for nb in adj[i]:\n            if arr[nb] == arr[i]:\n                c += 1\n        return c\n\n    def conflicts_if_color(i, color, arr):\n        cnt = 0\n        for nb in adj[i]:\n            if arr[nb] == color:\n                cnt += 1\n        return cnt\n\n    # Current conflict status\n    conflicted = [i for i in range(9) if vertex_conflicts(i, sol) > 0]\n\n    move_type = \"recolor\"\n    nb_type = \"1-opt\"\n\n    if conflicted:\n        # Resolve conflicts: pick vertex with highest conflicts, break ties by degree\n        best_i = max(conflicted, key=lambda i: (vertex_conflicts(i, sol), len(adj[i]), random.random()))\n        current_color = sol[best_i]\n        palette = sorted(set(sol))\n        # Try recolors within existing palette that minimize local conflicts\n        candidates = [c for c in palette if c != current_color]\n        best_color = None\n        best_conf = None\n        for c in candidates:\n            conf = conflicts_if_color(best_i, c, sol)\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_color = c\n        # As last resort, allow introducing a new color only if it strictly reduces conflicts\n        if best_conf is None or best_conf >= vertex_conflicts(best_i, sol):\n            newc = (max(palette) if palette else 0) + 1\n            new_conf = conflicts_if_color(best_i, newc, sol)\n            if new_conf < vertex_conflicts(best_i, sol):\n                best_color = newc\n        neighbor = sol[:]\n        if best_color is not None:\n            neighbor[best_i] = best_color\n        else:\n            # Fallback random recolor among palette\n            alt = [c for c in sorted(set(sol)) if c != current_color]\n            if alt:\n                neighbor[best_i] = random.choice(alt)\n        neighbor = normalize(neighbor)\n        return neighbor, nb_type, move_type\n\n    # Feasible state: attempt k-reduction while preserving feasibility\n    palette = sorted(set(sol))\n    cls_indices = {}\n    for i, c in enumerate(sol):\n        cls_indices.setdefault(c, []).append(i)\n    target_color = min(palette, key=lambda c: (len(cls_indices[c]), c))\n\n    # Try to move one vertex from target_color to another existing color without creating conflicts\n    movable = []\n    for i in cls_indices[target_color]:\n        for c in palette:\n            if c == target_color:\n                continue\n            if conflicts_if_color(i, c, sol) == 0:\n                movable.append((i, c))\n    if movable:\n        i, c = random.choice(movable)\n        neighbor = sol[:]\n        neighbor[i] = c\n        # If target color becomes empty, labels will be normalized\n        neighbor = normalize(neighbor)\n        return neighbor, nb_type, move_type\n\n    # If direct moves fail, try a Kempe-chain swap between target_color and a random other color\n    def kempe_chain_swap(arr, color_a, color_b):\n        # pick a seed vertex from target color to bias elimination attempts\n        seed_candidates = [i for i, cc in enumerate(arr) if cc == color_a]\n        if not seed_candidates:\n            return arr\n        start = random.choice(seed_candidates)\n        visited = [False]*9\n        q = deque([start])\n        visited[start] = True\n        component = [start]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and (arr[v] == color_a or arr[v] == color_b):\n                    visited[v] = True\n                    q.append(v)\n                    component.append(v)\n        out = arr[:]\n        for v in component:\n            out[v] = color_a if arr[v] == color_b else (color_b if arr[v] == color_a else arr[v])\n        return out\n\n    other_colors = [c for c in palette if c != target_color]\n    if other_colors:\n        c2 = random.choice(other_colors)\n        neighbor = kempe_chain_swap(sol, target_color, c2)\n        neighbor = normalize(neighbor)\n        move_type = \"kempe\"\n        nb_type = \"chain-swap\"\n        return neighbor, nb_type, move_type\n\n    # Fallback: random safe recolor that keeps feasibility\n    i = random.randrange(9)\n    safe_colors = [c for c in palette if c != sol[i] and conflicts_if_color(i, c, sol) == 0]\n    neighbor = sol[:]\n    if safe_colors:\n        neighbor[i] = random.choice(safe_colors)\n    neighbor = normalize(neighbor)\n    return neighbor, nb_type, move_type\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(c, int) or c <= 0) for c in solution):\n        s = [random.randint(1, 3) for _ in range(9)]\n    else:\n        s = list(solution)\n\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_chain_swap(arr, a, b):\n        # choose a random seed among vertices colored a or b\n        candidates = [i for i, c in enumerate(arr) if c == a or c == b]\n        if not candidates:\n            return arr\n        start = random.choice(candidates)\n        visited = [False]*9\n        q = deque([start])\n        visited[start] = True\n        component = [start]\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if not visited[v] and (arr[v] == a or arr[v] == b):\n                    visited[v] = True\n                    q.append(v)\n                    component.append(v)\n        out = arr[:]\n        for v in component:\n            out[v] = a if arr[v] == b else (b if arr[v] == a else arr[v])\n        return out\n\n    colors = sorted(set(s))\n\n    # Apply 1-3 Kempe swaps to shake structure without inflating palette\n    num_swaps = random.randint(1, 3) if len(colors) >= 2 else 0\n    for _ in range(num_swaps):\n        colors = sorted(set(s))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        s = kempe_chain_swap(s, a, b)\n\n    # Light recolors within existing palette to diversify\n    steps = random.randint(1, 3)\n    for _ in range(steps):\n        i = random.randrange(9)\n        palette = sorted(set(s))\n        choices = [c for c in palette if c != s[i]]\n        if choices:\n            s[i] = random.choice(choices)\n\n    s = normalize(s)\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a graph coloring solution encoded as a CSV string of 9 positive integers.\n    Returns a scalar fitness where lower is better. Feasible colorings return K=max(color).\n    Infeasible or invalid encodings get large penalties.\n    \"\"\"\n    # Problem constants embedded (no globals)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Type and format checks\n    if not isinstance(solution, str):\n        return 10**9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    if len(parts) != n:\n        return 10**9\n    colors = []\n    try:\n        for p in parts:\n            c = int(p)\n            colors.append(c)\n    except Exception:\n        return 10**9\n    # Domain checks\n    if any((not isinstance(c, int) or c < 1) for c in colors):\n        return 10**9\n\n    K = max(colors) if colors else 10**9\n\n    # Constraint violation count\n    conflicts = 0\n    for (u, v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        # strong per-conflict penalty keeps gradient informative; feasible solutions always dominate infeasible\n        return 10**6 * conflicts + K\n\n    # Feasible: minimize K\n    return K\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> tuple[str, str, str]:\n    \"\"\"\n    Generate a neighboring solution by biased recoloring with feasibility awareness.\n    Returns: (neighbor_solution_csv, NB_Type, Movement_Type)\n    NB_Type: \"LocalNB\"\n    Movement_Type: one of {\"RecolorOne\", \"RecolorMaxToLower\"}\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        # Simple greedy DSATUR-like initializer\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            # select vertex with max saturation (distinct neighbor colors), break ties by degree\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency for feasibility checks\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    max_k = max(colors)\n\n    # Identify conflicts and max-color vertices\n    conflicted = []\n    for (u,v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicted.append(u-1)\n            conflicted.append(v-1)\n    conflicted = list(sorted(set(conflicted)))\n\n    candidates = conflicted if conflicted else [i for i,c in enumerate(colors) if c == max_k]\n    if not candidates:\n        candidates = list(range(n))\n\n    v = random.choice(candidates)\n\n    # Compute forbidden colors at v\n    forbidden = {colors[u] for u in adj[v]}\n\n    move_type = \"RecolorOne\"\n    # Prefer smallest feasible color, favor lowering K\n    target_palette = list(range(1, max_k)) if not conflicted else list(range(1, max_k+1))\n    new_color = None\n    for c in target_palette:\n        if c not in forbidden and c != colors[v]:\n            new_color = c\n            break\n    if new_color is None:\n        # If no feasible lower color, try any different color within expanded palette\n        upper = min(n, max_k + (1 if random.random() < 0.2 and max_k < n else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = colors[v]\n    else:\n        if new_color < colors[v]:\n            move_type = \"RecolorMaxToLower\"\n\n    new_cols = colors[:]\n    new_cols[v] = new_color\n\n    return to_csv(new_cols), \"LocalNB\", move_type\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation combining multi-vertex min-conflicts recoloring and optional Kempe chain swap.\n    Returns a CSV string encoding the perturbed solution.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def kempe_swap(cols, a, b, start):\n        # Swap colors a and b on the connected component containing start in the subgraph induced by {a,b}\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        if cols[start] not in (a,b):\n            return cols\n        visited = [False]*n\n        q = deque([start])\n        visited[start] = True\n        comp = []\n        while q:\n            v = q.popleft()\n            if cols[v] in (a,b):\n                comp.append(v)\n                for u in adj[v]:\n                    if not visited[u] and cols[u] in (a,b):\n                        visited[u] = True\n                        q.append(u)\n        new_cols = cols[:]\n        for v in comp:\n            new_cols[v] = a if cols[v] == b else b\n        return new_cols\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    max_k = max(colors)\n\n    # Multi-vertex min-conflicts recoloring on a random subset (20-40% of vertices)\n    subset_size = max(2, int(n * random.uniform(0.2, 0.4)))\n    idxs = random.sample(range(n), subset_size)\n\n    # Build adjacency once\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    for v in idxs:\n        forbidden = {colors[u] for u in adj[v]}\n        # Prefer small palette, allow temporary expansion with small prob\n        allow_expand = (random.random() < 0.3) and (max_k < n)\n        upper = max_k + 1 if allow_expand else max_k\n        upper = min(upper, n)\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        # Greedy: pick smallest color not forbidden if available, else random fallback\n        feasible = [c for c in choices if c not in forbidden]\n        if feasible:\n            new_c = min(feasible)\n        else:\n            new_c = random.choice(choices) if choices else colors[v]\n        colors[v] = new_c\n        if new_c > max_k:\n            max_k = new_c\n\n    # Optional Kempe chain swap to escape plateaus\n    if max_k >= 3 and random.random() < 0.5:\n        palette = sorted(set(colors))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            start_candidates = [i for i,c in enumerate(colors) if c in (a,b)]\n            if start_candidates:\n                start = random.choice(start_candidates)\n                colors = kempe_swap(colors, a, b, start)\n\n    # Optional push-down: try to reduce highest color by recoloring its vertices to lower feasible colors\n    max_k = max(colors)\n    max_vs = [i for i,c in enumerate(colors) if c == max_k]\n    random.shuffle(max_vs)\n    for v in max_vs:\n        forbidden = {colors[u] for u in adj[v]}\n        for c in range(1, max_k):\n            if c not in forbidden:\n                colors[v] = c\n                break\n\n    return to_csv(colors)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a graph coloring solution encoded as a CSV string of 9 positive integers.\n    Lower score is better. Feasible colorings return K=max(color).\n    Infeasible\/invalid encodings get large penalties (1e6 per conflict).\n    \"\"\"\n    # Problem constants embedded (no globals)\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Type and format checks\n    if not isinstance(solution, str):\n        return 10**9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    if len(parts) != n:\n        return 10**9\n    colors = []\n    try:\n        for p in parts:\n            c = int(p)\n            colors.append(c)\n    except Exception:\n        return 10**9\n    if any((not isinstance(c, int) or c < 1) for c in colors):\n        return 10**9\n\n    K = max(colors) if colors else 10**9\n\n    conflicts = 0\n    for (u, v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return 10**6 * conflicts + K\n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Return a neighbor solution and a meta string (\"NBType,MoveType\").\n    Two-value return avoids unpacking mismatch in local solvers.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        # Greedy DSATUR-like initializer\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def canonicalize(cols):\n        # Relabel colors by first-appearance order to reduce symmetry\n        mapping = {}\n        next_label = 1\n        canon = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            canon.append(mapping[c])\n        return canon\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency once\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Conflict accounting and priorities\n    conflict_count = [0]*n\n    for (u1,v1) in E:\n        if colors[u1-1] == colors[v1-1]:\n            conflict_count[u1-1] += 1\n            conflict_count[v1-1] += 1\n\n    max_k = max(colors)\n    degrees = [len(adj[i]) for i in range(n)]\n\n    # Candidate selection: prioritize conflicted, else vertices with color==max_k; break ties by (conflicts, degree)\n    candidates = list(range(n))\n    candidates.sort(key=lambda i: (\n        -(conflict_count[i] > 0),  # conflicted first\n        -(colors[i] == max_k),     # then max color\n        -conflict_count[i],        # more conflicts\n        -degrees[i]                # higher degree\n    ))\n\n    # Select top subset to sample from\n    pool = candidates[:max(2, n\/\/3)]\n    v = random.choice(pool)\n\n    forbidden = {colors[u] for u in adj[v]}\n\n    move_type = \"RecolorOne\"\n\n    # Try to push down if on max color and feasible\n    target_palette = list(range(1, max_k)) if conflict_count[v] == 0 else list(range(1, max_k+1))\n\n    new_color = None\n    for c in target_palette:\n        if c not in forbidden and c != colors[v]:\n            new_color = c\n            break\n\n    # If stuck, attempt Kempe chain swap with a random neighbor color\n    if new_color is None and adj[v]:\n        neigh_colors = list({colors[u] for u in adj[v]})\n        if neigh_colors:\n            a = colors[v]\n            b = random.choice(neigh_colors)\n            if a != b:\n                # BFS on subgraph induced by {a,b}\n                visited = [False]*n\n                q = deque([v])\n                visited[v] = True\n                comp = []\n                while q:\n                    x = q.popleft()\n                    if colors[x] in (a,b):\n                        comp.append(x)\n                        for y in adj[x]:\n                            if not visited[y] and colors[y] in (a,b):\n                                visited[y] = True\n                                q.append(y)\n                trial = colors[:]\n                for x in comp:\n                    trial[x] = a if colors[x] == b else b\n                # Accept Kempe if it reduces conflicts or lowers max color after canonicalization\n                def score(cols):\n                    K = max(cols)\n                    conflicts = 0\n                    for (uu,vv) in E:\n                        if cols[uu-1] == cols[vv-1]:\n                            conflicts += 1\n                    return (conflicts, K)\n                if score(trial) < score(colors):\n                    colors = trial\n                    move_type = \"KempeSwap\"\n\n    # If still no recolor chosen, try any different color within limited palette\n    if new_color is None:\n        upper = min(n, max_k + (1 if random.random() < 0.2 and max_k < n else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = colors[v]\n\n    new_cols = colors[:]\n    if new_color != new_cols[v]:\n        new_cols[v] = new_color\n        if new_color < colors[v] and colors[v] == max_k:\n            move_type = \"RecolorMaxToLower\"\n\n    # Canonical relabel to stabilize search\n    new_cols = canonicalize(new_cols)\n\n    return to_csv(new_cols), f\"LocalNB,{move_type}\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multi-vertex recolor + optional color-class swap + optional Kempe swap + push-down.\n    Returns CSV string.\n    \"\"\"\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v = None\n            best_key = None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def canonicalize(cols):\n        mapping = {}\n        next_label = 1\n        canon = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            canon.append(mapping[c])\n        return canon\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    max_k = max(colors)\n\n    # 1) Multi-vertex min-conflicts recoloring on 20-40% of vertices\n    subset_size = max(2, int(n * random.uniform(0.2, 0.4)))\n    idxs = random.sample(range(n), subset_size)\n    for v in idxs:\n        forbidden = {colors[u] for u in adj[v]}\n        allow_expand = (random.random() < 0.35) and (max_k < n)\n        upper = min(n, max_k + (1 if allow_expand else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        feasible = [c for c in choices if c not in forbidden]\n        new_c = (min(feasible) if feasible else (random.choice(choices) if choices else colors[v]))\n        colors[v] = new_c\n        if new_c > max_k:\n            max_k = new_c\n\n    # 2) Optional global color-class swap to escape label traps\n    palette = sorted(set(colors))\n    if len(palette) >= 2 and random.random() < 0.5:\n        a, b = random.sample(palette, 2)\n        colors = [a if c == b else (b if c == a else c) for c in colors]\n\n    # 3) Optional Kempe chain swap starting from a random vertex\n    if max_k >= 2 and random.random() < 0.6:\n        a, b = random.sample(sorted(set(colors)), 2)\n        start_candidates = [i for i,c in enumerate(colors) if c in (a,b)]\n        if start_candidates:\n            start = random.choice(start_candidates)\n            # BFS on subgraph induced by {a,b}\n            visited = [False]*n\n            q = deque([start])\n            visited[start] = True\n            comp = []\n            while q:\n                x = q.popleft()\n                if colors[x] in (a,b):\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and colors[y] in (a,b):\n                            visited[y] = True\n                            q.append(y)\n            for x in comp:\n                colors[x] = a if colors[x] == b else b\n\n    # 4) Push-down: try to lower highest color class\n    max_k = max(colors)\n    max_vs = [i for i,c in enumerate(colors) if c == max_k]\n    random.shuffle(max_vs)\n    for v in max_vs:\n        forbidden = {colors[u] for u in adj[v]}\n        lowered = False\n        for c in range(1, max_k):\n            if c not in forbidden:\n                colors[v] = c\n                lowered = True\n                break\n        if not lowered:\n            # try swap with a random lower color\n            lower_palette = [c for c in range(1, max_k) if c not in forbidden]\n            if lower_palette:\n                colors[v] = random.choice(lower_palette)\n\n    colors = canonicalize(colors)\n\n    return to_csv(colors)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a graph coloring solution encoded as a CSV string of 9 positive integers.\n    Lower score is better. Feasible colorings return K=max(color).\n    Infeasible\/invalid encodings get large penalties (1e5 per conflict) + format penalty.\n    \"\"\"\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    # Type and format checks\n    if not isinstance(solution, str):\n        return 10**9\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    if len(parts) != n:\n        return 10**9\n    try:\n        colors = [int(p) for p in parts]\n    except Exception:\n        return 10**9\n    if any((c < 1) for c in colors):\n        return 10**9\n\n    K = max(colors)\n    conflicts = 0\n    for (u, v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts > 0:\n        return 100000 * conflicts + K\n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Generate a neighboring CSV solution and a meta string \"LocalNB,<MoveType>\".\n    Robust to invalid input by seeding via DSATUR-like heuristic.\n    \"\"\"\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v, best_key = None, None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def canonicalize(cols):\n        mapping = {}\n        next_label = 1\n        canon = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            canon.append(mapping[c])\n        return canon\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Conflict counts\n    conflict_count = [0]*n\n    for (u,v) in E:\n        if colors[u-1] == colors[v-1]:\n            conflict_count[u-1] += 1\n            conflict_count[v-1] += 1\n\n    max_k = max(colors)\n    degrees = [len(adj[i]) for i in range(n)]\n\n    # Candidate selection\n    candidates = list(range(n))\n    candidates.sort(key=lambda i: (\n        -(conflict_count[i] > 0),\n        -(colors[i] == max_k),\n        -conflict_count[i],\n        -degrees[i]\n    ))\n    pool = candidates[:max(2, n\/\/3)]\n    v = random.choice(pool)\n\n    forbidden = {colors[u] for u in adj[v]}\n    move_type = \"RecolorOne\"\n\n    # Prefer reducing color if possible\n    target_palette = list(range(1, max_k)) if conflict_count[v] == 0 else list(range(1, max_k+1))\n    new_color = None\n    for c in target_palette:\n        if c not in forbidden and c != colors[v]:\n            new_color = c\n            break\n\n    # Kempe chain if stuck\n    if new_color is None and adj[v]:\n        neigh_colors = list({colors[u] for u in adj[v]})\n        if neigh_colors:\n            a = colors[v]\n            b = random.choice(neigh_colors)\n            if a != b:\n                visited = [False]*n\n                q = deque([v])\n                visited[v] = True\n                comp = []\n                while q:\n                    x = q.popleft()\n                    if colors[x] in (a,b):\n                        comp.append(x)\n                        for y in adj[x]:\n                            if not visited[y] and colors[y] in (a,b):\n                                visited[y] = True\n                                q.append(y)\n                trial = colors[:]\n                for x in comp:\n                    trial[x] = a if colors[x] == b else b\n                # Accept if better in lexicographic (conflicts, K)\n                def score(cols):\n                    K = max(cols)\n                    conflicts = 0\n                    for (uu,vv) in E:\n                        if cols[uu-1] == cols[vv-1]:\n                            conflicts += 1\n                    return (conflicts, K)\n                if score(trial) < score(colors):\n                    colors = trial\n                    move_type = \"KempeSwap\"\n\n    if new_color is None:\n        upper = min(n, max_k + (1 if random.random() < 0.2 and max_k < n else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = colors[v]\n\n    new_cols = colors[:]\n    if new_color != new_cols[v]:\n        prev = new_cols[v]\n        new_cols[v] = new_color\n        if new_color < prev and prev == max_k:\n            move_type = \"RecolorMaxToLower\"\n\n    new_cols = canonicalize(new_cols)\n    return to_csv(new_cols), f\"LocalNB,{move_type}\"\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: multi-vertex recolor + optional color-class swap + optional Kempe swap + push-down.\n    Returns CSV string robustly.\n    \"\"\"\n    n = 9\n    E = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\n    def parse_csv(sol_str: str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n\n    def to_csv(cols):\n        return ','.join(str(c) for c in cols)\n\n    def build_seed_dsat():\n        adj = [[] for _ in range(n)]\n        for (u,v) in E:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        colors = [0]*n\n        uncolored = set(range(n))\n        while uncolored:\n            best_v, best_key = None, None\n            for v in uncolored:\n                neigh_cols = {colors[u] for u in adj[v] if colors[u] != 0}\n                key = (len(neigh_cols), len(adj[v]))\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best_v = v\n            used = {colors[u] for u in adj[best_v] if colors[u] != 0}\n            c = 1\n            while c in used:\n                c += 1\n            colors[best_v] = c\n            uncolored.remove(best_v)\n        return colors\n\n    def canonicalize(cols):\n        mapping = {}\n        next_label = 1\n        canon = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_label\n                next_label += 1\n            canon.append(mapping[c])\n        return canon\n\n    # Parse or initialize\n    try:\n        colors = parse_csv(solution) if isinstance(solution, str) else []\n    except Exception:\n        colors = []\n    if not isinstance(colors, list) or len(colors) != n or any((not isinstance(c, int) or c < 1) for c in colors):\n        colors = build_seed_dsat()\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    max_k = max(colors)\n\n    # 1) Multi-vertex recolor (biased toward feasibility)\n    subset_size = max(2, int(n * random.uniform(0.25, 0.45)))\n    idxs = random.sample(range(n), subset_size)\n    for v in idxs:\n        forbidden = {colors[u] for u in adj[v]}\n        allow_expand = (random.random() < 0.25) and (max_k < n)\n        upper = min(n, max_k + (1 if allow_expand else 0))\n        choices = [c for c in range(1, upper+1) if c != colors[v]]\n        feasible = [c for c in choices if c not in forbidden]\n        new_c = (random.choice(feasible) if feasible else (random.choice(choices) if choices else colors[v]))\n        colors[v] = new_c\n        if new_c > max_k:\n            max_k = new_c\n\n    # 2) Optional color-class relabel swap\n    palette = sorted(set(colors))\n    if len(palette) >= 2 and random.random() < 0.5:\n        a, b = random.sample(palette, 2)\n        colors = [a if c == b else (b if c == a else c) for c in colors]\n\n    # 3) Optional Kempe chain swap from random start\n    if len(set(colors)) >= 2 and random.random() < 0.6:\n        a, b = random.sample(sorted(set(colors)), 2)\n        start_candidates = [i for i,c in enumerate(colors) if c in (a,b)]\n        if start_candidates:\n            start = random.choice(start_candidates)\n            visited = [False]*n\n            q = deque([start])\n            visited[start] = True\n            comp = []\n            while q:\n                x = q.popleft()\n                if colors[x] in (a,b):\n                    comp.append(x)\n                    for y in adj[x]:\n                        if not visited[y] and colors[y] in (a,b):\n                            visited[y] = True\n                            q.append(y)\n            for x in comp:\n                colors[x] = a if colors[x] == b else b\n\n    # 4) Push-down highest color class when possible\n    max_k = max(colors)\n    max_vs = [i for i,c in enumerate(colors) if c == max_k]\n    random.shuffle(max_vs)\n    for v in max_vs:\n        forbidden = {colors[u] for u in adj[v]}\n        for c in range(1, max_k):\n            if c not in forbidden:\n                colors[v] = c\n                break\n\n    colors = canonicalize(colors)\n    return to_csv(colors)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"LIST_INT_LEN9_POSITIVE_GROUP_IDS_NORMALIZED: solution is a list of 9 positive integers where index i maps to vertex i+1 and values are color IDs relabeled to contiguous 1..K in order of first appearance.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Fast validation and evaluation. Returns groups_used + 1000*conflicts.\n    # Embedded graph (1-indexed edges)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Basic structural checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    conflicts = 0\n    s = solution\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Descriptor only; actual move implemented by the metaheuristic using this specification.\n    # Neighborhood: pick one vertex uniformly at random and recolor it to a color not used by its neighbors if possible; otherwise allow introducing a new color.\n    return (\"LocalMove\", \"SingleVertexRecolor\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Returns a perturbed copy using conflict-aware recolors, occasional swaps, and color normalization.\n    # Validate and construct a safe starting point if invalid\n    if not isinstance(solution, list) or len(solution) != 9:\n        base = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n        s = base[:]  # valid 4-coloring\n    else:\n        # Coerce to positive ints; fallback to 1 for invalid entries\n        s = [int(g) if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u-1].add(v-1)\n        adj[v-1].add(u-1)\n    # Helper: normalize colors to contiguous 1..K by order of first appearance\n    def normalize_colors(arr):\n        mapping = {}\n        next_c = 1\n        for i in range(len(arr)):\n            c = arr[i]\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            arr[i] = mapping[c]\n        return arr\n    # Compute initial conflicts list\n    def list_conflicts(arr):\n        conf = []\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    conflicts = list_conflicts(s)\n    # Decide perturbation strength adaptively\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    # Helper recolor for a vertex preferring reuse of existing colors\n    def recolor_vertex(i):\n        neighbor_colors = {s[j] for j in adj[i]}\n        maxc = max(s) if s else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            s[i] = random.choice(candidates)\n        else:\n            s[i] = maxc + 1\n    # Apply k_moves edits\n    for _ in range(k_moves):\n        # Choose a target vertex, prioritizing conflicts\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.7:\n            recolor_vertex(v)\n        elif r < 0.9:\n            # Swap colors with another vertex to escape local minima\n            u = random.randrange(n)\n            if u != v:\n                s[u], s[v] = s[v], s[u]\n        else:\n            # Merge attempt: try to set v to a lower color if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        # Refresh conflicts after the move\n        conflicts = list_conflicts(s)\n    # Final normalization to reduce symmetry and keep objective stable\n    s = normalize_colors(s)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] of length 9, positive group IDs. Index i corresponds to vertex i+1. Colors must be normalized to contiguous labels 1..K in order of first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1_000_000.0\n    # Count conflicts\n    s = solution\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    # Conflicts dominate objective via large penalty\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Neighborhood descriptor for metaheuristics:\n    #   - Primary: conflict-aware single-vertex recolor using existing feasible colors when available\n    #   - Secondary: occasional whole color-class swap to escape plateaus\n    # The metaheuristic should enumerate candidate colors from neighbor colors + one spare and prefer minimal incremental conflicts.\n    return (\"LocalMove\", \"SingleVertexRecolor+ClassSwap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    # Helpers\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        if not arr:\n            return\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = s[:]\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            # Merge attempt: try to lower color of v if feasible\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_student_groups_standard","Representacion":"List[int] length 9. Index i corresponds to vertex i+1. Positive integers as color IDs, normalized to contiguous 1..K by first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n    # Structural validation\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for g in solution:\n        if not isinstance(g, int) or g <= 0:\n            return 1000000.0\n    s = normalize_labels(solution)\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if s[u-1] == s[v-1]:\n            conflicts += 1\n    groups_used = len(set(s))\n    return float(groups_used + 1000.0 * conflicts)\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns a single neighbour solution (list[int]) produced by conflict-aware recolor\n    # plus occasional color-class swap if no conflicts.\n    # Validate\/coerce input\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    # Embedded graph (1-indexed in data, convert to 0-indexed)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize_labels(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def conflicts_list(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    s = normalize_labels(s)\n    k = max(s) if s else 1\n    confs = conflicts_list(s)\n    t = s[:]\n    if confs:\n        # Focus on a conflicted vertex\n        a, b = random.choice(confs)\n        v = a if random.random() < 0.5 else b\n        neighbor_colors = {t[j] for j in adj[v]}\n        candidates = list(range(1, k + 1))\n        if (k + 1) not in candidates:\n            candidates.append(k + 1)\n        best_c = None\n        best_cnt = 10**9\n        ties = []\n        for c in candidates:\n            cnt = 0\n            for j in adj[v]:\n                if t[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                ties = [c]\n            elif cnt == best_cnt:\n                ties.append(c)\n        if ties:\n            best_c = random.choice(ties)\n        else:\n            best_c = k + 1\n        t[v] = best_c\n    else:\n        # No conflicts: attempt color-class swap or recolor a random vertex to reduce colors\n        if random.random() < 0.4 and len(set(t)) >= 2:\n            colors = list(set(t))\n            c1, c2 = random.sample(colors, 2)\n            for i in range(n):\n                if t[i] == c1:\n                    t[i] = c2\n                elif t[i] == c2:\n                    t[i] = c1\n        else:\n            v = random.randrange(n)\n            neighbor_colors = {t[j] for j in adj[v]}\n            candidates = [c for c in range(1, k + 1) if c not in neighbor_colors]\n            if not candidates:\n                candidates = [t[v]]\n            t[v] = random.choice(candidates)\n    t = normalize_labels(t)\n    return t\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Returns a perturbed, normalized copy using conflict-focused recolors, class swaps, and merge attempts.\n    if not isinstance(solution, list) or len(solution) != 9:\n        s = [1, 2, 3, 1, 3, 3, 4, 4, 2]\n    else:\n        s = [g if isinstance(g, int) and g > 0 else 1 for g in solution]\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].add(v); adj[v].add(u)\n    def normalize(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nxt; nxt += 1\n            out.append(mapping[c])\n        return out\n    def list_conflicts(arr):\n        conf = []\n        for (u, v) in edges:\n            if arr[u-1] == arr[v-1]:\n                conf.append((u-1, v-1))\n        return conf\n    def recolor_vertex(arr, i):\n        neighbor_colors = {arr[j] for j in adj[i]}\n        maxc = max(arr) if arr else 1\n        candidates = [c for c in range(1, maxc + 1) if c not in neighbor_colors]\n        if candidates:\n            arr[i] = random.choice(candidates)\n        else:\n            arr[i] = maxc + 1\n    def swap_classes(arr):\n        colors = list(set(arr))\n        if len(colors) < 2:\n            return\n        c1, c2 = random.sample(colors, 2)\n        for k in range(len(arr)):\n            if arr[k] == c1:\n                arr[k] = c2\n            elif arr[k] == c2:\n                arr[k] = c1\n    # Begin perturbation\n    s = normalize(s)\n    conflicts = list_conflicts(s)\n    k_moves = 3 if len(conflicts) == 0 else min(6, max(3, len(conflicts)))\n    for _ in range(k_moves):\n        if conflicts:\n            a, b = random.choice(conflicts)\n            v = a if random.random() < 0.5 else b\n        else:\n            v = random.randrange(n)\n        r = random.random()\n        if r < 0.6:\n            recolor_vertex(s, v)\n        elif r < 0.85:\n            swap_classes(s)\n        else:\n            target_colors = list(range(1, max(s)))\n            random.shuffle(target_colors)\n            for tc in target_colors:\n                if all(s[nbr] != tc for nbr in adj[v]):\n                    s[v] = tc\n                    break\n        conflicts = list_conflicts(s)\n    s = normalize(s)\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS. Solution is a Python list of 9 positive integers [c1,...,c9], where ci is the color assigned to node i (i in {1..9}). Colors are labels; solutions are normalized to a compact palette 1..k after moves.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != n:\n        length_penalty = 1_000_000.0 + float(abs(len(solution) - n) * 100_000)\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return float('inf')\n                uniq.add(x)\n            obj = float(len(uniq))\n        except Exception:\n            obj = float('inf')\n        return float(obj + length_penalty)\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return float(1_000_000.0 * invalid_vals)\n    # Objective: number of used colors\n    obj = float(len(uniq))\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000.0\n    fitness = obj + conflicts * conflict_penalty_weight\n    return float(fitness)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns (new_solution, NB_Type, Movement_Type)\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def is_valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def conflict_count_at(sol, v, adj):\n        c = sol[v-1]\n        cnt = 0\n        for u in adj[v]:\n            if sol[u-1] == c:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        # Build induced subgraph of colors {a,b} and get the component containing start_v\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        # Swap colors on the component\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not is_valid_list(solution):\n        new_sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(new_sol), \"REINIT\", \"Random\"\n\n    sol = list(solution)\n    adj = build_adj()\n\n    # Determine conflicts per vertex\n    conflicts_per_v = {i: 0 for i in range(1, n+1)}\n    total_conf = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u] += 1\n            conflicts_per_v[v] += 1\n            total_conf += 1\n\n    # Select target vertex: prioritize most conflicted; tie-break by degree\n    if total_conf > 0:\n        max_conf = max(conflicts_per_v.values())\n        candidates = [v for v, c in conflicts_per_v.items() if c == max_conf]\n        candidates.sort(key=lambda v: -len(adj[v]))\n        target = candidates[0]\n    else:\n        # No conflicts: focus on potential color reduction by recoloring a high-degree vertex\n        target = max(range(1, n+1), key=lambda v: len(adj[v]))\n\n    current_color = sol[target-1]\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    # Attempt greedy recolor to existing colors avoiding neighbor colors\n    neighbor_colors = {sol[u-1] for u in adj[target]}\n    candidates = [c for c in palette if c != current_color and c not in neighbor_colors]\n    # Prefer lower colors to encourage palette compaction\n    candidates.sort()\n\n    if candidates:\n        # Choose color minimizing new local conflicts (0 by construction), fallback to lowest\n        chosen = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = chosen\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"RECOLOR\", \"TargetedGreedy\"\n\n    # If recolor failed or identical, try a Kempe chain swap with a different color\n    if len(palette) >= 2:\n        # Pick second color: prefer one causing many neighbor matches\n        color_freq_neighbors = {}\n        for c in palette:\n            if c == current_color:\n                continue\n            color_freq_neighbors[c] = sum(1 for u in adj[target] if sol[u-1] == c)\n        if color_freq_neighbors:\n            other_color = max(color_freq_neighbors.items(), key=lambda kv: kv[1])[0]\n        else:\n            other_color = random.choice([c for c in palette if c != current_color])\n        new_sol = kempe_swap(sol, current_color, other_color, target, adj)\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, \"KEMPE_SWAP\", \"ColorPairComponent\"\n\n    # As a last resort, change to a different existing color (even if it may introduce conflicts)\n    fallback_colors = [c for c in palette if c != current_color]\n    if not fallback_colors:\n        fallback_colors = [max_color + 1]\n    new_color = random.choice(fallback_colors)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    # Guarantee change\n    if new_sol == sol:\n        # Flip a random different vertex's color as well\n        idx = random.randrange(n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = random.choice(alt_colors)\n        new_sol = normalize(new_sol)\n    return new_sol, \"RECOLOR\", \"FallbackDifferent\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def build_adj():\n        adj = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def kempe_swap(sol, a_color, b_color, start_v, adj):\n        target_colors = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target_colors:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target_colors and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n    adj = build_adj()\n    palette = sorted(set(sol))\n\n    # 1) Apply t random Kempe swaps\n    t = 3  # bounded strength\n    for _ in range(t):\n        if len(palette) < 2:\n            break\n        # pick a random vertex and a distinct color present in palette\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        other_choices = [c for c in palette if c != curr]\n        if not other_choices:\n            continue\n        other = random.choice(other_choices)\n        sol = kempe_swap(sol, curr, other, v, adj)\n        palette = sorted(set(sol))\n\n    # 2) Randomly recolor a few vertices to diversify\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n    for _ in range(k):\n        i = random.randrange(n)\n        choices = list(range(1, max_color + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_color + 1]\n        sol[i] = random.choice(choices)\n        palette = sorted(set(sol))\n        max_color = max(palette)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses DSATUR-driven targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol, len(comp)\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 4\n        new_sol = [random.randint(1, base_k) for _ in range(n)]\n        return normalize(new_sol), (\"REINIT\", \"RandomPaletteK4\")\n\n    sol = list(solution)\n\n    # DSATUR-like vertex selection\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n    max_color = max(palette)\n\n    def dsatur_vertex(sol):\n        # Saturation degree: number of distinct neighbor colors among neighbors\n        best_v = 1\n        best_key = (-1, -1)  # larger is better; we will compare tuples (sat, deg)\n        for v in range(1, n+1):\n            nb_cols = {sol[u-1] for u in adj[v]}\n            sat = len(nb_cols)\n            deg = len(adj[v])\n            key = (sat, deg)\n            if key > best_key:\n                best_key = key\n                best_v = v\n        return best_v\n\n    # Strategy: if conflicts exist, pick the most conflicted with DSATUR tiebreak; else try to eliminate highest color\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        if len(cand) > 1:\n            # Choose by saturation degree then degree\n            best = None\n            best_key = (-1, -1)\n            for v in cand:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                sat = len(nb_cols)\n                deg = len(adj[v])\n                key = (sat, deg)\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = cand[0]\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max_color\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        if kmax_vertices:\n            # break ties by DSATUR\n            best = None\n            best_key = (-1, -1)\n            for v in kmax_vertices:\n                nb_cols = {sol[u-1] for u in adj[v]}\n                key = (len(nb_cols), len(adj[v]))\n                if key > best_key:\n                    best_key = key\n                    best = v\n            target = best\n        else:\n            target = dsatur_vertex(sol)\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = normalize(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap with the color that maximizes component size around target\n    if len(palette) >= 2:\n        best_other = None\n        best_size = -1\n        best_swap_sol = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            swp_sol, comp_size = kempe_swap(sol, curr_c, c, target)\n            if comp_size > best_size and swp_sol != sol:\n                best_size = comp_size\n                best_other = c\n                best_swap_sol = swp_sol\n        if best_swap_sol is not None:\n            best_swap_sol = normalize(best_swap_sol)\n            if best_swap_sol != sol:\n                return best_swap_sol, (\"KEMPE_SWAP\", f\"a{curr_c}_b{best_other}_size{best_size}\")\n\n    # 3) Fallback: recolor to another existing color (may create conflicts), prefer lowest different\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max_color + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = normalize(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a second vertex\n        idx = (target % n)\n        alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[idx]]\n        if not alt_colors:\n            alt_colors = [max(new_sol) + 1]\n        new_sol[idx] = alt_colors[0]\n        new_sol = normalize(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compaction.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {\n        1: [2,3,7,8,9],\n        2: [1,3,5,6,7,8],\n        3: [1,2,7,8,9],\n        4: [5,6,7,8,9],\n        5: [2,4],\n        6: [2,4,7,8],\n        7: [1,2,3,4,6,8],\n        8: [1,2,3,4,6,7,9],\n        9: [1,3,4,8]\n    }\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def normalize(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_swap(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    if not valid(solution):\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return normalize(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps\n    t = 3\n    palette = sorted(set(sol))\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        v = random.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = random.choice(others)\n        sol = kempe_swap(sol, curr, other, v)\n\n    # 2) Random recolors\n    k = max(3, n \/\/ 3)\n    palette = sorted(set(sol))\n    for _ in range(k):\n        i = random.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = random.choice(choices)\n\n    # 3) Normalize palette\n    sol = normalize(sol)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    # Basic structure checks\n    if not isinstance(solution, list):\n        return int(10**12)\n    if len(solution) != n:\n        length_penalty = 1_000_000 + abs(len(solution) - n) * 100_000\n        try:\n            uniq = set()\n            for x in solution:\n                if not isinstance(x, int) or x < 1:\n                    return int(10**12)\n                uniq.add(x)\n            obj = len(uniq)\n        except Exception:\n            obj = 10**9\n        return int(obj + length_penalty)\n\n    invalid_vals = 0\n    uniq = set()\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            invalid_vals += 1\n        else:\n            uniq.add(x)\n    if invalid_vals > 0:\n        return int(1_000_000 * invalid_vals)\n\n    # Objective: number of used colors\n    obj = len(uniq)\n    # Constraints: count edge conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Strongly prioritize feasibility\n    conflict_penalty_weight = 1_000_000\n    fitness = obj + conflicts * conflict_penalty_weight\n    return int(fitness)\n","Vecindad":"import random\nfrom collections import defaultdict, deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution, move_id) where move_id is a 2-tuple (NB_Type, Movement_Type).\n    Ensures a non-null move. Uses targeted recolor and Kempe-chain swap.\n    \"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid_list(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def count_conflicts(sol):\n        conflicts = 0\n        per_v = defaultdict(int)\n        for u, v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n                per_v[u] += 1\n                per_v[v] += 1\n        return conflicts, per_v\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Initialize\/repair if invalid\n    if not valid_list(solution):\n        base_k = 5\n        new_sol = [rng.randint(1, base_k) for _ in range(n)]\n        return compress_palette(new_sol), (\"REINIT\", \"RandomPaletteK5\")\n\n    sol = list(solution)\n\n    # Analyze current state\n    conflicts, per_v = count_conflicts(sol)\n    palette = sorted(set(sol))\n\n    # Select target vertex\n    if conflicts > 0:\n        max_conf = max(per_v.values()) if per_v else 0\n        cand = [v for v in range(1, n+1) if per_v[v] == max_conf]\n        # Tie-break by saturation degree then degree\n        best = None\n        best_key = (-1, -1)\n        for v in cand:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n    else:\n        # Choose a vertex colored with the highest color to encourage palette compaction\n        kmax = max(palette)\n        kmax_vertices = [v for v in range(1, n+1) if sol[v-1] == kmax]\n        # break ties by saturation then degree\n        best = None\n        best_key = (-1, -1)\n        for v in kmax_vertices:\n            nb_cols = {sol[u-1] for u in adj[v]}\n            key = (len(nb_cols), len(adj[v]))\n            if key > best_key:\n                best_key = key\n                best = v\n        target = best\n\n    curr_c = sol[target-1]\n    nb_colors = {sol[u-1] for u in adj[target]}\n\n    # 1) Greedy recolor into existing palette avoiding neighbor colors; prefer lower colors\n    candidates = [c for c in palette if c != curr_c and c not in nb_colors]\n    candidates.sort()\n    if candidates:\n        new_color = candidates[0]\n        new_sol = list(sol)\n        new_sol[target-1] = new_color\n        new_sol = compress_palette(new_sol)\n        if new_sol != sol:\n            return new_sol, (\"RECOLOR\", \"TargetedGreedy\")\n\n    # 2) Kempe swap: choose color that most reduces conflicts (evaluated locally by full check, small n)\n    if len(palette) >= 2:\n        best_swap = None\n        best_score = None\n        for c in palette:\n            if c == curr_c:\n                continue\n            comp = kempe_component(sol, curr_c, c, target)\n            if not comp:\n                continue\n            swp_sol = apply_kempe(sol, comp, curr_c, c)\n            # Evaluate conflict count only (faster than full evaluate)\n            conf_after, _ = count_conflicts(swp_sol)\n            if best_score is None or conf_after < best_score:\n                best_score = conf_after\n                best_swap = swp_sol\n        if best_swap is not None and best_swap != sol:\n            best_swap = compress_palette(best_swap)\n            if best_swap != sol:\n                return best_swap, (\"KEMPE_SWAP\", \"BestConflictDelta\")\n\n    # 3) Fallback: recolor to another color (may create conflicts), prefer lowest different; ensure non-null move\n    fallback = [c for c in palette if c != curr_c]\n    if not fallback:\n        fallback = [max(palette) + 1]\n    new_color = min(fallback)\n    new_sol = list(sol)\n    new_sol[target-1] = new_color\n    new_sol = compress_palette(new_sol)\n    if new_sol == sol:\n        # Ensure non-null by toggling a different vertex safely\n        indices = [i for i in range(n) if (i+1) != target]\n        if not indices:\n            # Should not happen for n>=2, but guard anyway\n            new_sol[target-1] = max(new_sol) + 1\n        else:\n            i = rng.choice(indices)\n            alt_colors = [c for c in sorted(set(new_sol)) if c != new_sol[i]]\n            if not alt_colors:\n                alt_colors = [max(new_sol) + 1]\n            new_sol[i] = alt_colors[0]\n            new_sol = compress_palette(new_sol)\n    return new_sol, (\"RECOLOR\", \"FallbackDifferent\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    \"\"\"Strong but bounded perturbation using multiple Kempe swaps and random recolors, then palette compression.\"\"\"\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    rng = random.Random()\n\n    def valid(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        return all(isinstance(x, int) and x >= 1 for x in sol)\n\n    def compress_palette(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_component(sol, a_color, b_color, start_v):\n        target = {a_color, b_color}\n        visited = set()\n        stack = [start_v]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if sol[v-1] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for u in adj[v]:\n                if sol[u-1] in target and u not in visited:\n                    stack.append(u)\n        return comp\n\n    def apply_kempe(sol, comp, a_color, b_color):\n        new_sol = list(sol)\n        for v in comp:\n            new_sol[v-1] = a_color if sol[v-1] == b_color else b_color\n        return new_sol\n\n    # Repair if invalid\n    if not valid(solution):\n        sol = [rng.randint(1, 5) for _ in range(n)]\n        return compress_palette(sol)\n\n    sol = list(solution)\n\n    # 1) Apply t random Kempe swaps biased by high colors\n    t = 3\n    for _ in range(t):\n        palette = sorted(set(sol))\n        if len(palette) < 2:\n            break\n        # pick a start vertex among those with max color with 50% prob\n        if rng.random() < 0.5:\n            kmax = max(palette)\n            cand = [v for v in range(1, n+1) if sol[v-1] == kmax]\n            v = rng.choice(cand) if cand else rng.randrange(1, n+1)\n        else:\n            v = rng.randrange(1, n+1)\n        curr = sol[v-1]\n        others = [c for c in palette if c != curr]\n        if not others:\n            continue\n        other = rng.choice(others)\n        comp = kempe_component(sol, curr, other, v)\n        if comp:\n            sol = apply_kempe(sol, comp, curr, other)\n\n    # 2) Random recolors of k vertices\n    k = 4\n    for _ in range(k):\n        i = rng.randrange(n)\n        palette = sorted(set(sol))\n        max_c = max(palette)\n        choices = list(range(1, max_c + 1))\n        if sol[i] in choices:\n            choices.remove(sol[i])\n        if not choices:\n            choices = [max_c + 1]\n        sol[i] = rng.choice(choices)\n\n    # 3) Compress palette\n    sol = compress_palette(sol)\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9. Index i corresponds to vertex i+1 (vertices 1..9). Each entry is a positive integer color label starting at 1. Example: [c1,c2,...,c9].","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        return float(conflicts * 10**6 + invalid * 10**3 + max_color if max_color > 0 else conflicts * 10**6 + invalid * 10**3 + 10**2)\n    return float(max_color)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        sat_deg = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            # pick vertex with max saturation, break ties by degree\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        conflicted = set()\n        for (u,v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                conflicted.add(u-1)\n                conflicted.add(v-1)\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor a conflicted vertex to the smallest feasible color (<= max_color+1)\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        used = neighbor_colors_of(idx, cur, adj)\n        # Try colors 1..max_color first, then allow max_color+1 if needed\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflict\"\n        # Fallback (should not happen): random color\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = random.choice(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, try relocating a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        # choose least used feasible to balance classes\n        feasible.sort(key=lambda c: color_usage.get(c, 0))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification (keeps feasibility)\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) within palette 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = list(range(n)) if len(indices) < 2 else indices\n        t = random.randint(2, min(4, len(pool))) if pool else random.randint(2, 4)\n        chosen = random.sample(pool if pool else list(range(n)), t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx]}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        # Large integer penalties to dominate objective while preserving determinism\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        cur[idx] = random.randint(1, max_color + 1)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            # bias to smallest feasible color to compress palette\n            cur[idx] = min(candidates)\n            return cur, \"NB_Recolor\", \"ReduceMaxColor\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.6:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return cur\n    else:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_0_textbook_standard","Representacion":"List[int] of length 9; index i corresponds to vertex i+1. Each entry is a positive integer color label starting at 1.","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Internal graph data (1-indexed vertices)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n    # Shape checks\n    if not isinstance(solution, list):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n)\n    invalid = 0\n    max_color = 0\n    for c in solution:\n        if not isinstance(c, int) or c <= 0:\n            invalid += 1\n        else:\n            if c > max_color:\n                max_color = c\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u - 1]\n        cv = solution[v - 1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    # Penalize conflicts overwhelmingly, then invalids, then objective (max color)\n    if invalid > 0 or conflicts > 0:\n        penalty = conflicts * (10**6) + invalid * (10**3) + (max_color if max_color > 0 else 10**2)\n        return int(penalty)\n    return int(max_color)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns (new_solution, NB_Type, Movement_Type)\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        # Relabel colors to contiguous 1..k preserving order of first appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def dsatur_init():\n        adj = adj_list(n, edges)\n        colors = [0]*n\n        uncolored = set(range(n))\n        degrees = [len(adj[i]) for i in range(n)]\n        neighbor_colors = [set() for _ in range(n)]\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), degrees[x]))\n            used = neighbor_colors[v]\n            c = 1\n            while c in used:\n                c += 1\n            colors[v] = c\n            uncolored.remove(v)\n            for w in adj[v]:\n                if colors[w] == 0:\n                    neighbor_colors[w].add(c)\n        return colors\n\n    def compute_conflicted(cur):\n        counts = [0]*n\n        for (u, v) in edges:\n            if isinstance(cur[u-1], int) and isinstance(cur[v-1], int) and cur[u-1] == cur[v-1]:\n                counts[u-1] += 1\n                counts[v-1] += 1\n        conflicted = [i for i, c in enumerate(counts) if c > 0]\n        conflicted.sort(key=lambda i: -counts[i])\n        return conflicted\n\n    def neighbor_colors_of(idx, cur, adj):\n        return {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n\n    def kempe_chain_swap(cur, a, b, start_idx, adj):\n        # BFS on subgraph induced by colors a and b, swap colors on the connected component containing start_idx\n        target = {a, b}\n        if cur[start_idx] not in target:\n            return None\n        visited = set()\n        stack = [start_idx]\n        comp = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            if cur[v] not in target:\n                continue\n            visited.add(v)\n            comp.append(v)\n            for w in adj[v]:\n                if cur[w] in target and w not in visited:\n                    stack.append(w)\n        if not comp:\n            return None\n        new_cur = cur[:]\n        for v in comp:\n            new_cur[v] = a if cur[v] == b else b\n        return new_cur\n\n    # Validate input, or initialize\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        new_sol = dsatur_init()\n        new_sol = normalize_palette(new_sol)\n        return new_sol, \"NB_Init\", \"DSATUR\"\n\n    cur = list(solution)\n    adj = adj_list(n, edges)\n    cur = normalize_palette(cur)\n    conflicted = compute_conflicted(cur)\n    max_color = max(cur) if cur else 1\n\n    # If conflicts exist: recolor most conflicted vertex to smallest feasible color\n    if conflicted:\n        idx = conflicted[0]\n        used = neighbor_colors_of(idx, cur, adj)\n        for c in range(1, max_color + 2):\n            if c not in used:\n                cur[idx] = c\n                cur = normalize_palette(cur)\n                return cur, \"NB_Recolor\", \"ResolveConflictGreedy\"\n        # Fallback random recolor\n        cur[idx] = random.randint(1, max_color + 1)\n        cur = normalize_palette(cur)\n        return cur, \"NB_Recolor\", \"ResolveConflictFallback\"\n\n    # No conflicts: try to reduce palette by recoloring a max-color vertex to a lower feasible color\n    max_nodes = [i for i, c in enumerate(cur) if c == max_color]\n    random.shuffle(max_nodes)\n    for idx in max_nodes:\n        used = neighbor_colors_of(idx, cur, adj)\n        candidates = [c for c in range(1, max_color) if c not in used]\n        if candidates:\n            cur[idx] = min(candidates)\n            cur = normalize_palette(cur)\n            return cur, \"NB_Recolor\", \"ReduceMaxColorGreedy\"\n\n    # Try Kempe-chain between max_color and a lower color\n    if max_color > 1:\n        base = random.choice(max_nodes)\n        for low in random.sample(list(range(1, max_color)), k=min(2, max_color-1)):\n            new_cur = kempe_chain_swap(cur, max_color, low, base, adj)\n            if new_cur is not None and new_cur != cur:\n                new_cur = normalize_palette(new_cur)\n                return new_cur, \"NB_Swap\", \"KempeChain\"\n\n    # If cannot reduce, relocate a random vertex to the least-loaded feasible color among 1..max_color\n    color_usage = {}\n    for c in cur:\n        color_usage[c] = color_usage.get(c, 0) + 1\n    idx = random.randrange(n)\n    used = neighbor_colors_of(idx, cur, adj)\n    feasible = [c for c in range(1, max_color + 1) if c not in used]\n    if feasible:\n        feasible.sort(key=lambda c: (color_usage.get(c, 0), c))\n        cur[idx] = feasible[0]\n        cur = normalize_palette(cur)\n        return cur, \"NB_Reassign\", \"BalanceClasses\"\n\n    # Last resort: introduce a new color for diversification\n    cur[idx] = max_color + 1\n    cur = normalize_palette(cur)\n    return cur, \"NB_Recolor\", \"DiversifyNewColor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger randomization while preserving representation and encouraging palette compression\n    edges = [\n        (1,2),(1,3),(1,7),(1,8),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,7),(3,8),(3,9),\n        (4,5),(4,6),(4,7),(4,8),(4,9),\n        (6,7),(6,8),\n        (8,9)\n    ]\n    n = 9\n\n    def adj_list(n, edges):\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            adj[ui].append(vi)\n            adj[vi].append(ui)\n        return adj\n\n    def normalize_palette(cur):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cur:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def random_valid_shape():\n        return [random.randint(1, 5) for _ in range(n)]\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(c, int) or c <= 0) for c in solution):\n        return random_valid_shape()\n\n    cur = list(solution)\n    cur = normalize_palette(cur)\n    adj = adj_list(n, edges)\n    max_color = max(cur) if cur else 1\n\n    mode = random.random()\n    if mode < 0.5:\n        # Recolor t random vertices (prefer from max color) to feasible colors within 1..max_color+1\n        indices = [i for i, c in enumerate(cur) if c == max_color]\n        pool = indices if len(indices) >= 2 else list(range(n))\n        t = min(len(pool), random.randint(2, 4)) if pool else 2\n        if t == 0:\n            return cur\n        chosen = random.sample(pool, t)\n        for idx in chosen:\n            used = {cur[w] for w in adj[idx] if isinstance(cur[w], int) and cur[w] > 0}\n            candidates = [c for c in range(1, max_color + 2) if c not in used]\n            if candidates:\n                cur[idx] = random.choice(candidates)\n            else:\n                cur[idx] = random.randint(1, max_color + 1)\n        return normalize_palette(cur)\n    elif mode < 0.8:\n        # Palette relabeling: random permutation of used colors\n        used_colors = sorted(set(c for c in cur if isinstance(c, int) and c > 0))\n        if len(used_colors) <= 1:\n            return cur\n        perm = used_colors[:]\n        random.shuffle(perm)\n        mapping = {u: p for (u, p) in zip(used_colors, perm)}\n        return [mapping.get(c, c) for c in cur]\n    else:\n        # Attempt merge: map one color class onto another and repair lightly\n        if max_color <= 1:\n            return cur\n        a, b = random.sample(list(range(1, max_color + 1)), 2)\n        merged = [a if x == b else x for x in cur]\n        # Light repair: for each conflict edge, push one endpoint to a feasible color if possible\n        adj = adj_list(n, edges)\n        for (u, v) in edges:\n            ui, vi = u-1, v-1\n            if merged[ui] == merged[vi]:\n                used_u = {merged[w] for w in adj[ui]}\n                used_v = {merged[w] for w in adj[vi]}\n                # Try to recolor u first then v\n                moved = False\n                for cand in range(1, max_color + 2):\n                    if cand not in used_u:\n                        merged[ui] = cand\n                        moved = True\n                        break\n                if not moved:\n                    for cand in range(1, max_color + 2):\n                        if cand not in used_v:\n                            merged[vi] = cand\n                            break\n        return normalize_palette(merged)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    # Type and range checks\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for u, v in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return colors_used + penalty\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, \"NB_Type\", \"Movement_Type\")\n    # Implements biased single-node recolor and occasional Kempe-chain swap\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving equality\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb), \"Repair\", \"RandomInit\"\n\n    nb = solution[:]\n\n    # With small probability perform a 2-color (Kempe) swap on a connected component\n    if random.random() < 0.2:\n        # pick two distinct colors present\n        present = list(sorted(set(nb)))\n        if len(present) >= 2:\n            c1, c2 = random.sample(present, 2)\n            # pick a start vertex that has color c1 or c2\n            candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n            if candidates:\n                start = random.choice(candidates)\n                # BFS on subgraph induced by colors c1 and c2\n                adj = [[] for _ in range(n)]\n                for (u, v) in edges:\n                    u0, v0 = u-1, v-1\n                    adj[u0].append(v0)\n                    adj[v0].append(u0)\n                queue = [start]\n                visited = set([start])\n                comp = []\n                while queue:\n                    u = queue.pop()\n                    comp.append(u)\n                    for w in adj[u]:\n                        if w not in visited and nb[w] in (c1, c2):\n                            visited.add(w)\n                            queue.append(w)\n                # swap colors c1 <-> c2 in this component\n                for u in comp:\n                    nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n                nb = compress_colors(nb)\n                return nb, \"KempeSwap\", \"TwoColorComponentSwap\"\n\n    # Otherwise single-node recolor biased toward feasibility and color reduction\n    max_color = max(nb)\n\n    # Prefer conflicted vertices; if none, pick a random vertex\n    conflicts = set()\n    edge_list = edges\n    for (u, v) in edge_list:\n        if nb[u-1] == nb[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    if conflicts:\n        idx = random.choice(list(conflicts))\n        move_tag = \"ConflictDirected\"\n    else:\n        idx = random.randrange(n)\n        move_tag = \"RandomPick\"\n\n    # Determine forbidden colors from neighbors\n    neighbor_indices = [v-1 for (u, v) in edges if u-1 == idx] + [u-1 for (u, v) in edges if v-1 == idx]\n    forbidden = set()\n    for j in neighbor_indices:\n        forbidden.add(nb[j])\n\n    # Candidate colors within current palette\n    candidates = [c for c in range(1, max_color + 1) if c != nb[idx] and c not in forbidden]\n    if candidates:\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_FeasibleMinColor\"\n    else:\n        # Allow introducing a new color only if necessary\n        nb[idx] = max_color + 1\n        nb = compress_colors(nb)\n        return nb, \"SingleNodeRecolor\", move_tag+\"_ExpandPalette\"\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    # Multi-node adaptive perturbation: random recolors and a possible Kempe cascade\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by random initialization\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        nb = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(nb)\n\n    nb = solution[:]\n\n    # Step 1: random recolor k vertices with colors sampled from existing palette plus one extra\n    k = random.randint(2, 4)\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n    indices = random.sample(range(n), k)\n    for idx in indices:\n        nb[idx] = int(random.choice(pool))\n\n    # Step 2: perform 1-2 Kempe component swaps to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        adj = [[] for _ in range(n)]\n        for (u, v) in edges:\n            u0, v0 = u-1, v-1\n            adj[u0].append(v0)\n            adj[v0].append(u0)\n        queue = [start]\n        visited = set([start])\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    nb = compress_colors(nb)\n    return nb\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9 \/\/ encoding: list of 9 positive integers [c1..c9], colors start at 1; graph nodes are 1..9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Minimize number of colors with heavy penalties for conflicts\/invalid structure\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            penalty += 10000.0\n\n    # Objective value = number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport copy\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a neighbor solution (list of 9 ints >=1).\n    Metadata (\"NB_Type\",\"Movement_Type\") omitted to satisfy 2-ary unpackers.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    # Repair invalid input by a simple greedy initialization\n    def greedy_init():\n        adj = [[] for _ in range(n)]\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n        sol = [0]*n\n        order = sorted(range(n), key=lambda i: -len(adj[i]))\n        for i in order:\n            forbidden = {sol[j] for j in adj[i] if sol[j] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            sol[i] = c\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return greedy_init()\n\n    nb = solution[:]\n\n    # Precompute adjacency lists\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u,v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Pick vertex: prefer conflicted with higher degree, else random\n    if conflicted:\n        idx = max(conflicted, key=lambda i: (len(adj[i]), random.random()))\n    else:\n        idx = random.randrange(n)\n\n    # Determine forbidden colors from neighbors\n    forbidden = {nb[j] for j in adj[idx]}\n\n    # Consider feasible colors within current palette\n    max_color = max(nb) if nb else 1\n    candidates = [c for c in range(1, max_color+1) if c != nb[idx] and c not in forbidden]\n\n    if candidates:\n        # Least-conflicting tie-broken randomly\n        random.shuffle(candidates)\n        new_color = min(candidates)\n        nb[idx] = int(new_color)\n        return compress_colors(nb)\n\n    # Try a localized two-color Kempe swap to create feasibility without increasing palette\n    present = list(sorted(set(nb)))\n    if len(present) >= 2:\n        c1 = nb[idx]\n        others = [c for c in present if c != c1]\n        if others:\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n            # After swap, retry assigning a feasible existing color to idx\n            forbidden = {nb[j] for j in adj[idx]}\n            candidates = [c for c in range(1, max(nb)+1) if c != nb[idx] and c not in forbidden]\n            if candidates:\n                nb[idx] = int(min(candidates))\n                return compress_colors(nb)\n\n    # As last resort, temporarily expand palette by one color\n    nb[idx] = max_color + 1\n    return compress_colors(nb)\n","Perturbacion":"import random\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Multi-node recolor + optional Kempe cascades.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    def fallback_init():\n        sol = [random.randint(1, 4) for _ in range(n)]\n        return compress_colors(sol)\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return fallback_init()\n\n    nb = solution[:]\n\n    # Build adjacency and conflict set\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: random recolor k nodes (biased to conflicted if any)\n    k = random.randint(2, 4)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) < k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]  # allow one extra color occasionally\n\n    for idx in indices:\n        # choose a color avoiding immediate neighbor clashes if possible\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas:\n            nb[idx] = int(random.choice(feas))\n        else:\n            nb[idx] = int(random.choice(pool))\n\n    # Step 2: 1-2 Kempe swaps from random seeds to diversify\n    for _ in range(random.randint(1, 2)):\n        present = list(sorted(set(nb)))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        # pick a start vertex that has color c1 or c2\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        # BFS on subgraph induced by colors c1 and c2\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            nb[u] = c1 if nb[u] == c2 else (c2 if nb[u] == c1 else nb[u])\n\n    return compress_colors(nb)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_parties_with_exes_standard","Representacion":"INT_LIST_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Returns a scalar fitness (lower is better): number of colors used + conflict penalties.\n    Expects solution: list of 9 positive ints (colors start at 1).\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return 1e9\n    if len(solution) != n:\n        return 1e9 + 1e6 + 1e5 * abs(len(solution) - n)\n\n    penalty = 0.0\n\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            penalty += 1e6\n\n    # Conflict penalties (scaled to dominate color count but not overflow)\n    conflict_penalty = 1000.0\n    conflicts = 0\n    for (u, v) in edges:\n        cu = solution[u-1]\n        cv = solution[v-1]\n        if isinstance(cu, int) and isinstance(cv, int) and cu == cv:\n            conflicts += 1\n    penalty += conflict_penalty * conflicts\n\n    # Objective: number of colors used\n    colors_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if colors_used <= 0:\n        colors_used = 1e6\n\n    return float(colors_used + penalty)\n","Vecindad":"import random\nimport math\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (neighbor_solution, movement_type_str)\n    - Keeps color labels stable; does NOT compress\/relabel the palette.\n    - Repairs invalid inputs via DSATUR initialization.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            # select uncolored vertex with highest saturation; break ties on degree\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    # Validate input\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return (dsatur_init(), \"RepairInit\")\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicts_nodes = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicts_nodes.add(u-1); conflicts_nodes.add(v-1)\n\n    # Helper: min-conflicts recolor within existing palette if possible\n    def min_conflicts_recolor(idx):\n        cur = nb[idx]\n        palette = sorted(set(nb))\n        best_c = None\n        best_cnt = math.inf\n        for c in palette:\n            if c == cur:\n                continue\n            cnt = 0\n            for j in adj[idx]:\n                if nb[j] == c:\n                    cnt += 1\n            if cnt < best_cnt:\n                best_cnt = cnt\n                best_c = c\n        if best_c is not None and best_cnt < sum(1 for j in adj[idx] if nb[j]==cur):\n            nb[idx] = best_c\n            return True\n        return False\n\n    # Try to fix conflicts first\n    if conflicts_nodes:\n        # pick most conflicted with degree tiebreak\n        def conflict_count(i):\n            c = nb[i]\n            return sum(1 for j in adj[i] if nb[j]==c)\n        idx = max(conflicts_nodes, key=lambda i: (conflict_count(i), len(adj[i]), random.random()))\n        # try feasible recolor that avoids immediate neighbor clashes\n        forbidden = {nb[j] for j in adj[idx]}\n        palette = sorted(set(nb))\n        feas = [c for c in palette if c != nb[idx] and c not in forbidden]\n        if feas:\n            nb[idx] = min(feas)\n            return (nb, \"SingleVertexRecolor\")\n        # else use min-conflicts among palette\n        if min_conflicts_recolor(idx):\n            return (nb, \"MinConflictsRecolor\")\n        # Kempe swap between current color and a random other color\n        present = sorted(set(nb))\n        if len(present) >= 2:\n            c1 = nb[idx]\n            others = [c for c in present if c != c1]\n            c2 = random.choice(others)\n            # BFS on subgraph induced by colors c1 and c2 starting at idx\n            queue = [idx]\n            visited = {idx}\n            comp = []\n            while queue:\n                u = queue.pop()\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and nb[w] in (c1, c2):\n                        visited.add(w)\n                        queue.append(w)\n            for u in comp:\n                if nb[u] == c1:\n                    nb[u] = c2\n                elif nb[u] == c2:\n                    nb[u] = c1\n            return (nb, \"KempeSwap\")\n        # As last resort, introduce a new color to break deadlock\n        nb[idx] = max(nb) + 1\n        return (nb, \"PaletteExpand\")\n\n    # No conflicts: try to reduce number of colors by merging a sparse color class\n    palette = sorted(set(nb))\n    if len(palette) > 1:\n        # pick smallest class size color to eliminate\n        counts = {c: sum(1 for x in nb if x==c) for c in palette}\n        target = min(palette, key=lambda c: (counts[c], c))\n        # attempt to recolor its vertices into other colors greedily\n        verts = [i for i, x in enumerate(nb) if x == target]\n        success = True\n        for i in verts:\n            forbidden = {nb[j] for j in adj[i]}\n            feas = [c for c in palette if c != target and c not in forbidden]\n            if feas:\n                nb[i] = min(feas)\n            else:\n                success = False\n                break\n        if success:\n            return (nb, \"ClassMergeGreedy\")\n        # fallback: swap two color classes to shake\n        if len(palette) >= 2:\n            c1, c2 = random.sample(palette, 2)\n            for i in range(n):\n                if nb[i] == c1:\n                    nb[i] = c2\n                elif nb[i] == c2:\n                    nb[i] = c1\n            return (nb, \"ClassSwap\")\n\n    # Default small diversification: recolor a random vertex to a random feasible color (or same)\n    idx = random.randrange(n)\n    forbidden = {nb[j] for j in adj[idx]}\n    feas = [c for c in palette if c not in forbidden]\n    if feas:\n        nb[idx] = random.choice(feas)\n        return (nb, \"RandomFeasibleRecolor\")\n    return (nb, \"NoOp\")\n","Perturbacion":"import random\nimport math\nimport copy\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed solution (list of 9 ints >=1). Keeps labels stable; repairs invalid input.\n    \"\"\"\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n\n    def dsatur_init():\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        for (u,v) in edges:\n            u-=1; v-=1\n            adj[u].append(v); adj[v].append(u)\n            deg[u]+=1; deg[v]+=1\n        colors = [0]*n\n        sat = [0]*n\n        neighbor_colors = [set() for _ in range(n)]\n        for _ in range(n):\n            candidates = [i for i in range(n) if colors[i]==0]\n            i = max(candidates, key=lambda x: (sat[x], deg[x]))\n            forb = neighbor_colors[i]\n            c = 1\n            while c in forb:\n                c += 1\n            colors[i] = c\n            for j in adj[i]:\n                if colors[j]==0:\n                    neighbor_colors[j].add(c)\n                    sat[j] = len(neighbor_colors[j])\n        return colors\n\n    if (not isinstance(solution, list)) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return dsatur_init()\n\n    nb = solution[:]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        u0, v0 = u-1, v-1\n        adj[u0].append(v0)\n        adj[v0].append(u0)\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in edges:\n        if nb[u-1] == nb[v-1]:\n            conflicted.add(u-1); conflicted.add(v-1)\n\n    # Step 1: recolor k nodes (biased to conflicted if any)\n    k = random.randint(3, 5)\n    indices_space = list(conflicted) if conflicted else list(range(n))\n    if len(indices_space) <= k:\n        indices = indices_space\n    else:\n        indices = random.sample(indices_space, k)\n\n    palette = sorted(set(nb))\n    max_c = max(palette)\n    pool = palette + [max_c + 1]\n\n    for idx in indices:\n        forbidden = {nb[j] for j in adj[idx]}\n        feas = [c for c in palette if c not in forbidden]\n        if feas and random.random() < 0.85:\n            nb[idx] = random.choice(feas)\n        else:\n            nb[idx] = random.choice(pool)\n\n    # Step 2: 1-2 Kempe swaps for diversification\n    iters = random.randint(1, 2)\n    for _ in range(iters):\n        present = sorted(set(nb))\n        if len(present) < 2:\n            break\n        c1, c2 = random.sample(present, 2)\n        candidates = [i for i, c in enumerate(nb) if c in (c1, c2)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        queue = [start]\n        visited = {start}\n        comp = []\n        while queue:\n            u = queue.pop()\n            comp.append(u)\n            for w in adj[u]:\n                if w not in visited and nb[w] in (c1, c2):\n                    visited.add(w)\n                    queue.append(w)\n        for u in comp:\n            if nb[u] == c1:\n                nb[u] = c2\n            elif nb[u] == c2:\n                nb[u] = c1\n\n    return nb\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (5,9-1), (7,9-1), (8,9-1) # duplicates guarded below; harmless\n    ]\n    # Deduplicate edges and ensure 0-based correctness\n    E = []\n    seen = set()\n    for u,v in edges:\n        if u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) not in seen and 0 <= a < 9 and 0 <= b < 9:\n            seen.add((a,b))\n            E.append((a,b))\n\n    LARGE = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    # Type check\n    if not isinstance(solution, list):\n        return HUGE\n\n    n = 9\n    fitness = 0.0\n\n    # Length penalty\n    if len(solution) != n:\n        fitness += LARGE * float(abs(len(solution) - n) + 1)\n\n    # Entry validity and objective computation\n    max_color = 0\n    invalid_entries = 0\n    for v in solution[:n]:\n        if isinstance(v, int) and v >= 1:\n            if v > max_color:\n                max_color = v\n        else:\n            invalid_entries += 1\n\n    # Conflict count (only if length sufficient)\n    conflicts = 0\n    if len(solution) == n:\n        for u, v in E:\n            try:\n                su = solution[u]\n                sv = solution[v]\n                if isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1:\n                    if su == sv:\n                        conflicts += 1\n                else:\n                    conflicts += 1\n            except Exception:\n                conflicts += 1\n\n    # Objective: number of groups used\n    obj = float(max_color) if max_color > 0 else LARGE\n\n    # Aggregate fitness (lower is better)\n    fitness += obj\n    fitness += 1000.0 * float(conflicts)\n    fitness += 1000.0 * float(invalid_entries)\n\n    return float(fitness)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator with palette compression, best-improvement recolor, and Kempe-chain flips\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Normalize solution to INDEX_LIST of length 9 with ints >=1\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    # Graph data (0-based)\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7), (4,5)  # duplicates safe\n    ]\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def count_conflicts(arr):\n        c = 0\n        for u in range(n):\n            cu = arr[u]\n            for v in adj[u]:\n                if v > u and cu == arr[v]:\n                    c += 1\n        return c\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, max_color):\n        # Try colors 1..max_color, choose one minimizing conflicts; allow staying same if best\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        # Current conflicts at idx\n        base = vertex_conflicts(idx, arr)\n        for c in range(1, max_color+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        # Build component in subgraph induced by colors a and b, then swap colors\n        if a == b:\n            return None\n        if arr[start_idx] not in (a, b):\n            return None\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        new_arr = arr[:]\n        for u in comp:\n            new_arr[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return new_arr\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        # Resolve conflicts: pick a conflicted vertex and try best recolor; else Kempe; else expand palette\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None:\n            new_s = cand\n        else:\n            # Try a Kempe flip between current color and a random other color\n            current = new_s[idx]\n            other = random.randint(1, max_color)\n            if other == current:\n                other = (other % max_color) + 1 if max_color > 1 else current\n            kc = kempe_chain_flip(idx, current, other, new_s)\n            if kc is not None and count_conflicts(kc) <= count_conflicts(new_s):\n                new_s = kc\n            else:\n                # Last resort: expand palette for this vertex\n                new_s[idx] = max_color + 1\n    else:\n        # No conflicts: attempt palette compression on max color class\n        max_color = max(new_s)\n        max_vertices = [i for i,c in enumerate(new_s) if c == max_color]\n        if max_vertices:\n            idx = random.choice(max_vertices)\n            # Try recolor to any color < max that is feasible\n            feas = []\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            for c in range(1, max_color):\n                if c not in neighbor_colors:\n                    feas.append(c)\n            if feas:\n                new_s[idx] = min(feas)\n            else:\n                # Try Kempe chain with a lower color to make space\n                if max_color > 1:\n                    target = random.randint(1, max_color-1)\n                    kc = kempe_chain_flip(idx, max_color, target, new_s)\n                    if kc is not None:\n                        # Accept if max color reduces or stays same without introducing conflicts\n                        if max(kc) < max_color or count_conflicts(kc) <= count_conflicts(new_s):\n                            new_s = kc\n                # If still no change, small shake: recolor a random vertex to a random existing color\n                if new_s[idx] == s[idx]:\n                    j = random.randrange(n)\n                    new_s[j] = random.randint(1, max_color)\n\n    # Return as required by local solvers: (solution, 'INDEX_LIST')\n    return new_s, \"INDEX_LIST\"\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Structured perturbation: remap colors, then reassign a subset of max-color vertices with min-conflicts,\n# followed by 1-2 random Kempe-chain flips to escape deep local minima.\n\ndef perturb_solution(solution):\n    n = 9\n    s = list(solution) if isinstance(solution, list) else [1]*n\n    if len(s) != n:\n        s = (s + [1]*n)[:n]\n    for i in range(n):\n        if not (isinstance(s[i], int) and s[i] >= 1):\n            s[i] = 1\n\n    edges = [\n        (0,1),(0,2),(0,3),(0,7),(0,8),\n        (1,2),(1,3),(1,4),(1,5),(1,6),(1,7),\n        (2,3),(2,4),(2,5),(2,6),(2,8),\n        (3,6),\n        (4,5),(4,6),(4,7),(4,8),\n        (6,7),(6,8),\n        (7,8),\n        (2,8), (2,7)\n    ]\n    adj = [[] for _ in range(n)]\n    seen = set()\n    for u,v in edges:\n        if not (0 <= u < n and 0 <= v < n) or u==v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        if (a,b) in seen:\n            continue\n        seen.add((a,b))\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def kempe_chain_flip(start_idx, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[start_idx] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [start_idx]\n        comp = []\n        visited[start_idx] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    # Color remapping (palette permutation)\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    mapping = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        new_s[i] = mapping.get(new_s[i], new_s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(new_s)\n    max_class = [i for i,c in enumerate(new_s) if c == max_color]\n    if max_class:\n        k = max(2, len(max_class) \/\/ 2)\n        random.shuffle(max_class)\n        for idx in max_class[:k]:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            choices = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if choices:\n                new_s[idx] = random.choice(choices)\n            else:\n                # pick color minimizing conflicts\n                best_c = 1\n                best_hits = math.inf\n                for c in range(1, max_color):\n                    hits = 0\n                    for v in adj[idx]:\n                        if new_s[v] == c:\n                            hits += 1\n                    if hits < best_hits:\n                        best_hits = hits\n                        best_c = c\n                new_s[idx] = best_c\n\n    # 1-2 random Kempe-chain flips to diversify\n    for _ in range(random.randint(1,2)):\n        a = random.randint(1, max(new_s))\n        b = random.randint(1, max(new_s))\n        if a == b:\n            b = (b % max(new_s)) + 1 if max(new_s) > 1 else b\n        seed = random.randrange(n)\n        new_s = kempe_chain_flip(seed, a, b, new_s)\n\n    return new_s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Build canonical 0-based edge set from PROBLEM_DEF once per call (self-contained)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n\n    INF = 1_000_000.0\n    HUGE = 1_000_000_000.0\n\n    def parse_to_index_list(x):\n        # Accept str\/list\/tuple; coerce to list[int] length n; ints must be >=1\n        if isinstance(x, str):\n            # split by comma or whitespace\n            if \",\" in x:\n                parts = [p.strip() for p in x.replace(\"[\",\" \").replace(\"]\",\" \").split(\",\")]\n            else:\n                parts = x.strip().replace(\"[\",\" \").replace(\"]\",\" \").split()\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        # Normalize length strictly\n        if len(vals) != n:\n            return None\n        # Validate entries (>=1), coerce by taking max(1, val)\n        out = []\n        for v in vals:\n            out.append(int(v) if isinstance(v, int) else 1)\n        return out\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return HUGE\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in E:\n        su = s[u]\n        sv = s[v]\n        if not (isinstance(su, int) and isinstance(sv, int) and su >= 1 and sv >= 1):\n            conflicts += 1\n        elif su == sv:\n            conflicts += 1\n\n    max_color = max(s) if all(isinstance(v, int) for v in s) else n\n\n    # Lexicographic objective: minimize conflicts first, then max_color\n    score = conflicts * INF + float(max_color)\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\n# Neighbour generator: conflict-directed recolor, Kempe-chain flips, and palette compression\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Graph data\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1]*n\n\n    def vertex_conflicts(idx, arr):\n        c = 0\n        col = arr[idx]\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def total_conflicts(arr):\n        c = 0\n        for (u,v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr, palette_max):\n        current = arr[idx]\n        best_col = current\n        best_delta = math.inf\n        for c in range(1, palette_max+1):\n            if c == current:\n                delta = 0\n            else:\n                delta = 0\n                for v in adj[idx]:\n                    if arr[v] == current:\n                        delta -= 1\n                    if arr[v] == c:\n                        delta += 1\n            if delta < best_delta or (delta == best_delta and c < best_col):\n                best_delta = delta\n                best_col = c\n        if best_col != current:\n            arr2 = arr[:]\n            arr2[idx] = best_col\n            return arr2\n        return None\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        n_local = len(arr)\n        in_colors = (a, b)\n        if arr[seed] not in in_colors:\n            return None\n        visited = [False]*n_local\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in in_colors:\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    new_s = s[:]\n    max_color = max(new_s)\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    if conflicted:\n        idx = random.choice(conflicted)\n        cand = best_recolor(idx, new_s, max_color)\n        if cand is not None and total_conflicts(cand) <= total_conflicts(new_s):\n            new_s = cand\n        else:\n            # Try a few Kempe flips; pick the best non-worsening\n            best = new_s\n            best_conf = total_conflicts(new_s)\n            tried = set()\n            for _ in range(4):\n                a = new_s[idx]\n                b = random.randint(1, max_color)\n                if b == a:\n                    b = (b % max_color) + 1 if max_color > 1 else b\n                key = (a,b)\n                if key in tried:\n                    continue\n                tried.add(key)\n                kc = kempe_chain_flip(idx, a, b, new_s)\n                if kc is not None:\n                    c = total_conflicts(kc)\n                    if c < best_conf or (c == best_conf and max(kc) < max(best)):\n                        best = kc\n                        best_conf = c\n            if best is new_s:\n                # As a last resort, expand palette for this vertex\n                new_s[idx] = max_color + 1\n            else:\n                new_s = best\n    else:\n        # Palette compression: try to recolor vertices in the max color class to lower feasible colors\n        max_color = max(new_s)\n        candidates = [i for i,c in enumerate(new_s) if c == max_color]\n        random.shuffle(candidates)\n        changed = False\n        for idx in candidates:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, max_color) if c not in neighbor_colors]\n            if feasible:\n                new_s[idx] = min(feasible)\n                changed = True\n                break\n        if not changed and max_color > 1:\n            # Try Kempe flip between max_color and a lower color\n            idx = random.choice(candidates) if candidates else random.randrange(n)\n            target = random.randint(1, max_color - 1)\n            kc = kempe_chain_flip(idx, max_color, target, new_s)\n            if kc is not None:\n                # accept if does not increase palette size and non-worsens conflicts\n                if max(kc) <= max_color and total_conflicts(kc) <= total_conflicts(new_s):\n                    new_s = kc\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n# Perturbation: palette shuffle, partial reassignment of max-color class, and random Kempe flips\n\ndef perturb_solution(solution):\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n    seen = set()\n    E = []\n    for (u1,v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a,b = (u0,v0) if u0 < v0 else (v0,u0)\n        if (a,b) not in seen:\n            seen.add((a,b))\n            E.append((a,b))\n    adj = [[] for _ in range(n)]\n    for (u,v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse_to_list(x):\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == \"\":\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1]*n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1]*n\n        else:\n            return [1]*n\n        if len(vals) != n:\n            return [1]*n\n        for i in range(n):\n            if not (isinstance(vals[i], int) and vals[i] >= 1):\n                vals[i] = 1\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a,b):\n            return arr[:]\n        visited = [False]*n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a,b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    max_color = max(s)\n\n    # Palette permutation to change basin\n    palette = list(range(1, max_color+1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color+1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign a subset of vertices from the max color using min-conflict heuristic\n    max_color = max(s)\n    max_class = [i for i,c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = 1 + max(1, len(max_class)\/\/2)\n    for idx in max_class[:k]:\n        # Try any color in 1..max_color-1 with minimal neighbor hits\n        best_c = 1 if max_color > 1 else 1\n        best_hits = math.inf\n        for c in range(1, max(2, max_color)):\n            if c == max_color:\n                continue\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c\n\n    # 1-2 random Kempe flips between random color pairs\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Problem data (internal to function per constraints)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    # Strict parser: accept list\/tuple of length n or comma\/space separated string of n integers >=1\n    def parse_to_index_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    v = int(p)\n                except Exception:\n                    return None\n                vals.append(v)\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    iv = int(v)\n                except Exception:\n                    return None\n                vals.append(iv)\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    s = parse_to_index_list(solution)\n    if s is None:\n        return float(10**9)\n\n    # Build edge list 0-based (deduplicate defensively)\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n        if s[u] == s[v]:\n            conflicts += 1\n\n    max_color = max(s) if s else 0\n\n    # Lexicographic scalarization: weight larger than max possible max_color\n    # |E| <= 24 here, but use a conservative K\n    K = 1000\n    score = conflicts * K + max_color\n    return float(score)\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return None\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return None\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return None\n        else:\n            return None\n        if len(vals) != n:\n            return None\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return None\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(arr):\n        c = 0\n        for (u, v) in E:\n            if arr[u] == arr[v]:\n                c += 1\n        return c\n\n    def score_tuple(arr):\n        return (total_conflicts(arr), max(arr) if arr else 0)\n\n    def better(a, b):\n        return a[0] < b[0] or (a[0] == b[0] and a[1] < b[1])\n\n    def vertex_conflicts(idx, arr):\n        col = arr[idx]\n        c = 0\n        for v in adj[idx]:\n            if arr[v] == col:\n                c += 1\n        return c\n\n    def best_recolor(idx, arr):\n        palette_max = max(arr)\n        cur = arr[idx]\n        best = None\n        best_sc = None\n        for c in range(1, palette_max + 1):\n            if c == cur:\n                continue\n            cand = arr[:]\n            cand[idx] = c\n            sc = score_tuple(cand)\n            if best is None or better(sc, best_sc) or (sc == best_sc and c < (best[idx] if best is not None else c)):\n                best = cand\n                best_sc = sc\n        return best, best_sc\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return None\n        if arr[seed] not in (a, b):\n            return None\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n    if s is None:\n        s = [1] * n\n\n    cur_sc = score_tuple(s)\n    new_s = s[:]\n\n    conflicted = [i for i in range(n) if vertex_conflicts(i, new_s) > 0]\n\n    moved = False\n    if conflicted:\n        # Target a random conflicted vertex, try best recolor then Kempe improvements\n        idx = random.choice(conflicted)\n        cand, cand_sc = best_recolor(idx, new_s)\n        if cand is not None and (better(cand_sc, cur_sc) or cand_sc == cur_sc):\n            new_s = cand\n            cur_sc = cand_sc\n            moved = True\n        else:\n            # Try Kempe flips with all b in palette\n            a = new_s[idx]\n            palette_max = max(new_s)\n            best = None\n            best_sc = None\n            for b_col in range(1, palette_max + 1):\n                if b_col == a:\n                    continue\n                kc = kempe_chain_flip(idx, a, b_col, new_s)\n                if kc is None:\n                    continue\n                sc = score_tuple(kc)\n                if best is None or better(sc, best_sc):\n                    best = kc\n                    best_sc = sc\n            if best is not None and (better(best_sc, cur_sc) or best_sc == cur_sc):\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n    if not moved:\n        # Compression: try to lower max color class\n        palette_max = max(new_s)\n        targets = [i for i, c in enumerate(new_s) if c == palette_max]\n        random.shuffle(targets)\n        for idx in targets:\n            neighbor_colors = set(new_s[v] for v in adj[idx])\n            feasible = [c for c in range(1, palette_max) if c not in neighbor_colors]\n            for c in feasible:\n                cand = new_s[:]\n                cand[idx] = c\n                sc = score_tuple(cand)\n                if better(sc, cur_sc) or sc == cur_sc:\n                    new_s = cand\n                    cur_sc = sc\n                    moved = True\n                    break\n            if moved:\n                break\n        if not moved and palette_max > 1 and targets:\n            # Kempe swap between max color and lower colors, pick best non-worsening\n            best = None\n            best_sc = None\n            for idx in targets:\n                for c in range(1, palette_max):\n                    kc = kempe_chain_flip(idx, palette_max, c, new_s)\n                    if kc is None:\n                        continue\n                    sc = score_tuple(kc)\n                    if (best is None or better(sc, best_sc)) and (better(sc, cur_sc) or sc == cur_sc):\n                        best = kc\n                        best_sc = sc\n            if best is not None:\n                new_s = best\n                cur_sc = best_sc\n                moved = True\n\n    return (to_str(new_s), \"INDEX_LIST\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Problem data internal\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    n = 9\n\n    def parse_to_list(x):\n        vals = None\n        if isinstance(x, str):\n            parts = [p.strip() for p in (x.split(',') if ',' in x else x.strip().split())]\n            vals = []\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    vals.append(int(p))\n                except Exception:\n                    return [1] * n\n        elif isinstance(x, (list, tuple)):\n            vals = []\n            for v in x:\n                if isinstance(v, bool):\n                    return [1] * n\n                try:\n                    vals.append(int(v))\n                except Exception:\n                    return [1] * n\n        else:\n            return [1] * n\n        if len(vals) != n:\n            return [1] * n\n        if any((not isinstance(v, int)) or v < 1 for v in vals):\n            return [1] * n\n        return vals\n\n    def to_str(arr):\n        return \",\".join(str(int(v)) for v in arr)\n\n    # Build adjacency\n    seen = set()\n    E = []\n    for (u1, v1) in edges_1_based:\n        u0 = u1 - 1\n        v0 = v1 - 1\n        if not (0 <= u0 < n and 0 <= v0 < n) or u0 == v0:\n            continue\n        a, b = (u0, v0) if u0 < v0 else (v0, u0)\n        if (a, b) not in seen:\n            seen.add((a, b))\n            E.append((a, b))\n    adj = [[] for _ in range(n)]\n    for (u, v) in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def kempe_chain_flip(seed, a, b, arr):\n        if a == b:\n            return arr[:]\n        if arr[seed] not in (a, b):\n            return arr[:]\n        visited = [False] * n\n        stack = [seed]\n        visited[seed] = True\n        comp = []\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not visited[v] and arr[v] in (a, b):\n                    visited[v] = True\n                    stack.append(v)\n        out = arr[:]\n        for u in comp:\n            out[u] = a if arr[u] == b else (b if arr[u] == a else arr[u])\n        return out\n\n    s = parse_to_list(solution)\n\n    # Palette shuffle to escape basin\n    max_color = max(s)\n    palette = list(range(1, max_color + 1))\n    random.shuffle(palette)\n    remap = {c: palette[i] for i, c in enumerate(range(1, max_color + 1))}\n    for i in range(n):\n        s[i] = remap.get(s[i], s[i])\n\n    # Reassign half of vertices from current max color to least-conflicting lower colors\n    max_color = max(s)\n    max_class = [i for i, c in enumerate(s) if c == max_color]\n    random.shuffle(max_class)\n    k = max(1, len(max_class) \/\/ 2)\n    for idx in max_class[:k]:\n        best_c = 1\n        best_hits = math.inf\n        for c in range(1, max_color):\n            hits = 0\n            for v in adj[idx]:\n                if s[v] == c:\n                    hits += 1\n            if hits < best_hits:\n                best_hits = hits\n                best_c = c\n        s[idx] = best_c if max_color > 1 else s[idx]\n\n    # Apply 1-2 random Kempe flips\n    flips = random.randint(1, 2)\n    for _ in range(flips):\n        a = random.randint(1, max(s))\n        b = random.randint(1, max(s))\n        if a == b:\n            b = (b % max(s)) + 1 if max(s) > 1 else b\n        seed = random.randrange(n)\n        s = kempe_chain_flip(seed, a, b, s)\n\n    return to_str(s)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9. Each solution is a list of 9 positive integers [r1,r2,...,r9], where ri is the room (color) assigned to node i (1-based nodes). Valid domains: ri >= 1. Objective: minimize max(ri) subject to r_u != r_v for all edges.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded constraints graph (1-based to 0-based inline conversion)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    n = 9\n    if len(solution) != n:\n        return 10**9\n    # Validate domain and track max room\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic fitness: first minimize conflicts, then number of rooms\n    return conflicts * 1000 + max_room\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution, movement_type)\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute current conflicts per node and total\n    conflicts_per_node = [0]*n\n    total_conflicts = 0\n    for u, v in edges:\n        if solution[u] == solution[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n    max_room_current = max(solution)\n    # Select a node (bias to higher conflict; +1 smoothing)\n    weights = [c + 1 for c in conflicts_per_node]\n    total_w = sum(weights)\n    r = random.uniform(0.0, float(total_w))\n    acc = 0.0\n    chosen = 0\n    for i, w in enumerate(weights):\n        acc += w\n        if r <= acc:\n            chosen = i\n            break\n    # Candidate colors: existing colors; optionally try removing highest color\n    used_colors = sorted(set(solution))\n    candidate_colors = list(used_colors)\n    # Do not introduce a new color unless we still have conflicts\n    if total_conflicts > 0:\n        candidate_colors.append(max_room_current + 1)\n    # Evaluate objective delta for recoloring chosen node\n    def objective(sol):\n        # Inline evaluation to avoid external dependency\n        max_room = 0\n        conflicts = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 1000 + max_room\n    base_obj = objective(solution)\n    best_color = solution[chosen]\n    best_obj = base_obj\n    # Prefer smaller colors on ties to encourage palette compression\n    for c in candidate_colors:\n        if c == solution[chosen]:\n            continue\n        trial = solution.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n    if best_color == solution[chosen]:\n        # If no improvement, random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"random_recolor\"\n    else:\n        move_type = \"greedy_recolor\"\n    new_solution = solution.copy()\n    new_solution[chosen] = best_color\n    # Canonicalize colors to 1..k by first occurrence to reduce symmetry\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    new_solution = [remap[v] for v in new_solution]\n    return (new_solution, move_type)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Kempe-chain style color swap between two colors; fallback to multi-node random reassignment\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    new_solution = solution.copy()\n    colors = sorted(set(new_solution))\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_solution) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False]*n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_solution[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_solution[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_solution[u] == c1:\n                    new_solution[u] = c2\n                elif new_solution[u] == c2:\n                    new_solution[u] = c1\n            # Canonicalize colors to 1..k by first occurrence\n            remap = {}\n            next_c = 1\n            for v in new_solution:\n                if v not in remap:\n                    remap[v] = next_c\n                    next_c += 1\n            return [remap[v] for v in new_solution]\n    # Fallback: reassign a small block of nodes\n    k = random.randint(2, 4)\n    used = set(new_solution)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_solution[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_solution[i] = maxc\n            used.add(maxc)\n    # Canonicalize\n    remap = {}\n    next_c = 1\n    for v in new_solution:\n        if v not in remap:\n            remap[v] = next_c\n            next_c += 1\n    return [remap[v] for v in new_solution]\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: A solution is a Python list of 9 positive ints [r1,...,r9], ri>=1, representing colors assigned to nodes 1..9.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    # Scale = |E|+1 = 24+1 = 25 ensures strict lexicographic order\n    return conflicts * 25 + max_room\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Helper: objective consistent with evaluate_solution\n    def objective(sol):\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * 25 + max_room\n\n    cur = solution\n    base_obj = objective(cur)\n\n    # Compute conflicts per node and total conflicts\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Node selection: choose among max-conflict nodes; tie-break at random\n    max_c = max(conflicts_per_node) if conflicts_per_node else 0\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    chosen = random.choice(candidates) if candidates else random.randrange(n)\n\n    new_sol = cur.copy()\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: prefer existing colors; introduce new color only when conflicts remain and with small probability\n    candidate_colors = list(used_colors)\n    if total_conflicts > 0 and random.random() < 0.15:\n        candidate_colors.append(max_color + 1)\n\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        trial = new_sol.copy()\n        trial[chosen] = c\n        obj = objective(trial)\n        if obj < best_obj or (obj == best_obj and c < best_color):\n            best_obj = obj\n            best_color = c\n\n    if best_color == new_sol[chosen]:\n        # No improvement found: random recolor among candidate colors\n        best_color = random.choice(candidate_colors)\n        move_type = \"recolor_random\"\n\n    new_sol[chosen] = best_color\n\n    # Optional palette compression if conflict-free: try to reduce max color by recoloring a node using highest color\n    if max_c == 0:\n        max_color_now = max(new_sol)\n        if max_color_now > 1:\n            nodes_max = [i for i, c in enumerate(new_sol) if c == max_color_now]\n            if nodes_max:\n                i = random.choice(nodes_max)\n                best_c = new_sol[i]\n                best_o = objective(new_sol)\n                # Try lower colors only\n                for c in range(1, max_color_now):\n                    t = new_sol.copy()\n                    t[i] = c\n                    o = objective(t)\n                    if o < best_o or (o == best_o and c < best_c):\n                        best_o = o\n                        best_c = c\n                if best_c != new_sol[i]:\n                    new_sol[i] = best_c\n                    move_type = \"palette_compress\"\n\n    return (new_sol, move_type)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol):\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution.copy()\n    colors = sorted(set(new_sol))\n\n    # Try Kempe-chain swap between two colors\n    if len(colors) >= 2:\n        c1, c2 = random.sample(colors, 2)\n        nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n        if nodes_c12:\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            # Swap colors on the component\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            return canonicalize(new_sol)\n\n    # Fallback: shuffle a few nodes among existing colors or introduce one new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used)\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.85 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n\n    return canonicalize(new_sol)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_taekwondo_tournament_standard","Representacion":"INT_LIST_LEN_9: list of 9 positive integers [r1,...,r9], ri>=1, representing colors\/rooms for nodes 1..9.","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Embedded graph edges (1-based listed, converted to 0-based)\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    n = 9\n    scale = len(edges) + 1  # ensures lexicographic order: conflicts prioritized over palette size\n\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9\n    # Domain check and max color\n    max_room = 0\n    for v in solution:\n        if not isinstance(v, int) or v < 1:\n            return 10**9\n        if v > max_room:\n            max_room = v\n    # Conflict count\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    # Lexicographic objective: prioritize conflicts, then palette size\n    return conflicts * scale + max_room\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robustness checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_input_noop\")\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n    scale = len(edges) + 1\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def obj(sol: List[int]) -> int:\n        # Fast objective consistent with evaluate_solution\n        max_room = 0\n        for val in sol:\n            if val > max_room:\n                max_room = val\n        conflicts = 0\n        for (u, v) in edges:\n            if sol[u] == sol[v]:\n                conflicts += 1\n        return conflicts * scale + max_room\n\n    cur = solution\n    base_obj = obj(cur)\n\n    # Conflicts per node and total\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for (u, v) in edges:\n        if cur[u] == cur[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n\n    used_colors = sorted(set(cur))\n    max_color = max(used_colors)\n\n    # Helper: saturation degree\n    def sat_deg(i: int) -> int:\n        return len(set(cur[j] for j in adj[i]))\n\n    # Conflict-free state: only attempt safe palette compression (non-worsening guard)\n    if total_conflicts == 0:\n        maxc = max(cur)\n        nodes_max = [i for i, c in enumerate(cur) if c == maxc]\n        if not nodes_max or maxc == 1:\n            return (cur[:], \"noop_conflict_free\")\n        i = random.choice(nodes_max)\n        best_c = cur[i]\n        best_o = base_obj\n        for c in range(1, maxc):\n            ok = True\n            for nb in adj[i]:\n                if cur[nb] == c:\n                    ok = False\n                    break\n            if not ok:\n                continue\n            cand = cur[:]\n            cand[i] = c\n            o = obj(cand)\n            if o < best_o or (o == best_o and c < best_c):\n                best_o = o\n                best_c = c\n        if best_c != cur[i]:\n            new_sol = cur[:]\n            new_sol[i] = best_c\n            return (new_sol, \"palette_compress\")\n        else:\n            return (cur[:], \"noop_conflict_free\")\n\n    # Choose a node: max conflicts, then higher saturation, then higher degree\n    max_c = max(conflicts_per_node)\n    candidates = [i for i, c in enumerate(conflicts_per_node) if c == max_c]\n    candidates.sort(key=lambda i: (sat_deg(i), len(adj[i])), reverse=True)\n    chosen = candidates[0]\n\n    new_sol = cur[:]\n    move_type = \"recolor_greedy\"\n\n    # Candidate colors: existing colors\n    candidate_colors = list(used_colors)\n\n    # Try recolor chosen to minimize objective; prefer conflict reduction\n    best_color = new_sol[chosen]\n    best_obj = base_obj\n    improved = False\n    for c in candidate_colors:\n        if c == new_sol[chosen]:\n            continue\n        conflict_here = any(cur[nb] == c for nb in adj[chosen])\n        trial = new_sol[:]\n        trial[chosen] = c\n        o = obj(trial)\n        if o < best_obj or (o == best_obj and not conflict_here):\n            best_obj = o\n            best_color = c\n            improved = True\n    if best_color != new_sol[chosen]:\n        new_sol[chosen] = best_color\n        move_type = \"recolor_greedy\"\n        return (new_sol, move_type)\n\n    # Kempe-chain swap attempt between chosen color and one of neighbor colors\n    neighbor_colors = list(set(cur[j] for j in adj[chosen]))\n    random.shuffle(neighbor_colors)\n    for c2 in neighbor_colors:\n        c1 = cur[chosen]\n        # Build Kempe component in colors {c1,c2}\n        stack = [chosen]\n        visited = [False]*n\n        comp = []\n        while stack:\n            u = stack.pop()\n            if visited[u]:\n                continue\n            visited[u] = True\n            if cur[u] in (c1, c2):\n                comp.append(u)\n                for v in adj[u]:\n                    if not visited[v] and cur[v] in (c1, c2):\n                        stack.append(v)\n        trial = cur[:]\n        for u in comp:\n            trial[u] = c2 if cur[u] == c1 else c1\n        o = obj(trial)\n        if o < base_obj:\n            return (trial, \"kempe_swap\")\n\n    # Pair-swap colors on an offending edge\n    offending_edges = [(u, v) for (u, v) in edges if cur[u] == cur[v]]\n    if offending_edges:\n        u, v = random.choice(offending_edges)\n        trial = cur[:]\n        trial[u], trial[v] = trial[v], trial[u]\n        o = obj(trial)\n        if o <= base_obj:\n            return (trial, \"pair_swap_nonworsening\")\n\n    # As last resort, allow introducing a new color only if no non-worsening found\n    new_color = max_color + 1\n    trial = cur[:]\n    trial[chosen] = new_color\n    o = obj(trial)\n    if o < base_obj:\n        return (trial, \"introduce_color\")\n\n    # Fallback: random recolor among existing colors (non-improving plateau move)\n    rc = random.choice(candidate_colors) if candidate_colors else new_color\n    trial = cur[:]\n    trial[chosen] = rc\n    return (trial, \"recolor_random_plateau\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Robustness\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n\n    n = 9\n    edges_1_based = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),(8,9)\n    ]\n    edges = [(u-1, v-1) for (u, v) in edges_1_based]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonicalize(sol: List[int]) -> List[int]:\n        remap = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in remap:\n                remap[v] = next_c\n                next_c += 1\n            out.append(remap[v])\n        return out\n\n    new_sol = solution[:]\n\n    # Primary: multiple Kempe-chain shakes\n    colors = list(sorted(set(new_sol)))\n    if len(colors) >= 2:\n        shakes = random.randint(2, 4)\n        for _ in range(shakes):\n            if len(colors) < 2:\n                break\n            c1, c2 = random.sample(colors, 2)\n            nodes_c12 = [i for i, c in enumerate(new_sol) if c in (c1, c2)]\n            if not nodes_c12:\n                continue\n            visited = [False] * n\n            seed = random.choice(nodes_c12)\n            stack = [seed]\n            comp = []\n            while stack:\n                u = stack.pop()\n                if visited[u]:\n                    continue\n                visited[u] = True\n                if new_sol[u] in (c1, c2):\n                    comp.append(u)\n                    for v in adj[u]:\n                        if not visited[v] and new_sol[v] in (c1, c2):\n                            stack.append(v)\n            for u in comp:\n                if new_sol[u] == c1:\n                    new_sol[u] = c2\n                elif new_sol[u] == c2:\n                    new_sol[u] = c1\n            colors = list(sorted(set(new_sol)))\n        return canonicalize(new_sol)\n\n    # Fallback: random recolor of a small subset with possible introduction of a new color\n    k = random.randint(2, 4)\n    used = set(new_sol)\n    maxc = max(used) if used else 1\n    for _ in range(k):\n        i = random.randrange(n)\n        if random.random() < 0.8 and used:\n            new_sol[i] = random.choice(list(used))\n        else:\n            maxc += 1\n            new_sol[i] = maxc\n            used.add(maxc)\n    return canonicalize(new_sol)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9; solution encodes colors [x1..x9] with xi>=1. Example: '1 2 3 1 2 3 1 2 3'","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef _parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution) -> float:\n    # Robust parser to accept the defined string representation or a list\/tuple\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 1e9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 1e9\n    # Edge set (1-based indices)\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    # Count conflicts and compute k\n    k = 0\n    conflicts = 0\n    for c in sol:\n        if c > k:\n            k = c\n    if k <= 0:\n        return 1e9\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then k\n    return float(conflicts * 1000 + k)\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef _nb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return ([1,2,3,1,2,3,1,2,3], \"NodeRecolor\", \"MinConflictsBounded\")\n    # Problem data\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    n = 9\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    # Vertex choice: prefer conflicting; else pick a vertex with highest current color to encourage compaction\n    if conflicting:\n        i = random.choice(conflicting)\n    else:\n        maxc = max(sol)\n        idxs = [idx+1 for idx, c in enumerate(sol) if c == maxc]\n        i = random.choice(idxs)\n    # Candidate colors: 1..k (bounded palette, do not introduce new colors here)\n    candidates = list(range(1, k+1))\n    # Global color usage for tiebreaking\n    usage = {}\n    for c in sol:\n        usage[c] = usage.get(c, 0) + 1\n    # Evaluate conflict count for assigning color c to vertex i\n    best_conf = None\n    best_colors = []\n    for c in candidates:\n        conf = 0\n        for v in adj[i]:\n            if c == sol[v-1]:\n                conf += 1\n        if best_conf is None or conf < best_conf:\n            best_conf = conf\n            best_colors = [c]\n        elif conf == best_conf:\n            best_colors.append(c)\n    # Tiebreak: prefer least used color to aid balancing\/compaction\n    if not best_colors:\n        new_color = sol[i-1]\n    else:\n        best_colors.sort(key=lambda c: (usage.get(c, 0), c))\n        new_color = best_colors[0]\n    new_sol = sol[:]\n    new_sol[i-1] = int(new_color)\n    return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n","Perturbacion":"import random\nfrom collections import deque\nfrom typing import List, Tuple, Union\n\ndef _pb_parse_solution_to_list(sol: Union[str, List[int], Tuple[int,...]]) -> List[int]:\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random chain; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present (invalid but robust), randomly recolor a few vertices to color 2\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        # BFS on subgraph induced by colors {a, b}\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        # Swap colors a<->b on this component\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n        colors = sorted(set(sol))\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return float(conflicts * 25 + k)\n\n# Target Simulated Annealing heuristic signature\n# SA tries to minimize the evaluate_solution value (smaller is better)\n# It accepts a callable generate_neighbour and evaluate_solution\n# Note: perturbation can be injected externally by caller between temperature schedules if desired\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Parse\/normalize current solution\n    cur = _parse_solution_to_list(currentSolution)\n    if len(cur) != 9:\n        cur = [i % 3 + 1 for i in range(9)]\n    if best is None:\n        best = cur[:]\n        best_score = evaluate_solution(best)\n    cur_score = evaluate_solution(cur)\n    if best_score is None or cur_score < best_score:\n        best = cur[:]\n        best_score = cur_score\n    # SA loop\n    T = float(max(temp, 1e-6))\n    minT = float(max(minTemp, 1e-6))\n    alpha = float(min(max(cooling_factor, 0.80), 0.9999))\n    rng = random.random\n    while T > minT:\n        # Generate neighbour\n        nb, _, _ = generate_neighbour(cur)\n        nb_score = evaluate_solution(nb)\n        delta = nb_score - cur_score\n        if delta <= 0:\n            cur, cur_score = nb, nb_score\n        else:\n            if rng() < math.exp(-delta \/ max(T, 1e-12)):\n                cur, cur_score = nb, nb_score\n        if cur_score < best_score:\n            best = cur[:]\n            best_score = cur_score\n        T *= alpha\n    return {\n        \"current\": cur,\n        \"currentScore\": cur_score,\n        \"best\": best,\n        \"bestScore\": best_score\n    }\n","Vecindad":"import random\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    k = max(max(sol), 1)\n    # Identify conflicting vertices\n    conflicting = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conflicting.append(i)\n                break\n    new_sol = sol[:]\n    if conflicting:\n        # Min-conflicts recolor on a random conflicting vertex using palette 1..k\n        i = random.choice(conflicting)\n        candidates = list(range(1, k+1))\n        best_conf = None\n        best_colors = []\n        for c in candidates:\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        # Prefer smallest color to promote compaction\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n    else:\n        # No conflicts: attempt k-reduction by trying to recolor one highest-color vertex into [1..k-1] feasibly\n        maxc = max(new_sol)\n        idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n        i = random.choice(idxs)\n        feasible = []\n        for c in range(1, max(1, maxc)):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            # If we eliminated max color from all vertices, compact palette by remapping maxc -> smallest missing\n            if maxc not in new_sol:\n                # Palette compaction: map colors to 1..max\n                mapping = {}\n                nextc = 1\n                for c in sorted(set(new_sol)):\n                    mapping[c] = nextc\n                    nextc += 1\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n        else:\n            # As a diversification when k-reduction fails, perform a small color-class swap on a random color pair\n            colors = sorted(set(new_sol))\n            if len(colors) >= 2:\n                a, b = random.sample(colors, 2)\n                for idx, c in enumerate(new_sol):\n                    if c == a:\n                        new_sol[idx] = b\n                    elif c == b:\n                        new_sol[idx] = a\n                return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n            else:\n                # Fallback: random recolor one vertex\n                i = random.randint(1, n)\n                new_sol[i-1] = 1\n                return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef perturb_solution(solution):\n    # Kempe-chain based perturbation: pick random color pair and swap along a random connected component; repeat 1..3 times\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # If only one color present, recolor a few vertices to color 2 to enable movement\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    repeats = random.randint(1, 3)\n    for _ in range(repeats):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        start_vertices = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        visited = set()\n        comp = []\n        dq = deque([start])\n        while dq:\n            u = dq.popleft()\n            if u in visited:\n                continue\n            if sol[u-1] not in (a, b):\n                continue\n            visited.add(u)\n            comp.append(u)\n            for v in adj[u]:\n                if v not in visited and sol[v-1] in (a, b):\n                    dq.append(v)\n        for u in comp:\n            if sol[u-1] == a:\n                sol[u-1] = b\n            elif sol[u-1] == b:\n                sol[u-1] = a\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_1_textbook_standard","Representacion":"SPACE_SEPARATED_INT_LIST_LEN9","Evaluacion":"import math\nimport random\n\ndef _parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        lst = list(sol)\n    elif isinstance(sol, str):\n        parts = sol.replace(',', ' ').split()\n        try:\n            lst = list(map(int, parts))\n        except Exception:\n            return []\n    else:\n        return []\n    return lst\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return 10**9\n    for c in sol:\n        if not isinstance(c, int) or c <= 0:\n            return 10**9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol)\n    # Lexicographic objective: minimize conflicts first, then k\n    # |E| = 24, so weight = 25 ensures conflicts dominate any change in k\n    return int(conflicts * 25 + k)\n","Vecindad":"import random\nfrom collections import deque\n\ndef _nb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _graph_def():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _conflicting_vertices(sol, adj):\n    n = len(sol)\n    conf = []\n    for i in range(1, n+1):\n        ci = sol[i-1]\n        for v in adj[i]:\n            if ci == sol[v-1]:\n                conf.append(i)\n                break\n    return conf\n\ndef _kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, NB_Type, Movement_Type)\n    sol = _nb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        sol = [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _graph_def()\n    new_sol = sol[:]\n    k = max(max(sol), 1)\n\n    # 1) If conflicts exist: min-conflicts recolor on a random conflicting vertex\n    conflicting = _conflicting_vertices(sol, adj)\n    if conflicting:\n        i = random.choice(conflicting)\n        # Occasionally try a Kempe swap between two best colors to escape plateaus\n        if random.random() < 0.25:\n            palette = sorted(set(sol))\n            if len(palette) >= 2:\n                a, b = random.sample(palette, 2)\n                # choose a starting vertex among {a,b} near i if possible\n                start = i if sol[i-1] in (a, b) else i\n                comp = _kempe_component(sol, adj, start, a, b)\n                if comp:\n                    for u in comp:\n                        new_sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n                    return (new_sol, \"KempeSwap\", \"KempeComponentSwap\")\n        # Min-conflicts recolor\n        best_conf = None\n        best_colors = []\n        for c in range(1, k+1):\n            conf = 0\n            for v in adj[i]:\n                if c == sol[v-1]:\n                    conf += 1\n            if best_conf is None or conf < best_conf:\n                best_conf = conf\n                best_colors = [c]\n            elif conf == best_conf:\n                best_colors.append(c)\n        new_color = min(best_colors) if best_colors else sol[i-1]\n        new_sol[i-1] = int(new_color)\n        return (new_sol, \"NodeRecolor\", \"MinConflictsBounded\")\n\n    # 2) No conflicts: attempt k-reduction by recoloring one max-color vertex to [1..k-1]\n    maxc = max(new_sol)\n    idxs = [idx+1 for idx, c in enumerate(new_sol) if c == maxc]\n    random.shuffle(idxs)\n    for i in idxs:\n        feasible = []\n        for c in range(1, maxc):\n            ok = True\n            for v in adj[i]:\n                if c == new_sol[v-1]:\n                    ok = False\n                    break\n            if ok:\n                feasible.append(c)\n        if feasible:\n            new_sol[i-1] = min(feasible)\n            if maxc not in new_sol:\n                # Compact palette only when maxc eliminated\n                mapping = {}\n                for rank, c in enumerate(sorted(set(new_sol)), start=1):\n                    mapping[c] = rank\n                new_sol = [mapping[c] for c in new_sol]\n            return (new_sol, \"NodeRecolor\", \"KReductionAttempt\")\n\n    # 3) Diversification: color-class swap to reshuffle structure\n    colors = sorted(set(new_sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for idx, c in enumerate(new_sol):\n            if c == a:\n                new_sol[idx] = b\n            elif c == b:\n                new_sol[idx] = a\n        return (new_sol, \"ColorClassSwap\", \"SwapTwoColors\")\n\n    # 4) Fallback\n    i = random.randint(1, n)\n    new_sol[i-1] = 1\n    return (new_sol, \"NodeRecolor\", \"Fallback\")\n","Perturbacion":"import random\nfrom collections import deque\n\ndef _pb_parse_solution_to_list(sol):\n    if isinstance(sol, (list, tuple)):\n        return list(sol)\n    if isinstance(sol, str):\n        try:\n            return list(map(int, sol.replace(',', ' ').split()))\n        except Exception:\n            return []\n    return []\n\ndef _pb_graph():\n    n = 9\n    edges = [\n        (1,2),(1,3),(1,4),(1,8),(1,9),\n        (2,3),(2,4),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,6),(3,7),(3,9),\n        (4,7),\n        (5,6),(5,7),(5,8),(5,9),\n        (7,8),(7,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    return n, edges, adj\n\ndef _pb_kempe_component(sol, adj, start, a, b):\n    dq = deque([start])\n    comp = set()\n    seen = set()\n    while dq:\n        u = dq.popleft()\n        if u in seen:\n            continue\n        if sol[u-1] not in (a, b):\n            continue\n        seen.add(u)\n        comp.add(u)\n        for v in adj[u]:\n            if v not in seen and sol[v-1] in (a, b):\n                dq.append(v)\n    return comp\n\ndef perturb_solution(solution):\n    # Kempe-chain based multi-swap plus random recolor shake\n    sol = _pb_parse_solution_to_list(solution)\n    if len(sol) != 9:\n        return [1,2,3,1,2,3,1,2,3]\n    n, edges, adj = _pb_graph()\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        # seed a second color\n        idxs = random.sample(range(n), k=min(3, n))\n        for idx in idxs:\n            sol[idx] = 2\n        return sol\n    reps = random.randint(2, 4)\n    for _ in range(reps):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a, b = random.sample(colors, 2)\n        candidates = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        comp = _pb_kempe_component(sol, adj, start, a, b)\n        if comp:\n            for u in comp:\n                sol[u-1] = b if sol[u-1] == a else (a if sol[u-1] == b else sol[u-1])\n    # Additional shake: recolor a small random subset to random existing colors\n    m = max(1, n \/\/ 5)\n    idxs = random.sample(range(n), k=m)\n    palette = sorted(set(sol))\n    for idx in idxs:\n        sol[idx] = random.choice(palette)\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations\n    base = max(solution)\n    # Penalty scaled to dominate base objective but not overflow\n    penalty = 100 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive validation and repair to a trivial feasible domain element\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1]*9, \"Recolor\")\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Build adjacency list 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflicting vertices set\n    conflicts = []\n    for u, neighs in enumerate(adj):\n        cu = sol[u]\n        for v in neighs:\n            if v > u and sol[v] == cu:\n                conflicts.append(u)\n                conflicts.append(v)\n    if conflicts:\n        idx = random.choice(conflicts)\n    else:\n        idx = random.randrange(n)\n    current_color = sol[idx]\n    max_color = max(sol)\n    # Candidate colors: prefer within 1..max_color; allow +1 with small diversification probability\n    p_div = 0.1\n    candidates = list(range(1, max_color + 1))\n    if random.random() < p_div:\n        candidates.append(max_color + 1)\n    # Remove current color if present\n    candidates = [c for c in candidates if c != current_color]\n    if not candidates:\n        candidates = [current_color if current_color >= 1 else 1]\n    # Score colors by induced conflicts at idx\n    def local_conflicts(color):\n        cnt = 0\n        for v in adj[idx]:\n            if sol[v] == color:\n                cnt += 1\n        return cnt\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        if best_score is None or sc < best_score:\n            best_score = sc\n            best_colors = [c]\n        elif sc == best_score:\n            best_colors.append(c)\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\ndef perturb_solution(solution):\n    # Defensive validation\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1]*9\n    sol = solution[:]\n    n = 9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Adjacency 0-indexed\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n    # Select k vertices to recolor\n    k_low, k_high = 2, 4\n    k = random.randint(k_low, k_high)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) < k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n    # Recolor chosen vertices with diversification\n    for idx in picks:\n        max_color = max(sol)\n        candidates = list(range(1, max_color + 1))\n        # higher diversification than neighbour move\n        if random.random() < 0.2:\n            candidates.append(max_color + 1)\n        # Exclude current color\n        candidates = [c for c in candidates if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts\n        best_score = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            if best_score is None or sc < best_score:\n                best_score = sc\n                best_colors = [c]\n            elif sc == best_score:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count constraint violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: minimize number of colors (max color index), penalize violations heavily\n    base = max(solution)\n    penalty = 1000 * violations\n    return base + penalty\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Internal helpers and data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            # DSATUR: pick vertex with max saturation, break ties by degree\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    def compress_colors(sol):\n        # Relabel colors to 1..k preserving order of appearance\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive validation and repair using DSATUR\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts and violations count\n    conflict_vertices = set()\n    violations = 0\n    for u in range(n):\n        cu = sol[u]\n        for v in adj[u]:\n            if v > u and sol[v] == cu:\n                violations += 1\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Selection strategy\n    if conflict_vertices:\n        # focus on most conflicting vertex (break ties by degree)\n        def conflict_count(u):\n            cu = sol[u]\n            return sum(1 for v in adj[u] if sol[v] == cu)\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        # try to reduce max color usage\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color = max(sol)\n\n    # Candidate colors: avoid increasing palette if no violations\n    allow_new_color = violations > 0 and random.random() < 0.1\n    candidates = list(range(1, max_color + (1 if allow_new_color else 0)))\n    # Exclude current color to enforce a move\n    candidates = [c for c in candidates if c != current_color and c >= 1]\n    if not candidates:\n        # If no alternative, pick a different vertex randomly\n        other = (idx + 1) % n\n        if sol[other] != sol[idx]:\n            idx = other\n            current_color = sol[idx]\n            candidates = [c for c in range(1, max_color+1) if c != current_color]\n        if not candidates:\n            # fallback: return compressed solution unchanged (rare)\n            return (compress_colors(sol), \"Recolor\")\n\n    # Score candidates by local conflicts, tie-break by color frequency (favor rarer colors to enable class elimination)\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    def local_conflicts(color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    best_score = None\n    best_colors = []\n    for c in candidates:\n        sc = local_conflicts(c)\n        key = (sc, freq.get(c, 0))  # minimize conflicts, then prefer rarer\n        if best_score is None or key < best_score:\n            best_score = key\n            best_colors = [c]\n        elif key == best_score:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        edges = get_edges()\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Defensive: if invalid, create a simple feasible seed via greedy\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts to focus perturbation\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[v] == sol[u]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Select k vertices to recolor (bounded to avoid destroying structure)\n    k = random.randint(2, 3)\n    pool = list(conflict_vertices) if conflict_vertices else list(range(n))\n    if len(pool) <= k:\n        picks = pool[:]\n        while len(picks) < k:\n            x = random.randrange(n)\n            if x not in picks:\n                picks.append(x)\n    else:\n        picks = random.sample(pool, k)\n\n    # Recolor chosen vertices with diversification but no palette expansion when already feasible\n    for idx in picks:\n        max_color = max(sol)\n        # Allow new color only if there are conflicts overall to help escape; small probability\n        allow_new = (len(conflict_vertices) > 0) and (random.random() < 0.15)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        # Choose color minimizing local conflicts; tie-break by rarity\n        freq = {}\n        for c in sol:\n            freq[c] = freq.get(c, 0) + 1\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, freq.get(c, 0))\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_COLORS_FOR_VERTICES_1_TO_9","Evaluacion":"import math\nimport random\nimport copy\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10**9\n    # Problem data (1-indexed)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Count violations\n    violations = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            violations += 1\n    # Objective: lexicographic (violations, max_color)\n    max_color = max(solution)\n    M = 100  # > n ensures feasibility prioritized\n    return violations * M + max_color\n","Vecindad":"import math\nimport random\nimport copy\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers and embedded data\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    # Validate\/repair input\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Compute conflicts\n    conflict_edges = []\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_edges.append((u, v))\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    # Try Kempe-chain swap if conflicts exist\n    if conflict_edges and random.random() < 0.6:\n        u, v = random.choice(conflict_edges)\n        a = sol[u]\n        b = sol[v]\n        if a == b:\n            # pick a neighbor color different from a to attempt swap\n            neigh_colors = [sol[w] for w in adj[u] if sol[w] != a]\n            if neigh_colors:\n                b = random.choice(neigh_colors)\n        if a != b:\n            # BFS on subgraph induced by colors {a,b}, starting from u\n            visited = [False]*n\n            queue = [u]\n            visited[u] = True\n            comp = []\n            while queue:\n                x = queue.pop()\n                comp.append(x)\n                for y in adj[x]:\n                    if not visited[y] and sol[y] in (a, b):\n                        visited[y] = True\n                        queue.append(y)\n            new_sol = sol[:]\n            for x in comp:\n                if new_sol[x] == a:\n                    new_sol[x] = b\n                elif new_sol[x] == b:\n                    new_sol[x] = a\n            new_sol = compress_colors(new_sol)\n            if new_sol != sol:\n                return (new_sol, \"KempeSwap\")\n\n    # Otherwise perform targeted recolor\n    def local_conflicts(idx, color):\n        return sum(1 for v in adj[idx] if sol[v] == color)\n\n    # Choose vertex: conflicting first; else from max color class to reduce palette\n    if conflict_vertices:\n        def conflict_count(u):\n            return sum(1 for v in adj[u] if sol[v] == sol[u])\n        idx = max(conflict_vertices, key=lambda u: (conflict_count(u), len(adj[u]), random.random()))\n    else:\n        max_color = max(sol)\n        candidates = [i for i, c in enumerate(sol) if c == max_color]\n        idx = random.choice(candidates) if candidates else random.randrange(n)\n\n    current_color = sol[idx]\n    max_color_now = max(sol)\n\n    # Allow temporary palette expansion when conflicts exist\n    allow_new = (len(conflict_vertices) > 0 and random.random() < 0.2)\n    upper = max_color_now + (1 if allow_new else 0)\n    candidates = [c for c in range(1, upper+1) if c != current_color]\n    if not candidates:\n        # force a different vertex\n        idx = (idx + 1) % n\n        current_color = sol[idx]\n        candidates = [c for c in range(1, max(sol)+1) if c != current_color]\n        if not candidates:\n            # as last resort, introduce a new color\n            candidates = [max(sol)+1]\n\n    # Score candidates: prioritize reducing conflicts, then max color usage\n    freq = {}\n    for c in sol:\n        freq[c] = freq.get(c, 0) + 1\n\n    best_key = None\n    best_colors = []\n    for c in candidates:\n        before_conf = local_conflicts(idx, current_color)\n        after_conf = local_conflicts(idx, c)\n        delta_viol = after_conf - before_conf  # prefer negative\n        new_max = max(max_color_now, c)\n        key = (delta_viol, new_max, freq.get(c, 0))\n        if best_key is None or key < best_key:\n            best_key = key\n            best_colors = [c]\n        elif key == best_key:\n            best_colors.append(c)\n\n    new_color = random.choice(best_colors)\n    new_sol = sol[:]\n    new_sol[idx] = new_color\n    new_sol = compress_colors(new_sol)\n    if new_sol == sol:\n        # ensure a move: flip to any different color\n        alt = new_color + 1 if new_color < max(sol)+1 else 1\n        if alt == current_color:\n            alt = (alt % (max(sol)+1)) + 1\n        new_sol[idx] = alt\n        new_sol = compress_colors(new_sol)\n    return (new_sol, \"Recolor\")\n","Perturbacion":"import math\nimport random\nimport copy\n\n\ndef perturb_solution(solution):\n    def get_edges():\n        return [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        ]\n\n    def build_adj(n=9):\n        adj = [[] for _ in range(n)]\n        for u, v in get_edges():\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    def compress_colors(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def greedy_dsatur_init(n=9):\n        adj = build_adj(n)\n        colors = [0]*n\n        degrees = [len(adj[i]) for i in range(n)]\n        uncolored = set(range(n))\n        while uncolored:\n            best = None\n            best_key = None\n            for v in uncolored:\n                sat = len(set(colors[u] for u in adj[v] if colors[u] != 0))\n                key = (sat, degrees[v], random.random())\n                if best_key is None or key > best_key:\n                    best_key = key\n                    best = v\n            used = set(colors[u] for u in adj[best] if colors[u] != 0)\n            c = 1\n            while c in used:\n                c += 1\n            colors[best] = c\n            uncolored.remove(best)\n        return colors\n\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = greedy_dsatur_init()\n    else:\n        sol = solution[:]\n\n    n = 9\n    adj = build_adj(n)\n\n    # Identify conflicts and largest color class\n    conflict_vertices = set()\n    for u in range(n):\n        for v in adj[u]:\n            if v > u and sol[u] == sol[v]:\n                conflict_vertices.add(u)\n                conflict_vertices.add(v)\n\n    freq = {}\n    for i, c in enumerate(sol):\n        freq[c] = freq.get(c, 0) + 1\n    largest_color = max(freq, key=lambda k: (freq[k], k))\n    largest_class_vertices = [i for i, c in enumerate(sol) if c == largest_color]\n\n    # Perturb strength: 2-4 vertices, prefer conflicts and largest class\n    k = random.randint(2, 4)\n    pool = list(dict.fromkeys(list(conflict_vertices) + largest_class_vertices))\n    if not pool:\n        pool = list(range(n))\n    picks = random.sample(pool, k if len(pool) >= k else len(pool))\n    while len(picks) < k:\n        x = random.randrange(n)\n        if x not in picks:\n            picks.append(x)\n\n    # Recolor picks with minimized local conflicts; allow temporary new color with small prob if conflicts present\n    has_conflicts = len(conflict_vertices) > 0\n    for idx in picks:\n        max_color = max(sol)\n        allow_new = has_conflicts and (random.random() < 0.2)\n        upper = max_color + (1 if allow_new else 0)\n        candidates = [c for c in range(1, upper+1) if c != sol[idx]]\n        if not candidates:\n            continue\n        best_key = None\n        best_colors = []\n        for c in candidates:\n            sc = 0\n            for v in adj[idx]:\n                if sol[v] == c:\n                    sc += 1\n            key = (sc, c)\n            if best_key is None or key < best_key:\n                best_key = key\n                best_colors = [c]\n            elif key == best_key:\n                best_colors.append(c)\n        sol[idx] = random.choice(best_colors)\n\n    sol = compress_colors(sol)\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return float(BIG)\n    if len(solution) != V_count:\n        return float(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float(BIG - 2)\n    # Core objective components\n    k = max(solution)\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better)\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + float(k)\n    return float(score)\n","Vecindad":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef generate_neighbour(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        colors = list(range(1, max(2, k) + 1))\n        # With small probability allow a new color to escape plateaus\n        if random.random() < 0.1:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            if c == current_color and random.random() < 0.5:\n                # sometimes skip staying put\n                continue\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: perform label-aware exploration\n        r = random.random()\n        if r < 0.5 and k >= 2:\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.8:\n            # Kempe chain swap between two colors starting at random vertex\n            if k >= 2:\n                v = random.randrange(n)\n                a, b = random.sample(range(1, k + 1), 2)\n                target_colors = {a, b}\n                stack = [v]\n                visited = set([v])\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target_colors:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target_colors:\n                                visited.add(j)\n                                stack.append(j)\n                # swap a<->b in component\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                i = random.randrange(n)\n                sol[i] = 1\n                move_desc = (\"NoOpFallback\", \"Reassign\")\n        else:\n            # Merge attempt: try to recolor a random vertex to a lower label to reduce k\n            i = random.randrange(n)\n            candidate_colors = list(range(1, k)) if k > 1 else [1]\n            if candidate_colors:\n                sol[i] = random.choice(candidate_colors)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef _canonicalize_labels(sol):\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    return [mapping[x] for x in sol]\n\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    k = max(sol)\n    # Kick parameters\n    t = 4 + random.randrange(4)  # 4..7 vertex edits\n\n    # 1) Random recolors with slight palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        if k > 1 and random.random() < 0.6:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n        k = max(sol)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair\n    k = max(sol)\n    if k >= 2:\n        v = random.randrange(n)\n        a, b = random.sample(range(1, k + 1), 2)\n        target_colors = {a, b}\n        stack = [v]\n        visited = set([v])\n        component = []\n        while stack:\n            u = stack.pop()\n            if sol[u] in target_colors:\n                component.append(u)\n                for nb in adj[u + 1]:\n                    j = nb - 1\n                    if j not in visited and sol[j] in target_colors:\n                        visited.add(j)\n                        stack.append(j)\n        for u in component:\n            sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    return _canonicalize_labels(sol)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    k = max(sol)\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"SingleIndexRecolor\", \"Reassign\")\n\n    if conflicts:\n        # Conflict-biased recolor: pick a conflicting vertex and recolor greedily\n        i = random.choice(list(conflicts))\n        current_color = sol[i]\n        # assemble candidate colors, bias to <= k; allow k+1 with very small prob only if conflicts exist\n        colors = list(range(1, max(2, k) + 1))\n        if random.random() < 0.05:\n            colors.append(max(colors) + 1)\n        best_color = current_color\n        best_conflicts = math.inf\n        for c in colors:\n            cnt = 0\n            for nb in adj[i + 1]:\n                if sol[nb - 1] == c:\n                    cnt += 1\n            # prefer lower color on tie to aid palette reduction later\n            if cnt < best_conflicts or (cnt == best_conflicts and c < best_color):\n                best_conflicts = cnt\n                best_color = c\n        sol[i] = best_color\n        if best_color != current_color:\n            move_desc = (\"ConflictGreedyRecolor\", \"Reassign\")\n    else:\n        # No conflicts: label-aware exploration\n        k = max(sol)\n        r = random.random()\n        if r < 0.45 and k >= 2:\n            # direct label swap\n            a, b = random.sample(range(1, k + 1), 2)\n            sol = [a if x == b else b if x == a else x for x in sol]\n            move_desc = (\"LabelSwap\", \"SwapColors\")\n        elif r < 0.85 and k >= 2:\n            # Kempe chain swap between two colors, ensure seed color in target set\n            a, b = random.sample(range(1, k + 1), 2)\n            target = {a, b}\n            # choose a vertex whose color is in {a,b}; if none exist (degenerate), fallback recolor\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                v = random.choice(candidates)\n                stack = [v]\n                visited = {v}\n                component = []\n                while stack:\n                    u = stack.pop()\n                    if sol[u] in target:\n                        component.append(u)\n                        for nb in adj[u + 1]:\n                            j = nb - 1\n                            if j not in visited and sol[j] in target:\n                                visited.add(j)\n                                stack.append(j)\n                for u in component:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChain\", \"SwapColors\")\n            else:\n                # fallback small recolor to lower labels\n                i = random.randrange(n)\n                if k > 1:\n                    sol[i] = random.randint(1, k - 1)\n                move_desc = (\"FallbackLowerRecolor\", \"Reassign\")\n        else:\n            # Palette reduction attempt: try to recolor a random vertex to a lower label avoiding immediate conflict if possible\n            i = random.randrange(n)\n            lowered = False\n            if k > 1:\n                for c in range(1, k):\n                    conflict = False\n                    for nb in adj[i + 1]:\n                        if sol[nb - 1] == c:\n                            conflict = True\n                            break\n                    if not conflict:\n                        sol[i] = c\n                        lowered = True\n                        break\n            if not lowered:\n                # if no conflict-free lower color, keep color or random minor tweak\n                if k > 1 and random.random() < 0.3:\n                    sol[i] = random.randint(1, k - 1)\n            move_desc = (\"PaletteReduceBias\", \"Reassign\")\n\n    neighbour = _canonicalize_labels(sol)\n    # Postcondition safety\n    if len(neighbour) != 9 or min(neighbour) < 1:\n        neighbour = [1] * 9\n    return neighbour, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    sol = [x if isinstance(x, int) and x >= 1 else 1 for x in sol]\n\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: set() for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def _canonicalize_labels(sol_loc):\n        used = sorted(set(sol_loc))\n        mapping = {c: i + 1 for i, c in enumerate(used)}\n        return [mapping[x] for x in sol_loc]\n\n    # Kick strength\n    t = 5 + random.randrange(3)  # 5..7 edits\n\n    # 1) Random recolors with palette-reduction bias\n    for _ in range(t):\n        i = random.randrange(n)\n        k = max(sol)\n        if k > 1 and random.random() < 0.65:\n            sol[i] = random.randint(1, k - 1)\n        else:\n            sol[i] = random.randint(1, k)\n\n    # 2) Random label swap between two colors (if available)\n    k = max(sol)\n    if k >= 2 and random.random() < 0.9:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [a if x == b else b if x == a else x for x in sol]\n\n    # 3) Kempe-chain swap around a random seed and color pair (ensure seed in target)\n    k = max(sol)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        target = {a, b}\n        candidates = [idx for idx, x in enumerate(sol) if x in target]\n        if candidates:\n            v = random.choice(candidates)\n            stack = [v]\n            visited = {v}\n            component = []\n            while stack:\n                u = stack.pop()\n                if sol[u] in target:\n                    component.append(u)\n                    for nb in adj[u + 1]:\n                        j = nb - 1\n                        if j not in visited and sol[j] in target:\n                            visited.add(j)\n                            stack.append(j)\n            for u in component:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n\n    sol = _canonicalize_labels(sol)\n    if len(sol) != 9 or min(sol) < 1:\n        sol = [1] * 9\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (internal)\n    V_count = 9\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    BIG = 10**15\n    # Type and length checks\n    if not isinstance(solution, (list, tuple)):\n        return int(BIG)\n    if len(solution) != V_count:\n        return int(BIG - 1)\n    # Element checks (positive integers)\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return int(BIG - 2)\n    # Core objective components\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    labels = set(solution)\n    # Contiguity gap: number of missing labels in 1..k\n    contiguity_gap = k - len(labels)\n    # Count edge violations\n    violations = 0\n    for (u, v) in E:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n    # Lexicographic penalty encoding (lower is better):\n    # Primary: violations; Secondary: contiguity gap; Tertiary: k\n    score = violations * 1_000_000_000 + contiguity_gap * 1_000_000 + k\n    return int(score)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    # length repair\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Repair invalid entries by greedy assignment to minimize immediate conflicts\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            best_c = 1\n            best_conf = math.inf\n            k_cur = max(1, max(c for c in sol if isinstance(c, int) and c >= 1))\n            for c in range(1, k_cur + 1):\n                cnt = 0\n                for nb in adj[i + 1]:\n                    if nb - 1 < n and sol[nb - 1] == c:\n                        cnt += 1\n                if cnt < best_conf:\n                    best_conf = cnt\n                    best_c = c\n            sol[i] = best_c\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    def saturation(idx):\n        return len({sol[j - 1] for j in adj[idx + 1]})\n\n    # Identify conflicting vertices\n    conflicts = set()\n    for (u, v) in E:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts.add(u - 1)\n            conflicts.add(v - 1)\n\n    move_desc = (\"NoOp\", \"None\")\n\n    if conflicts:\n        # DSATUR-based pick: prioritize by (#conflicts, saturation, degree)\n        def key_func(i):\n            return (vertex_conflicts(i), saturation(i), len(adj[i + 1]))\n        i = max(conflicts, key=key_func)\n        k_cur = max(sol)\n        # Check if any conflicting vertex has a conflict-free color in 1..k_cur\n        exists_cf = False\n        for j in conflicts:\n            for c in range(1, k_cur + 1):\n                if c == sol[j]:\n                    continue\n                if count_conflicts_at(j, c) == 0:\n                    exists_cf = True\n                    break\n            if exists_cf:\n                break\n        # Try best color within current palette first\n        best_color = sol[i]\n        best_score = (count_conflicts_at(i, sol[i]), sol[i])\n        for c in range(1, k_cur + 1):\n            if c == sol[i]:\n                continue\n            cnt = count_conflicts_at(i, c)\n            # prefer fewer conflicts, then lower color\n            if (cnt, c) < best_score:\n                best_score = (cnt, c)\n                best_color = c\n        # Allow k+1 only if no vertex has a conflict-free recolor\n        if not exists_cf and count_conflicts_at(i, best_color) > 0:\n            best_color = k_cur + 1\n        old = sol[i]\n        sol[i] = best_color\n        move_desc = (\"ConflictRecolor_DSatur\", f\"{i}:{old}->{best_color}\")\n    else:\n        # No conflicts: label-aware exploration\n        k_cur = max(sol)\n        r = random.random()\n        if r < 0.25 and k_cur >= 2:\n            # Label swap (reduced frequency)\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            if a != b:\n                sol = [a if x == b else b if x == a else x for x in sol]\n                move_desc = (\"LabelSwap\", f\"{a}<->{b}\")\n        elif r < 0.7 and k_cur >= 2:\n            # Kempe chain swap with proper alternation between colors a and b\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            # seed must be in target\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if candidates:\n                seed = random.choice(candidates)\n                # BFS alternating on colors a and b\n                from collections import deque\n                q = deque([seed])\n                visited = {seed}\n                while q:\n                    u = q.popleft()\n                    cu = sol[u]\n                    for nb in adj[u + 1]:\n                        v = nb - 1\n                        if v in visited:\n                            continue\n                        if sol[v] in target and sol[v] != cu:\n                            visited.add(v)\n                            q.append(v)\n                for u in visited:\n                    sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n                move_desc = (\"KempeChainAlt\", f\"{a}<->{b} size={len(visited)}\")\n            else:\n                # fallback: no-op\n                move_desc = (\"KempeFallback\", \"None\")\n        else:\n            # Palette reduction attempt: try to absorb highest color class into lower labels greedily\n            if k_cur >= 2:\n                highest = k_cur\n                idxs = [i for i, x in enumerate(sol) if x == highest]\n                absorbed = True\n                for i in idxs:\n                    placed = False\n                    for c in range(1, highest):\n                        if count_conflicts_at(i, c) == 0:\n                            sol[i] = c\n                            placed = True\n                            break\n                    if not placed:\n                        absorbed = False\n                        # try least-conflict lower color\n                        best_c = 1\n                        best_cnt = math.inf\n                        for c in range(1, highest):\n                            cnt = count_conflicts_at(i, c)\n                            if cnt < best_cnt:\n                                best_cnt = cnt\n                                best_c = c\n                        sol[i] = best_c\n                move_desc = (\"PaletteReduce\", f\"k={k_cur}{'->'+str(max(sol)) if absorbed else ''}\")\n            else:\n                move_desc = (\"NoChange\", \"k=1\")\n\n    # Ensure basic validity\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol, move_desc\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Robust copy and repair\n    n = 9\n    if isinstance(solution, list):\n        sol = solution[:]\n    elif isinstance(solution, tuple):\n        sol = list(solution)\n    else:\n        sol = [1] * n\n    if len(sol) != n:\n        if len(sol) < n:\n            sol = sol + [1] * (n - len(sol))\n        else:\n            sol = sol[:n]\n    # Graph (internal)\n    E = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    adj = {i: [] for i in range(1, n + 1)}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts_at(idx, color):\n        cnt = 0\n        for nb in adj[idx + 1]:\n            if sol[nb - 1] == color:\n                cnt += 1\n        return cnt\n\n    def vertex_conflicts(idx):\n        return count_conflicts_at(idx, sol[idx])\n\n    # Sanitize entries\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n\n    # Choose perturbation mode\n    mode = 0 if random.random() < 0.5 else 1\n    # Intensity\n    intensity = 5 + random.randrange(3)  # 5..7\n\n    if mode == 0:\n        # Multiple Kempe swaps (with proper alternation)\n        for _ in range(intensity):\n            k_cur = max(sol)\n            if k_cur < 2:\n                break\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            target = {a, b}\n            candidates = [idx for idx, x in enumerate(sol) if x in target]\n            if not candidates:\n                continue\n            seed = random.choice(candidates)\n            from collections import deque\n            q = deque([seed])\n            visited = {seed}\n            while q:\n                u = q.popleft()\n                cu = sol[u]\n                for nb in adj[u + 1]:\n                    v = nb - 1\n                    if v in visited:\n                        continue\n                    if sol[v] in target and sol[v] != cu:\n                        visited.add(v)\n                        q.append(v)\n            for u in visited:\n                sol[u] = a if sol[u] == b else (b if sol[u] == a else sol[u])\n    else:\n        # Merge two color classes then repair greedily\n        k_cur = max(sol)\n        if k_cur >= 2:\n            a, b = random.sample(range(1, k_cur + 1), 2)\n            # Merge b into a\n            sol = [a if x == b else x for x in sol]\n            # Greedy repairs up to budget\n            budget = intensity * n\n            for _ in range(budget):\n                # find any conflicting vertex\n                bads = []\n                for (u, v) in E:\n                    if sol[u - 1] == sol[v - 1]:\n                        bads.append(u - 1)\n                        bads.append(v - 1)\n                if not bads:\n                    break\n                # DSATUR-like pick among conflicts\n                bads = list(set(bads))\n                # compute saturation on demand\n                def sat(idx):\n                    return len({sol[j - 1] for j in adj[idx + 1]})\n                i = max(bads, key=lambda x: (vertex_conflicts(x), sat(x), len(adj[x + 1])))\n                best_c = sol[i]\n                best_val = (vertex_conflicts(i), sol[i])\n                for c in range(1, k_cur + 1):\n                    if c == sol[i]:\n                        continue\n                    cnt = count_conflicts_at(i, c)\n                    if (cnt, c) < best_val:\n                        best_val = (cnt, c)\n                        best_c = c\n                sol[i] = best_c\n\n    # Canonicalize labels to enforce contiguity\n    used = sorted(set(sol))\n    mapping = {c: i + 1 for i, c in enumerate(used)}\n    sol = [mapping[x] for x in sol]\n\n    # Final safety\n    if len(sol) != 9:\n        sol = sol[:9] + [1] * (9 - len(sol))\n    for i in range(9):\n        if not isinstance(sol[i], int) or sol[i] < 1:\n            sol[i] = 1\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICALIZED_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n = 9\n    if len(solution) != n:\n        return 10**12 + abs(len(solution) - n)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize colors to 1..K by order of first occurrence\n    relabel = {}\n    next_c = 1\n    canon = []\n    for v in solution:\n        if v not in relabel:\n            relabel[v] = next_c\n            next_c += 1\n        canon.append(relabel[v])\n    # Graph definition (1-based in edges)\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    return conflicts * 10**6 + K\n\n# Optional orchestrator (SA) provided for completeness per TARGET_HEURISTIC_SA\n# Uses lexicographic acceptance (conflicts first, then K) with temperature on numeric proxy\n\ndef SA(currentSolution, best, best_score, generate_neighbour, evaluate_solution, temp, minTemp, cooling_factor):\n    # Internal helpers\n    def canonicalize(sol):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in sol:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def conflicts_K(sol):\n        sol = canonicalize(sol)\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        conflicts = 0\n        for u,v in edges:\n            if sol[u-1] == sol[v-1]:\n                conflicts += 1\n        K = len(set(sol))\n        return conflicts, K\n    # Defensive repair\n    if not isinstance(currentSolution, (list, tuple)) or len(currentSolution) != 9:\n        current = list(range(1, 10))\n    else:\n        current = [int(v) if isinstance(v, int) and v >= 1 else 1 for v in currentSolution]\n    current = canonicalize(current)\n    # Initialize best if needed\n    if best is None or best_score is None:\n        best = current[:]\n        best_score = evaluate_solution(best)\n    # SA loop (bounded)\n    iter_budget = 2000\n    for _ in range(iter_budget):\n        neighbour, _ = generate_neighbour(current)\n        cur_conf, cur_K = conflicts_K(current)\n        nb_conf, nb_K = conflicts_K(neighbour)\n        # Lexicographic improvement check\n        better = (nb_conf < cur_conf) or (nb_conf == cur_conf and nb_K < cur_K)\n        # Numeric delta for probabilistic acceptance\n        delta = evaluate_solution(neighbour) - evaluate_solution(current)\n        if better or (delta <= 0) or (random.random() < math.exp(-max(0, delta) \/ max(minTemp, temp))):\n            current = neighbour\n            # Update best if improved lexicographically\n            b_conf, b_K = conflicts_K(best)\n            if (nb_conf < b_conf) or (nb_conf == b_conf and nb_K < b_K):\n                best = neighbour\n                best_score = evaluate_solution(best)\n        temp = max(minTemp, temp * cooling_factor)\n        if temp <= minTemp and cur_conf == 0 and cur_K <= 4:\n            break\n    return {\n        'current': current,\n        'currentScore': evaluate_solution(current),\n        'best': best,\n        'bestScore': best_score,\n    }\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize colors by first occurrence\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    # Conflict counts\n    conflicts_per_v = [0]*n\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v)\/\/2\n    max_color = max(sol)\n    # Helper: drop empty color classes and canonicalize\n    def squeeze(arr):\n        counts = {}\n        for c in arr:\n            counts[c] = counts.get(c, 0) + 1\n        # Remove holes by relabeling\n        return canonicalize(arr)\n    # If conflicts exist: recolor a conflicting vertex with best delta\n    if total_conflicts > 0:\n        conflict_vertices = [i for i,c in enumerate(conflicts_per_v) if c>0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best_color = current_color\n        best_tuple = (10**9, 1, 1)  # (delta_conflicts, color_increase, color_index)\n        for c in range(1, max_color+2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            color_increase = 1 if c == max_color+1 else 0\n            cand = (delta, color_increase, c)\n            if cand < best_tuple:\n                best_tuple = cand\n                best_color = c\n        new_sol = sol[:]\n        new_sol[i] = best_color\n        new_sol = squeeze(new_sol)\n        move = \"RecolorConflict\"\n        # Occasionally attempt a small Kempe swap to escape plateaus\n        if random.random() < 0.2 and max_color >= 2:\n            c1 = random.randrange(1, max_color+1)\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 5:\n                c2 = random.randrange(1, max_color+1)\n                tries += 1\n            if c2 != c1:\n                # pick seed with color c1 or c2\n                indices = [idx for idx,v in enumerate(new_sol) if v in (c1,c2)]\n                if indices:\n                    seed = random.choice(indices)\n                    queue = [seed]\n                    seen = {seed}\n                    component = [seed]\n                    while queue:\n                        u = queue.pop(0)\n                        for w in adj[u]:\n                            if new_sol[w] in (c1,c2) and w not in seen:\n                                seen.add(w)\n                                queue.append(w)\n                                component.append(w)\n                    for u in component:\n                        if new_sol[u] == c1:\n                            new_sol[u] = c2\n                        elif new_sol[u] == c2:\n                            new_sol[u] = c1\n                    new_sol = squeeze(new_sol)\n                    move = \"KempeSwap\"\n        return new_sol, move\n    # If no conflicts: try to reduce K by moving a vertex from the highest color class\n    # without introducing new colors\n    highest = max_color\n    indices_high = [i for i,v in enumerate(sol) if v == highest]\n    if indices_high:\n        random.shuffle(indices_high)\n        for i in indices_high:\n            # try assign to one of the lower colors only\n            candidate_colors = list(range(1, highest))\n            random.shuffle(candidate_colors)\n            for c in candidate_colors:\n                ok = True\n                for j in adj[i]:\n                    if sol[j] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol = sol[:]\n                    new_sol[i] = c\n                    # if highest color becomes empty, squeeze\n                    if all(v != highest for v in new_sol):\n                        new_sol = squeeze(new_sol)\n                    else:\n                        new_sol = canonicalize(new_sol)\n                    return new_sol, \"ReduceK-Recolor\"\n    # If cannot reduce, perform a harmless color-class swap to diversify (keeps K)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 5:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        new_sol = sol[:]\n        for i,v in enumerate(new_sol):\n            if v == c1:\n                new_sol[i] = c2\n            elif v == c2:\n                new_sol[i] = c1\n        new_sol = canonicalize(new_sol)\n        return new_sol, \"ColorClassSwap\"\n    # Fallback: random recolor without increasing K\n    i = random.randrange(n)\n    c = random.randrange(1, max_color+1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Defensive copy and repair\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n = 9\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    # Canonicalize\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    sol = canonicalize(sol)\n    # Graph data\n    edges = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9),\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    max_color = max(sol)\n    new_sol = sol[:]\n    # Kick 1: recolor k random vertices; allow temporary new color\n    k = 3\n    for _ in range(k):\n        i = random.randrange(n)\n        c = random.randrange(1, max_color + 2)  # may introduce a new color\n        if c < 1:\n            c = 1\n        new_sol[i] = c\n        if c > max_color:\n            max_color = c\n    # Kick 2: Kempe-chain swap on random color pair within a BFS component\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color+1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color+1)\n            tries += 1\n        if c2 != c1:\n            indices = [i for i,v in enumerate(new_sol) if v in (c1,c2)]\n            if indices:\n                seed = random.choice(indices)\n                queue = [seed]\n                seen = {seed}\n                component = [seed]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1,c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                for u in component:\n                    if new_sol[u] == c1:\n                        new_sol[u] = c2\n                    elif new_sol[u] == c2:\n                        new_sol[u] = c1\n    # Canonicalize result to drop empty classes\n    new_sol = canonicalize(new_sol)\n    return new_sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    # Conflict computation helpers\n    def conflicts_of(arr):\n        c = 0\n        for u, v in edges:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Conflicts per vertex\n    conflicts_per_v = [0] * n\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    max_color = max(sol)\n    # Helper to remove gaps in color labels\n    def squeeze(arr):\n        return canonicalize(arr)\n    # Operator 1: If conflicts exist, recolor a conflicting vertex with best improvement (no worse; cap K growth)\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current_color = sol[i]\n        best = sol[:]\n        best_tuple = (10**9, 1, 10**9)  # (delta_conflicts, color_increase, color_index)\n        base_conf = conflicts_per_v[i]\n        # Build neighbor color set (including current K; optionally K+1 only if strictly reduces conflicts)\n        for c in range(1, max_color + 2):\n            if c == current_color:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == current_color:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            # Accept only non-worsening; allow new color only if strictly improves\n            color_increase = 1 if c == max_color + 1 else 0\n            if color_increase == 1 and delta >= 0:\n                continue\n            cand_tuple = (delta, color_increase, c)\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_i_color = c\n        new_sol = sol[:]\n        if best_tuple[0] == 10**9:\n            # fallback: pick a different existing color randomly\n            choices = [c for c in range(1, max_color + 1) if c != current_color]\n            if choices:\n                best_i_color = random.choice(choices)\n            else:\n                best_i_color = current_color\n        new_sol[i] = best_i_color\n        new_sol = squeeze(new_sol)\n        # Guarded small Kempe swap (only if not worsening conflicts)\n        if random.random() < 0.25 and max(new_sol) >= 2:\n            c1 = new_sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 6:\n                c2 = random.randrange(1, max(new_sol) + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by colors c1, c2 starting at i\n                queue = [i]\n                seen = {i}\n                component = [i]\n                while queue:\n                    u = queue.pop(0)\n                    for w in adj[u]:\n                        if new_sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            queue.append(w)\n                            component.append(w)\n                trial = new_sol[:]\n                for u in component:\n                    trial[u] = c2 if new_sol[u] == c1 else (c1 if new_sol[u] == c2 else trial[u])\n                trial = squeeze(trial)\n                if conflicts_of(trial) <= conflicts_of(new_sol):\n                    return trial, \"KempeSwap\"\n        return new_sol, \"RecolorConflict\"\n    # Operator 2: K reduction attempt by moving vertices from highest color without conflicts\n    highest = max_color\n    indices_high = [i for i, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for i in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for j in adj[i]:\n                if sol[j] == c:\n                    ok = False\n                    break\n            if ok:\n                new_sol = sol[:]\n                new_sol[i] = c\n                new_sol = squeeze(new_sol)\n                return new_sol, \"ReduceK-Recolor\"\n    # Operator 3: Merge smallest color class into others if feasible\n    counts = {}\n    for v in sol:\n        counts[v] = counts.get(v, 0) + 1\n    smallest_color = min(counts, key=lambda c: counts[c]) if counts else 1\n    verts = [i for i, v in enumerate(sol) if v == smallest_color]\n    target_colors = [c for c in range(1, max_color + 1) if c != smallest_color]\n    random.shuffle(target_colors)\n    def can_assign_all(color):\n        for i in verts:\n            for j in adj[i]:\n                if sol[j] == color:\n                    return False\n        return True\n    for c in target_colors:\n        if can_assign_all(c):\n            new_sol = sol[:]\n            for i in verts:\n                new_sol[i] = c\n            new_sol = squeeze(new_sol)\n            return new_sol, \"MergeClasses\"\n    # Operator 4: Random localized Kempe chain for diversification (keeps K; guarded)\n    if max_color >= 2:\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 6:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        # pick random seed with color c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if idxs:\n            seed = random.choice(idxs)\n            queue = [seed]\n            seen = {seed}\n            component = [seed]\n            while queue:\n                u = queue.pop(0)\n                for w in adj[u]:\n                    if sol[w] in (c1, c2) and w not in seen:\n                        seen.add(w)\n                        queue.append(w)\n                        component.append(w)\n            trial = sol[:]\n            for u in component:\n                trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n            trial = canonicalize(trial)\n            return trial, \"RandomKempeChain\"\n    # Fallback: random recolor within existing colors\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    new_sol = sol[:]\n    new_sol[i] = c\n    new_sol = canonicalize(new_sol)\n    return new_sol, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Kick 1: recolor a small random subset, allowing at most one extra color if it strictly reduces local conflicts\n    k = 3\n    indices = list(range(n))\n    random.shuffle(indices)\n    indices = indices[:k]\n    def local_conflicts(idx, arr):\n        c = 0\n        for j in adj[idx]:\n            if arr[j] == arr[idx]:\n                c += 1\n        return c\n    for i in indices:\n        base_c = local_conflicts(i, sol)\n        candidate_colors = list(range(1, max_color + 2))\n        random.shuffle(candidate_colors)\n        best = sol[i]\n        best_delta = 0\n        for c in candidate_colors:\n            if c == sol[i]:\n                continue\n            delta = 0\n            for j in adj[i]:\n                if sol[j] == sol[i]:\n                    delta -= 1\n                if sol[j] == c:\n                    delta += 1\n            inc = 1 if c == max_color + 1 else 0\n            if inc == 1 and delta >= 0:\n                continue\n            if delta < best_delta or (delta == best_delta and inc == 0):\n                best_delta = delta\n                best = c\n        sol[i] = best\n        if best > max_color:\n            max_color = best\n    # Kick 2: One or two guarded Kempe-chain swaps for diversification\n    swaps = 2\n    for _ in range(swaps):\n        if max_color < 2:\n            break\n        c1 = random.randrange(1, max_color + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, max_color + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices colored c1 or c2\n        idxs = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not idxs:\n            continue\n        seed = random.choice(idxs)\n        queue = [seed]\n        seen = {seed}\n        component = [seed]\n        while queue:\n            u = queue.pop(0)\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    queue.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        # accept non-worsening in terms of conflicts; tolerate small temporary K changes but canonicalize after\n        def conflicts_of(arr):\n            c = 0\n            for (u, v) in edges:\n                if arr[u-1] == arr[v-1]:\n                    c += 1\n            return c\n        if conflicts_of(trial) <= conflicts_of(sol):\n            sol = trial\n            max_color = max(sol)\n    sol = canonicalize(sol)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_taekwondo_tournament_standard","Representacion":"LIST_INT_LEN9_COLORS_START_AT_1_CANONICAL_BY_FIRST_OCCURRENCE","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        return n, edges\n    # Validate type and length\n    if not isinstance(solution, (list, tuple)):\n        return 10**12\n    n_expected, edges = G()\n    if len(solution) != n_expected:\n        return 10**12 + abs(len(solution) - n_expected)\n    # Validate entries are positive integers\n    bad = sum(1 for v in solution if not isinstance(v, int) or v < 1)\n    if bad:\n        return 10**12 + bad\n    # Canonicalize\n    canon = canonicalize(list(solution))\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if canon[u-1] == canon[v-1]:\n            conflicts += 1\n    K = len(set(canon))\n    if conflicts == 0:\n        return K\n    # Large penalty prioritizing conflict elimination first\n    return conflicts * 10**6 + K\n","Vecindad":"import random\nimport math\nfrom collections import deque\n\ndef generate_neighbour(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    max_color = max(sol)\n    # Build conflicts per vertex\n    conflicts_per_v = [0] * n\n    for (u, v) in edges:\n        cu = sol[u-1]; cv = sol[v-1]\n        if cu == cv:\n            conflicts_per_v[u-1] += 1\n            conflicts_per_v[v-1] += 1\n    total_conflicts = sum(conflicts_per_v) \/\/ 2\n    # If conflicts exist, try to recolor a conflicting vertex within existing colors\n    if total_conflicts > 0:\n        conflict_vertices = [i for i, c in enumerate(conflicts_per_v) if c > 0]\n        i = random.choice(conflict_vertices)\n        current = sol[i]\n        best_color = current\n        best_conf = total_conflicts\n        for c in range(1, max_color + 1):\n            if c == current:\n                continue\n            trial = sol[:]\n            trial[i] = c\n            cval = conflicts_of(trial, edges)\n            if cval < best_conf:\n                best_conf = cval\n                best_color = c\n        if best_color != current:\n            sol2 = sol[:]\n            sol2[i] = best_color\n            sol2 = canonicalize(sol2)\n            return sol2, \"RecolorConflict\"\n        # Guarded Kempe chain swap (does not worsen conflicts)\n        if max_color >= 2:\n            c1 = sol[i]\n            c2 = c1\n            tries = 0\n            while c2 == c1 and tries < 8:\n                c2 = random.randrange(1, max_color + 1)\n                tries += 1\n            if c2 != c1:\n                # BFS on subgraph induced by c1,c2 from i\n                q = deque([i])\n                seen = {i}\n                component = [i]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) <= total_conflicts:\n                    trial = canonicalize(trial)\n                    return trial, \"KempeSwap\"\n        # Fallback random recolor within existing palette\n        c = random.randrange(1, max_color + 1)\n        j = i\n        sol3 = sol[:]\n        sol3[j] = c\n        sol3 = canonicalize(sol3)\n        return sol3, \"RandomRecolorConflict\"\n    # No conflicts: try reducing K by moving vertices from highest color downwards\n    highest = max_color\n    indices_high = [idx for idx, v in enumerate(sol) if v == highest]\n    random.shuffle(indices_high)\n    for idx in indices_high:\n        candidate_colors = list(range(1, highest))\n        random.shuffle(candidate_colors)\n        for c in candidate_colors:\n            ok = True\n            for nb in adj[idx]:\n                if sol[nb] == c:\n                    ok = False\n                    break\n            if ok:\n                trial = sol[:]\n                trial[idx] = c\n                # Now squeeze labels to possibly remove the highest color\n                trial = canonicalize(trial)\n                return trial, \"ReduceK-Recolor\"\n    # If K-reduction not possible, diversify with a guarded Kempe swap that keeps conflicts at 0\n    if max_color >= 2:\n        colors = list(range(1, max_color + 1))\n        c1 = random.choice(colors)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.choice(colors)\n            tries += 1\n        if c2 != c1:\n            # pick seed from vertices colored c1 or c2\n            candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n            if candidates:\n                seed = random.choice(candidates)\n                q = deque([seed])\n                seen = {seed}\n                component = [seed]\n                while q:\n                    u = q.popleft()\n                    for w in adj[u]:\n                        if sol[w] in (c1, c2) and w not in seen:\n                            seen.add(w)\n                            q.append(w)\n                            component.append(w)\n                trial = sol[:]\n                for u in component:\n                    trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n                if conflicts_of(trial, edges) == 0:\n                    trial = canonicalize(trial)\n                    return trial, \"DiversifyKempe\"\n    # Final fallback: random recolor within existing colors (should keep feasibility in most cases)\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    trial = sol[:]\n    trial[i] = c\n    trial = canonicalize(trial)\n    return trial, \"RandomRecolor\"\n","Perturbacion":"import random\nimport math\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Utilities (scoped and consistent)\n    def canonicalize(arr):\n        relabel = {}\n        next_c = 1\n        out = []\n        for v in arr:\n            if v not in relabel:\n                relabel[v] = next_c\n                next_c += 1\n            out.append(relabel[v])\n        return out\n    def G():\n        edges = [\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9),\n        ]\n        n = 9\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return n, edges, adj\n    def conflicts_of(arr, edges_local):\n        c = 0\n        for (u, v) in edges_local:\n            if arr[u-1] == arr[v-1]:\n                c += 1\n        return c\n    # Defensive copy and sanitation\n    if not isinstance(solution, (list, tuple)):\n        sol = list(range(1, 10))\n    else:\n        sol = list(solution)\n    n, edges, adj = G()\n    if len(sol) != n:\n        sol = (sol + list(range(1, n+1)))[:n]\n    for i, v in enumerate(sol):\n        if not isinstance(v, int) or v < 1:\n            sol[i] = 1\n    sol = canonicalize(sol)\n    K = max(sol)\n    # Kick 1: recolor k random vertices using only existing colors, aiming not to increase conflicts\n    k = 3\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:k]\n    for i in idxs:\n        current = sol[i]\n        best = current\n        base_conf = 0\n        for nb in adj[i]:\n            if sol[nb] == current:\n                base_conf += 1\n        best_delta = 0\n        cand_colors = list(range(1, K + 1))\n        random.shuffle(cand_colors)\n        for c in cand_colors:\n            if c == current:\n                continue\n            delta = 0\n            for nb in adj[i]:\n                if sol[nb] == current:\n                    delta -= 1\n                if sol[nb] == c:\n                    delta += 1\n            if delta < best_delta:\n                best_delta = delta\n                best = c\n        sol[i] = best\n    # Kick 2: up to 2 guarded Kempe-chain swaps that do not worsen total conflicts\n    total_c = conflicts_of(sol, edges)\n    swaps = 2\n    for _ in range(swaps):\n        if K < 2:\n            break\n        c1 = random.randrange(1, K + 1)\n        c2 = c1\n        tries = 0\n        while c2 == c1 and tries < 8:\n            c2 = random.randrange(1, K + 1)\n            tries += 1\n        if c2 == c1:\n            continue\n        # choose random seed from vertices with color c1 or c2\n        candidates = [idx for idx, v in enumerate(sol) if v in (c1, c2)]\n        if not candidates:\n            continue\n        seed = random.choice(candidates)\n        # BFS component in (c1,c2)\n        from collections import deque as _dq\n        q = _dq([seed])\n        seen = {seed}\n        component = [seed]\n        while q:\n            u = q.popleft()\n            for w in adj[u]:\n                if sol[w] in (c1, c2) and w not in seen:\n                    seen.add(w)\n                    q.append(w)\n                    component.append(w)\n        trial = sol[:]\n        for u in component:\n            trial[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else trial[u])\n        if conflicts_of(trial, edges) <= total_c:\n            sol = trial\n            total_c = conflicts_of(sol, edges)\n    sol = canonicalize(sol)\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Conflict-driven recolor within current k; canonicalize labels\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        # Canonical by sorting color classes by (min vertex index, then color id)\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    # Identify conflicting vertices\n    conflicting_vertices = set()\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n\n    new_sol = sol[:]\n\n    if conflicting_vertices:\n        v = random.choice(list(conflicting_vertices))\n        current = new_sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing resulting conflicts at v\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            tmp = new_sol[:]\n            tmp[v-1] = c\n            # Only need to evaluate conflicts involving v\n            conf_v = 0\n            for w in adj[v]:\n                if tmp[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol[v-1] = best_c\n        move_desc = f\"recolor_conflicting_vertex_{v}_to_{best_c}\"\n    else:\n        # Feasible: do a lateral move without increasing conflicts and without increasing k\n        v = random.randint(1, 9)\n        current = new_sol[v-1]\n        candidates = [c for c in range(1, k+1) if c != current]\n        best_c = current\n        base_conf = 0  # feasible, local conflicts at v is 0\n        best_extra = None\n        for c in candidates:\n            extra = 0\n            for w in adj[v]:\n                if new_sol[w-1] == c:\n                    extra += 1\n            if best_extra is None or extra < best_extra:\n                best_extra = extra\n                best_c = c\n        if best_c != current and best_extra == 0:\n            new_sol[v-1] = best_c\n            move_desc = f\"lateral_recolor_vertex_{v}_to_{best_c}\"\n        else:\n            move_desc = f\"no_op_vertex_{v}\"\n\n    new_sol = canonicalize(new_sol)\n    return (new_sol, move_desc)\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: multiple random conflict-directed recolors and Kempe swaps; may allow k+1 temporarily\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def canonicalize(sol_list):\n        color_to_vertices = {}\n        for i, c in enumerate(sol_list, start=1):\n            color_to_vertices.setdefault(c, []).append(i)\n        order = sorted(color_to_vertices.items(), key=lambda kv: (min(kv[1]), kv[0]))\n        mapping = {old: i+1 for i, (old, _) in enumerate(order)}\n        return [mapping[c] for c in sol_list]\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        # BFS on subgraph induced by colors a and b; swap colors on component containing v\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set()\n        q = deque([v])\n        visited.add(v)\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    adj = adjacency()\n    k = max(max(sol), 1)\n\n    steps = 5  # strength\n    cur = sol[:]\n\n    for _ in range(steps):\n        move_type = random.random()\n        if move_type < 0.5:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = random.choice(list(conflicting))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif move_type < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random color class relabel (diversification without changing feasibility)\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    cur = canonicalize(cur)\n    return cur\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (DSATUR-like focus)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional k+1 expansion\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_10_textbook_standard","Representacion":"INDEX_LIST_9_POSITIVE_INTS length=9; solution[i] is color of vertex i+1; colors in {1,2,...}","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return 10**9\n    try:\n        colors = [int(x) for x in solution]\n    except Exception:\n        return 10**9\n    if any(x < 1 for x in colors):\n        return 10**9\n\n    # Problem data (internal)\n    edges_raw = [\n        (1,3),(1,4),(1,5),(1,9),\n        (2,3),(2,5),(2,6),(2,7),(2,8),\n        (3,4),(3,5),(3,7),(3,8),(3,9),\n        (4,6),(4,7),\n        (5,8),(5,9),\n        (8,9)\n    ]\n    # Normalize edges undirected without duplicates\n    seen = set()\n    for (u,v) in edges_raw:\n        if u == v:\n            continue\n        a,b = (u,v) if u < v else (v,u)\n        seen.add((a,b))\n    edges = tuple(seen)\n\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    if conflicts == 0:\n        return max(colors)\n\n    # Infeasible penalty: scale conflicts high relative to k\n    n = 9\n    k = max(colors)\n    penalty_base = 10**6\n    return penalty_base + conflicts * (n*n) + k\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution_list, movement_description)\n    if not isinstance(solution, list) or len(solution) != 9:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_input_reset_to_example\")\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return ([2,4,1,3,3,1,2,2,4], \"invalid_cast_reset_to_example\")\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def count_conflicts(sol_list):\n        cnt = 0\n        for (u,v) in edges():\n            if sol_list[u-1] == sol_list[v-1]:\n                cnt += 1\n        return cnt\n\n    def try_drop_highest_color(sol_list, adj):\n        # Attempt to reduce k by recoloring vertices of the highest color greedily\n        k = max(max(sol_list), 1)\n        targets = [v for v,c in enumerate(sol_list, start=1) if c == k]\n        if not targets or k == 1:\n            return None\n        new_sol = sol_list[:]\n        # Order targets by decreasing degree to place harder vertices first\n        targets.sort(key=lambda v: -len(adj[v]))\n        for v in targets:\n            # Try assign a color in 1..k-1 that does not clash\n            assigned = False\n            for c in range(1, k):\n                ok = True\n                for w in adj[v]:\n                    if new_sol[w-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    new_sol[v-1] = c\n                    assigned = True\n                    break\n            if not assigned:\n                return None  # fail to drop\n        # Verify feasibility preserved (no new conflicts introduced)\n        if count_conflicts(new_sol) == 0 and max(new_sol) <= k-1:\n            return new_sol\n        return None\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    # 1) Try k-reduction via dropping highest color class\n    dropped = try_drop_highest_color(sol, adj)\n    if dropped is not None:\n        return (dropped, f\"drop_color_{k}_to_{k-1}\")\n\n    # 2) Identify conflicts\n    conflict_count = {i: 0 for i in range(1,10)}\n    total_conflicts = 0\n    for (u,v) in edges():\n        if sol[u-1] == sol[v-1]:\n            conflict_count[u] += 1\n            conflict_count[v] += 1\n            total_conflicts += 1\n\n    if total_conflicts > 0:\n        # Choose vertex with maximum conflicts (focus like TabuCol\/DSATUR)\n        v = max(range(1,10), key=lambda x: (conflict_count[x], len(adj[x]), -x))\n        current = sol[v-1]\n        # Candidate colors restricted to 1..k (no inflation here)\n        candidates = [c for c in range(1, k+1) if c != current]\n        if not candidates:\n            candidates = [current]\n        # Choose color minimizing conflicts at v; tie-break by color id\n        best_c = current\n        best_conf = None\n        for c in candidates:\n            conf_v = 0\n            for w in adj[v]:\n                if sol[w-1] == c:\n                    conf_v += 1\n            if (best_conf is None) or (conf_v < best_conf) or (conf_v == best_conf and c < best_c):\n                best_conf = conf_v\n                best_c = c\n        new_sol = sol[:]\n        new_sol[v-1] = best_c\n        return (new_sol, f\"recolor_conflicting_vertex_{v}_to_{best_c}\")\n\n    # 3) Feasible: explore plateau moves without increasing conflicts or k\n    # Try a Kempe-chain swap that keeps feasibility\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        v = random.randint(1,9)\n        # Build Kempe component and swap\n        def kempe_swap(sol_list, vtx, ca, cb):\n            if sol_list[vtx-1] not in (ca, cb):\n                return sol_list[:]\n            nsol = sol_list[:]\n            visited = set([vtx])\n            q = deque([vtx])\n            while q:\n                x = q.popleft()\n                if nsol[x-1] == ca:\n                    nsol[x-1] = cb\n                elif nsol[x-1] == cb:\n                    nsol[x-1] = ca\n                for y in adj[x]:\n                    if y not in visited and nsol[y-1] in (ca, cb):\n                        visited.add(y)\n                        q.append(y)\n            return nsol\n        candidate = kempe_swap(sol, v, a, b)\n        if count_conflicts(candidate) == 0 and max(candidate) == k:\n            return (candidate, f\"kempe_swap_vertex_{v}_colors_{a}_{b}\")\n    # As fallback, relabel swap two colors (neutral diversification)\n    if k >= 2:\n        a, b = random.sample(range(1, k+1), 2)\n        relabeled = [b if x == a else (a if x == b else x) for x in sol]\n        return (relabeled, f\"relabel_swap_colors_{a}_{b}\")\n\n    return (sol[:], \"no_op\")\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Diversification: random conflict-directed recolors, Kempe swaps, and occasional color relabels\n    if not isinstance(solution, list) or len(solution) != 9:\n        return [2,4,1,3,3,1,2,2,4]\n    try:\n        sol = [int(x) for x in solution]\n    except Exception:\n        return [2,4,1,3,3,1,2,2,4]\n\n    def edges():\n        return (\n            (1,3),(1,4),(1,5),(1,9),\n            (2,3),(2,5),(2,6),(2,7),(2,8),\n            (3,4),(3,5),(3,7),(3,8),(3,9),\n            (4,6),(4,7),\n            (5,8),(5,9),\n            (8,9)\n        )\n\n    def build_adjacency():\n        adj = {i: set() for i in range(1,10)}\n        for (u,v) in edges():\n            if u == v:\n                continue\n            adj[u].add(v)\n            adj[v].add(u)\n        return {i: sorted(adj[i]) for i in range(1,10)}\n\n    def kempe_swap(sol_list, v, a, b, adj):\n        if sol_list[v-1] not in (a, b):\n            return sol_list[:]\n        nsol = sol_list[:]\n        visited = set([v])\n        q = deque([v])\n        while q:\n            x = q.popleft()\n            if nsol[x-1] == a:\n                nsol[x-1] = b\n            elif nsol[x-1] == b:\n                nsol[x-1] = a\n            for y in adj[x]:\n                if y not in visited and nsol[y-1] in (a, b):\n                    visited.add(y)\n                    q.append(y)\n        return nsol\n\n    adj = build_adjacency()\n    k = max(max(sol), 1)\n\n    steps = 6\n    cur = sol[:]\n\n    for _ in range(steps):\n        r = random.random()\n        if r < 0.45:\n            # Conflict-directed recolor; allow k+1 while perturbing\n            conflicting = set()\n            for (u,v) in edges():\n                if cur[u-1] == cur[v-1]:\n                    conflicting.add(u)\n                    conflicting.add(v)\n            if conflicting:\n                v = max(conflicting, key=lambda x: sum(1 for w in adj[x] if cur[w-1] == cur[x-1]))\n            else:\n                v = random.randint(1,9)\n            used = {cur[w-1] for w in adj[v]}\n            pool = [c for c in range(1, k+2) if c not in used]\n            if not pool:\n                pool = list(range(1, k+2))\n            newc = random.choice(pool)\n            cur[v-1] = newc\n            k = max(k, newc)\n        elif r < 0.9:\n            # Kempe swap between two random colors\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                v = random.randint(1,9)\n                cur = kempe_swap(cur, v, a, b, adj)\n        else:\n            # Random relabel swap\n            if k >= 2:\n                a, b = random.sample(range(1, k+1), 2)\n                cur = [b if x == a else (a if x == b else x) for x in cur]\n\n    return cur\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9. solution = [c(1),...,c(9)] with integers >=1. Labels must be contiguous 1..k (no gaps).","Evaluacion":"import math\n\ndef evaluate_solution(solution: list) -> int:\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution)-n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Label contiguity penalty (prefer canonical contiguous labels 1..k)\n    used = set(colors)\n    contig_ok = used == set(range(1, k+1))\n    gap_pen = 0 if contig_ok else 100 + (abs(k - len(used))**2)\n\n    # Count edge conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            conflicts += 1\n\n    # Shaped score: prioritize feasibility (conflicts) first, then minimize k\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Build adjacency for advanced moves (Kempe chain)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u<v else v, v if u<v else u) for (u,v) in edges if u!=v]\n    edges = sorted(set(edges))\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        # Deterministic canonical mapping by ascending label value\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return ([1]*n, \"Init-Fallback\")\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    move_choice = random.random()\n\n    if move_choice < 0.5:\n        # Recolor one vertex\n        i = random.randrange(n)\n        cur = s[i]\n        candidates = [c for c in range(1, k+1) if c != cur]\n        # Allow new color only if currently conflicting to escape plateaus\n        if count_conflicts(s) > 0 and random.random() < 0.1:\n            candidates.append(k+1)\n        if not candidates:\n            candidates = [1 if cur != 1 else 2]\n        s[i] = random.choice(candidates)\n        s = normalize_labels(s)\n        return s, \"Recolor-One\"\n    elif move_choice < 0.8:\n        # Kempe-chain swap between two colors a,b starting from a random vertex\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            start = random.randrange(1, n+1)\n            target_colors = {a, b}\n            visited = set()\n            stack = [start]\n            while stack:\n                u = stack.pop()\n                if u in visited:\n                    continue\n                if s[u-1] in target_colors:\n                    visited.add(u)\n                    for v in adj[u]:\n                        if v not in visited and s[v-1] in target_colors:\n                            stack.append(v)\n            # Swap colors a<->b on the reached component\n            for u in visited:\n                if s[u-1] == a:\n                    s[u-1] = b\n                elif s[u-1] == b:\n                    s[u-1] = a\n            s = normalize_labels(s)\n            return s, \"Kempe-Chain\"\n        else:\n            # Fallback to recolor\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n    else:\n        # Color-swap: pick two colors and swap labels globally\n        if k >= 2:\n            a, b = random.sample(range(1, k+1), 2)\n            for i in range(n):\n                if s[i] == a:\n                    s[i] = b\n                elif s[i] == b:\n                    s[i] = a\n            s = normalize_labels(s)\n            return s, \"Swap-Labels\"\n        else:\n            i = random.randrange(n)\n            s[i] = 1\n            s = normalize_labels(s)\n            return s, \"Recolor-One\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-vertex perturbation with occasional relabel shuffle\n    n = 9\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return [1]*n\n\n    s = solution[:]\n    k = max(s) if s else 1\n\n    # Random relabel swap between two colors (if at least 2 colors)\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k+1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Multi-vertex recolors\n    t = max(3, min(n\/\/2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        # 90% pick within existing colors, 10% allow new color k_now+1\n        if random.random() < 0.9:\n            newc = random.randrange(1, k_now+1)\n        else:\n            newc = k_now + 1\n        s[i] = newc\n\n    s = normalize_labels(s)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; solution is a Python list of 9 positive integers [c(1),...,c(9)] with contiguous labels 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Graph definition (1-indexed vertices)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Label contiguity penalty (only when conflict-free; small weight)\n    used = set(colors)\n    contig_ok = used == set(range(1, k + 1))\n    gap_pen = 0\n    if conflicts == 0 and not contig_ok:\n        gap_pen = 5 + (abs(k - len(used)) ** 2)\n\n    # Objective: minimize conflicts first, then k, then contiguity\n    score = conflicts * 1000 + k + gap_pen\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Ensure input validity minimally; fallback to trivial\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return ([1] * n, \"Init-Fallback\")\n\n    # Problem data (embedded)\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    conf_set = conflict_vertices(s)\n\n    # If conflicts exist: min-conflicts recolor on a conflicting vertex\n    if conf_set:\n        v = random.choice(list(conf_set))\n        current_color = s[v - 1]\n        # Evaluate conflicts per color assignment\n        best_colors = []\n        best_conf = None\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_colors = [c]\n            elif cval == best_conf:\n                best_colors.append(c)\n        # Allow introducing k+1 only if all colors keep conflicts\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if best_conf > 0:\n            tmp = s[:]\n            tmp[v - 1] = k + 1\n            cval_new = count_conflicts(tmp)\n            if cval_new < best_conf:\n                s = tmp\n                s = normalize_labels(s)\n                return s, \"Recolor-Introduce-New\"\n        # Tie-breaker: least used color among best\n        if best_colors:\n            freq = Counter(s)\n            c_choice = min(best_colors, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback random recolor\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt k reduction via moving a vertex off highest color\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    moved = False\n    for v in idxs:\n        # Try to recolor v into existing colors < max_color feasibly\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # Choose color that minimally increases future conflicts (all zero here)\n            s[v - 1] = random.choice(feas)\n            moved = True\n            break\n    if moved:\n        s = normalize_labels(s)\n        return s, \"ReduceK-Reassign\"\n\n    # If cannot move any vertex: Kempe-chain swap between two colors to diversify\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: random single-vertex recolor (keeps feasibility)\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter\n\ndef perturb_solution(solution):\n    n = 9\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        return [1] * n\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Embedded graph\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    edges = [(u if u < v else v, v if u < v else u) for (u, v) in edges if u != v]\n    edges = sorted(set(edges))\n\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    s = solution[:]\n    k = max(s)\n\n    # Step 1: Random relabel swap to diversify\n    if k >= 2 and random.random() < 0.7:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Color merge-split perturbation\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a into a and new color a' greedily to reduce conflicts\n        new_color = max(s) + 1\n        # Identify conflicts within color a\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            # If v conflicts within color a, try recoloring to existing colors first\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            # Try to move to any existing color that is feasible\n            moved = False\n            for ctry in random.sample(list(range(1, max(s) + 1)), k=min(3, max(s))):\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                # Move to new color\n                s[v - 1] = new_color\n        s = normalize_labels(s)\n\n    # Step 3: Multi-vertex small random recolors\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_parties_with_exes_standard","Representacion":"INDEX_LIST length=9; contiguous labels 1..k","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Constants (embedded problem data)\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    PENALTY_INVALID = 10**6\n\n    # Structural checks\n    if not isinstance(solution, list):\n        return PENALTY_INVALID + 100_000\n    if len(solution) != n:\n        return PENALTY_INVALID + 100_000 + abs(len(solution) - n)\n    if any((not isinstance(x, int) or x < 1) for x in solution):\n        return PENALTY_INVALID + 50_000\n\n    colors = solution\n    k = max(colors) if colors else 0\n\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if colors[u - 1] == colors[v - 1]:\n            conflicts += 1\n\n    # Objective: minimize conflicts first, then k\n    score = conflicts * 1000 + k\n    return int(score)\n","Vecindad":"import random\nfrom collections import Counter, deque\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Minimal validation; fallback to DSATUR init if needed\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    # Helpers\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    def conflict_vertices(sol):\n        conf = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf.add(u); conf.add(v)\n        return conf\n\n    def count_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    k = max(s)\n    conf_set = conflict_vertices(s)\n\n    # If conflicts: DSATUR-guided min-conflicts recolor\n    if conf_set:\n        # Saturation degree among conflicting vertices\n        def sat_deg(v):\n            return len({s[u - 1] for u in adj[v]})\n        candidates = sorted(list(conf_set), key=lambda v: (sat_deg(v), len(adj[v])), reverse=True)\n        v = random.choice(candidates[:min(3, len(candidates))])\n        current_color = s[v - 1]\n        best_sol = None\n        best_conf = None\n        best_color_choices = []\n        for c in range(1, k + 1):\n            if c == current_color:\n                continue\n            tmp = s[:]\n            tmp[v - 1] = c\n            cval = count_conflicts(tmp)\n            if best_conf is None or cval < best_conf:\n                best_conf = cval\n                best_color_choices = [c]\n                best_sol = tmp\n            elif cval == best_conf:\n                best_color_choices.append(c)\n        # Optionally try introducing new color if it reduces conflicts\n        tmp_new = s[:]\n        tmp_new[v - 1] = k + 1\n        cval_new = count_conflicts(tmp_new)\n        if best_conf is None:\n            best_conf = count_conflicts(s)\n        if cval_new < best_conf:\n            s = normalize_labels(tmp_new)\n            return s, \"Recolor-Introduce-New\"\n        if best_color_choices:\n            freq = Counter(s)\n            c_choice = min(best_color_choices, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"Recolor-MinConflicts\"\n        # Fallback\n        s[v - 1] = random.randint(1, max(1, k))\n        s = normalize_labels(s)\n        return s, \"Recolor-Fallback\"\n\n    # Conflict-free: attempt to reduce max color by moving vertices off it\n    max_color = max(s)\n    idxs = [i + 1 for i, c in enumerate(s) if c == max_color]\n    random.shuffle(idxs)\n    for v in idxs:\n        feas = [c for c in range(1, max_color) if feasible_color_for(v, c, s)]\n        if feas:\n            # choose least frequent feasible color to balance\n            freq = Counter(s)\n            c_choice = min(feas, key=lambda c: (freq[c], c))\n            s[v - 1] = c_choice\n            s = normalize_labels(s)\n            return s, \"ReduceK-Reassign\"\n\n    # Kempe-chain swap between two colors\n    if max_color >= 2:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        start = random.randrange(1, n + 1)\n        target = {a, b}\n        visited = set()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            if s[u - 1] in target:\n                visited.add(u)\n                for w in adj[u]:\n                    if w not in visited and s[w - 1] in target:\n                        stack.append(w)\n        for u in visited:\n            if s[u - 1] == a:\n                s[u - 1] = b\n            elif s[u - 1] == b:\n                s[u - 1] = a\n        s = normalize_labels(s)\n        return s, \"Kempe-Chain\"\n\n    # Last resort: toggle a random vertex color within current palette\n    v = random.randrange(1, n + 1)\n    s[v - 1] = 1 if s[v - 1] != 1 else (2 if max_color >= 2 else 1)\n    s = normalize_labels(s)\n    return s, \"Recolor-LastResort\"\n","Perturbacion":"import random\nfrom collections import Counter, deque\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    n = 9\n    edges = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n\n    # Validation and fallback DSATUR init for robustness\n    def dsatur_init():\n        adj = {i: set() for i in range(1, n + 1)}\n        for (u, v) in edges:\n            adj[u].add(v); adj[v].add(u)\n        colors = [0] * n\n        uncolored = set(range(1, n + 1))\n        neighbor_colors = {i: set() for i in range(1, n + 1)}\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n            forbidden = {colors[u - 1] for u in adj[v] if colors[u - 1] > 0}\n            c = 1\n            while c in forbidden:\n                c += 1\n            colors[v - 1] = c\n            uncolored.remove(v)\n            for u in adj[v]:\n                if u in uncolored:\n                    neighbor_colors[u].add(c)\n        return colors\n\n    if (not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution)):\n        s = dsatur_init()\n    else:\n        s = solution[:]\n\n    def normalize_labels(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        return [mapping[x] for x in sol]\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].add(v); adj[v].add(u)\n\n    def feasible_color_for(v, color, sol):\n        for nb in adj[v]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    # Step 1: Random color relabel swap (diversification)\n    k = max(s)\n    if k >= 2 and random.random() < 0.8:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n\n    # Step 2: Merge-split of two color classes to create structured disruption\n    k = max(s)\n    if k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        # Merge b -> a\n        for i in range(n):\n            if s[i] == b:\n                s[i] = a\n        # Split a by resolving conflicts greedily, possibly using a new color\n        new_color = max(s) + 1\n        vertices_a = [i + 1 for i, c in enumerate(s) if c == a]\n        random.shuffle(vertices_a)\n        for v in vertices_a:\n            conflict_in_a = any(s[nb - 1] == a for nb in adj[v])\n            if not conflict_in_a:\n                continue\n            moved = False\n            palette = list(range(1, max(s) + 1))\n            random.shuffle(palette)\n            for ctry in palette:\n                if ctry != a and feasible_color_for(v, ctry, s):\n                    s[v - 1] = ctry\n                    moved = True\n                    break\n            if not moved:\n                s[v - 1] = new_color\n    \n    # Step 3: Random multi-vertex recolors (bounded)\n    s = normalize_labels(s)\n    t = max(3, min(n \/\/ 2, 5))\n    for _ in range(t):\n        i = random.randrange(n)\n        k_now = max(s)\n        if random.random() < 0.85:\n            s[i] = random.randint(1, k_now)\n        else:\n            s[i] = k_now + 1\n    s = normalize_labels(s)\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n    # Basic validation\n    if not isinstance(solution, list):\n      return PENALTY_BASE * 100\n    if len(solution) != n:\n      return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n      if not isinstance(x, int):\n        return PENALTY_BASE * 40\n      if x < 1:\n        return PENALTY_BASE * 30\n    # Count conflicts\n    conflicts = 0\n    for (u, v) in E:\n      if solution[u-1] == solution[v-1]:\n        conflicts += 1\n    # Compute colors used\n    K = 0\n    for x in solution:\n      if x > K:\n        K = x\n    if conflicts > 0:\n      # Structured penalty to rank infeasible states\n      return PENALTY_BASE + 100 * conflicts + K\n    # Feasible: objective is number of colors used\n    return K\n","Vecindad":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    # Relabel colors to 1..m in order of first occurrence to stabilize K\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef generate_neighbour(solution: Any):\n    \"\"\"\n    Neighbor operator for INDEX_LIST.\n    Movement types internally used:\n      - RECOLOR_CONFLICTED\n      - REDUCE_MAX_COLOR\n      - KEMPE_SWAP\n      - RANDOM_RECOLOR\n    Returns: new solution (INDEX_LIST)\n    \"\"\"\n    # Validate and clone\n    if not isinstance(solution, list) or any((not isinstance(x, int) or x < 1) for x in solution) or len(solution) != 9:\n        # create a simple random valid-length solution\n        sol = [random.randint(1, 3) for _ in range(9)]\n    else:\n        sol = list(solution)\n    # Normalize labels to avoid drift\n    sol = _normalize_colors(sol)\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def neighbors_of(idx: int) -> set:\n        neigh = set()\n        for (u, v) in E:\n            if u - 1 == idx:\n                neigh.add(v - 1)\n            elif v - 1 == idx:\n                neigh.add(u - 1)\n        return neigh\n\n    # Identify conflicts\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color\n    if conflicted:\n        idx = random.choice(list(conflicted))\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[idx] = c\n        return _normalize_colors(sol)\n\n    # Strategy 2: attempt to reduce K by eliminating the max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    reduced = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in neighbors_of(idx)}\n        # try assign the smallest color strictly less than max_c\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            reduced = True\n    if reduced:\n        return _normalize_colors(sol)\n\n    # Strategy 3: Kempe chain swap between two colors to enable reduction later\n    # pick two colors a,b (prefer include max color)\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a = max(colors)\n        b = random.choice([c for c in colors if c != a])\n        # pick a random vertex with color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            # BFS on induced subgraph of colors {a,b}\n            queue = [start]\n            visited = set([start])\n            while queue:\n                v = queue.pop(0)\n                for nb in neighbors_of(v):\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        queue.append(nb)\n            # swap colors a<->b on visited component\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return _normalize_colors(sol)\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in neighbors_of(idx)}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return _normalize_colors(sol)\n","Perturbacion":"import random\nfrom typing import Any\n\ndef _normalize_colors(sol: list) -> list:\n    mapping = {}\n    next_c = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        out.append(mapping[c])\n    return out\n\ndef perturb_solution(solution: Any):\n    # Strong shake: multi-vertex recolor + optional color-class swap + greedy repair\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    if not isinstance(solution, list) or len(solution) != n or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = _normalize_colors(sol)\n\n    def neighbors_of(idx: int) -> list:\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    # Step 1: random subset recolor into existing or new color\n    m = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    maxc = max(sol) if sol else 1\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap to reshuffle structure\n    colors = list(sorted(set(sol)))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_colors = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_colors:\n            c += 1\n        sol[v] = c\n\n    return _normalize_colors(sol)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Early exit on first conflict (fast infeasible ranking)\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            return PENALTY_BASE + 100  # infeasible indicator\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: fix a conflict by recoloring to smallest feasible color within [1..max_c], allow +1 only if necessary\n    if conflicted:\n        # bias: pick vertex with highest degree among conflicted\n        idx = max(conflicted, key=lambda i: len(adj[i]))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        c = 1\n        found = False\n        while c <= max_c:\n            if c not in neigh_cols:\n                sol[idx] = c\n                found = True\n                break\n            c += 1\n        if not found:\n            sol[idx] = max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Strategy 2: iterative reduction of max color class\n    max_c = max(sol) if sol else 1\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    improved = False\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        target = 1\n        while target < max_c and target in neigh_cols:\n            target += 1\n        if target < max_c and target not in neigh_cols:\n            sol[idx] = target\n            improved = True\n    if improved:\n        return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            for v in visited:\n                sol[v] = a if sol[v] == b else b\n            return normalize(sol), \"KEMPE_SWAP\"\n\n    # Strategy 4: random recolor to minimal feasible color (exploration)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    c = 1\n    while c in neigh_cols:\n        c += 1\n    sol[idx] = c\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def neighbors_of(idx):\n        res = []\n        for (u, v) in E:\n            if u - 1 == idx:\n                res.append(v - 1)\n            elif v - 1 == idx:\n                res.append(u - 1)\n        return res\n\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Step 1: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 2: random color-class swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # Step 3: greedy repair to minimal feasible colors\n    for v in range(n):\n        neigh_cols = set(sol[j] for j in neighbors_of(v))\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_student_groups_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution) -> int:\n    # Embedded graph definition\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n    n = 9\n    PENALTY_BASE = 10**6\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return PENALTY_BASE * 100\n    if len(solution) != n:\n        return PENALTY_BASE * 50 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return PENALTY_BASE * 40\n        if x < 1:\n            return PENALTY_BASE * 30\n\n    # Normalize labels to 1..m in order of first appearance\n    mapping = {}\n    next_c = 1\n    norm = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = next_c\n            next_c += 1\n        norm.append(mapping[c])\n\n    # Compute conflict count for gradient penalties\n    conflict_count = 0\n    for (u, v) in E:\n        if norm[u-1] == norm[v-1]:\n            conflict_count += 1\n\n    if conflict_count > 0:\n        return PENALTY_BASE + conflict_count\n\n    # Feasible: objective is number of colors used (bounded by n after normalization)\n    K = 0\n    for x in norm:\n        if x > K:\n            K = x\n    if K > n:\n        K = n\n    return K\n","Vecindad":"import random\nfrom collections import deque\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a tuple: (new_solution_INDEX_LIST, movement_type_str)\n    Movement types: RECOLOR_CONFLICTED, REDUCE_MAX_COLOR, KEMPE_SWAP, RANDOM_RECOLOR\n    \"\"\"\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    # Validate and clone\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    # Precompute adjacency sets\n    adj = {i: set() for i in range(n)}\n    for (u, v) in E:\n        ui, vi = u-1, v-1\n        adj[ui].add(vi)\n        adj[vi].add(ui)\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Identify conflicted vertices\n    conflicted = set()\n    for (u, v) in E:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n\n    # Strategy 1: DSATUR-biased recolor of a conflicted vertex (single change)\n    if conflicted:\n        def sat_deg(i):\n            return len({sol[j] for j in adj[i]})\n        idx = max(conflicted, key=lambda i: (sat_deg(i), len(adj[i])))\n        neigh_cols = {sol[j] for j in adj[idx]}\n        max_c = max(sol) if sol else 1\n        best_c = None\n        best_proj = None\n        for c in range(1, max_c + 2):  # allow introducing one new color if needed\n            if c in neigh_cols:\n                continue\n            trial = sol[:]\n            trial[idx] = c\n            proj = conflict_count(trial)\n            if best_proj is None or proj < best_proj or (proj == best_proj and (best_c is None or c < best_c)):\n                best_proj = proj\n                best_c = c\n        sol[idx] = best_c if best_c is not None else max_c + 1\n        return normalize(sol), \"RECOLOR_CONFLICTED\"\n\n    # Feasible region from here\n    max_c = max(sol) if sol else 1\n\n    # Strategy 2: try reducing max color by moving a single vertex to a lower feasible color\n    max_class = [i for i, c in enumerate(sol) if c == max_c]\n    random.shuffle(max_class)\n    for idx in max_class:\n        neigh_cols = {sol[j] for j in adj[idx]}\n        feasible = [c for c in range(1, max_c) if c not in neigh_cols]\n        if feasible:\n            # bias toward lower colors but randomize to avoid determinism\n            target = random.choice(feasible[:max(1, min(2, len(feasible)))])\n            sol[idx] = target\n            return normalize(sol), \"REDUCE_MAX_COLOR\"\n\n    # Strategy 3: Kempe chain swap between max color and another color; accept only if remains feasible\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            target_colors = {a, b}\n            q = deque([start])\n            visited = {start}\n            while q:\n                v = q.popleft()\n                for nb in adj[v]:\n                    if nb not in visited and sol[nb] in target_colors:\n                        visited.add(nb)\n                        q.append(nb)\n            trial = sol[:]\n            for v in visited:\n                trial[v] = a if sol[v] == b else b\n            # accept only if feasible remains\n            if conflict_count(trial) == 0:\n                return normalize(trial), \"KEMPE_SWAP\"\n\n    # Strategy 4: random feasible recolor of a random vertex (single change)\n    idx = random.randrange(n)\n    neigh_cols = {sol[j] for j in adj[idx]}\n    feasible = [c for c in range(1, max_c + 1) if c not in neigh_cols]\n    if not feasible:\n        feasible = [max_c + 1]\n    # bias to smaller labels\n    feasible.sort()\n    pick_pool = feasible[:max(1, min(2, len(feasible)))]\n    sol[idx] = random.choice(pick_pool)\n    return normalize(sol), \"RANDOM_RECOLOR\"\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Problem data\n    n = 9\n    E = [(1,4),(1,6),(1,8),(2,3),(2,6),(2,7),(2,8),(2,9),(3,5),(3,6),(3,7),(3,9),(4,5),(4,6),(4,7),(5,6),(5,8),(7,8)]\n\n    def normalize(sol):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def adj_list():\n        adj = {i: set() for i in range(n)}\n        for (u, v) in E:\n            ui, vi = u-1, v-1\n            adj[ui].add(vi)\n            adj[vi].add(ui)\n        return adj\n\n    def conflict_count(sol_local):\n        cnt = 0\n        for (u, v) in E:\n            if sol_local[u-1] == sol_local[v-1]:\n                cnt += 1\n        return cnt\n\n    # Initialize\/validate\n    if (not isinstance(solution, list)) or (len(solution) != n) or any((not isinstance(x, int) or x < 1) for x in solution):\n        sol = [random.randint(1, 3) for _ in range(n)]\n    else:\n        sol = list(solution)\n    sol = normalize(sol)\n\n    adj = adj_list()\n\n    # Step 1: t random Kempe-like swaps focused on max color class to diversify\n    t = 2\n    for _ in range(t):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            break\n        a = max(colors)\n        b_choices = [c for c in colors if c != a]\n        b = random.choice(b_choices)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            continue\n        start = random.choice(candidates)\n        target_colors = {a, b}\n        q = deque([start])\n        visited = {start}\n        while q:\n            v = q.popleft()\n            for nb in adj[v]:\n                if nb not in visited and sol[nb] in target_colors:\n                    visited.add(nb)\n                    q.append(nb)\n        for v in visited:\n            sol[v] = a if sol[v] == b else b\n\n    # Step 2: random subset recolor within current palette + optional new color\n    maxc = max(sol) if sol else 1\n    m = max(3, n \/\/ 3)\n    idxs = random.sample(range(n), m)\n    for i in idxs:\n        sol[i] = random.randint(1, maxc + 1)\n\n    # Step 3: greedy repair to minimal feasible colors to restore feasibility\n    for v in range(n):\n        neigh_cols = {sol[j] for j in adj[v]}\n        c = 1\n        while c in neigh_cols:\n            c += 1\n        sol[v] = c\n\n    return normalize(sol)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST length=9; solution[i-1] is the color (positive int starting at 1) assigned to vertex i. Colors may be relabeled to maintain compact palette 1..k.","Evaluacion":"import math\n\ndef evaluate_solution(solution: list):\n    # Graph coloring: return number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a new neighboring solution (list of ints). Heuristic: conflict repair then color reduction.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n    cur = list(solution)\n    cur = compact_palette(cur)\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    if conflicts:\n        # Repair a conflicting vertex with highest degree first\n        v = max(conflicts, key=lambda x: (len(adj[x]), random.random()))\n        feas = feasible_colors(cur, v)\n        if feas:\n            # Prefer existing colors <= k, smallest first\n            feas.sort(key=lambda c: (c > k, c))\n            # Avoid current color if possible\n            candidates = [c for c in feas if c != cur[v-1]] or feas\n            cur[v-1] = candidates[0]\n        else:\n            cur[v-1] = k + 1\n        return compact_palette(cur)\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        return cur\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try multiple vertices from highest class\n    tried = 0\n    for v in class_vertices:\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != cur[v-1]]\n        if reduc:\n            cur[v-1] = min(reduc)\n            cur = compact_palette(cur)\n            return cur\n        tried += 1\n        if tried >= 3:\n            break\n\n    # If reduction failed, perform a mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != cur[v-1]]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    return compact_palette(cur)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger diversification: recolor a subset; may enable future color reduction. Palette is compacted at end.\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols, v):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    p = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), p)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        # Prefer changing color; slight chance to pick a higher\/new color to escape plateaus\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choices = alternatives or feas\n        cur[v-1] = random.choice(choices)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9, 1-based colors. solution[i-1] is the color of vertex i. Colors are positive integers; palette compacted to 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Returns number of colors if feasible; else float('inf')\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import Tuple, Dict, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution, move_metadata)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        # Return same type with metadata indicating invalid input handled\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Detect conflicts\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur)}\n\n    if conflicts:\n        # Select conflicting vertex with max saturation degree (DSATUR heuristic), tie-break by degree then random\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        if feas:\n            feas.sort()\n            # Prefer existing colors <= k and not equal to current color\n            feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n            cur[v-1] = feas_pref[0]\n        else:\n            cur[v-1] = k + 1\n        new_cur, post_map = compact_palette(cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur)\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction via highest color class move\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\"})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try recoloring up to 3 vertices from highest class to a lower feasible color\n    for v in class_vertices[:min(3, len(class_vertices))]:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            cur[v-1] = new_color\n            new_cur, post_map = compact_palette(cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur)\n            })\n            return new_cur, meta\n\n    # Mild diversification: recolor a random vertex to an alternative feasible color\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt = [c for c in feas if c != old]\n    if alt:\n        cur[v-1] = random.choice(alt)\n    new_cur, post_map = compact_palette(cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur)\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification: recolor t random vertices; compact palette after\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alternatives = [c for c in feas if c != cur[v-1]]\n        choice_pool = alternatives or feas\n        cur[v-1] = random.choice(choice_pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_taekwondo_tournament_standard","Representacion":"INDEX_LIST: list[int] of length 9; solution[i-1] is the 1-based color assigned to vertex i. Colors are positive integers with a compact palette 1..k.","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    # Graph Coloring evaluator: returns number of colors if feasible; else +inf\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    if not isinstance(solution, list) or len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Feasibility check: adjacent vertices must differ\n    for (u, v) in E:\n        if solution[u-1] == solution[v-1]:\n            return float('inf')\n    # Cost = number of colors used\n    return len(set(solution))\n","Vecindad":"import random\nimport math\nfrom typing import List, Dict, Tuple\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution: List[int], move_metadata: Dict)\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]):\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols], mapping\n\n    def num_conflicts(cols: List[int]) -> int:\n        c = 0\n        for (u, v) in E:\n            if cols[u-1] == cols[v-1]:\n                c += 1\n        return c\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap at k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        # BFS on subgraph induced by colors {a,b} starting from v; swap a<->b on that component\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        new_cols = cols[:]\n        for x in comp:\n            new_cols[x-1] = a if cols[x-1] == b else b\n        return new_cols\n\n    # Validate and normalize input\n    if not isinstance(solution, list) or len(solution) != n:\n        fixed = list(solution) if isinstance(solution, list) else []\n        return fixed, {\"type\": \"invalid_input\", \"note\": \"returned_copy_or_empty\"}\n\n    cur, pre_map = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Conflict set\n    conflicts = set()\n    for (u, v) in E:\n        if cur[u-1] == cur[v-1]:\n            conflicts.add(u)\n            conflicts.add(v)\n\n    meta: Dict[str, object] = {\"pre_palette_map\": pre_map, \"pre_solution\": tuple(cur), \"pre_conflicts\": num_conflicts(cur)}\n\n    if conflicts:\n        # DSATUR-based repair with optional Kempe-chain\n        def sat_deg(vertex: int) -> int:\n            return len({cur[nbr-1] for nbr in adj[vertex]})\n        v = max(conflicts, key=lambda x: (sat_deg(x), len(adj[x]), random.random()))\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        # Prefer colors <= k, avoid old if possible\n        feas_pref = [c for c in feas if c <= k and c != old] or [c for c in feas if c != old] or feas\n        new_cur = cur[:]\n        if feas_pref:\n            new_cur[v-1] = feas_pref[0]\n        else:\n            new_cur[v-1] = k + 1\n        # If still conflicting, try a Kempe-chain swap between old and chosen color\n        if num_conflicts(new_cur) >= num_conflicts(cur):\n            # pick neighbor color to swap with\n            neigh_colors = list({cur[nbr-1] for nbr in adj[v] if cur[nbr-1] != old}) or [((old % k) + 1) if k >= 1 else 1]\n            b = random.choice(neigh_colors)\n            a = old if old != b else ((b % max(k, 1)) + 1)\n            new_cur = kempe_chain_recolor(cur, v, a, b)\n        new_cur, post_map = compact_palette(new_cur)\n        meta.update({\n            \"type\": \"repair\",\n            \"vertex\": v,\n            \"old\": old,\n            \"new\": new_cur[v-1],\n            \"post_palette_map\": post_map,\n            \"post_solution\": tuple(new_cur),\n            \"post_conflicts\": num_conflicts(new_cur),\n            \"delta_colors\": len(set(new_cur)) - len(set(cur))\n        })\n        return new_cur, meta\n\n    # No conflicts: attempt color reduction from highest color class\n    colors_used = sorted(set(cur))\n    if len(colors_used) <= 1:\n        meta.update({\"type\": \"idle\", \"reason\": \"single_color\", \"post_conflicts\": 0, \"delta_colors\": 0})\n        return cur, meta\n\n    highest = colors_used[-1]\n    class_vertices = [i for i, c in enumerate(cur, start=1) if c == highest]\n    random.shuffle(class_vertices)\n\n    # Try all vertices in the highest class for reduction; exit on first success\n    for v in class_vertices:\n        old = cur[v-1]\n        feas = feasible_colors(cur, v)\n        reduc = [c for c in feas if c < highest and c != old]\n        if reduc:\n            new_color = min(reduc)\n            new_cur = cur[:]\n            new_cur[v-1] = new_color\n            new_cur, post_map = compact_palette(new_cur)\n            meta.update({\n                \"type\": \"reduce\",\n                \"vertex\": v,\n                \"old\": old,\n                \"new\": new_cur[v-1],\n                \"post_palette_map\": post_map,\n                \"post_solution\": tuple(new_cur),\n                \"post_conflicts\": num_conflicts(new_cur),\n                \"delta_colors\": len(set(new_cur)) - len(set(cur))\n            })\n            return new_cur, meta\n\n    # Diversification: recolor a random vertex to an alternative color (prefer <= k)\n    v = random.randint(1, n)\n    old = cur[v-1]\n    feas = feasible_colors(cur, v)\n    alt_existing = [c for c in feas if c != old and c <= k]\n    choice_pool = alt_existing or [c for c in feas if c != old] or feas\n    new_cur = cur[:]\n    new_cur[v-1] = random.choice(choice_pool)\n    new_cur, post_map = compact_palette(new_cur)\n    meta.update({\n        \"type\": \"diversify\",\n        \"vertex\": v,\n        \"old\": old,\n        \"new\": new_cur[v-1],\n        \"post_palette_map\": post_map,\n        \"post_solution\": tuple(new_cur),\n        \"post_conflicts\": num_conflicts(new_cur),\n        \"delta_colors\": len(set(new_cur)) - len(set(cur))\n    })\n    return new_cur, meta\n","Perturbacion":"import random\nimport math\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Strong diversification via multi-step Kempe-chain swaps and random recolors\n    n = 9\n    E = [\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in E:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def compact_palette(cols: List[int]) -> List[int]:\n        mapping = {c: i+1 for i, c in enumerate(sorted(set(cols)))}\n        return [mapping[c] for c in cols]\n\n    def feasible_colors(cols: List[int], v: int):\n        forb = {cols[u-1] for u in adj[v]}\n        k = max(cols) if cols else 1\n        limit = max(k, 1) + 1  # cap to at most k+1\n        return [c for c in range(1, limit+1) if c not in forb]\n\n    def kempe_chain_recolor(cols: List[int], v: int, a: int, b: int) -> List[int]:\n        if cols[v-1] not in (a, b):\n            return cols[:]\n        target_colors = {a, b}\n        visited = set()\n        stack = [v]\n        comp = []\n        while stack:\n            x = stack.pop()\n            if x in visited:\n                continue\n            visited.add(x)\n            if cols[x-1] in target_colors:\n                comp.append(x)\n                for y in adj[x]:\n                    if cols[y-1] in target_colors and y not in visited:\n                        stack.append(y)\n        out = cols[:]\n        for x in comp:\n            out[x-1] = a if cols[x-1] == b else b\n        return out\n\n    if not isinstance(solution, list) or len(solution) != n:\n        return list(solution) if isinstance(solution, list) else []\n\n    cur = compact_palette(list(solution))\n    k = max(cur) if cur else 1\n\n    # Perform p Kempe swaps on random vertices\n    p = random.randint(2, 4)\n    for _ in range(p):\n        v = random.randint(1, n)\n        # choose a neighbor color if possible, else random existing color\n        neigh_cols = list({cur[u-1] for u in adj[v] if cur[u-1] != cur[v-1]})\n        if not neigh_cols:\n            neigh_cols = list(set(cur))\n        if not neigh_cols:\n            continue\n        b = random.choice(neigh_cols)\n        a = cur[v-1]\n        if a == b:\n            continue\n        cur = kempe_chain_recolor(cur, v, a, b)\n\n    # Then randomly recolor t vertices (favor existing colors)\n    t = random.randint(2, 4)\n    idxs = random.sample(range(1, n+1), t)\n    for v in idxs:\n        feas = feasible_colors(cur, v)\n        if not feas:\n            cur[v-1] = k + 1\n            k = max(k, cur[v-1])\n            continue\n        alt_existing = [c for c in feas if c != cur[v-1] and c <= k]\n        pool = alt_existing or [c for c in feas if c != cur[v-1]] or feas\n        cur[v-1] = random.choice(pool)\n        k = max(k, cur[v-1])\n\n    return compact_palette(cur)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Basic validation\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n    # Compute max color (k)\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    # Degrees for structure-aware penalties\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Count violations and weighted conflict measure\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    lb = 3\n    if violations > 0:\n        # Large base + structure-aware gradient; lower is better\n        return 1_000_000 + 1000 * conflict_weight + 10 * k + violations\n    # Enforce known lower bound if labels produce k < lb\n    if k < lb:\n        return 100_000 + (lb - k) * 10_000\n    # Canonicalize labels to remove permutation bias\n    mapping = {}\n    nextc = 1\n    canon = []\n    for c in solution:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        canon.append(mapping[c])\n    kcanon = 0\n    ssum = 0\n    for c in canon:\n        ssum += c\n        if c > kcanon:\n            kcanon = c\n    # Primary objective on k, tie-break by compact label sum\n    return kcanon * 10_000 + ssum\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (new_solution_list, move_tag)\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_swap(sol, start_node, c1, c2):\n        # Swap colors c1<->c2 on the Kempe chain component containing start_node\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    def try_k_reduction(sol):\n        # Attempt to eliminate the highest color by recoloring its nodes\n        sol = sol[:]\n        k = max(sol)\n        if k <= 1:\n            return sol, False\n        targets = [i + 1 for i, c in enumerate(sol) if c == k]\n        random.shuffle(targets)\n        for node in targets:\n            # Try to assign the smallest feasible color in 1..k-1\n            new_c = lowest_feasible(node, sol, k - 1)\n            if new_c is None:\n                # Try Kempe-based escape with a random color among 1..k-1\n                pool = list(range(1, k))\n                random.shuffle(pool)\n                moved = False\n                for c2 in pool:\n                    if c2 == sol[node - 1]:\n                        continue\n                    candidate = kempe_swap(sol, node, k, c2)\n                    new_c2 = lowest_feasible(node, candidate, k - 1)\n                    if new_c2 is not None:\n                        candidate[node - 1] = new_c2\n                        sol = candidate\n                        moved = True\n                        break\n                if not moved:\n                    return sol, False\n            else:\n                sol[node - 1] = new_c\n        # If all reassigned, relabel to remove gaps\n        sol = canonize(sol)\n        return sol, True\n\n    # Initialize\/repair input\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    if r < 0.35:\n        # Conflict-directed recolor (or general recolor if no conflicts)\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        current_max = max(sol)\n        # Prefer colors within current range; occasionally allow +1 if currently feasible\n        allow_new = (viols == 0 and random.random() < 0.1)\n        upper = current_max + 1 if allow_new else current_max\n        upper = max(3, upper)\n        # Try lowest feasible first to bias towards feasibility\n        new_c = lowest_feasible(node, sol, upper)\n        if new_c is None:\n            # fallback random color\n            new_c = random.randint(1, upper)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % upper) + 1\n        new_sol = sol[:]\n        new_sol[node - 1] = new_c\n        return canonize(new_sol), \"Recolor-CD\"\n    elif r < 0.6:\n        # Color-label swap\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return canonize(new_sol), \"Swap-Labels\"\n    elif r < 0.85:\n        # Kempe-chain swap around a random node and random color pair present\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(3, k)) + 1\n            return canonize(new_sol), \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        new_sol = kempe_swap(sol, node, c1, c2)\n        return canonize(new_sol), \"Kempe-Swap\"\n    else:\n        # Targeted k-reduction attempt\n        new_sol, ok = try_k_reduction(sol)\n        tag = \"K-Reduce-Success\" if ok else \"K-Reduce-Attempt\"\n        return canonize(new_sol), tag\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-step randomized perturbation combining recolors and Kempe swaps\n    n = 9\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def canonize(sol):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in sol:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    if not valid_input(solution):\n        sol = [1, 1, 2, 2, 1, 3, 3, 2, 3]\n    else:\n        sol = solution[:]\n\n    steps = random.randint(3, 7)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # random recolor within current range +\/- 1\n            idx = random.randrange(1, n + 1)\n            k = max(sol)\n            upper = max(3, k + (1 if random.random() < 0.2 else 0))\n            new_c = random.randint(1, upper)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % upper) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # label swap of two random colors present\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap using two random colors from present set\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        # maintain canonical labeling after each sub-move\n        sol = canonize(sol)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"LIST_LEN9_POSINTS_COLORS_1_TO_K","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> int:\n    # Embedded problem data (no globals)\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n    # Validate\n    if not isinstance(solution, list) or len(solution) != n:\n        return 1_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 1_000_000\n    # Compute k and degrees\n    k = 0\n    for x in solution:\n        if x > k:\n            k = x\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        deg[u] += 1\n        deg[v] += 1\n    # Violations and conflict weight\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n    # Scoring\n    if violations > 0:\n        base = 100_000\n        alpha = 2_000  # per conflicting edge\n        beta = 3       # structure-aware gradient\n        return base + alpha * violations + beta * conflict_weight + k\n    # Feasible: primary = minimize k; secondary deterministic tie-break by class sizes\n    # Count color class sizes irrespective of labels\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    sizes = sorted(counts.values(), reverse=True)\n    s1 = sizes[0] if len(sizes) > 0 else 0\n    s2 = sizes[1] if len(sizes) > 1 else 0\n    # Prefer larger leading classes (more compact usage) deterministically\n    secondary = (100 - s1) * 100 + (100 - s2)\n    return k * 10_000 + secondary\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data and precomputations scoped locally (no globals)\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol: List[int]):\n        conf_nodes = set()\n        count = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n                count += 1\n        return count, conf_nodes\n\n    def feasible_color(node: int, color: int, sol: List[int]) -> bool:\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node: int, sol: List[int], max_color: int):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n\n    k = max(sol)\n    viols, conf_nodes = conflicts(sol)\n\n    r = random.random()\n    # 1) Conflict-directed recolor (no k increase when currently feasible)\n    if r < 0.4:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a node with highest degree bias\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, k)\n        if new_c is None:\n            # fallback: random color in 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"Recolor-CD\"\n    # 2) Kempe-chain swap using two present colors\n    elif r < 0.75:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        c1, c2 = random.sample(colors_present, 2)\n        node = random.randrange(1, n + 1)\n        # Build Kempe component and swap\n        stack = [node]\n        visited = set()\n        component = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                component.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in component:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n    # 3) Label swap of two colors present (diversification without changing feasibility)\n    else:\n        colors_present = list(set(sol))\n        if len(colors_present) >= 2:\n            c1, c2 = random.sample(colors_present, 2)\n            mapping = {c1: c2, c2: c1}\n            new_sol = [mapping.get(x, x) for x in sol]\n            return new_sol, \"Swap-Labels\"\n        # Fallback single recolor\n        node = random.randrange(1, n + 1)\n        new_sol = sol[:]\n        new_sol[node - 1] = ((sol[node - 1] - 1 + 1) % max(1, k)) + 1\n        return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\nfrom typing import List, Tuple\n\ndef perturb_solution(solution: List[int]):\n    # Embedded problem data\n    n = 9\n    edges: Tuple[Tuple[int, int], ...] = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol: List[int]) -> bool:\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol: List[int], start_node: int, c1: int, c2: int) -> List[int]:\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair and lock k to current max to avoid unnecessary expansion\n    if not valid_input(solution):\n        sol = [1,2,3,2,1,3,3,2,3]\n    else:\n        sol = solution[:]\n    k = max(sol)\n\n    steps = random.randint(3, 6)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.5:\n            # random recolor within 1..k (k-preserving)\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.75:\n            # color label swap for diversification\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n        else:\n            # Kempe swap between two present colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_11_textbook_standard","Representacion":"List of length 9 with positive integers as color labels, e.g., [c1,c2,c3,c4,c5,c6,c7,c8,c9] where ci>=1.","Evaluacion":"import random\n\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != n:\n        return 10_000_000\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return 10_000_000\n\n    # Build adjacency and degrees (local scope)\n    adj = {i: [] for i in range(1, n + 1)}\n    deg = [0] * (n + 1)\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n\n    # Count violations\n    violations = 0\n    conflict_weight = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            violations += 1\n            conflict_weight += deg[u] + deg[v]\n\n    if violations > 0:\n        # Infeasible: make score strictly worse than any feasible\n        base = 20_000_000\n        alpha = 50_000\n        beta = 100\n        return base + alpha * violations + beta * conflict_weight + max(solution)\n\n    # Feasible: primary objective = minimize number of colors actually used\n    colors_present = {}\n    for c in solution:\n        colors_present[c] = 1\n    k = len(colors_present)\n\n    # Secondary: encourage balanced\/mergeable classes via larger min class size\n    counts = {}\n    for c in solution:\n        counts[c] = counts.get(c, 0) + 1\n    min_class_size = min(counts.values()) if counts else 0\n\n    secondary = 1000 - min_class_size\n    return k * 1_000_000 + secondary\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency (local)\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def conflicts(sol):\n        conf_nodes = set()\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                conf_nodes.add(u)\n                conf_nodes.add(v)\n        return conf_nodes\n\n    def feasible_color(node, color, sol):\n        for nb in adj[node]:\n            if sol[nb - 1] == color:\n                return False\n        return True\n\n    def lowest_feasible(node, sol, max_color):\n        for c in range(1, max_color + 1):\n            if feasible_color(node, c, sol):\n                return c\n        return None\n\n    def kempe_component(sol, start, c1, c2):\n        stack = [start]\n        visited = set()\n        comp = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                comp.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        return comp\n\n    # Prepare working copy\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k (symmetry reduction, stable k tracking)\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n    conf_nodes = conflicts(sol)\n\n    r = random.random()\n\n    # 0) Targeted color-drop attempt on highest label\n    if r < 0.2 and k > 1:\n        target_color = k\n        vertices = [i for i in range(1, n + 1) if sol[i - 1] == target_color]\n        new_sol = sol[:]\n        possible = True\n        for v in vertices:\n            # try greedy recolor into 1..k-1\n            recol = None\n            for c in range(1, k):\n                if feasible_color(v, c, new_sol):\n                    recol = c\n                    break\n            if recol is None:\n                possible = False\n                break\n            new_sol[v - 1] = recol\n        if possible:\n            # remove unused highest label -> reduce k\n            return new_sol, \"Color-Drop\"\n        # fallthrough to other moves if drop fails\n\n    # 1) Conflict-directed recolor\n    if r < 0.55:\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            # pick a high-degree node to perturb\n            node = max(range(1, n + 1), key=lambda u: len(adj[u]))\n        new_sol = sol[:]\n        new_c = lowest_feasible(node, sol, max(1, k))\n        if new_c is None:\n            # fallback random different color within 1..k\n            new_c = random.randint(1, k)\n            if new_c == sol[node - 1]:\n                new_c = (new_c % k) + 1\n        new_sol[node - 1] = new_c\n        return new_sol, \"CD-Recolor\"\n\n    # 2) Kempe-chain swap using two present colors (conflict-guided when possible)\n    if r < 0.85:\n        colors_present = list(set(sol))\n        if len(colors_present) < 2:\n            node = random.randrange(1, n + 1)\n            new_sol = sol[:]\n            new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n            return new_sol, \"Recolor-1\"\n        if conf_nodes:\n            node = random.choice(list(conf_nodes))\n        else:\n            node = random.randrange(1, n + 1)\n        c1, c2 = random.sample(colors_present, 2)\n        comp = kempe_component(sol, node, c1, c2)\n        new_sol = sol[:]\n        for u in comp:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol, \"Kempe-Swap\"\n\n    # 3) Label swap (diversification, symmetry move)\n    colors_present = list(set(sol))\n    if len(colors_present) >= 2:\n        c1, c2 = random.sample(colors_present, 2)\n        mapping = {c1: c2, c2: c1}\n        new_sol = [mapping.get(x, x) for x in sol]\n        return new_sol, \"Label-Swap\"\n\n    # Fallback single-node recolor\n    node = random.randrange(1, n + 1)\n    new_sol = sol[:]\n    new_sol[node - 1] = ((sol[node - 1]) % max(1, k)) + 1\n    return new_sol, \"Recolor-1\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    edges = (\n        (1,4),(1,6),(1,8),\n        (2,3),(2,6),(2,7),(2,8),(2,9),\n        (3,5),(3,6),(3,7),(3,9),\n        (4,5),(4,6),(4,7),\n        (5,6),(5,8),\n        (7,8)\n    )\n    n = 9\n\n    # Build adjacency\n    adj = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def valid_input(sol):\n        if not isinstance(sol, list) or len(sol) != n:\n            return False\n        for x in sol:\n            if not isinstance(x, int) or x < 1:\n                return False\n        return True\n\n    def kempe_swap(sol, start_node, c1, c2):\n        if sol[start_node - 1] not in (c1, c2):\n            return sol[:]\n        visited = set()\n        stack = [start_node]\n        chain_nodes = []\n        while stack:\n            u = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            if sol[u - 1] in (c1, c2):\n                chain_nodes.append(u)\n                for w in adj[u]:\n                    if w not in visited and sol[w - 1] in (c1, c2):\n                        stack.append(w)\n        new_sol = sol[:]\n        for u in chain_nodes:\n            new_sol[u - 1] = c2 if sol[u - 1] == c1 else c1\n        return new_sol\n\n    # Initialize\/repair\n    if not valid_input(solution):\n        sol = [1,2,3,3,2,1,1,3,1]\n    else:\n        sol = solution[:]\n\n    # Normalize labels to 1..k\n    remap = {}\n    next_label = 1\n    for x in sol:\n        if x not in remap:\n            remap[x] = next_label\n            next_label += 1\n    sol = [remap[x] for x in sol]\n\n    k = max(sol)\n\n    steps = random.randint(4, 8)\n    for _ in range(steps):\n        move = random.random()\n        if move < 0.4:\n            # multiple random recolors within current palette\n            idx = random.randrange(1, n + 1)\n            new_c = random.randint(1, k)\n            if new_c == sol[idx - 1]:\n                new_c = (new_c % k) + 1\n            sol[idx - 1] = new_c\n        elif move < 0.7:\n            # Kempe-chain kick\n            colors_present = list(set(sol))\n            if len(colors_present) >= 2:\n                c1, c2 = random.sample(colors_present, 2)\n                node = random.randrange(1, n + 1)\n                sol = kempe_swap(sol, node, c1, c2)\n        else:\n            # Color label cycle among up to 3 colors\n            colors_present = list(set(sol))\n            if len(colors_present) >= 3:\n                c1, c2, c3 = random.sample(colors_present, 3)\n                mapping = {c1: c2, c2: c3, c3: c1}\n                sol = [mapping.get(x, x) for x in sol]\n            elif len(colors_present) == 2:\n                c1, c2 = colors_present\n                mapping = {c1: c2, c2: c1}\n                sol = [mapping.get(x, x) for x in sol]\n\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    # Self-contained evaluator with canonical relabeling and strict length handling\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n    Eset = set((a,b) if a < b else (b,a) for (a,b) in edges)\n\n    # Robust repair to exact length n with positive integers\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    colors_raw = repair_to_length_n(solution)\n\n    # Canonical relabeling to consecutive 1..k preserving first-appearance order\n    mapping = {}\n    next_label = 1\n    colors = []\n    for x in colors_raw:\n        if x not in mapping:\n            mapping[x] = next_label\n            next_label += 1\n        colors.append(mapping[x])\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    sum_conflicts = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    # Internal helpers and embedded graph\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def distinct_colors(colors):\n        return sorted(set(colors))\n\n    def min_conflict_color(colors, idx):\n        # Try existing colors plus possibly a new color (max+1)\n        current_set = set(colors)\n        max_c = max(current_set) if current_set else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = 10**9\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            # Score by (violations, local conflicts at idx, k)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = repair(solution)\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex\n        worst = max(range(n), key=lambda i: (deg[i], random.random()))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            # fallback: random recolor among expanded palette\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return nb, (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (try to reduce k)\n        color_list = distinct_colors(colors)\n        if len(color_list) <= 1:\n            # nothing to do; small random tweak\n            idx = random.randrange(n)\n            max_c = max(colors)\n            new_c = random.randint(1, max_c)\n            if new_c == colors[idx]:\n                new_c = max_c if colors[idx] != max_c else 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return nb, (\"Diversify\", \"RandomTweak\")\n        # pick a candidate color class to eliminate\n        target = random.choice(color_list)\n        if len(color_list) >= 2:\n            other_colors = [c for c in color_list if c != target]\n        else:\n            other_colors = color_list\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            # choose best color among existing other colors\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return nb, (\"Intensify\", \"ColorClassElimination\")\n        # Otherwise perform a color-class swap to diversify\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return nb, (\"Diversify\", \"SwapColorClasses\")\n        # Fallback\n        idx = random.randrange(n)\n        return colors, (\"NoOp\", \"Stable\")","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-move random shake combining recolors and occasional color-class swap\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = repair(solution)\n    steps = 5  # moderate intensity\n    for t in range(steps):\n        if random.random() < 0.25 and len(set(pert)) >= 2:\n            # color-class swap\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n    # Optional quick repair if became highly infeasible: one greedy pass\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n    return pert","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    k = max(colors) if colors else 0\n\n    # Count edge violations and sum of endpoint-conflicts (tie-breaker)\n    violations = 0\n    conflict_deg = [0]*n\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    sum_conflicts = sum(conflict_deg)\n\n    # Lexicographic fitness via large scaling: prioritize feasibility -> minimize k -> minimize residual conflicts\n    fitness = violations * 1_000_000 + k * 1_000 + sum_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        conflict_deg = [0]*n\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                conflict_deg[u-1] += 1\n                conflict_deg[v-1] += 1\n        return viol, conflict_deg\n\n    def min_conflict_color(colors, idx):\n        curset = sorted(set(colors))\n        max_c = curset[-1] if curset else 1\n        candidates = list(range(1, max_c+1)) + [max_c+1]\n        best_c = colors[idx]\n        best_score = (10**9, 10**9, 10**9)\n        for c in candidates:\n            if c == colors[idx] and len(candidates) > 1:\n                continue\n            tmp = colors[:]\n            tmp[idx] = c\n            viol, deg = conflicts(tmp)\n            k_tmp = len(set(tmp))\n            score = (viol, deg[idx], k_tmp)\n            if score < best_score:\n                best_score = score\n                best_c = c\n        return best_c\n\n    colors = canonicalize(repair(solution))\n    viol, deg = conflicts(colors)\n\n    if viol > 0:\n        # Conflict-directed min-conflicts recolor on worst vertex (deterministic tie-break)\n        worst = max(range(n), key=lambda i: (deg[i], i))\n        new_c = min_conflict_color(colors, worst)\n        if new_c == colors[worst]:\n            max_c = max(colors)\n            cand = list(range(1, max_c+2))\n            if colors[worst] in cand and len(cand) > 1:\n                cand.remove(colors[worst])\n            new_c = random.choice(cand)\n        nb = colors[:]\n        nb[worst] = new_c\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt targeted color-killing (reduce k)\n        color_list = sorted(set(colors))\n        if len(color_list) <= 1:\n            idx = 0\n            max_c = max(colors)\n            new_c = 1 if max_c == 1 else max_c\n            if new_c == colors[idx]:\n                new_c = 1\n            nb = colors[:]\n            nb[idx] = new_c\n            return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n        target = random.choice(color_list)\n        other_colors = [c for c in color_list if c != target]\n        nb = colors[:]\n        movable = [i for i,c in enumerate(nb) if c == target]\n        success = True\n        for i in movable:\n            best_c = None\n            best_score = (10**9, 10**9)\n            for c in other_colors:\n                tmp = nb[:]\n                tmp[i] = c\n                v, d = conflicts(tmp)\n                score = (v, d[i])\n                if score < best_score:\n                    best_score = score\n                    best_c = c\n            if best_c is None:\n                success = False\n                break\n            nb[i] = best_c\n        v_after, _ = conflicts(nb)\n        if success and v_after == 0 and len(set(nb)) < len(set(colors)):\n            return canonicalize(nb), (\"Intensify\", \"ColorClassElimination\")\n        if len(color_list) >= 2:\n            a, b = random.sample(color_list, 2)\n            nb = [b if c==a else a if c==b else c for c in colors]\n            return canonicalize(nb), (\"Diversify\", \"SwapColorClasses\")\n        return colors, (\"NoOp\", \"Stable\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts(colors):\n        viol = 0\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n        return viol\n\n    pert = canonicalize(repair(solution))\n    steps = 5\n    for _ in range(steps):\n        if random.random() < 0.3 and len(set(pert)) >= 2:\n            a, b = random.sample(sorted(set(pert)), 2)\n            pert = [b if c==a else a if c==b else c for c in pert]\n        else:\n            idx = random.randrange(n)\n            max_c = max(pert) if pert else 1\n            cand = list(range(1, max_c+2))\n            if len(cand) > 1 and pert[idx] in cand:\n                cand.remove(pert[idx])\n            pert[idx] = random.choice(cand)\n        pert = canonicalize(pert)\n    if conflicts(pert) > 0:\n        for i in range(n):\n            max_c = max(pert)\n            best = pert[i]\n            best_v = 10**9\n            for c in list(range(1, max_c+1)) + [max_c+1]:\n                if c == pert[i]:\n                    continue\n                tmp = pert[:]\n                tmp[i] = c\n                v = 0\n                for (u,vv) in edges:\n                    if tmp[u-1] == tmp[vv-1]:\n                        v += 1\n                if v < best_v:\n                    best_v = v\n                    best = c\n            pert[i] = best\n        pert = canonicalize(pert)\n    return pert\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_parties_with_exes_standard","Representacion":"LIST_INT_LEN9_POSITIVE_INTS","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Graph definition (1-indexed)\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    def repair_to_length_n(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    colors_raw = repair_to_length_n(solution)\n    colors = canonicalize(colors_raw)\n    if not colors:\n        return 10**12\n    k = max(colors)\n\n    # Count edge violations and per-vertex conflict degrees\n    conflict_deg = [0]*n\n    violations = 0\n    for (u,v) in edges:\n        if colors[u-1] == colors[v-1]:\n            violations += 1\n            conflict_deg[u-1] += 1\n            conflict_deg[v-1] += 1\n\n    # Stronger tie-breaker: sum of squared conflict degrees\n    weighted_conflicts = sum(d*d for d in conflict_deg)\n\n    # Lexicographic fitness: feasibility -> minimize k -> minimize conflict structure\n    fitness = violations * 1_000_000 + k * 1_000 + weighted_conflicts\n    return fitness\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Returns: (neighbor_solution, (\"NB_Type\", \"Movement_Type\"))\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    # Build adjacency list for efficient local checks\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def conflicts_and_deg(colors):\n        viol = 0\n        deg = [0]*n\n        for (u,v) in edges:\n            if colors[u-1] == colors[v-1]:\n                viol += 1\n                deg[u-1] += 1\n                deg[v-1] += 1\n        return viol, deg\n\n    def saturation_degree(colors, i):\n        return len({colors[j] for j in adj[i]})\n\n    def min_conflict_color_repair(colors, i):\n        # restrict to existing colors only in infeasible phase\n        palette = sorted(set(colors))\n        best_c = colors[i]\n        best_tuple = (10**9, 10**9, 10**9)\n        for c in palette:\n            if c == colors[i] and len(palette) > 1:\n                continue\n            tmp_c = colors[i]\n            # delta evaluate: count conflicts at i only\n            viol_i = 0\n            for nb in adj[i]:\n                if colors[nb] == c:\n                    viol_i += 1\n            # tie-break by neighbor availability: prefer colors that reduce conflicts and increase neighbor diversity\n            k_tmp = len(set(colors))\n            score = (viol_i, -saturation_degree(colors, i), k_tmp)\n            if score < best_tuple:\n                best_tuple = score\n                best_c = c\n        return best_c\n\n    def kempe_chain_swap(colors, a, b, seed):\n        # BFS on subgraph induced by colors a and b, swap within the connected component of seed\n        if colors[seed] not in (a, b):\n            return colors[:]\n        target = colors[seed]\n        other = b if target == a else a\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    def try_color_class_elimination(colors):\n        # Attempt to eliminate the highest color label greedily\n        k = max(colors)\n        target = k\n        verts = [i for i,c in enumerate(colors) if c == target]\n        if not verts:\n            return colors[:], False\n        order = sorted(verts, key=lambda i: (-saturation_degree(colors, i), -len(adj[i]), i))\n        nb = colors[:]\n        palette = [c for c in sorted(set(nb)) if c != target]\n        for i in order:\n            best_c = None\n            best_v = 10**9\n            best_deg = 10**9\n            for c in palette:\n                # compute conflicts if i recolored to c\n                v_i = 0\n                for j in adj[i]:\n                    if nb[j] == c:\n                        v_i += 1\n                if v_i < best_v or (v_i == best_v and saturation_degree(nb, i) < best_deg):\n                    best_v = v_i\n                    best_deg = saturation_degree(nb, i)\n                    best_c = c\n            if best_c is None:\n                return colors[:], False\n            nb[i] = best_c\n            # if we created a conflict, abort\n            for (u,v) in edges:\n                if nb[u-1] == nb[v-1]:\n                    return colors[:], False\n        # success if feasible and color removed\n        if max(nb) < k:\n            return canonicalize(nb), True\n        return colors[:], False\n\n    colors = repair(solution)\n    # do not canonicalize internally to preserve structure; canonicalize only on return\n    viol, deg = conflicts_and_deg(colors)\n\n    if viol > 0:\n        # Infeasible phase: choose hard vertex by (conflict deg, saturation, degree, index)\n        scores = [ (deg[i], saturation_degree(colors, i), len(adj[i]), -i) for i in range(n) ]\n        worst = max(range(n), key=lambda i: scores[i])\n        new_color = min_conflict_color_repair(colors, worst)\n        nb = colors[:]\n        nb[worst] = new_color\n        # If still conflicted at worst, try a Kempe swap with the most frequent neighbor color\n        v_before = sum(1 for j in adj[worst] if colors[j] == colors[worst])\n        v_after = sum(1 for j in adj[worst] if nb[j] == nb[worst])\n        if v_after >= v_before and len(set(colors)) >= 2:\n            neigh_colors = [colors[j] for j in adj[worst]]\n            if neigh_colors:\n                # pick most common neighbor color distinct from current\n                curc = colors[worst]\n                freq = {}\n                for c in neigh_colors:\n                    if c != curc:\n                        freq[c] = freq.get(c, 0) + 1\n                if freq:\n                    b = max(freq, key=freq.get)\n                    a = curc\n                    nb2 = kempe_chain_swap(colors, a, b, worst)\n                    colors_ret = canonicalize(nb2)\n                    return colors_ret, (\"Heuristic\", \"KempeRepair\")\n        return canonicalize(nb), (\"Heuristic\", \"MinConflictsRecolor\")\n    else:\n        # Feasible: attempt to reduce k by color class elimination, else Kempe diversify\n        nb1, ok = try_color_class_elimination(colors)\n        if ok:\n            return nb1, (\"Intensify\", \"ColorClassElimination\")\n        # Kempe chain between two random colors on random seed\n        palette = sorted(set(colors))\n        if len(palette) >= 2:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            nb2 = kempe_chain_swap(colors, a, b, seed)\n            return canonicalize(nb2), (\"Diversify\", \"KempeSwap\")\n        # Fallback: random tweak within palette\n        idx = random.randrange(n)\n        pal = sorted(set(colors)) or [1]\n        if len(pal) > 1 and colors[idx] in pal:\n            pal = [c for c in pal if c != colors[idx]]\n        nb = colors[:]\n        nb[idx] = random.choice(pal or [colors[idx]])\n        return canonicalize(nb), (\"Diversify\", \"RandomTweak\")\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Multi-step Kempe-chain based shake with occasional recolor within current palette\n    n = 9\n    edges = [(1,7),(1,8),(2,3),(2,6),(2,8),(2,9),(3,5),(3,6),(3,7),(4,7),(4,8),(4,9),(5,6),(5,7),(5,8),(6,8),(7,9)]\n\n    adj = [[] for _ in range(n)]\n    for (u,v) in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            sol = []\n        fixed = []\n        for x in sol[:n]:\n            try:\n                xi = int(x)\n                if xi <= 0:\n                    xi = 1\n            except Exception:\n                xi = 1\n            fixed.append(xi)\n        while len(fixed) < n:\n            fixed.append(1)\n        return fixed\n\n    def canonicalize(sol_list):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_list:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n\n    def kempe_chain_swap(colors, a, b, seed):\n        if colors[seed] not in (a, b):\n            return colors[:]\n        comp = []\n        seen = [False]*n\n        stack = [seed]\n        seen[seed] = True\n        while stack:\n            u = stack.pop()\n            comp.append(u)\n            for v in adj[u]:\n                if not seen[v] and colors[v] in (a, b):\n                    seen[v] = True\n                    stack.append(v)\n        nb = colors[:]\n        for u in comp:\n            nb[u] = a if colors[u] == b else b if colors[u] == a else colors[u]\n        return nb\n\n    colors = canonicalize(repair(solution))\n    steps = 7\n    for _ in range(steps):\n        palette = sorted(set(colors)) or [1]\n        if len(palette) >= 2 and random.random() < 0.8:\n            a, b = random.sample(palette, 2)\n            seed = random.randrange(n)\n            colors = canonicalize(kempe_chain_swap(colors, a, b, seed))\n        else:\n            # Local recolor within current palette or extend by +1 with small prob to escape\n            idx = random.randrange(n)\n            pal = palette[:]\n            if random.random() < 0.15:\n                pal = pal + [max(palette)+1]\n            if len(pal) > 1 and colors[idx] in pal:\n                pal = [c for c in pal if c != colors[idx]]\n            colors[idx] = random.choice(pal or [colors[idx]])\n            colors = canonicalize(colors)\n    return colors\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"STRING: space-separated 9 positive integers, encoding vertex colors c1..c9 in contiguous domain {1..k}. Example: \"1 1 2 1 1 3 3 2 2\". Feasible iff all labels are integers >=1, contiguous {1..k} with k=max, and for every edge (u,v) in E colors differ.","Evaluacion":"import re\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Returns a scalar cost; lower is better. Lexicographic via cost = conflicts*20 + k.\n    # Robust parser: accepts list[int] or string of ints.\n    PENALTY_BASE = 1000\n    # Edge set with 1-based vertices\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    # Contiguity check {1..k}\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    # Cost: conflicts dominate; minimal k within zero-conflict region\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # In-place neighbor on list[int]. If non-list provided, return error metadata.\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    # Problem data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    # Compute current conflicts and conflicting vertices\n    conf_vertices = [i for i in range(n) if conflicts_of_vertex(solution, i) > 0]\n\n    move_roll = random.random()\n    if conf_vertices and move_roll < 0.8:\n        # Conflict-driven recolor of the most conflicting vertex\n        i = max(conf_vertices, key=lambda x: conflicts_of_vertex(solution, x))\n        current_k = max(solution)\n        # Candidate colors: 1..current_k, avoid introducing new color unless all fail\n        best_color = solution[i]\n        best_conf = 10**9\n        # Evaluate each candidate color (excluding current first)\n        candidates = list(range(1, current_k + 1))\n        if solution[i] in candidates:\n            candidates.remove(solution[i])\n        # Try existing colors\n        for c in candidates:\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n                if conf == 0:\n                    # Prefer zero-conflict immediately\n                    break\n            solution[i] = tmp\n        # If no improvement and still conflicts, optionally try introducing color current_k+1 (bounded by 9)\n        if best_conf > 0 and current_k < 9:\n            c = current_k + 1\n            tmp = solution[i]\n            solution[i] = c\n            conf = conflicts_of_vertex(solution, i)\n            if conf < best_conf:\n                best_conf = conf\n                best_color = c\n            solution[i] = tmp\n        solution[i] = best_color\n        normalize(solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One\")\n    elif move_roll < 0.95:\n        # Symmetry move: swap two labels globally (if >=2 labels)\n        uniq = sorted(set(solution))\n        if len(uniq) >= 2:\n            a, b = random.sample(uniq, 2)\n            for idx in range(n):\n                if solution[idx] == a:\n                    solution[idx] = b\n                elif solution[idx] == b:\n                    solution[idx] = a\n            normalize(solution)\n            return (\"NB_Symmetry\", \"Swap-Labels\")\n        else:\n            # Introduce second label to escape uniform state\n            j = random.randrange(n)\n            solution[j] = 2\n            normalize(solution)\n            return (\"NB_Local\", \"Introduce-Second-Label\")\n    else:\n        # Pairwise color exchange on two vertices (not a global swap)\n        i, j = random.sample(range(n), 2)\n        solution[i], solution[j] = solution[j], solution[i]\n        normalize(solution)\n        return (\"NB_Local\", \"Swap-Vertices-Colors\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Returns a new perturbed solution; accepts list[int] or string. Preserves type when possible.\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = [int(x) for x in sol.replace(',', ' ').split()]\n            return parts, 'str'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    # Problem data\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mapping = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mapping[sol[i]]\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1]*9\n    sol = list(sol)\n    normalize(sol)\n\n    # Determine vertices by conflict priority\n    conflict_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(9)]\n    conflict_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Random-kick on top p vertices\n    p = random.randint(2, 4)\n    targets = [i for i, _ in conflict_scores[:p]]\n    current_k = max(sol)\n    for i in targets:\n        # Try a random existing color different from current; 20% chance allow k+1 (<=9)\n        candidates = [c for c in range(1, current_k + 1) if c != sol[i]]\n        if random.random() < 0.2 and current_k < 9:\n            candidates.append(current_k + 1)\n        if candidates:\n            sol[i] = random.choice(candidates)\n    normalize(sol)\n\n    # Color-class shake: choose a color and reassign ~40% of its vertices\n    uniq = sorted(set(sol))\n    if uniq:\n        c = random.choice(uniq)\n        idxs = [i for i in range(9) if sol[i] == c]\n        if idxs:\n            m = max(1, int(0.4 * len(idxs)))\n            pick = random.sample(idxs, m)\n            current_k = max(sol)\n            for i in pick:\n                pool = [x for x in range(1, current_k + 1) if x != sol[i]]\n                if not pool and current_k < 9:\n                    pool = [current_k + 1]\n                if pool:\n                    sol[i] = random.choice(pool)\n    normalize(sol)\n\n    # Forced merge attempt with 50% chance to encourage k reduction\n    if random.random() < 0.5 and len(set(sol)) > 1:\n        uniq = sorted(set(sol))\n        a = random.choice(uniq[1:])\n        b = random.choice([x for x in uniq if x != a])\n        for i in range(9):\n            if sol[i] == a:\n                sol[i] = b\n        normalize(sol)\n\n    return to_type(sol, typ)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors c1..c9 with contiguous domain {1..k}. Example feasible solution: \"1 1 2 1 1 3 3 2 2\".","Evaluacion":"import re\n\ndef evaluate_solution(solution):\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums]\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate input: in-place operation on list[int] of length 9\n    if not isinstance(solution, list) or len(solution) != 9 or any((not isinstance(x, int)) for x in solution):\n        return (\"ERROR\", \"INVALID_INPUT\")\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def total_conflicts(sol):\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def try_reduce_k(sol):\n        # Greedy attempt to remove the highest color class entirely\n        k = max(sol)\n        if k <= 1:\n            return False\n        target = k\n        changed = False\n        moved_any = True\n        # Attempt multiple passes to relocate vertices of 'target'\n        while moved_any:\n            moved_any = False\n            idxs = [i for i, c in enumerate(sol) if c == target]\n            if not idxs:\n                break\n            for i in idxs:\n                for c in range(1, target):\n                    if all(sol[j] != c for j in adj[i]):\n                        sol[i] = c\n                        moved_any = True\n                        changed = True\n                        break\n        if all(c != target for c in sol):\n            before = set(sol)\n            normalize_if_labelset_changed(before, sol)\n            return True\n        return changed\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        ca = sol[seed]\n        cb = b if ca == a else a\n        # BFS on subgraph induced by colors {a,b}\n        seen = set()\n        stack = [seed]\n        seen.add(seed)\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        # swap a<->b on the component 'seen'\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # Begin move selection\n    k = max(solution)\n    tot_conf = total_conflicts(solution)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor with global conflict delta evaluation\n        conf_scores = [(i, conflicts_of_vertex(solution, i)) for i in range(n)]\n        # pick a most conflicting vertex; tie-break by higher degree to be more impactful\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        i = max(cand_vertices, key=lambda x: len(adj[x]))\n        current_k = max(solution)\n        best_color = solution[i]\n        best_total = tot_conf\n        colors = list(range(1, current_k + 1))\n        if solution[i] in colors:\n            colors.remove(solution[i])\n        # allow k+1 occasionally to escape dead-ends\n        if current_k < 9:\n            colors.append(current_k + 1)\n        before_set = set(solution)\n        original = solution[i]\n        for c in colors:\n            solution[i] = c\n            cand_total = total_conflicts(solution)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n                if best_total == 0:\n                    # can't do better than zero conflicts\n                    pass\n        solution[i] = best_color\n        normalize_if_labelset_changed(before_set, solution)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try k-reduction often; otherwise perform Kempe chain to diversify while preserving feasibility\n        move_roll = random.random()\n        if move_roll < 0.7:\n            before_k = max(solution)\n            reduced = try_reduce_k(solution)\n            after_k = max(solution)\n            if reduced and after_k < before_k:\n                return (\"NB_K_Reduction\", \"Greedy-Merge-Highest-Color\")\n            # If not reduced, try to move one vertex from highest color to a feasible lower color\n            target = max(solution)\n            idxs = [i for i, c in enumerate(solution) if c == target]\n            random.shuffle(idxs)\n            for i in idxs:\n                for c in range(1, target):\n                    if all(solution[j] != c for j in adj[i]):\n                        before = set(solution)\n                        solution[i] = c\n                        normalize_if_labelset_changed(before, solution)\n                        return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n            # fall through to diversification if nothing applied\n        # Kempe-chain interchange (feasibility-preserving)\n        kempe_chain_flip(solution)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nimport re\n\n\ndef perturb_solution(solution):\n    # Parse and preserve type\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            nums = re.findall(r\"-?\\d+\", sol)\n            return [int(x) for x in nums], 'str'\n        return [1] * 9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(sol):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def conflicts_of_vertex(sol, i):\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Kempe diversifications (2-3 times)\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n\n    # 2) Random-kick on top conflict vertices (if any conflicts exist)\n    confs = [conflicts_of_vertex(sol, i) for i in range(n)]\n    idxs = list(range(n))\n    idxs.sort(key=lambda i: confs[i], reverse=True)\n    top_p = max(2, min(4, len(idxs)))\n    picks = idxs[:top_p]\n    k = max(sol)\n    for i in picks:\n        # choose a different color; 25% chance allow k+1 (<=9)\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.25 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Forced partial merge attempt of highest color to encourage k drop\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_student_groups_standard","Representacion":"Space-separated 9 positive integers representing colors for vertices 1..9 with contiguous labels {1..k}. Example: \"2 2 1 2 2 3 3 1 1\".","Evaluacion":"import math\nfrom typing import List, Tuple, Union\n\ndef evaluate_solution(solution: Union[str, List[int]]) -> int:\n    PENALTY_BASE = 1000\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol)\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts]\n            except Exception:\n                return None\n        return None\n\n    sol = parse(solution)\n    if sol is None:\n        return PENALTY_BASE + 1\n    if len(sol) != 9:\n        return PENALTY_BASE + 2\n    if any((not isinstance(x, int)) for x in sol):\n        return PENALTY_BASE + 3\n    if min(sol) < 1:\n        return PENALTY_BASE + 4\n    k = max(sol)\n    if k > 9:\n        return PENALTY_BASE + 5\n    uniq = set(sol)\n    if uniq != set(range(1, k + 1)):\n        return PENALTY_BASE + 6\n    conflicts = 0\n    for u, v in edges:\n        if sol[u - 1] == sol[v - 1]:\n            conflicts += 1\n    return conflicts * 20 + k\n","Vecindad":"import random\nfrom typing import List, Tuple, Union\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # This neighborhood operates in-place on list[int] of length 9.\n    # If a string is provided, it performs no change to the input and only returns move metadata.\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_list_valid(sol):\n        return isinstance(sol, list) and len(sol) == 9 and all(isinstance(x, int) for x in sol)\n\n    def normalize_if_labelset_changed(before_set, sol):\n        after_set = set(sol)\n        if after_set != before_set:\n            uniq = sorted(after_set)\n            mp = {c: i + 1 for i, c in enumerate(uniq)}\n            for i in range(len(sol)):\n                sol[i] = mp[sol[i]]\n\n    def total_conflicts(sol: List[int]) -> int:\n        c = 0\n        for (u, v) in edges:\n            if sol[u - 1] == sol[v - 1]:\n                c += 1\n        return c\n\n    def conflicts_of_vertex(sol: List[int], i: int) -> int:\n        ci = sol[i]\n        return sum(1 for j in adj[i] if sol[j] == ci)\n\n    def kempe_chain_flip(sol: List[int]) -> bool:\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return False\n        # Bias towards involving highest color to promote k-reduction\n        mx = max(uniq)\n        if len(uniq) >= 2 and random.random() < 0.7 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        # pick a seed vertex having color a or b\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not candidates:\n            return False\n        seed = random.choice(candidates)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n        return True\n\n    # If input is a list, we operate in place. If not, we only return move info.\n    if not is_list_valid(solution):\n        return (\"NB_NoOp\", \"Invalid-Or-NonList-Input\")\n\n    # Begin move selection on a copy, then commit to original to reduce partial side effects if aborted\n    sol = solution  # operate in-place as required by API\n    k = max(sol)\n    tot_conf = total_conflicts(sol)\n\n    if tot_conf > 0:\n        # Conflict-driven recolor: pick a most conflicting vertex and recolor to minimize global conflicts.\n        conf_scores = [(i, conflicts_of_vertex(sol, i)) for i in range(n)]\n        max_conf = max(s for _, s in conf_scores)\n        cand_vertices = [i for i, s in conf_scores if s == max_conf]\n        # tie-break: prefer vertices from highest color class, then higher degree\n        highest_class = max(sol)\n        cand_vertices.sort(key=lambda i: ((sol[i] != highest_class), -len(adj[i])))\n        i = cand_vertices[0]\n        current_k = max(sol)\n        best_color = sol[i]\n        best_total = tot_conf\n        colors = [c for c in range(1, current_k + 1) if c != sol[i]]\n        # Allow k+1 only if it strictly reduces conflicts\n        allow_extra = current_k < 9\n        before_set = set(sol)\n        original = sol[i]\n        for c in colors + ([current_k + 1] if allow_extra else []):\n            sol[i] = c\n            cand_total = total_conflicts(sol)\n            if cand_total < best_total or (cand_total == best_total and c < best_color):\n                best_total = cand_total\n                best_color = c\n        sol[i] = best_color\n        normalize_if_labelset_changed(before_set, sol)\n        return (\"NB_Local\", \"Conflict-Recolor-One-GlobalDelta\")\n    else:\n        # No conflicts: try reduce k greedily, else diversify via Kempe chains\n        # Attempt to reassign vertices in highest color class to lower colors\n        target = k\n        idxs = [i for i, c in enumerate(sol) if c == target]\n        random.shuffle(idxs)\n        moved = False\n        for i in idxs:\n            for c in range(1, target):\n                if all(sol[j] != c for j in adj[i]):\n                    before_set = set(sol)\n                    sol[i] = c\n                    moved = True\n                    normalize_if_labelset_changed(before_set, sol)\n                    break\n            if moved:\n                break\n        if moved:\n            return (\"NB_K_Reduction\", \"Single-Vertex-Downshift\")\n        # Else perform a Kempe chain flip to diversify while preserving feasibility\n        kempe_chain_flip(sol)\n        return (\"NB_Diversify\", \"Kempe-Chain-Flip\")\n","Perturbacion":"import random\nfrom typing import List, Tuple, Union\n\ndef perturb_solution(solution: Union[str, List[int]]):\n    # Returns a perturbed solution preserving input type (list or str).\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def parse(sol):\n        if isinstance(sol, list):\n            return list(sol), 'list'\n        if isinstance(sol, str):\n            parts = sol.strip().split()\n            try:\n                return [int(x) for x in parts], 'str'\n            except Exception:\n                return [1]*9, 'list'\n        return [1]*9, 'list'\n\n    def to_type(sol_list, typ):\n        if typ == 'list':\n            return sol_list\n        if typ == 'str':\n            return ' '.join(str(x) for x in sol_list)\n        return sol_list\n\n    def normalize(sol: List[int]):\n        uniq = sorted(set(sol))\n        mp = {c: i + 1 for i, c in enumerate(uniq)}\n        for i in range(len(sol)):\n            sol[i] = mp[sol[i]]\n\n    def kempe_chain_flip(sol: List[int]):\n        uniq = sorted(set(sol))\n        if len(uniq) < 2:\n            return\n        mx = max(uniq)\n        # Bias 0.6 to include highest color to encourage k reduction\n        if random.random() < 0.6 and len(uniq) >= 2 and mx in uniq:\n            a = mx\n            b = random.choice([c for c in uniq if c != mx])\n        else:\n            a, b = random.sample(uniq, 2)\n        seeds = [i for i, c in enumerate(sol) if c == a or c == b]\n        if not seeds:\n            return\n        seed = random.choice(seeds)\n        seen = set([seed])\n        stack = [seed]\n        while stack:\n            u = stack.pop()\n            for v in adj[u]:\n                if v not in seen and (sol[v] == a or sol[v] == b):\n                    seen.add(v)\n                    stack.append(v)\n        for u in seen:\n            if sol[u] == a:\n                sol[u] = b\n            elif sol[u] == b:\n                sol[u] = a\n\n    sol, typ = parse(solution)\n    if not isinstance(sol, list) or len(sol) != 9:\n        sol = [1] * 9\n    sol = list(sol)\n    normalize(sol)\n\n    # 1) Perform 2-3 Kempe chain flips for diversification\n    for _ in range(random.randint(2, 3)):\n        kempe_chain_flip(sol)\n    normalize(sol)\n\n    # 2) Random recolor kicks on up to 3 vertices (allow k+1 with small probability)\n    k = max(sol)\n    picks = list(range(n))\n    random.shuffle(picks)\n    picks = picks[:3]\n    for i in picks:\n        choices = [c for c in range(1, k + 1) if c != sol[i]]\n        if random.random() < 0.2 and k < 9:\n            choices.append(k + 1)\n        if choices:\n            sol[i] = random.choice(choices)\n    normalize(sol)\n\n    # 3) Attempt partial merge of highest color into lower ones\n    target = max(sol)\n    idxs = [i for i, c in enumerate(sol) if c == target]\n    random.shuffle(idxs)\n    for i in idxs[:max(1, len(idxs)\/\/2)]:\n        for c in range(1, target):\n            if all(sol[j] != c for j in adj[i]):\n                sol[i] = c\n                break\n    normalize(sol)\n\n    return to_type(sol, typ)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k} and k minimized.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = normalize_colors(solution[:])\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        target_color = sol[v-1]\n        if target_color not in (color_a, color_b):\n            return sol[:]\n        keep = set([color_a, color_b])\n        visited = set()\n        stack = [v]\n        visited.add(v)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    k = max(cur)\n\n    # Identify conflicts\n    conflicts = []\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflicts.append((u, v))\n\n    if conflicts:\n        # Conflict-directed recolor: pick a conflicting vertex, try best existing color\n        u, v = random.choice(conflicts)\n        target = random.choice([u, v])\n        best_sol = None\n        best_score = None\n        used_colors = list(range(1, k+1))\n        random.shuffle(used_colors)\n        for c in used_colors:\n            if c == cur[target-1]:\n                continue\n            if feasible_recolor(cur, target, c):\n                trial = cur[:]\n                trial[target-1] = c\n                sc = count_conflicts(trial)\n                if best_score is None or sc < best_score:\n                    best_score = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n        # If no direct recolor reduces conflicts, attempt a Kempe-chain swap between two existing colors\n        c_a = cur[target-1]\n        # Pick an alternative color present in the palette\n        alt_colors = [c for c in range(1, k+1) if c != c_a]\n        if not alt_colors:\n            return (cur, \"noop\")\n        c_b = random.choice(alt_colors)\n        swapped = kempe_swap(cur, target, c_a, c_b)\n        return (normalize_colors(swapped), \"kempe_swap_conflict\")\n    else:\n        # Feasible: try to reduce number of colors by eliminating the highest label\n        if k > 1:\n            target_color = k\n            vertices = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            random.shuffle(vertices)\n            reduced = cur[:]\n            success = True\n            for v in vertices:\n                # Try to move v to any lower color without conflicts\n                moved = False\n                palette = list(range(1, target_color))\n                random.shuffle(palette)\n                for c in palette:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                return (normalize_colors(reduced), \"color_drop\")\n        # If not reduced, apply a small Kempe swap to diversify keeping k constant\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        # choose a different color within current palette\n        choices = [c for c in range(1, k+1) if c != c_a]\n        if not choices:\n            return (cur, \"noop\")\n        c_b = random.choice(choices)\n        swapped = kempe_swap(cur, v, c_a, c_b)\n        swapped = normalize_colors(swapped)\n        return (swapped, \"kempe_swap_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = set([color_a, color_b])\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            out[x-1] = color_a if sol[x-1] == color_b else (color_b if sol[x-1] == color_a else sol[x-1])\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # With probability, relabel colors by a random permutation to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Perform several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        # choose a different existing color to swap with\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment of a few vertices to existing colors (no new colors)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        # Try up to 2 attempts to pick a different color within existing palette\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden. Output example: [1,1,2,1,1,3,3,2,2].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Soft cap on color labels to avoid drift\n    max_color = max(solution)\n    if max_color > 9:\n        return 10**9 + max_color\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    if conflicts:\n        return 10**8 + conflicts\n    # Feasible: number of distinct colors (lower is better)\n    k = len(set(solution))\n    return k\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed recolor: choose most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_conflicts = count_conflicts(cur)\n        best_sol = None\n        best_conf = None\n        palette = list(range(1, max(k, 2)+1))  # ensure at least 2 to allow a move\n        random.shuffle(palette)\n        for c in palette:\n            if c == cur[worst_v-1]:\n                continue\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = count_conflicts(trial)\n                if sc <= current_conflicts and (best_conf is None or sc < best_conf):\n                    best_conf = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (best_sol, \"conflict_recolor\")\n        # Try a gated Kempe swap that does not increase conflicts\n        alt_colors = [c for c in range(1, k+1) if c != cur[worst_v-1]]\n        if alt_colors:\n            c_b = random.choice(alt_colors)\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if count_conflicts(swapped) <= current_conflicts:\n                return (swapped, \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            # Order by saturation degree (distinct neighbor colors desc)\n            def sat_deg(v):\n                return len({cur[w-1] for w in adj[v]})\n            verts.sort(key=sat_deg, reverse=True)\n            reduced = cur[:]\n            success = True\n            for v in verts:\n                # Try to move v to a lower color without conflicts\n                candidates = list(range(1, target_color))\n                random.shuffle(candidates)\n                moved = False\n                for c in candidates:\n                    if feasible_recolor(reduced, v, c):\n                        reduced[v-1] = c\n                        moved = True\n                        break\n                if not moved:\n                    success = False\n                    break\n            if success:\n                reduced = normalize_colors(reduced)\n                return (reduced, \"color_drop\")\n        # If not reduced, diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (trial, \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if count_conflicts(swapped) == 0:\n                return (swapped, \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.6:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 3 if k <= 3 else 5\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Light random reassignment within existing palette (may introduce few conflicts)\n    m = random.randint(2, 3)\n    idxs = random.sample(range(n), m)\n    k = max(s)\n    for i in idxs:\n        for _ in range(2):\n            c = random.randint(1, k)\n            if c != s[i]:\n                s[i] = c\n                break\n    s = normalize_colors(s)\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_taekwondo_tournament_standard","Representacion":"INDEX_LIST_LEN_9_POSITIVE_INTEGERS representing colors c_1..c_9 with labels in {1..k}. Objective: minimize k subject to edge conflicts forbidden.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Type and size validation\n    if not isinstance(solution, list):\n        return 10**12\n    n = len(solution)\n    if n != 9:\n        return 10**12 + abs(n - 9)\n    # Domain validation: positive integers\n    domain_pen = 0\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            domain_pen += 1\n    if domain_pen:\n        return 10**10 + 10**6 * domain_pen\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Conflicts\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u - 1] == solution[v - 1]:\n            conflicts += 1\n    k = len(set(solution))\n    if conflicts:\n        # Composite score to guide search within equal-conflict plateaus\n        return 10**8 * conflicts + k\n    # Feasible: number of distinct colors (lower is better)\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive checks\n    if not isinstance(solution, list) or len(solution) != 9:\n        return (solution, \"invalid_noop\")\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return (solution, \"invalid_noop\")\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        # Relabel to consecutive 1..k preserving first-appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def conflict_count(sol):\n        cnt = 0\n        for (u, v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def score(sol):\n        c = conflict_count(sol)\n        if c:\n            return 10**8 * c + len(set(sol))\n        return len(set(sol))\n\n    def feasible_recolor(sol, v, color):\n        for w in adj[v]:\n            if sol[w-1] == color:\n                return False\n        return True\n\n    def kempe_swap(sol, v, color_a, color_b):\n        # BFS on Kempe component with colors in {color_a,color_b}\n        if sol[v-1] not in (color_a, color_b):\n            return sol[:]\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    cur = solution[:]\n    k = max(cur)\n\n    # Identify conflicts and conflict degrees\n    conflict_edges = []\n    conf_deg = {i: 0 for i in range(1, n+1)}\n    for (u, v) in edges:\n        if cur[u-1] == cur[v-1]:\n            conflict_edges.append((u, v))\n            conf_deg[u] += 1\n            conf_deg[v] += 1\n\n    if conflict_edges:\n        # Conflict-directed move: pick most conflicted vertex\n        worst_v = max(range(1, n+1), key=lambda v: conf_deg[v])\n        current_score = score(cur)\n\n        # Attempt recolor to least frequent feasible color in neighborhood\n        neigh_colors = {}\n        for w in adj[worst_v]:\n            c = cur[w-1]\n            neigh_colors[c] = neigh_colors.get(c, 0) + 1\n        palette = list(range(1, max(k, 2)+1))\n        palette = [c for c in palette if c != cur[worst_v-1]]\n        palette.sort(key=lambda c: neigh_colors.get(c, 0))  # least frequent first\n        best_sol = None\n        best_sc = None\n        for c in palette:\n            if feasible_recolor(cur, worst_v, c):\n                trial = cur[:]\n                trial[worst_v-1] = c\n                sc = score(trial)\n                if sc <= current_score and (best_sc is None or sc < best_sc):\n                    best_sc = sc\n                    best_sol = trial\n        if best_sol is not None:\n            return (normalize_colors(best_sol), \"conflict_recolor\")\n\n        # If recolor failed, try a biased Kempe swap with color minimizing neighbor frequency\n        if palette:\n            # pick color with min frequency among neighbors\n            c_b = min(palette, key=lambda c: neigh_colors.get(c, 0))\n            swapped = kempe_swap(cur, worst_v, cur[worst_v-1], c_b)\n            if score(swapped) <= current_score:\n                return (normalize_colors(swapped), \"kempe_conflict\")\n        return (cur, \"noop_conflict\")\n    else:\n        # Feasible state: attempt to drop the highest color k with multi-pass reassignment\n        if k > 1:\n            target_color = k\n            verts = [i for i in range(1, n+1) if cur[i-1] == target_color]\n            if verts:\n                reduced = cur[:]\n                changed = True\n                attempt_limit = 3\n                attempts = 0\n                while attempts < attempt_limit and verts:\n                    attempts += 1\n                    progress = False\n                    for v in list(verts):\n                        # Try least-constraining feasible color in 1..target_color-1\n                        cand = list(range(1, target_color))\n                        # order by conflicts that would be introduced (LCV heuristic)\n                        def clash_count(color):\n                            cnt = 0\n                            for w in adj[v]:\n                                if reduced[w-1] == color:\n                                    cnt += 1\n                            return cnt\n                        cand.sort(key=clash_count)\n                        moved = False\n                        for c in cand:\n                            if feasible_recolor(reduced, v, c):\n                                reduced[v-1] = c\n                                verts.remove(v)\n                                progress = True\n                                moved = True\n                                break\n                        if not moved:\n                            continue\n                    if not progress:\n                        break\n                if not verts:\n                    reduced = normalize_colors(reduced)\n                    return (reduced, \"color_drop\")\n        # Diversify while preserving feasibility\n        v = random.randint(1, n)\n        cur_color = cur[v-1]\n        choices = [c for c in range(1, k+1) if c != cur_color and feasible_recolor(cur, v, c)]\n        if choices:\n            new_c = random.choice(choices)\n            trial = cur[:]\n            trial[v-1] = new_c\n            return (normalize_colors(trial), \"feasible_recolor\")\n        # Fallback Kempe swap that preserves feasibility if possible\n        v = random.randint(1, n)\n        c_a = cur[v-1]\n        alt = [c for c in range(1, k+1) if c != c_a]\n        if alt:\n            c_b = random.choice(alt)\n            swapped = kempe_swap(cur, v, c_a, c_b)\n            if conflict_count(swapped) == 0:\n                return (normalize_colors(swapped), \"kempe_feasible\")\n        return (cur, \"noop_feasible\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong but structure-preserving perturbation using Kempe-chain swaps and color relabeling\n    if not isinstance(solution, list) or len(solution) != 9:\n        # Seed with small palette random assignment (not guaranteed feasible)\n        return [random.randint(1, 3) for _ in range(9)]\n\n    # Graph definition (undirected)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    n = 9\n\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def normalize_colors(col):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in col:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_swap(sol, v, color_a, color_b):\n        keep = {color_a, color_b}\n        visited = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y not in visited and sol[y-1] in keep:\n                    visited.add(y)\n                    stack.append(y)\n        out = sol[:]\n        for x in visited:\n            if out[x-1] == color_a:\n                out[x-1] = color_b\n            elif out[x-1] == color_b:\n                out[x-1] = color_a\n        return out\n\n    s = normalize_colors(solution[:])\n\n    # Random relabel to break symmetry\n    colors = sorted(set(s))\n    if len(colors) > 1 and random.random() < 0.7:\n        perm = colors[:]\n        random.shuffle(perm)\n        mapping = {c: perm[i] for i, c in enumerate(colors)}\n        s = [mapping[c] for c in s]\n        s = normalize_colors(s)\n\n    # Several Kempe-chain swaps to move to a different basin\n    k = max(s)\n    steps = 4 if k <= 3 else 6\n    for _ in range(steps):\n        v = random.randint(1, n)\n        c_a = s[v-1]\n        palette = [c for c in range(1, k+1) if c != c_a]\n        if not palette:\n            continue\n        c_b = random.choice(palette)\n        s = kempe_swap(s, v, c_a, c_b)\n        s = normalize_colors(s)\n        k = max(s)\n\n    # Reassign a subset of vertices in the highest color to random lower colors (may add few conflicts)\n    k = max(s)\n    high_idxs = [i for i, c in enumerate(s) if c == k]\n    if high_idxs:\n        m = max(1, min(len(high_idxs), 2))\n        for i in random.sample(high_idxs, m):\n            if k > 1:\n                s[i] = random.randint(1, k-1)\n    s = normalize_colors(s)\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color of vertex i+1 for i=0..8; length=9; colors are positive integers; no other encoding.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    PEN_INVALID = 10**7\n    PEN_CONFLICT = 10**5\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate and symmetrize\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    if conflicts > 0:\n        # Heavy penalty dominates; add small tie breaker by used colors\n        return PEN_INVALID + conflicts * PEN_CONFLICT + len(set(solution))\n    # Feasible: minimize number of used colors\n    used = len(set(solution))\n    return used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {NB_Recolor, NB_Kempe, NB_ClassSwap, NB_ColorDrop, NB_InvalidPassthrough}\n    Movement_Type in {SingleVertex, Chain, ClassPair, Palette, None}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"NB_InvalidPassthrough\", \"None\"\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, \"NB_InvalidPassthrough\", \"None\"\n\n    # Graph data\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts(sol):\n        cnt = 0\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        # Pick conflicted vertex if any, else high-degree vertex\n        bad = conflict_vertices(sol)\n        if bad:\n            v = random.choice(bad)\n        else:\n            # Highest degree, tie-broken randomly\n            v = max(range(1, n+1), key=lambda u: (len(adj[u]), random.random()))\n        cur = sol[:]\n        max_color = max(cur)\n        # Candidate colors: existing palette only (avoid color explosion) unless conflicts exist\n        candidate_colors = list(sorted(set(cur)))\n        if bad and random.random() < 0.2:\n            candidate_colors.append(max_color + 1)\n        random.shuffle(candidate_colors)\n        best = cur\n        best_score = None\n        for c in candidate_colors:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Compute conflict delta locally\n            conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    conf += 1\n            # Add small tie-breaker to reduce colors\n            used = len(set(trial))\n            score = (conf, used, random.random())\n            if best_score is None or score < best_score:\n                best_score = score\n                best = trial\n        return compact_palette(best), \"NB_Recolor\", \"SingleVertex\"\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Pick target color different from c1; prefer neighbor colors\n        nb_colors = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_colors:\n            palette = sorted(set(cur))\n            if len(palette) == 1:\n                return cur, \"NB_Kempe\", \"Chain\"\n            nb_colors = [random.choice([c for c in palette if c != c1])]\n        c2 = random.choice(nb_colors)\n        # BFS to collect Kempe chain for colors {c1,c2}\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on the chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return compact_palette(cur), \"NB_Kempe\", \"Chain\"\n\n    def class_swap(sol):\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) < 2:\n            return cur, \"NB_ClassSwap\", \"ClassPair\"\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if cur[i] == a:\n                cur[i] = b\n            elif cur[i] == b:\n                cur[i] = a\n        return compact_palette(cur), \"NB_ClassSwap\", \"ClassPair\"\n\n    def color_drop(sol):\n        # Try to eliminate a color by greedily recoloring its vertices\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, \"NB_ColorDrop\", \"Palette\"\n        target = random.choice(palette)\n        other = [c for c in palette if c != target]\n        random.shuffle(other)\n        ok = True\n        for v in [i+1 for i,c in enumerate(cur) if c == target]:\n            placed = False\n            random.shuffle(other)\n            for c in other:\n                conflict = False\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        conflict = True\n                        break\n                if not conflict:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                ok = False\n                break\n        if ok:\n            return compact_palette(cur), \"NB_ColorDrop\", \"Palette\"\n        else:\n            return sol[:], \"NB_ColorDrop\", \"Palette\"\n\n    moves = []\n    # Prefer recolor\/Kempe when conflicts exist; else attempt color drop\n    if conflict_vertices(solution):\n        moves.extend([guided_recolor, kempe_chain_move])\n        if random.random() < 0.3:\n            moves.append(class_swap)\n    else:\n        moves.extend([color_drop, guided_recolor, kempe_chain_move, class_swap])\n    move = random.choice(moves)\n    neigh, nb_type, mv = move(solution)\n    return compact_palette(neigh), nb_type, mv\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def compact_palette(sol):\n        palette = sorted(set(sol))\n        remap = {c: i+1 for i, c in enumerate(palette)}\n        return [remap[c] for c in sol]\n\n    def kempe(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = list({cur[nb-1] for nb in adj[v] if cur[nb-1] != c1})\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        chain = set([v])\n        stack = [v]\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    s = solution[:]\n    # Intensity: 2-5 Kempe chains and 1 class swap attempt; finalize with palette compaction\n    steps = random.randint(2, 5)\n    for _ in range(steps):\n        s = kempe(s)\n    # Class swap attempt\n    palette = sorted(set(s))\n    if len(palette) >= 2 and random.random() < 0.8:\n        a, b = random.sample(palette, 2)\n        for i in range(n):\n            if s[i] == a:\n                s[i] = b\n            elif s[i] == b:\n                s[i] = a\n    s = compact_palette(s)\n    return s\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_1..k; solution[i] is color (positive int) of vertex i+1 for i=0..8; length=9; colors are labels, not compacted automatically.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**9\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    # Weight >= 100 ensures any conflict worse than any color count decrease\n    CONFLICT_WEIGHT = 100\n    return conflicts * CONFLICT_WEIGHT + used","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns a 2-tuple: (neighbor_solution, meta_dict)\n    meta_dict contains keys: {'NB_Type': str, 'Movement_Type': str}\n    \"\"\"\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def guided_recolor(sol):\n        # DSATUR-ish: pick a vertex (prefer conflicted; else highest saturation\/degree)\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Compute saturation (distinct neighbor colors)\n        def sat(u):\n            return len({cur[v-1] for v in adj[u]})\n        v = max(cand_vertices, key=lambda u: (sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        # Candidate colors: try existing colors first, then at most one new color\n        nb_cols = {cur[nb-1] for nb in adj[v]}\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        # Allow new color only if all neighbor colors block current palette\n        if len(nb_cols) >= len(used_palette) - (1 if cur[v-1] in used_palette else 0):\n            candidates.append(max(used_palette) + 1)\n        random.shuffle(candidates)\n        best = cur\n        best_key = None\n        for c in candidates:\n            if c == cur[v-1]:\n                continue\n            trial = cur[:]\n            trial[v-1] = c\n            # Local conflict count at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if best_key is None or key < best_key:\n                best_key = key\n                best = trial\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        # Seed vertex prefers conflicted; else random\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        # Choose c2 among neighbor colors that currently conflict most with v\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        # bias to highest frequency\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        # Collect (c1,c2)-Kempe chain via DFS\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        # Swap c1<->c2 on chain\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        random.shuffle(verts)\n        success = True\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                # Check if assigning c to v creates conflict\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    break\n            if not placed:\n                success = False\n                break\n        if success:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection: prioritize reducing conflicts; otherwise try to reduce colors\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Targeted recolor of 1-2 random vertices to diversify\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_12_textbook_standard","Representacion":"INDEX_LIST_9_COLORS_POSITIVE_INTS: solution[i] gives color of vertex (i+1); length=9; colors are labels (not auto-compacted).","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    BIG = 10**12\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return BIG\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return BIG\n    # Graph (1-indexed)\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Deduplicate+validate\n    es = set()\n    for (u,v) in edges:\n        if not (1 <= u <= 9 and 1 <= v <= 9) or u == v:\n            return BIG\n        a = u if u < v else v\n        b = v if u < v else u\n        es.add((a,b))\n    edges = list(es)\n    # Count conflicts\n    conflicts = 0\n    for (u,v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used = len(set(solution))\n    # Lexicographic scalar: conflicts dominate colors\n    CONFLICT_WEIGHT = 1000\n    return conflicts * CONFLICT_WEIGHT + used\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution, {\"NB_Type\": \"NB_InvalidPassthrough\", \"Movement_Type\": \"None\"}\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    # Build adjacency\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    def conflict_vertices(sol):\n        bad = set()\n        for (u,v) in edges:\n            if sol[u-1] == sol[v-1]:\n                bad.add(u); bad.add(v)\n        return list(bad)\n\n    def local_conflicts_for_vertex(sol, v):\n        c = sol[v-1]\n        cnt = 0\n        for nb in adj[v]:\n            if sol[nb-1] == c:\n                cnt += 1\n        return cnt\n\n    def guided_recolor(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        cand_vertices = bad if bad else list(range(1, n+1))\n        # Priority: (#conflicts at v, saturation, degree)\n        def sat(u):\n            return len({cur[w-1] for w in adj[u]})\n        def confdeg(u):\n            return local_conflicts_for_vertex(cur, u)\n        v = max(cand_vertices, key=lambda u: (confdeg(u), sat(u), len(adj[u]), random.random()))\n        used_palette = sorted(set(cur))\n        nb_cols = {cur[w-1] for w in adj[v]}\n        # Try existing colors first\n        candidates = [c for c in used_palette if c != cur[v-1]]\n        best = cur\n        best_key = (10**9, 10**9)\n        for c in candidates:\n            trial = cur[:]\n            trial[v-1] = c\n            # Evaluate local conflicts at v\n            local_conf = 0\n            for nb in adj[v]:\n                if trial[nb-1] == trial[v-1]:\n                    local_conf += 1\n            key = (local_conf, len(set(trial)))\n            if key < best_key:\n                best_key = key\n                best = trial\n        # Consider introducing a new color only if conflicts remain and all existing colors are blocked\n        if best_key[0] > 0 and len(nb_cols) >= len(used_palette):\n            c_new = max(used_palette) + 1\n            trial = cur[:]\n            trial[v-1] = c_new\n            key = (0, len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best, {\"NB_Type\": \"NB_Recolor\", \"Movement_Type\": \"SingleVertex\"}\n\n    def kempe_chain_move(sol):\n        cur = sol[:]\n        bad = conflict_vertices(cur)\n        v = random.choice(bad) if bad else random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_colors = {}\n        for nb in adj[v]:\n            col = cur[nb-1]\n            if col == c1:\n                continue\n            nb_colors[col] = nb_colors.get(col, 0) + 1\n        if not nb_colors:\n            return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        maxfreq = max(nb_colors.values())\n        top = [c for c,f in nb_colors.items() if f == maxfreq]\n        c2 = random.choice(top)\n        stack = [v]\n        chain = set([v])\n        palette = (c1, c2)\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in palette:\n                    chain.add(y)\n                    stack.append(y)\n        after = cur[:]\n        for x in chain:\n            after[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        # Accept if it does not worsen (conflicts, used)\n        def score(solx):\n            # fast local eval: count conflicts and used\n            confl = 0\n            for (u,v) in edges:\n                if solx[u-1] == solx[v-1]:\n                    confl += 1\n            return (confl, len(set(solx)))\n        if score(after) <= score(cur):\n            return after, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n        return cur, {\"NB_Type\": \"NB_Kempe\", \"Movement_Type\": \"Chain\"}\n\n    def color_drop(sol):\n        # Attempt to eliminate one color class by reassignment; keep partial successes\n        cur = sol[:]\n        palette = sorted(set(cur))\n        if len(palette) <= 1:\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        target = random.choice(palette)\n        others = [c for c in palette if c != target]\n        verts = [i+1 for i,c in enumerate(cur) if c == target]\n        # Sort by degree desc to place hard vertices first\n        verts.sort(key=lambda v: len(adj[v]), reverse=True)\n        moved_any = False\n        for v in verts:\n            placed = False\n            random.shuffle(others)\n            for c in others:\n                ok = True\n                for nb in adj[v]:\n                    if cur[nb-1] == c:\n                        ok = False\n                        break\n                if ok:\n                    cur[v-1] = c\n                    placed = True\n                    moved_any = True\n                    break\n        if moved_any and target not in set(cur):\n            return cur, {\"NB_Type\": \"NB_ColorDrop\", \"Movement_Type\": \"Palette\"}\n        # Fallback: guided recolor to avoid no-op\n        return guided_recolor(sol)\n\n    # Strategy selection\n    has_conflict = len(conflict_vertices(solution)) > 0\n    moves = [guided_recolor, kempe_chain_move] if has_conflict else [color_drop, guided_recolor, kempe_chain_move]\n    move = random.choice(moves)\n    neigh, meta = move(solution)\n    return neigh, meta\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            return solution\n\n    n = 9\n    edges = [\n        (1,7),(1,8),\n        (2,3),(2,6),(2,8),(2,9),\n        (3,5),(3,6),(3,7),\n        (4,7),(4,8),(4,9),\n        (5,6),(5,7),(5,8),\n        (6,8),\n        (7,9)\n    ]\n    adj = {i: set() for i in range(1, n+1)}\n    for (u,v) in edges:\n        a = u if u < v else v\n        b = v if u < v else u\n        adj[a].add(b)\n        adj[b].add(a)\n\n    s = solution[:]\n\n    def kempe_once(sol):\n        cur = sol[:]\n        v = random.randrange(1, n+1)\n        c1 = cur[v-1]\n        nb_cols = [cur[u-1] for u in adj[v] if cur[u-1] != c1]\n        if not nb_cols:\n            return cur\n        c2 = random.choice(nb_cols)\n        stack = [v]\n        chain = set([v])\n        while stack:\n            x = stack.pop()\n            for y in adj[x]:\n                if y in chain:\n                    continue\n                if cur[y-1] in (c1, c2):\n                    chain.add(y)\n                    stack.append(y)\n        for x in chain:\n            cur[x-1] = c1 if cur[x-1] == c2 else (c2 if cur[x-1] == c1 else cur[x-1])\n        return cur\n\n    # Apply 2-4 Kempe perturbations\n    for _ in range(random.randint(2, 4)):\n        s = kempe_once(s)\n\n    # Recolor 1-2 random vertices with non-conflicting colors, allowing one new color as last resort\n    m = random.randint(1, 2)\n    for _ in range(m):\n        v = random.randrange(1, n+1)\n        used = sorted(set(s))\n        candidates = used + [max(used) + 1]\n        random.shuffle(candidates)\n        for c in candidates:\n            if c == s[v-1]:\n                continue\n            conflict = False\n            for nb in adj[v]:\n                if s[nb-1] == c:\n                    conflict = True\n                    break\n            if not conflict:\n                s[v-1] = c\n                break\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust, gradient-preserving evaluator for graph coloring on fixed 9-vertex graph\n    # Score semantics (minimize):\n    # - If feasible (no edge conflicts, labels contiguous 1..k): return k\n    # - If infeasible: 1e9 + conflicts*1e6 + label_gaps*1e3 + k\n    # This preserves gradient towards feasibility and then towards fewer colors.\n    BASE_PENALTY = 10**9\n    # Basic structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + 10**7\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + 10**7 + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + 10**7 + 1\n        if x <= 0:\n            return BASE_PENALTY + 10**7 + 2\n    k = max(solution)\n    # Contiguity check: labels must be exactly 1..k with each used\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            # Should not happen due to k = max(solution), keep safe\n            return BASE_PENALTY + 10**7 + 3\n    label_gaps = 0\n    for c in range(1, k + 1):\n        if freq[c] == 0:\n            label_gaps += 1\n    # Graph definition (0-based indices)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Count conflicts (monochromatic edges)\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    # Feasible: minimize k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns a 3-tuple: (nb_type:str, move_type:str, neighbor_solution:list[int])\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    # Ensure proper base solution\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        # Fallback reasonable seed\n        sol = [1,3,2,1,1,2,2,2,3]\n    n = 9\n    idx = random.randrange(n)\n    k = max(1, max(sol))\n    if random.random() < 0.2:\n        new_color = k + 1\n    else:\n        choices = [c for c in range(1, k + 1) if c != sol[idx]]\n        if choices:\n            new_color = random.choice(choices)\n        else:\n            new_color = sol[idx]\n    sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return (\"RandomSingleRecolor\", \"RecolorVertex\", sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger, multi-edit perturbation with optional global color swap\n    def relabel_contiguous(sol_in):\n        mapping = {}\n        next_label = 1\n        out = []\n        for x in sol_in:\n            if x not in mapping:\n                mapping[x] = next_label\n                next_label += 1\n            out.append(mapping[x])\n        return out\n    if isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x > 0 for x in solution):\n        sol = list(solution)\n    else:\n        sol = [1,3,2,1,1,2,2,2,3]\n    k = max(1, max(sol))\n    if random.random() < 0.5 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        sol = [b if x == a else a if x == b else x for x in sol]\n    else:\n        edits = random.randint(2, 4)\n        n = 9\n        for _ in range(edits):\n            idx = random.randrange(n)\n            k = max(1, max(sol))\n            if random.random() < 0.3:\n                new_color = k + 1\n            else:\n                choices = [c for c in range(1, k + 1) if c != sol[idx]]\n                new_color = random.choice(choices) if choices else sol[idx]\n            sol[idx] = new_color\n    sol = relabel_contiguous(sol)\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust evaluator for fixed 9-vertex graph coloring\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    n = 9\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    k = max(solution)\n    # Contiguity check 1..k all used at least once\n    freq = [0] * (k + 1)\n    for x in solution:\n        if 1 <= x <= k:\n            freq[x] += 1\n        else:\n            return BASE_PENALTY + STRUCT_PENALTY + 3\n    label_gaps = sum(1 for c in range(1, k + 1) if freq[c] == 0)\n    # Graph edges (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    conflicts = 0\n    for (u, v) in edges0:\n        if solution[u] == solution[v]:\n            conflicts += 1\n    if conflicts > 0 or label_gaps > 0:\n        return BASE_PENALTY + conflicts * (10**6) + label_gaps * (10**3) + k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (nb_type:str, move_type:str, neighbor_solution:list[int])\n    # Internal graph (0-based)\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        # Feasible 3-color seed\n        return [1,3,2,1,1,2,2,2,3]\n    def compute_conflicts(sol):\n        cset = set()\n        for (u, v) in edges0:\n            if sol[u] == sol[v]:\n                cset.add(u); cset.add(v)\n        return cset\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    conflict_vertices = list(compute_conflicts(sol))\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    if random.random() < 0.2 and k >= 2:\n        # occasional color-class swap diversification\n        a, b = random.sample(range(1, k + 1), 2)\n        new_sol = [b if x == a else a if x == b else x for x in new_sol]\n        move_type = \"SwapColors({},{})\".format(a, b)\n        nb_type = \"ColorClassSwap\"\n    else:\n        if conflict_vertices:\n            v = random.choice(conflict_vertices)\n        else:\n            v = random.randrange(n)\n        # Try best existing color for v (greedy min local conflicts)\n        # Build adjacency list for quick conflict eval\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        current = new_sol[v]\n        best_color = current\n        best_conf = 10**9\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                # usually skip no-op\n                continue\n            tmpc = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmpc += 1\n            if tmpc < best_conf:\n                best_conf = tmpc\n                best_color = c\n                if best_conf == 0:\n                    break\n        # Consider adding a new color only if conflicts exist and it helps\n        if conflict_vertices and random.random() < 0.1:\n            best_color = k + 1\n        new_sol[v] = best_color\n    # Ensure positivity and length preserved\n    if len(new_sol) != n:\n        new_sol = valid_or_seed(None)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (nb_type, move_type, new_sol)\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Stronger multi-edit perturbation using Kempe-chain swaps and random recolors\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    n = 9\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def kempe_chain_swap(sol, start_v, a, b):\n        # BFS over subgraph induced by colors a and b starting at start_v\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        adj = [[] for _ in range(n)]\n        for (u, w) in edges0:\n            adj[u].append(w); adj[w].append(u)\n        target_colors = {a, b}\n        q = deque([start_v])\n        comp = set([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target_colors and u not in comp:\n                    comp.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in comp:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = valid_or_seed(solution)\n    k = max(sol)\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            # random recolor a few vertices\n            edits = random.randint(1, 3)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n    # Sanity: ensure all entries valid\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_parties_with_exes_standard","Representacion":"LIST_INT_COLORING_LEN9_CONTIGUOUS_LABELS_1_TO_K","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns fitness (lower is better). 3-color feasible => 3.\n    BASE_PENALTY = 10**9\n    STRUCT_PENALTY = 10**7\n    # Internal helpers and data (embedded to avoid external\/global deps)\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    # Structural checks\n    if not isinstance(solution, list):\n        return BASE_PENALTY + STRUCT_PENALTY\n    if len(solution) != n:\n        return BASE_PENALTY + STRUCT_PENALTY + abs(len(solution) - n)\n    for x in solution:\n        if not isinstance(x, int):\n            return BASE_PENALTY + STRUCT_PENALTY + 1\n        if x <= 0:\n            return BASE_PENALTY + STRUCT_PENALTY + 2\n    # Normalize labels to contiguous 1..k to avoid artificial gaps\n    sol = compress_labels(solution)\n    k = max(sol)\n    # Count edge conflicts\n    conflicts = 0\n    for (u, v) in edges0:\n        if sol[u] == sol[v]:\n            conflicts += 1\n    if conflicts > 0:\n        # Penalize conflicts heavily; break ties by k\n        return BASE_PENALTY + conflicts * (10**6) + k\n    # Feasible: objective is k\n    return k\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, (NB_Type, Movement_Type))\n    # Embeds graph data and uses normalization to maintain contiguity.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    # Build adjacency once per call\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def vertex_conflicts(sol, v):\n        c = 0\n        for u in adj[v]:\n            if sol[u] == sol[v]:\n                c += 1\n        return c\n    def saturation_degree(sol, v):\n        colors = set()\n        for u in adj[v]:\n            colors.add(sol[u])\n        return len(colors)\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Identify conflict set and metrics\n    conflict_vertices = [v for v in range(n) if vertex_conflicts(sol, v) > 0]\n    move_type = \"RecolorVertex\"\n    nb_type = \"ConflictDriven\"\n    new_sol = sol[:]\n    # Diversification: occasional color-class swap\n    if random.random() < 0.15 and k >= 2:\n        a, b = random.sample(range(1, k + 1), 2)\n        for i in range(n):\n            if new_sol[i] == a:\n                new_sol[i] = b\n            elif new_sol[i] == b:\n                new_sol[i] = a\n        move_type = f\"SwapColors({a},{b})\"\n        nb_type = \"ColorClassSwap\"\n    else:\n        # Select vertex: prefer max conflicts, tie-break by saturation degree\n        if conflict_vertices:\n            v = max(conflict_vertices, key=lambda x: (vertex_conflicts(sol, x), saturation_degree(sol, x), random.random()))\n        else:\n            v = max(range(n), key=lambda x: (saturation_degree(sol, x), random.random()))\n        current = new_sol[v]\n        best_color = current\n        best_score = 10**9\n        # Try existing colors 1..k (minimize local conflicts for v)\n        palette = list(range(1, k + 1))\n        random.shuffle(palette)\n        for c in palette:\n            if c == current and random.random() < 0.7:\n                continue\n            tmp = 0\n            for u in adj[v]:\n                if new_sol[u] == c:\n                    tmp += 1\n            if tmp < best_score:\n                best_score = tmp\n                best_color = c\n                if best_score == 0:\n                    break\n        # Only consider introducing a new color if all existing colors cause conflicts for this vertex\n        if best_score > 0:\n            # small chance to try k+1 to escape local minima\n            if random.random() < 0.05:\n                best_color = k + 1\n        new_sol[v] = best_color\n    # Normalize and sanitize\n    new_sol = compress_labels(new_sol)\n    for i in range(n):\n        if not isinstance(new_sol[i], int) or new_sol[i] <= 0:\n            new_sol[i] = 1\n    return (new_sol, (nb_type, move_type))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong multi-edit perturbation with Kempe-chain swaps + random recolors; maintains contiguity via normalization.\n    n = 9\n    edges0 = [\n        (0,1),(0,6),(0,8),\n        (1,2),(1,5),(1,6),(1,7),\n        (2,3),\n        (3,5),(3,6),(3,7),(3,8),\n        (4,6),(4,7),(4,8),\n        (6,8),\n        (7,8)\n    ]\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n    def valid_or_seed(sol):\n        if isinstance(sol, list) and len(sol) == n and all(isinstance(x, int) and x > 0 for x in sol):\n            return list(sol)\n        return [1,3,2,1,1,2,2,2,3]\n    def compress_labels(sol):\n        mapping = {}\n        nxt = 1\n        out = []\n        for x in sol:\n            if x not in mapping:\n                mapping[x] = nxt\n                nxt += 1\n            out.append(mapping[x])\n        return out\n    def kempe_chain_swap(sol, start_v, a, b):\n        if sol[start_v] not in (a, b):\n            return sol\n        from collections import deque\n        target = {a, b}\n        seen = set([start_v])\n        q = deque([start_v])\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if sol[u] in target and u not in seen:\n                    seen.add(u)\n                    q.append(u)\n        out = sol[:]\n        for v in seen:\n            out[v] = a if sol[v] == b else (b if sol[v] == a else sol[v])\n        return out\n    sol = compress_labels(valid_or_seed(solution))\n    k = max(sol)\n    # Apply 2-4 perturbation steps\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        if k >= 2 and random.random() < 0.7:\n            a, b = random.sample(range(1, k + 1), 2)\n            start_v = random.randrange(n)\n            sol = kempe_chain_swap(sol, start_v, a, b)\n        else:\n            edits = random.randint(2, 4)\n            for _ in range(edits):\n                v = random.randrange(n)\n                k = max(sol)\n                if random.random() < 0.15:\n                    sol[v] = k + 1\n                else:\n                    choices = [c for c in range(1, k + 1) if c != sol[v]]\n                    if choices:\n                        sol[v] = random.choice(choices)\n        sol = compress_labels(sol)\n        k = max(sol)\n    # Final normalization and sanitation\n    sol = compress_labels(sol)\n    for i in range(n):\n        if not isinstance(sol[i], int) or sol[i] <= 0:\n            sol[i] = 1\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import random, math\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    # Heavy penalties for malformed or conflicting assignments\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import random, math\n\n# Helper utilities fully local to avoid globals\n\ndef _edges():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adjacency():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canonical_relabel(sol):\n    # Relabel colors by first appearance to 1..k to reduce symmetry\n    mapping = {}\n    nextc = 1\n    out = []\n    for c in sol:\n        if c not in mapping:\n            mapping[c] = nextc\n            nextc += 1\n        out.append(mapping[c])\n    return out\n\ndef _is_conflict_free(sol):\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            return False\n    return True\n\ndef _used_colors(sol):\n    return sorted(set(sol))\n\ndef _dsatur_initial():\n    # DSATUR heuristic to build a low-color feasible solution\n    n = 9\n    adj = _adjacency()\n    colors = [0]*n\n    sat = [0]*n\n    uncolored = set(range(1,n+1))\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    while uncolored:\n        # pick vertex with max saturation, break ties by degree\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        forbid = neighbor_colors[v]\n        c = 1\n        while c in forbid:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canonical_relabel(colors)\n\ndef _valid_colors_for_vertex(sol, v, forbid_new_color=True):\n    # v is 1-based\n    adj = _adjacency()\n    neighbor_cols = set(sol[n-1] for n in adj[v])\n    used = set(sol)\n    candidates = [c for c in used if c not in neighbor_cols]\n    if not candidates and not forbid_new_color:\n        candidates = [max(used)+1]\n    return candidates\n\ndef _steepest_recolor(sol):\n    # Choose a vertex (prefer high conflicts \/ high degree) and assign best feasible color\n    n = 9\n    adj = _adjacency()\n    # conflict score per vertex\n    conf = [0]*n\n    for u,v in _edges():\n        if sol[u-1] == sol[v-1]:\n            conf[u-1] += 1\n            conf[v-1] += 1\n    # pick target\n    if any(conf):\n        v = max(range(1,n+1), key=lambda x: (conf[x-1], len(adj[x])))\n    else:\n        # intensification toward palette reduction: pick vertex in highest color class\n        colors = sorted(_used_colors(sol))\n        v = 1\n        if colors:\n            high = colors[-1]\n            # pick a vertex in the highest color class with largest degree\n            candidates = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(candidates, key=lambda x: len(adj[x]))\n    candidates = _valid_colors_for_vertex(sol, v, forbid_new_color=True)\n    if not candidates:\n        return sol[:]  # no move that avoids adding colors\n    # try to minimize conflicts and palette size\n    best = None\n    best_tuple = None\n    for c in sorted(candidates):\n        if c == sol[v-1]:\n            continue\n        trial = sol[:]\n        trial[v-1] = c\n        # score tuple: (conflicts, palette_size, color_value)\n        conflicts = 0\n        for u,w in _edges():\n            if trial[u-1] == trial[w-1]:\n                conflicts += 1\n        score = (conflicts, len(set(trial)), c)\n        if best is None or score < best_tuple:\n            best = trial\n            best_tuple = score\n    if best is None:\n        return sol[:]\n    return _canonical_relabel(best)\n\ndef _swap_palette(sol):\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    nb = [b if x == a else a if x == b else x for x in sol]\n    return _canonical_relabel(nb)\n\ndef _kempe_chain_swap(sol):\n    # Basic Kempe chain between two colors to escape plateaus\n    adj = _adjacency()\n    cols = _used_colors(sol)\n    if len(cols) < 2:\n        return sol[:]\n    a,b = random.sample(cols, 2)\n    # pick start vertex with color a or b\n    candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n    if not candidates:\n        return sol[:]\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    pair = {a, b}\n    while stack:\n        v = stack.pop()\n        if v in target_set:\n            continue\n        target_set.add(v)\n        for w in adj[v]:\n            if sol[w-1] in pair:\n                stack.append(w)\n    nb = sol[:]\n    for v in target_set:\n        nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n    return _canonical_relabel(nb)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_initial()\n    else:\n        base = _canonical_relabel(solution)\n    r = random.random()\n    if r < 0.55:\n        nb = _steepest_recolor(base)\n        move_t, move_s = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = _kempe_chain_swap(base)\n        move_t, move_s = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = _swap_palette(base)\n        move_t, move_s = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, move_t, move_s)\n","Perturbacion":"import random, math\n\ndef _edges_p():\n    return [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n\ndef _adj_p():\n    adj = {i: set() for i in range(1,10)}\n    for u,v in _edges_p():\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\ndef _canon(sol):\n    m = {}\n    k = 1\n    out = []\n    for c in sol:\n        if c not in m:\n            m[c] = k\n            k += 1\n        out.append(m[c])\n    return out\n\ndef _dsatur_seed():\n    n = 9\n    adj = _adj_p()\n    colors = [0]*n\n    neighbor_colors = {i:set() for i in range(1,n+1)}\n    uncolored = set(range(1,n+1))\n    while uncolored:\n        v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(adj[x])))\n        c = 1\n        while c in neighbor_colors[v]:\n            c += 1\n        colors[v-1] = c\n        uncolored.remove(v)\n        for w in adj[v]:\n            if colors[w-1] == 0:\n                neighbor_colors[w].add(c)\n    return _canon(colors)\n\ndef _random_feasible_recolor(sol):\n    # recolor a random vertex without introducing a new color\n    adj = _adj_p()\n    n = 9\n    i = random.randrange(n)\n    v = i+1\n    neighbor_cols = set(sol[w-1] for w in adj[v])\n    palette = list(set(sol))\n    options = [c for c in palette if c not in neighbor_cols]\n    if not options:\n        return sol[:]\n    cur = sol[i]\n    choices = [c for c in options if c != cur] or options\n    nb = sol[:]\n    nb[i] = random.choice(choices)\n    return _canon(nb)\n\ndef _palette_merge_attempt(sol, retries=3):\n    # Try to eliminate highest color by reassigning its vertices greedily with randomized order\n    colors = sorted(set(sol))\n    if len(colors) <= 1:\n        return sol[:]\n    high = colors[-1]\n    vertices = [i for i,c in enumerate(sol) if c == high]\n    if not vertices:\n        return sol[:]\n    order = vertices[:]\n    random.shuffle(order)\n    nb = sol[:]\n    adj = _adj_p()\n    for idx in order:\n        v = idx+1\n        neighbor_cols = set(nb[w-1] for w in adj[v])\n        candidates = [c for c in colors if c != high and c not in neighbor_cols]\n        if not candidates:\n            return sol[:]  # abort merge\n        nb[idx] = random.choice(candidates)\n    return _canon(nb)\n\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification: sequence of feasible recolors, optional Kempe-like relabel, and palette merge attempts\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    if not sol_ok:\n        base = _dsatur_seed()\n    else:\n        base = _canon(solution)\n    steps = max(3, len(base)\/\/2)\n    cur = base\n    for _ in range(steps):\n        cur = _random_feasible_recolor(cur)\n    # swap two colors with 0.5 probability\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = _canon([b if x==a else a if x==b else x for x in cur])\n    # attempt palette merge\n    if random.random() < 0.6:\n        cand = _palette_merge_attempt(cur)\n        cur = cand\n    return cur\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is positive int color for vertex i+1.","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10_000\n    if len(solution) != n:\n        return 10_000 + abs(len(solution) - n) * 1_000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1_000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10_000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Internal graph data and helpers\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def conflicts(sol):\n        cnt = 0\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def used_colors(sol):\n        return sorted(set(sol))\n\n    def valid_colors_for_vertex(sol, v):\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        return [c for c in set(sol) if c not in neighbor_cols]\n\n    def recolor_steepest(sol):\n        n = 9\n        conf = [0]*n\n        for u,v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                conf[u-1] += 1\n                conf[v-1] += 1\n        if any(conf):\n            v = max(range(1,n+1), key=lambda x: (conf[x-1], len(ADJ[x])))\n        else:\n            cols = used_colors(sol)\n            high = cols[-1] if cols else 1\n            cand = [i+1 for i,c in enumerate(sol) if c == high]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (conflicts(sol), len(set(sol)), sol[v-1])\n        for c in sorted(set(sol)):\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (conflicts(trial), len(set(trial)), c)\n            if key < best_key:\n                best = trial\n                best_key = key\n        return canon(best)\n\n    def kempe_chain_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        start_candidates = [i+1 for i,c in enumerate(sol) if c in (a,b)]\n        if not start_candidates:\n            return sol[:]\n        start = random.choice(start_candidates)\n        stack = [start]\n        seen = set()\n        pair = {a,b}\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in pair and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return canon(nb)\n\n    def palette_swap(sol):\n        cols = used_colors(sol)\n        if len(cols) < 2:\n            return sol[:]\n        a,b = random.sample(cols, 2)\n        return canon([b if x==a else a if x==b else x for x in sol])\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    base = canon(solution) if sol_ok else dsatur_seed()\n\n    r = random.random()\n    if r < 0.55:\n        nb = recolor_steepest(base)\n        mt, ms = \"Recolor\", \"Steepest\"\n    elif r < 0.8:\n        nb = kempe_chain_swap(base)\n        mt, ms = \"Kempe\", \"ChainSwap\"\n    else:\n        nb = palette_swap(base)\n        mt, ms = \"SwapColors\", \"PaletteRelabel\"\n    return (nb, mt, ms)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Strong but controlled diversification preserving feasibility when possible\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    def build_adj():\n        adj = {i: set() for i in range(1,10)}\n        for u,v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        n = 9\n        colors = [0]*n\n        neighbor_colors = {i:set() for i in range(1,n+1)}\n        uncolored = set(range(1,n+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def random_feasible_recolor(sol):\n        n = 9\n        i = random.randrange(n)\n        v = i+1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return canon(nb)\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        vertices = [i for i,c in enumerate(sol) if c == high]\n        if not vertices:\n            return sol[:]\n        order = vertices[:]\n        random.shuffle(order)\n        nb = sol[:]\n        for idx in order:\n            v = idx+1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    # Normalize\/seed\n    n = 9\n    sol_ok = isinstance(solution, list) and len(solution) == n and all(isinstance(x,int) and x>0 for x in solution)\n    cur = canon(solution) if sol_ok else dsatur_seed()\n\n    steps = max(3, len(cur)\/\/2)\n    for _ in range(steps):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5 and len(set(cur)) >= 2:\n        a,b = random.sample(sorted(set(cur)), 2)\n        cur = canon([b if x==a else a if x==b else x for x in cur])\n    if random.random() < 0.6:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_student_groups_standard","Representacion":"INDEX_LIST length=9; solution[i] is a positive int color for vertex (i+1).","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Lower is better; feasible solutions return number of used colors\n    n = 9\n    edges = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    if not isinstance(solution, list):\n        return 10000\n    if len(solution) != n:\n        return 10000 + abs(len(solution) - n) * 1000\n    penalty = 0\n    for x in solution:\n        if not isinstance(x, int) or x <= 0:\n            penalty += 1000\n    conflicts = 0\n    for (u, v) in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    used_colors = len(set(solution))\n    fitness = used_colors\n    if conflicts > 0 or penalty > 0:\n        fitness += 10000 + 100 * conflicts + penalty\n    return fitness\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        # Renumber colors to 1..k in order of first appearance\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def count_conflicts(sol):\n        cnt = 0\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                cnt += 1\n        return cnt\n\n    def recolor_conflict_steepest(sol):\n        # Choose vertex with max conflicts; try recolors from existing palette minimizing conflicts\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            v = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            # No conflicts: target highest color class to potentially reduce palette later\n            cols_sorted = sorted(set(sol))\n            target = cols_sorted[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == target]\n            v = max(cand, key=lambda x: len(ADJ[x])) if cand else 1\n        best = sol[:]\n        best_key = (count_conflicts(sol), len(set(sol)))\n        palette = sorted(set(sol))\n        for c in palette:\n            if c == sol[v-1]:\n                continue\n            trial = sol[:]\n            trial[v-1] = c\n            key = (count_conflicts(trial), len(set(trial)))\n            if key < best_key:\n                best = trial\n                best_key = key\n        return best\n\n    def color_elimination_attempt(sol):\n        # Try to eliminate the highest color class by relocating its vertices to lower feasible colors\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        order = verts[:]\n        random.shuffle(order)\n        nb = sol[:]\n        success = True\n        for idx in order:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c < high and c not in neighbor_cols]\n            if not candidates:\n                success = False\n                break\n            nb[idx] = random.choice(candidates)\n        if success:\n            # Drop the now-empty highest color and canonicalize\n            return canon(nb)\n        return sol[:]\n\n    def kempe_chain_biased(sol):\n        # Pick two colors biased toward highest color or conflict-heavy vertex\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        # Bias start vertex\n        nconf = [0]*N\n        for u, v in EDGES:\n            if sol[u-1] == sol[v-1]:\n                nconf[u-1] += 1\n                nconf[v-1] += 1\n        if any(nconf):\n            start = max(range(1, N+1), key=lambda x: (nconf[x-1], len(ADJ[x])))\n        else:\n            high = colors[-1]\n            cand = [i+1 for i, c in enumerate(sol) if c == high]\n            start = random.choice(cand) if cand else random.randint(1, N)\n        # Pick partner color\n        a = sol[start-1]\n        b = random.choice([c for c in colors if c != a])\n        # Build Kempe chain component containing start in subgraph induced by colors {a,b}\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    # Input repair\/normalization\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    base = solution[:] if sol_ok else dsatur_seed()\n\n    # Decide neighborhood based on state\n    confs = count_conflicts(base)\n    kcols = len(set(base))\n    r = random.random()\n    if confs > 0:\n        if r < 0.7:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"SteepestConflicts\")\n        else:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChain\")\n    else:\n        # Feasible: push palette reduction moves more often\n        if r < 0.55:\n            nb = color_elimination_attempt(base)\n            return (nb, \"ColorElim\", \"GreedyHighestDrop\")\n        elif r < 0.85:\n            nb = kempe_chain_biased(base)\n            return (nb, \"Kempe\", \"BiasedChainFeasible\")\n        else:\n            nb = recolor_conflict_steepest(base)\n            return (nb, \"Recolor\", \"TargetHighClass\")\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Diversification with controlled strength: Kempe kicks + random feasible recolors + optional palette merge\n    EDGES = [\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    ]\n    N = 9\n    def build_adj():\n        adj = {i: set() for i in range(1, N+1)}\n        for u, v in EDGES:\n            adj[u].add(v)\n            adj[v].add(u)\n        return adj\n    ADJ = build_adj()\n\n    def canon(sol):\n        m = {}\n        k = 1\n        out = []\n        for c in sol:\n            if c not in m:\n                m[c] = k\n                k += 1\n            out.append(m[c])\n        return out\n\n    def dsatur_seed():\n        colors = [0]*N\n        neighbor_colors = {i:set() for i in range(1,N+1)}\n        uncolored = set(range(1,N+1))\n        while uncolored:\n            v = max(uncolored, key=lambda x: (len(neighbor_colors[x]), len(ADJ[x])))\n            c = 1\n            while c in neighbor_colors[v]:\n                c += 1\n            colors[v-1] = c\n            uncolored.remove(v)\n            for w in ADJ[v]:\n                if colors[w-1] == 0:\n                    neighbor_colors[w].add(c)\n        return canon(colors)\n\n    def kempe_kick(sol):\n        colors = sorted(set(sol))\n        if len(colors) < 2:\n            return sol[:]\n        a, b = random.sample(colors, 2)\n        # choose a random start among vertices colored a or b\n        cand = [i+1 for i, c in enumerate(sol) if c in (a, b)]\n        if not cand:\n            return sol[:]\n        start = random.choice(cand)\n        stack = [start]\n        seen = set()\n        while stack:\n            v = stack.pop()\n            if v in seen:\n                continue\n            seen.add(v)\n            for w in ADJ[v]:\n                if sol[w-1] in (a, b) and w not in seen:\n                    stack.append(w)\n        nb = sol[:]\n        for v in seen:\n            nb[v-1] = a if sol[v-1] == b else (b if sol[v-1] == a else sol[v-1])\n        return nb\n\n    def random_feasible_recolor(sol):\n        i = random.randrange(N)\n        v = i + 1\n        neighbor_cols = set(sol[w-1] for w in ADJ[v])\n        palette = list(set(sol))\n        options = [c for c in palette if c not in neighbor_cols]\n        if not options:\n            return sol[:]\n        cur = sol[i]\n        choices = [c for c in options if c != cur] or options\n        nb = sol[:]\n        nb[i] = random.choice(choices)\n        return nb\n\n    def palette_merge_attempt(sol):\n        colors = sorted(set(sol))\n        if len(colors) <= 1:\n            return sol[:]\n        high = colors[-1]\n        verts = [i for i, c in enumerate(sol) if c == high]\n        if not verts:\n            return sol[:]\n        nb = sol[:]\n        random.shuffle(verts)\n        for idx in verts:\n            v = idx + 1\n            neighbor_cols = set(nb[w-1] for w in ADJ[v])\n            candidates = [c for c in colors if c != high and c not in neighbor_cols]\n            if not candidates:\n                return sol[:]\n            nb[idx] = random.choice(candidates)\n        return canon(nb)\n\n    sol_ok = isinstance(solution, list) and len(solution) == N and all(isinstance(x, int) and x > 0 for x in solution)\n    cur = solution[:] if sol_ok else dsatur_seed()\n\n    # Strength parameters\n    k_kicks = 2 + (1 if random.random() < 0.5 else 0)\n    k_recolors = 3\n\n    for _ in range(k_kicks):\n        cur = kempe_kick(cur)\n    for _ in range(k_recolors):\n        cur = random_feasible_recolor(cur)\n    if random.random() < 0.5:\n        cur = palette_merge_attempt(cur)\n    return cur\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Early exit on first violation; penalty dominates\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            return 1000000 + colors_used\n    return colors_used\n","Vecindad":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    adj = _adjacency()\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR\", \"feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR\", \"new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR\", \"conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol):\n    n = len(sol)\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    adj = _adjacency()\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP\", \"kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set()\n    stack = [start]\n    target_set.add(start)\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE\", \"component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol):\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP\", \"merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    adj = _adjacency()\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # If not feasible, try the reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in _adjacency()[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE\", \"color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, NB_Type, Movement_Type)\n\ndef generate_neighbour(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID\", \"NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID\", \"NOOP\"\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency():\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        # build component in {a,b}\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    n = 9\n    if len(solution) != n:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    # Canonicalize labels 1..m\n    mapping = {}\n    next_color = 1\n    compacted = [0]*n\n    for i, x in enumerate(solution):\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        compacted[i] = mapping[x]\n    colors_used = len(mapping)\n    # Graph edges (1-based)\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if compacted[u-1] == compacted[v-1]:\n            conflicts += 1\n    # Lexicographic objective: minimize conflicts first, then colors\n    return conflicts * 1000.0 + float(colors_used)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Helper: adjacency list for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Feasibility-aware recolor of a single vertex; allows new color with small prob\ndef _recolor_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    n = len(sol)\n    sol = _compact_labels(sol)\n    max_col = max(sol)\n    i = random.randrange(n)  # vertex index 0..8\n    v = i + 1  # 1-based vertex id\n    used_by_neigh = {sol[u-1] for u in adj[v]}\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible-1-change\"\n    # allow new color rarely to diversify\n    if random.random() < 0.2:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # fallback: conflict-tolerant recolor to an existing different color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    if not candidates:\n        sol[i] = 1\n    else:\n        sol[i] = random.choice(candidates)\n    return sol, \"RECOLOR|conflict-1-change\"\n\n# Kempe-chain swap between two colors\ndef _kempe_chain_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    a, b = random.sample(colors, 2)\n    # pick a random start vertex with color a or b\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    target_set = set([start])\n    stack = [start]\n    # Build connected component in subgraph induced by colors {a,b}\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in adj[v]:\n            j = u - 1\n            if sol[j] == a or sol[j] == b:\n                if j not in target_set:\n                    target_set.add(j)\n                    stack.append(j)\n    # Swap colors a<->b on the component\n    for j in target_set:\n        if sol[j] == a:\n            sol[j] = b\n        elif sol[j] == b:\n            sol[j] = a\n    return _compact_labels(sol), \"KEMPE|component-swap\"\n\n# Attempt to merge two colors (assign all of one color to the other if feasible)\ndef _merge_colors_move(sol: List[int], adj: dict) -> Tuple[List[int], str]:\n    sol = _compact_labels(sol)\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    a, b = random.sample(colors, 2)\n    # Try reassign all a-colored vertices to b if no conflicts\n    feasible = True\n    a_vertices = [i for i, c in enumerate(sol) if c == a]\n    for i in a_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == b:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in a_vertices:\n            sol[i] = b\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Try reverse direction\n    feasible = True\n    b_vertices = [i for i, c in enumerate(sol) if c == b]\n    for i in b_vertices:\n        v = i + 1\n        for u in adj[v]:\n            if sol[u-1] == a:\n                feasible = False\n                break\n        if not feasible:\n            break\n    if feasible:\n        for i in b_vertices:\n            sol[i] = a\n        return _compact_labels(sol), \"MERGE|color-merge\"\n    # Fallback to recolor move\n    return _recolor_move(sol, adj)\n\n# Public API\n# Must return (new_solution, move_tag) as 2-tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    adj = _adjacency()\n    move_r = random.random()\n    if move_r < 0.5:\n        return _recolor_move(solution, adj)\n    elif move_r < 0.8:\n        return _kempe_chain_move(solution, adj)\n    else:\n        return _merge_colors_move(solution, adj)\n","Perturbacion":"import random\nfrom typing import List\n\n# Helper: canonicalize labels to 1..m\ndef _compact_labels(sol: List[int]) -> List[int]:\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\n# Local adjacency for fixed graph\ndef _adjacency() -> dict:\n    n = 9\n    edges = (\n        (1,2),(1,7),(1,9),\n        (2,3),(2,6),(2,7),(2,8),\n        (3,4),\n        (4,6),(4,7),(4,8),(4,9),\n        (5,7),(5,8),(5,9),\n        (7,9),(8,9)\n    )\n    adj = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    return adj\n\n# Stronger shake combining multiple recolors and a Kempe swap\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(solution[:])\n    n = len(sol)\n    max_col = max(sol)\n    # Multi-vertex recolor\n    k = random.choice([3,4,5])\n    idxs = random.sample(range(n), k)\n    adj = _adjacency()\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in adj[v]}\n        # prefer existing colors not used by neighbors; allow new color with small prob\n        candidates = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if candidates:\n            sol[i] = random.choice(candidates)\n        else:\n            if random.random() < 0.3:\n                sol[i] = max_col + 1\n                max_col += 1\n            else:\n                # conflict-tolerant recolor\n                opts = [c for c in range(1, max_col+1) if c != sol[i]]\n                if opts:\n                    sol[i] = random.choice(opts)\n    # One Kempe chain swap on random color pair\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in adj[v]:\n                    j = u - 1\n                    if sol[j] == a or sol[j] == b:\n                        if j not in comp:\n                            comp.add(j)\n                            stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_13_taekwondo_tournament_standard","Representacion":"LIST9_POSINTS","Evaluacion":"import math\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helper: canonicalize labels to 1..m preserving relative class mapping\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef evaluate_solution(solution):\n    # Validate\n    if not isinstance(solution, list):\n        return float('inf')\n    if len(solution) != N:\n        return float('inf')\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return float('inf')\n    sol = _compact_labels(solution)\n    # Count colors\n    colors_used = len(set(sol))\n    # Count conflicts\n    conflicts = 0\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Lexicographic: conflicts first (dominates), then colors used\n    SCALE = 1000.0  # must exceed maximal colors used (<= N=9)\n    return conflicts * SCALE + float(colors_used)\n","Vecindad":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Moves\ndef _recolor_move(sol):\n    sol = _compact_labels(list(sol))\n    max_col = max(sol)\n    # Bias pick towards conflicted vertices\n    conflicted = _conflict_vertices(sol)\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        i = random.randrange(N)\n    v = i + 1\n    used_by_neigh = {sol[u-1] for u in ADJ[v]}\n    # Prefer feasible recolor using existing palette\n    candidate_colors = [c for c in range(1, max_col+1) if c != sol[i] and c not in used_by_neigh]\n    if candidate_colors:\n        sol[i] = random.choice(candidate_colors)\n        return sol, \"RECOLOR|feasible\"\n    # Allow new color only if conflicts persist\n    if conflicted and random.random() < 0.15:\n        sol[i] = max_col + 1\n        return _compact_labels(sol), \"RECOLOR|new-color\"\n    # Fallback: conflict-tolerant recolor to a different existing color\n    candidates = [c for c in range(1, max_col+1) if c != sol[i]]\n    sol[i] = random.choice(candidates) if candidates else 1\n    return sol, \"RECOLOR|fallback\"\n\ndef _kempe_chain_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|kempe-unavailable\"\n    # Prefer color pairs appearing on conflict edges\n    pair_counts = {}\n    for u, v in EDGES:\n        cu, cv = sol[u-1], sol[v-1]\n        if cu == cv:\n            continue\n        a, b = sorted((cu, cv))\n        pair_counts[(a, b)] = pair_counts.get((a, b), 0) + 1\n    if pair_counts:\n        (a, b) = random.choices(list(pair_counts.keys()), weights=list(pair_counts.values()))[0]\n    else:\n        a, b = random.sample(colors, 2)\n    candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n    if not candidates:\n        return sol, \"NOOP|kempe-empty\"\n    start = random.choice(candidates)\n    comp = set([start])\n    stack = [start]\n    while stack:\n        idx = stack.pop()\n        v = idx + 1\n        for u in ADJ[v]:\n            j = u - 1\n            if (sol[j] == a or sol[j] == b) and (j not in comp):\n                comp.add(j)\n                stack.append(j)\n    for j in comp:\n        sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    return _compact_labels(sol), \"KEMPE|swap\"\n\ndef _merge_colors_move(sol):\n    sol = _compact_labels(list(sol))\n    colors = sorted(set(sol))\n    if len(colors) < 2:\n        return sol, \"NOOP|merge-unavailable\"\n    # Try multiple pairs for a feasible full merge\n    pairs = [(a, b) for idx, a in enumerate(colors) for b in colors[idx+1:]]\n    random.shuffle(pairs)\n    for a, b in pairs:\n        # Try merge a -> b\n        ok = True\n        a_vertices = [i for i, c in enumerate(sol) if c == a]\n        for i in a_vertices:\n            v = i + 1\n            if any(sol[u-1] == b for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in a_vertices:\n                sol[i] = b\n            return _compact_labels(sol), \"MERGE|a->b\"\n        # Try merge b -> a\n        ok = True\n        b_vertices = [i for i, c in enumerate(sol) if c == b]\n        for i in b_vertices:\n            v = i + 1\n            if any(sol[u-1] == a for u in ADJ[v]):\n                ok = False\n                break\n        if ok:\n            for i in b_vertices:\n                sol[i] = a\n            return _compact_labels(sol), \"MERGE|b->a\"\n    # Fallback to recolor if no merge possible\n    return _recolor_move(sol)\n\n# Public API\n# Must return (new_solution, move_tag)\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution, \"INVALID|NOOP\"\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution, \"INVALID|NOOP\"\n    r = random.random()\n    if r < 0.5:\n        return _recolor_move(solution)\n    elif r < 0.8:\n        return _kempe_chain_move(solution)\n    else:\n        return _merge_colors_move(solution)\n","Perturbacion":"import random\n\n# Module-scope constants for performance\nN = 9\nEDGES = (\n    (1,2),(1,7),(1,9),\n    (2,3),(2,6),(2,7),(2,8),\n    (3,4),\n    (4,6),(4,7),(4,8),(4,9),\n    (5,7),(5,8),(5,9),\n    (7,9),(8,9)\n)\nADJ = {i: set() for i in range(1, N+1)}\nfor u, v in EDGES:\n    ADJ[u].add(v)\n    ADJ[v].add(u)\n\n# Helpers\ndef _compact_labels(sol):\n    mapping = {}\n    next_color = 1\n    out = []\n    for x in sol:\n        if x not in mapping:\n            mapping[x] = next_color\n            next_color += 1\n        out.append(mapping[x])\n    return out\n\ndef _conflict_vertices(sol):\n    conflicted = set()\n    for u, v in EDGES:\n        if sol[u-1] == sol[v-1]:\n            conflicted.add(u-1)\n            conflicted.add(v-1)\n    return list(conflicted)\n\n# Stronger shake: conflict-proportional multi-recolor + one Kempe swap + random relabel shuffle\n\ndef perturb_solution(solution):\n    if not isinstance(solution, list) or len(solution) != N:\n        return solution\n    for x in solution:\n        if not isinstance(x, int) or x < 1:\n            return solution\n    sol = _compact_labels(list(solution))\n    max_col = max(sol)\n    conflicted = _conflict_vertices(sol)\n    k = max(3, min(N, (len(conflicted) if conflicted else 3)))\n    idxs = random.sample(range(N), k)\n    for i in idxs:\n        v = i + 1\n        used = {sol[u-1] for u in ADJ[v]}\n        feasible = [c for c in range(1, max_col+1) if c != sol[i] and c not in used]\n        if feasible:\n            sol[i] = random.choice(feasible)\n        else:\n            # occasionally introduce a new color to escape deep basins\n            if random.random() < 0.25:\n                max_col += 1\n                sol[i] = max_col\n            else:\n                choices = [c for c in range(1, max_col+1) if c != sol[i]]\n                if choices:\n                    sol[i] = random.choice(choices)\n    # One Kempe chain swap\n    colors = sorted(set(sol))\n    if len(colors) >= 2:\n        a, b = random.sample(colors, 2)\n        candidates = [i for i, c in enumerate(sol) if c == a or c == b]\n        if candidates:\n            start = random.choice(candidates)\n            comp = set([start])\n            stack = [start]\n            while stack:\n                idx = stack.pop()\n                v = idx + 1\n                for u in ADJ[v]:\n                    j = u - 1\n                    if (sol[j] == a or sol[j] == b) and (j not in comp):\n                        comp.add(j)\n                        stack.append(j)\n            for j in comp:\n                sol[j] = a if sol[j] == b else (b if sol[j] == a else sol[j])\n    # Random relabel shuffle to diversify label identities without changing partition\n    mapping = {c: c for c in sorted(set(sol))}\n    new_labels = list(mapping.keys())\n    random.shuffle(new_labels)\n    remap = {old: new for old, new in zip(mapping.keys(), new_labels)}\n    sol = [remap[c] for c in sol]\n    return _compact_labels(sol)\n","Version":2}
