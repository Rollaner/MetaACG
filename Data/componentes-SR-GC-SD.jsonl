{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"list of length 9; index i corresponds to student i+1 and value is the assigned group ID (positive integer >=1). Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return float('inf')\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Conflict count\n    conflicts = 0\n    for a,b in edges:\n        if solution[a] == solution[b]:\n            conflicts += 1\n    # Number of groups used\n    k = len(set(solution))\n    # Heavy penalty for conflicts to enforce feasibility first; then minimize k\n    penalty_per_conflict = 1000000\n    cost = penalty_per_conflict * conflicts + k\n    return float(cost)","Vecindad":"import random\n\n# Returns (neighbour_solution, meta)\n# meta includes movement descriptors per local-search instrumentation needs\n\ndef generate_neighbour(solution):\n    # Defensive copy and validation\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution, {\"NB_Type\": \"Invalid\", \"Movement_Type\": \"NoMove\"}\n    s = solution[:]\n    n = 9\n    # Bias selection toward conflicted vertices if any\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    conflicted = set()\n    for a,b in edges:\n        if s[a] == s[b]:\n            conflicted.add(a)\n            conflicted.add(b)\n    if conflicted:\n        i = random.choice(list(conflicted))\n    else:\n        i = random.randrange(n)\n    current = s[i]\n    current_k = len(set(s))\n    # Candidate colors restricted to 1..current_k+1 excluding current\n    candidates = [c for c in range(1, current_k + 2) if c != current]\n    new_color = random.choice(candidates)\n    old_color = s[i]\n    s[i] = new_color\n    meta = {\n        \"NB_Type\": \"Recolor\",\n        \"Movement_Type\": \"Single\",\n        \"i\": i,\n        \"old_color\": old_color,\n        \"new_color\": new_color\n    }\n    return s, meta","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong perturbation: recolor 3 random vertices to random colors in [1..current_k+1]\n    if not isinstance(solution, list) or len(solution) != 9 or not all(isinstance(x, int) and x >= 1 for x in solution):\n        return solution\n    s = solution[:]\n    n = 9\n    moves = 3\n    idxs = random.sample(range(n), k=moves)\n    current_k = len(set(s))\n    for i in idxs:\n        candidates = list(range(1, current_k + 2))\n        s[i] = random.choice(candidates)\n        current_k = len(set(s))\n    return s","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"Python list of length 9 where index i corresponds to student i+1 and the value is the assigned group ID (positive int starting at 1). Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)):\n        return float('inf')\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Conflict count\n    conflicts = 0\n    for a,b in edges:\n        if solution[a] == solution[b]:\n            conflicts += 1\n    # Number of groups used\n    k = len(set(solution))\n    # Heavy penalty for conflicts; then minimize k\n    penalty_per_conflict = 1000000\n    cost = penalty_per_conflict * conflicts + k\n    return float(cost)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)):\n        return solution, \"Invalid\", \"NoMove\"\n    s = solution[:]\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Identify conflicted vertices\n    conflict_count = [0]*n\n    for a,b in edges:\n        if s[a] == s[b]:\n            conflict_count[a] += 1\n            conflict_count[b] += 1\n    if any(conflict_count):\n        max_conf = max(conflict_count)\n        candidates_i = [i for i,c in enumerate(conflict_count) if c == max_conf]\n        i = random.choice(candidates_i)\n    else:\n        i = random.randrange(n)\n    current = s[i]\n    current_k = len(set(s))\n    # Candidate colors 1..current_k+1 excluding current\n    palette = list(range(1, current_k + 2))\n    if current in palette:\n        palette.remove(current)\n    new_color = random.choice(palette)\n    s[i] = new_color\n    # Optional palette compaction: relabel colors to 1..k to reduce symmetry\n    # Build mapping based on first appearance\n    remap = {}\n    next_id = 1\n    for x in s:\n        if x not in remap:\n            remap[x] = next_id\n            next_id += 1\n    s = [remap[x] for x in s]\n    return s, \"Recolor\", \"Single\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)):\n        return solution\n    s = solution[:]\n    n = 9\n    moves = 3\n    idxs = random.sample(range(n), k=moves)\n    current_k = len(set(s))\n    for i in idxs:\n        candidates = list(range(1, current_k + 2))\n        s[i] = random.choice(candidates)\n        current_k = len(set(s))\n    # Normalize palette to 1..k\n    remap = {}\n    next_id = 1\n    for x in s:\n        if x not in remap:\n            remap[x] = next_id\n            next_id += 1\n    s = [remap[x] for x in s]\n    return s\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_standard","Representacion":"Python list of length 9 where index i corresponds to student i+1 and the value is the assigned group ID (positive int starting at 1). Example: [1,2,3,1,2,3,2,1,3].","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)):\n        return float('inf')\n    # Graph edges (0-based indices)\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Conflict count\n    conflicts = 0\n    for a,b in edges:\n        if solution[a] == solution[b]:\n            conflicts += 1\n    # Number of groups used\n    k = len(set(solution))\n    # Heavy penalty for conflicts; then minimize k\n    penalty_per_conflict = 1000000\n    cost = penalty_per_conflict * conflicts + k\n    return float(cost)\n","Vecindad":"import random\n\n# Returns only the neighbor solution (to avoid unpack errors). The return annotation is retained per required signature.\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)):\n        return solution\n    s = solution[:]\n    n = 9\n    edges = [\n        (0,1),(0,2),(0,6),(0,8),\n        (1,5),(1,8),\n        (2,3),(2,4),(2,6),\n        (3,4),(3,5),\n        (4,5),(4,7),\n        (5,6),(5,7),\n        (6,8),\n        (7,8)\n    ]\n    # Identify conflicted vertices\n    conflict_count = [0]*n\n    for a,b in edges:\n        if s[a] == s[b]:\n            conflict_count[a] += 1\n            conflict_count[b] += 1\n    # Choose a vertex: prioritize most conflicted; if none, random\n    if any(conflict_count):\n        max_conf = max(conflict_count)\n        candidates_i = [i for i,c in enumerate(conflict_count) if c == max_conf]\n        i = random.choice(candidates_i)\n    else:\n        i = random.randrange(n)\n    current_k = len(set(s))\n    # Candidate colors: 1..current_k+1 excluding current to allow expansion\/shrinkage\n    palette = list(range(1, current_k + 2))\n    if s[i] in palette:\n        palette.remove(s[i])\n    s[i] = random.choice(palette)\n    # Normalize palette to canonical 1..k based on first appearance to reduce symmetry\n    remap = {}\n    next_id = 1\n    for x in s:\n        if x not in remap:\n            remap[x] = next_id\n            next_id += 1\n    s = [remap[x] for x in s]\n    return s\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Validate input\n    if not (isinstance(solution, list) and len(solution) == 9 and all(isinstance(x, int) and x >= 1 for x in solution)):\n        return solution\n    s = solution[:]\n    n = 9\n    # Perform a stronger random perturbation: recolor t random vertices\n    t = 3\n    idxs = random.sample(range(n), k=min(t, n))\n    current_k = len(set(s))\n    for i in idxs:\n        candidates = list(range(1, current_k + 2))\n        s[i] = random.choice(candidates)\n        current_k = len(set(s))\n    # Canonicalize colors to 1..k\n    remap = {}\n    next_id = 1\n    for x in s:\n        if x not in remap:\n            remap[x] = next_id\n            next_id += 1\n    s = [remap[x] for x in s]\n    return s\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9; positive integers >=1; index i corresponds to participant i; example: \"2,1,3,1,2,3,1,1,3\"","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Internal problem data (undirected edges, 1-indexed participants)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Parse CSV string -> list of ints\n    try:\n        parts = [p.strip() for p in str(solution).split(',') if len(p.strip())>0]\n        if len(parts) != n:\n            return 10**9\n        assign = []\n        for p in parts:\n            v = int(p)\n            if v <= 0:\n                return 10**9\n            assign.append(v)\n    except Exception:\n        return 10**9\n    # Count conflicts\n    conflicts = 0\n    for u,v in edges:\n        if assign[u-1] == assign[v-1]:\n            conflicts += 1\n    # Number of rooms (colors) used (canonicalized via set size)\n    rooms_used = len(set(assign))\n    # Objective: minimize conflicts first, then rooms\n    score = conflicts*1000 + rooms_used\n    return int(score)\n","Vecindad":"def generate_neighbour(solution):\n    import random\n    # Helpers\n    def parse(sol):\n        parts = [p.strip() for p in str(sol).split(',') if len(p.strip())>0]\n        if len(parts) != 9:\n            # default feasible seed (3 rooms)\n            return [2,1,3,1,2,3,1,1,3]\n        out = []\n        for p in parts:\n            try:\n                v = int(p)\n                if v <= 0:\n                    return [2,1,3,1,2,3,1,1,3]\n                out.append(v)\n            except Exception:\n                return [2,1,3,1,2,3,1,1,3]\n        return out\n    def conflicts_of(assign):\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        conf = []\n        for (u,v) in edges:\n            if assign[u-1] == assign[v-1]:\n                conf.append((u-1,v-1))\n        return conf\n    def canonicalize(assign):\n        # Relabel colors to 1..k in order of first appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in assign:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def degree_list():\n        # degrees for heuristic choices\n        deg = [0]*9\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        for u,v in edges:\n            deg[u-1]+=1; deg[v-1]+=1\n        return deg\n    def neighbor_colors(i, assign):\n        edges_adj = {i: [] for i in range(9)}\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        for u,v in edges:\n            edges_adj[u-1].append(v-1)\n            edges_adj[v-1].append(u-1)\n        return [assign[j] for j in edges_adj[i]]\n    assign = parse(solution)\n    assign = canonicalize(assign)\n    k = max(assign) if assign else 3\n    k_cap = max(3, min(k+1, 5))  # cap palette growth to avoid explosion\n    conf_edges = conflicts_of(assign)\n    move_type = \"recolor\"\n    if conf_edges:\n        # Conflict-directed recoloring: pick a conflicted vertex with higher degree first\n        deg = degree_list()\n        u,v = random.choice(conf_edges)\n        i = u if deg[u] >= deg[v] else v\n        # Try least-conflicting color from [1..k_cap]\n        best_color = assign[i]\n        best_conf = 10**9\n        neigh_cols = neighbor_colors(i, assign)\n        for c in range(1, k_cap+1):\n            if c == assign[i]:\n                continue\n            confc = sum(1 for nc in neigh_cols if nc == c)\n            if confc < best_conf:\n                best_conf = confc\n                best_color = c\n        assign[i] = best_color\n        move_type = \"conflict_directed_recolor\"\n    else:\n        # No conflicts: try to reduce number of rooms by recoloring a vertex from the highest label\n        # Pick a vertex using the rarest color (highest label bias)\n        color_counts = {}\n        for c in assign:\n            color_counts[c] = color_counts.get(c,0)+1\n        # Choose a color to eliminate preference: highest label then smallest count\n        target_color = sorted(color_counts.items(), key=lambda x: (x[0], x[1]))[-1][0]\n        candidates = [i for i,c in enumerate(assign) if c == target_color]\n        if candidates:\n            i = random.choice(candidates)\n            # Try assign smallest feasible color different from target_color\n            neigh_cols = set(neighbor_colors(i, assign))\n            feasible = [c for c in range(1, max(1, target_color)) if c not in neigh_cols]\n            if feasible:\n                assign[i] = min(feasible)\n                move_type = \"room_reduction\"\n            else:\n                # fallback small diversification: swap labels of two existing colors\n                colors = sorted(set(assign))\n                if len(colors) >= 2:\n                    c1,c2 = random.sample(colors,2)\n                    assign = [c2 if x==c1 else (c1 if x==c2 else x) for x in assign]\n                    move_type = \"swap_two_colors\"\n                else:\n                    # minimal recolor within cap\n                    i = random.randrange(9)\n                    newc = assign[i]\n                    tries=0\n                    while newc==assign[i] and tries<10:\n                        newc = random.randint(1, k_cap)\n                        tries+=1\n                    assign[i]=newc\n                    move_type = \"recolor\"\n    assign = canonicalize(assign)\n    nb = ','.join(str(x) for x in assign)\n    return nb, move_type\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Parse and helpers shared with neighbour\n    def parse(sol):\n        parts = [p.strip() for p in str(sol).split(',') if len(p.strip())>0]\n        if len(parts) != 9:\n            return [2,1,3,1,2,3,1,1,3]\n        out = []\n        for p in parts:\n            try:\n                v = int(p)\n                if v <= 0:\n                    return [2,1,3,1,2,3,1,1,3]\n                out.append(v)\n            except Exception:\n                return [2,1,3,1,1,3,1,1,3]\n        return out\n    def canonicalize(assign):\n        mapping = {}\n        nextc = 1\n        out = []\n        for x in assign:\n            if x not in mapping:\n                mapping[x] = nextc\n                nextc += 1\n            out.append(mapping[x])\n        return out\n    def adj_list():\n        adj = {i: [] for i in range(9)}\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    assign = canonicalize(parse(solution))\n    k = max(assign) if assign else 3\n    k_cap = max(3, min(k+2, 5))\n    adj = adj_list()\n    # Kempe-like chain perturbation: pick two colors and flip along a BFS component\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        colors = sorted(set(assign))\n        if len(colors) < 2:\n            i = random.randrange(9)\n            assign[i] = random.randint(1, k_cap)\n            continue\n        c1, c2 = random.sample(colors if len(colors)>=2 else [1,2], 2)\n        start_vertices = [i for i,x in enumerate(assign) if x in (c1,c2)]\n        if not start_vertices:\n            continue\n        start = random.choice(start_vertices)\n        target_set = set([start])\n        queue = [start]\n        seen = set([start])\n        while queue:\n            u = queue.pop(0)\n            for v in adj[u]:\n                if v in seen:\n                    continue\n                if assign[v] in (c1,c2):\n                    seen.add(v)\n                    queue.append(v)\n                    target_set.add(v)\n        # flip c1<->c2 on the discovered component\n        for v in target_set:\n            assign[v] = c2 if assign[v] == c1 else (c1 if assign[v] == c2 else assign[v])\n        # occasional random recolor within cap to diversify\n        if random.random() < 0.3:\n            i = random.randrange(9)\n            newc = random.randint(1, k_cap)\n            assign[i] = newc\n        assign = canonicalize(assign)\n        k = max(assign)\n        k_cap = max(3, min(k+2, 5))\n    return ','.join(str(x) for x in canonicalize(assign))\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9; positive integers >=1; index i corresponds to participant i; example: 2,3,1,2,3,1,3,2,1","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Internal problem data (undirected edges, 1-indexed participants)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Parse CSV string -> list of ints\n    try:\n        parts = [p.strip() for p in str(solution).split(',') if len(p.strip())>0]\n        if len(parts) != n:\n            return 10**9\n        assign = []\n        for p in parts:\n            v = int(p)\n            if v <= 0:\n                return 10**9\n            assign.append(v)\n    except Exception:\n        return 10**9\n    # Count conflicts\n    conflicts = 0\n    for u,v in edges:\n        if assign[u-1] == assign[v-1]:\n            conflicts += 1\n    rooms_used = len(set(assign))\n    # Objective: minimize conflicts first, then rooms\n    score = conflicts*1000 + rooms_used\n    return int(score)","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    # Helpers\n    def parse(sol):\n        parts = [p.strip() for p in str(sol).split(',') if len(p.strip())>0]\n        if len(parts) != 9:\n            return [2,3,1,2,3,1,3,2,1]\n        out = []\n        for p in parts:\n            try:\n                v = int(p)\n                if v <= 0:\n                    return [2,3,1,2,3,1,3,2,1]\n                out.append(v)\n            except Exception:\n                return [2,3,1,2,3,1,3,2,1]\n        return out\n    def adj_list():\n        adj = {i: [] for i in range(9)}\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj, edges\n    def conflicts_of(assign, edges):\n        conf = []\n        for (u,v) in edges:\n            if assign[u-1] == assign[v-1]:\n                conf.append((u-1,v-1))\n        return conf\n    def degree_list():\n        deg = [0]*9\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        for u,v in edges:\n            deg[u-1]+=1; deg[v-1]+=1\n        return deg\n    def try_recolor(assign, i, newc, adj):\n        # Return new assignment if feasible (no added conflicts on neighbors), else None\n        old = assign[i]\n        if old == newc:\n            return None\n        for j in adj[i]:\n            if assign[j] == newc:\n                return None\n        out = assign[:]\n        out[i] = newc\n        return out\n    def eliminate_color(assign, target_color, adj):\n        colors = sorted(set(assign))\n        other_colors = [c for c in colors if c != target_color]\n        out = assign[:]\n        verts = [i for i,c in enumerate(assign) if c == target_color]\n        for i in verts:\n            # try assign to any other existing color with least neighbor conflicts\n            best = None\n            for c in other_colors:\n                if all(out[j] != c for j in adj[i]):\n                    best = c\n                    break\n            if best is None:\n                return None  # cannot eliminate\n            out[i] = best\n        # relabel to keep labels compact (remove gaps) while preserving others\n        mapping = {}\n        nextc = 1\n        for x in sorted(set(out), key=lambda z: z):\n            mapping[x] = nextc; nextc += 1\n        out = [mapping[x] for x in out]\n        return out\n    def kempe_flip(assign, c1, c2, start, adj):\n        # BFS over subgraph induced by colors c1,c2 and flip\n        n = len(assign)\n        seen = [False]*n\n        queue = [start]\n        seen[start] = True\n        comp = []\n        while queue:\n            u = queue.pop(0)\n            if assign[u] in (c1,c2):\n                comp.append(u)\n                for v in adj[u]:\n                    if not seen[v] and assign[v] in (c1,c2):\n                        seen[v] = True\n                        queue.append(v)\n        out = assign[:]\n        for v in comp:\n            out[v] = c2 if assign[v] == c1 else (c1 if assign[v] == c2 else out[v])\n        return out\n    assign = parse(solution)\n    adj, edges = adj_list()\n    conf_edges = conflicts_of(assign, edges)\n    k = max(assign) if assign else 3\n    k_cap = min(k+1, 9)\n    move_type = \"recolor\"\n    if conf_edges:\n        # Conflict-directed recoloring using higher-degree endpoint and least-conflict color\n        deg = degree_list()\n        u,v = random.choice(conf_edges)\n        i = u if deg[u] >= deg[v] else v\n        neigh_cols = {assign[j] for j in adj[i]}\n        # Candidate colors: existing plus possibly one new color (up to k_cap)\n        candidate_colors = list(sorted(set(assign)))\n        if max(candidate_colors) < k_cap:\n            candidate_colors.append(max(candidate_colors)+1)\n        # Exclude current color\n        candidate_colors = [c for c in candidate_colors if c != assign[i]]\n        best_c = None\n        best_conf = 10**9\n        for c in candidate_colors:\n            # count conflicts created on neighbors\n            confc = 0\n            for j in adj[i]:\n                if assign[j] == c:\n                    confc += 1\n            if confc < best_conf:\n                best_conf = confc\n                best_c = c\n        if best_c is not None:\n            assign[i] = best_c\n            move_type = \"conflict_directed_recolor\"\n        else:\n            # fallback: random recolor within cap\n            newc = assign[i]\n            tries = 0\n            while newc == assign[i] and tries < 10:\n                newc = random.randint(1, k_cap)\n                tries += 1\n            assign[i] = newc\n            move_type = \"random_recolor\"\n    else:\n        # No conflicts: attempt to reduce number of rooms by eliminating rarest color\n        color_counts = {}\n        for c in assign:\n            color_counts[c] = color_counts.get(c, 0) + 1\n        # choose rarest color (min count), tie-break by highest label\n        target_color = sorted(color_counts.items(), key=lambda x: (x[1], x[0]))[0][0]\n        reduced = eliminate_color(assign, target_color, adj)\n        if reduced is not None:\n            assign = reduced\n            move_type = \"room_reduction_eliminate_color\"\n        else:\n            # Kempe-chain interchange between two colors to diversify\n            colors = sorted(set(assign))\n            if len(colors) >= 2:\n                c1, c2 = random.sample(colors, 2)\n                candidates = [i for i,x in enumerate(assign) if x in (c1,c2)]\n                if candidates:\n                    start = random.choice(candidates)\n                    assign = kempe_flip(assign, c1, c2, start, adj)\n                    move_type = \"kempe_chain_flip\"\n            else:\n                # tiny random recolor within cap\n                i = random.randrange(9)\n                newc = random.randint(1, max(3, k_cap))\n                assign[i] = newc\n                move_type = \"random_recolor\"\n    nb = ','.join(str(x) for x in assign)\n    return nb, move_type","Perturbacion":"def perturb_solution(solution):\n    import random\n    # Parse\n    def parse(sol):\n        parts = [p.strip() for p in str(sol).split(',') if len(p.strip())>0]\n        if len(parts) != 9:\n            return [2,3,1,2,3,1,3,2,1]\n        out = []\n        for p in parts:\n            try:\n                v = int(p)\n                if v <= 0:\n                    return [2,3,1,2,3,1,3,2,1]\n                out.append(v)\n            except Exception:\n                return [2,3,1,2,3,1,3,2,1]\n        return out\n    def adj_list():\n        adj = {i: [] for i in range(9)}\n        edges = [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return adj\n    def kempe_flip(assign, c1, c2, start, adj):\n        seen = set([start])\n        queue = [start]\n        comp = []\n        while queue:\n            u = queue.pop(0)\n            if assign[u] in (c1,c2):\n                comp.append(u)\n                for v in adj[u]:\n                    if v not in seen and assign[v] in (c1,c2):\n                        seen.add(v)\n                        queue.append(v)\n        out = assign[:]\n        for v in comp:\n            out[v] = c2 if assign[v] == c1 else (c1 if assign[v] == c2 else out[v])\n        return out\n    assign = parse(solution)\n    adj = adj_list()\n    colors = sorted(set(assign))\n    k = max(colors) if colors else 3\n    k_cap = min(k+2, 9)\n    # Multi-step perturbation: mix random recolors of high-degree vertices and Kempe flips\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        # 50% Kempe, 50% random recolor within cap\n        if random.random() < 0.5 and len(colors) >= 2:\n            c1, c2 = random.sample(colors, 2)\n            pool = [i for i,x in enumerate(assign) if x in (c1,c2)]\n            if pool:\n                start = random.choice(pool)\n                assign = kempe_flip(assign, c1, c2, start, adj)\n        else:\n            i = random.randrange(9)\n            newc = random.randint(1, max(3, k_cap))\n            assign[i] = newc\n        colors = sorted(set(assign))\n        k = max(colors) if colors else 3\n        k_cap = min(k+2, 9)\n    return ','.join(str(x) for x in assign)","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_LEN9; positive integers >=1; index i corresponds to participant i; example: 2,3,1,2,3,1,3,2,1","Evaluacion":"def evaluate_solution(solution):\n    import math\n    # Internal problem data (undirected edges, 1-indexed participants)\n    edges = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    n = 9\n    # Parse CSV string -> list of ints\n    try:\n        parts = [p.strip() for p in str(solution).split(',') if len(p.strip())>0]\n        if len(parts) != n:\n            return 10**9\n        assign = []\n        for p in parts:\n            v = int(p)\n            if v <= 0:\n                return 10**9\n            assign.append(v)\n    except Exception:\n        return 10**9\n    # Count conflicts\n    conflicts = 0\n    for u,v in edges:\n        if assign[u-1] == assign[v-1]:\n            conflicts += 1\n    rooms_used = len(set(assign))\n    # Objective: minimize conflicts first, then rooms\n    score = conflicts*1000 + rooms_used\n    return int(score)\n","Vecindad":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    import random\n    from collections import deque\n\n    # Problem graph (internal)\n    EDGES = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    N = 9\n\n    def build_adj():\n        adj = {i: [] for i in range(N)}\n        for u,v in EDGES:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    ADJ = build_adj()\n\n    def parse_or_dsatur(sol_str):\n        # Try parse; if invalid, return DSATUR greedy 3-coloring seed\n        parts = [p.strip() for p in str(sol_str).split(',') if len(p.strip())>0]\n        valid = True\n        assign = []\n        if len(parts) != N:\n            valid = False\n        else:\n            for p in parts:\n                try:\n                    v = int(p)\n                    if v <= 0:\n                        valid = False\n                        break\n                    assign.append(v)\n                except Exception:\n                    valid = False\n                    break\n        if valid:\n            return assign, False\n        # DSATUR greedy coloring\n        colors = [0]*N\n        degrees = [len(ADJ[i]) for i in range(N)]\n        used = set()\n        for _ in range(N):\n            # pick uncolored with max saturation, tiebreak by degree\n            sat = []\n            for i in range(N):\n                if colors[i] == 0:\n                    neigh_cols = {colors[j] for j in ADJ[i] if colors[j] != 0}\n                    sat.append((len(neigh_cols), degrees[i], i))\n            if not sat:\n                break\n            sat.sort(reverse=True)\n            _, _, u = sat[0]\n            neigh_cols = {colors[j] for j in ADJ[u] if colors[j] != 0}\n            c = 1\n            while c in neigh_cols:\n                c += 1\n            colors[u] = c\n            used.add(c)\n        # Normalize labels to 1..k\n        mapping = {}\n        nxt = 1\n        for c in sorted(set(colors)):\n            mapping[c] = nxt\n            nxt += 1\n        colors = [mapping[c] for c in colors]\n        return colors, True\n\n    def normalize(assign):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in assign:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts(assign):\n        return [(u-1,v-1) for (u,v) in EDGES if assign[u-1] == assign[v-1]]\n\n    def dsat_value(i, assign):\n        return len({assign[j] for j in ADJ[i]})\n\n    def kempe_flip(assign, c1, c2, start):\n        q = deque([start])\n        seen = {start}\n        comp = []\n        while q:\n            u = q.popleft()\n            if assign[u] in (c1,c2):\n                comp.append(u)\n                for v in ADJ[u]:\n                    if v not in seen and assign[v] in (c1,c2):\n                        seen.add(v)\n                        q.append(v)\n        out = assign[:]\n        for v in comp:\n            out[v] = c2 if assign[v] == c1 else (c1 if assign[v] == c2 else out[v])\n        return out\n\n    def try_recolor_min_conf(assign, i, palette, allow_same=False):\n        best = None\n        best_inc = 10**9\n        cur = assign[i]\n        for c in palette:\n            if not allow_same and c == cur:\n                continue\n            inc = 0\n            for j in ADJ[i]:\n                if assign[j] == c:\n                    inc += 1\n            if inc < best_inc:\n                # ensure feasibility preference\n                best_inc = inc\n                best = c\n        if best is None or (best == cur and not allow_same):\n            return None\n        out = assign[:]\n        out[i] = best\n        return out\n\n    assign, sanitized = parse_or_dsatur(solution)\n    assign = normalize(assign)\n\n    conf = conflicts(assign)\n    move_type = \"none\"\n    k = max(assign)\n\n    if conf:\n        # Choose conflicting vertex by DSATUR among endpoints\n        cand = set()\n        for u,v in conf:\n            cand.add(u); cand.add(v)\n        cand = list(cand)\n        cand.sort(key=lambda i: (dsat_value(i, assign), len(ADJ[i])), reverse=True)\n        i = cand[0]\n        palette = sorted(set(assign))\n        # Try recolor within current palette first\n        nb1 = try_recolor_min_conf(assign, i, palette)\n        if nb1 is not None and nb1 != assign and len(conflicts(nb1)) <= len(conf):\n            assign = nb1\n            move_type = \"conflict_recolor_in_palette\"\n        else:\n            # Try Kempe chain with best alternate color\n            if len(palette) >= 2:\n                # choose target color that minimizes conflicts after flip\n                best_nb = None\n                best_c = None\n                best_score = 10**9\n                for c2 in palette:\n                    if c2 == assign[i]:\n                        continue\n                    trial = kempe_flip(assign, assign[i], c2, i)\n                    score = len(conflicts(trial))\n                    if score < best_score:\n                        best_score = score\n                        best_nb = trial\n                        best_c = c2\n                if best_nb is not None and best_score <= len(conf):\n                    assign = best_nb\n                    move_type = f\"kempe_flip_to_{best_c}\"\n                else:\n                    # Allow temporary expansion by one color\n                    newc = max(palette)+1\n                    assign[i] = newc\n                    move_type = \"conflict_expand_palette\"\n            else:\n                assign[i] = 2\n                move_type = \"conflict_trivial_expand\"\n    else:\n        # No conflicts: attempt to reduce number of rooms by eliminating highest label color\n        palette = sorted(set(assign))\n        if len(palette) > 1:\n            target_color = max(palette)\n            verts = [i for i,c in enumerate(assign) if c == target_color]\n            success = True\n            for i in verts:\n                # Try recolor into existing colors except target_color avoiding conflicts\n                ok = False\n                for c in palette:\n                    if c == target_color:\n                        continue\n                    if all(assign[j] != c for j in ADJ[i]):\n                        assign[i] = c\n                        ok = True\n                        break\n                if not ok:\n                    success = False\n                    break\n            if success:\n                assign = normalize(assign)\n                move_type = \"room_reduction_eliminate_highest\"\n            else:\n                # Diversify via Kempe flip between two random colors\n                if len(palette) >= 2:\n                    c1, c2 = random.sample(palette, 2)\n                    candidates = [i for i,x in enumerate(assign) if x in (c1,c2)]\n                    if candidates:\n                        start = random.choice(candidates)\n                        assign = kempe_flip(assign, c1, c2, start)\n                        move_type = \"kempe_chain_diversify\"\n                else:\n                    # Minor random recolor within current palette\n                    i = random.randrange(N)\n                    assign[i] = random.choice(palette)\n                    move_type = \"random_small_jitter\"\n        else:\n            # Only one color exists; expand minimally to escape\n            i = random.randrange(N)\n            assign[i] = 2\n            move_type = \"expand_from_single_color\"\n\n    assign = normalize(assign)\n    nb = ','.join(str(x) for x in assign)\n    if sanitized and move_type == \"none\":\n        move_type = \"sanitize_default_if_invalid\"\n    return nb, move_type\n","Perturbacion":"def perturb_solution(solution):\n    import random\n    from collections import deque\n\n    EDGES = [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n    N = 9\n\n    def build_adj():\n        adj = {i: [] for i in range(N)}\n        for u,v in EDGES:\n            u -= 1; v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        return adj\n\n    ADJ = build_adj()\n\n    def parse_or_seed(sol_str):\n        parts = [p.strip() for p in str(sol_str).split(',') if len(p.strip())>0]\n        if len(parts) != N:\n            # simple 3-color seed\n            return [2,1,3,2,1,3,1,2,3]\n        out = []\n        try:\n            for p in parts:\n                v = int(p)\n                if v <= 0:\n                    return [2,1,3,2,1,3,1,2,3]\n                out.append(v)\n            return out\n        except Exception:\n            return [2,1,3,2,1,3,1,2,3]\n\n    def normalize(assign):\n        mapping = {}\n        nxt = 1\n        out = []\n        for c in assign:\n            if c not in mapping:\n                mapping[c] = nxt\n                nxt += 1\n            out.append(mapping[c])\n        return out\n\n    def kempe_flip(assign, c1, c2, start):\n        q = deque([start])\n        seen = {start}\n        comp = []\n        while q:\n            u = q.popleft()\n            if assign[u] in (c1,c2):\n                comp.append(u)\n                for v in ADJ[u]:\n                    if v not in seen and assign[v] in (c1,c2):\n                        seen.add(v)\n                        q.append(v)\n        out = assign[:]\n        for v in comp:\n            out[v] = c2 if assign[v] == c1 else (c1 if assign[v] == c2 else out[v])\n        return out\n\n    def degree_order():\n        return sorted(range(N), key=lambda i: len(ADJ[i]), reverse=True)\n\n    assign = parse_or_seed(solution)\n    assign = normalize(assign)\n\n    # Multi-step perturbation combining Kempe flips and recolors\n    steps = random.randint(2, 4)\n    for _ in range(steps):\n        palette = sorted(set(assign))\n        r = random.random()\n        if r < 0.5 and len(palette) >= 2:\n            # Kempe flip on a high-degree vertex between two random colors\n            i = random.choice(degree_order()[:5])  # bias to higher degree\n            if assign[i] not in palette:\n                palette = sorted(set(assign))\n            if len(palette) >= 2:\n                c1 = assign[i]\n                c2 = random.choice([c for c in palette if c != c1])\n                assign = kempe_flip(assign, c1, c2, i)\n        elif r < 0.85:\n            # Random recolor within current or expanded palette by +1\n            i = random.randrange(N)\n            candidate = sorted(set(assign))\n            if random.random() < 0.3:\n                candidate.append(max(candidate)+1)\n            assign[i] = random.choice(candidate)\n        else:\n            # Swap colors of two vertices to reshuffle usage\n            i, j = random.sample(range(N), 2)\n            assign[i], assign[j] = assign[j], assign[i]\n        assign = normalize(assign)\n\n    return ','.join(str(x) for x in assign)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN_9_COLORS_IN_[1..K]","Evaluacion":"import math\nimport random\n\ndef _parse_solution_eval(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n    if isinstance(solution, list):\n        return [int(x) for x in solution]\n    raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\ndef _graph_edges_eval():\n    # Undirected edges with 1-indexed vertices\n    return [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_eval(solution)\n    n = 9\n    if len(sol) != n:\n        raise ValueError(f\"Solution must have length {n}\")\n    if any((not isinstance(c,int)) or c < 1 for c in sol):\n        raise ValueError(\"All colors must be integers >= 1\")\n    edges = _graph_edges_eval()\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol) if sol else 0\n    # Minimize conflicts first (heavy), then number of colors\n    cost = conflicts * 1000 + k\n    return float(cost)\n","Vecindad":"import random\n\ndef _parse_solution_nb(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        return [int(p) for p in parts], 'str'\n    if isinstance(solution, list):\n        return [int(x) for x in solution], 'list'\n    raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\ndef _serialize_solution_nb(sol_list, t):\n    if t == 'str':\n        return ','.join(str(x) for x in sol_list)\n    return sol_list\n\ndef _graph_edges_nb():\n    return [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\ndef _conflict_count_vertex(sol, v, color, edges):\n    # v is 0-indexed; edges are 1-indexed\n    cnt = 0\n    for u,w in edges:\n        if u-1 == v:\n            if color == sol[w-1]:\n                cnt += 1\n        elif w-1 == v:\n            if color == sol[u-1]:\n                cnt += 1\n    return cnt\n\ndef _current_conflicts(sol, edges):\n    conflicts = set()\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts.add(u-1)\n            conflicts.add(v-1)\n    return conflicts\n\ndef _compact_palette(sol):\n    unique = sorted(set(sol))\n    mapping = {c: i+1 for i, c in enumerate(unique)}\n    return [mapping[c] for c in sol]\n\n# Signature must be exactly the required name and argument; return neighbor and metadata\ndef generate_neighbour(solution):\n    sol, sol_type = _parse_solution_nb(solution)\n    n = len(sol)\n    if n == 0:\n        return (_serialize_solution_nb(sol, sol_type), (\"NoOp\", \"Empty\"))\n    edges = _graph_edges_nb()\n    conflicts = _current_conflicts(sol, edges)\n    k = max(sol) if sol else 1\n\n    move_type = None\n\n    if conflicts:\n        # Min-conflicts recolor on a randomly chosen conflicted vertex\n        v = random.choice(list(conflicts))\n        # Candidate colors: existing 1..k, and optionally k+1 with small prob\n        introduce_new = random.random() < 0.1\n        candidates = list(range(1, k+1)) + ([k+1] if introduce_new else [])\n        best_color = sol[v]\n        best_score = 10**9\n        for c in candidates:\n            score = _conflict_count_vertex(sol, v, c, edges)\n            if score < best_score and c != sol[v]:\n                best_score = score\n                best_color = c\n        new_sol = sol[:]\n        new_sol[v] = best_color\n        move_type = (\"MinConflicts\", \"SingleVertexRecolor\")\n    else:\n        # Palette compaction or mild color swap to try reducing k\n        # Try swapping labels of two colors if k>1\n        if k > 1 and random.random() < 0.5:\n            a, b = random.sample(range(1, k+1), 2)\n            new_sol = [b if x == a else a if x == b else x for x in sol]\n            move_type = (\"LabelSwap\", \"GlobalSwap\")\n        else:\n            # Random recolor a non-conflicted vertex to an existing color to test compaction\n            idx = random.randrange(n)\n            choices = [c for c in range(1, k+1) if c != sol[idx]]\n            if choices:\n                c = random.choice(choices)\n                new_sol = sol[:]\n                new_sol[idx] = c\n            else:\n                new_sol = sol[:]\n            move_type = (\"Exploration\", \"RandomRecolor\")\n\n    new_sol = _compact_palette(new_sol)\n    return (_serialize_solution_nb(new_sol, sol_type), move_type)\n","Perturbacion":"import random\n\ndef _parse_solution_pt(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        return [int(p) for p in parts], 'str'\n    if isinstance(solution, list):\n        return [int(x) for x in solution], 'list'\n    raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\ndef _serialize_solution_pt(sol_list, t):\n    if t == 'str':\n        return ','.join(str(x) for x in sol_list)\n    return sol_list\n\ndef _graph_edges_pt():\n    return [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\ndef _conflict_vertices_pt(sol, edges):\n    s = set()\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            s.add(u-1); s.add(v-1)\n    return list(s)\n\ndef _vertex_conflicts_pt(sol, v, color, edges):\n    cnt = 0\n    for u,w in edges:\n        if u-1 == v:\n            if color == sol[w-1]:\n                cnt += 1\n        elif w-1 == v:\n            if color == sol[u-1]:\n                cnt += 1\n    return cnt\n\ndef _compact_palette_pt(sol):\n    uniq = sorted(set(sol))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping[c] for c in sol]\n\ndef perturb_solution(solution):\n    sol, sol_type = _parse_solution_pt(solution)\n    n = len(sol)\n    if n == 0:\n        return _serialize_solution_pt(sol, sol_type)\n    edges = _graph_edges_pt()\n    k = max(sol) if sol else 1\n\n    # 1) Kempe-like color swap on two random colors over a random subset\n    if k > 1:\n        a, b = random.sample(range(1, k+1), 2)\n        mask = [i for i,x in enumerate(sol) if x == a or x == b]\n        random.shuffle(mask)\n        depth = max(1, len(mask)\/\/3)\n        for i in mask[:depth]:\n            sol[i] = a if sol[i] == b else b\n\n    # 2) Recolor ~30% of vertices (biased to conflicted if any) with min-conflicts\n    m = max(1, n\/\/3)\n    conflicted = _conflict_vertices_pt(sol, edges)\n    pool = conflicted if conflicted else list(range(n))\n    random.shuffle(pool)\n    sel = pool[:m]\n    for v in sel:\n        candidates = list(range(1, max(1, max(sol)) + 1))\n        if random.random() < 0.2:\n            candidates.append(max(sol)+1)\n        best = sol[v]\n        best_score = 10**9\n        for c in candidates:\n            s = _vertex_conflicts_pt(sol, v, c, edges)\n            if s < best_score and c != sol[v]:\n                best_score = s\n                best = c\n        sol[v] = best\n\n    sol = _compact_palette_pt(sol)\n    return _serialize_solution_pt(sol, sol_type)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN_9_COLORS_IN_[1..K]","Evaluacion":"import math\nimport random\n\ndef _parse_solution_eval(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n    if isinstance(solution, list):\n        return [int(x) for x in solution]\n    raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\ndef _graph_edges_eval():\n    # Undirected edges with 1-indexed vertices\n    return [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\ndef evaluate_solution(solution):\n    sol = _parse_solution_eval(solution)\n    n = 9\n    if len(sol) != n:\n        raise ValueError(f\"Solution must have length {n}\")\n    if any((not isinstance(c,int)) or c < 1 for c in sol):\n        raise ValueError(\"All colors must be integers >= 1\")\n    edges = _graph_edges_eval()\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol) if sol else 0\n    # Lower is better: penalize conflicts heavily, then number of colors\n    cost = conflicts * 1000 + k\n    return float(cost)\n","Vecindad":"import random\n\ndef _parse_solution_nb(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        return [int(p) for p in parts], 'str'\n    if isinstance(solution, list):\n        return [int(x) for x in solution], 'list'\n    raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\ndef _serialize_solution_nb(sol_list, t):\n    if t == 'str':\n        return ','.join(str(x) for x in sol_list)\n    return sol_list\n\ndef _graph_edges_nb():\n    return [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\ndef _conflict_count_vertex_nb(sol, v, color, edges):\n    cnt = 0\n    for u,w in edges:\n        if u-1 == v:\n            if color == sol[w-1]:\n                cnt += 1\n        elif w-1 == v:\n            if color == sol[u-1]:\n                cnt += 1\n    return cnt\n\ndef _current_conflicts_vertices_nb(sol, edges):\n    freq = {}\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            freq[u-1] = freq.get(u-1, 0) + 1\n            freq[v-1] = freq.get(v-1, 0) + 1\n    return freq  # dict: vertex->conflict degree\n\ndef _compact_palette_nb(sol):\n    unique = sorted(set(sol))\n    mapping = {c: i+1 for i, c in enumerate(unique)}\n    return [mapping[c] for c in sol]\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    sol, sol_type = _parse_solution_nb(solution)\n    n = len(sol)\n    if n == 0:\n        return (_serialize_solution_nb(sol, sol_type), (\"NoOp\", \"Empty\"))\n    edges = _graph_edges_nb()\n    conf_deg = _current_conflicts_vertices_nb(sol, edges)\n    k = max(sol) if sol else 1\n\n    if conf_deg:\n        # Weighted pick by conflict degree (higher weight -> more likely)\n        vertices = list(conf_deg.keys())\n        weights = [conf_deg[v] for v in vertices]\n        total = sum(weights)\n        r = random.uniform(0, total)\n        acc = 0.0\n        v = vertices[0]\n        for idx, w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                v = vertices[idx]\n                break\n        # Try recoloring v to minimize its local conflicts using existing palette only\n        current_color = sol[v]\n        best_color = current_color\n        best_score = _conflict_count_vertex_nb(sol, v, current_color, edges)\n        for c in range(1, k+1):\n            if c == current_color:\n                continue\n            score = _conflict_count_vertex_nb(sol, v, c, edges)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        # If no improvement exists among existing colors, very rarely introduce k+1\n        # to escape stalemate when heavily conflicted\n        if best_color == current_color:\n            if random.random() < 0.05:\n                best_color = k + 1\n        new_sol = sol[:]\n        new_sol[v] = best_color\n        move_type = (\"MinConflicts\", \"WeightedSingleVertexRecolor\")\n    else:\n        # No conflicts: attempt to reduce number of colors via targeted recolor\n        # Pick a vertex from the highest color class and try to move it to existing colors\n        k = max(sol) if sol else 1\n        if k > 1:\n            candidates_idx = [i for i, x in enumerate(sol) if x == k]\n            if not candidates_idx:\n                candidates_idx = list(range(n))\n            v = random.choice(candidates_idx)\n            current_color = sol[v]\n            target_colors = [c for c in range(1, k) if c != current_color]\n            random.shuffle(target_colors)\n            picked = current_color\n            best_score = _conflict_count_vertex_nb(sol, v, current_color, edges)\n            for c in target_colors:\n                s = _conflict_count_vertex_nb(sol, v, c, edges)\n                if s == 0:  # keep feasibility\n                    picked = c\n                    best_score = 0\n                    break\n            new_sol = sol[:]\n            new_sol[v] = picked\n            move_type = (\"PaletteCompaction\", \"MoveFromMaxColorClass\")\n        else:\n            # Trivial exploration\n            idx = random.randrange(n)\n            new_sol = sol[:]\n            new_sol[idx] = 1\n            move_type = (\"Exploration\", \"NoOpColor\")\n\n    new_sol = _compact_palette_nb(new_sol)\n    return (_serialize_solution_nb(new_sol, sol_type), move_type)\n","Perturbacion":"import random\n\ndef _parse_solution_pt(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        return [int(p) for p in parts], 'str'\n    if isinstance(solution, list):\n        return [int(x) for x in solution], 'list'\n    raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\ndef _serialize_solution_pt(sol_list, t):\n    if t == 'str':\n        return ','.join(str(x) for x in sol_list)\n    return sol_list\n\ndef _graph_edges_pt():\n    return [\n        (1,2),(1,3),(1,7),(1,9),\n        (2,6),(2,9),\n        (3,4),(3,5),(3,7),\n        (4,5),(4,6),\n        (5,6),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]\n\ndef _vertex_conflicts_pt(sol, v, color, edges):\n    cnt = 0\n    for u,w in edges:\n        if u-1 == v:\n            if color == sol[w-1]:\n                cnt += 1\n        elif w-1 == v:\n            if color == sol[u-1]:\n                cnt += 1\n    return cnt\n\ndef _conflicted_vertices_pt(sol, edges):\n    s = set()\n    for u,v in edges:\n        if sol[u-1] == sol[v-1]:\n            s.add(u-1); s.add(v-1)\n    return list(s)\n\ndef _compact_palette_pt(sol):\n    uniq = sorted(set(sol))\n    mapping = {c:i+1 for i,c in enumerate(uniq)}\n    return [mapping[c] for c in sol]\n\ndef perturb_solution(solution):\n    sol, sol_type = _parse_solution_pt(solution)\n    n = len(sol)\n    if n == 0:\n        return _serialize_solution_pt(sol, sol_type)\n    edges = _graph_edges_pt()\n    k = max(sol) if sol else 1\n\n    # Step 1: Kempe-like partial swap between two random colors to shake structure\n    if k > 1:\n        a, b = random.sample(range(1, k+1), 2)\n        nodes = [i for i,x in enumerate(sol) if x == a or x == b]\n        random.shuffle(nodes)\n        depth = max(1, len(nodes)\/\/3)\n        for i in nodes[:depth]:\n            sol[i] = a if sol[i] == b else b\n\n    # Step 2: Recolor a subset (about one third) using local min-conflicts\n    m = max(1, n\/\/3)\n    pool = _conflicted_vertices_pt(sol, edges)\n    if not pool:\n        pool = list(range(n))\n    random.shuffle(pool)\n    for v in pool[:m]:\n        current = sol[v]\n        best = current\n        best_score = _vertex_conflicts_pt(sol, v, current, edges)\n        for c in range(1, max(1, max(sol)) + 1):\n            if c == current:\n                continue\n            s = _vertex_conflicts_pt(sol, v, c, edges)\n            if s < best_score:\n                best_score = s\n                best = c\n        # Very rarely allow a new color if nothing helps\n        if best == current and random.random() < 0.05:\n            best = max(sol) + 1\n        sol[v] = best\n\n    sol = _compact_palette_pt(sol)\n    return _serialize_solution_pt(sol, sol_type)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_standard","Representacion":"CSV_INT_LIST_LEN_9_COLORS_IN_[1..K]","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    def _parse_solution_eval(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            return [int(p) for p in parts]\n        if isinstance(sol, list):\n            return [int(x) for x in sol]\n        raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n\n    sol = _parse_solution_eval(solution)\n    n = 9\n    if len(sol) != n:\n        raise ValueError(f\"Solution must have length {n}\")\n    if any((not isinstance(c,int)) or c < 1 for c in sol):\n        raise ValueError(\"All colors must be integers >= 1\")\n\n    edges = _edges()\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    k = max(sol) if sol else 0\n    cost = conflicts * 1000 + k\n    return float(cost)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    def _parse_solution_nb(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            return [int(p) for p in parts], 'str'\n        if isinstance(sol, list):\n            return [int(x) for x in sol], 'list'\n        raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\n    def _serialize_solution_nb(sol_list, t):\n        if t == 'str':\n            return ','.join(str(x) for x in sol_list)\n        return sol_list\n\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n\n    def _vertex_conflicts(sol, v, color, edges):\n        cnt = 0\n        for u,w in edges:\n            if u-1 == v:\n                if color == sol[w-1]:\n                    cnt += 1\n            elif w-1 == v:\n                if color == sol[u-1]:\n                    cnt += 1\n        return cnt\n\n    def _current_conflict_degrees(sol, edges):\n        freq = {}\n        for u,v in edges:\n            if sol[u-1] == sol[v-1]:\n                freq[u-1] = freq.get(u-1, 0) + 1\n                freq[v-1] = freq.get(v-1, 0) + 1\n        return freq\n\n    def _compact_palette(sol):\n        unique = sorted(set(sol))\n        mapping = {c: i+1 for i, c in enumerate(unique)}\n        return [mapping[c] for c in sol]\n\n    sol, sol_type = _parse_solution_nb(solution)\n    n = len(sol)\n    edges = _edges()\n    if n == 0:\n        return _serialize_solution_nb(sol, sol_type), (\"NoOp\",\"Empty\")\n\n    conf_deg = _current_conflict_degrees(sol, edges)\n    k = max(sol) if sol else 1\n\n    if conf_deg:\n        # Select a conflicted vertex with probability proportional to its conflict degree\n        vertices = list(conf_deg.keys())\n        weights = [conf_deg[v] for v in vertices]\n        total = float(sum(weights))\n        r = random.uniform(0.0, total)\n        acc = 0.0\n        v = vertices[0]\n        for idx, w in enumerate(weights):\n            acc += w\n            if r <= acc:\n                v = vertices[idx]\n                break\n        current_color = sol[v]\n        best_color = current_color\n        best_score = _vertex_conflicts(sol, v, current_color, edges)\n        for c in range(1, k+1):\n            if c == current_color:\n                continue\n            score = _vertex_conflicts(sol, v, c, edges)\n            if score < best_score:\n                best_score = score\n                best_color = c\n        # Allow new color only if all existing colors conflict equally (strict stalemate)\n        if best_color == current_color:\n            all_conflicting = True\n            for c in range(1, k+1):\n                if _vertex_conflicts(sol, v, c, edges) == 0:\n                    all_conflicting = False\n                    break\n            if all_conflicting:\n                best_color = k + 1\n        new_sol = sol[:]\n        new_sol[v] = best_color\n        move_type = (\"MinConflicts\", \"WeightedSingleVertexRecolor\")\n    else:\n        # No conflicts: try to reduce palette by moving from highest color class\n        k = max(sol) if sol else 1\n        if k > 1:\n            candidates_idx = [i for i, x in enumerate(sol) if x == k]\n            if not candidates_idx:\n                candidates_idx = list(range(n))\n            v = random.choice(candidates_idx)\n            current_color = sol[v]\n            target_colors = [c for c in range(1, k) if c != current_color]\n            random.shuffle(target_colors)\n            picked = current_color\n            for c in target_colors:\n                if _vertex_conflicts(sol, v, c, edges) == 0:\n                    picked = c\n                    break\n            new_sol = sol[:]\n            new_sol[v] = picked\n            move_type = (\"PaletteCompaction\", \"MoveFromMaxColorClass\")\n        else:\n            idx = random.randrange(n)\n            new_sol = sol[:]\n            new_sol[idx] = 1\n            move_type = (\"Exploration\", \"NoOpColor\")\n\n    new_sol = _compact_palette(new_sol)\n    return _serialize_solution_nb(new_sol, sol_type), move_type\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    def _parse_solution_pt(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            return [int(p) for p in parts], 'str'\n        if isinstance(sol, list):\n            return [int(x) for x in sol], 'list'\n        raise ValueError(\"Unsupported solution type; expected CSV string or list of ints\")\n\n    def _serialize_solution_pt(sol_list, t):\n        if t == 'str':\n            return ','.join(str(x) for x in sol_list)\n        return sol_list\n\n    def _edges():\n        return [\n            (1,2),(1,3),(1,7),(1,9),\n            (2,6),(2,9),\n            (3,4),(3,5),(3,7),\n            (4,5),(4,6),\n            (5,6),(5,8),\n            (6,7),(6,8),\n            (7,9),\n            (8,9)\n        ]\n\n    def _vertex_conflicts(sol, v, color, edges):\n        cnt = 0\n        for u,w in edges:\n            if u-1 == v:\n                if color == sol[w-1]:\n                    cnt += 1\n            elif w-1 == v:\n                if color == sol[u-1]:\n                    cnt += 1\n        return cnt\n\n    def _conflicted_vertices(sol, edges):\n        s = set()\n        for u,v in edges:\n            if sol[u-1] == sol[v-1]:\n                s.add(u-1); s.add(v-1)\n        return list(s)\n\n    def _compact_palette(sol):\n        uniq = sorted(set(sol))\n        mapping = {c:i+1 for i,c in enumerate(uniq)}\n        return [mapping[c] for c in sol]\n\n    sol, sol_type = _parse_solution_pt(solution)\n    n = len(sol)\n    if n == 0:\n        return _serialize_solution_pt(sol, sol_type)\n\n    edges = _edges()\n    k = max(sol) if sol else 1\n\n    # Step 1: partial swap between two random color classes (Kempe-like shake)\n    if k > 1:\n        a, b = random.sample(range(1, k+1), 2)\n        nodes = [i for i,x in enumerate(sol) if x == a or x == b]\n        random.shuffle(nodes)\n        depth = max(1, len(nodes)\/\/3)\n        for i in nodes[:depth]:\n            sol[i] = a if sol[i] == b else b\n\n    # Step 2: locally repair a third of vertices using min-conflicts, avoiding new colors unless necessary\n    m = max(1, n\/\/3)\n    pool = _conflicted_vertices(sol, edges)\n    if not pool:\n        pool = list(range(n))\n    random.shuffle(pool)\n    for v in pool[:m]:\n        current = sol[v]\n        best = current\n        best_score = _vertex_conflicts(sol, v, current, edges)\n        for c in range(1, max(1, max(sol)) + 1):\n            if c == current:\n                continue\n            s = _vertex_conflicts(sol, v, c, edges)\n            if s < best_score:\n                best_score = s\n                best = c\n        if best == current:\n            all_conflicting = True\n            for c in range(1, max(1, max(sol)) + 1):\n                if _vertex_conflicts(sol, v, c, edges) == 0:\n                    all_conflicting = False\n                    break\n            if all_conflicting:\n                best = max(sol) + 1\n        sol[v] = best\n\n    sol = _compact_palette(sol)\n    return _serialize_solution_pt(sol, sol_type)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"CSV_COLORS_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Parse CSV into list of positive integers\n    try:\n        colors = [int(x.strip()) for x in solution.split(',') if x.strip() != '']\n    except Exception:\n        return float('inf')\n    n = 9\n    if len(colors) != n:\n        return float('inf')\n    if any((not isinstance(c, int)) or (c <= 0) for c in colors):\n        return float('inf')\n    # Undirected edges of the given graph (store as normalized pairs i<j)\n    edges = {\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    }\n    E = set()\n    for u, v in edges:\n        a, b = (u, v) if u < v else (v, u)\n        E.add((a, b))\n    # Constraint: no two UNCONNECTED nodes share the same color\n    violations = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i, j) not in E:\n                if colors[i-1] == colors[j-1]:\n                    violations += 1\n    num_colors = len(set(colors))\n    # Lexicographic objective encoded as large-penalty scalarization\n    if violations > 0:\n        return float(1_000_000 * violations + num_colors)\n    return float(num_colors)","Vecindad":"import random\n\n# Helper utilities local to this module\n_DEF_N = 9\n_DEF_EDGES = {\n    (1,4),(1,5),(1,6),(1,8),\n    (2,3),(2,4),(2,5),(2,7),(2,8),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (5,7),(5,9),\n    (6,9),\n    (7,8)\n}\n_DEF_E = set()\nfor _u, _v in _DEF_EDGES:\n    a, b = (_u, _v) if _u < _v else (_v, _u)\n    _DEF_E.add((a, b))\n\n\ndef _parse_csv(sol):\n    return [int(x.strip()) for x in sol.split(',') if x.strip() != '']\n\n\ndef _stringify(cols):\n    return ','.join(str(c) for c in cols)\n\n\ndef _is_edge(i, j):\n    a, b = (i, j) if i < j else (j, i)\n    return (a, b) in _DEF_E\n\n\ndef _feasible_color(cols, v_idx, color_val):\n    # Check if assigning color_val to vertex v_idx keeps color-class as a clique\n    v = v_idx + 1\n    for u_idx, c in enumerate(cols):\n        if u_idx == v_idx:\n            continue\n        if c == color_val:\n            u = u_idx + 1\n            if not _is_edge(u, v):\n                return False\n    return True\n\n\ndef _candidate_colors(cols, v_idx):\n    palette = sorted(set(cols))\n    feas = [c for c in palette if c != cols[v_idx] and _feasible_color(cols, v_idx, c)]\n    # If no feasible existing color, optionally allow a new color (diversification)\n    if not feas:\n        feas = [max(palette) + 1]\n    return feas\n\n\ndef _op_recolor(cols):\n    n = len(cols)\n    idx = random.randrange(n)\n    cands = _candidate_colors(cols, idx)\n    new_cols = cols[:]\n    new_cols[idx] = random.choice(cands)\n    return new_cols, (\"Recolor\", \"Single-Vertex\")\n\n\ndef _op_swap_colors(cols):\n    # Swap two existing color labels across all vertices (structure-preserving move)\n    palette = list(sorted(set(cols)))\n    if len(palette) < 2:\n        return cols[:], (\"NoOp\", \"Swap-Colors-Insufficient\")\n    a, b = random.sample(palette, 2)\n    trans = {a: b, b: a}\n    new_cols = [trans.get(c, c) for c in cols]\n    return new_cols, (\"Relabel\", \"Color-Swap\")\n\n\ndef _op_kempe_like(cols):\n    # Kempe-chain inspired on two colors: try moving a vertex to the other color if feasible\n    palette = list(sorted(set(cols)))\n    if len(palette) < 2:\n        return cols[:], (\"NoOp\", \"Kempe-Insufficient\")\n    n = len(cols)\n    idx = random.randrange(n)\n    cur = cols[idx]\n    other_choices = [c for c in palette if c != cur]\n    random.shuffle(other_choices)\n    for tgt in other_choices:\n        if _feasible_color(cols, idx, tgt):\n            new_cols = cols[:]\n            new_cols[idx] = tgt\n            return new_cols, (\"Kempe\", \"Vertex-Move\")\n    # If no feasible target, fall back to recolor\n    return _op_recolor(cols)\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    cols = _parse_csv(solution)\n    if len(cols) != _DEF_N:\n        return solution, (\"NoOp\", \"Invalid-Length\")\n    # Randomly pick an operator with bias toward constructive recolor\n    r = random.random()\n    if r < 0.6:\n        new_cols, meta = _op_recolor(cols)\n    elif r < 0.8:\n        new_cols, meta = _op_kempe_like(cols)\n    else:\n        new_cols, meta = _op_swap_colors(cols)\n    return _stringify(new_cols), meta","Perturbacion":"import random\n\n_DEF_N = 9\n_DEF_EDGES = {\n    (1,4),(1,5),(1,6),(1,8),\n    (2,3),(2,4),(2,5),(2,7),(2,8),\n    (3,6),(3,8),(3,9),\n    (4,7),(4,8),(4,9),\n    (5,7),(5,9),\n    (6,9),\n    (7,8)\n}\n_DEF_E = set()\nfor _u, _v in _DEF_EDGES:\n    a, b = (_u, _v) if _u < _v else (_v, _u)\n    _DEF_E.add((a, b))\n\n\ndef _parse_csv(sol):\n    return [int(x.strip()) for x in sol.split(',') if x.strip() != '']\n\ndef _stringify(cols):\n    return ','.join(str(c) for c in cols)\n\ndef _is_edge(i, j):\n    a, b = (i, j) if i < j else (j, i)\n    return (a, b) in _DEF_E\n\ndef _feasible_color(cols, v_idx, color_val):\n    v = v_idx + 1\n    for u_idx, c in enumerate(cols):\n        if u_idx == v_idx:\n            continue\n        if c == color_val:\n            u = u_idx + 1\n            if not _is_edge(u, v):\n                return False\n    return True\n\ndef perturb_solution(solution):\n    cols = _parse_csv(solution)\n    if len(cols) != _DEF_N:\n        return solution\n    n = len(cols)\n    k = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k)\n    palette = sorted(set(cols))\n    for idx in idxs:\n        # Try a few feasible recolors; allow a new color with small probability\n        choices = [c for c in palette if c != cols[idx] and _feasible_color(cols, idx, c)]\n        if not choices or random.random() < 0.2:\n            choices = choices + [max(palette) + 1]\n        cols[idx] = random.choice(choices)\n        # Update palette dynamically\n        palette = sorted(set(cols))\n    return _stringify(cols)","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"CSV_COLORS_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Parse CSV into list of positive integers\n    try:\n        colors = [int(x.strip()) for x in solution.split(',') if x.strip() != '']\n    except Exception:\n        return float('inf')\n    n = 9\n    if len(colors) != n:\n        return float('inf')\n    if any((not isinstance(c, int)) or (c <= 0) for c in colors):\n        return float('inf')\n    # Undirected edges of the given graph (store as normalized pairs i<j)\n    edges = {\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    }\n    E = set()\n    for u, v in edges:\n        a, b = (u, v) if u < v else (v, u)\n        E.add((a, b))\n    # Constraint: no two UNCONNECTED nodes share the same color\n    violations = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            a, b = (i, j) if i < j else (j, i)\n            if (a, b) not in E and colors[i-1] == colors[j-1]:\n                violations += 1\n    num_colors = len(set(colors))\n    # Lexicographic objective encoded as large-penalty scalarization\n    if violations > 0:\n        return float(1_000_000 * violations + num_colors)\n    return float(num_colors)\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Internal utilities and data kept local to avoid globals\n    def parse_csv(sol):\n        return [int(x.strip()) for x in sol.split(',') if x.strip() != '']\n    def stringify(cols):\n        return ','.join(str(c) for c in cols)\n    def is_edge(i, j):\n        edges = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        a, b = (i, j) if i < j else (j, i)\n        return (a, b) in {(min(u,v), max(u,v)) for (u,v) in edges}\n    def feasible_color(cols, v_idx, color_val):\n        v = v_idx + 1\n        for u_idx, c in enumerate(cols):\n            if u_idx == v_idx:\n                continue\n            if c == color_val:\n                u = u_idx + 1\n                if not is_edge(u, v):\n                    return False\n        return True\n    # Parse and validate\n    try:\n        cols = parse_csv(solution)\n    except Exception:\n        # If parsing fails, start from a trivial valid assignment\n        cols = [i+1 for i in range(9)]\n    if len(cols) != 9:\n        cols = [i+1 for i in range(9)]\n    # Operator: single-vertex recolor to a feasible existing color or introduce a new color if needed\n    n = len(cols)\n    idx = random.randrange(n)\n    palette = sorted(set(cols))\n    candidates = [c for c in palette if c != cols[idx] and feasible_color(cols, idx, c)]\n    if not candidates:\n        candidates = [max(palette) + 1]\n    new_cols = cols[:]\n    new_cols[idx] = random.choice(candidates)\n    return stringify(new_cols)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Local helpers and embedded data\n    def parse_csv(sol):\n        return [int(x.strip()) for x in sol.split(',') if x.strip() != '']\n    def stringify(cols):\n        return ','.join(str(c) for c in cols)\n    def is_edge(i, j):\n        edges = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        a, b = (i, j) if i < j else (j, i)\n        return (a, b) in {(min(u,v), max(u,v)) for (u,v) in edges}\n    def feasible_color(cols, v_idx, color_val):\n        v = v_idx + 1\n        for u_idx, c in enumerate(cols):\n            if u_idx == v_idx:\n                continue\n            if c == color_val:\n                u = u_idx + 1\n                if not is_edge(u, v):\n                    return False\n        return True\n    # Parse and guard\n    try:\n        cols = parse_csv(solution)\n    except Exception:\n        cols = [i+1 for i in range(9)]\n    if len(cols) != 9:\n        cols = [i+1 for i in range(9)]\n    n = len(cols)\n    # Shake k vertices\n    k = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        palette = sorted(set(cols))\n        choices = [c for c in palette if c != cols[idx] and feasible_color(cols, idx, c)]\n        if not choices or random.random() < 0.25:\n            choices = choices + [max(palette) + 1]\n        cols[idx] = random.choice(choices)\n    return stringify(cols)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_textbook_inverted","Representacion":"CSV_COLORS_9","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Parse CSV into list of positive integers\n    try:\n        colors = [int(x.strip()) for x in solution.split(',') if x.strip() != '']\n    except Exception:\n        return float('inf')\n    n = 9\n    if len(colors) != n:\n        return float('inf')\n    if any((not isinstance(c, int)) or (c <= 0) for c in colors):\n        return float('inf')\n    # Undirected edges of the given graph (store as normalized pairs i<j)\n    edges = {\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    }\n    E = set()\n    for u, v in edges:\n        a, b = (u, v) if u < v else (v, u)\n        E.add((a, b))\n    # Constraint: no two UNCONNECTED nodes share the same color\n    violations = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            a, b = (i, j) if i < j else (j, i)\n            if (a, b) not in E and colors[i-1] == colors[j-1]:\n                violations += 1\n    num_colors = len(set(colors))\n    # Use large-penalty scalarization: minimize violations first, then num_colors\n    if violations > 0:\n        return float(1_000_000 * violations + num_colors)\n    return float(num_colors)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Helpers and embedded immutable data\n    def parse_csv(sol):\n        return [int(x.strip()) for x in sol.split(',') if x.strip() != '']\n\n    def stringify(cols):\n        return ','.join(str(c) for c in cols)\n\n    def edge_set():\n        edges = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        return {(min(u,v), max(u,v)) for (u,v) in edges}\n\n    E = edge_set()\n\n    def is_edge(i, j):\n        a, b = (i, j) if i < j else (j, i)\n        return (a, b) in E\n\n    def feasible_color(cols, v_idx, color_val):\n        v = v_idx + 1\n        for u_idx, c in enumerate(cols):\n            if u_idx == v_idx:\n                continue\n            if c == color_val:\n                u = u_idx + 1\n                if not is_edge(u, v):\n                    return False\n        return True\n\n    def compact_palette(cols):\n        # Relabel colors to 1..k preserving relative groups\n        unique = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(unique)}\n        return [mapping[c] for c in cols]\n\n    # Parse and guard\n    try:\n        cols = parse_csv(solution)\n    except Exception:\n        cols = [1,1,2,1,2,2,1,1,2]  # small palette seed\n    if len(cols) != 9 or any((not isinstance(c, int)) or c <= 0 for c in cols):\n        cols = [1,1,2,1,2,2,1,1,2]\n\n    cols = compact_palette(cols)\n    n = len(cols)\n\n    # Choose move type\n    move_roll = random.random()\n\n    if move_roll < 0.6:\n        # Single-vertex recolor to an existing feasible color, else new color\n        idx = random.randrange(n)\n        palette = sorted(set(cols))\n        candidates = [c for c in palette if c != cols[idx] and feasible_color(cols, idx, c)]\n        if not candidates:\n            candidates = [max(palette) + 1]\n        new_cols = cols[:]\n        new_cols[idx] = random.choice(candidates)\n        return stringify(compact_palette(new_cols))\n\n    elif move_roll < 0.85:\n        # Color swap: pick two colors and swap labels\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            return stringify(cols)\n        a, b = random.sample(palette, 2)\n        swap = {a: b, b: a}\n        new_cols = [swap.get(c, c) for c in cols]\n        return stringify(compact_palette(new_cols))\n\n    else:\n        # Attempt color merge with light repair on a subset\n        palette = sorted(set(cols))\n        if len(palette) < 2:\n            return stringify(cols)\n        c_keep, c_merge = random.sample(palette, 2)\n        new_cols = cols[:]\n        for i in range(n):\n            if new_cols[i] == c_merge:\n                if feasible_color(new_cols, i, c_keep):\n                    new_cols[i] = c_keep\n        # Greedy repair: for any remaining vertex with c_merge, assign feasible existing or new color\n        if c_merge in new_cols:\n            for i in range(n):\n                if new_cols[i] == c_merge:\n                    cand = [c for c in sorted(set(new_cols)) if c != c_merge and feasible_color(new_cols, i, c)]\n                    if not cand:\n                        cand = [max(sorted(set(new_cols))) + 1]\n                    new_cols[i] = random.choice(cand)\n        return stringify(compact_palette(new_cols))\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Helpers and embedded data\n    def parse_csv(sol):\n        return [int(x.strip()) for x in sol.split(',') if x.strip() != '']\n\n    def stringify(cols):\n        return ','.join(str(c) for c in cols)\n\n    def edge_set():\n        edges = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        return {(min(u,v), max(u,v)) for (u,v) in edges}\n\n    E = edge_set()\n\n    def is_edge(i, j):\n        a, b = (i, j) if i < j else (j, i)\n        return (a, b) in E\n\n    def feasible_color(cols, v_idx, color_val):\n        v = v_idx + 1\n        for u_idx, c in enumerate(cols):\n            if u_idx == v_idx:\n                continue\n            if c == color_val:\n                u = u_idx + 1\n                if not is_edge(u, v):\n                    return False\n        return True\n\n    def compact_palette(cols):\n        unique = sorted(set(cols))\n        mapping = {c: i+1 for i, c in enumerate(unique)}\n        return [mapping[c] for c in cols]\n\n    # Parse and guard\n    try:\n        cols = parse_csv(solution)\n    except Exception:\n        cols = [1,1,2,1,2,2,1,1,2]\n    if len(cols) != 9 or any((not isinstance(c, int)) or c <= 0 for c in cols):\n        cols = [1,1,2,1,2,2,1,1,2]\n\n    cols = compact_palette(cols)\n    n = len(cols)\n\n    # Shake: recolor k random vertices; try to keep feasibility, else introduce new colors\n    k = max(2, n \/\/ 3)\n    idxs = random.sample(range(n), k)\n    for idx in idxs:\n        palette = sorted(set(cols))\n        # 25% chance to force exploration by allowing a new color\n        candidates = [c for c in palette if c != cols[idx] and feasible_color(cols, idx, c)]\n        if not candidates or random.random() < 0.25:\n            candidates = candidates + [max(palette) + 1]\n        cols[idx] = random.choice(candidates)\n\n    # Optional palette compaction to avoid color bloat\n    cols = compact_palette(cols)\n    return stringify(cols)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"CSV_STR_GROUPS_PER_STUDENT_ORDERED_1_TO_9","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n    if len(parts) != 9:\n        return 1e9\n    try:\n        groups = [int(x) for x in parts]\n    except Exception:\n        return 1e9\n    # Friendship edges (1-indexed in problem -> 0-indexed here)\n    pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n             (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    edges = set()\n    for u,v in pairs:\n        u -= 1; v -= 1\n        edges.add((u,v)); edges.add((v,u))\n    # Penalty for any pair in same group that are not friends (hard constraint)\n    penalty = 0\n    n = 9\n    for i in range(n):\n        for j in range(i+1, n):\n            if groups[i] == groups[j] and (i,j) not in edges:\n                penalty += 1000\n    num_groups = len(set(groups))\n    return float(num_groups + penalty)\n","Vecindad":"import random\n\nNB_Type = \"NB_Type\"\nMovement_Type = \"Movement_Type\"\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n    if len(parts) != 9:\n        return solution, \"LOCAL\", \"Reassign\"\n    try:\n        groups = [int(x) for x in parts]\n    except Exception:\n        return solution, \"LOCAL\", \"Reassign\"\n    # Problem data\n    pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n             (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    edges = set()\n    for u,v in pairs:\n        u -= 1; v -= 1\n        edges.add((u,v)); edges.add((v,u))\n    n = 9\n    idx = random.randrange(n)\n    # Build members per label\n    members = {}\n    for s,g in enumerate(groups):\n        members.setdefault(g, []).append(s)\n    # Feasible target groups for idx: must be friends with all members\n    feasible_targets = []\n    for g, mems in members.items():\n        if g == groups[idx]:\n            continue\n        ok = True\n        for m in mems:\n            a, b = (idx, m) if idx < m else (m, idx)\n            if (a, b) not in edges:\n                ok = False\n                break\n        if ok:\n            feasible_targets.append(g)\n    if not feasible_targets:\n        target = max(members) + 1  # open new singleton group\n    else:\n        target = random.choice(feasible_targets)\n    new_groups = groups[:]\n    new_groups[idx] = target\n    # Stable normalization: order labels by lowest-index member\n    label_min = {}\n    for s,g in enumerate(new_groups):\n        if g not in label_min or s < label_min[g]:\n            label_min[g] = s\n    ordered = [g for g,_ in sorted(label_min.items(), key=lambda kv: kv[1])]\n    remap = {g:i+1 for i,g in enumerate(ordered)}\n    normalized = [remap[g] for g in new_groups]\n    neighbor_solution = ','.join(str(x) for x in normalized)\n    return neighbor_solution, \"LOCAL\", \"Reassign\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n    if len(parts) != 9:\n        return solution\n    try:\n        groups = [int(x) for x in parts]\n    except Exception:\n        return solution\n    # Problem data\n    pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n             (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    edges = set()\n    for u,v in pairs:\n        u -= 1; v -= 1\n        edges.add((u,v)); edges.add((v,u))\n    n = 9\n    k_moves = random.randint(2, 4)\n    idxs = random.sample(range(n), k=k_moves)\n    # Build members per label helper each time\n    for idx in idxs:\n        members = {}\n        for s,g in enumerate(groups):\n            members.setdefault(g, []).append(s)\n        # Remove idx temporarily from its group to evaluate feasibility elsewhere\n        orig_group = groups[idx]\n        # Feasible target groups for idx\n        feasible_targets = []\n        for g, mems in members.items():\n            if g == orig_group:\n                continue\n            ok = True\n            for m in mems:\n                a, b = (idx, m) if idx < m else (m, idx)\n                if (a, b) not in edges:\n                    ok = False\n                    break\n            if ok:\n                feasible_targets.append(g)\n        if feasible_targets:\n            groups[idx] = random.choice(feasible_targets)\n        else:\n            groups[idx] = max(members) + 1  # open new group\n    # Stable normalization\n    label_min = {}\n    for s,g in enumerate(groups):\n        if g not in label_min or s < label_min[g]:\n            label_min[g] = s\n    ordered = [g for g,_ in sorted(label_min.items(), key=lambda kv: kv[1])]\n    remap = {g:i+1 for i,g in enumerate(ordered)}\n    normalized = [remap[g] for g in groups]\n    return ','.join(str(x) for x in normalized)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"CSV_STR_GROUPS_PER_STUDENT_ORDERED_1_TO_9","Evaluacion":"import random\n\ndef evaluate_solution(solution):\n    if not isinstance(solution, str):\n        return 1000000000.0\n    parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n    if len(parts) != 9:\n        return 1000000000.0\n    try:\n        groups = [int(x) for x in parts]\n    except Exception:\n        return 1000000000.0\n    # Problem data (friendships, 1-indexed in statement -> 0-indexed here)\n    pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n             (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    edges = set()\n    for u,v in pairs:\n        u -= 1; v -= 1\n        edges.add((u,v)); edges.add((v,u))\n    n = 9\n    # Count violations: any pair in same group that are not friends\n    violations = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if groups[i] == groups[j] and (i,j) not in edges:\n                violations += 1\n    num_groups = len(set(groups))\n    # Cost: prioritize feasibility; then minimize number of groups\n    # Moderate penalty to retain gradient while making any violation costly\n    cost = violations * 100 + num_groups\n    return float(cost)\n","Vecindad":"import random\n\n# Returns a neighbor solution as CSV string; signature annotation kept per spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n    if len(parts) != 9:\n        return solution\n    try:\n        groups = [int(x) for x in parts]\n    except Exception:\n        return solution\n    # Problem data (friendships)\n    pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n             (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    edges = set()\n    for u,v in pairs:\n        u -= 1; v -= 1\n        edges.add((u,v)); edges.add((v,u))\n    n = 9\n\n    def normalize(lbls):\n        label_min = {}\n        for s,g in enumerate(lbls):\n            if g not in label_min or s < label_min[g]:\n                label_min[g] = s\n        ordered = [g for g,_ in sorted(label_min.items(), key=lambda kv: kv[1])]\n        remap = {g:i+1 for i,g in enumerate(ordered)}\n        return [remap[g] for g in lbls]\n\n    idx = random.randrange(n)\n    # Build members per label\n    members = {}\n    for s,g in enumerate(groups):\n        members.setdefault(g, []).append(s)\n    # Feasible target groups for idx: must be friends with all members\n    feasible_targets = []\n    for g, mems in members.items():\n        if g == groups[idx]:\n            continue\n        ok = True\n        for m in mems:\n            a, b = (idx, m) if idx < m else (m, idx)\n            if (a, b) not in edges:\n                ok = False\n                break\n        if ok:\n            feasible_targets.append((g, len(mems)))  # include size for bias\n    # Choose target: prefer larger feasible groups to consolidate labels\n    if feasible_targets:\n        max_size = max(sz for _,sz in feasible_targets)\n        candidates = [g for g,sz in feasible_targets if sz == max_size]\n        target = random.choice(candidates)\n    else:\n        target = max(members) + 1  # open new singleton group\n    new_groups = groups[:]\n    new_groups[idx] = target\n    normalized = normalize(new_groups)\n    neighbor_solution = ','.join(str(x) for x in normalized)\n    return neighbor_solution\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    parts = [p.strip() for p in solution.split(',') if p.strip()!='']\n    if len(parts) != 9:\n        return solution\n    try:\n        groups = [int(x) for x in parts]\n    except Exception:\n        return solution\n    # Problem data (friendships)\n    pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n             (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    edges = set()\n    for u,v in pairs:\n        u -= 1; v -= 1\n        edges.add((u,v)); edges.add((v,u))\n    n = 9\n\n    def normalize(lbls):\n        label_min = {}\n        for s,g in enumerate(lbls):\n            if g not in label_min or s < label_min[g]:\n                label_min[g] = s\n        ordered = [g for g,_ in sorted(label_min.items(), key=lambda kv: kv[1])]\n        remap = {g:i+1 for i,g in enumerate(ordered)}\n        return [remap[g] for g in lbls]\n\n    # Perform k random feasible reassignments with a chance to create a new group\n    k_moves = random.randint(2, 4)\n    idxs = random.sample(range(n), k=k_moves)\n    for idx in idxs:\n        # Recompute members each time for up-to-date feasibility\n        members = {}\n        for s,g in enumerate(groups):\n            members.setdefault(g, []).append(s)\n        orig_group = groups[idx]\n        feasible_targets = []\n        for g, mems in members.items():\n            if g == orig_group:\n                continue\n            ok = True\n            for m in mems:\n                a, b = (idx, m) if idx < m else (m, idx)\n                if (a, b) not in edges:\n                    ok = False\n                    break\n            if ok:\n                feasible_targets.append((g, len(mems)))\n        # With small probability force a new group to diversify\n        if feasible_targets and random.random() > 0.2:\n            # prefer larger feasible group\n            max_size = max(sz for _,sz in feasible_targets)\n            candidates = [g for g,sz in feasible_targets if sz == max_size]\n            groups[idx] = random.choice(candidates)\n        else:\n            groups[idx] = max(members) + 1\n    groups = normalize(groups)\n    return ','.join(str(x) for x in groups)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_student_groups_inverted","Representacion":"CSV_STR_GROUPS_PER_STUDENT_ORDERED_1_TO_9","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Robust parse accepting str|list|tuple and normalizing to CSV semantics\n    def parse_solution(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = [str(x).strip() for x in sol]\n        else:\n            return None\n        if len(parts) != 9:\n            return None\n        try:\n            groups = [int(x) for x in parts]\n        except Exception:\n            return None\n        return groups\n\n    groups = parse_solution(solution)\n    if groups is None:\n        return 1000000000.0\n\n    # Problem data (friendships, 1-indexed given -> 0-indexed here)\n    pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n             (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n    edges = set()\n    for u,v in pairs:\n        u -= 1; v -= 1\n        edges.add((u,v)); edges.add((v,u))\n    n = 9\n\n    # Count violations: pairs in same group that are not friends\n    violations = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if groups[i] == groups[j] and ((i,j) not in edges):\n                violations += 1\n    num_groups = len(set(groups))\n\n    # Lexicographic cost: any feasible (violations==0) beats any infeasible.\n    # B >= max number of pairs + 1 = 9*8\/2 + 1 = 37\n    B = 37\n    cost = violations * B + num_groups\n    return float(cost)\n","Vecindad":"import random\nimport itertools\n\n# Returns a neighbor solution as CSV string; signature annotation kept per spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers enclosed to avoid globals\n    def parse_solution(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = [str(x).strip() for x in sol]\n        else:\n            return None\n        if len(parts) != 9:\n            return None\n        try:\n            groups = [int(x) for x in parts]\n        except Exception:\n            return None\n        return groups\n\n    def normalize(lbls):\n        label_min = {}\n        for s,g in enumerate(lbls):\n            if g not in label_min or s < label_min[g]:\n                label_min[g] = s\n        ordered = [g for g,_ in sorted(label_min.items(), key=lambda kv: kv[1])]\n        remap = {g:i+1 for i,g in enumerate(ordered)}\n        return [remap[g] for g in lbls]\n\n    def build_edges():\n        pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n                 (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n        E = set()\n        for u,v in pairs:\n            u -= 1; v -= 1\n            E.add((u,v)); E.add((v,u))\n        return E\n\n    def members_by_group(lbls):\n        m = {}\n        for s,g in enumerate(lbls):\n            m.setdefault(g, []).append(s)\n        return m\n\n    def group_is_clique(members, E):\n        for i in range(len(members)):\n            a = members[i]\n            for j in range(i+1, len(members)):\n                b = members[j]\n                if (a,b) not in E:\n                    return False\n        return True\n\n    def conflicts_for(lbls, E, idx):\n        g = lbls[idx]\n        mems = [s for s in range(len(lbls)) if lbls[s]==g and s!=idx]\n        c = 0\n        for m in mems:\n            a,b = (m, idx) if m < idx else (idx, m)\n            if (a,b) not in E:\n                c += 1\n        return c\n\n    groups = parse_solution(solution)\n    if groups is None:\n        return '1,1,1,1,1,1,1,1,1'\n\n    E = build_edges()\n    n = 9\n\n    # Conflict-driven index selection\n    conflict_counts = [conflicts_for(groups, E, i) for i in range(n)]\n    max_conf = max(conflict_counts)\n    if max_conf > 0:\n        candidates = [i for i,c in enumerate(conflict_counts) if c == max_conf]\n        idx = random.choice(candidates)\n    else:\n        # No conflicts: try to reduce number of groups by merging tendencies\n        # pick a student from the smallest group\n        mems = members_by_group(groups)\n        min_size = min(len(v) for v in mems.values())\n        pool = [s for s,g in enumerate(groups) if len(mems[g]) == min_size]\n        idx = random.choice(pool)\n\n    mems = members_by_group(groups)\n\n    # Attempt 1: Move idx to a feasible existing group (prefer larger to consolidate)\n    feasible_targets = []\n    for g, members in mems.items():\n        if g == groups[idx]:\n            continue\n        ok = True\n        for m in members:\n            a,b = (idx, m) if idx < m else (m, idx)\n            if (a,b) not in E:\n                ok = False\n                break\n        if ok:\n            feasible_targets.append((g, len(members)))\n    if feasible_targets:\n        max_sz = max(sz for _,sz in feasible_targets)\n        candidates = [g for g,sz in feasible_targets if sz == max_sz]\n        target = random.choice(candidates)\n        new_groups = groups[:]\n        new_groups[idx] = target\n        return ','.join(str(x) for x in normalize(new_groups))\n\n    # Attempt 2: If no feasible move, try a 1-1 swap with another student to repair\n    order = list(range(n))\n    random.shuffle(order)\n    for j in order:\n        if groups[j] == groups[idx]:\n            continue\n        new_groups = groups[:]\n        gi, gj = new_groups[idx], new_groups[j]\n        new_groups[idx], new_groups[j] = gj, gi\n        # Validate both affected groups remain cliques\n        mems2 = members_by_group(new_groups)\n        ok = True\n        for gk, members in mems2.items():\n            if not group_is_clique(members, E):\n                ok = False\n                break\n        if ok:\n            return ','.join(str(x) for x in normalize(new_groups))\n\n    # Attempt 3: Try merging two groups if their union is a clique\n    groups_set = list(set(groups))\n    random.shuffle(groups_set)\n    for g1, g2 in itertools.permutations(groups_set, 2):\n        if g1 == g2:\n            continue\n        union = [i for i,x in enumerate(groups) if x==g1 or x==g2]\n        if group_is_clique(union, E):\n            new_groups = groups[:]\n            for i in range(n):\n                if new_groups[i] == g2:\n                    new_groups[i] = g1\n            return ','.join(str(x) for x in normalize(new_groups))\n\n    # Fallback: open a new singleton for idx (may increase groups but helps escape)\n    new_label = max(mems) + 1\n    new_groups = groups[:]\n    new_groups[idx] = new_label\n    return ','.join(str(x) for x in normalize(new_groups))\n","Perturbacion":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    def parse_solution(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = [str(x).strip() for x in sol]\n        else:\n            return None\n        if len(parts) != 9:\n            return None\n        try:\n            groups = [int(x) for x in parts]\n        except Exception:\n            return None\n        return groups\n\n    def normalize(lbls):\n        label_min = {}\n        for s,g in enumerate(lbls):\n            if g not in label_min or s < label_min[g]:\n                label_min[g] = s\n        ordered = [g for g,_ in sorted(label_min.items(), key=lambda kv: kv[1])]\n        remap = {g:i+1 for i,g in enumerate(ordered)}\n        return [remap[g] for g in lbls]\n\n    def build_edges():\n        pairs = [(1,4),(1,5),(1,6),(1,8),(2,3),(2,4),(2,5),(2,7),(2,8),\n                 (3,6),(3,8),(3,9),(4,7),(4,8),(4,9),(5,7),(5,9),(6,9),(7,8)]\n        E = set()\n        for u,v in pairs:\n            u -= 1; v -= 1\n            E.add((u,v)); E.add((v,u))\n        return E\n\n    def members_by_group(lbls):\n        m = {}\n        for s,g in enumerate(lbls):\n            m.setdefault(g, []).append(s)\n        return m\n\n    def group_is_clique(members, E):\n        for i in range(len(members)):\n            a = members[i]\n            for j in range(i+1, len(members)):\n                b = members[j]\n                if (a,b) not in E:\n                    return False\n        return True\n\n    groups = parse_solution(solution)\n    if groups is None:\n        return '1,2,3,1,2,3,1,2,3'\n\n    E = build_edges()\n    n = 9\n\n    # Perform k diversified moves\n    k_moves = random.randint(3, 5)\n    curr = groups[:]\n    for _ in range(k_moves):\n        mems = members_by_group(curr)\n        # 40% try a merge-if-clique; 40% try feasible reassignment; 20% random split\n        r = random.random()\n        if r < 0.4 and len(mems) > 1:\n            groups_set = list(mems.keys())\n            random.shuffle(groups_set)\n            merged = False\n            for g1 in groups_set:\n                for g2 in groups_set:\n                    if g1 >= g2:\n                        continue\n                    union = mems[g1] + mems[g2]\n                    if group_is_clique(union, E):\n                        for i in range(n):\n                            if curr[i] == g2:\n                                curr[i] = g1\n                        merged = True\n                        break\n                if merged:\n                    break\n            if merged:\n                curr = normalize(curr)\n                continue\n        if r < 0.8:\n            # Feasible reassignment for a high-conflict or random index\n            def conflicts_for(lbls, idx):\n                g = lbls[idx]\n                others = [s for s in range(n) if lbls[s]==g and s!=idx]\n                c = 0\n                for m in others:\n                    a,b = (m, idx) if m < idx else (idx, m)\n                    if (a,b) not in E:\n                        c += 1\n                return c\n            confs = [conflicts_for(curr, i) for i in range(n)]\n            if max(confs) > 0:\n                idx = random.choice([i for i,c in enumerate(confs) if c==max(confs)])\n            else:\n                # pick from smallest group to consolidate later\n                min_size = min(len(v) for v in mems.values())\n                idx = random.choice([i for i,g in enumerate(curr) if len(mems[g])==min_size])\n            feasible = []\n            for g, members in mems.items():\n                if g == curr[idx]:\n                    continue\n                ok = True\n                for m in members:\n                    a,b = (idx, m) if idx < m else (m, idx)\n                    if (a,b) not in E:\n                        ok = False\n                        break\n                if ok:\n                    feasible.append((g, len(members)))\n            if feasible:\n                max_sz = max(sz for _,sz in feasible)\n                candidates = [g for g,sz in feasible if sz==max_sz]\n                curr[idx] = random.choice(candidates)\n                curr = normalize(curr)\n                continue\n        # Random split: move a random node to a new label to diversify\n        idx = random.randrange(n)\n        new_label = max(curr) + 1\n        curr[idx] = new_label\n        curr = normalize(curr)\n\n    return ','.join(str(x) for x in normalize(curr))\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST length=9; 1-indexed room labels for participants 1..9","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Parse CSV of 9 integers (rooms are 1-indexed)\n    try:\n        labels = [int(x.strip()) for x in solution.split(',') if x.strip()!='']\n    except Exception:\n        return 1000000000.0\n    n = 9\n    if len(labels) != n:\n        return 1000000000.0\n    if any(x < 1 for x in labels):\n        return 1000000000.0\n    # Opponent edges (undirected)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    # Count violations: same room but NOT opponents\n    violations = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if labels[i-1] == labels[j-1]:\n                key = (i,j) if i<j else (j,i)\n                if key not in opp:\n                    violations += 1\n    rooms_used = len(set(labels))\n    return float(1000*violations + rooms_used)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution_csv, NB_Type, Movement_Type)\n    def parse(sol: str):\n        return [int(x.strip()) for x in sol.split(',') if x.strip()!='']\n    def serialize(labels):\n        # compress to dense 1..k\n        uniq = {}\n        next_id = 1\n        dense = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_id\n                next_id += 1\n            dense.append(uniq[x])\n        return ','.join(str(x) for x in dense)\n    labels = parse(solution)\n    n = len(labels)\n    # Opponent edges and fast lookup\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    def are_opponents(i,j):\n        a,b = (i+1,j+1) if i<j else (j+1,i+1)\n        return (a,b) in opp\n    # Build room membership\n    room_members = {}\n    for idx, r in enumerate(labels):\n        room_members.setdefault(r, []).append(idx)\n    rooms = sorted(room_members.keys())\n    # Compute conflicts (same room and not opponents)\n    conflicts = []\n    for r, members in room_members.items():\n        m = len(members)\n        for ii in range(m):\n            for jj in range(ii+1, m):\n                u, v = members[ii], members[jj]\n                if not are_opponents(u, v):\n                    conflicts.append((u, v))\n    def conflicts_if_assign(p_idx, room_label):\n        # Count conflicts p_idx would have in room_label\n        cnt = 0\n        for q in room_members.get(room_label, []):\n            if not are_opponents(p_idx, q):\n                cnt += 1\n        return cnt\n    labels_new = list(labels)\n    if conflicts:\n        # Conflict-driven reassignment\n        u,v = random.choice(conflicts)\n        p = random.choice([u,v])\n        k = len(rooms)\n        candidates = rooms + [max(rooms)+1]\n        best_cost = None\n        best_rooms = []\n        for rr in candidates:\n            c = conflicts_if_assign(p, rr)\n            if best_cost is None or c < best_cost:\n                best_cost = c\n                best_rooms = [rr]\n            elif c == best_cost:\n                best_rooms.append(rr)\n        target_room = random.choice(best_rooms)\n        # Update structure\n        old_room = labels_new[p]\n        labels_new[p] = target_room\n    else:\n        # Zero-conflict state: attempt room reduction by moving singletons\n        # Identify singleton rooms first\n        singleton = None\n        for r in rooms:\n            if len(room_members[r]) == 1:\n                singleton = r\n                break\n        moved = False\n        if singleton is not None:\n            p = room_members[singleton][0]\n            # Try place p into any other existing room without conflicts\n            compatible_rooms = []\n            for r in rooms:\n                if r == singleton:\n                    continue\n                if conflicts_if_assign(p, r) == 0:\n                    compatible_rooms.append(r)\n            if compatible_rooms:\n                labels_new[p] = random.choice(compatible_rooms)\n                moved = True\n        if not moved:\n            # Neutral move: pick random participant, move to a random compatible room\n            p = random.randrange(n)\n            comp = [r for r in rooms if r != labels_new[p] and conflicts_if_assign(p, r) == 0]\n            if comp:\n                labels_new[p] = random.choice(comp)\n            else:\n                # As last resort, open a new room (kept rare in zero-conflict)\n                labels_new[p] = max(rooms)+1\n    return (serialize(labels_new), 'conflict_driven' if conflicts else 'zero_conflict', 'reassign')\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    def parse(sol: str):\n        return [int(x.strip()) for x in sol.split(',') if x.strip()!='']\n    def serialize(labels):\n        # compress to dense 1..k\n        uniq = {}\n        next_id = 1\n        dense = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_id\n                next_id += 1\n            dense.append(uniq[x])\n        return ','.join(str(x) for x in dense)\n    labels = parse(solution)\n    n = len(labels)\n    if n == 0:\n        return ''\n    # Opponent edges\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    def are_opponents(i,j):\n        a,b = (i+1,j+1) if i<j else (j+1,i+1)\n        return (a,b) in opp\n    # Random k recolors followed by greedy repair attempts\n    ksteps = max(3, n\/\/3)\n    labels_new = list(labels)\n    for _ in range(ksteps):\n        i = random.randrange(n)\n        current_rooms = sorted(set(labels_new))\n        new_room = random.randint(1, min(len(current_rooms)+1, n))\n        labels_new[i] = new_room\n    # Greedy repair: try to eliminate conflicts by reassigning conflicting nodes\n    def build_room_members(L):\n        rm = {}\n        for idx, r in enumerate(L):\n            rm.setdefault(r, []).append(idx)\n        return rm\n    def conflicts_exist(L):\n        rm = build_room_members(L)\n        for r, members in rm.items():\n            m = len(members)\n            for ii in range(m):\n                for jj in range(ii+1, m):\n                    u, v = members[ii], members[jj]\n                    if not are_opponents(u, v):\n                        return True\n        return False\n    def count_conflicts_for_room(L, p_idx, room_label):\n        rm = build_room_members(L)\n        cnt = 0\n        for q in rm.get(room_label, []):\n            if not are_opponents(p_idx, q):\n                cnt += 1\n        return cnt\n    # Limited iterations of repair\n    for _ in range(3*n):\n        rm = build_room_members(labels_new)\n        bad_pair = None\n        for r, members in rm.items():\n            m = len(members)\n            found = False\n            for ii in range(m):\n                for jj in range(ii+1, m):\n                    u, v = members[ii], members[jj]\n                    if not are_opponents(u, v):\n                        bad_pair = (u, v)\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if bad_pair is None:\n            break\n        p = random.choice(bad_pair)\n        rooms = sorted(set(labels_new))\n        candidates = rooms + [max(rooms)+1]\n        best_cost = None\n        best_rooms = []\n        for rr in candidates:\n            c = count_conflicts_for_room(labels_new, p, rr)\n            if best_cost is None or c < best_cost:\n                best_cost = c\n                best_rooms = [rr]\n            elif c == best_cost:\n                best_rooms.append(rr)\n        labels_new[p] = random.choice(best_rooms)\n    # Compress labels to dense\n    return serialize(labels_new)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST length=9; participants 1..9 mapped to 1-indexed room IDs. Example: \"1,2,3,1,2,3,2,1,3\"","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Parse CSV of 9 integers (rooms are 1-indexed)\n    try:\n        labels = [int(x.strip()) for x in solution.split(',') if x.strip()!='']\n    except Exception:\n        return 1000000000.0\n    n = 9\n    if len(labels) != n:\n        return 1000000000.0\n    if any(x < 1 for x in labels):\n        return 1000000000.0\n    # Opponent edges (undirected)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    # Count violations: same room but NOT opponents\n    violations = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if labels[i-1] == labels[j-1]:\n                key = (i,j) if i<j else (j,i)\n                if key not in opp:\n                    violations += 1\n    rooms_used = len(set(labels))\n    return float(1000*violations + rooms_used)\n","Vecindad":"import random\n\ndef generate_neighbour(solution):\n    # Returns a neighbour solution as CSV string (rooms 1..k), densified.\n    def parse(sol: str):\n        return [int(x.strip()) for x in sol.split(',') if x.strip()!='']\n    def serialize(labels):\n        # compress to dense 1..k\n        uniq = {}\n        next_id = 1\n        dense = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_id\n                next_id += 1\n            dense.append(uniq[x])\n        return ','.join(str(x) for x in dense)\n    labels = parse(solution)\n    n = len(labels)\n    if n != 9:\n        # fallback random valid-sized vector\n        labels = [1]*9\n        n = 9\n    # Opponent edges and fast lookup\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    def are_opponents(i,j):\n        a,b = (i+1,j+1) if i<j else (j+1,i+1)\n        return (a,b) in opp\n    # Build room membership\n    room_members = {}\n    for idx, r in enumerate(labels):\n        room_members.setdefault(r, []).append(idx)\n    rooms = sorted(room_members.keys())\n    # Compute conflicts (same room and not opponents)\n    conflicts = []\n    for r, members in room_members.items():\n        m = len(members)\n        for ii in range(m):\n            for jj in range(ii+1, m):\n                u, v = members[ii], members[jj]\n                if not are_opponents(u, v):\n                    conflicts.append((u, v))\n    def conflicts_if_assign(p_idx, room_label):\n        # Count conflicts p_idx would have in room_label\n        cnt = 0\n        for q in room_members.get(room_label, []):\n            if not are_opponents(p_idx, q):\n                cnt += 1\n        return cnt\n    labels_new = list(labels)\n    if conflicts:\n        # Conflict-driven reassignment\n        u,v = random.choice(conflicts)\n        p = random.choice([u,v])\n        k = len(rooms)\n        candidates = rooms + [max(rooms)+1]\n        best_cost = None\n        best_rooms = []\n        for rr in candidates:\n            c = conflicts_if_assign(p, rr)\n            if best_cost is None or c < best_cost:\n                best_cost = c\n                best_rooms = [rr]\n            elif c == best_cost:\n                best_rooms.append(rr)\n        target_room = random.choice(best_rooms)\n        labels_new[p] = target_room\n    else:\n        # Zero-conflict state: attempt room reduction by moving singletons only\n        singleton = None\n        for r in rooms:\n            if len(room_members[r]) == 1:\n                singleton = r\n                break\n        moved = False\n        if singleton is not None:\n            p = room_members[singleton][0]\n            compatible_rooms = []\n            for r in rooms:\n                if r == singleton:\n                    continue\n                if conflicts_if_assign(p, r) == 0:\n                    compatible_rooms.append(r)\n            if compatible_rooms:\n                labels_new[p] = random.choice(compatible_rooms)\n                moved = True\n        if not moved:\n            # Neutral swap between two participants (room reassignment if compatible)\n            i = random.randrange(n)\n            rooms_now = sorted(set(labels_new))\n            compat = [r for r in rooms_now if r != labels_new[i] and conflicts_if_assign(i, r) == 0]\n            if compat:\n                labels_new[i] = random.choice(compat)\n            # else leave unchanged to preserve feasibility\n    return serialize(labels_new)\n","Perturbacion":"import random\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-move perturbation with greedy repair; returns CSV string\n    def parse(sol: str):\n        return [int(x.strip()) for x in sol.split(',') if x.strip()!='']\n    def serialize(labels):\n        uniq = {}\n        next_id = 1\n        dense = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_id\n                next_id += 1\n            dense.append(uniq[x])\n        return ','.join(str(x) for x in dense)\n    labels = parse(solution)\n    n = len(labels)\n    if n != 9:\n        labels = [1]*9\n        n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    def are_opponents(i,j):\n        a,b = (i+1,j+1) if i<j else (j+1,i+1)\n        return (a,b) in opp\n    def build_room_members(L):\n        rm = {}\n        for idx, r in enumerate(L):\n            rm.setdefault(r, []).append(idx)\n        return rm\n    # Random recolor steps\n    labels_new = list(labels)\n    ksteps = max(4, n\/\/2)\n    for _ in range(ksteps):\n        i = random.randrange(n)\n        rooms_now = sorted(set(labels_new))\n        new_room = random.randint(1, min(len(rooms_now)+1, n))\n        labels_new[i] = new_room\n    # Greedy repair to eliminate conflicts\n    def count_conflicts_for_room(L, p_idx, room_label):\n        rm = build_room_members(L)\n        cnt = 0\n        for q in rm.get(room_label, []):\n            if not are_opponents(p_idx, q):\n                cnt += 1\n        return cnt\n    for _ in range(3*n):\n        rm = build_room_members(labels_new)\n        bad_pair = None\n        for r, members in rm.items():\n            m = len(members)\n            found = False\n            for ii in range(m):\n                for jj in range(ii+1, m):\n                    u, v = members[ii], members[jj]\n                    if not are_opponents(u, v):\n                        bad_pair = (u, v)\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if bad_pair is None:\n            break\n        p = random.choice(bad_pair)\n        rooms = sorted(set(labels_new))\n        candidates = rooms + [max(rooms)+1]\n        best_cost = None\n        best_rooms = []\n        for rr in candidates:\n            c = count_conflicts_for_room(labels_new, p, rr)\n            if best_cost is None or c < best_cost:\n                best_cost = c\n                best_rooms = [rr]\n            elif c == best_cost:\n                best_rooms.append(rr)\n        labels_new[p] = random.choice(best_rooms)\n    return serialize(labels_new)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_taekwondo_tournament_inverted","Representacion":"CSV_INT_LIST length=9; participants 1..9 mapped to 1-indexed room IDs. Example: \"1,2,3,1,2,3,2,1,3\"","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Parse CSV of 9 integers (rooms are 1-indexed)\n    try:\n        labels = [int(x.strip()) for x in solution.split(',') if x.strip()!='']\n    except Exception:\n        return 1000000000.0\n    n = 9\n    if len(labels) != n:\n        return 1000000000.0\n    if any(x < 1 for x in labels):\n        return 1000000000.0\n    # Opponent edges (undirected)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    # Count violations: same room but NOT opponents\n    violations = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if labels[i-1] == labels[j-1]:\n                key = (i,j) if i<j else (j,i)\n                if key not in opp:\n                    violations += 1\n    rooms_used = len(set(labels))\n    return float(1000*violations + rooms_used)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbour_solution_csv, move_type)\n    def parse(sol: str):\n        try:\n            return [int(x.strip()) for x in sol.split(',') if x.strip()!='']\n        except Exception:\n            return [1]*9\n    def serialize(labels):\n        # compress to dense 1..k (canonicalize)\n        uniq = {}\n        next_id = 1\n        dense = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_id\n                next_id += 1\n            dense.append(uniq[x])\n        return ','.join(str(x) for x in dense)\n    labels = parse(solution)\n    n = 9\n    if len(labels) != n:\n        labels = [1]*n\n    # Opponent edges and fast lookup\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    def are_opponents(i,j):\n        a,b = (i+1,j+1) if i<j else (j+1,i+1)\n        return (a,b) in opp\n    # Build room membership\n    room_members = {}\n    for idx, r in enumerate(labels):\n        room_members.setdefault(r, []).append(idx)\n    rooms = sorted(room_members.keys())\n    # Compute conflicts (same room and not opponents)\n    conflicts = []\n    for r, members in room_members.items():\n        m = len(members)\n        for ii in range(m):\n            for jj in range(ii+1, m):\n                u, v = members[ii], members[jj]\n                if not are_opponents(u, v):\n                    conflicts.append((u, v))\n    def conflicts_if_assign(p_idx, room_label):\n        cnt = 0\n        for q in room_members.get(room_label, []):\n            if not are_opponents(p_idx, q):\n                cnt += 1\n        return cnt\n    labels_new = list(labels)\n    move_type = \"noop\"\n    if conflicts:\n        # Conflict-driven reassignment\n        u,v = random.choice(conflicts)\n        p = random.choice([u,v])\n        rooms_now = sorted(set(labels_new))\n        candidates = rooms_now + ([max(rooms_now)+1] if rooms_now else [1])\n        # Exclude current room to avoid null move unless it's the only option\n        candidates = [rr for rr in candidates if rr != labels_new[p]] or [labels_new[p]]\n        best_cost = None\n        best_rooms = []\n        for rr in candidates:\n            c = conflicts_if_assign(p, rr)\n            if best_cost is None or c < best_cost:\n                best_cost = c\n                best_rooms = [rr]\n            elif c == best_cost:\n                best_rooms.append(rr)\n        target_room = random.choice(best_rooms)\n        labels_new[p] = target_room\n        move_type = \"conflict_reassign\"\n    else:\n        # Zero-conflict: try room reduction and structural moves\n        # 1) Greedy merge small rooms (size<=2)\n        reduced = False\n        for r in sorted(rooms, key=lambda x: len(room_members[x])):\n            members = list(room_members[r])\n            if len(members) <= 2:\n                can_move_all = True\n                assignments = {}\n                for p in members:\n                    placed = False\n                    for rr in rooms:\n                        if rr == r:\n                            continue\n                        if conflicts_if_assign(p, rr) == 0:\n                            assignments[p] = rr\n                            placed = True\n                            break\n                    if not placed:\n                        can_move_all = False\n                        break\n                if can_move_all and assignments:\n                    for p, rr in assignments.items():\n                        labels_new[p] = rr\n                    reduced = True\n                    move_type = \"room_reduce\"\n                    break\n        if not reduced:\n            # 2) Kempe-chain like 2-room swap\n            rooms_now = sorted(set(labels_new))\n            if len(rooms_now) >= 2:\n                r1, r2 = random.sample(rooms_now, 2)\n                A = set(room_members[r1])\n                B = set(room_members[r2])\n                # attempt to swap a random participant from each if compatible\n                a_candidates = [i for i in A if conflicts_if_assign(i, r2) == 0]\n                b_candidates = [j for j in B if conflicts_if_assign(j, r1) == 0]\n                if a_candidates and b_candidates:\n                    i = random.choice(a_candidates)\n                    j = random.choice(b_candidates)\n                    labels_new[i], labels_new[j] = r2, r1\n                    move_type = \"swap2\"\n                else:\n                    # 3) Neutral reassignment to another compatible room\n                    i = random.randrange(n)\n                    compat = [r for r in rooms_now if r != labels_new[i] and conflicts_if_assign(i, r) == 0]\n                    if compat:\n                        labels_new[i] = random.choice(compat)\n                        move_type = \"neutral_reassign\"\n                    else:\n                        move_type = \"idle\"\n            else:\n                move_type = \"idle\"\n    return serialize(labels_new), move_type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution: str) -> str:\n    # Multi-move perturbation with greedy repair; returns CSV string\n    def parse(sol: str):\n        try:\n            return [int(x.strip()) for x in sol.split(',') if x.strip()!='']\n        except Exception:\n            return [1]*9\n    def serialize(labels):\n        uniq = {}\n        next_id = 1\n        dense = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_id\n                next_id += 1\n            dense.append(uniq[x])\n        return ','.join(str(x) for x in dense)\n    labels = parse(solution)\n    n = 9\n    if len(labels) != n:\n        labels = [1]*n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),\n        (2,3),(2,4),(2,5),(2,7),(2,8),\n        (3,6),(3,8),(3,9),\n        (4,7),(4,8),(4,9),\n        (5,7),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    opp = set()\n    for a,b in edges:\n        if a>b:\n            a,b=b,a\n        opp.add((a,b))\n    def are_opponents(i,j):\n        a,b = (i+1,j+1) if i<j else (j+1,i+1)\n        return (a,b) in opp\n    def build_room_members(L):\n        rm = {}\n        for idx, r in enumerate(L):\n            rm.setdefault(r, []).append(idx)\n        return rm\n    # Random recolor steps\n    labels_new = list(labels)\n    ksteps = max(4, n\/\/2)\n    for _ in range(ksteps):\n        i = random.randrange(n)\n        rooms_now = sorted(set(labels_new))\n        if rooms_now:\n            new_room = random.randint(1, min(len(rooms_now)+1, n))\n        else:\n            new_room = 1\n        labels_new[i] = new_room\n    # Greedy repair to eliminate conflicts\n    def count_conflicts_for_room(L, p_idx, room_label):\n        rm = build_room_members(L)\n        cnt = 0\n        for q in rm.get(room_label, []):\n            if not are_opponents(p_idx, q):\n                cnt += 1\n        return cnt\n    for _ in range(3*n):\n        rm = build_room_members(labels_new)\n        bad_pair = None\n        for r, members in rm.items():\n            m = len(members)\n            found = False\n            for ii in range(m):\n                for jj in range(ii+1, m):\n                    u, v = members[ii], members[jj]\n                    if not are_opponents(u, v):\n                        bad_pair = (u, v)\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if bad_pair is None:\n            break\n        p = random.choice(bad_pair)\n        rooms = sorted(set(labels_new))\n        candidates = rooms + ([max(rooms)+1] if rooms else [1])\n        # Exclude current room\n        candidates = [rr for rr in candidates if rr != labels_new[p]] or [labels_new[p]]\n        best_cost = None\n        best_rooms = []\n        for rr in candidates:\n            c = count_conflicts_for_room(labels_new, p, rr)\n            if best_cost is None or c < best_cost:\n                best_cost = c\n                best_rooms = [rr]\n            elif c == best_cost:\n                best_rooms.append(rr)\n        labels_new[p] = random.choice(best_rooms)\n    return serialize(labels_new)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"CSV_INT_ASSIGNMENT_LEN9; labels are positive integers starting at 1 and contiguous; position i gives party of friend i.","Evaluacion":"import itertools\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Scalar cost (lower is better) for clique-partition feasibility on 9 friends.\n    Cost = 1_000_000*violations + 1_000*party_count\n    Representation: CSV of 9 ints, labels contiguous not required by eval.\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    # Precompute undirected adjacency as a set of pairs\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _violations(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,label in enumerate(assign, start=1):\n            groups[label].append(i)\n        vio = 0\n        for members in groups.values():\n            if len(members) <= 1:\n                continue\n            for u,v in itertools.combinations(members,2):\n                if (u,v) not in ADJ:\n                    vio += 1\n        return vio\n\n    def _party_count(assign):\n        return len(set(assign))\n\n    assign = _parse_solution_csv(solution)\n    vio = _violations(assign)\n    parties = _party_count(assign)\n    return float(1_000_000*vio + 1_000*parties)\n","Vecindad":"import random\nimport itertools\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution_csv, movement_type)\n    Feasibility-aware neighborhood on CSV_INT_ASSIGNMENT_LEN9 with labels normalized.\n    Movement types: 'reassign_feasible', 'swap', 'merge_clique', 'split_targeted', 'random_reassign'\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _to_csv(assign):\n        return ','.join(str(x) for x in assign)\n\n    def _normalize(assign):\n        uniq = sorted(set(assign))\n        remap = {lab:i+1 for i,lab in enumerate(uniq)}\n        return [remap[x] for x in assign]\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _party_members(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,l in enumerate(assign, start=1):\n            groups[l].append(i)\n        return groups\n\n    def _node_violations_in_party(node, members):\n        # count non-edges between node and other members\n        return sum(1 for u in members if u!=node and (node,u) not in ADJ)\n\n    assign = _parse_solution_csv(solution)\n    n = len(assign)\n\n    groups = _party_members(assign)\n    # list violating nodes (those that have any non-edge within their party)\n    viol_nodes = []\n    for label, members in groups.items():\n        for u in members:\n            if _node_violations_in_party(u, members) > 0:\n                viol_nodes.append(u)\n    move_type = None\n\n    r = random.random()\n    if viol_nodes and r < 0.5:\n        # feasibility-aware reassignment: move a violating node to a label where it fits\n        u = random.choice(viol_nodes)\n        current_label = assign[u-1]\n        candidate_labels = sorted(groups.keys())\n        feasible_labels = []\n        for lbl in candidate_labels:\n            members = groups[lbl]\n            if all((u,v) in ADJ for v in members if v!=u):\n                feasible_labels.append(lbl)\n        if feasible_labels:\n            new_label = random.choice(feasible_labels)\n            assign[u-1] = new_label\n            move_type = 'reassign_feasible'\n        else:\n            # create a new label\n            assign[u-1] = max(candidate_labels)+1\n            move_type = 'reassign_feasible'\n    elif r < 0.65:\n        # swap two nodes' labels\n        i,j = random.sample(range(n), 2)\n        assign[i], assign[j] = assign[j], assign[i]\n        move_type = 'swap'\n    elif r < 0.8:\n        # merge two parties only if their union is a clique\n        labels = list(groups.keys())\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            A = groups[a][:]\n            B = groups[b][:]\n            ok = True\n            for u,v in itertools.combinations(A+B,2):\n                if (u,v) not in ADJ:\n                    ok = False; break\n            if ok:\n                # relabel b -> a\n                assign = [a if x==b else x for x in assign]\n                move_type = 'merge_clique'\n            else:\n                # fallback random reassign\n                i = random.randrange(n)\n                labs = set(assign)\n                assign[i] = random.choice(list(labs) + [max(labs)+1])\n                move_type = 'random_reassign'\n        else:\n            i = random.randrange(n)\n            labs = set(assign)\n            assign[i] = random.choice(list(labs) + [max(labs)+1])\n            move_type = 'random_reassign'\n    else:\n        # targeted split: split the party by extracting nodes with highest internal conflicts\n        labels = list(groups.keys())\n        a = random.choice(labels)\n        members = groups[a][:]\n        if len(members) >= 2:\n            # score members by conflicts\n            scores = [(u, _node_violations_in_party(u, members)) for u in members]\n            scores.sort(key=lambda x: x[1], reverse=True)\n            # move top k>=1 to a new label\n            k = max(1, len(members)\/\/2)\n            to_move = [u for u,_ in scores[:k] if _ > 0] or [scores[0][0]]\n            new_label = max(labels)+1\n            for u in to_move:\n                assign[u-1] = new_label\n            move_type = 'split_targeted'\n        else:\n            # fallback reassign\n            i = random.randrange(n)\n            labs = set(assign)\n            assign[i] = random.choice(list(labs) + [max(labs)+1])\n            move_type = 'random_reassign'\n\n    assign = _normalize(assign)\n    return _to_csv(assign), move_type\n","Perturbacion":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger shake: perform k targeted reassignments focusing on violating nodes\n    and occasional clique-preserving merges\/splits. Returns CSV_INT_ASSIGNMENT_LEN9.\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _to_csv(assign):\n        return ','.join(str(x) for x in assign)\n\n    def _normalize(assign):\n        uniq = sorted(set(assign))\n        remap = {lab:i+1 for i,lab in enumerate(uniq)}\n        return [remap[x] for x in assign]\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _party_members(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,l in enumerate(assign, start=1):\n            groups[l].append(i)\n        return groups\n\n    def _node_violations_in_party(node, members):\n        return sum(1 for u in members if u!=node and (node,u) not in ADJ)\n\n    assign = _parse_solution_csv(solution)\n    groups = _party_members(assign)\n\n    k_moves = random.randint(3, 6)\n    for _ in range(k_moves):\n        groups = _party_members(assign)\n        # collect violating nodes\n        viol_nodes = []\n        for label, members in groups.items():\n            for u in members:\n                if _node_violations_in_party(u, members) > 0:\n                    viol_nodes.append(u)\n        r = random.random()\n        if viol_nodes and r < 0.7:\n            # move a random violating node to a feasible label if exists\n            u = random.choice(viol_nodes)\n            candidate_labels = sorted(groups.keys())\n            feasible = []\n            for lbl in candidate_labels:\n                members = groups[lbl]\n                if all((u,v) in ADJ for v in members if v!=u):\n                    feasible.append(lbl)\n            if feasible:\n                assign[u-1] = random.choice(feasible)\n            else:\n                assign[u-1] = max(candidate_labels)+1\n        elif r < 0.85:\n            # clique-preserving merge with small prob\n            labels = list(groups.keys())\n            if len(labels) >= 2:\n                a,b = random.sample(labels,2)\n                A = groups[a][:]; B = groups[b][:]\n                ok = True\n                for x,y in itertools.combinations(A+B,2):\n                    if (x,y) not in ADJ:\n                        ok = False; break\n                if ok:\n                    assign = [a if x==b else x for x in assign]\n        else:\n            # targeted split\n            labels = list(groups.keys())\n            a = random.choice(labels)\n            members = groups[a][:]\n            if len(members) >= 2:\n                scores = [(u, _node_violations_in_party(u, members)) for u in members]\n                scores.sort(key=lambda x: x[1], reverse=True)\n                to_move = [u for u,s in scores if s>0]\n                if not to_move:\n                    to_move = [members[0]]\n                new_label = max(labels)+1\n                for u in to_move[:max(1, len(members)\/\/2)]:\n                    assign[u-1] = new_label\n        assign = _normalize(assign)\n\n    assign = _normalize(assign)\n    return _to_csv(assign)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"CSV_INT_ASSIGNMENT_LEN9; labels are positive integers starting at 1 and contiguous; position i gives party of friend i.","Evaluacion":"import itertools\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Scalar cost (lower is better) for clique-partition feasibility on 9 friends.\n    Cost = 1_000_000*violations + 1_000*party_count\n    Representation: CSV of 9 ints, labels contiguous not required by eval.\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _violations(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,label in enumerate(assign, start=1):\n            groups[label].append(i)\n        vio = 0\n        for members in groups.values():\n            if len(members) <= 1:\n                continue\n            for u,v in itertools.combinations(members,2):\n                if (u,v) not in ADJ:\n                    vio += 1\n        return vio\n\n    def _party_count(assign):\n        return len(set(assign))\n\n    assign = _parse_solution_csv(solution)\n    vio = _violations(assign)\n    parties = _party_count(assign)\n    return float(1_000_000*vio + 1_000*parties)\n","Vecindad":"import random\nimport itertools\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution_csv, movement_type)\n    Feasibility-aware neighborhood on CSV_INT_ASSIGNMENT_LEN9 with labels normalized.\n    Movement types: 'reassign_feasible', 'swap_guided', 'merge_clique', 'split_targeted', 'random_reassign'\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _to_csv(assign):\n        return ','.join(str(x) for x in assign)\n\n    def _normalize(assign):\n        uniq = sorted(set(assign))\n        remap = {lab:i+1 for i,lab in enumerate(uniq)}\n        return [remap[x] for x in assign]\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _party_members(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,l in enumerate(assign, start=1):\n            groups[l].append(i)\n        return groups\n\n    def _node_violations_in_party(node, members):\n        return sum(1 for u in members if u!=node and (node,u) not in ADJ)\n\n    def _violations_total(assign):\n        groups = _party_members(assign)\n        vio = 0\n        for members in groups.values():\n            for u,v in itertools.combinations(members,2):\n                if (u,v) not in ADJ:\n                    vio += 1\n        return vio\n\n    assign = _parse_solution_csv(solution)\n    n = len(assign)\n    groups = _party_members(assign)\n\n    viol_nodes = []\n    for label, members in groups.items():\n        for u in members:\n            if _node_violations_in_party(u, members) > 0:\n                viol_nodes.append(u)\n\n    move_type = None\n    r = random.random()\n    if viol_nodes and r < 0.5:\n        # feasibility-aware reassignment: move a violating node to a label where it fits\n        u = random.choice(viol_nodes)\n        current_label = assign[u-1]\n        candidate_labels = sorted(groups.keys())\n        feasible_labels = []\n        for lbl in candidate_labels:\n            if lbl == current_label:\n                continue  # avoid null move\n            members = groups[lbl]\n            if all((u,v) in ADJ for v in members if v!=u):\n                feasible_labels.append(lbl)\n        if feasible_labels:\n            assign[u-1] = random.choice(feasible_labels)\n            move_type = 'reassign_feasible'\n        else:\n            # create a new label only as last resort\n            assign[u-1] = max(candidate_labels)+1\n            move_type = 'reassign_feasible'\n    elif r < 0.7:\n        # guided swap: accept only if it does not increase violations\n        i,j = random.sample(range(n), 2)\n        before = _violations_total(assign)\n        assign[i], assign[j] = assign[j], assign[i]\n        after = _violations_total(assign)\n        if after > before:\n            # revert with probability 1 to avoid degrading in pure NB\n            assign[i], assign[j] = assign[j], assign[i]\n        move_type = 'swap_guided'\n    elif r < 0.85:\n        # merge two parties only if their union is a clique\n        labels = list(groups.keys())\n        if len(labels) >= 2:\n            a,b = random.sample(labels, 2)\n            A = groups[a][:]\n            B = groups[b][:]\n            ok = True\n            for u,v in itertools.combinations(A+B,2):\n                if (u,v) not in ADJ:\n                    ok = False; break\n            if ok:\n                assign = [a if x==b else x for x in assign]\n                move_type = 'merge_clique'\n            else:\n                # fallback mild reassign within existing labels when possible\n                i = random.randrange(n)\n                labs = sorted(set(assign))\n                dests = [l for l in labs if l != assign[i]]\n                if dests:\n                    assign[i] = random.choice(dests)\n                move_type = 'random_reassign'\n        else:\n            i = random.randrange(n)\n            labs = sorted(set(assign))\n            dests = [l for l in labs if l != assign[i]]\n            if dests:\n                assign[i] = random.choice(dests)\n            move_type = 'random_reassign'\n    else:\n        # targeted split: move a single highest-conflict node out\n        labels = list(groups.keys())\n        a = random.choice(labels)\n        members = groups[a][:]\n        if len(members) >= 2:\n            scores = [(u, _node_violations_in_party(u, members)) for u in members]\n            scores.sort(key=lambda x: x[1], reverse=True)\n            if scores[0][1] > 0:\n                new_label = max(labels)+1\n                assign[scores[0][0]-1] = new_label\n                move_type = 'split_targeted'\n            else:\n                # no conflicts; do a gentle relabel to existing party\n                i = random.randrange(n)\n                labs = sorted(set(assign))\n                dests = [l for l in labs if l != assign[i]]\n                if dests:\n                    assign[i] = random.choice(dests)\n                move_type = 'random_reassign'\n        else:\n            i = random.randrange(n)\n            labs = sorted(set(assign))\n            dests = [l for l in labs if l != assign[i]]\n            if dests:\n                assign[i] = random.choice(dests)\n            move_type = 'random_reassign'\n\n    assign = _normalize(assign)\n    return _to_csv(assign), move_type\n","Perturbacion":"import random\nimport itertools\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger shake: perform several targeted moves focusing on violating nodes\n    with restrained party creation and occasional clique-preserving merges.\n    Returns CSV_INT_ASSIGNMENT_LEN9.\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _to_csv(assign):\n        return ','.join(str(x) for x in assign)\n\n    def _normalize(assign):\n        uniq = sorted(set(assign))\n        remap = {lab:i+1 for i,lab in enumerate(uniq)}\n        return [remap[x] for x in assign]\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _party_members(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,l in enumerate(assign, start=1):\n            groups[l].append(i)\n        return groups\n\n    def _node_violations_in_party(node, members):\n        return sum(1 for u in members if u!=node and (node,u) not in ADJ)\n\n    assign = _parse_solution_csv(solution)\n\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        groups = _party_members(assign)\n        # collect violating nodes\n        viol_nodes = []\n        for label, members in groups.items():\n            for u in members:\n                if _node_violations_in_party(u, members) > 0:\n                    viol_nodes.append(u)\n        r = random.random()\n        if viol_nodes and r < 0.65:\n            # move a violating node to a feasible existing label if possible\n            u = random.choice(viol_nodes)\n            current_label = assign[u-1]\n            candidate_labels = sorted(groups.keys())\n            feasible = []\n            for lbl in candidate_labels:\n                if lbl == current_label:\n                    continue\n                members = groups[lbl]\n                if all((u,v) in ADJ for v in members if v!=u):\n                    feasible.append(lbl)\n            if feasible:\n                assign[u-1] = random.choice(feasible)\n            else:\n                # if no feasible existing label, create at most one new label per step\n                assign[u-1] = max(candidate_labels)+1\n        elif r < 0.8:\n            # clique-preserving merge attempt\n            labels = list(groups.keys())\n            if len(labels) >= 2:\n                a,b = random.sample(labels,2)\n                A = groups[a][:]; B = groups[b][:]\n                ok = True\n                for x,y in itertools.combinations(A+B,2):\n                    if (x,y) not in ADJ:\n                        ok = False; break\n                if ok:\n                    assign = [a if x==b else x for x in assign]\n        else:\n            # targeted single-node split of most conflicting party\n            labels = list(groups.keys())\n            a = random.choice(labels)\n            members = groups[a][:]\n            if len(members) >= 2:\n                scores = [(u, _node_violations_in_party(u, members)) for u in members]\n                scores.sort(key=lambda x: x[1], reverse=True)\n                if scores[0][1] > 0:\n                    new_label = max(labels)+1\n                    assign[scores[0][0]-1] = new_label\n        assign = _normalize(assign)\n\n    assign = _normalize(assign)\n    return _to_csv(assign)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_23_parties_with_exes_inverted","Representacion":"CSV_INT_ASSIGNMENT_LEN9; labels are positive integers starting at 1 and contiguous after normalization; position i gives party of friend i.","Evaluacion":"import itertools\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Scalar cost (lower is better) for clique-partition feasibility on 9 friends.\n    Cost = 1_000_000*violations + 1_000*party_count\n    Representation: CSV of 9 ints (labels need not be contiguous on input).\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _violations(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,label in enumerate(assign, start=1):\n            groups[label].append(i)\n        vio = 0\n        for members in groups.values():\n            if len(members) <= 1:\n                continue\n            for u,v in itertools.combinations(members,2):\n                if (u,v) not in ADJ:\n                    vio += 1\n        return vio\n\n    def _party_count(assign):\n        return len(set(assign))\n\n    assign = _parse_solution_csv(solution)\n    vio = _violations(assign)\n    parties = _party_count(assign)\n    return float(1_000_000*vio + 1_000*parties)\n","Vecindad":"import random\nimport itertools\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (new_solution_csv, movement_type)\n    Feasibility-aware neighborhood on CSV_INT_ASSIGNMENT_LEN9 with labels normalized.\n    Movement types: 'reassign_feasible', 'swap_guided', 'merge_relaxed', 'split_targeted', 'random_reassign'\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _to_csv(assign):\n        return ','.join(str(x) for x in assign)\n\n    def _normalize(assign):\n        uniq = sorted(set(assign))\n        remap = {lab:i+1 for i,lab in enumerate(uniq)}\n        return [remap[x] for x in assign]\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _party_members(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,l in enumerate(assign, start=1):\n            groups[l].append(i)\n        return groups\n\n    def _node_violations_in_party(node, members):\n        return sum(1 for u in members if u!=node and (node,u) not in ADJ)\n\n    def _violations_total(assign):\n        groups = _party_members(assign)\n        vio = 0\n        for members in groups.values():\n            for u,v in itertools.combinations(members,2):\n                if (u,v) not in ADJ:\n                    vio += 1\n        return vio\n\n    assign = _parse_solution_csv(solution)\n    n = len(assign)\n\n    # retry budget to avoid null moves\n    for _attempt in range(5):\n        groups = _party_members(assign)\n        viol_nodes = []\n        for label, members in groups.items():\n            for u in members:\n                if _node_violations_in_party(u, members) > 0:\n                    viol_nodes.append(u)\n\n        move_type = None\n        r = random.random()\n        if viol_nodes and r < 0.5:\n            # feasibility-aware reassignment: move a violating node to a label where it fits, else best non-worsening\n            u = random.choice(viol_nodes)\n            current_label = assign[u-1]\n            candidate_labels = sorted(groups.keys())\n            feasible_labels = []\n            best_lbl = None\n            best_delta = None\n            before = _violations_total(assign)\n            for lbl in candidate_labels:\n                if lbl == current_label:\n                    continue\n                members = groups[lbl]\n                if all((u,v) in ADJ for v in members if v!=u):\n                    feasible_labels.append(lbl)\n                # evaluate delta by tentative move\n                old = assign[u-1]\n                assign[u-1] = lbl\n                after = _violations_total(assign)\n                delta = after - before\n                assign[u-1] = old\n                if best_delta is None or (delta < best_delta) or (delta == best_delta and lbl < (best_lbl if best_lbl is not None else 1e9)):\n                    best_delta = delta; best_lbl = lbl\n            if feasible_labels:\n                assign[u-1] = random.choice(feasible_labels)\n                move_type = 'reassign_feasible'\n            elif best_lbl is not None and best_delta is not None and best_delta <= 0:\n                assign[u-1] = best_lbl\n                move_type = 'reassign_feasible'\n            else:\n                # create a new label only as last resort\n                assign[u-1] = max(candidate_labels)+1\n                move_type = 'reassign_feasible'\n        elif r < 0.7:\n            # guided swap: accept only if it does not increase violations\n            i,j = random.sample(range(n), 2)\n            before = _violations_total(assign)\n            assign[i], assign[j] = assign[j], assign[i]\n            after = _violations_total(assign)\n            if after > before:\n                # revert and try again in loop\n                assign[i], assign[j] = assign[j], assign[i]\n                continue\n            move_type = 'swap_guided'\n        elif r < 0.9:\n            # relaxed merge: allow merge if it does not increase violations and reduces party count\n            labels = list(groups.keys())\n            if len(labels) >= 2:\n                a,b = random.sample(labels, 2)\n                before = _violations_total(assign)\n                merged = [a if x==b else x for x in assign]\n                after = _violations_total(merged)\n                if after <= before and len(set(merged)) < len(set(assign)):\n                    assign = merged\n                    move_type = 'merge_relaxed'\n                else:\n                    # mild reassignment fallback\n                    i = random.randrange(n)\n                    labs = sorted(set(assign))\n                    dests = [l for l in labs if l != assign[i]]\n                    if dests:\n                        assign[i] = random.choice(dests)\n                    move_type = 'random_reassign'\n            else:\n                i = random.randrange(n)\n                labs = sorted(set(assign))\n                dests = [l for l in labs if l != assign[i]]\n                if dests:\n                    assign[i] = random.choice(dests)\n                move_type = 'random_reassign'\n        else:\n            # targeted split: try moving highest-conflict node into best compatible existing label, else new\n            labels = list(groups.keys())\n            a = random.choice(labels)\n            members = groups[a][:]\n            if len(members) >= 2:\n                scores = [(u, _node_violations_in_party(u, members)) for u in members]\n                scores.sort(key=lambda x: x[1], reverse=True)\n                u = scores[0][0]\n                current_label = assign[u-1]\n                candidate_labels = sorted(set(assign))\n                best_lbl = None\n                best_delta = None\n                before = _violations_total(assign)\n                for lbl in candidate_labels:\n                    if lbl == current_label:\n                        continue\n                    old = assign[u-1]\n                    assign[u-1] = lbl\n                    after = _violations_total(assign)\n                    delta = after - before\n                    assign[u-1] = old\n                    if best_delta is None or (delta < best_delta) or (delta == best_delta and lbl < (best_lbl if best_lbl is not None else 1e9)):\n                        best_delta = delta; best_lbl = lbl\n                if best_lbl is not None and best_delta is not None and best_delta <= 0:\n                    assign[u-1] = best_lbl\n                    move_type = 'split_targeted'\n                else:\n                    assign[u-1] = max(candidate_labels)+1\n                    move_type = 'split_targeted'\n            else:\n                i = random.randrange(n)\n                labs = sorted(set(assign))\n                dests = [l for l in labs if l != assign[i]]\n                if dests:\n                    assign[i] = random.choice(dests)\n                move_type = 'random_reassign'\n\n        assign = _normalize(assign)\n        return _to_csv(assign), move_type\n\n    # If all retries failed to change, force a random label change\n    labs = sorted(set(assign))\n    i = random.randrange(n)\n    if len(labs) == 1:\n        assign[i] = 2\n    else:\n        dests = [l for l in labs if l != assign[i]]\n        assign[i] = random.choice(dests)\n    assign = _normalize(assign)\n    return _to_csv(assign), 'random_reassign'\n","Perturbacion":"import random\nimport itertools\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Stronger shake: perform several targeted moves focusing on violating nodes\n    with restrained party creation and occasional non-worsening merges.\n    Returns CSV_INT_ASSIGNMENT_LEN9.\n    \"\"\"\n    def _parse_solution_csv(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip()!='']\n        elif isinstance(sol, (list, tuple)):\n            parts = list(map(str, sol))\n        else:\n            raise ValueError('Unsupported solution type')\n        vals = list(map(int, parts))\n        if len(vals) != 9:\n            raise ValueError('Solution length must be 9')\n        return vals\n\n    def _to_csv(assign):\n        return ','.join(str(x) for x in assign)\n\n    def _normalize(assign):\n        uniq = sorted(set(assign))\n        remap = {lab:i+1 for i,lab in enumerate(uniq)}\n        return [remap[x] for x in assign]\n\n    def _adjacency():\n        E = {\n            (1,4),(1,5),(1,6),(1,8),\n            (2,3),(2,4),(2,5),(2,7),(2,8),\n            (3,6),(3,8),(3,9),\n            (4,7),(4,8),(4,9),\n            (5,7),(5,9),\n            (6,9),\n            (7,8)\n        }\n        undirected = set()\n        for u,v in E:\n            undirected.add((u,v)); undirected.add((v,u))\n        return undirected\n\n    ADJ = _adjacency()\n\n    def _party_members(assign):\n        from collections import defaultdict\n        groups = defaultdict(list)\n        for i,l in enumerate(assign, start=1):\n            groups[l].append(i)\n        return groups\n\n    def _node_violations_in_party(node, members):\n        return sum(1 for u in members if u!=node and (node,u) not in ADJ)\n\n    def _violations_total(assign):\n        groups = _party_members(assign)\n        vio = 0\n        for members in groups.values():\n            for u,v in itertools.combinations(members,2):\n                if (u,v) not in ADJ:\n                    vio += 1\n        return vio\n\n    assign = _parse_solution_csv(solution)\n\n    steps = random.randint(4, 7)\n    for _ in range(steps):\n        groups = _party_members(assign)\n        viol_nodes = []\n        for label, members in groups.items():\n            for u in members:\n                if _node_violations_in_party(u, members) > 0:\n                    viol_nodes.append(u)\n        r = random.random()\n        if viol_nodes and r < 0.65:\n            # move a violating node to a feasible\/best non-worsening existing label if possible\n            u = random.choice(viol_nodes)\n            current_label = assign[u-1]\n            candidate_labels = sorted(groups.keys())\n            feasible = []\n            best_lbl = None\n            best_delta = None\n            before = _violations_total(assign)\n            for lbl in candidate_labels:\n                if lbl == current_label:\n                    continue\n                members = groups[lbl]\n                if all((u,v) in ADJ for v in members if v!=u):\n                    feasible.append(lbl)\n                old = assign[u-1]\n                assign[u-1] = lbl\n                after = _violations_total(assign)\n                delta = after - before\n                assign[u-1] = old\n                if best_delta is None or delta < best_delta:\n                    best_delta = delta; best_lbl = lbl\n            if feasible:\n                assign[u-1] = random.choice(feasible)\n            elif best_lbl is not None and best_delta is not None and best_delta <= 0:\n                assign[u-1] = best_lbl\n            else:\n                assign[u-1] = max(candidate_labels)+1\n        elif r < 0.85:\n            # non-worsening merge attempt\n            labels = list(groups.keys())\n            if len(labels) >= 2:\n                a,b = random.sample(labels,2)\n                before = _violations_total(assign)\n                merged = [a if x==b else x for x in assign]\n                after = _violations_total(merged)\n                if after <= before and len(set(merged)) < len(set(assign)):\n                    assign = merged\n        else:\n            # targeted single-node split of most conflicting party\n            labels = list(groups.keys())\n            a = random.choice(labels)\n            members = groups[a][:]\n            if len(members) >= 2:\n                scores = [(u, _node_violations_in_party(u, members)) for u in members]\n                scores.sort(key=lambda x: x[1], reverse=True)\n                if scores[0][1] > 0:\n                    current_labels = sorted(set(assign))\n                    u = scores[0][0]\n                    # try best existing label first\n                    best_lbl = None\n                    best_delta = None\n                    before = _violations_total(assign)\n                    for lbl in current_labels:\n                        if lbl == assign[u-1]:\n                            continue\n                        old = assign[u-1]\n                        assign[u-1] = lbl\n                        after = _violations_total(assign)\n                        delta = after - before\n                        assign[u-1] = old\n                        if best_delta is None or delta < best_delta:\n                            best_delta = delta; best_lbl = lbl\n                    if best_lbl is not None and best_delta is not None and best_delta <= 0:\n                        assign[u-1] = best_lbl\n                    else:\n                        assign[u-1] = max(current_labels)+1\n        assign = _normalize(assign)\n\n    assign = _normalize(assign)\n    return _to_csv(assign)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_1..K_ORDERED_BY_NODE_INDEX","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input\n    if not isinstance(solution, list) or len(solution) != 9:\n        return float('inf')\n    for c in solution:\n        if not isinstance(c, int) or c < 1:\n            return float('inf')\n    # Adjacency (1-indexed in data, mapped to 0-indexed)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if solution[u-1] == solution[v-1]:\n            conflicts += 1\n    # Number of colors used\n    num_colors = len(set(solution))\n    # Cost: feasibility priority, then minimize colors\n    return conflicts * 1000 + num_colors\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    n = len(solution) if isinstance(solution, list) else 0\n    if n != 9:\n        return (solution[:] if isinstance(solution, list) else solution, \"invalid_length_noop\")\n\n    # Build adjacency for local conflict checks\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    sol = solution[:]\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(9) if any(sol[i] == sol[j] for j in adj[i])]\n    # Choose a vertex: prefer conflicted; if none, pick random to attempt color reduction\n    i = random.choice(conflicted) if conflicted else random.randrange(9)\n\n    # Current color set size\n    k = max(sol) if sol else 1\n\n    # Min-conflicts recolor within existing palette first\n    best_c = sol[i]\n    best_val = 10**9\n    for c in range(1, k+1):\n        if c == sol[i]:\n            continue\n        val = sum(1 for j in adj[i] if sol[j] == c)\n        if val < best_val or (val == best_val and c < best_c):\n            best_val = val\n            best_c = c\n\n    movement = \"recolor_minconf\"\n\n    # If still conflicted at this vertex and no zero-conflict color available,\n    # allow introducing a new color sparingly (only when vertex currently conflicts)\n    if conflicted and best_val > 0:\n        new_color = k + 1\n        sol[i] = new_color\n        movement = \"introduce_color\"\n    else:\n        # Apply best existing color (may reduce colors if followed by global cleanup)\n        sol[i] = best_c\n\n    return sol, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Structured perturbation: try merge two colors, then greedy local repairs\n    if not isinstance(solution, list) or len(solution) != 9:\n        return solution[:] if isinstance(solution, list) else solution\n\n    sol = solution[:]  # copy\n    k = max(sol) if sol else 1\n\n    # If at least two colors exist, merge two random colors to challenge palette size\n    if k >= 2:\n        a, b = sorted(random.sample(range(1, k+1), 2))\n        sol = [a if c == b else c for c in sol]\n\n    # Build adjacency\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    adj = [[] for _ in range(9)]\n    for u, v in edges:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n\n    # Greedy repair for a few steps\n    steps = 4\n    for _ in range(steps):\n        conflicted = [i for i in range(9) if any(sol[i] == sol[j] for j in adj[i])]\n        if not conflicted:\n            break\n        i = random.choice(conflicted)\n        k = max(sol)\n        best_c = sol[i]\n        best_val = 10**9\n        for c in range(1, k+1):\n            if c == sol[i]:\n                continue\n            val = sum(1 for j in adj[i] if sol[j] == c)\n            if val < best_val or (val == best_val and c < best_c):\n                best_val = val\n                best_c = c\n        sol[i] = best_c\n\n    return sol\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_1..K_ORDERED_BY_NODE_INDEX","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept list\/tuple; reject others\n    if isinstance(solution, (list, tuple)):\n        sol = list(solution)\n    else:\n        return float('inf')\n    # Validate length and domain\n    if len(sol) != 9:\n        return float('inf')\n    for c in sol:\n        if not isinstance(c, int) or c < 1:\n            return float('inf')\n    # Adjacency (1-indexed in data, mapped to 0-indexed)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Number of colors used (labels may be non-contiguous; use set)\n    num_colors = len(set(sol))\n    # Cost: lexicographically minimize (conflicts, colors). Heavy weight on conflicts.\n    return conflicts * 1000000 + num_colors\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if isinstance(solution, (list, tuple)):\n        sol = list(solution)\n    else:\n        return solution, \"invalid_input_noop\"\n    if len(sol) != 9:\n        return sol[:], \"invalid_length_noop\"\n\n    # Problem data\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for u, v in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(9)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Palette compaction utility (stabilizes k and removes gaps)\n    def compact_palette(arr):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    sol = compact_palette(sol)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(9) if any(sol[i] == sol[j] for j in adj[i])]\n\n    movement = \"recolor_minconflict\"\n\n    # Choose a vertex: prefer conflicted; otherwise pick one that may reduce max color\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        # bias towards vertices using the highest color to promote reduction\n        k = max(sol)\n        candidates = [idx for idx, c in enumerate(sol) if c == k]\n        i = random.choice(candidates) if candidates else random.randrange(9)\n\n    # Try min-conflict recoloring within current palette (no new colors)\n    k = max(sol)\n    best_c = sol[i]\n    best_val = 10**9\n    # Evaluate conflict count for color c on vertex i\n    for c in range(1, k+1):\n        if c == sol[i]:\n            continue\n        val = 0\n        for j in adj[i]:\n            if sol[j] == c:\n                val += 1\n        if val < best_val or (val == best_val and c < best_c):\n            best_val = val\n            best_c = c\n\n    # Apply move\n    old_c = sol[i]\n    sol[i] = best_c\n    if best_c != old_c:\n        movement = \"recolor_minconflict\"\n    else:\n        movement = \"noop_retain\"\n\n    # Compact palette again (may reduce number of colors if a color becomes unused)\n    sol = compact_palette(sol)\n\n    return sol, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate and copy\n    if isinstance(solution, (list, tuple)):\n        sol = list(solution)\n    else:\n        return solution\n    if len(sol) != 9:\n        return sol[:]\n\n    # Problem data\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for u, v in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(9)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Palette compaction utility\n    def compact_palette(arr):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    sol = compact_palette(sol)\n    k = max(sol)\n\n    # If at least two colors, randomly merge one color class into another to challenge palette size\n    if k >= 2:\n        a, b = sorted(random.sample(range(1, k+1), 2))\n        # Map color b to a\n        sol = [a if c == b else c for c in sol]\n        sol = compact_palette(sol)\n\n    # Local greedy repairs for a few steps to reduce conflicts introduced by merge\n    steps = 5\n    for _ in range(steps):\n        # Find conflicted vertices\n        conflicted = [i for i in range(9) if any(sol[i] == sol[j] for j in adj[i])]\n        if not conflicted:\n            break\n        i = random.choice(conflicted)\n        k = max(sol)\n        # Try best recolor within current palette\n        best_c = sol[i]\n        best_val = 10**9\n        for c in range(1, k+1):\n            if c == sol[i]:\n                continue\n            val = 0\n            for j in adj[i]:\n                if sol[j] == c:\n                    val += 1\n            if val < best_val or (val == best_val and c < best_c):\n                best_val = val\n                best_c = c\n        sol[i] = best_c\n        sol = compact_palette(sol)\n\n    return sol\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"LIST_INT_LEN9_COLORS_1..K_ORDERED_BY_NODE_INDEX","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept list\/tuple; reject others\n    if isinstance(solution, (list, tuple)):\n        sol = list(solution)\n    else:\n        return float('inf')\n    # Validate length and domain\n    if len(sol) != 9:\n        return float('inf')\n    for c in sol:\n        if not isinstance(c, int) or c < 1:\n            return float('inf')\n    # Adjacency (1-indexed in data, mapped to 0-indexed)\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if sol[u-1] == sol[v-1]:\n            conflicts += 1\n    # Number of colors used (labels may be non-contiguous; use set)\n    num_colors = len(set(sol))\n    # Cost: lexicographically minimize (conflicts, colors). Heavy weight on conflicts.\n    return conflicts * 1000000 + num_colors\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Defensive copy and validation\n    if isinstance(solution, (list, tuple)):\n        sol = list(solution)\n    else:\n        return solution, \"invalid_input_noop\"\n    if len(sol) != 9:\n        return sol[:], \"invalid_length_noop\"\n\n    # Problem data\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for u, v in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(9)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Palette compaction utility (stabilizes k and removes gaps)\n    def compact_palette(arr):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    sol = compact_palette(sol)\n\n    # Identify conflicted vertices\n    conflicted = [i for i in range(9) if any(sol[i] == sol[j] for j in adj[i])]\n\n    movement = \"recolor_minconflict\"\n\n    # Choose a vertex: prefer conflicted; otherwise pick one that may reduce max color\n    if conflicted:\n        i = random.choice(conflicted)\n    else:\n        # bias towards vertices using the highest color to promote reduction\n        k = max(sol)\n        candidates = [idx for idx, c in enumerate(sol) if c == k]\n        i = random.choice(candidates) if candidates else random.randrange(9)\n\n    # Try min-conflict recoloring within current palette (no new colors)\n    k = max(sol)\n    best_c = sol[i]\n    best_val = 10**9\n    # Evaluate conflict count for color c on vertex i\n    for c in range(1, k+1):\n        if c == sol[i]:\n            continue\n        val = 0\n        for j in adj[i]:\n            if sol[j] == c:\n                val += 1\n        if val < best_val or (val == best_val and c < best_c and random.random() < 0.5):\n            best_val = val\n            best_c = c\n\n    # If no improvement and more than 1 color, attempt a simple Kempe-chain swap between two colors around i\n    if best_c == sol[i] and k >= 2:\n        colors = list(range(1, k+1))\n        colors.remove(sol[i])\n        c2 = random.choice(colors)\n        c1 = sol[i]\n        # BFS over subgraph induced by colors {c1,c2} starting at i\n        from collections import deque\n        q = deque([i])\n        visited = set([i])\n        sub = []\n        while q:\n            u = q.popleft()\n            sub.append(u)\n            for v in adj[u]:\n                if sol[v] in (c1, c2) and v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        # Swap c1<->c2 on this component\n        for u in sub:\n            sol[u] = c2 if sol[u] == c1 else (c1 if sol[u] == c2 else sol[u])\n        movement = \"kempe_swap\"\n    else:\n        # Apply recolor\n        old_c = sol[i]\n        sol[i] = best_c\n        movement = \"recolor_minconflict\" if best_c != old_c else \"noop_retain\"\n\n    # Compact palette again (may reduce number of colors if a color becomes unused)\n    sol = compact_palette(sol)\n\n    return sol, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Validate and copy\n    if isinstance(solution, (list, tuple)):\n        sol = list(solution)\n    else:\n        return solution\n    if len(sol) != 9:\n        return sol[:]\n\n    # Problem data\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for u, v in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(9)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Palette compaction utility\n    def compact_palette(arr):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in arr:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    sol = compact_palette(sol)\n    k = max(sol)\n\n    # If at least two colors, randomly merge one color class into another to challenge palette size\n    if k >= 2:\n        a, b = sorted(random.sample(range(1, k+1), 2))\n        # Map color b to a\n        sol = [a if c == b else c for c in sol]\n        sol = compact_palette(sol)\n\n    # Local greedy repairs for a few steps to reduce conflicts introduced by merge\n    steps = 6\n    for _ in range(steps):\n        # Find conflicted vertices\n        conflicted = [i for i in range(9) if any(sol[i] == sol[j] for j in adj[i])]\n        if not conflicted:\n            break\n        i = random.choice(conflicted)\n        k = max(sol)\n        # Try best recolor within current palette\n        best_c = sol[i]\n        best_val = 10**9\n        for c in range(1, k+1):\n            if c == sol[i]:\n                continue\n            val = 0\n            for j in adj[i]:\n                if sol[j] == c:\n                    val += 1\n            if val < best_val or (val == best_val and c < best_c and random.random() < 0.5):\n                best_val = val\n                best_c = c\n        sol[i] = best_c\n        sol = compact_palette(sol)\n\n    return sol\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV_INT_LIST.N=9.VALUES\u2208{1..K}.ORDER_BY_STUDENT_ID_ASC","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Parse CSV -> list[int]\n    try:\n        colors = [int(x) for x in solution.strip().split(',') if x.strip()]\n    except Exception:\n        return float('inf')\n    n = 9\n    if len(colors) != n:\n        return float('inf')\n    # Graph (0-indexed)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    # Conflicts\n    conflicts = 0\n    for u, v in edges:\n        if colors[u] == colors[v]:\n            conflicts += 1\n    # Groups used\n    groups_used = len(set(colors))\n    # Lexicographic objective via large multiplier\n    return float(conflicts) * 10000.0 + float(groups_used)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helpers\n    def parse(sol):\n        try:\n            return [int(x) for x in sol.strip().split(',') if x.strip()]\n        except Exception:\n            return []\n    def to_csv(cols):\n        return ','.join(str(x) for x in cols)\n    n = 9\n    cols = parse(solution)\n    if len(cols) != n:\n        return (solution, \"invalid_input\")\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    def node_conflicts(i, c=None):\n        col = cols[i] if c is None else c\n        cnt = 0\n        for nb in adj[i]:\n            if cols[nb] == col:\n                cnt += 1\n        return cnt\n    total_conf = 0\n    for u, v in edges:\n        if cols[u] == cols[v]:\n            total_conf += 1\n    max_color = max(cols) if cols else 1\n    # Move strategy\n    # 1) If conflicts exist: pick a max-conflict node and recolor to best color in 1..max_color+1 minimizing its conflicts, tie-break by fewer groups then smaller color.\n    if total_conf > 0:\n        best_i = 0\n        best_nc = -1\n        for i in range(n):\n            nc = node_conflicts(i)\n            if nc > best_nc or (nc == best_nc and i < best_i):\n                best_nc = nc\n                best_i = i\n        i = best_i\n        best_c = cols[i]\n        best_tuple = (node_conflicts(i), len(set(cols)), cols[i])\n        for c in range(1, max_color + 2):\n            if c == cols[i]:\n                continue\n            old = cols[i]\n            cols[i] = c\n            cand_tuple = (node_conflicts(i), len(set(cols)), c)\n            cols[i] = old\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_c = c\n        cols[i] = best_c\n        return (to_csv(cols), \"recolor_conflict\")\n    # 2) No conflicts: try compressing colors by moving a node to an existing color not used by its neighbors.\n    color_counts = {}\n    for c in cols:\n        color_counts[c] = color_counts.get(c, 0) + 1\n    max_color = max(cols) if cols else 1\n    # Prefer singleton colors\n    singleton_nodes = [i for i in range(n) if color_counts.get(cols[i], 0) == 1]\n    candidates = singleton_nodes if singleton_nodes else list(range(n))\n    random.shuffle(candidates)\n    for i in candidates:\n        used_nb = {cols[nb] for nb in adj[i]}\n        avail = [c for c in range(1, max_color + 1) if c != cols[i] and c not in used_nb]\n        if avail:\n            cols[i] = min(avail)\n            return (to_csv(cols), \"recolor_compress\")\n    # 3) If no safe compression, try a random color swap (Kempe-like) between two colors on a random connected component induced by those colors.\n    a = random.randrange(1, max_color + 1)\n    b = a\n    if max_color >= 2:\n        while b == a:\n            b = random.randrange(1, max_color + 1)\n    # BFS over nodes with color in {a,b} reachable from a random seed having color a or b\n    nodes_ab = [i for i in range(n) if cols[i] == a or cols[i] == b]\n    if nodes_ab:\n        seed = random.choice(nodes_ab)\n        target_set = set()\n        stack = [seed]\n        seen = set([seed])\n        while stack:\n            u = stack.pop()\n            if cols[u] == a or cols[u] == b:\n                target_set.add(u)\n                for v in adj[u]:\n                    if v not in seen and (cols[v] == a or cols[v] == b):\n                        seen.add(v)\n                        stack.append(v)\n        # swap a<->b on target_set\n        for u in target_set:\n            cols[u] = a if cols[u] == b else (b if cols[u] == a else cols[u])\n        return (to_csv(cols), \"kempe_swap\")\n    # Fallback: random recolor\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    cols[i] = c\n    return (to_csv(cols), \"random_recolor\")\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Random multi-move shake: merge two colors if possible then repair via min-conflicts recolors\n    def parse(sol):\n        try:\n            return [int(x) for x in sol.strip().split(',') if x.strip()]\n        except Exception:\n            return []\n    def to_csv(cols):\n        return ','.join(str(x) for x in cols)\n    n = 9\n    cols = parse(solution)\n    if len(cols) != n:\n        return solution\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    max_color = max(cols) if cols else 1\n    # Choose two colors to merge (or introduce a new one with small prob)\n    if max_color >= 2:\n        a = random.randrange(1, max_color + 1)\n        b = a\n        while b == a:\n            b = random.randrange(1, max_color + 1)\n        # Merge b into a\n        for i in range(n):\n            if cols[i] == b:\n                cols[i] = a\n    else:\n        # Introduce a second color randomly\n        for _ in range(2):\n            i = random.randrange(n)\n            cols[i] = 2\n    # Repair: up to R min-conflicts recolors allowing a new color if necessary\n    def conflicts_count(ca):\n        cnt = 0\n        for u, v in edges:\n            if ca[u] == ca[v]:\n                cnt += 1\n        return cnt\n    R = 10\n    for _ in range(R):\n        # find a conflicted node\n        conflicted = []\n        for u, v in edges:\n            if cols[u] == cols[v]:\n                conflicted.append(u)\n                conflicted.append(v)\n        if not conflicted:\n            break\n        i = random.choice(conflicted)\n        max_color = max(cols) if cols else 1\n        best_c = cols[i]\n        best_val = (10**9, 10**9)\n        for c in range(1, max_color + 2):\n            if c == cols[i]:\n                continue\n            old = cols[i]\n            cols[i] = c\n            cand = (conflicts_count(cols), len(set(cols)))\n            cols[i] = old\n            if cand < best_val:\n                best_val = cand\n                best_c = c\n        cols[i] = best_c\n    return to_csv(cols)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV_INT_LIST.N=9.VALUES\u2208{1..K}.ORDER_BY_STUDENT_ID_ASC","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Accept CSV string, list, or tuple; return lexicographic cost: (conflicts, groups)\n    # with conflicts dominating via M = |E|+1\n    def parse_to_list(sol):\n        if isinstance(sol, str):\n            try:\n                vals = [int(x) for x in sol.strip().split(',') if x.strip()]\n                return vals\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple)):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n    cols = parse_to_list(solution)\n    n = 9\n    if cols is None or len(cols) != n:\n        return float('inf')\n    # Graph (0-indexed)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    # Validate colors are positive integers\n    for c in cols:\n        if not isinstance(c, int) or c < 1:\n            return float('inf')\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if cols[u] == cols[v]:\n            conflicts += 1\n    groups_used = len(set(cols))\n    M = len(edges) + 1\n    return float(conflicts * M + groups_used)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_csv, move_type)\n    def parse(sol):\n        if isinstance(sol, str):\n            try:\n                return [int(x) for x in sol.strip().split(',') if x.strip()]\n            except Exception:\n                return []\n        elif isinstance(sol, (list, tuple)):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        else:\n            return []\n    def to_csv(cols):\n        return ','.join(str(x) for x in cols)\n    def canonicalize(cols):\n        # Relabel colors to 1..k by first appearance order\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    n = 9\n    cols = parse(solution)\n    if len(cols) != n:\n        return (solution if isinstance(solution, str) else to_csv(cols), \"invalid_input\")\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    def node_conflicts(i, color=None):\n        c = cols[i] if color is None else color\n        cnt = 0\n        for nb in adj[i]:\n            if cols[nb] == c:\n                cnt += 1\n        return cnt\n    # Total conflicts\n    total_conf = 0\n    for u, v in edges:\n        if cols[u] == cols[v]:\n            total_conf += 1\n    max_color = max(cols) if cols else 1\n    # Phase 1: resolve conflicts via min-conflicts recolor on a critical vertex\n    if total_conf > 0:\n        # Select vertex: max conflicts, tie-break by higher degree then lower index\n        best_i = 0\n        best_key = (-1, -1, 1e9)\n        for i in range(n):\n            nc = node_conflicts(i)\n            deg = len(adj[i])\n            key = (nc, deg, -i)\n            if key > best_key:\n                best_key = key\n                best_i = i\n        i = best_i\n        current_groups = len(set(cols))\n        best_c = cols[i]\n        best_tuple = (node_conflicts(i), current_groups, cols[i])\n        for c in range(1, max_color + 2):\n            if c == cols[i]:\n                continue\n            old = cols[i]\n            cols[i] = c\n            cand_tuple = (node_conflicts(i), len(set(cols)), c)\n            cols[i] = old\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_c = c\n        cols[i] = best_c\n        cols = canonicalize(cols)\n        return (to_csv(cols), \"recolor_conflict\")\n    # Phase 2: compress colors (reduce groups) without introducing conflicts\n    color_counts = {}\n    for c in cols:\n        color_counts[c] = color_counts.get(c, 0) + 1\n    max_color = max(cols) if cols else 1\n    # Try to eliminate the highest color class greedily\n    target_color = max_color\n    if target_color >= 2:\n        vertices = [i for i in range(n) if cols[i] == target_color]\n        random.shuffle(vertices)\n        feasible = True\n        saved = cols[:]\n        for i in vertices:\n            used_nb = {cols[nb] for nb in adj[i]}\n            avail = [c for c in range(1, target_color) if c not in used_nb]\n            if not avail:\n                feasible = False\n                break\n            cols[i] = min(avail)\n        if feasible:\n            cols = canonicalize(cols)\n            return (to_csv(cols), \"color_eliminate\")\n        else:\n            cols = saved\n    # Prefer moving singleton color vertices to existing feasible colors\n    singleton_nodes = [i for i in range(n) if color_counts.get(cols[i], 0) == 1]\n    candidates = singleton_nodes if singleton_nodes else list(range(n))\n    random.shuffle(candidates)\n    for i in candidates:\n        used_nb = {cols[nb] for nb in adj[i]}\n        avail = [c for c in range(1, max_color + 1) if c != cols[i] and c not in used_nb]\n        if avail:\n            cols[i] = min(avail)\n            cols = canonicalize(cols)\n            return (to_csv(cols), \"recolor_compress\")\n    # Phase 3: targeted Kempe swap for a randomly chosen vertex and blocking color\n    i = random.randrange(n)\n    used_nb = {cols[nb] for nb in adj[i]}\n    if max_color >= 2 and used_nb:\n        a = cols[i]\n        b = random.choice(list(used_nb))\n        # Build component induced by colors a and b containing i\n        stack = [i]\n        seen = {i}\n        nodes = []\n        while stack:\n            u = stack.pop()\n            if cols[u] == a or cols[u] == b:\n                nodes.append(u)\n                for v in adj[u]:\n                    if v not in seen and (cols[v] == a or cols[v] == b):\n                        seen.add(v)\n                        stack.append(v)\n        # Swap a<->b on this component\n        for u in nodes:\n            if cols[u] == a:\n                cols[u] = b\n            elif cols[u] == b:\n                cols[u] = a\n        cols = canonicalize(cols)\n        return (to_csv(cols), \"kempe_swap_targeted\")\n    # Fallback: random recolor within current palette\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    cols[i] = c\n    cols = canonicalize(cols)\n    return (to_csv(cols), \"random_recolor\")\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Shake by merging two colors (if >=2), then repair with bounded min-conflicts steps\n    def parse(sol):\n        if isinstance(sol, str):\n            try:\n                return [int(x) for x in sol.strip().split(',') if x.strip()]\n            except Exception:\n                return []\n        elif isinstance(sol, (list, tuple)):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        else:\n            return []\n    def to_csv(cols):\n        return ','.join(str(x) for x in cols)\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    n = 9\n    cols = parse(solution)\n    if len(cols) != n:\n        return solution if isinstance(solution, str) else to_csv(cols)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    max_color = max(cols) if cols else 1\n    if max_color >= 2:\n        a = random.randrange(1, max_color + 1)\n        b = a\n        while b == a:\n            b = random.randrange(1, max_color + 1)\n        for i in range(n):\n            if cols[i] == b:\n                cols[i] = a\n    else:\n        # Seed diversity\n        for _ in range(2):\n            i = random.randrange(n)\n            cols[i] = 2\n    # Repair up to R steps\n    def conflicts_count(ca):\n        cnt = 0\n        for u, v in edges:\n            if ca[u] == ca[v]:\n                cnt += 1\n        return cnt\n    R = 15\n    for _ in range(R):\n        conflicted = []\n        for u, v in edges:\n            if cols[u] == cols[v]:\n                conflicted.append(u)\n                conflicted.append(v)\n        if not conflicted:\n            break\n        i = random.choice(conflicted)\n        max_color = max(cols) if cols else 1\n        best_c = cols[i]\n        best_val = (10**9, 10**9)\n        for c in range(1, max_color + 2):\n            if c == cols[i]:\n                continue\n            old = cols[i]\n            cols[i] = c\n            cand = (conflicts_count(cols), len(set(cols)))\n            cols[i] = old\n            if cand < best_val:\n                best_val = cand\n                best_c = c\n        cols[i] = best_c\n    cols = canonicalize(cols)\n    return to_csv(cols)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_standard","Representacion":"CSV_INT_LIST.N=9.VALUES\u2208{1..K}.ORDER_BY_STUDENT_ID_ASC","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Returns integer cost: M*conflicts + groups_used, M=|E|+1 for lexicographic priority\n    def parse_to_list(sol):\n        if isinstance(sol, str):\n            try:\n                vals = [int(x) for x in sol.strip().split(',') if x.strip()]\n                return vals\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple)):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n    cols = parse_to_list(solution)\n    n = 9\n    if cols is None or len(cols) != n:\n        return int(10**9)\n    # Validate colors are positive integers\n    for c in cols:\n        if not isinstance(c, int) or c < 1:\n            return int(10**9)\n    # Graph (0-indexed)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if cols[u] == cols[v]:\n            conflicts += 1\n    groups_used = len(set(cols))\n    M = len(edges) + 1\n    return int(conflicts * M + groups_used)\n","Vecindad":"import math\nimport random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (new_solution_csv, move_type)\n    def parse(sol):\n        if isinstance(sol, str):\n            try:\n                return [int(x) for x in sol.strip().split(',') if x.strip()]\n            except Exception:\n                return []\n        elif isinstance(sol, (list, tuple)):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        else:\n            return []\n    def to_csv(cols):\n        return ','.join(str(x) for x in cols)\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    n = 9\n    cols = parse(solution)\n    if len(cols) != n:\n        return (solution if isinstance(solution, str) else to_csv(cols), \"invalid_input\")\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    def node_conflicts(i, color=None):\n        c = cols[i] if color is None else color\n        cnt = 0\n        for nb in adj[i]:\n            if cols[nb] == c:\n                cnt += 1\n        return cnt\n    # Total conflicts\n    total_conf = 0\n    for u, v in edges:\n        if cols[u] == cols[v]:\n            total_conf += 1\n    max_color = max(cols) if cols else 1\n    # Phase 1: resolve conflicts via min-conflicts recolor on a critical vertex\n    if total_conf > 0:\n        # Select vertex with maximum conflicts (tie-break by degree then random)\n        conflict_counts = [node_conflicts(i) for i in range(n)]\n        maxc = max(conflict_counts)\n        candidates = [i for i in range(n) if conflict_counts[i] == maxc]\n        if len(candidates) > 1:\n            degs = [len(adj[i]) for i in candidates]\n            maxdeg = max(degs)\n            candidates = [i for i in candidates if len(adj[i]) == maxdeg]\n        i = random.choice(candidates)\n        current_groups = len(set(cols))\n        best_c = cols[i]\n        best_tuple = (node_conflicts(i), current_groups, cols[i])\n        for c in range(1, max_color + 2):\n            if c == cols[i]:\n                continue\n            old = cols[i]\n            cols[i] = c\n            cand_tuple = (node_conflicts(i), len(set(cols)), c)\n            cols[i] = old\n            if cand_tuple < best_tuple:\n                best_tuple = cand_tuple\n                best_c = c\n        cols[i] = best_c\n        cols = canonicalize(cols)\n        return (to_csv(cols), \"recolor_conflict\")\n    # Phase 2: compress colors (reduce groups) without introducing conflicts\n    color_counts = {}\n    for c in cols:\n        color_counts[c] = color_counts.get(c, 0) + 1\n    max_color = max(cols) if cols else 1\n    # Try to eliminate the highest color class greedily\n    target_color = max_color\n    if target_color >= 2:\n        vertices = [i for i in range(n) if cols[i] == target_color]\n        random.shuffle(vertices)\n        feasible = True\n        saved = cols[:]\n        for i in vertices:\n            used_nb = {cols[nb] for nb in adj[i]}\n            avail = [c for c in range(1, target_color) if c not in used_nb]\n            if not avail:\n                feasible = False\n                break\n            cols[i] = min(avail)\n        if feasible:\n            cols = canonicalize(cols)\n            return (to_csv(cols), \"color_eliminate\")\n        else:\n            cols = saved\n    # Prefer moving singleton color vertices to existing feasible colors\n    singleton_nodes = [i for i in range(n) if color_counts.get(cols[i], 0) == 1]\n    candidates = singleton_nodes if singleton_nodes else list(range(n))\n    random.shuffle(candidates)\n    for i in candidates:\n        used_nb = {cols[nb] for nb in adj[i]}\n        avail = [c for c in range(1, max_color + 1) if c != cols[i] and c not in used_nb]\n        if avail:\n            cols[i] = min(avail)\n            cols = canonicalize(cols)\n            return (to_csv(cols), \"recolor_compress\")\n    # Phase 3: targeted Kempe swap for a randomly chosen vertex and blocking color\n    i = random.randrange(n)\n    used_nb = {cols[nb] for nb in adj[i]}\n    if max_color >= 2 and used_nb:\n        a = cols[i]\n        b = random.choice(list(used_nb))\n        stack = [i]\n        seen = {i}\n        nodes = []\n        while stack:\n            u = stack.pop()\n            if cols[u] == a or cols[u] == b:\n                nodes.append(u)\n                for v in adj[u]:\n                    if v not in seen and (cols[v] == a or cols[v] == b):\n                        seen.add(v)\n                        stack.append(v)\n        for u in nodes:\n            if cols[u] == a:\n                cols[u] = b\n            elif cols[u] == b:\n                cols[u] = a\n        cols = canonicalize(cols)\n        return (to_csv(cols), \"kempe_swap_targeted\")\n    # Fallback: random recolor within current palette\n    i = random.randrange(n)\n    c = random.randrange(1, max_color + 1)\n    cols[i] = c\n    cols = canonicalize(cols)\n    return (to_csv(cols), \"random_recolor\")\n","Perturbacion":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Shake by merging two random colors, then min-conflicts repair\n    def parse(sol):\n        if isinstance(sol, str):\n            try:\n                return [int(x) for x in sol.strip().split(',') if x.strip()]\n            except Exception:\n                return []\n        elif isinstance(sol, (list, tuple)):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return []\n        else:\n            return []\n    def to_csv(cols):\n        return ','.join(str(x) for x in cols)\n    def canonicalize(cols):\n        mapping = {}\n        next_c = 1\n        out = []\n        for c in cols:\n            if c not in mapping:\n                mapping[c] = next_c\n                next_c += 1\n            out.append(mapping[c])\n        return out\n    n = 9\n    cols = parse(solution)\n    if len(cols) != n:\n        return solution if isinstance(solution, str) else to_csv(cols)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [set() for _ in range(n)]\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    max_color = max(cols) if cols else 1\n    if max_color >= 2:\n        a = random.randrange(1, max_color + 1)\n        b = a\n        while b == a:\n            b = random.randrange(1, max_color + 1)\n        for i in range(n):\n            if cols[i] == b:\n                cols[i] = a\n    else:\n        # seed diversity\n        for _ in range(2):\n            i = random.randrange(n)\n            cols[i] = 2\n    def conflicts_count(ca):\n        cnt = 0\n        for u, v in edges:\n            if ca[u] == ca[v]:\n                cnt += 1\n        return cnt\n    R = 20\n    for _ in range(R):\n        conflicted = []\n        for u, v in edges:\n            if cols[u] == cols[v]:\n                conflicted.append(u)\n                conflicted.append(v)\n        if not conflicted:\n            break\n        i = random.choice(conflicted)\n        max_color = max(cols) if cols else 1\n        best_c = cols[i]\n        best_val = (10**9, 10**9)\n        for c in range(1, max_color + 2):\n            if c == cols[i]:\n                continue\n            old = cols[i]\n            cols[i] = c\n            cand = (conflicts_count(cols), len(set(cols)))\n            cols[i] = old\n            if cand < best_val:\n                best_val = cand\n                best_c = c\n        cols[i] = best_c\n    cols = canonicalize(cols)\n    return to_csv(cols)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST_COLORS_LENGTH_9_VALUES>=1","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    try:\n        parts = [p.strip() for p in solution.split(',') if p.strip()]\n        colors = [int(x) for x in parts]\n    except Exception:\n        return 1e9\n    n = 9\n    if len(colors) != n:\n        return 1e9\n    if any(c < 1 for c in colors):\n        return 1e9\n    # Edges are 0-indexed\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if colors[u] == colors[v]:\n            conflicts += 1\n    colors_used = max(colors)\n    return conflicts * 1000.0 + float(colors_used)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse and sanitize\n    parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n    try:\n        colors = [int(x) for x in parts]\n    except Exception:\n        colors = [1]*9\n    n = 9\n    if len(colors) != n:\n        if len(colors) < n:\n            colors = colors + [1]*(n - len(colors))\n        else:\n            colors = colors[:n]\n    max_color = max(1, max(colors))\n\n    # Problem graph (0-indexed)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(vec):\n        c = 0\n        for u,v in edges:\n            if vec[u] == vec[v]:\n                c += 1\n        return c\n\n    current_conf = count_conflicts(colors)\n\n    # Identify conflicted vertices\n    conflicted = []\n    for u,v in edges:\n        if colors[u] == colors[v]:\n            conflicted.append(u)\n            conflicted.append(v)\n    conflicted = list(dict.fromkeys(conflicted))  # unique order-preserving\n\n    move_roll = random.random()\n\n    # Priority 1: resolve conflicts via best-improving recolor\n    if current_conf > 0 and (move_roll < 0.70 or not conflicted):\n        v = random.choice(conflicted) if conflicted else random.randrange(n)\n        best_col = colors[v]\n        best_delta = 0\n        # Restrict to existing palette to avoid bloat\n        for c in range(1, max_color+1):\n            if c == colors[v]:\n                continue\n            old = colors[v]\n            colors[v] = c\n            delta = count_conflicts(colors) - current_conf\n            if delta < best_delta:\n                best_delta = delta\n                best_col = c\n            colors[v] = old\n        # If no improving color, try a lateral move among existing colors\n        if best_delta == 0:\n            cands = [c for c in range(1, max_color+1) if c != colors[v]]\n            if cands:\n                best_col = random.choice(cands)\n        colors[v] = best_col\n        return (\"targeted_recolor\", ','.join(str(x) for x in colors))\n\n    # Priority 2: color reduction attempt when conflict-free\n    if current_conf == 0 and move_roll < 0.85:\n        # Try to eliminate the highest color by recoloring one of its vertices\n        hi = max_color\n        verts = [i for i,c in enumerate(colors) if c == hi]\n        if verts:\n            v = random.choice(verts)\n            # Try recolor v to a lower color that doesn't add conflicts\n            best_col = None\n            for c in range(1, hi):\n                ok = True\n                for nb in adj[v]:\n                    if colors[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    best_col = c\n                    break\n            if best_col is not None:\n                colors[v] = best_col\n                return (\"color_reduction\", ','.join(str(x) for x in colors))\n        # If unable, fall through to diversification\n\n    # Priority 3: color-swap between two colors to reshuffle structure\n    if move_roll < 0.95 and max_color >= 2:\n        c1, c2 = random.sample(range(1, max_color+1), 2)\n        new = [c2 if x == c1 else (c1 if x == c2 else x) for x in colors]\n        return (\"color_swap\", ','.join(str(x) for x in new))\n\n    # Fallback: random recolor of a random vertex within current palette\n    idx = random.randrange(n)\n    new_color = random.randint(1, max_color)\n    colors[idx] = new_color\n    return (\"random_recolor\", ','.join(str(x) for x in colors))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n    try:\n        colors = [int(x) for x in parts]\n    except Exception:\n        colors = [1]*9\n    n = 9\n    if len(colors) != n:\n        if len(colors) < n:\n            colors = colors + [1]*(n - len(colors))\n        else:\n            colors = colors[:n]\n    max_color = max(1, max(colors))\n\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u,v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(vec):\n        c = 0\n        for u,v in edges:\n            if vec[u] == vec[v]:\n                c += 1\n        return c\n\n    cur_conf = conflicts(colors)\n\n    # Strength adaptive to conflicts\n    k = 5 if cur_conf > 0 else 3\n\n    for _ in range(k):\n        r = random.random()\n        if r < 0.5:\n            # Recolor a conflicted or random vertex\n            conflicted = []\n            for u,v in edges:\n                if colors[u] == colors[v]:\n                    conflicted.append(u)\n                    conflicted.append(v)\n            conflicted = list(dict.fromkeys(conflicted))\n            v = random.choice(conflicted) if conflicted else random.randrange(n)\n            # Choose a color from existing palette, occasionally any up to max_color\n            new_c = random.randint(1, max_color)\n            colors[v] = new_c\n        elif r < 0.8 and max_color >= 2:\n            # Swap two colors\n            c1, c2 = random.sample(range(1, max_color+1), 2)\n            colors = [c2 if x == c1 else (c1 if x == c2 else x) for x in colors]\n        else:\n            # Attempt to push off the highest color by greedy recolor of one vertex\n            hi = max_color\n            verts = [i for i,c in enumerate(colors) if c == hi]\n            if verts:\n                v = random.choice(verts)\n                for c in range(1, hi):\n                    ok = True\n                    for nb in adj[v]:\n                        if colors[nb] == c:\n                            ok = False\n                            break\n                    if ok:\n                        colors[v] = c\n                        break\n        max_color = max(1, max(colors))\n\n    return ','.join(str(x) for x in colors)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"CSV_INT_LIST length=9; entries are integers >=1; position i corresponds to participant i+1; example: \"1,1,1,2,3,2,4,3,4\".","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    try:\n        parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n        colors = [int(x) for x in parts]\n    except Exception:\n        return 1e9\n    n = 9\n    if len(colors) != n:\n        return 1e9\n    if any(c < 1 for c in colors):\n        return 1e9\n    # Graph edges (0-indexed)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if colors[u] == colors[v]:\n            conflicts += 1\n    rooms_used = len(set(colors))\n    return conflicts * 1000.0 + float(rooms_used)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse and sanitize to length 9, ints >=1\n    parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n    try:\n        colors = [int(x) for x in parts]\n    except Exception:\n        colors = [1]*9\n    n = 9\n    if len(colors) != n:\n        if len(colors) < n:\n            colors = colors + [1]*(n - len(colors))\n        else:\n            colors = colors[:n]\n    for i in range(n):\n        if colors[i] < 1:\n            colors[i] = 1\n    # Problem graph (0-indexed)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def count_conflicts(vec):\n        c = 0\n        for u, v in edges:\n            if vec[u] == vec[v]:\n                c += 1\n        return c\n\n    def normalize_palette(vec):\n        # Remap colors to 1..k preserving equivalence classes\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in vec:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    colors = normalize_palette(colors)\n    max_color = max(colors) if colors else 1\n    current_conf = count_conflicts(colors)\n\n    # Identify conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if colors[u] == colors[v]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # unique while preserving order\n    seen = set()\n    conflicted_uniq = []\n    for x in conflicted:\n        if x not in seen:\n            seen.add(x)\n            conflicted_uniq.append(x)\n    conflicted = conflicted_uniq\n\n    move_roll = random.random()\n\n    # Move 1: targeted recolor to reduce conflicts\n    if current_conf > 0 and (move_roll < 0.70 or not conflicted):\n        v = random.choice(conflicted) if conflicted else random.randrange(n)\n        best_col = colors[v]\n        best_delta = 0\n        base_conf = current_conf\n        # Try only existing colors first\n        for c in range(1, max_color+1):\n            if c == colors[v]:\n                continue\n            old = colors[v]\n            colors[v] = c\n            delta = count_conflicts(colors) - base_conf\n            if delta < best_delta:\n                best_delta = delta\n                best_col = c\n            colors[v] = old\n        # If no improvement, lateral move within palette\n        if best_delta == 0:\n            cands = [c for c in range(1, max_color+1) if c != colors[v]]\n            if cands:\n                best_col = random.choice(cands)\n        colors[v] = best_col\n        colors = normalize_palette(colors)\n        return (\"targeted_recolor\", ','.join(str(x) for x in colors))\n\n    # Move 2: color reduction when conflict-free\n    if current_conf == 0 and move_roll < 0.85:\n        hi = max_color\n        verts = [i for i, c in enumerate(colors) if c == hi]\n        if verts:\n            v = random.choice(verts)\n            # Try recolor v to lower color keeping conflict-free\n            for c in range(1, hi):\n                ok = True\n                for nb in adj[v]:\n                    if colors[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    colors[v] = c\n                    colors = normalize_palette(colors)\n                    return (\"color_reduction\", ','.join(str(x) for x in colors))\n        # fall-through to diversification\n\n    # Move 3: color swap between two classes\n    if move_roll < 0.95 and max_color >= 2:\n        c1, c2 = random.sample(range(1, max_color+1), 2)\n        new = [c2 if x == c1 else (c1 if x == c2 else x) for x in colors]\n        new = normalize_palette(new)\n        return (\"color_swap\", ','.join(str(x) for x in new))\n\n    # Move 4: random recolor within palette\n    idx = random.randrange(n)\n    new_color = random.randint(1, max_color)\n    colors[idx] = new_color\n    colors = normalize_palette(colors)\n    return (\"random_recolor\", ','.join(str(x) for x in colors))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n    try:\n        colors = [int(x) for x in parts]\n    except Exception:\n        colors = [1]*9\n    n = 9\n    if len(colors) != n:\n        if len(colors) < n:\n            colors = colors + [1]*(n - len(colors))\n        else:\n            colors = colors[:n]\n    for i in range(n):\n        if colors[i] < 1:\n            colors[i] = 1\n\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(vec):\n        c = 0\n        for u, v in edges:\n            if vec[u] == vec[v]:\n                c += 1\n        return c\n\n    def normalize_palette(vec):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in vec:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    colors = normalize_palette(colors)\n    max_color = max(colors) if colors else 1\n    cur_conf = conflicts(colors)\n\n    # Adaptive shake strength\n    k = 5 if cur_conf > 0 else 3\n\n    for _ in range(k):\n        r = random.random()\n        if r < 0.5:\n            # Recolor a conflicted or random vertex within palette\n            conflicted = []\n            for u, v in edges:\n                if colors[u] == colors[v]:\n                    conflicted.append(u)\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(list(dict.fromkeys(conflicted)))\n            else:\n                v = random.randrange(n)\n            colors[v] = random.randint(1, max_color)\n        elif r < 0.8 and max_color >= 2:\n            # Swap two color classes\n            c1, c2 = random.sample(range(1, max_color+1), 2)\n            colors = [c2 if x == c1 else (c1 if x == c2 else x) for x in colors]\n        else:\n            # Try to eliminate highest color by greedy single-vertex move\n            hi = max_color\n            verts = [i for i, c in enumerate(colors) if c == hi]\n            if verts:\n                v = random.choice(verts)\n                for c in range(1, hi):\n                    ok = True\n                    for nb in adj[v]:\n                        if colors[nb] == c:\n                            ok = False\n                            break\n                    if ok:\n                        colors[v] = c\n                        break\n        colors = normalize_palette(colors)\n        max_color = max(colors)\n\n    return ','.join(str(x) for x in colors)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_standard","Representacion":"4,1,2,1,2,3,4,2,5","Evaluacion":"import math\n\ndef evaluate_solution(solution: str) -> float:\n    # Parse CSV -> list[int]\n    try:\n        parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n        colors = [int(x) for x in parts]\n    except Exception:\n        return 1e9\n    n = 9\n    if len(colors) != n:\n        return 1e9\n    if any(c < 1 for c in colors):\n        return 1e9\n    # Edges (0-indexed)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    conflicts = 0\n    for u, v in edges:\n        if colors[u] == colors[v]:\n            conflicts += 1\n    rooms_used = len(set(colors))\n    # Primary objective: zero conflicts, then minimize rooms\n    return conflicts * 1000.0 + float(rooms_used)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse and sanitize\n    parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n    try:\n        colors = [int(x) for x in parts]\n    except Exception:\n        colors = [1]*9\n    n = 9\n    if len(colors) != n:\n        if len(colors) < n:\n            colors = colors + [1]*(n - len(colors))\n        else:\n            colors = colors[:n]\n    for i in range(n):\n        if colors[i] < 1:\n            colors[i] = 1\n\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(vec):\n        c = 0\n        for u, v in edges:\n            if vec[u] == vec[v]:\n                c += 1\n        return c\n\n    def normalize_palette(vec):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in vec:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    colors = normalize_palette(colors)\n    max_color = max(colors) if colors else 1\n    cur_conf = conflicts(colors)\n\n    # Collect conflicted vertices\n    conflicted = []\n    for u, v in edges:\n        if colors[u] == colors[v]:\n            conflicted.append(u)\n            conflicted.append(v)\n    # unique preserve order\n    seen = set()\n    conflicted_u = []\n    for x in conflicted:\n        if x not in seen:\n            seen.add(x)\n            conflicted_u.append(x)\n    conflicted = conflicted_u\n\n    roll = random.random()\n\n    # 1) Targeted recolor if conflicts exist\n    if cur_conf > 0 and (roll < 0.7 or not conflicted):\n        v = random.choice(conflicted) if conflicted else random.randrange(n)\n        base = cur_conf\n        best_col = colors[v]\n        best_delta = 0\n        # try existing palette\n        for c in range(1, max_color+1):\n            if c == colors[v]:\n                continue\n            old = colors[v]\n            colors[v] = c\n            delta = conflicts(colors) - base\n            if delta < best_delta:\n                best_delta = delta\n                best_col = c\n            colors[v] = old\n        # fallback lateral move\n        if best_delta == 0:\n            cands = [c for c in range(1, max_color+1) if c != colors[v]]\n            if cands:\n                best_col = random.choice(cands)\n        colors[v] = best_col\n        colors = normalize_palette(colors)\n        return (\"targeted_recolor\", ','.join(str(x) for x in colors))\n\n    # 2) If conflict-free, attempt color reduction from highest class\n    if cur_conf == 0 and roll < 0.85 and max_color >= 2:\n        hi = max_color\n        verts = [i for i, c in enumerate(colors) if c == hi]\n        if verts:\n            v = random.choice(verts)\n            for c in range(1, hi):\n                ok = True\n                for nb in adj[v]:\n                    if colors[nb] == c:\n                        ok = False\n                        break\n                if ok:\n                    colors[v] = c\n                    colors = normalize_palette(colors)\n                    return (\"color_reduction\", ','.join(str(x) for x in colors))\n        # fallthrough\n\n    # 3) Kempe chain swap between two colors to diversify\n    if roll < 0.95 and max_color >= 2:\n        c1, c2 = random.sample(range(1, max_color+1), 2)\n        # pick random root and BFS on subgraph of {c1,c2}\n        vertices = [i for i, cv in enumerate(colors) if cv in (c1, c2)]\n        if vertices:\n            root = random.choice(vertices)\n            target_set = set([root])\n            queue = [root]\n            allowed = {c1, c2}\n            while queue:\n                u = queue.pop()\n                for w in adj[u]:\n                    if w not in target_set and colors[w] in allowed:\n                        target_set.add(w)\n                        queue.append(w)\n            new = colors[:]\n            for u in target_set:\n                new[u] = c1 if colors[u] == c2 else (c2 if colors[u] == c1 else colors[u])\n            new = normalize_palette(new)\n            return (\"kempe_swap\", ','.join(str(x) for x in new))\n\n    # 4) Random recolor within palette\n    idx = random.randrange(n)\n    new_color = random.randint(1, max_color if max_color >= 1 else 1)\n    colors[idx] = new_color\n    colors = normalize_palette(colors)\n    return (\"random_recolor\", ','.join(str(x) for x in colors))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    parts = [p.strip() for p in str(solution).split(',') if p.strip()]\n    try:\n        colors = [int(x) for x in parts]\n    except Exception:\n        colors = [1]*9\n    n = 9\n    if len(colors) != n:\n        if len(colors) < n:\n            colors = colors + [1]*(n - len(colors))\n        else:\n            colors = colors[:n]\n    for i in range(n):\n        if colors[i] < 1:\n            colors[i] = 1\n\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def conflicts(vec):\n        c = 0\n        for u, v in edges:\n            if vec[u] == vec[v]:\n                c += 1\n        return c\n\n    def normalize_palette(vec):\n        mapping = {}\n        next_c = 1\n        out = []\n        for x in vec:\n            if x not in mapping:\n                mapping[x] = next_c\n                next_c += 1\n            out.append(mapping[x])\n        return out\n\n    colors = normalize_palette(colors)\n    max_color = max(colors) if colors else 1\n    cur_conf = conflicts(colors)\n\n    # Adaptive shake size\n    k = 5 if cur_conf > 0 else 3\n\n    for _ in range(k):\n        r = random.random()\n        if r < 0.45:\n            # Recolor a conflicted or random vertex to random existing color\n            conflicted = []\n            for u, v in edges:\n                if colors[u] == colors[v]:\n                    conflicted.append(u)\n                    conflicted.append(v)\n            if conflicted:\n                v = random.choice(list(dict.fromkeys(conflicted)))\n            else:\n                v = random.randrange(n)\n            colors[v] = random.randint(1, max_color)\n        elif r < 0.8 and max_color >= 2:\n            # Swap two color classes globally\n            c1, c2 = random.sample(range(1, max_color+1), 2)\n            colors = [c2 if x == c1 else (c1 if x == c2 else x) for x in colors]\n        else:\n            # Try to fold highest color class into lower colors greedily\n            hi = max_color\n            verts = [i for i, c in enumerate(colors) if c == hi]\n            if verts:\n                v = random.choice(verts)\n                for c in range(1, hi):\n                    ok = True\n                    for nb in adj[v]:\n                        if colors[nb] == c:\n                            ok = False\n                            break\n                    if ok:\n                        colors[v] = c\n                        break\n        colors = normalize_palette(colors)\n        max_color = max(colors)\n\n    return ','.join(str(x) for x in colors)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"CSV_INT_9PARTY_ASSIGNMENT","Evaluacion":"import random\n\ndef evaluate_solution(solution: str) -> int:\n    # Validate and parse CSV into list of 9 positive integers\n    try:\n        parts = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return 10**9\n    if len(parts) != 9:\n        return 10**9\n    if any((not isinstance(p, int)) or (p <= 0) for p in parts):\n        return 10**9\n    parties = parts\n    # Graph edges (0-based)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if parties[u] == parties[v]:\n            conflicts += 1\n    used_parties = len(set(parties))\n    # Lower is better; conflicts dominate\n    cost = conflicts * 1000 + used_parties\n    return cost\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Helper: canonical relabeling to 1..k (sorted by label then first occurrence)\n    def compress_labels(labels):\n        uniq = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_label\n                next_label += 1\n            out.append(uniq[x])\n        return out\n    # Parse solution\n    try:\n        parts = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        parts = [1]*9\n    if len(parts) != 9 or any(p <= 0 for p in parts):\n        parts = [1]*9\n    n = 9\n    labels = parts[:]\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Compute conflict counts per node\n    conflicts_per_node = [0]*n\n    for u, v in edges:\n        if labels[u] == labels[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n    total_conflicts = sum(1 for u,v in edges if labels[u] == labels[v])\n    used = sorted(set(labels))\n    used_set = set(used)\n    k = len(used)\n    movement = \"RandomReassign\"\n    if total_conflicts > 0:\n        # Pick a conflicted node with highest conflict degree (tie-break by higher degree)\n        deg = [len(adj[i]) for i in range(n)]\n        conflicted_nodes = [i for i in range(n) if conflicts_per_node[i] > 0]\n        if conflicted_nodes:\n            i = max(conflicted_nodes, key=lambda x: (conflicts_per_node[x], deg[x], random.random()))\n        else:\n            i = random.randrange(n)\n        current = labels[i]\n        # Candidate palette: existing labels; consider new label only if needed\n        palette = list(used)\n        best_label = current\n        best_delta = (10**9, 10**9)  # (delta_conflicts, delta_used)\n        # Evaluate moving i to each label in palette\n        for c in palette:\n            if c == current:\n                continue\n            # Compute local delta conflicts for node i\n            delta_c = 0\n            for nb in adj[i]:\n                if labels[nb] == current:\n                    delta_c -= 1\n                if labels[nb] == c:\n                    delta_c += 1\n            # Delta used parties: if moving leaves current label unused -> -1; introducing existing label -> 0\n            will_current_disappear = all((labels[j] != current) or (j == i) for j in range(n))\n            delta_used = -1 if will_current_disappear and (c in used_set) else 0\n            # Lexicographic: conflicts first, then used parties\n            cand = (delta_c, delta_used)\n            if cand < best_delta:\n                best_delta = cand\n                best_label = c\n        # If no improving\/neutral conflict move found, allow new label (k+1 up to 9)\n        if best_delta[0] >= 0 and k < 9:\n            c = max(used) + 1\n            if c <= 9:\n                best_label = c\n                movement = \"ConflictNewLabel\"\n            else:\n                movement = \"ConflictNoImprove\"\n        else:\n            movement = \"ConflictDirected\"\n        labels[i] = best_label\n    else:\n        # No conflicts: attempt to reduce number of used parties by reassigning a random node to an existing lower label if safe\n        i = random.randrange(n)\n        current = labels[i]\n        palette = sorted(set(labels))\n        target = current\n        for c in palette:\n            if c == current:\n                continue\n            # safe if no neighbor has label c\n            safe = True\n            for nb in adj[i]:\n                if labels[nb] == c:\n                    safe = False\n                    break\n            if safe:\n                target = c\n                break\n        labels[i] = target\n        movement = \"PartyReduction\" if target != current else \"NoOpStable\"\n    # Compress labels to 1..k\n    labels = compress_labels(labels)\n    neighbour = ','.join(str(x) for x in labels)\n    return neighbour, movement\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Helper: compress labels to 1..k\n    def compress_labels(labels):\n        uniq = {}\n        next_label = 1\n        out = []\n        for x in labels:\n            if x not in uniq:\n                uniq[x] = next_label\n                next_label += 1\n            out.append(uniq[x])\n        return out\n    # Parse\n    try:\n        parts = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        parts = [1]*9\n    if len(parts) != 9 or any(p <= 0 for p in parts):\n        parts = [1]*9\n    n = 9\n    labels = parts[:]\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    used = sorted(set(labels))\n    if len(used) >= 2:\n        # Kempe-chain swap between two labels a and b in a random component\n        a = random.choice(used)\n        b_choices = [x for x in used if x != a]\n        b = random.choice(b_choices)\n        # pick start node with label a or b\n        candidates = [i for i in range(n) if labels[i] == a or labels[i] == b]\n        if not candidates:\n            # fallback random relabel of few nodes\n            k = random.randint(2, 4)\n            for i in random.sample(range(n), k):\n                labels[i] = random.randint(1, min(9, max(used)+1))\n        else:\n            start = random.choice(candidates)\n            target_set = {a, b}\n            # BFS within subgraph induced by labels {a,b}\n            comp = [False]*n\n            dq = deque([start])\n            comp[start] = True\n            while dq:\n                u = dq.popleft()\n                for v in adj[u]:\n                    if not comp[v] and labels[v] in target_set:\n                        comp[v] = True\n                        dq.append(v)\n            # Swap a<->b within component\n            for i in range(n):\n                if comp[i]:\n                    if labels[i] == a:\n                        labels[i] = b\n                    elif labels[i] == b:\n                        labels[i] = a\n    else:\n        # If only one label used, randomize a few nodes to create diversity\n        k = random.randint(3, 5)\n        for i in random.sample(range(n), k):\n            labels[i] = random.randint(1, min(9, labels[i]+2))\n    # Compress labels\n    labels = compress_labels(labels)\n    perturbed = ','.join(str(x) for x in labels)\n    return perturbed\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"CSV_INT_9PARTY_ASSIGNMENT","Evaluacion":"import random\n\ndef evaluate_solution(solution: str) -> int:\n    try:\n        parts = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return 10**9\n    if len(parts) != 9:\n        return 10**9\n    if any((not isinstance(p, int)) or (p <= 0) for p in parts):\n        return 10**9\n    parties = parts\n    # Graph edges (0-based)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if parties[u] == parties[v]:\n            conflicts += 1\n    used_parties = len(set(parties))\n    # Lower is better; conflicts dominate party count\n    cost = conflicts * 1000 + used_parties\n    return cost\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse solution safely\n    try:\n        labels = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        labels = [1] * 9\n    if len(labels) != 9 or any(p <= 0 for p in labels):\n        labels = [1] * 9\n    n = 9\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict metrics\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if labels[u] == labels[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n    used = sorted(set(labels))\n    used_set = set(used)\n    # Helper to count local conflict change when moving vertex i to color c\n    def local_delta(i, c):\n        cur = labels[i]\n        if c == cur:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            if labels[nb] == cur:\n                delta -= 1\n            if labels[nb] == c:\n                delta += 1\n        return delta\n    movement = \"NoOp\"\n    new_labels = labels[:]\n    if total_conflicts > 0:\n        # Pick a conflicted node with highest conflict count (tie-breaking by degree and random)\n        deg = [len(adj[i]) for i in range(n)]\n        conflicted = [i for i in range(n) if conflicts_per_node[i] > 0]\n        if conflicted:\n            i = max(conflicted, key=lambda x: (conflicts_per_node[x], deg[x], random.random()))\n        else:\n            i = random.randrange(n)\n        cur = labels[i]\n        palette = list(used)\n        best_c = cur\n        best_delta = 10**9\n        for c in palette:\n            if c == cur:\n                continue\n            dc = local_delta(i, c)\n            if dc < best_delta:\n                best_delta = dc\n                best_c = c\n        if best_delta < 0:\n            new_labels[i] = best_c\n            movement = \"ConflictGreedyRecolor\"\n        else:\n            # Try a Kempe-chain swap between cur and a chosen color to reduce conflicts at i\n            if len(palette) >= 2:\n                # pick color that minimizes conflicts after swap neighborhood-wise\n                target_colors = [c for c in palette if c != cur]\n                random.shuffle(target_colors)\n                performed = False\n                for c in target_colors:\n                    # BFS component in subgraph induced by {cur, c} starting from i\n                    from collections import deque\n                    comp = [False] * n\n                    dq = deque([i])\n                    comp[i] = True\n                    target_set = {cur, c}\n                    while dq:\n                        u = dq.popleft()\n                        for v in adj[u]:\n                            if not comp[v] and labels[v] in target_set:\n                                comp[v] = True\n                                dq.append(v)\n                    # Evaluate conflicts after swap restricted to edges touching comp nodes\n                    tmp = new_labels[:]\n                    for v in range(n):\n                        if comp[v]:\n                            if tmp[v] == cur:\n                                tmp[v] = c\n                            elif tmp[v] == c:\n                                tmp[v] = cur\n                    # compute conflict change focused on affected nodes\n                    delta_conf = 0\n                    for u, v in edges:\n                        if comp[u] or comp[v]:\n                            before = 1 if (new_labels[u] == new_labels[v]) else 0\n                            after = 1 if (tmp[u] == tmp[v]) else 0\n                            delta_conf += (after - before)\n                    if delta_conf < 0:\n                        new_labels = tmp\n                        movement = \"ConflictKempeSwap\"\n                        performed = True\n                        break\n                if not performed:\n                    # Last resort: move i to a random existing color or introduce a new label limited to 9\n                    cho = random.choice(palette + [max(used) + 1 if (max(used) + 1) <= 9 else random.choice(palette)])\n                    new_labels[i] = cho\n                    movement = \"ConflictRandomKick\"\n            else:\n                # Only one color used; diversify\n                new_labels[i] = min(9, cur + 1)\n                movement = \"ConflictExpandPalette\"\n    else:\n        # Conflict-free: try to eliminate a smallest color class\n        class_sizes = {}\n        for c in used:\n            class_sizes[c] = sum(1 for x in labels if x == c)\n        # pick smallest non-empty class\n        target_class = min(used, key=lambda c: (class_sizes[c], c))\n        members = [i for i in range(n) if labels[i] == target_class]\n        # attempt to reassign all members to other existing colors without creating conflicts\n        possible_colors = [c for c in used if c != target_class]\n        random.shuffle(members)\n        reassign = {}\n        eliminable = True\n        for v in members:\n            found = False\n            # try colors that are safe for v (no neighbor has that color)\n            # prefer smaller labels to encourage consolidation\n            for c in sorted(possible_colors):\n                safe = True\n                for nb in adj[v]:\n                    if (new_labels[nb] if nb in reassign else labels[nb]) == c:\n                        safe = False\n                        break\n                if safe:\n                    reassign[v] = c\n                    found = True\n                    break\n            if not found:\n                eliminable = False\n                break\n        if eliminable and members:\n            for v, c in reassign.items():\n                new_labels[v] = c\n            movement = \"EliminateColorClass\"\n        else:\n            # If elimination fails, try moving a random vertex to a lower-index safe color\n            i = random.randrange(n)\n            cur = labels[i]\n            target = cur\n            for c in sorted(used):\n                if c == cur:\n                    continue\n                safe = True\n                for nb in adj[i]:\n                    if new_labels[nb] == c:\n                        safe = False\n                        break\n                if safe:\n                    target = c\n                    break\n            new_labels[i] = target\n            movement = \"PartyReductionMove\" if target != cur else \"NoOpStable\"\n    neighbour = ','.join(str(x) for x in new_labels)\n    return neighbour, movement\n","Perturbacion":"import random\nfrom collections import deque\n\n\ndef perturb_solution(solution):\n    # Parse\n    try:\n        labels = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        labels = [1] * 9\n    if len(labels) != 9 or any(p <= 0 for p in labels):\n        labels = [1] * 9\n    n = 9\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    used = sorted(set(labels))\n    new_labels = labels[:]\n    if len(used) >= 2:\n        # Perform multiple Kempe-chain swaps to shake the state\n        swaps = random.randint(1, 2)\n        for _ in range(swaps):\n            a = random.choice(used)\n            b_choices = [x for x in used if x != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            candidates = [i for i in range(n) if new_labels[i] == a or new_labels[i] == b]\n            if not candidates:\n                continue\n            start = random.choice(candidates)\n            comp = [False] * n\n            dq = deque([start])\n            comp[start] = True\n            target_set = {a, b}\n            while dq:\n                u = dq.popleft()\n                for v in adj[u]:\n                    if not comp[v] and new_labels[v] in target_set:\n                        comp[v] = True\n                        dq.append(v)\n            for i in range(n):\n                if comp[i]:\n                    if new_labels[i] == a:\n                        new_labels[i] = b\n                    elif new_labels[i] == b:\n                        new_labels[i] = a\n        # Additionally, randomly reassign a small number of vertices to nearby labels\n        k = random.randint(1, 2)\n        for i in random.sample(range(n), k):\n            palette = sorted(set(new_labels))\n            if palette:\n                new_labels[i] = random.choice(palette)\n    else:\n        # If only one label used, diversify with 3-4 random labels within bound\n        k = random.randint(3, 4)\n        for i in random.sample(range(n), k):\n            new_labels[i] = random.randint(1, min(9, 4))\n    perturbed = ','.join(str(x) for x in new_labels)\n    return perturbed\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_standard","Representacion":"CSV_INT_9PARTY_ASSIGNMENT","Evaluacion":"import random\n\ndef evaluate_solution(solution: str) -> int:\n    try:\n        parts = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return 10**9\n    if len(parts) != 9:\n        return 10**9\n    if any((not isinstance(p, int)) or (p <= 0) for p in parts):\n        return 10**9\n    parties = parts\n    # Graph edges (0-based)\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    # Count conflicts\n    conflicts = 0\n    for u, v in edges:\n        if parties[u] == parties[v]:\n            conflicts += 1\n    used_parties = len(set(parties))\n    # Lower is better; conflicts dominate party count\n    cost = conflicts * 1000 + used_parties\n    return cost\n","Vecindad":"import random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse solution safely\n    try:\n        labels = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        labels = [1] * 9\n    if len(labels) != 9 or any(p <= 0 for p in labels):\n        labels = [1] * 9\n    n = 9\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    # Conflict metrics\n    conflicts_per_node = [0] * n\n    total_conflicts = 0\n    for u, v in edges:\n        if labels[u] == labels[v]:\n            conflicts_per_node[u] += 1\n            conflicts_per_node[v] += 1\n            total_conflicts += 1\n    used = sorted(set(labels))\n    # Helper to count local conflict change when moving vertex i to color c\n    def local_delta(i, c):\n        cur = labels[i]\n        if c == cur:\n            return 0\n        delta = 0\n        for nb in adj[i]:\n            if labels[nb] == cur:\n                delta -= 1\n            if labels[nb] == c:\n                delta += 1\n        return delta\n    movement = \"NoOp\"\n    new_labels = labels[:]\n    if total_conflicts > 0:\n        # Pick a conflicted node with highest conflict count (tie-break by degree and random)\n        deg = [len(adj[i]) for i in range(n)]\n        conflicted = [i for i in range(n) if conflicts_per_node[i] > 0]\n        if conflicted:\n            i = max(conflicted, key=lambda x: (conflicts_per_node[x], deg[x], random.random()))\n        else:\n            i = random.randrange(n)\n        cur = labels[i]\n        palette = list(used)\n        best_c = cur\n        best_delta = 10**9\n        for c in palette:\n            if c == cur:\n                continue\n            dc = local_delta(i, c)\n            if dc < best_delta:\n                best_delta = dc\n                best_c = c\n        if best_delta < 0:\n            new_labels[i] = best_c\n            movement = \"ConflictGreedyRecolor\"\n        else:\n            # Try a Kempe-chain swap between cur and a chosen color\n            if len(palette) >= 2:\n                target_colors = [c for c in palette if c != cur]\n                random.shuffle(target_colors)\n                performed = False\n                for c in target_colors:\n                    comp = [False] * n\n                    dq = deque([i])\n                    comp[i] = True\n                    target_set = {cur, c}\n                    while dq:\n                        u = dq.popleft()\n                        for v in adj[u]:\n                            if not comp[v] and labels[v] in target_set:\n                                comp[v] = True\n                                dq.append(v)\n                    tmp = new_labels[:]\n                    for v in range(n):\n                        if comp[v]:\n                            if tmp[v] == cur:\n                                tmp[v] = c\n                            elif tmp[v] == c:\n                                tmp[v] = cur\n                    # compute conflict change focused on affected nodes\n                    delta_conf = 0\n                    for u, v in edges:\n                        if comp[u] or comp[v]:\n                            before = 1 if (new_labels[u] == new_labels[v]) else 0\n                            after = 1 if (tmp[u] == tmp[v]) else 0\n                            delta_conf += (after - before)\n                    if delta_conf < 0:\n                        new_labels = tmp\n                        movement = \"ConflictKempeSwap\"\n                        performed = True\n                        break\n                if not performed:\n                    # Last resort: move i to a random existing color (no new colors when conflicted handling)\n                    cho = random.choice(palette)\n                    new_labels[i] = cho\n                    movement = \"ConflictRandomKick\"\n            else:\n                new_labels[i] = 1\n                movement = \"ConflictReset\"\n    else:\n        # Conflict-free: try to reduce number of colors\n        used = sorted(set(new_labels))\n        class_sizes = {c: sum(1 for x in new_labels if x == c) for c in used}\n        target_class = min(used, key=lambda c: (class_sizes[c], c))\n        members = [i for i in range(n) if new_labels[i] == target_class]\n        possible_colors = [c for c in used if c != target_class]\n        # Attempt to reassign members greedily to lowest feasible colors\n        reassigned = {}\n        feasible = True\n        for v in members:\n            ok = False\n            for c in sorted(possible_colors):\n                if all((new_labels[nb] if nb not in reassigned else reassigned.get(nb, new_labels[nb])) != c for nb in adj[v]):\n                    reassigned[v] = c\n                    ok = True\n                    break\n            if not ok:\n                feasible = False\n                break\n        if feasible and members:\n            for v, c in reassigned.items():\n                new_labels[v] = c\n            movement = \"EliminateColorClass\"\n        else:\n            # Best-improvement single-vertex recolor to lowest-index safe color\n            best_gain = 0\n            best_move = None\n            for i in range(n):\n                cur = new_labels[i]\n                for c in sorted(used):\n                    if c == cur:\n                        continue\n                    if all(new_labels[nb] != c for nb in adj[i]):\n                        # color count may reduce if cur becomes empty\n                        new_used = set(new_labels)\n                        will_empty = sum(1 for x in new_labels if x == cur) == 1\n                        gain = (1 if will_empty else 0)\n                        if gain > best_gain or (gain == best_gain and best_move is None):\n                            best_gain = gain\n                            best_move = (i, c)\n            if best_move is not None:\n                i, c = best_move\n                new_labels[i] = c\n                movement = \"ConsolidateBest\"\n            else:\n                movement = \"NoOpStable\"\n    # Normalize labels to consecutive 1..k\n    mapping = {}\n    next_c = 1\n    for x in new_labels:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n    new_labels = [mapping[x] for x in new_labels]\n    neighbour = ','.join(str(x) for x in new_labels)\n    return neighbour, movement\n","Perturbacion":"import random\nfrom collections import deque\n\ndef perturb_solution(solution):\n    # Parse\n    try:\n        labels = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        labels = [1] * 9\n    if len(labels) != 9 or any(p <= 0 for p in labels):\n        labels = [1] * 9\n    n = 9\n    # Graph\n    edges = [\n        (0,3),(0,4),(0,5),(0,7),(0,8),\n        (1,4),(1,5),(1,6),(1,7),(1,8),\n        (2,3),(2,5),(2,6),\n        (3,4),(3,6),(3,7),(3,8),\n        (4,5),(4,8),\n        (5,8),\n        (6,7)\n    ]\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    used = sorted(set(labels))\n    new_labels = labels[:]\n    if len(used) >= 2:\n        # Perform 1-2 Kempe-chain swaps to shake the state\n        swaps = random.randint(1, 2)\n        for _ in range(swaps):\n            a = random.choice(used)\n            b_choices = [x for x in used if x != a]\n            if not b_choices:\n                continue\n            b = random.choice(b_choices)\n            candidates = [i for i in range(n) if new_labels[i] == a or new_labels[i] == b]\n            if not candidates:\n                continue\n            start = random.choice(candidates)\n            comp = [False] * n\n            dq = deque([start])\n            comp[start] = True\n            target_set = {a, b}\n            while dq:\n                u = dq.popleft()\n                for v in adj[u]:\n                    if not comp[v] and new_labels[v] in target_set:\n                        comp[v] = True\n                        dq.append(v)\n            for i in range(n):\n                if comp[i]:\n                    if new_labels[i] == a:\n                        new_labels[i] = b\n                    elif new_labels[i] == b:\n                        new_labels[i] = a\n        # Additionally, randomly reassign a small number of vertices to existing labels\n        k = random.randint(1, 2)\n        for i in random.sample(range(n), k):\n            palette = sorted(set(new_labels))\n            if palette:\n                new_labels[i] = random.choice(palette)\n    else:\n        # If only one label used, diversify within 1..4\n        k = random.randint(3, 4)\n        for i in random.sample(range(n), k):\n            new_labels[i] = random.randint(1, min(9, 4))\n    # Normalize labels to consecutive 1..k\n    mapping = {}\n    next_c = 1\n    for x in new_labels:\n        if x not in mapping:\n            mapping[x] = next_c\n            next_c += 1\n    new_labels = [mapping[x] for x in new_labels]\n    perturbed = ','.join(str(x) for x in new_labels)\n    return perturbed\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"2,2,2,1,3,1,3,4,4","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Strict type check\n    if not isinstance(solution, str):\n        return float('inf')\n    # Parse representation: comma-separated list of 9 positive integers\n    try:\n        tokens = [x.strip() for x in solution.split(',')]\n        colors = [int(x) for x in tokens]\n    except Exception:\n        return float('inf')\n    n = 9\n    if len(colors) != n:\n        return float('inf')\n    if any(c <= 0 for c in colors):\n        return float('inf')\n    # Graph edges (1-indexed given -> map to 0-based)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    edges = set(tuple(sorted(e)) for e in edges)\n    # Adjacency boolean matrix\n    adj = [[False]*n for _ in range(n)]\n    for i in range(n):\n        adj[i][i] = True\n    for u,v in edges:\n        u -= 1; v -= 1\n        adj[u][v] = True\n        adj[v][u] = True\n    # Count conflicts: pairs NOT connected but share the same color\n    conflicts = 0\n    for i in range(n):\n        ci = colors[i]\n        for j in range(i+1, n):\n            if not adj[i][j] and ci == colors[j]:\n                conflicts += 1\n    # Objective: minimize conflicts, then number of colors used\n    num_colors = len(set(colors))\n    PENALTY = 10**6\n    cost = conflicts * PENALTY + num_colors\n    return cost\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Per required signature, return only metadata describing the neighborhood move\n    # Metadata: a recolor of a single node to an existing or new color\n    return (\"RECOLOR\", \"single-node\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        return solution\n    try:\n        colors = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return solution\n    n = 9\n    if len(colors) != n:\n        return solution\n    # Moderate perturbation: change k random nodes to random colors among existing or a new color\n    unique_colors = sorted(set(colors))\n    max_color = max(unique_colors) if unique_colors else 1\n    k = max(1, n \/\/ 3)\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for idx in idxs[:k]:\n        if random.random() < 0.7 and unique_colors:\n            colors[idx] = random.choice(unique_colors)\n        else:\n            max_color += 1\n            colors[idx] = max_color\n            unique_colors = sorted(set(colors))\n    # Relabel to compact 1..m for canonical form\n    used = sorted(set(colors))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    colors = [remap[c] for c in colors]\n    return ','.join(str(c) for c in colors)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"1,1,1,2,3,2,3,4,4","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    # Strict type and format checks\n    if not isinstance(solution, str):\n        return float('inf')\n    try:\n        tokens = [x.strip() for x in solution.split(',')]\n        colors = [int(x) for x in tokens]\n    except Exception:\n        return float('inf')\n    n = 9\n    if len(colors) != n:\n        return float('inf')\n    if any(c <= 0 for c in colors):\n        return float('inf')\n    # Graph edges (1-indexed)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    edges = set(tuple(sorted(e)) for e in edges)\n    # Build adjacency\n    adj = [[False]*n for _ in range(n)]\n    for i in range(n):\n        adj[i][i] = True\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u][v] = True\n        adj[v][u] = True\n    # Count conflicts: pairs NOT connected but share the same color\n    conflicts = 0\n    for i in range(n):\n        ci = colors[i]\n        for j in range(i+1, n):\n            if not adj[i][j] and ci == colors[j]:\n                conflicts += 1\n    # Objective: minimize conflicts first, then number of colors\n    if conflicts > 0:\n        return conflicts * 10**6\n    num_colors = len(set(colors))\n    return num_colors","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Return a valid neighbor solution string (single-node recolor, conflict-aware)\n    if not isinstance(solution, str):\n        return solution\n    try:\n        colors = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return solution\n    n = 9\n    if len(colors) != n:\n        return solution\n    # Build adjacency for the given fixed graph\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    edges = set(tuple(sorted(e)) for e in edges)\n    adj = [[False]*n for _ in range(n)]\n    for i in range(n):\n        adj[i][i] = True\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u][v] = True\n        adj[v][u] = True\n    # Helper: conflict count for a node color assignment (local)\n    def local_conflicts(idx, col, arr):\n        cnt = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if not adj[idx][j] and arr[j] == col:\n                cnt += 1\n        return cnt\n    # Choose a random index to recolor\n    i = random.randrange(n)\n    current = colors[i]\n    uniq = sorted(set(colors))\n    maxc = max(uniq) if uniq else 1\n    candidates = uniq + [maxc + 1]\n    # Evaluate candidates and pick one with minimum local conflicts (tie-break random)\n    scored = []\n    for c in candidates:\n        scored.append((local_conflicts(i, c, colors), c))\n    random.shuffle(scored)\n    best_local = min(scored, key=lambda t: t[0])[1]\n    colors[i] = best_local\n    # Canonical relabel to 1..m\n    used = sorted(set(colors))\n    remap = {c: k+1 for k, c in enumerate(used)}\n    colors = [remap[c] for c in colors]\n    return ','.join(str(c) for c in colors)","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger multi-move perturbation: recolor k nodes + optional color merge\n    if not isinstance(solution, str):\n        return solution\n    try:\n        colors = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return solution\n    n = 9\n    if len(colors) != n:\n        return solution\n    # Graph structure\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    edges = set(tuple(sorted(e)) for e in edges)\n    adj = [[False]*n for _ in range(n)]\n    for i in range(n):\n        adj[i][i] = True\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u][v] = True\n        adj[v][u] = True\n    # Local conflict counter\n    def local_conflicts(idx, col, arr):\n        cnt = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if not adj[idx][j] and arr[j] == col:\n                cnt += 1\n        return cnt\n    uniq = sorted(set(colors))\n    maxc = max(uniq) if uniq else 1\n    # Randomly recolor about a third of the nodes\n    k = max(2, n \/\/ 3)\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for idx in idxs[:k]:\n        # With bias, choose among existing colors that minimize local conflicts; else possibly a new color\n        candidates = uniq + ([maxc + 1] if random.random() < 0.5 else [])\n        scored = [(local_conflicts(idx, c, colors), c) for c in candidates]\n        random.shuffle(scored)\n        c_best = min(scored, key=lambda t: t[0])[1]\n        colors[idx] = c_best\n        uniq = sorted(set(colors))\n        maxc = max(uniq)\n    # Occasionally merge two random color classes to reduce palette, then allow conflicts to be fixed later\n    if len(uniq) >= 3 and random.random() < 0.7:\n        a, b = random.sample(uniq, 2)\n        target = min(a, b)\n        source = max(a, b)\n        colors = [target if c == source else c for c in colors]\n    # Canonical relabel 1..m\n    used = sorted(set(colors))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    colors = [remap[c] for c in colors]\n    return ','.join(str(c) for c in colors)","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_inverted","Representacion":"1,1,1,2,3,2,3,4,4","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate type\n    if not isinstance(solution, str):\n        return float('inf')\n    # Parse\n    try:\n        tokens = [x.strip() for x in solution.split(',')]\n        colors = [int(x) for x in tokens]\n    except Exception:\n        return float('inf')\n    n = 9\n    if len(colors) != n:\n        return float('inf')\n    if any(c <= 0 for c in colors):\n        return float('inf')\n    # Graph edges (1-indexed)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    edges = set(tuple(sorted(e)) for e in edges)\n    # Build adjacency\n    adj = [[False]*n for _ in range(n)]\n    for i in range(n):\n        adj[i][i] = True\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u][v] = True\n        adj[v][u] = True\n    # Count conflicts: pairs NOT connected but share the same color\n    conflicts = 0\n    for i in range(n):\n        ci = colors[i]\n        for j in range(i+1, n):\n            if not adj[i][j] and ci == colors[j]:\n                conflicts += 1\n    # Objective encoding: primary = conflicts, secondary = number of colors\n    if conflicts > 0:\n        return (conflicts << 20) | 0\n    num_colors = len(set(colors))\n    return num_colors\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type)\n    if not isinstance(solution, str):\n        return solution, \"invalid\"\n    try:\n        colors = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return solution, \"invalid\"\n    n = 9\n    if len(colors) != n:\n        return solution, \"invalid\"\n    # Graph edges (1-indexed)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    edges = set(tuple(sorted(e)) for e in edges)\n    adj = [[False]*n for _ in range(n)]\n    for i in range(n):\n        adj[i][i] = True\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u][v] = True\n        adj[v][u] = True\n    # Local conflict count for assigning color 'col' to node 'idx'\n    def local_conflicts(idx, col, arr):\n        cnt = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if not adj[idx][j] and arr[j] == col:\n                cnt += 1\n        return cnt\n    i = random.randrange(n)\n    uniq = sorted(set(colors))\n    maxc = max(uniq) if uniq else 1\n    candidates = uniq + [maxc + 1]\n    scored = [(local_conflicts(i, c, colors), c) for c in candidates]\n    random.shuffle(scored)\n    best_c = min(scored, key=lambda t: t[0])[1]\n    colors[i] = best_c\n    # Canonical relabel to 1..m to keep encoding compact\n    used = sorted(set(colors))\n    remap = {c: k+1 for k, c in enumerate(used)}\n    colors = [remap[c] for c in colors]\n    return ','.join(str(c) for c in colors), \"recolor\"\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    if not isinstance(solution, str):\n        return solution\n    try:\n        colors = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return solution\n    n = 9\n    if len(colors) != n:\n        return solution\n    # Graph edges (1-indexed)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    edges = set(tuple(sorted(e)) for e in edges)\n    adj = [[False]*n for _ in range(n)]\n    for i in range(n):\n        adj[i][i] = True\n    for u, v in edges:\n        u -= 1; v -= 1\n        adj[u][v] = True\n        adj[v][u] = True\n    def local_conflicts(idx, col, arr):\n        cnt = 0\n        for j in range(n):\n            if j == idx:\n                continue\n            if not adj[idx][j] and arr[j] == col:\n                cnt += 1\n        return cnt\n    uniq = sorted(set(colors))\n    maxc = max(uniq) if uniq else 1\n    k = max(2, n \/\/ 3)\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    for idx in idxs[:k]:\n        candidates = uniq + ([maxc + 1] if random.random() < 0.5 else [])\n        scored = [(local_conflicts(idx, c, colors), c) for c in candidates]\n        random.shuffle(scored)\n        c_best = min(scored, key=lambda t: t[0])[1]\n        colors[idx] = c_best\n        uniq = sorted(set(colors))\n        maxc = max(uniq)\n    # Optionally merge two color classes to reduce palette\n    if len(uniq) >= 3 and random.random() < 0.6:\n        a, b = random.sample(uniq, 2)\n        target, source = (a, b) if a < b else (b, a)\n        colors = [target if c == source else c for c in colors]\n    used = sorted(set(colors))\n    remap = {c: i+1 for i, c in enumerate(used)}\n    colors = [remap[c] for c in colors]\n    return ','.join(str(c) for c in colors)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"CSV_INT_GROUP_ASSIGNMENT_FOR_9_STUDENTS_ORDERED_BY_STUDENT_ID","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Accept CSV string and evaluate feasibility + objective (min groups, hard-penalize conflicts)\n    # Returns a float cost; lower is better.\n    if isinstance(solution, str):\n        try:\n            parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n            sol = [int(p) for p in parts]\n        except Exception:\n            return 1e9\n    elif isinstance(solution, list):\n        sol = solution[:]\n    else:\n        return 1e9\n    if len(sol) != 9:\n        return 1e9\n    for x in sol:\n        if not isinstance(x, int) or x < 1:\n            return 1e9\n    # Friendship edges (undirected) as normalized pairs (i<j)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n    # Count conflicts: pairs in same group without an edge\n    conflicts = 0\n    n = 9\n    for i in range(n):\n        gi = sol[i]\n        for j in range(i+1, n):\n            if gi == sol[j]:\n                u, v = i+1, j+1\n                if (min(u,v), max(u,v)) not in E:\n                    conflicts += 1\n    groups = len(set(sol))\n    return float(groups + conflicts * 1000.0)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Accepts CSV string, returns (CSV string neighbour, movement_type)\n    def parse_csv(sol_str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n    def to_csv(sol_list):\n        return ','.join(str(x) for x in sol_list)\n    def canonicalize(sol_list):\n        # Deterministic relabel: order groups by smallest member id\n        groups = {}\n        for idx, g in enumerate(sol_list, start=1):\n            groups.setdefault(g, []).append(idx)\n        order = sorted(groups.values(), key=lambda members: min(members))\n        label_of = {}\n        for new_label, members in enumerate(order, start=1):\n            for idx in members:\n                label_of[idx] = new_label\n        return [label_of[i+1] for i in range(len(sol_list))]\n    if not isinstance(solution, str):\n        return (solution, \"NOOP\")\n    try:\n        sol = parse_csv(solution)\n    except Exception:\n        return (solution, \"NOOP\")\n    if len(sol) == 0:\n        return (solution, \"NOOP\")\n    n = len(sol)\n    i = random.randrange(n)\n    current_group = sol[i]\n    labels = sorted(set(sol))\n    candidates = [g for g in labels if g != current_group]\n    move_type = \"MOVE\"\n    if random.random() < 0.25:\n        candidates.append(max(labels) + 1)\n        move_type = \"SPLIT\"\n    if not candidates:\n        return (solution, \"NOOP\")\n    sol[i] = random.choice(candidates)\n    sol = canonicalize(sol)\n    return (to_csv(sol), move_type)\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Accepts CSV string, returns CSV string after stronger diversification\n    def parse_csv(sol_str):\n        parts = [p.strip() for p in sol_str.split(',') if p.strip() != '']\n        return [int(p) for p in parts]\n    def to_csv(sol_list):\n        return ','.join(str(x) for x in sol_list)\n    def canonicalize(sol_list):\n        groups = {}\n        for idx, g in enumerate(sol_list, start=1):\n            groups.setdefault(g, []).append(idx)\n        order = sorted(groups.values(), key=lambda members: min(members))\n        label_of = {}\n        for new_label, members in enumerate(order, start=1):\n            for idx in members:\n                label_of[idx] = new_label\n        return [label_of[i+1] for i in range(len(sol_list))]\n    def is_clique(members, edge_set):\n        m = len(members)\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if (min(u,v), max(u,v)) not in edge_set:\n                    return False\n        return True\n    if not isinstance(solution, str):\n        return solution\n    try:\n        sol = parse_csv(solution)\n    except Exception:\n        return solution\n    n = len(sol)\n    if n == 0:\n        return solution\n    # Friendship edges (normalized)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n    # Try: merge two random groups if combined is a clique\n    groups = {}\n    for i_idx, g in enumerate(sol, start=1):\n        groups.setdefault(g, []).append(i_idx)\n    labels = sorted(groups.keys())\n    if len(labels) >= 2:\n        a, b = random.sample(labels, 2)\n        A = groups[a]\n        B = groups[b]\n        if is_clique(A + B, E):\n            for v in B:\n                sol[v - 1] = a\n            sol = canonicalize(sol)\n            return to_csv(sol)\n    # Fallback: perform 2 random reassigments with possible new group, then canonicalize\n    steps = 2\n    for _ in range(steps):\n        i = random.randrange(n)\n        g = sol[i]\n        labels = sorted(set(sol))\n        cand = [x for x in labels if x != g] + [max(labels) + 1]\n        sol[i] = random.choice(cand)\n        sol = canonicalize(sol)\n    return to_csv(sol)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"CSV_INT_GROUP_ASSIGNMENT_FOR_9_STUDENTS_ORDERED_BY_STUDENT_ID","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic objective: minimize (conflicts, groups) encoded as conflicts*1_000_000 + groups\n    # Accepts CSV string of 9 positive integers\n    if not isinstance(solution, str):\n        return 1e12\n    try:\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        sol = [int(p) for p in parts]\n    except Exception:\n        return 1e12\n    if len(sol) != 9:\n        return 1e12\n    for x in sol:\n        if not isinstance(x, int) or x < 1:\n            return 1e12\n    # Friendship edges (undirected) as normalized pairs (i<j)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n    # Count conflicts: pairs in same group without an edge\n    conflicts = 0\n    n = 9\n    for i in range(n):\n        gi = sol[i]\n        for j in range(i+1, n):\n            if gi == sol[j]:\n                u, v = i+1, j+1\n                if (min(u,v), max(u,v)) not in E:\n                    conflicts += 1\n    groups = len(set(sol))\n    return float(conflicts * 1_000_000 + groups)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (CSV string neighbour, movement_type). Conflict-aware MOVE\/MERGE\/SWAP with canonical relabel.\n    if not isinstance(solution, str):\n        return (solution, \"NOOP\")\n    try:\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        sol = [int(p) for p in parts]\n    except Exception:\n        return (solution, \"NOOP\")\n    n = len(sol)\n    if n != 9:\n        return (solution, \"NOOP\")\n\n    # Problem data (embedded)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n\n    def is_edge(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in E\n\n    def canonicalize(sol_list):\n        groups = {}\n        for idx, g in enumerate(sol_list, start=1):\n            groups.setdefault(g, []).append(idx)\n        order = sorted(groups.values(), key=lambda members: min(members))\n        label_of_group = {}\n        for new_label, members in enumerate(order, start=1):\n            for idx in members:\n                label_of_group[idx] = new_label\n        return [label_of_group[i+1] for i in range(len(sol_list))]\n\n    def group_members(sol_list):\n        gm = {}\n        for idx, g in enumerate(sol_list, start=1):\n            gm.setdefault(g, []).append(idx)\n        return gm\n\n    def group_is_clique(members):\n        m = len(members)\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if not is_edge(u, v):\n                    return False\n        return True\n\n    gm = group_members(sol)\n    labels = sorted(gm.keys())\n\n    move_choice = random.random()\n\n    # Attempt MERGE: pick two groups; if union is clique, merge\n    if move_choice < 0.2 and len(labels) >= 2:\n        a, b = random.sample(labels, 2)\n        merged = gm[a] + gm[b]\n        if group_is_clique(merged):\n            for v in gm[b]:\n                sol[v-1] = a\n            sol = canonicalize(sol)\n            return (','.join(str(x) for x in sol), \"MERGE\")\n\n    # Attempt SWAP between two vertices from different groups if keeps both cliques feasible\n    if 0.2 <= move_choice < 0.4:\n        tries = 10\n        for _ in range(tries):\n            i, j = random.sample(range(1, n+1), 2)\n            gi, gj = sol[i-1], sol[j-1]\n            if gi == gj:\n                continue\n            Gi = [v for v in gm[gi] if v != i]\n            Gj = [v for v in gm[gj] if v != j]\n            ok_i = all(is_edge(i, v) for v in Gj)\n            ok_j = all(is_edge(j, v) for v in Gi)\n            if ok_i and ok_j:\n                sol[i-1], sol[j-1] = gj, gi\n                sol = canonicalize(sol)\n                return (','.join(str(x) for x in sol), \"SWAP\")\n\n    # MOVE: pick a vertex and move to a compatible existing group (prefer) else new group\n    i = random.randrange(1, n+1)\n    gi = sol[i-1]\n    candidates = []\n    for g in labels:\n        if g == gi:\n            continue\n        members = [v for v in gm[g]]\n        if all(is_edge(i, v) for v in members):\n            candidates.append((g, len(members)))\n    # Prefer larger target cliques first to encourage consolidation\n    candidates.sort(key=lambda t: (-t[1], t[0]))\n    if candidates:\n        target = candidates[0][0]\n        sol[i-1] = target\n        # If source group becomes empty, it will be removed by canonicalization\n        sol = canonicalize(sol)\n        return (','.join(str(x) for x in sol), \"MOVE\")\n    else:\n        # Split to singleton new label\n        new_label = max(labels) + 1\n        sol[i-1] = new_label\n        sol = canonicalize(sol)\n        return (','.join(str(x) for x in sol), \"SPLIT\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong diversification: try clique-merge else relocate k vertices to best compatible groups\n    if not isinstance(solution, str):\n        return solution\n    try:\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        sol = [int(p) for p in parts]\n    except Exception:\n        return solution\n    n = len(sol)\n    if n != 9:\n        return solution\n\n    # Problem data (embedded)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n\n    def is_edge(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in E\n\n    def canonicalize(sol_list):\n        groups = {}\n        for idx, g in enumerate(sol_list, start=1):\n            groups.setdefault(g, []).append(idx)\n        order = sorted(groups.values(), key=lambda members: min(members))\n        label_of_group = {}\n        for new_label, members in enumerate(order, start=1):\n            for idx in members:\n                label_of_group[idx] = new_label\n        return [label_of_group[i+1] for i in range(len(sol_list))]\n\n    def group_members(sol_list):\n        gm = {}\n        for idx, g in enumerate(sol_list, start=1):\n            gm.setdefault(g, []).append(idx)\n        return gm\n\n    def group_is_clique(members):\n        m = len(members)\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if not is_edge(u, v):\n                    return False\n        return True\n\n    gm = group_members(sol)\n    labels = sorted(gm.keys())\n\n    # Try multiple random merges if possible\n    for _ in range(3):\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        merged = gm[a] + gm[b]\n        if group_is_clique(merged):\n            for v in gm[b]:\n                sol[v-1] = a\n            sol = canonicalize(sol)\n            gm = group_members(sol)\n            labels = sorted(gm.keys())\n\n    # Relocate k random vertices to best compatible groups (favor larger groups), allow opening new if none compatible\n    k = 3\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    vertices = vertices[:k]\n    for i in vertices:\n        gm = group_members(sol)\n        labels = sorted(gm.keys())\n        gi = sol[i-1]\n        best_g = None\n        best_size = -1\n        for g in labels:\n            if g == gi:\n                continue\n            members = gm[g]\n            if all(is_edge(i, v) for v in members):\n                if len(members) > best_size:\n                    best_size = len(members)\n                    best_g = g\n        if best_g is None:\n            best_g = max(labels) + 1\n        sol[i-1] = best_g\n        sol = canonicalize(sol)\n    return ','.join(str(x) for x in sol)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_student_groups_inverted","Representacion":"CSV_INT_GROUP_ASSIGNMENT_FOR_9_STUDENTS_ORDERED_BY_STUDENT_ID","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Lexicographic objective: minimize (conflicts, groups) encoded as conflicts*1_000_000 + groups\n    # Accepts CSV string of 9 positive integers\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ','.join(str(int(x)) for x in solution)\n        except Exception:\n            return 1e12\n    if not isinstance(solution, str):\n        return 1e12\n    try:\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        sol = [int(p) for p in parts]\n    except Exception:\n        return 1e12\n    if len(sol) != 9:\n        return 1e12\n    for x in sol:\n        if not isinstance(x, int) or x < 1:\n            return 1e12\n    # Friendship edges (undirected) as normalized pairs (i<j)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n    # Count conflicts: pairs in same group without an edge\n    conflicts = 0\n    n = 9\n    for i in range(n):\n        gi = sol[i]\n        for j in range(i+1, n):\n            if gi == sol[j]:\n                u, v = i+1, j+1\n                if (min(u,v), max(u,v)) not in E:\n                    conflicts += 1\n    groups = len(set(sol))\n    return float(conflicts * 1_000_000 + groups)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (CSV string neighbour, movement_type). Conflict-aware MOVE\/MERGE\/SWAP with canonical relabel.\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ','.join(str(int(x)) for x in solution)\n        except Exception:\n            return (solution, \"NOOP\")\n    if not isinstance(solution, str):\n        return (solution, \"NOOP\")\n    try:\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        sol = [int(p) for p in parts]\n    except Exception:\n        return (solution, \"NOOP\")\n    n = len(sol)\n    if n != 9:\n        return (solution, \"NOOP\")\n\n    # Problem data (embedded)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n\n    def is_edge(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in E\n\n    def canonicalize(sol_list):\n        groups = {}\n        for idx, g in enumerate(sol_list, start=1):\n            groups.setdefault(g, []).append(idx)\n        order = sorted(groups.values(), key=lambda members: min(members))\n        label_of_group = {}\n        for new_label, members in enumerate(order, start=1):\n            for idx in members:\n                label_of_group[idx] = new_label\n        return [label_of_group[i+1] for i in range(len(sol_list))]\n\n    def group_members(sol_list):\n        gm = {}\n        for idx, g in enumerate(sol_list, start=1):\n            gm.setdefault(g, []).append(idx)\n        return gm\n\n    def group_is_clique(members):\n        m = len(members)\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if not is_edge(u, v):\n                    return False\n        return True\n\n    gm = group_members(sol)\n    labels = sorted(gm.keys())\n\n    move_choice = random.random()\n\n    # Attempt MERGE: pick two groups; if union is clique, merge\n    if move_choice < 0.25 and len(labels) >= 2:\n        a, b = random.sample(labels, 2)\n        merged = gm[a] + gm[b]\n        if group_is_clique(merged):\n            for v in gm[b]:\n                sol[v-1] = a\n            sol = canonicalize(sol)\n            return (','.join(str(x) for x in sol), \"MERGE\")\n\n    # Attempt SWAP between two vertices from different groups if keeps both cliques feasible\n    if 0.25 <= move_choice < 0.5:\n        tries = 12\n        for _ in range(tries):\n            i, j = random.sample(range(1, n+1), 2)\n            gi, gj = sol[i-1], sol[j-1]\n            if gi == gj:\n                continue\n            gm = group_members(sol)\n            Gi = [v for v in gm[gi] if v != i]\n            Gj = [v for v in gm[gj] if v != j]\n            ok_i = all(is_edge(i, v) for v in Gj)\n            ok_j = all(is_edge(j, v) for v in Gi)\n            if ok_i and ok_j:\n                sol[i-1], sol[j-1] = gj, gi\n                sol = canonicalize(sol)\n                return (','.join(str(x) for x in sol), \"SWAP\")\n\n    # MOVE: pick a vertex and move to a compatible existing group (prefer) else new group\n    i = random.randrange(1, n+1)\n    gi = sol[i-1]\n    gm = group_members(sol)\n    labels = sorted(gm.keys())\n    candidates = []\n    for g in labels:\n        if g == gi:\n            continue\n        members = [v for v in gm[g]]\n        if all(is_edge(i, v) for v in members):\n            candidates.append((g, len(members)))\n    # Prefer larger target cliques first to encourage consolidation\n    candidates.sort(key=lambda t: (-t[1], t[0]))\n    if candidates:\n        target = candidates[0][0]\n        sol[i-1] = target\n        sol = canonicalize(sol)\n        return (','.join(str(x) for x in sol), \"MOVE\")\n    else:\n        # If no compatible group, keep as-is (avoid unnecessary label inflation)\n        return (','.join(str(x) for x in sol), \"NOOP\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Strong diversification: try clique-merge then relocate k vertices to best compatible groups\n    if isinstance(solution, (list, tuple)):\n        try:\n            solution = ','.join(str(int(x)) for x in solution)\n        except Exception:\n            return solution\n    if not isinstance(solution, str):\n        return solution\n    try:\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        sol = [int(p) for p in parts]\n    except Exception:\n        return solution\n    n = len(sol)\n    if n != 9:\n        return solution\n\n    # Problem data (embedded)\n    E = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    E = {(min(u,v), max(u,v)) for (u,v) in E}\n\n    def is_edge(u, v):\n        if u == v:\n            return True\n        a, b = (u, v) if u < v else (v, u)\n        return (a, b) in E\n\n    def canonicalize(sol_list):\n        groups = {}\n        for idx, g in enumerate(sol_list, start=1):\n            groups.setdefault(g, []).append(idx)\n        order = sorted(groups.values(), key=lambda members: min(members))\n        label_of_group = {}\n        for new_label, members in enumerate(order, start=1):\n            for idx in members:\n                label_of_group[idx] = new_label\n        return [label_of_group[i+1] for i in range(len(sol_list))]\n\n    def group_members(sol_list):\n        gm = {}\n        for idx, g in enumerate(sol_list, start=1):\n            gm.setdefault(g, []).append(idx)\n        return gm\n\n    def group_is_clique(members):\n        m = len(members)\n        for a in range(m):\n            u = members[a]\n            for b in range(a+1, m):\n                v = members[b]\n                if not is_edge(u, v):\n                    return False\n        return True\n\n    gm = group_members(sol)\n    labels = sorted(gm.keys())\n\n    # Try multiple random merges if possible\n    for _ in range(3):\n        gm = group_members(sol)\n        labels = sorted(gm.keys())\n        if len(labels) < 2:\n            break\n        a, b = random.sample(labels, 2)\n        merged = gm[a] + gm[b]\n        if group_is_clique(merged):\n            for v in gm[b]:\n                sol[v-1] = a\n            sol = canonicalize(sol)\n\n    # Relocate k random vertices to best compatible groups (favor larger groups), allow opening new if none compatible\n    k = 3\n    vertices = list(range(1, n+1))\n    random.shuffle(vertices)\n    vertices = vertices[:k]\n    for i in vertices:\n        gm = group_members(sol)\n        labels = sorted(gm.keys())\n        gi = sol[i-1]\n        best_g = None\n        best_size = -1\n        for g in labels:\n            if g == gi:\n                continue\n            members = gm[g]\n            if all(is_edge(i, v) for v in members):\n                if len(members) > best_size:\n                    best_size = len(members)\n                    best_g = g\n        if best_g is None:\n            best_g = max(labels) + 1\n        sol[i-1] = best_g\n        sol = canonicalize(sol)\n    return ','.join(str(x) for x in sol)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV string of 9 integers in [1..K]. Index i (1-indexed participants) gives room of participant i. Example valid encoding: \"1,1,1,2,3,2,3,4,4\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution: str) -> float:\n    # Parse CSV to list of ints\n    try:\n        rooms = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return 1e9\n    if len(rooms) != 9:\n        return 1e9\n    # Problem data: opponent edges (undirected)\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n    n = 9\n    # Validate feasibility: any two in same room must be opponents\n    violations = 0\n    for i in range(n):\n        ri = rooms[i]\n        for j in range(i+1, n):\n            if ri == rooms[j]:\n                if frozenset((i+1, j+1)) not in E:\n                    violations += 1\n    used_rooms = len(set(rooms))\n    # Strong penalty for infeasibility; objective is to minimize rooms\n    return used_rooms + 1000 * violations\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    parts = [int(x.strip()) for x in solution.split(',')]\n    n = len(parts)\n    used = sorted(set(parts))\n    # Opponent edges\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n\n    def room_members(room_id):\n        return [i for i in range(n) if parts[i] == room_id]\n\n    def can_join(i, room_id):\n        # Check if participant i can be in room_id maintaining clique (all pairs are opponents)\n        for j in range(n):\n            if i != j and parts[j] == room_id:\n                if frozenset((i+1, j+1)) not in E:\n                    return False\n        return True\n\n    def renumber_compact(arr):\n        # Relabel rooms to a compact sequence starting at 1, preserving relative grouping\n        mapping = {}\n        next_id = 1\n        out = []\n        for r in arr:\n            if r not in mapping:\n                mapping[r] = next_id\n                next_id += 1\n            out.append(mapping[r])\n        return out\n\n    move_types = [\"move\", \"swap\", \"merge\"]\n    random.shuffle(move_types)\n\n    # Try each move type; if a feasible neighbour is found, return it\n    for mt in move_types:\n        if mt == \"move\":\n            i = random.randrange(n)\n            current_room = parts[i]\n            # Try feasible existing rooms first\n            candidates = [r for r in used if r != current_room and can_join(i, r)]\n            if candidates:\n                dst = random.choice(candidates)\n                parts[i] = dst\n                parts = renumber_compact(parts)\n                return ','.join(str(x) for x in parts), \"move\"\n            # If no feasible existing room, consider a new room as last resort\n            new_room = max(used) + 1\n            parts[i] = new_room\n            parts = renumber_compact(parts)\n            return ','.join(str(x) for x in parts), \"move_new\"\n\n        elif mt == \"swap\":\n            # Attempt a 1-1 swap between two different rooms\n            a, b = random.sample(range(n), 2)\n            if parts[a] != parts[b]:\n                ra, rb = parts[a], parts[b]\n                # Tentative swap\n                parts[a], parts[b] = rb, ra\n                ok = can_join(a, parts[a]) and can_join(b, parts[b])\n                # Also ensure rooms of other members remain cliques with swapped members\n                if ok:\n                    # Verify all pairs within both rooms\n                    def room_ok(r):\n                        members = room_members(r)\n                        for x in members:\n                            for y in members:\n                                if x < y and frozenset((x+1, y+1)) not in E:\n                                    return False\n                        return True\n                    ok = room_ok(rb) and room_ok(ra)\n                if ok:\n                    parts = renumber_compact(parts)\n                    return ','.join(str(x) for x in parts), \"swap\"\n                else:\n                    # Revert\n                    parts[a], parts[b] = ra, rb\n\n        elif mt == \"merge\":\n            # Try to merge two rooms if their union is a clique\n            if len(used) >= 2:\n                r1, r2 = random.sample(used, 2)\n                members = room_members(r1) + room_members(r2)\n                clique = True\n                for x in range(len(members)):\n                    for y in range(x+1, len(members)):\n                        u, v = members[x]+1, members[y]+1\n                        if frozenset((u, v)) not in E:\n                            clique = False\n                            break\n                    if not clique:\n                        break\n                if clique:\n                    # Merge r2 into r1\n                    for i in range(n):\n                        if parts[i] == r2:\n                            parts[i] = r1\n                    parts = renumber_compact(parts)\n                    return ','.join(str(x) for x in parts), \"merge\"\n\n    # Fallback: random reassignment to an existing room (may be infeasible; SA\/EVAL will penalize)\n    i = random.randrange(n)\n    dsts = [r for r in used if r != parts[i]] or [max(used)+1]\n    parts[i] = random.choice(dsts)\n    parts = renumber_compact(parts)\n    return ','.join(str(x) for x in parts), \"reassign_fallback\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: split a random largest room and reinsert some members to random rooms\/new room\n    parts = [int(x.strip()) for x in solution.split(',')]\n    n = len(parts)\n    used = sorted(set(parts))\n    # Opponent edges\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n\n    def can_join(i, room_id, arr):\n        for j in range(n):\n            if i != j and arr[j] == room_id:\n                if frozenset((i+1, j+1)) not in E:\n                    return False\n        return True\n\n    def renumber_compact(arr):\n        mapping = {}\n        next_id = 1\n        out = []\n        for r in arr:\n            if r not in mapping:\n                mapping[r] = next_id\n                next_id += 1\n            out.append(mapping[r])\n        return out\n\n    # Identify largest room\n    counts = {r: parts.count(r) for r in used}\n    target_room = max(used, key=lambda r: counts[r])\n    members = [i for i in range(n) if parts[i] == target_room]\n\n    # Choose subset to move\n    k = max(1, len(members)\/\/2)\n    move_set = set(random.sample(members, k))\n\n    # Create a new room id\n    new_room = max(used) + 1\n\n    # Move selected members to new room initially\n    for i in move_set:\n        parts[i] = new_room\n\n    # Optionally try reinserting some moved members into other existing rooms if feasible\n    used = sorted(set(parts))\n    for i in list(move_set):\n        # Try a few attempts to place i into an existing room (excluding its current one)\n        candidates = used[:-1]  # exclude the newest room for diversification\n        random.shuffle(candidates)\n        placed = False\n        for r in candidates:\n            if r != parts[i] and can_join(i, r, parts):\n                parts[i] = r\n                placed = True\n                break\n        if not placed:\n            # keep in new room\n            pass\n\n    parts = renumber_compact(parts)\n    return ','.join(str(x) for x in parts)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV string of 9 integers >=1. Index i (1..9) gives the room assigned to participant i. Example: \"1,1,1,2,3,2,3,4,4\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution: str) -> float:\n    # Parse CSV to list of ints\n    try:\n        rooms = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return 1e9\n    if len(rooms) != 9:\n        return 1e9\n    # Problem data: opponent edges (undirected)\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n    n = 9\n    # Validate feasibility: any two in same room must be opponents\n    violations = 0\n    for i in range(n):\n        ri = rooms[i]\n        for j in range(i+1, n):\n            if ri == rooms[j]:\n                if frozenset((i+1, j+1)) not in E:\n                    violations += 1\n    used_rooms = len(set(rooms))\n    # Strong penalty for infeasibility; objective is to minimize rooms\n    return used_rooms + 1000 * violations\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse current solution\n    parts = [int(x.strip()) for x in solution.split(',')]\n    n = len(parts)\n    used = sorted(set(parts))\n    # Opponent edges\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n\n    def room_members(room_id):\n        return [i for i in range(n) if parts[i] == room_id]\n\n    def can_join(i, room_id):\n        # Check if participant i can be in room_id maintaining clique (all pairs are opponents)\n        for j in range(n):\n            if i != j and parts[j] == room_id:\n                if frozenset((i+1, j+1)) not in E:\n                    return False\n        return True\n\n    def room_ok(r):\n        members = room_members(r)\n        for x in range(len(members)):\n            for y in range(x+1, len(members)):\n                if frozenset((members[x]+1, members[y]+1)) not in E:\n                    return False\n        return True\n\n    def renumber_compact(arr):\n        # Relabel rooms to a compact sequence starting at 1, preserving relative grouping\n        mapping = {}\n        next_id = 1\n        out = []\n        for r in arr:\n            if r not in mapping:\n                mapping[r] = next_id\n                next_id += 1\n            out.append(mapping[r])\n        return out\n\n    move_types = [\"merge\", \"move\", \"swap\", \"kempe\", \"two_move\"]\n    random.shuffle(move_types)\n\n    # Try each move type; if a feasible neighbour is found, return it\n    for mt in move_types:\n        parts_work = parts[:]  # local copy per attempt\n        used_local = sorted(set(parts_work))\n        if mt == \"move\":\n            i = random.randrange(n)\n            current_room = parts_work[i]\n            # Try feasible existing rooms first\n            candidates = [r for r in used_local if r != current_room and can_join(i, r)]\n            if candidates:\n                dst = random.choice(candidates)\n                parts_work[i] = dst\n                parts_work = renumber_compact(parts_work)\n                return ','.join(str(x) for x in parts_work), \"move\"\n            # If no feasible existing room, consider a new room as last resort\n            new_room = (max(used_local) if used_local else 0) + 1\n            parts_work[i] = new_room\n            parts_work = renumber_compact(parts_work)\n            return ','.join(str(x) for x in parts_work), \"move_new\"\n\n        elif mt == \"swap\":\n            a, b = random.sample(range(n), 2)\n            if parts_work[a] != parts_work[b]:\n                ra, rb = parts_work[a], parts_work[b]\n                parts_work[a], parts_work[b] = rb, ra\n                if room_ok(rb) and room_ok(ra):\n                    parts_work = renumber_compact(parts_work)\n                    return ','.join(str(x) for x in parts_work), \"swap\"\n\n        elif mt == \"merge\":\n            if len(used_local) >= 2:\n                r1, r2 = random.sample(used_local, 2)\n                members = room_members(r1) + room_members(r2)\n                clique = True\n                for x in range(len(members)):\n                    for y in range(x+1, len(members)):\n                        u, v = members[x]+1, members[y]+1\n                        if frozenset((u, v)) not in E:\n                            clique = False\n                            break\n                    if not clique:\n                        break\n                if clique:\n                    for i in range(n):\n                        if parts_work[i] == r2:\n                            parts_work[i] = r1\n                    parts_work = renumber_compact(parts_work)\n                    return ','.join(str(x) for x in parts_work), \"merge\"\n\n        elif mt == \"kempe\":\n            # Kempe-chain style: pick two rooms and flip membership of a connected component within the bipartite subgraph (simplified)\n            if len(used_local) >= 2:\n                r1, r2 = random.sample(used_local, 2)\n                indices = [i for i in range(n) if parts_work[i] in (r1, r2)]\n                if indices:\n                    seed = random.choice(indices)\n                    from_room = parts_work[seed]\n                    to_room = r1 if from_room == r2 else r2\n                    flip_set = [seed]\n                    # Greedy expansion: add nodes that can move maintaining clique constraints locally\n                    improved = True\n                    while improved:\n                        improved = False\n                        for i in indices:\n                            if i not in flip_set and parts_work[i] == from_room:\n                                # Tentatively flip i\n                                parts_tmp = parts_work[:]\n                                parts_tmp[i] = to_room\n                                # Validate both rooms remain cliques\n                                ok = True\n                                for r in (from_room, to_room):\n                                    members = [idx for idx in range(n) if parts_tmp[idx] == r]\n                                    for x in range(len(members)):\n                                        for y in range(x+1, len(members)):\n                                            if frozenset((members[x]+1, members[y]+1)) not in E:\n                                                ok = False; break\n                                        if not ok: break\n                                    if not ok: break\n                                if ok:\n                                    parts_work = parts_tmp\n                                    flip_set.append(i)\n                                    improved = True\n                    parts_work = renumber_compact(parts_work)\n                    return ','.join(str(x) for x in parts_work), \"kempe\"\n\n        elif mt == \"two_move\":\n            # Move two participants jointly (may create new room), checking feasibility\n            a, b = random.sample(range(n), 2)\n            src_a, src_b = parts_work[a], parts_work[b]\n            target_rooms = used_local + [ (max(used_local) if used_local else 0) + 1 ]\n            random.shuffle(target_rooms)\n            success = False\n            for r in target_rooms:\n                for s in target_rooms:\n                    pw = parts_work[:]\n                    pw[a], pw[b] = r, s\n                    # validate rooms affected are cliques\n                    affected = set([src_a, src_b, r, s])\n                    ok = True\n                    for rr in affected:\n                        members = [i for i in range(n) if pw[i] == rr]\n                        for x in range(len(members)):\n                            for y in range(x+1, len(members)):\n                                if frozenset((members[x]+1, members[y]+1)) not in E:\n                                    ok = False; break\n                            if not ok: break\n                        if not ok: break\n                    if ok:\n                        parts_work = pw\n                        success = True\n                        break\n                if success:\n                    break\n            if success:\n                parts_work = renumber_compact(parts_work)\n                return ','.join(str(x) for x in parts_work), \"two_move\"\n\n    # Fallback: random reassignment to an existing room (may be infeasible; external EVAL will penalize)\n    i = random.randrange(n)\n    dsts = [r for r in used if r != parts[i]] or [ (max(used) if used else 0) + 1]\n    parts[i] = random.choice(dsts)\n    parts = renumber_compact(parts)\n    return ','.join(str(x) for x in parts), \"reassign_fallback\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Strong perturbation: split a random largest room and reinsert members with feasibility checks\n    parts = [int(x.strip()) for x in solution.split(',')]\n    n = len(parts)\n    used = sorted(set(parts))\n    # Opponent edges\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n\n    def can_join(i, room_id, arr):\n        for j in range(n):\n            if i != j and arr[j] == room_id:\n                if frozenset((i+1, j+1)) not in E:\n                    return False\n        return True\n\n    def room_ok(r, arr):\n        members = [i for i in range(n) if arr[i] == r]\n        for x in range(len(members)):\n            for y in range(x+1, len(members)):\n                if frozenset((members[x]+1, members[y]+1)) not in E:\n                    return False\n        return True\n\n    def renumber_compact(arr):\n        mapping = {}\n        next_id = 1\n        out = []\n        for r in arr:\n            if r not in mapping:\n                mapping[r] = next_id\n                next_id += 1\n            out.append(mapping[r])\n        return out\n\n    if not used:\n        return ','.join(str(x) for x in parts)\n\n    # Identify one of the largest rooms\n    counts = {r: parts.count(r) for r in used}\n    max_count = max(counts.values())\n    candidates = [r for r,c in counts.items() if c == max_count]\n    target_room = random.choice(candidates)\n    members = [i for i in range(n) if parts[i] == target_room]\n\n    # Choose subset to move\n    k = max(1, len(members)\/\/2)\n    move_set = set(random.sample(members, k))\n\n    # Create a new room id\n    new_room = (max(used) if used else 0) + 1\n\n    # Move selected members to new room initially\n    for i in move_set:\n        parts[i] = new_room\n\n    # Try reinserting each moved member into other existing rooms if feasible\n    used2 = sorted(set(parts))\n    for i in list(move_set):\n        candidates2 = [r for r in used2 if r != parts[i]]\n        random.shuffle(candidates2)\n        for r in candidates2:\n            if can_join(i, r, parts):\n                old = parts[i]\n                parts[i] = r\n                # ensure both affected rooms remain cliques\n                if room_ok(r, parts) and room_ok(old, parts):\n                    break\n                else:\n                    parts[i] = old\n\n    parts = renumber_compact(parts)\n    return ','.join(str(x) for x in parts)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_taekwondo_tournament_inverted","Representacion":"CSV string of 9 integers >=1. Index i (1..9) gives the room for participant i. Example: \"1,1,1,2,4,2,3,4,3\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution: str) -> float:\n    # Parse CSV to list of ints\n    try:\n        rooms = [int(x.strip()) for x in solution.split(',')]\n    except Exception:\n        return 1e9\n    if len(rooms) != 9:\n        return 1e9\n    if any(x < 1 for x in rooms):\n        return 1e9\n    # Problem data: opponent edges (undirected)\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n    n = 9\n    # Validate feasibility: any two in same room must be opponents\n    violations = 0\n    for i in range(n):\n        ri = rooms[i]\n        for j in range(i+1, n):\n            if ri == rooms[j]:\n                if frozenset((i+1, j+1)) not in E:\n                    violations += 1\n    used_rooms = len(set(rooms))\n    # Strong penalty for infeasibility; objective is to minimize rooms\n    return used_rooms + 1000 * violations\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Parse solution; on failure, start from singleton rooms\n    def parse_sol(s):\n        try:\n            arr = [int(x.strip()) for x in s.split(',')]\n            if len(arr) != 9 or any(x < 1 for x in arr):\n                raise ValueError\n            return arr\n        except Exception:\n            return list(range(1, 10))\n\n    parts = parse_sol(solution)\n    n = 9\n    # Opponent edges\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n\n    def room_members(arr, room_id):\n        return [i for i, r in enumerate(arr) if r == room_id]\n\n    def is_clique(arr, indices):\n        k = len(indices)\n        for a in range(k):\n            u = indices[a] + 1\n            for b in range(a+1, k):\n                v = indices[b] + 1\n                if frozenset((u, v)) not in E:\n                    return False\n        return True\n\n    def room_ok(arr, room_id):\n        return is_clique(arr, room_members(arr, room_id))\n\n    def can_join(arr, i, room_id):\n        members = room_members(arr, room_id)\n        for j in members:\n            if frozenset((i+1, j+1)) not in E:\n                return False\n        return True\n\n    def renumber_compact(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for r in arr:\n            if r not in mapping:\n                mapping[r] = nxt\n                nxt += 1\n            out.append(mapping[r])\n        return out\n\n    used = sorted(set(parts))\n\n    # Define move generators, all feasibility-preserving\n    def move_single(arr):\n        i = random.randrange(n)\n        cur = arr[i]\n        rooms = sorted(set(arr))\n        candidates = [r for r in rooms if r != cur and can_join(arr, i, r)]\n        # consider creating a new room if no feasible existing move\n        if not candidates:\n            new_r = (max(rooms) if rooms else 0) + 1\n            b = arr[:]\n            b[i] = new_r\n            return b, \"move_new\"\n        dst = random.choice(candidates)\n        b = arr[:]\n        b[i] = dst\n        return b, \"move\"\n\n    def swap_two(arr):\n        a, b = random.sample(range(n), 2)\n        if arr[a] == arr[b]:\n            return None\n        r_a, r_b = arr[a], arr[b]\n        c = arr[:]\n        c[a], c[b] = r_b, r_a\n        if room_ok(c, r_a) and room_ok(c, r_b):\n            return c, \"swap\"\n        return None\n\n    def merge_rooms(arr):\n        rooms = sorted(set(arr))\n        if len(rooms) < 2:\n            return None\n        r1, r2 = random.sample(rooms, 2)\n        members = room_members(arr, r1) + room_members(arr, r2)\n        if not is_clique(arr, members):\n            return None\n        c = arr[:]\n        for i in range(n):\n            if c[i] == r2:\n                c[i] = r1\n        return c, \"merge\"\n\n    def split_room(arr):\n        rooms = sorted(set(arr))\n        r = random.choice(rooms)\n        mem = room_members(arr, r)\n        if len(mem) <= 1:\n            return None\n        k = max(1, len(mem)\/\/2)\n        sel = set(random.sample(mem, k))\n        new_r = (max(rooms) if rooms else 0) + 1\n        c = arr[:]\n        for i in sel:\n            c[i] = new_r\n        # ensure both rooms remain cliques\n        if room_ok(c, r) and room_ok(c, new_r):\n            return c, \"split\"\n        return None\n\n    def kempe_like(arr):\n        rooms = sorted(set(arr))\n        if len(rooms) < 2:\n            return None\n        r1, r2 = random.sample(rooms, 2)\n        idx = [i for i in range(n) if arr[i] in (r1, r2)]\n        if not idx:\n            return None\n        seed = random.choice(idx)\n        from_r = arr[seed]\n        to_r = r1 if from_r == r2 else r2\n        c = arr[:]\n        c[seed] = to_r\n        # try to expand by flipping more from from_r to to_r greedily\n        improved = True\n        while improved:\n            improved = False\n            for i in idx:\n                if c[i] == from_r:\n                    tmp = c[:]\n                    tmp[i] = to_r\n                    if room_ok(tmp, from_r) and room_ok(tmp, to_r):\n                        c = tmp\n                        improved = True\n        if room_ok(c, r1) and room_ok(c, r2):\n            return c, \"kempe\"\n        return None\n\n    moves = [merge_rooms, swap_two, move_single, kempe_like, split_room]\n    random.shuffle(moves)\n    for mv in moves:\n        res = mv(parts)\n        if res is not None:\n            cand, mtype = res\n            cand = renumber_compact(cand)\n            return ','.join(str(x) for x in cand), mtype\n\n    # No change\n    parts = renumber_compact(parts)\n    return ','.join(str(x) for x in parts), \"noop\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Parse solution; on failure, start from singleton rooms\n    def parse_sol(s):\n        try:\n            arr = [int(x.strip()) for x in s.split(',')]\n            if len(arr) != 9 or any(x < 1 for x in arr):\n                raise ValueError\n            return arr\n        except Exception:\n            return list(range(1, 10))\n\n    parts = parse_sol(solution)\n    n = 9\n    # Opponent edges\n    E = {frozenset(e) for e in [\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    ]}\n\n    def room_members(arr, room_id):\n        return [i for i, r in enumerate(arr) if r == room_id]\n\n    def is_clique(arr, indices):\n        k = len(indices)\n        for a in range(k):\n            u = indices[a] + 1\n            for b in range(a+1, k):\n                v = indices[b] + 1\n                if frozenset((u, v)) not in E:\n                    return False\n        return True\n\n    def room_ok(arr, room_id):\n        return is_clique(arr, room_members(arr, room_id))\n\n    def can_join(arr, i, room_id):\n        members = room_members(arr, room_id)\n        for j in members:\n            if frozenset((i+1, j+1)) not in E:\n                return False\n        return True\n\n    def renumber_compact(arr):\n        mapping = {}\n        nxt = 1\n        out = []\n        for r in arr:\n            if r not in mapping:\n                mapping[r] = nxt\n                nxt += 1\n            out.append(mapping[r])\n        return out\n\n    rooms = sorted(set(parts))\n    if not rooms:\n        return ','.join(str(x) for x in parts)\n\n    # Choose a largest room to disrupt\n    counts = {r: parts.count(r) for r in rooms}\n    max_count = max(counts.values())\n    candidates = [r for r, c in counts.items() if c == max_count]\n    target = random.choice(candidates)\n    members = room_members(parts, target)\n\n    # Move about half of its members to a new room, then try feasible reinsertions\n    k = max(1, len(members)\/\/2)\n    move_set = set(random.sample(members, k))\n    new_room = (max(rooms) if rooms else 0) + 1\n    c = parts[:]\n    for i in move_set:\n        c[i] = new_room\n\n    # Attempt to reinsert moved participants into existing rooms if feasible\n    for i in list(move_set):\n        rooms2 = sorted(set(c))\n        choices = [r for r in rooms2 if r != c[i]]\n        random.shuffle(choices)\n        for r in choices:\n            old = c[i]\n            if can_join(c, i, r):\n                c[i] = r\n                if room_ok(c, r) and room_ok(c, old):\n                    break\n                c[i] = old\n\n    c = renumber_compact(c)\n    return ','.join(str(x) for x in c)\n","Version":2}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"CSV_INT_LIST_LEN_9_PARTY_IDS_1_BASED. Example: '1,1,1,2,3,2,3,4,4'. Each position i (1..9) is friend i's party label. Labels are positive integers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Parse to list[int]\n    def _parse(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n    assign = _parse(solution)\n    if assign is None:\n        return float('inf')\n    if len(assign) != 9:\n        return float('inf')\n    if any((not isinstance(x, int)) or x <= 0 for x in assign):\n        return float('inf')\n    # Edge set (undirected) as given\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    def is_edge(i,j):\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in edges\n    # Group members by party id\n    parties = {}\n    for idx, pid in enumerate(assign, start=1):\n        parties.setdefault(pid, []).append(idx)\n    # Count violations: any pair in same party without an edge\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if not is_edge(u, v):\n                    violations += 1\n    used_parties = len(parties)\n    # Lexicographic objective: minimize violations first, then number of parties\n    return violations * 1000000 + used_parties\n","Vecindad":"import random\n\n# Helpers kept internal to avoid globals\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        try:\n            return [int(p) for p in parts]\n        except Exception:\n            return None\n    elif isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _to_csv(assign):\n    return ','.join(str(x) for x in assign)\n\ndef _is_edge(u,v):\n    a,b = (u,v) if u < v else (v,u)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    return (a,b) in edges\n\ndef _party_members(assign, pid):\n    return [i+1 for i,x in enumerate(assign) if x == pid]\n\ndef _feasible_to_join(assign, node_idx1_based, target_pid):\n    # Node can join target party only if it's adjacent to all its members\n    members = _party_members(assign, target_pid)\n    for other in members:\n        if other == node_idx1_based:\n            continue\n        if not _is_edge(node_idx1_based, other):\n            return False\n    return True\n\ndef _compact_labels(assign):\n    label_map = {}\n    next_id = 1\n    out = []\n    for x in assign:\n        if x not in label_map:\n            label_map[x] = next_id\n            next_id += 1\n        out.append(label_map[x])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns tuple: (neighbor_solution_csv, NB_Type, Movement_Type)\n    assign = _parse_solution_csv_or_list(solution)\n    if assign is None or len(assign) == 0:\n        assign = [1]*9\n    n = len(assign)\n    used = sorted(set(assign))\n    # Choose move with bias toward feasibility-preserving reassignment\n    move_choice = random.random()\n    if move_choice < 0.6:\n        # Move a single node to an existing feasible party if possible; else fallback to random existing\n        i = random.randrange(n)\n        node = i+1\n        # Candidate existing parties\n        candidates = used[:]\n        random.shuffle(candidates)\n        # Try feasible first\n        moved = False\n        for pid in candidates:\n            if pid == assign[i]:\n                continue\n            if _feasible_to_join(assign, node, pid):\n                assign[i] = pid\n                moved = True\n                nb_type = \"reassign_feasible\"\n                movement = \"single_move\"\n                break\n        if not moved:\n            # Optional small chance to create new party\n            if random.random() < 0.1:\n                assign[i] = max(used) + 1\n                nb_type = \"reassign_new_party\"\n                movement = \"single_move\"\n            else:\n                # Move to random existing different party (may be infeasible; SA will handle)\n                if len(candidates) > 1:\n                    pid_other = random.choice([p for p in candidates if p != assign[i]])\n                    assign[i] = pid_other\n                nb_type = \"reassign_any\"\n                movement = \"single_move\"\n    else:\n        # Attempt party-elimination oriented swap\/relocate between two nodes\n        i, j = random.sample(range(n), 2)\n        pi, pj = assign[i], assign[j]\n        node_i, node_j = i+1, j+1\n        did = False\n        # Try swapping parties if both will be feasible in the other's party\n        if pi != pj and _feasible_to_join(assign, node_i, pj) and _feasible_to_join(assign, node_j, pi):\n            assign[i], assign[j] = assign[j], assign[i]\n            nb_type = \"swap_if_feasible\"\n            movement = \"pair_swap\"\n            did = True\n        if not did:\n            # Try moving j into i's party if feasible\n            if pi != pj and _feasible_to_join(assign, node_j, pi):\n                assign[j] = pi\n                nb_type = \"merge_into_party\"\n                movement = \"single_move\"\n                did = True\n        if not did:\n            # Fallback random swap (may be infeasible)\n            assign[i], assign[j] = assign[j], assign[i]\n            nb_type = \"swap_any\"\n            movement = \"pair_swap\"\n    # Compact labels to canonical 1..k order by first appearance to stabilize representation\n    assign = _compact_labels(assign)\n    return _to_csv(assign), nb_type, movement\n","Perturbacion":"import random\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        try:\n            return [int(p) for p in parts]\n        except Exception:\n            return None\n    elif isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _to_csv(assign):\n    return ','.join(str(x) for x in assign)\n\ndef _is_edge(u,v):\n    a,b = (u,v) if u < v else (v,u)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    return (a,b) in edges\n\ndef _party_members(assign, pid):\n    return [i+1 for i,x in enumerate(assign) if x == pid]\n\ndef _feasible_to_join(assign, node_idx1_based, target_pid):\n    members = _party_members(assign, target_pid)\n    for other in members:\n        if other == node_idx1_based:\n            continue\n        if not _is_edge(node_idx1_based, other):\n            return False\n    return True\n\ndef _compact_labels(assign):\n    label_map = {}\n    next_id = 1\n    out = []\n    for x in assign:\n        if x not in label_map:\n            label_map[x] = next_id\n            next_id += 1\n        out.append(label_map[x])\n    return out\n\ndef perturb_solution(solution):\n    # Strong diversification: attempt merge of two random parties, then random k reassignments\n    assign = _parse_solution_csv_or_list(solution)\n    if assign is None or len(assign) == 0:\n        assign = [1]*9\n    n = len(assign)\n    used = sorted(set(assign))\n    # 1) Try merging two random parties by moving nodes of the smaller into the larger if feasible; otherwise spill to new party\n    if len(used) >= 2:\n        p_a, p_b = random.sample(used, 2)\n        # Ensure p_a is larger to bias toward elimination of p_b\n        if sum(1 for x in assign if x == p_a) < sum(1 for x in assign if x == p_b):\n            p_a, p_b = p_b, p_a\n        for idx, pid in enumerate(assign):\n            if pid == p_b:\n                node = idx+1\n                if _feasible_to_join(assign, node, p_a):\n                    assign[idx] = p_a\n                else:\n                    # move to any feasible existing party if possible\n                    moved = False\n                    for q in used:\n                        if q == pid or q == p_a:\n                            continue\n                        if _feasible_to_join(assign, node, q):\n                            assign[idx] = q\n                            moved = True\n                            break\n                    if not moved:\n                        assign[idx] = max(used) + 1\n                        used.append(assign[idx])\n        # Relabel if p_b becomes empty\n    # 2) Random k reassignments with feasibility preference\n    k = random.randint(3, max(3, n))\n    idxs = random.sample(range(n), min(k, n))\n    used = sorted(set(assign))\n    for idx in idxs:\n        node = idx+1\n        # 70% try feasible existing party, 20% any existing, 10% new party\n        r = random.random()\n        if r < 0.7:\n            candidates = used[:]\n            random.shuffle(candidates)\n            for pid in candidates:\n                if pid == assign[idx]:\n                    continue\n                if _feasible_to_join(assign, node, pid):\n                    assign[idx] = pid\n                    break\n        elif r < 0.9 and len(used) > 1:\n            assign[idx] = random.choice([p for p in used if p != assign[idx]])\n        else:\n            assign[idx] = max(used) + 1\n        used = sorted(set(assign))\n    # Compact labels to keep representation stable\n    assign = _compact_labels(assign)\n    return _to_csv(assign)\n","Version":0}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"CSV_INT_LIST_LEN_9_PARTY_IDS_1_BASED. Each position i=1..9 is friend i's party label. Example: '1,1,2,2,3,3,4,4,4'. Labels are positive integers; order is arbitrary but compacted to 1..k by first appearance.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    def _parse(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n    assign = _parse(solution)\n    if assign is None:\n        return float('inf')\n    if len(assign) != 9:\n        return float('inf')\n    if any((not isinstance(x, int)) or x <= 0 for x in assign):\n        return float('inf')\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    def is_edge(i,j):\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in edges\n    parties = {}\n    for idx, pid in enumerate(assign, start=1):\n        parties.setdefault(pid, []).append(idx)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if not is_edge(u, v):\n                    violations += 1\n    used_parties = len(parties)\n    return violations * 1000000 + used_parties\n","Vecindad":"import random\n\n# Internal helpers (no globals)\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        try:\n            return [int(p) for p in parts]\n        except Exception:\n            return None\n    elif isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _to_csv(assign):\n    return ','.join(str(x) for x in assign)\n\ndef _is_edge(u,v):\n    a,b = (u,v) if u < v else (v,u)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    return (a,b) in edges\n\ndef _party_members(assign, pid):\n    return [i+1 for i,x in enumerate(assign) if x == pid]\n\ndef _feasible_to_join(assign, node_idx1_based, target_pid):\n    members = _party_members(assign, target_pid)\n    for other in members:\n        if other == node_idx1_based:\n            continue\n        if not _is_edge(node_idx1_based, other):\n            return False\n    return True\n\ndef _compact_labels(assign):\n    label_map = {}\n    next_id = 1\n    out = []\n    for x in assign:\n        if x not in label_map:\n            label_map[x] = next_id\n            next_id += 1\n        out.append(label_map[x])\n    return out\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    assign = _parse_solution_csv_or_list(solution)\n    if assign is None or len(assign) != 9:\n        assign = [1]*9\n    n = len(assign)\n    used = sorted(set(assign))\n    move_choice = random.random()\n    if move_choice < 0.6:\n        i = random.randrange(n)\n        node = i+1\n        candidates = used[:]\n        random.shuffle(candidates)\n        moved = False\n        for pid in candidates:\n            if pid == assign[i]:\n                continue\n            if _feasible_to_join(assign, node, pid):\n                assign[i] = pid\n                moved = True\n                nb_type = \"reassign_feasible\"\n                movement = \"single_move\"\n                break\n        if not moved:\n            if random.random() < 0.1:\n                assign[i] = max(used) + 1\n                nb_type = \"reassign_new_party\"\n                movement = \"single_move\"\n            else:\n                if len(candidates) > 1:\n                    pid_other = random.choice([p for p in candidates if p != assign[i]])\n                    assign[i] = pid_other\n                nb_type = \"reassign_any\"\n                movement = \"single_move\"\n    else:\n        i, j = random.sample(range(n), 2)\n        pi, pj = assign[i], assign[j]\n        node_i, node_j = i+1, j+1\n        did = False\n        if pi != pj and _feasible_to_join(assign, node_i, pj) and _feasible_to_join(assign, node_j, pi):\n            assign[i], assign[j] = assign[j], assign[i]\n            nb_type = \"swap_if_feasible\"\n            movement = \"pair_swap\"\n            did = True\n        if not did and pi != pj and _feasible_to_join(assign, node_j, pi):\n            assign[j] = pi\n            nb_type = \"merge_into_party\"\n            movement = \"single_move\"\n            did = True\n        if not did:\n            assign[i], assign[j] = assign[j], assign[i]\n            nb_type = \"swap_any\"\n            movement = \"pair_swap\"\n    assign = _compact_labels(assign)\n    return _to_csv(assign), nb_type, movement\n","Perturbacion":"import random\n\n# Internal helpers (no globals)\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        try:\n            return [int(p) for p in parts]\n        except Exception:\n            return None\n    elif isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _to_csv(assign):\n    return ','.join(str(x) for x in assign)\n\ndef _is_edge(u,v):\n    a,b = (u,v) if u < v else (v,u)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    return (a,b) in edges\n\ndef _party_members(assign, pid):\n    return [i+1 for i,x in enumerate(assign) if x == pid]\n\ndef _feasible_to_join(assign, node_idx1_based, target_pid):\n    members = _party_members(assign, target_pid)\n    for other in members:\n        if other == node_idx1_based:\n            continue\n        if not _is_edge(node_idx1_based, other):\n            return False\n    return True\n\ndef _compact_labels(assign):\n    label_map = {}\n    next_id = 1\n    out = []\n    for x in assign:\n        if x not in label_map:\n            label_map[x] = next_id\n            next_id += 1\n        out.append(label_map[x])\n    return out\n\ndef perturb_solution(solution):\n    assign = _parse_solution_csv_or_list(solution)\n    if assign is None or len(assign) != 9:\n        assign = [1]*9\n    n = len(assign)\n    used = sorted(set(assign))\n    if len(used) >= 2:\n        p_a, p_b = random.sample(used, 2)\n        if sum(1 for x in assign if x == p_a) < sum(1 for x in assign if x == p_b):\n            p_a, p_b = p_b, p_a\n        for idx, pid in enumerate(assign):\n            if pid == p_b:\n                node = idx+1\n                if _feasible_to_join(assign, node, p_a):\n                    assign[idx] = p_a\n                else:\n                    moved = False\n                    for q in used:\n                        if q == pid or q == p_a:\n                            continue\n                        if _feasible_to_join(assign, node, q):\n                            assign[idx] = q\n                            moved = True\n                            break\n                    if not moved:\n                        assign[idx] = max(used) + 1\n                        used.append(assign[idx])\n    k = random.randint(3, max(3, n))\n    idxs = random.sample(range(n), min(k, n))\n    used = sorted(set(assign))\n    for idx in idxs:\n        node = idx+1\n        r = random.random()\n        if r < 0.7:\n            candidates = used[:]\n            random.shuffle(candidates)\n            for pid in candidates:\n                if pid == assign[idx]:\n                    continue\n                if _feasible_to_join(assign, node, pid):\n                    assign[idx] = pid\n                    break\n        elif r < 0.9 and len(used) > 1:\n            assign[idx] = random.choice([p for p in used if p != assign[idx]])\n        else:\n            assign[idx] = max(used) + 1\n        used = sorted(set(assign))\n    assign = _compact_labels(assign)\n    return _to_csv(assign)\n","Version":1}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_parties_with_exes_inverted","Representacion":"CSV_INT_LIST_LEN_9_PARTY_IDS_1_BASED","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    def _parse(sol):\n        if isinstance(sol, str):\n            parts = [p.strip() for p in sol.split(',') if p.strip() != '']\n            try:\n                return [int(p) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, list):\n            try:\n                return [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n    assign = _parse(solution)\n    if assign is None:\n        return float('inf')\n    if len(assign) != 9:\n        return float('inf')\n    if any((not isinstance(x, int)) or x <= 0 for x in assign):\n        return float('inf')\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    def is_edge(i,j):\n        a,b = (i,j) if i<j else (j,i)\n        return (a,b) in edges\n    parties = {}\n    for idx, pid in enumerate(assign, start=1):\n        parties.setdefault(pid, []).append(idx)\n    violations = 0\n    for members in parties.values():\n        m = len(members)\n        if m <= 1:\n            continue\n        for i in range(m):\n            u = members[i]\n            for j in range(i+1, m):\n                v = members[j]\n                if not is_edge(u, v):\n                    violations += 1\n    used_parties = len(parties)\n    return violations * 1000000 + used_parties\n","Vecindad":"import random\n\n# Internal helpers (no globals)\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        try:\n            return [int(p) for p in parts]\n        except Exception:\n            return None\n    elif isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _to_csv(assign):\n    return ','.join(str(x) for x in assign)\n\ndef _is_edge(u,v):\n    a,b = (u,v) if u < v else (v,u)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    return (a,b) in edges\n\ndef _party_members(assign, pid):\n    return [i+1 for i,x in enumerate(assign) if x == pid]\n\ndef _feasible_to_join(assign, node_idx1_based, target_pid):\n    members = _party_members(assign, target_pid)\n    for other in members:\n        if other == node_idx1_based:\n            continue\n        if not _is_edge(node_idx1_based, other):\n            return False\n    return True\n\ndef _compact_labels(assign):\n    label_map = {}\n    next_id = 1\n    out = []\n    for x in assign:\n        if x not in label_map:\n            label_map[x] = next_id\n            next_id += 1\n        out.append(label_map[x])\n    return out\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns a 3-tuple: (new_solution_csv, NB_Type, Movement_Type)\n    NB_Type in {reassign_feasible, reassign_new_party, reassign_any, swap_if_feasible, merge_into_party, swap_any}\n    Movement_Type in {single_move, pair_swap}\n    \"\"\"\n    assign = _parse_solution_csv_or_list(solution)\n    if assign is None or len(assign) != 9:\n        # Baseline: each node its own party to avoid massive initial violations\n        assign = list(range(1, 10))\n    n = len(assign)\n    used = sorted(set(assign))\n    move_choice = random.random()\n    if move_choice < 0.6:\n        i = random.randrange(n)\n        node = i+1\n        candidates = used[:]\n        random.shuffle(candidates)\n        moved = False\n        for pid in candidates:\n            if pid == assign[i]:\n                continue\n            if _feasible_to_join(assign, node, pid):\n                assign[i] = pid\n                nb_type = \"reassign_feasible\"\n                movement = \"single_move\"\n                moved = True\n                break\n        if not moved:\n            if random.random() < 0.1:\n                assign[i] = (max(used) + 1) if used else 1\n                nb_type = \"reassign_new_party\"\n                movement = \"single_move\"\n            else:\n                if len(candidates) > 1:\n                    pid_other = random.choice([p for p in candidates if p != assign[i]])\n                    assign[i] = pid_other\n                nb_type = \"reassign_any\"\n                movement = \"single_move\"\n    else:\n        i, j = random.sample(range(n), 2)\n        pi, pj = assign[i], assign[j]\n        node_i, node_j = i+1, j+1\n        did = False\n        if pi != pj and _feasible_to_join(assign, node_i, pj) and _feasible_to_join(assign, node_j, pi):\n            assign[i], assign[j] = assign[j], assign[i]\n            nb_type = \"swap_if_feasible\"\n            movement = \"pair_swap\"\n            did = True\n        if not did and pi != pj and _feasible_to_join(assign, node_j, pi):\n            assign[j] = pi\n            nb_type = \"merge_into_party\"\n            movement = \"single_move\"\n            did = True\n        if not did:\n            assign[i], assign[j] = assign[j], assign[i]\n            nb_type = \"swap_any\"\n            movement = \"pair_swap\"\n    assign = _compact_labels(assign)\n    out = _to_csv(assign)\n    # Validation\n    parts = out.split(',')\n    if len(parts) != 9 or any(int(x) <= 0 for x in parts):\n        out = '1,2,3,4,5,6,7,8,9'\n        nb_type = \"fallback\"\n        movement = \"single_move\"\n    return out, nb_type, movement\n","Perturbacion":"import random\n\n# Internal helpers (no globals)\n\ndef _parse_solution_csv_or_list(solution):\n    if isinstance(solution, str):\n        parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n        try:\n            return [int(p) for p in parts]\n        except Exception:\n            return None\n    elif isinstance(solution, list):\n        try:\n            return [int(x) for x in solution]\n        except Exception:\n            return None\n    return None\n\ndef _to_csv(assign):\n    return ','.join(str(x) for x in assign)\n\ndef _is_edge(u,v):\n    a,b = (u,v) if u < v else (v,u)\n    edges = {\n        (1,2),(1,3),(1,7),\n        (2,3),(2,4),\n        (3,5),(3,8),(3,9),\n        (4,6),\n        (5,7),(5,8),\n        (6,7),(6,8),\n        (7,9),\n        (8,9)\n    }\n    return (a,b) in edges\n\ndef _party_members(assign, pid):\n    return [i+1 for i,x in enumerate(assign) if x == pid]\n\ndef _feasible_to_join(assign, node_idx1_based, target_pid):\n    members = _party_members(assign, target_pid)\n    for other in members:\n        if other == node_idx1_based:\n            continue\n        if not _is_edge(node_idx1_based, other):\n            return False\n    return True\n\ndef _compact_labels(assign):\n    label_map = {}\n    next_id = 1\n    out = []\n    for x in assign:\n        if x not in label_map:\n            label_map[x] = next_id\n            next_id += 1\n        out.append(label_map[x])\n    return out\n\ndef perturb_solution(solution):\n    assign = _parse_solution_csv_or_list(solution)\n    if assign is None or len(assign) != 9:\n        assign = list(range(1, 10))\n    n = len(assign)\n    used = sorted(set(assign))\n    # First, attempt to merge a smaller party into a larger compatible one\n    if len(used) >= 2:\n        p_a, p_b = random.sample(used, 2)\n        # Ensure p_a is the larger party\n        if sum(1 for x in assign if x == p_a) < sum(1 for x in assign if x == p_b):\n            p_a, p_b = p_b, p_a\n        for idx, pid in enumerate(assign):\n            if pid == p_b:\n                node = idx+1\n                if _feasible_to_join(assign, node, p_a):\n                    assign[idx] = p_a\n                else:\n                    moved = False\n                    for q in used:\n                        if q == pid or q == p_a:\n                            continue\n                        if _feasible_to_join(assign, node, q):\n                            assign[idx] = q\n                            moved = True\n                            break\n                    if not moved:\n                        assign[idx] = (max(used) + 1)\n                        used.append(assign[idx])\n        used = sorted(set(assign))\n    # Random k-shake\n    k = random.choice([2,3])\n    idxs = random.sample(range(n), min(k, n))\n    used = sorted(set(assign))\n    for idx in idxs:\n        node = idx+1\n        r = random.random()\n        if r < 0.7:\n            candidates = used[:]\n            random.shuffle(candidates)\n            for pid in candidates:\n                if pid == assign[idx]:\n                    continue\n                if _feasible_to_join(assign, node, pid):\n                    assign[idx] = pid\n                    break\n        elif r < 0.9 and len(used) > 1:\n            assign[idx] = random.choice([p for p in used if p != assign[idx]])\n        else:\n            assign[idx] = (max(used) + 1)\n        used = sorted(set(assign))\n    assign = _compact_labels(assign)\n    out = _to_csv(assign)\n    # Validation\n    parts = out.split(',')\n    if len(parts) != 9 or any(int(x) <= 0 for x in parts):\n        out = '1,2,3,4,5,6,7,8,9'\n    return out\n","Version":2}
