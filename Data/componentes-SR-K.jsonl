{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_textbook_standard","Representacion":"comma-separated string of 1-based item indices (example: '1,3,5'). No duplicate indices. Empty or invalid inputs are heavily penalized.","Evaluacion":{"REPRESENTATION":"comma-separated string of 1-based item indices (example: '1,3,5'). No duplicate indices. Empty or invalid inputs are heavily penalized.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated string of 1-based indices, e.g. '1,2,5'\n    # returns a single numeric fitness score (higher is better). Feasible solutions return total value.\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    values  = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    capacity = 80\n    # Validate input type\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of 1-based indices')\n    s = solution.strip()\n    if s == '':\n        return -10**9  # empty solution very heavily penalized\n    # Parse indices\n    try:\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        idxs = [int(p) for p in parts]\n    except Exception:\n        return -10**9  # parse error\n    # No duplicates allowed for 0\/1 knapsack\n    if len(idxs) != len(set(idxs)):\n        return -10**9\n    # Check index bounds (1-based)\n    for i in idxs:\n        if i < 1 or i > len(weights):\n            return -10**9\n    # Compute totals\n    total_weight = 0\n    total_value = 0\n    for i in idxs:\n        j = i - 1\n        total_weight += weights[j]\n        total_value += values[j]\n    # Penalize infeasible (over capacity) solutions heavily\n    if total_weight > capacity:\n        # Penalize proportionally to overweight with a large multiplier\n        return total_value - 10000 * (total_weight - capacity)\n    # Feasible: return total value as fitness\n    return total_value"},"Vecindad":{"REPRESENTATION":"A comma-separated string of 1-based item indices (e.g. '1,2,5'). The generate_neighbour function returns a tuple (neighbor_solution_string, movement_label) where neighbor_solution_string uses the same representation and movement_label describes the applied move (e.g. 'add_3', 'remove_5', 'swap_7_for_2').","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbouring 0\/1-knapsack solution.\n\n    Input:\n        solution: comma-separated string of 1-based indices (e.g. '1,2,5').\n    Output:\n        (neighbor_solution_string, movement_label)\n    \"\"\"\n    # Problem data (embedded, 1-based indexing)\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    values  = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    capacity = 80\n    n = 24\n\n    # Parse input robustly\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of 1-based indices')\n    s = solution.strip()\n    if s == '':\n        current = []\n    else:\n        parts = [p.strip() for p in s.split(',') if p.strip() != '']\n        try:\n            current = [int(p) for p in parts]\n        except Exception:\n            # malformed input -> treat as empty\n            current = []\n    # sanitize: keep only valid, unique indices\n    cur = []\n    for i in current:\n        if 1 <= i <= n and i not in cur:\n            cur.append(i)\n    current = cur\n\n    total_weight = sum(weights[i-1] for i in current)\n    total_value = sum(values[i-1] for i in current)\n    in_set = set(current)\n    remaining = capacity - total_weight\n\n    # value\/weight ratios for heuristics\n    ratios = [values[i] \/ weights[i] for i in range(n)]\n\n    # Candidate items not currently selected\n    candidates = [i+1 for i in range(n) if (i+1) not in in_set]\n    # Prefer high ratio items for addition (tie-breaker random)\n    candidates.sort(key=lambda j: (-ratios[j-1], random.random()))\n\n    # 1) Try greedy add: best ratio that fits\n    for j in candidates:\n        if weights[j-1] <= remaining:\n            new = sorted(current + [j])\n            return (','.join(str(x) for x in new), 'add_{}'.format(j))\n\n    # 2) Try beneficial swap: remove one in current and add one outside to fit capacity\n    best_swap = None\n    best_gain = -10**9\n    for a in current:\n        for b in candidates:\n            new_weight = total_weight - weights[a-1] + weights[b-1]\n            if new_weight <= capacity:\n                gain = values[b-1] - values[a-1]\n                # prefer positive gains, tie-breaker random\n                if gain > best_gain or (gain == best_gain and random.random() < 0.5):\n                    best_gain = gain\n                    best_swap = (a, b)\n    if best_swap:\n        a, b = best_swap\n        new = [i for i in current if i != a] + [b]\n        new = sorted(new)\n        return (','.join(str(x) for x in new), 'swap_{}_for_{}'.format(b, a))\n\n    # 3) If no add\/swap possible, remove the worst ratio item (least efficient)\n    if current:\n        worst = min(current, key=lambda i: (ratios[i-1], random.random()))\n        new = [i for i in current if i != worst]\n        new = sorted(new)\n        return (','.join(str(x) for x in new), 'remove_{}'.format(worst))\n\n    # 4) Fallback (empty current and no candidate due to malformed input): add highest-value item\n    if candidates:\n        best = max(candidates, key=lambda j: (values[j-1], -weights[j-1]))\n        return (str(best), 'add_{}'.format(best))\n\n    # 5) Final fallback: return empty solution\n    return ('', 'noop')\n"},"Perturbacion":{"REPRESENTATION":"Randomized component perturbation: remove a random subset of selected items, then greedily refill by value\/weight ratio with small local swap improvements to increase total value while keeping weight <= capacity.","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data (no globals)\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    values  = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    capacity = 80\n    n = len(weights)\n\n    # Parse input (robust): expect comma-separated 1-based indices string\n    if not isinstance(solution, str):\n        solution = str(solution)\n    s = solution.strip()\n    sel = []\n    if s != '':\n        try:\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            cand = [int(p) for p in parts]\n            # keep valid 1..n and preserve first occurrences\n            seen = set()\n            for i in cand:\n                if 1 <= i <= n and i not in seen:\n                    sel.append(i)\n                    seen.add(i)\n        except Exception:\n            sel = []\n\n    def tot_weight(lst):\n        return sum(weights[i-1] for i in lst)\n    def tot_value(lst):\n        return sum(values[i-1] for i in lst)\n\n    # If current solution infeasible, trim worst ratio items until feasible\n    def make_feasible(lst):\n        lst = list(lst)\n        while tot_weight(lst) > capacity and lst:\n            ratios = [(values[i-1]\/weights[i-1], i) for i in lst]\n            # remove item with smallest ratio\n            worst = min(ratios)[1]\n            lst.remove(worst)\n        return lst\n\n    sel = make_feasible(sel)\n\n    # Perturbation: remove a random subset of components (at least 1 if non-empty)\n    if sel:\n        k = max(1, int(len(sel) * 0.4))\n        k = min(k, len(sel))\n        removed = set(random.sample(sel, k))\n        sel = [i for i in sel if i not in removed]\n    else:\n        removed = set()\n\n    # Greedy refill by value\/weight ratio (randomized tie-break)\n    free = capacity - tot_weight(sel)\n    candidates = [i for i in range(1, n+1) if i not in sel]\n    random.shuffle(candidates)\n    candidates.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]), reverse=True)\n    for i in candidates:\n        if weights[i-1] <= free:\n            sel.append(i)\n            free -= weights[i-1]\n\n    # Small local improvement: try beneficial swaps (replace some low-ratio items with a better candidate)\n    # One-pass attempt to keep runtime small\n    for i in candidates:\n        if i in sel:\n            continue\n        wi = weights[i-1]\n        vi = values[i-1]\n        if wi <= free:\n            # can add directly\n            sel.append(i)\n            free -= wi\n            continue\n        # need to free space: consider removing worst-ratio items\n        included = list(sel)\n        # sort included by ascending ratio (worst first)\n        included.sort(key=lambda j: (values[j-1]\/weights[j-1], values[j-1]))\n        to_remove = []\n        freed = 0\n        removed_value = 0\n        for j in included:\n            to_remove.append(j)\n            freed += weights[j-1]\n            removed_value += values[j-1]\n            if freed + free >= wi:\n                break\n        if freed + free >= wi:\n            # if value improves, perform swap\n            if vi > removed_value:\n                for j in to_remove:\n                    sel.remove(j)\n                sel.append(i)\n                free = free + freed - wi\n    # Final feasibility check\n    sel = make_feasible(sel)\n    # Return sorted, comma-separated 1-based indices (non-empty). If empty, return a single best item that fits.\n    if not sel:\n        # pick best single item that fits by value among items with weight<=capacity\n        feasible_items = [i for i in range(1, n+1) if weights[i-1] <= capacity]\n        if feasible_items:\n            best = max(feasible_items, key=lambda i: values[i-1])\n            return str(best)\n        else:\n            return ''\n    sel_sorted = sorted(set(sel))\n    return ','.join(str(i) for i in sel_sorted)"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":3}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_textbook_standard","Representacion":"Canonical representation: comma-separated 1-based item indices (e.g. '1,3,5'). evaluate_solution accepts str, list, tuple, or int. Fitness returned is a single numeric score: total value if total weight <= capacity, otherwise a penalized score (total_value - 10 * overweight). Items and capacity are embedded inside the function.","Evaluacion":{"REPRESENTATION":"Canonical representation: comma-separated 1-based item indices (e.g. '1,3,5'). evaluate_solution accepts str, list, tuple, or int. Fitness returned is a single numeric score: total value if total weight <= capacity, otherwise a penalized score (total_value - 10 * overweight). Items and capacity are embedded inside the function.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"Evaluate a knapsack solution.\n    solution: str (comma-separated indices), list\/tuple of ints, or single int.\n    Returns a single numeric fitness.\n    Embedded instance: 24 items (index, weight, value) and capacity 80.\n    Feasible solutions (total weight <= capacity) return total value.\n    Infeasible solutions return total_value - 10*(overweight) as a penalty.\n    \"\"\"\n    # Normalization helper: accept str, list, tuple, int\n    def _normalize(sol):\n        if sol is None:\n            return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            return [int(p) for p in parts]\n        if isinstance(sol, (list, tuple)):\n            return [int(p) for p in sol]\n        if isinstance(sol, int):\n            return [int(sol)]\n        raise TypeError('Unsupported solution type: %s' % type(sol))\n\n    # Problem data (embedded locally per CRITICAL_INSTRUCTIONS)\n    items = {\n        1: (22, 4),\n        2: (22, 2),\n        3: (4, 11),\n        4: (5, 2),\n        5: (6, 24),\n        6: (14, 5),\n        7: (15, 12),\n        8: (12, 24),\n        9: (3, 21),\n        10: (10, 20),\n        11: (7, 21),\n        12: (3, 23),\n        13: (23, 13),\n        14: (21, 21),\n        15: (7, 5),\n        16: (19, 8),\n        17: (20, 5),\n        18: (22, 8),\n        19: (6, 20),\n        20: (19, 9),\n        21: (14, 4),\n        22: (24, 15),\n        23: (24, 8),\n        24: (1, 6)\n    }\n    capacity = 80\n    n = len(items)\n\n    # Parse and validate\n    try:\n        picked = _normalize(solution)\n    except Exception as e:\n        # invalid input type -> heavy penalty\n        return -1e9\n\n    # Validate indices: filter out-of-range entries and convert to ints\n    valid_picked = []\n    for idx in picked:\n        try:\n            idxi = int(idx)\n        except Exception:\n            continue\n        if 1 <= idxi <= n:\n            valid_picked.append(idxi)\n        # out-of-range indices ignored (could alternatively penalize)\n\n    total_weight = 0\n    total_value = 0\n    for i in valid_picked:\n        w, v = items[i]\n        total_weight += w\n        total_value += v\n\n    if total_weight <= capacity:\n        return total_value\n    else:\n        overweight = total_weight - capacity\n        penalty = 10 * overweight\n        return total_value - penalty\n"},"Vecindad":{"REPRESENTATION":"Comma-separated 1-based item indices string (canonical: sorted unique integers, no spaces). Examples: '', '24', '1,2,4,6'. Internal problem size N=24.","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbour for a 24-item knapsack representation.\n\n    Input normalization: accepts str, int, list or tuple. Returns a canonical\n    comma-separated string of sorted unique indices (1..24) and a movement label.\n    Movement labels: 'add_X', 'remove_X', 'swap_A_for_B', 'noop'.\n    \"\"\"\n    N = 24\n\n    def _normalize(sol):\n        # Accept None, int, str, list, tuple. Return (canonical_str, list_of_ints_sorted)\n        if sol is None:\n            return \"\", []\n        if isinstance(sol, int):\n            lst = [sol]\n        elif isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                lst = []\n            else:\n                parts = [p.strip() for p in s.split(\",\") if p.strip() != \"\"]\n                lst = []\n                for p in parts:\n                    try:\n                        lst.append(int(p))\n                    except Exception:\n                        # ignore non-integer tokens\n                        continue\n        elif isinstance(sol, (list, tuple)):\n            lst = []\n            for p in sol:\n                try:\n                    lst.append(int(p))\n                except Exception:\n                    # try to parse strings like ' 3 '\n                    if isinstance(p, str):\n                        try:\n                            lst.append(int(p.strip()))\n                        except Exception:\n                            continue\n                    else:\n                        continue\n        else:\n            raise TypeError(\"Unsupported solution type: expected str, int, list, tuple or None\")\n        # filter to valid 1..N and unique-preserving then sort\n        seen = set()\n        filtered = []\n        for v in lst:\n            if 1 <= v <= N and v not in seen:\n                filtered.append(v)\n                seen.add(v)\n        filtered.sort()\n        canonical = \",\".join(str(x) for x in filtered)\n        return canonical, filtered\n\n    canonical, current = _normalize(solution)\n    full_set = set(range(1, N + 1))\n    current_set = set(current)\n    outside = list(full_set - current_set)\n\n    # Edge cases\n    if not current and not outside:\n        return \"\", \"noop\"\n\n    # Choose move type\n    if not current:\n        move = 'add'\n    elif not outside:\n        move = 'remove'\n    else:\n        move = random.choice(['add', 'remove', 'swap'])\n\n    if move == 'add':\n        added = random.choice(outside)\n        new = current + [added]\n        label = f\"add_{added}\"\n    elif move == 'remove':\n        removed = random.choice(current)\n        new = [x for x in current if x != removed]\n        label = f\"remove_{removed}\"\n    else:  # swap\n        removed = random.choice(current)\n        added = random.choice(outside)\n        new = [x for x in current if x != removed] + [added]\n        label = f\"swap_{added}_for_{removed}\"\n\n    new_sorted = sorted(set(new))\n    neighbor = \",\".join(str(x) for x in new_sorted)\n    return neighbor, label\n"},"Perturbacion":{"REPRESENTATION":"Canonical comma-separated string of 1-based item indices (e.g. '1,2,4,6'). Accepts input as str, list, tuple or int. Output of perturb_solution is a tuple: (new_solution_string, move_label).","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    \"\"\"Perturb a solution represented as a comma-separated string or as a list\/tuple\/int.\n\n    Args:\n        solution: str|list|tuple|int representing selected item indices.\n\n    Returns:\n        (new_solution_string, move_label) where new_solution_string is a canonical\n        comma-separated string (no spaces) and move_label describes the perturbation.\n    \"\"\"\n    def normalize(sol):\n        if sol is None:\n            return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == '':\n                return []\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            return parts\n        if isinstance(sol, (list, tuple)):\n            return [str(x) for x in sol]\n        if isinstance(sol, int):\n            return [str(sol)]\n        # fallback for other types\n        return [str(sol)]\n\n    seq = normalize(solution)\n    n = len(seq)\n    # handle trivial cases\n    if n == 0:\n        return ('', 'noop_empty')\n    if n == 1:\n        return (','.join(seq), 'noop_single')\n\n    # determine perturbation strength\n    k = random.randint(1, max(1, n \/\/ 2))\n    seq2 = seq[:]\n\n    op = random.choice(['swap', 'reverse', 'rotate', 'multi_swap'])\n    if op == 'swap':\n        i, j = random.sample(range(n), 2)\n        seq2[i], seq2[j] = seq2[j], seq2[i]\n        label = f'swap_pos_{i}_{j}'\n    elif op == 'reverse':\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        seq2[i:j+1] = list(reversed(seq2[i:j+1]))\n        label = f'reverse_{i}_{j}'\n    elif op == 'rotate':\n        shift = random.randint(1, n - 1)\n        seq2 = seq2[shift:] + seq2[:shift]\n        label = f'rotate_{shift}'\n    else:  # multi_swap\n        for _ in range(k):\n            i, j = random.sample(range(n), 2)\n            seq2[i], seq2[j] = seq2[j], seq2[i]\n        label = f'multi_swap_{k}'\n\n    return (','.join(seq2), label)"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_textbook_standard","Representacion":"A solution is a comma-separated string of 1-based item indices, e.g. '1,2,5'. The evaluator rejects non-strings (TypeError), duplicate indices or out-of-range indices with a heavy penalty (-1e9). Fitness = total_value - 10000 * max(0, total_weight - capacity). Items are embedded as (weight, value).","Evaluacion":{"REPRESENTATION":"A solution is a comma-separated string of 1-based item indices, e.g. '1,2,5'. The evaluator rejects non-strings (TypeError), duplicate indices or out-of-range indices with a heavy penalty (-1e9). Fitness = total_value - 10000 * max(0, total_weight - capacity). Items are embedded as (weight, value).","EVAL_CODE":"import re\n\ndef evaluate_solution(solution):\n    \"\"\"Evaluate a comma-separated string of item indices for the embedded 24-item knapsack.\n\n    Args:\n        solution: str, comma-separated 1-based indices like '1,2,5'. Empty string '' means select no items.\n\n    Returns:\n        numeric fitness = total_value - 10000 * overweight\n        or -1e9 for duplicate\/out-of-range indices.\n\n    Raises:\n        TypeError if solution is not a str.\n        ValueError if indices are not integers.\n    \"\"\"\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of indices')\n\n    s = solution.strip()\n    if s == \"\":\n        selected = []\n    else:\n        parts = re.split(r\"\\s*,\\s*\", s)\n        try:\n            selected = [int(p) for p in parts if p != \"\"]\n        except Exception:\n            raise ValueError('solution contains non-integer tokens')\n\n    # Embedded problem data: index -> (weight, value)\n    items = {\n        1: (22, 4),\n        2: (22, 2),\n        3: (4, 11),\n        4: (5, 2),\n        5: (6, 24),\n        6: (14, 5),\n        7: (15, 12),\n        8: (12, 24),\n        9: (3, 21),\n        10: (10, 20),\n        11: (7, 21),\n        12: (3, 23),\n        13: (23, 13),\n        14: (21, 21),\n        15: (7, 5),\n        16: (19, 8),\n        17: (20, 5),\n        18: (22, 8),\n        19: (6, 20),\n        20: (19, 9),\n        21: (14, 4),\n        22: (24, 15),\n        23: (24, 8),\n        24: (1, 6),\n    }\n    capacity = 80\n\n    # Reject duplicates or out-of-range indices with heavy penalty\n    if len(selected) != len(set(selected)):\n        return -10**9\n    for idx in selected:\n        if idx not in items:\n            return -10**9\n\n    total_weight = sum(items[i][0] for i in selected)\n    total_value = sum(items[i][1] for i in selected)\n    overweight = max(0, total_weight - capacity)\n    return total_value - 10000 * overweight\n"},"Vecindad":{"REPRESENTATION":"Comma-separated string of selected item indices (1-based), e.g. '1,2,5'. Empty string denotes no items selected.","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a single-step neighbour for a knapsack selection represented as a comma-separated string of indices.\n\n    - Input must be a str (matching local evaluator interface). Raises TypeError for non-str.\n    - Rejects duplicate or out-of-range indices with ValueError (keeps behaviour strict and predictable).\n    - Returns (neighbour_solution_str, movement_type) where movement_type in {'add','remove','swap'}.\n\n    The item set and capacity are embedded (24 items, capacity 80) to keep the function self-contained and compatible\n    with the provided sample instance.\n    \"\"\"\n    # Embedded problem data (index -> (weight, value)) from SAMPLE_SOL (index weight value)\n    items = {\n        1: (22, 4), 2: (22, 2), 3: (4, 11), 4: (5, 2), 5: (6, 24), 6: (14, 5), 7: (15, 12), 8: (12, 24),\n        9: (3, 21), 10: (10, 20), 11: (7, 21), 12: (3, 23), 13: (23, 13), 14: (21, 21), 15: (7, 5),\n        16: (19, 8), 17: (20, 5), 18: (22, 8), 19: (6, 20), 20: (19, 9), 21: (14, 4), 22: (24, 15),\n        23: (24, 8), 24: (1, 6)\n    }\n    max_idx = max(items.keys())\n\n    if not isinstance(solution, str):\n        raise TypeError('solution must be a comma-separated string of indices')\n\n    s = solution.strip()\n    if s == '':\n        current = []\n    else:\n        try:\n            parts = [p for p in s.split(',') if p != '']\n            current = [int(p) for p in parts]\n        except Exception:\n            raise ValueError('solution string must contain integers separated by commas')\n\n    # Validate duplicates and range (strict handling)\n    if len(current) != len(set(current)):\n        raise ValueError('solution contains duplicate indices')\n    for idx in current:\n        if idx < 1 or idx > max_idx:\n            raise ValueError('index out of range in solution')\n\n    current_set = set(current)\n    all_indices = set(range(1, max_idx + 1))\n    not_included = list(all_indices - current_set)\n\n    # Decide move type\n    possible_moves = []\n    if len(not_included) > 0:\n        possible_moves.append('add')\n    if len(current) > 0:\n        possible_moves.append('remove')\n    if len(not_included) > 0 and len(current) > 0:\n        possible_moves.append('swap')\n\n    if not possible_moves:\n        # No possible move (shouldn't happen because either add or remove is possible unless max_idx==0)\n        return (solution, 'none')\n\n    move = random.choice(possible_moves)\n\n    if move == 'add':\n        pick = random.choice(not_included)\n        new_set = set(current)\n        new_set.add(pick)\n        new_list = sorted(new_set)\n        neighbour = ','.join(str(i) for i in new_list)\n        return (neighbour, 'add')\n\n    if move == 'remove':\n        pick = random.choice(current)\n        new_set = set(current)\n        new_set.remove(pick)\n        new_list = sorted(new_set)\n        neighbour = ','.join(str(i) for i in new_list)\n        return (neighbour, 'remove')\n\n    # swap\n    remove_choice = random.choice(current)\n    add_choice = random.choice(not_included)\n    new_set = set(current)\n    new_set.remove(remove_choice)\n    new_set.add(add_choice)\n    new_list = sorted(new_set)\n    neighbour = ','.join(str(i) for i in new_list)\n    return (neighbour, 'swap')"},"Perturbacion":{"REPRESENTATION":"Inputs accepted: comma-separated indices string (e.g. '1,2,5') or a list\/tuple of ints. Returns same type as input. Items embedded: 24 items, capacity=80. Internal item tuples are (weight,value).","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data (from SAMPLE_SOL). items[index] = (weight, value)\n    items = {\n        1: (4, 22), 2: (2, 22), 3: (11, 4), 4: (2, 5), 5: (24, 6), 6: (5, 14),\n        7: (12, 15), 8: (24, 12), 9: (21, 3), 10: (20, 10), 11: (21, 7), 12: (23, 3),\n        13: (13, 23), 14: (21, 21), 15: (5, 7), 16: (8, 19), 17: (5, 20), 18: (8, 22),\n        19: (20, 6), 20: (9, 19), 21: (4, 14), 22: (15, 24), 23: (8, 24), 24: (6, 1)\n    }\n    capacity = 80\n\n    # Parse input and remember type\n    input_was_str = False\n    if isinstance(solution, str):\n        input_was_str = True\n        s = solution.strip()\n        if s == \"\":\n            sel = []\n        else:\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            sel = [int(p) for p in parts]\n    elif isinstance(solution, (list, tuple)):\n        sel = list(solution)\n    else:\n        raise TypeError('solution must be a comma-separated string or a list\/tuple of ints')\n\n    # Sanitize: keep ints, in-range, remove duplicates (preserve order)\n    n = len(items)\n    cleaned = []\n    seen = set()\n    for x in sel:\n        try:\n            xi = int(x)\n        except Exception:\n            continue\n        if 1 <= xi <= n and xi not in seen:\n            cleaned.append(xi)\n            seen.add(xi)\n    sel = cleaned\n\n    def total_weight(selection):\n        return sum(items[i][0] for i in selection)\n    def total_value(selection):\n        return sum(items[i][1] for i in selection)\n\n    tw = total_weight(sel)\n\n    # If overweight, remove low-value-density items first\n    if tw > capacity:\n        # compute value\/weight ratios for current items (lower is worse)\n        ratios = [(items[i][1] \/ items[i][0] if items[i][0] > 0 else float('inf'), i) for i in sel]\n        ratios.sort()  # ascending -> worst first\n        for _, i in ratios:\n            if i in sel:\n                sel.remove(i)\n                tw -= items[i][0]\n            if tw <= capacity:\n                break\n        # if still overweight, remove random items until feasible\n        while tw > capacity and sel:\n            r = random.choice(sel)\n            sel.remove(r)\n            tw -= items[r][0]\n    else:\n        # Not overweight: either greedily add high density items or perform a small random swap\n        avail = [i for i in range(1, n + 1) if i not in sel]\n        if random.random() < 0.6:\n            # greedy add by value\/weight density\n            avail.sort(key=lambda i: items[i][1] \/ items[i][0] if items[i][0] > 0 else float('inf'), reverse=True)\n            for i in avail:\n                if tw + items[i][0] <= capacity:\n                    sel.append(i)\n                    tw += items[i][0]\n        else:\n            # small random perturbation: remove up to 2 items and try to add alternatives\n            rcount = 1 if len(sel) <= 1 else random.randint(1, min(2, len(sel)))\n            if sel:\n                to_remove = random.sample(sel, rcount)\n                for i in to_remove:\n                    if i in sel:\n                        sel.remove(i)\n                        tw -= items[i][0]\n                add_candidates = [i for i in range(1, n + 1) if i not in sel]\n                random.shuffle(add_candidates)\n                for j in add_candidates:\n                    if tw + items[j][0] <= capacity:\n                        sel.append(j)\n                        tw += items[j][0]\n                        if len(sel) >= len(to_remove):\n                            break\n\n    # Small random local flips to maintain diversity\n    for idx in range(len(sel)):\n        if random.random() < 0.05:\n            avail = [a for a in range(1, n + 1) if a not in sel]\n            if avail:\n                new = random.choice(avail)\n                old = sel[idx]\n                sel[idx] = new\n                if total_weight(sel) > capacity and random.random() < 0.7:\n                    # revert with some probability if infeasible\n                    sel[idx] = old\n\n    # Final sanitization: unique, in-range\n    final = []\n    seen = set()\n    for x in sel:\n        xi = int(x)\n        if 1 <= xi <= n and xi not in seen:\n            final.append(xi)\n            seen.add(xi)\n\n    if input_was_str:\n        return ','.join(str(x) for x in final)\n    return final\n"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_textbook_standard","Representacion":"Comma-separated 1-based item indices as a single string, e.g. '1,2,4,6,7,13,16,17,18,20,21,23'. Empty\/invalid\/duplicate\/out-of-range\/overweight inputs return penalty -1e9.","Evaluacion":{"REPRESENTATION":"Comma-separated 1-based item indices as a single string, e.g. '1,2,4,6,7,13,16,17,18,20,21,23'. Empty\/invalid\/duplicate\/out-of-range\/overweight inputs return penalty -1e9.","EVAL_CODE":"import re\n\ndef evaluate_solution(solution):\n    \"\"\"Evaluate a knapsack solution string and return its total value (fitness).\n    Contract: accept a single string of comma\/space\/semicolon separated 1-based indices.\n    On any parse\/validation\/feasibility error or overweight, return the numeric penalty -1e9.\n    \"\"\"\n    PENALTY = -1e9\n    # Problem data embedded (weight, value) for items 1..24\n    capacity = 80\n    items = [\n        (4, 22),  # 1\n        (2, 22),  # 2\n        (11, 4),  # 3\n        (2, 5),   # 4\n        (24, 6),  # 5\n        (5, 14),  # 6\n        (12, 15), # 7\n        (24, 12), # 8\n        (21, 3),  # 9\n        (20, 10), #10\n        (21, 7),  #11\n        (23, 3),  #12\n        (13, 23), #13\n        (21, 21), #14\n        (5, 7),   #15\n        (8, 19),  #16\n        (5, 20),  #17\n        (8, 22),  #18\n        (20, 6),  #19\n        (9, 19),  #20\n        (4, 14),  #21\n        (15, 24), #22\n        (8, 24),  #23\n        (6, 1)    #24\n    ]\n    # Strict input type: expect string\n    if not isinstance(solution, str):\n        return PENALTY\n    s = solution.strip()\n    if not s:\n        return PENALTY\n    # Split on commas, semicolons or whitespace\n    try:\n        parts = [p for p in re.split(r'[,;\\s]+', s) if p != '']\n        indices = [int(p) for p in parts]\n    except Exception:\n        return PENALTY\n    if not indices:\n        return PENALTY\n    # No duplicate indices allowed in this contract\n    if len(set(indices)) != len(indices):\n        return PENALTY\n    n = len(items)\n    # Check range\n    if any(i < 1 or i > n for i in indices):\n        return PENALTY\n    # Compute totals\n    total_weight = 0\n    total_value = 0\n    for i in indices:\n        w, v = items[i - 1]\n        total_weight += w\n        total_value += v\n    # Feasibility check\n    if total_weight > capacity:\n        return PENALTY\n    return total_value\n"},"Vecindad":{"REPRESENTATION":"Neighbour is returned as a tuple: (neighbour_csv, move_tag). neighbour_csv is a comma-separated string of 1-based item indices (e.g. '1,2,4'), empty string for empty selection. move_tag is a short string describing the applied move (flip_add, flip_remove, swap_x_to_y, restart, etc.).","NB_CODE":"def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbour for a knapsack-like solution.\n\n    Input accepted formats:\n      - CSV string of indices: '1,2,3'\n      - list\/tuple of ints\n      - free text containing digits (will extract integers)\n    Output: (neighbour_csv, move_tag)\n    - neighbour_csv: comma-separated sorted indices ('' if empty)\n    - move_tag: description of movement\n\n    Function is self-contained, uses internal problem size N=24 and is tolerant of malformed inputs.\n    \"\"\"\n    import random\n    import re\n\n    # Internal problem dimension (embedded as required)\n    N = 24\n\n    # Parse input into list of integers robustly\n    indices = []\n    try:\n        if isinstance(solution, str):\n            s = solution.strip()\n            if s == \"\":\n                raise ValueError\n            # CSV-style\n            if ',' in s:\n                parts = [p.strip() for p in s.split(',') if p.strip() != '']\n                indices = [int(p) for p in parts]\n            else:\n                # extract all integers from arbitrary text (covers multiline\/sample formats)\n                nums = re.findall(r\"\\d+\", s)\n                indices = [int(n) for n in nums]\n        elif isinstance(solution, (list, tuple)):\n            indices = [int(x) for x in solution]\n        else:\n            # unsupported type -> fallback to empty\n            raise ValueError\n    except Exception:\n        indices = []\n\n    # Keep only valid indices in 1..N and deduplicate\n    sel = set(i for i in indices if 1 <= i <= N)\n\n    available = set(range(1, N + 1)) - sel\n\n    # Randomized neighbourhood strategy:\n    # 60% flip (add\/remove), 30% swap, 10% random restart\n    r = random.random()\n    move = 'none'\n\n    if r < 0.6:\n        # flip move\n        if len(sel) == 0:\n            # must add\n            item = random.choice(list(range(1, N + 1)))\n            sel.add(item)\n            move = 'flip_add'\n        elif len(sel) == N:\n            # must remove\n            item = random.choice(list(sel))\n            sel.remove(item)\n            move = 'flip_remove'\n        else:\n            if random.random() < 0.5 and len(available) > 0:\n                item = random.choice(list(available))\n                sel.add(item)\n                move = 'flip_add'\n            else:\n                item = random.choice(list(sel))\n                sel.remove(item)\n                move = 'flip_remove'\n    elif r < 0.9:\n        # swap move (replace one selected with one unselected)\n        if len(sel) == 0 or len(available) == 0:\n            # fallback to a safe flip-add\n            item = random.choice(list(range(1, N + 1)))\n            sel.add(item)\n            move = 'flip_add_fallback'\n        else:\n            out_item = random.choice(list(sel))\n            in_item = random.choice(list(available))\n            sel.remove(out_item)\n            sel.add(in_item)\n            move = f'swap_{out_item}_to_{in_item}'\n    else:\n        # random restart\n        k = random.randint(0, N)\n        sel = set(random.sample(range(1, N + 1), k))\n        move = 'restart'\n\n    neighbour_list = sorted(sel)\n    neighbour_csv = \",\".join(str(i) for i in neighbour_list)\n    return (neighbour_csv, move)\n"},"Perturbacion":{"REPRESENTATION":"CSV string of 1-based item indices (e.g. '1,2,4,6') or a Python list\/tuple of ints. The function returns the same type as input. Perturbation uses randomized remove\/add or swap moves with variable strength and is robust to malformed input.","PERTURB_CODE":"import random\nimport re\n\ndef perturb_solution(solution):\n    '''\n    Robust perturbation for knapsack item-index solutions.\n    - Accepts: CSV string of 1-based indices (e.g. '1,2,4') or list\/tuple of ints\/strs.\n    - Returns: same type as input (CSV string or list of ints).\n    - Behavior: if input is empty\/invalid, generates a random feasible index set.\n    - Perturbation: removes and\/or swaps a small randomized fraction of indices.\n\n    Notes: Problem size is embedded locally (n_items=24) to ensure self-containment.\n    '''\n    n_items = 24  # embedded problem size (1..24)\n\n    # Helper: parse input into list of unique ints in range\n    def _parse(sol):\n        parsed = []\n        if sol is None:\n            return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == '':\n                return []\n            parts = re.split(r'[^0-9]+', s)\n            for p in parts:\n                if p == '':\n                    continue\n                try:\n                    v = int(p)\n                except Exception:\n                    continue\n                if 1 <= v <= n_items:\n                    parsed.append(v)\n        elif isinstance(sol, (list, tuple)):\n            for x in sol:\n                try:\n                    v = int(x)\n                except Exception:\n                    continue\n                if 1 <= v <= n_items:\n                    parsed.append(v)\n        else:\n            return []\n        # deduplicate while preserving order\n        seen = set()\n        uniq = []\n        for v in parsed:\n            if v not in seen:\n                seen.add(v)\n                uniq.append(v)\n        return uniq\n\n    inp_type = 'str' if isinstance(solution, str) else ('list' if isinstance(solution, (list, tuple)) else 'other')\n    current = _parse(solution)\n\n    # If nothing valid parsed, create a random seed solution\n    if not current:\n        k = random.randint(1, max(1, n_items \/\/ 3))\n        new_sol = random.sample(range(1, n_items + 1), k)\n        # return in requested type\n        if inp_type == 'str':\n            return ','.join(str(x) for x in new_sol)\n        if inp_type == 'list':\n            return new_sol\n        return ','.join(str(x) for x in new_sol)\n\n    # Determine perturbation strength (fraction of items)\n    base_k = max(1, int(round(len(current) * 0.3)))\n    k = random.randint(1, max(1, base_k))\n\n    # Available items not currently selected\n    available = [i for i in range(1, n_items + 1) if i not in current]\n\n    # Choose operation: remove+add or swaps (randomized)\n    new = list(current)\n    try:\n        if available and random.random() < 0.6:\n            # remove up to k items, then add up to k new ones\n            rem_count = min(k, len(new))\n            if rem_count > 0:\n                rem = random.sample(new, rem_count)\n                for r in rem:\n                    if r in new:\n                        new.remove(r)\n            add_count = min(k, len(available))\n            if add_count > 0:\n                adds = random.sample(available, add_count)\n                new.extend(adds)\n        else:\n            # perform up to k swaps between selected and available\n            swap_count = min(k, len(new), len(available))\n            for _ in range(swap_count):\n                out = random.choice(new)\n                new.remove(out)\n                inn = random.choice(available)\n                # update available pool\n                available.remove(inn)\n                available.append(out)\n                new.append(inn)\n        # small random shuffle for diversity\n        random.shuffle(new)\n    except Exception:\n        # On any unexpected error, return the original parsed solution\n        new = list(current)\n\n    # Normalize output: unique and within range\n    seen = set()\n    final = []\n    for v in new:\n        try:\n            vi = int(v)\n        except Exception:\n            continue\n        if 1 <= vi <= n_items and vi not in seen:\n            seen.add(vi)\n            final.append(vi)\n\n    # Return in same format as input\n    if inp_type == 'str':\n        return ','.join(str(x) for x in final)\n    if inp_type == 'list':\n        return final\n    return ','.join(str(x) for x in final)\n"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard","Representacion":"Comma-separated 1-based customer indices (e.g. \"1,2,5\"). Empty string allowed and yields 0.0.","Evaluacion":{"REPRESENTATION":"Comma-separated 1-based customer indices (e.g. \"1,2,5\"). Empty string allowed and yields 0.0.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    # solution: comma-separated string of 1-based customer indices\n    # Returns: numeric fitness = revenue if feasible; large penalty if infeasible\/invalid.\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n    PENALTY_BASE = 1000000000.0\n\n    # Validate input type\n    if not isinstance(solution, str):\n        return -PENALTY_BASE\n\n    # Parse comma-separated indices\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    # empty selection -> zero revenue, feasible\n    if parts == []:\n        return 0.0\n\n    ids = []\n    for p in parts:\n        try:\n            i = int(p)\n        except Exception:\n            return -PENALTY_BASE\n        if i < 1 or i > 24:\n            return -PENALTY_BASE\n        ids.append(i)\n\n    # no duplicates allowed\n    if len(set(ids)) != len(ids):\n        return -PENALTY_BASE\n\n    # compute revenue and weight\n    total_rev = 0\n    total_w = 0\n    for i in ids:\n        total_rev += values[i-1]\n        total_w += weights[i-1]\n\n    # feasible -> return revenue as fitness\n    if total_w <= capacity:\n        return float(total_rev)\n\n    # infeasible -> heavy penalty proportional to excess capacity\n    excess = total_w - capacity\n    return float(total_rev) - PENALTY_BASE * excess\n"},"Vecindad":{"REPRESENTATION":"Stochastic local neighbour: try a single-item add move (if it fits), else attempt a 1-for-1 swap that yields feasibility, else remove a random selected item. Returns (neighbour_solution_string, (NB_Type, Movement_Type)). Solution format is comma-separated 1-based indices (empty string = empty selection).","NB_CODE":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Problem data embedded (no globals)\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n\n    # Robust parsing of comma-separated 1-based indices\n    if not isinstance(solution, str):\n        solution = str(solution)\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    ids = []\n    for p in parts:\n        try:\n            i = int(p)\n        except Exception:\n            # ignore invalid tokens\n            continue\n        if 1 <= i <= 24:\n            ids.append(i)\n    ids_set = set(ids)\n\n    def total_weight(s):\n        return sum(weights[i-1] for i in s)\n\n    cur_w = total_weight(ids_set)\n\n    # 1) Try single-item add move (randomized order)\n    candidates = [i for i in range(1, 25) if i not in ids_set]\n    random.shuffle(candidates)\n    for j in candidates:\n        if cur_w + weights[j-1] <= capacity:\n            newset = sorted(ids_set | {j})\n            neigh = \",\".join(str(x) for x in newset)\n            return neigh, (\"bitflip\", \"add\")\n\n    # 2) Try 1-for-1 swap (remove one selected, add one outside)\n    if ids_set:\n        outs = list(ids_set)\n        ins = [i for i in range(1, 25) if i not in ids_set]\n        random.shuffle(outs)\n        random.shuffle(ins)\n        for out in outs:\n            for inn in ins:\n                new_w = cur_w - weights[out-1] + weights[inn-1]\n                if new_w <= capacity:\n                    newset = set(ids_set)\n                    newset.remove(out)\n                    newset.add(inn)\n                    neigh = \",\".join(str(x) for x in sorted(newset))\n                    return neigh, (\"swap\", \"replace\")\n\n    # 3) Fallback: remove a random selected item (if any)\n    if ids_set:\n        rem = random.choice(list(ids_set))\n        newset = set(ids_set)\n        newset.remove(rem)\n        neigh = \",\".join(str(x) for x in sorted(newset))\n        return neigh, (\"bitflip\", \"remove\")\n\n    # 4) If empty and no add found (very unlikely), return empty\/no-op\n    return \"\", (\"noop\", \"none\")\n"},"Perturbacion":{"REPRESENTATION":"Comma-separated 1-based item indices (string). The perturbation applies a small randomized change: remove, add, swap, or greedy add, while attempting to restore feasibility by removing low value\/weight items if overweight. Empty string denotes selecting no items.","PERTURB_CODE":"def perturb_solution(solution):\n    import random\n    # Problem data embedded\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n\n    # Parse input safely\n    if not isinstance(solution, str):\n        return \"\"\n    parts = [p.strip() for p in solution.split(',') if p.strip() != '']\n    ids = []\n    for p in parts:\n        try:\n            i = int(p)\n        except Exception:\n            return \"\"\n        if i < 1 or i > 24:\n            return \"\"\n        ids.append(i)\n    # remove duplicates if any (defensive)\n    ids = list(dict.fromkeys(ids))\n\n    # helper: compute total weight\n    def total_weight(sel):\n        return sum(weights[i-1] for i in sel)\n\n    # helper: repair overweight by removing lowest value\/weight ratio items\n    def repair(sel):\n        while total_weight(sel) > capacity and sel:\n            # compute ratio value\/weight, remove item with smallest ratio (least efficient)\n            ratios = [(values[i-1] \/ float(weights[i-1]), i) for i in sel]\n            ratios.sort()  # ascending, smallest first\n            remove_i = ratios[0][1]\n            sel.remove(remove_i)\n        return sel\n\n    # begin perturbation\n    universe = list(range(1, 25))\n    present = ids[:]  # current selection\n    absent = [i for i in universe if i not in present]\n\n    # choose small perturbation\n    ops = ['remove', 'add', 'swap', 'greedy_add']\n    # bias toward small change\n    op = random.choices(ops, weights=[3,3,2,2], k=1)[0]\n\n    if op == 'remove' and present:\n        k = 1 if random.random() < 0.75 else 2\n        k = min(k, len(present))\n        for _ in range(k):\n            # remove a random item (prefer low ratio)\n            ratios = [(values[i-1] \/ float(weights[i-1]), i) for i in present]\n            # sometimes remove random, sometimes worst\n            if random.random() < 0.6:\n                # remove worst ratio\n                ratios.sort()\n                rem = ratios[0][1]\n            else:\n                rem = random.choice(present)\n            present.remove(rem)\n\n    elif op == 'add' and absent:\n        k = 1\n        candidates = absent[:]\n        # try to add an item likely to improve value: pick by high value\/weight\n        candidates.sort(key=lambda i: values[i-1]\/float(weights[i-1]), reverse=True)\n        for i in candidates:\n            if i in present:\n                continue\n            present.append(i)\n            if total_weight(present) > capacity:\n                # undo if it causes overweight and try next\n                present.remove(i)\n                continue\n            break\n\n    elif op == 'swap' and present and absent:\n        # remove one (low ratio) and add one (high ratio)\n        ratios_present = [(values[i-1]\/float(weights[i-1]), i) for i in present]\n        ratios_present.sort()\n        to_remove = ratios_present[0][1]\n        candidates = absent[:]\n        candidates.sort(key=lambda i: values[i-1]\/float(weights[i-1]), reverse=True)\n        present.remove(to_remove)\n        added = False\n        for i in candidates:\n            present.append(i)\n            if total_weight(present) <= capacity:\n                added = True\n                break\n            present.remove(i)\n        if not added:\n            # revert removal if no feasible add found\n            present.append(to_remove)\n\n    elif op == 'greedy_add' and absent:\n        # greedily add high ratio items until capacity\n        candidates = absent[:]\n        candidates.sort(key=lambda i: values[i-1]\/float(weights[i-1]), reverse=True)\n        for i in candidates:\n            if total_weight(present) + weights[i-1] <= capacity:\n                present.append(i)\n\n    # final repair to ensure feasibility (remove low ratio items if still overweight)\n    present = repair(present)\n\n    # return sorted, comma-separated string (stable order: increasing index)\n    present_sorted = sorted(set(present))\n    if not present_sorted:\n        return \"\"\n    return \",\".join(str(i) for i in present_sorted)\n"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":3}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard","Representacion":"Comma-separated 1-based item indices as a string (e.g. \"1,4,7\") or a list\/tuple of ints. There are 24 items (indexed 1..24) with embedded (weight,value) pairs; knapsack capacity = 80.","Evaluacion":{"REPRESENTATION":"Comma-separated 1-based item indices as a string (e.g. \"1,4,7\") or a list\/tuple of ints. There are 24 items (indexed 1..24) with embedded (weight,value) pairs; knapsack capacity = 80.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a candidate knapsack selection.\n\n    Args:\n        solution: either a string of comma-separated 1-based indices (e.g. '1,4,7'),\n                  or a list\/tuple of integers.\n\n    Returns:\n        A single numeric fitness (float). If total weight <= capacity the fitness is\n        the total value. If infeasible (weight > capacity) a linear penalty is\n        applied: fitness = total_value - PENALTY_PER_UNIT * (weight - capacity).\n\n    Notes:\n        - Item data and capacity are embedded and self-contained in this function.\n        - Invalid indices raise ValueError.\n    \"\"\"\n    # Embedded problem data: {index: (weight, value)}\n    items = {\n        1: (22, 4), 2: (22, 2), 3: (4, 11), 4: (5, 2), 5: (6, 24), 6: (14, 5),\n        7: (15, 12), 8: (12, 24), 9: (3, 21), 10: (10, 20), 11: (7, 21), 12: (3, 23),\n        13: (23, 13), 14: (21, 21), 15: (7, 5), 16: (19, 8), 17: (20, 5), 18: (22, 8),\n        19: (6, 20), 20: (19, 9), 21: (14, 4), 22: (24, 15), 23: (24, 8), 24: (1, 6)\n    }\n    capacity = 80\n    PENALTY_PER_UNIT = 1e6\n\n    # Parse solution into list of ints\n    if solution is None:\n        selected = []\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            selected = []\n        else:\n            # accept commas or semicolons as separators\n            parts = [p.strip() for p in s.replace(';', ',').split(',') if p.strip() != '']\n            try:\n                selected = [int(p) for p in parts]\n            except Exception:\n                raise ValueError('solution string must contain comma-separated integers')\n    elif isinstance(solution, (list, tuple)):\n        selected = list(solution)\n    else:\n        raise ValueError('unsupported solution type; provide string or list of ints')\n\n    # Validate indices\n    for idx in selected:\n        if not isinstance(idx, int):\n            raise ValueError('solution indices must be integers')\n        if idx < 1 or idx > len(items):\n            raise ValueError('index out of range: %s' % idx)\n\n    # Compute totals\n    total_weight = 0\n    total_value = 0\n    for idx in selected:\n        w, v = items[idx]\n        total_weight += w\n        total_value += v\n\n    if total_weight <= capacity:\n        return float(total_value)\n    else:\n        # Strong linear penalty for infeasible solutions\n        return float(total_value - PENALTY_PER_UNIT * (total_weight - capacity))\n"},"Vecindad":{"REPRESENTATION":"Comma-separated integer indices 1..24 (e.g. \"1,3,5\"). Empty string denotes empty selection.","NB_CODE":"import random\nimport hashlib\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbour of a knapsack selection for a 24-item instance.\n\n    Representation: comma-separated integers 1..24. Empty string means no items.\n    Returns: (neighbour_string, (nb_type, movement_type))\n    Deterministic: seeded by hash of input solution for reproducibility.\n    \"\"\"\n    # Problem-size encoded internally (no globals)\n    n = 24\n\n    if solution is None:\n        solution = ''\n    if not isinstance(solution, str):\n        raise ValueError('solution must be a string of comma-separated integers')\n\n    s = solution.strip()\n    if s == '':\n        selected = set()\n    else:\n        tokens = [t.strip() for t in s.split(',') if t.strip() != '']\n        selected = set()\n        try:\n            for tk in tokens:\n                v = int(tk)\n                if v < 1 or v > n:\n                    raise ValueError('index out of range 1..%d' % n)\n                selected.add(v)\n        except Exception as e:\n            raise ValueError('Invalid solution format: expected comma-separated integers 1..%d' % n) from e\n\n    # deterministic RNG seeded from solution for reproducible neighbour generation\n    seed = int(hashlib.sha256(solution.encode('utf-8')).hexdigest(), 16) & 0xFFFFFFFF\n    rnd = random.Random(seed)\n\n    # choose feasible operations\n    ops = []\n    if len(selected) < n:\n        ops.append('add')\n    if len(selected) > 0:\n        ops.append('remove')\n    if 0 < len(selected) < n:\n        ops.append('swap')\n    ops.append('perturb')\n\n    op = rnd.choice(ops)\n\n    neighbour = set(selected)\n    meta = ('unknown', 'unknown')\n\n    if op == 'add':\n        choices = [i for i in range(1, n + 1) if i not in neighbour]\n        if not choices:\n            # fallback to remove if nothing to add\n            out = rnd.choice(list(neighbour))\n            neighbour.remove(out)\n            meta = ('bitflip', 'remove')\n        else:\n            pick = rnd.choice(choices)\n            neighbour.add(pick)\n            meta = ('bitflip', 'add')\n\n    elif op == 'remove':\n        out = rnd.choice(list(neighbour))\n        neighbour.remove(out)\n        meta = ('bitflip', 'remove')\n\n    elif op == 'swap':\n        out = rnd.choice(list(neighbour))\n        ins_choices = [i for i in range(1, n + 1) if i not in neighbour]\n        ins = rnd.choice(ins_choices)\n        neighbour.remove(out)\n        neighbour.add(ins)\n        meta = ('swap', 'exchange')\n\n    else:  # perturb\n        # small random perturbation (1-2 changes) for diversification\n        strength = 1 if rnd.random() < 0.7 else 2\n        for _ in range(strength):\n            if rnd.random() < 0.5 and len(neighbour) < n:\n                choices = [i for i in range(1, n + 1) if i not in neighbour]\n                if choices:\n                    neighbour.add(rnd.choice(choices))\n            elif len(neighbour) > 0:\n                neighbour.remove(rnd.choice(list(neighbour)))\n        meta = ('perturb', 'multi')\n\n    # canonical string representation (sorted, comma-separated). Empty string for empty set.\n    if len(neighbour) == 0:\n        nb_str = ''\n    else:\n        nb_str = ','.join(str(i) for i in sorted(neighbour))\n\n    return nb_str, meta\n"},"Perturbacion":{"REPRESENTATION":"Comma-separated item indices as integers, e.g. \"24\" or \"1,2,5\" (empty string denotes no items).","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    \"\"\"Perturb a solution given as a comma-separated string of integer item indices.\n\n    Behaviour:\n    - Parses the input string into a list of unique positive integers.\n    - Applies a single small perturbation: add, remove, swap, or mutate (\u00b11\/\u00b12).\n    - Ensures the returned solution is a non-empty comma-separated string of integers.\n\n    Args:\n        solution: str (e.g. '1,2,5' or '24' or '')\n    Returns:\n        str: perturbed solution in the same representation (no spaces, comma-separated).\n    \"\"\"\n    # Normalize input\n    if solution is None:\n        s = \"\"\n    else:\n        s = str(solution).strip()\n    if s == \"\":\n        # Start from a small default single-item solution\n        return \"1\"\n\n    # Parse and validate tokens (must be integers)\n    tokens = [tok.strip() for tok in s.split(',') if tok.strip() != \"\"]\n    try:\n        ints = []\n        for t in tokens:\n            # raise on non-integer\n            v = int(t)\n            if v < 1:\n                raise ValueError\n            ints.append(v)\n    except Exception:\n        raise ValueError(\"Invalid solution string: must be comma-separated positive integers\")\n\n    # Preserve order, remove duplicates\n    seen = set()\n    ints = [x for x in ints if not (x in seen or seen.add(x))]\n\n    if not ints:\n        return \"1\"\n\n    max_idx = max(ints)\n\n    # Choose operation probabilistically, adapt to current length\n    ops = [\"remove\", \"add\", \"swap\", \"mutate\"]\n    if len(ints) <= 1:\n        weights = [0, 3, 0, 2]\n    else:\n        weights = [1, 3, 2, 2]\n    op = random.choices(ops, weights=weights, k=1)[0]\n\n    if op == \"remove\":\n        # remove a random element (keep at least one element)\n        if len(ints) > 1:\n            idx = random.randrange(len(ints))\n            ints.pop(idx)\n        else:\n            # fallback to add if removal would make empty\n            op = \"add\"\n\n    if op == \"add\":\n        # try to add a new small-index item not already present\n        upper = max(10, int(max_idx * 1.2) + 3)\n        candidate = random.randint(1, upper)\n        tries = 0\n        while candidate in ints and tries < 10:\n            candidate = random.randint(1, upper)\n            tries += 1\n        if candidate in ints:\n            candidate = max_idx + 1\n        ints.append(candidate)\n\n    if op == \"swap\":\n        if len(ints) >= 2:\n            i, j = random.sample(range(len(ints)), 2)\n            ints[i], ints[j] = ints[j], ints[i]\n        else:\n            # fallback: add a new index\n            ints.append(max_idx + 1)\n\n    if op == \"mutate\":\n        i = random.randrange(len(ints))\n        delta = random.choice([-2, -1, 1, 2])\n        newv = ints[i] + delta\n        if newv < 1:\n            newv = 1\n        # avoid creating a duplicate; if duplicate, append a new index instead\n        if newv in ints:\n            newv = max_idx + 1\n        ints[i] = newv\n\n    # Final normalization: remove duplicates while preserving first occurrences\n    seen = set()\n    out = []\n    for v in ints:\n        if v not in seen:\n            seen.add(v)\n            out.append(v)\n\n    # Ensure non-empty\n    if not out:\n        out = [1]\n\n    return \",\".join(str(int(x)) for x in out)\n"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard","Representacion":"Packed knapsack instance: 24 items (values,weights) and capacity=80. evaluate_solution accepts str\/list\/tuple\/int, treats indices as 1-based, disallows duplicates (0\/1 knapsack), returns total value for feasible solutions or large negative penalty for infeasible\/invalid inputs.","Evaluacion":{"REPRESENTATION":"Packed knapsack instance: 24 items (values,weights) and capacity=80. evaluate_solution accepts str\/list\/tuple\/int, treats indices as 1-based, disallows duplicates (0\/1 knapsack), returns total value for feasible solutions or large negative penalty for infeasible\/invalid inputs.","EVAL_CODE":"import re\n\ndef evaluate_solution(solution):\n    \"\"\"Evaluate a 0\/1 knapsack solution.\n    - Accepts: string (e.g. \"1,2,3\" or \"1 2 3\"), list\/tuple of ints\/strs, or single int.\n    - Indices are 1-based (1..24).\n    - Returns: float total value if weight <= capacity.\n    - If overweight: returns heavy negative penalty; invalid input or duplicates: heavier penalty.\n    \"\"\"\n    # embedded problem data (values, weights)\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n    PENALTY_INFEASIBLE = -1e6\n    PENALTY_INVALID = -1e9\n\n    try:\n        if solution is None:\n            return float(PENALTY_INVALID)\n\n        # normalize to list of integers (1-based indices)\n        idxs = []\n        if isinstance(solution, str):\n            s = solution.strip()\n            if s == \"\":\n                return 0.0\n            parts = re.findall(r'-?\\d+', s)\n            if not parts:\n                return float(PENALTY_INVALID)\n            idxs = [int(p) for p in parts]\n        elif isinstance(solution, int):\n            idxs = [int(solution)]\n        elif isinstance(solution, (list, tuple)):\n            for e in solution:\n                if isinstance(e, int):\n                    idxs.append(e)\n                elif isinstance(e, str):\n                    parts = re.findall(r'-?\\d+', e)\n                    if not parts:\n                        return float(PENALTY_INVALID)\n                    idxs.extend(int(p) for p in parts)\n                else:\n                    return float(PENALTY_INVALID)\n        else:\n            return float(PENALTY_INVALID)\n\n        # enforce 0\/1 knapsack (no duplicates)\n        if len(idxs) != len(set(idxs)):\n            return float(PENALTY_INVALID)\n\n        total_w = 0\n        total_v = 0\n        n = len(values)\n        for idx in idxs:\n            if not (1 <= idx <= n):\n                return float(PENALTY_INVALID)\n            i = idx - 1\n            total_w += weights[i]\n            total_v += values[i]\n\n        if total_w > capacity:\n            # heavy infeasible penalty; include overflow to break ties\n            return float(PENALTY_INFEASIBLE - (total_w - capacity))\n\n        return float(total_v)\n    except Exception:\n        return float(PENALTY_INVALID)\n"},"Vecindad":{"REPRESENTATION":"Solutions are sets of 1-based item indices encoded as a comma-separated string (e.g. '1,2,5') or as a list\/tuple of ints. generate_neighbour accepts string\/list\/tuple\/int and returns (neighbour_string,(NB_Type,Movement_Type)).","NB_CODE":"import random\nimport re\n\n# generate_neighbour: robust neighbour generator for the 24-item knapsack instance\n# Signature required by the system:\n# def generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Return (neighbour_solution_string, (NB_Type, Movement_Type)).\n\n    - Accepts solution as string (e.g. '1,2,5' or '1 2 5' or '[1,2]'), list\/tuple\/set of ints, or single int.\n    - Produces a canonical comma-separated sorted string of 1-based indices (\"\" for empty set).\n    - Embedded instance data (n=24, weights\/values\/capacity) are present for compatibility but not used by the neighbour generator itself.\n    \"\"\"\n\n    # Embedded problem data (internal, no globals):\n    n = 24\n    # values (second column in SAMPLE_SOL lines) and weights (third column)\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n\n    # Normalizer: coerce many input forms to a list of ints\n    def _normalize(sol):\n        if sol is None:\n            return []\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return []\n            # remove surrounding brackets\/parens\n            s = re.sub(r'^[\\[\\(\\{]+|[\\]\\)\\}]+$', '', s)\n            # unify separators to commas\n            s = re.sub(r'\\s+', ',', s)\n            parts = [p.strip() for p in s.split(',') if p.strip() != '']\n            out = []\n            for p in parts:\n                try:\n                    out.append(int(p))\n                except:\n                    # ignore non-integers robustly\n                    continue\n            return out\n        if isinstance(sol, (list, tuple, set)):\n            out = []\n            for x in sol:\n                try:\n                    out.append(int(x))\n                except:\n                    continue\n            return out\n        # try to coerce single value to int\n        try:\n            return [int(sol)]\n        except:\n            return []\n\n    current_list = _normalize(solution)\n    # enforce valid index range\n    current = set(i for i in current_list if 1 <= i <= n)\n    all_items = set(range(1, n + 1))\n    excluded = all_items - current\n\n    # Choose an operation with simple heuristics ensuring feasibility of chosen op\n    if len(current) == 0:\n        op = 'add'\n    elif len(excluded) == 0:\n        # all items included: must remove or swap\n        op = random.choice(['remove', 'swap'])\n    else:\n        # weighted stochastic choice favoring small perturbations\n        r = random.random()\n        if r < 0.45:\n            op = 'add'\n        elif r < 0.8:\n            op = 'remove'\n        elif r < 0.95:\n            op = 'swap'\n        else:\n            op = 'toggle'\n\n    neighbour = set(current)\n\n    if op == 'add':\n        # pick one excluded to add\n        pick = random.choice(list(excluded))\n        neighbour.add(pick)\n    elif op == 'remove':\n        # pick one included to remove\n        pick = random.choice(list(current))\n        neighbour.discard(pick)\n    elif op == 'swap':\n        # remove one included and add one excluded\n        remove_pick = random.choice(list(current))\n        add_pick = random.choice(list(excluded))\n        neighbour.discard(remove_pick)\n        neighbour.add(add_pick)\n    elif op == 'toggle':\n        # flip a random index (may add or remove)\n        idx = random.randint(1, n)\n        if idx in neighbour:\n            neighbour.discard(idx)\n        else:\n            neighbour.add(idx)\n    else:\n        # fallback: single-bit flip of a random index\n        idx = random.randint(1, n)\n        if idx in neighbour:\n            neighbour.discard(idx)\n        else:\n            neighbour.add(idx)\n\n    # produce canonical comma-separated sorted string\n    if len(neighbour) == 0:\n        neighbour_str = \"\"\n    else:\n        neighbour_str = \",\".join(str(i) for i in sorted(neighbour))\n\n    # Meta tuple: first element is a high-level neighbour family, second is specific movement\n    meta = (\"set_move\", op)\n    return neighbour_str, meta\n"},"Perturbacion":{"REPRESENTATION":"Canonical solution = sorted comma-separated item indices (e.g. \"1,3,5\"). Items indexed 1..24 with embedded (value,weight) from the instance; capacity = 80. Empty string denotes empty solution.","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    # Embedded problem data (values, weights) index 1..24; capacity C\n    values = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    weights = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    C = 80\n\n    # Robust parsing: accept str, list, tuple, set, int, None\n    cur = set()\n    if solution is None:\n        cur = set()\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s == '':\n            cur = set()\n        else:\n            toks = [t for t in s.replace(',', ' ').split() if t]\n            for t in toks:\n                try:\n                    i = int(t)\n                    if 1 <= i <= len(weights):\n                        cur.add(i)\n                except:\n                    continue\n    elif isinstance(solution, (list, tuple, set)):\n        for t in solution:\n            try:\n                i = int(t)\n                if 1 <= i <= len(weights):\n                    cur.add(i)\n            except:\n                continue\n    else:\n        try:\n            i = int(solution)\n            if 1 <= i <= len(weights):\n                cur = set([i])\n        except:\n            cur = set()\n\n    def total_weight(s):\n        return sum(weights[i-1] for i in s)\n\n    def total_value(s):\n        return sum(values[i-1] for i in s)\n\n    # If infeasible, remove lowest value\/weight-ratio items until feasible\n    w = total_weight(cur)\n    if w > C:\n        items = sorted(list(cur), key=lambda i: (values[i-1]\/weights[i-1], weights[i-1]))\n        idx = 0\n        while w > C and idx < len(items):\n            rm = items[idx]\n            if rm in cur:\n                cur.remove(rm)\n                w -= weights[rm-1]\n            idx += 1\n\n    not_in = [i for i in range(1, len(weights)+1) if i not in cur]\n    remaining = C - total_weight(cur)\n\n    # Choose a small random perturbation: add, remove, or swap\n    ops = ['add', 'remove', 'swap']\n    op = random.choice(ops)\n\n    if op == 'add' and not_in:\n        candidates = [i for i in not_in if weights[i-1] <= remaining]\n        if candidates:\n            cur.add(random.choice(candidates))\n        else:\n            # fallback: try a swap to potentially fit a better item\n            if cur and not_in:\n                rem = min(cur, key=lambda i: values[i-1]\/weights[i-1])\n                cur.remove(rem)\n                remaining = C - total_weight(cur)\n                candidates = [i for i in not_in if weights[i-1] <= remaining]\n                if candidates:\n                    cur.add(random.choice(candidates))\n    elif op == 'remove' and cur:\n        cur.remove(random.choice(list(cur)))\n    elif op == 'swap' and cur and not_in:\n        rem = random.choice(list(cur))\n        cur.remove(rem)\n        remaining = C - total_weight(cur)\n        candidates = [i for i in not_in if weights[i-1] <= remaining]\n        if candidates:\n            cur.add(random.choice(candidates))\n        else:\n            # if swap failed to add, try to re-add the removed item if it still fits\n            if weights[rem-1] <= C - total_weight(cur):\n                cur.add(rem)\n\n    # Return canonical sorted comma-separated string, empty string for none\n    if not cur:\n        return ''\n    return ','.join(str(i) for i in sorted(cur))"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_11_lemonade_stand_standard","Representacion":"Canonical representation: a comma-separated string of 1-based item indices (e.g. \"1,2,5\"). Empty string \"\" means select nothing. Single index allowed (e.g. \"24\"). Alternative accepted inputs: Python list\/tuple of ints or strings (e.g. [1,2,3]), or a single int. Returned fitness: float total value if feasible; -1e9 for invalid input (None, bad format, duplicates, out-of-range); -1e6 for overweight (total weight > capacity). Items: 24 items embedded, capacity=80.","Evaluacion":{"REPRESENTATION":"Canonical representation: a comma-separated string of 1-based item indices (e.g. \"1,2,5\"). Empty string \"\" means select nothing. Single index allowed (e.g. \"24\"). Alternative accepted inputs: Python list\/tuple of ints or strings (e.g. [1,2,3]), or a single int. Returned fitness: float total value if feasible; -1e9 for invalid input (None, bad format, duplicates, out-of-range); -1e6 for overweight (total weight > capacity). Items: 24 items embedded, capacity=80.","EVAL_CODE":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Evaluate a candidate solution for the embedded 24-item knapsack instance.\n    Signature required by the system: def evaluate_solution(solution):\n\n    Accepted solution formats:\n      - string of comma- or space-separated 1-based indices, e.g. \"1,2,5\"\n      - list\/tuple of ints\/strings, e.g. [1,2,5]\n      - single int or numeric string, e.g. 24 or \"24\"\n      - empty string or empty list -> returns 0.0\n\n    Returns:\n      float: total value for feasible solutions\n      -1e9: invalid input (None, bad tokens, duplicates, out-of-range indices)\n      -1e6: overweight (total weight > capacity)\n    \"\"\"\n    # Embedded problem data (weights and values for items 1..24)\n    weights = [22,22,4,5,6,14,15,12,3,10,7,3,23,21,7,19,20,22,6,19,14,24,24,1]\n    values  = [4,2,11,2,24,5,12,24,21,20,21,23,13,21,5,8,5,8,20,9,4,15,8,6]\n    capacity = 80\n\n    # Guard: explicit None -> invalid\n    if solution is None:\n        return -1e9\n\n    # Normalize input into a list of ints (1-based indices)\n    items = []\n    try:\n        if isinstance(solution, str):\n            s = solution.strip()\n            if s == \"\":\n                return 0.0\n            # accept comma or whitespace separators\n            tokens = [t for t in s.replace(',', ' ').split() if t != '']\n            for t in tokens:\n                items.append(int(t))\n        elif isinstance(solution, (list, tuple)):\n            if len(solution) == 0:\n                return 0.0\n            for t in solution:\n                items.append(int(t))\n        elif isinstance(solution, int):\n            items = [solution]\n        else:\n            # try to coerce other scalars\n            items = [int(solution)]\n    except Exception:\n        return -1e9\n\n    # Validate: no duplicates\n    if len(items) != len(set(items)):\n        return -1e9\n\n    # Validate: indices in range 1..24\n    if any((i < 1 or i > 24) for i in items):\n        return -1e9\n\n    # Compute weight and value\n    total_w = 0\n    total_v = 0\n    for i in items:\n        idx = i - 1\n        total_w += weights[idx]\n        total_v += values[idx]\n\n    # Overweight penalty\n    if total_w > capacity:\n        return -1e6\n\n    return float(total_v)\n"},"Vecindad":{"REPRESENTATION":"Solutions are comma-separated item indices (ascending), e.g. \"1,3,5\". Empty string \"\" means no items. generate_neighbour returns a tuple (neighbour_string, (NB_Type, Movement_Type)). NB_Type examples: 'single_flip', 'swap', 'repair'. Movement_Type examples: 'add','remove','swap','replace'.","NB_CODE":"import random\n\n# generate_neighbour must be self-contained: embed instance data and capacity inside the function\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"Generate a neighbor for the 24-item knapsack instance.\n\n    Input accepted forms:\n    - comma-separated string of indices, e.g. \"1,3,5\"\n    - list\/tuple of ints\n    - empty string or [] -> empty solution\n\n    Returns: (neighbour_string, (NB_Type, Movement_Type))\n    neighbour_string: canonical comma-separated sorted indices, or \"\" for empty solution\n    \"\"\"\n    # Instance data (from sample): index: (value, weight)\n    items = {\n        1: (22, 4), 2: (22, 2), 3: (4, 11), 4: (5, 2), 5: (6, 24), 6: (14, 5),\n        7: (15, 12), 8: (12, 24), 9: (3, 21), 10: (10, 20), 11: (7, 21), 12: (3, 23),\n        13: (23, 13), 14: (21, 21), 15: (7, 5), 16: (19, 8), 17: (20, 5), 18: (22, 8),\n        19: (6, 20), 20: (19, 9), 21: (14, 4), 22: (24, 15), 23: (24, 8), 24: (1, 6)\n    }\n    CAPACITY = 80\n    N = 24\n\n    # helpers\n    def canonical(solset):\n        if not solset:\n            return \"\"\n        arr = sorted(solset)\n        return \",\".join(str(int(x)) for x in arr)\n\n    def parse_input(sol):\n        # normalize to set of ints\n        if sol is None:\n            return None\n        if isinstance(sol, str):\n            s = sol.strip()\n            if s == \"\":\n                return set()\n            try:\n                parts = [p.strip() for p in s.split(\",\") if p.strip() != \"\"]\n                vals = [int(p) for p in parts]\n            except Exception:\n                return None\n        elif isinstance(sol, (list, tuple, set)):\n            try:\n                vals = [int(x) for x in sol]\n            except Exception:\n                return None\n        else:\n            return None\n        if len(vals) != len(set(vals)):\n            return None\n        for v in vals:\n            if not (1 <= v <= N):\n                return None\n        return set(vals)\n\n    def total_weight(solset):\n        return sum(items[i][1] for i in solset)\n\n    def total_value(solset):\n        return sum(items[i][0] for i in solset)\n\n    cur = parse_input(solution)\n    if cur is None:\n        return (\"\", (\"invalid\", \"input\"))\n\n    cur_w = total_weight(cur)\n\n    # Try single flip first (add or remove)\n    trials = 40\n    for _ in range(trials):\n        i = random.randint(1, N)\n        if i in cur:\n            # try removing\n            new = set(cur)\n            new.remove(i)\n            return (canonical(new), (\"single_flip\", \"remove\"))\n        else:\n            # try adding if capacity allows\n            w = items[i][1]\n            if cur_w + w <= CAPACITY:\n                new = set(cur)\n                new.add(i)\n                return (canonical(new), (\"single_flip\", \"add\"))\n    # If single flip failed to add (e.g., overweight), attempt a swap: remove one included, add one excluded\n    included = list(cur)\n    excluded = [i for i in range(1, N + 1) if i not in cur]\n    random.shuffle(included)\n    random.shuffle(excluded)\n    for a in included:\n        for b in excluded:\n            new_w = cur_w - items[a][1] + items[b][1]\n            if new_w <= CAPACITY:\n                new = set(cur)\n                new.remove(a)\n                new.add(b)\n                return (canonical(new), (\"swap\", \"swap\"))\n    # Repair heuristic: if overweight, remove lowest value\/weight ratio items until feasible\n    if cur_w > CAPACITY:\n        ratio_list = sorted(((i, items[i][0] \/ float(items[i][1])) for i in cur), key=lambda x: x[1])\n        new = set(cur)\n        cw = cur_w\n        removed = []\n        for i, _r in ratio_list:\n            new.remove(i)\n            cw -= items[i][1]\n            removed.append(i)\n            if cw <= CAPACITY:\n                return (canonical(new), (\"repair\", \"remove_repair\"))\n        # if still infeasible (shouldn't happen), return empty\n        return (\"\", (\"repair\", \"failed\"))\n\n    # Fallback: deterministic small perturbation - remove smallest-value included and try add best excluded\n    if cur:\n        smallest = min(cur, key=lambda x: items[x][0])\n        new = set(cur)\n        new.remove(smallest)\n        cur_w = total_weight(new)\n        # try add best value excluded that fits\n        candidates = [i for i in range(1, N + 1) if i not in new and cur_w + items[i][1] <= CAPACITY]\n        if candidates:\n            best = max(candidates, key=lambda x: items[x][0])\n            new.add(best)\n            return (canonical(new), (\"repair\", \"replace\"))\n        return (canonical(new), (\"single_flip\", \"remove\"))\n\n    # If current is empty and no add found (unlikely), return empty\n    return (\"\", (\"no_op\", \"none\"))\n"},"Perturbacion":{"REPRESENTATION":"Canonical comma-separated sorted string of selected item indices in 1..24 (e.g. \"1,3,5\"). Empty string means no items. Feasible solutions must respect capacity=80.","PERTURB_CODE":"import random\n\ndef perturb_solution(solution):\n    \"\"\"\n    Accepts a solution as a comma-separated string like \"1,3,5\" or a list\/tuple\/set of ints.\n    Returns a canonical comma-separated sorted string of item indices (\"\" for empty).\n    Dataset (embedded): 24 items as (weight, value). Capacity = 80.\n    \"\"\"\n    # dataset embedded locally (index 1..24)\n    items = {\n        1: (22,4), 2: (22,2), 3: (4,11), 4: (5,2), 5: (6,24), 6: (14,5),\n        7: (15,12), 8: (12,24), 9: (3,21), 10: (10,20), 11: (7,21), 12: (3,23),\n        13: (23,13), 14: (21,21), 15: (7,5), 16: (19,8), 17: (20,5), 18: (22,8),\n        19: (6,20), 20: (19,9), 21: (14,4), 22: (24,15), 23: (24,8), 24: (1,6)\n    }\n    capacity = 80\n\n    # parse input into set of ints\n    if solution is None:\n        cur = set()\n    elif isinstance(solution, str):\n        s = solution.strip()\n        if s == \"\":\n            cur = set()\n        else:\n            try:\n                cur = set(int(x) for x in s.split(\",\") if x.strip() != \"\")\n            except:\n                cur = set()\n    elif isinstance(solution, (list, tuple, set)):\n        try:\n            cur = set(int(x) for x in solution)\n        except:\n            cur = set()\n    else:\n        cur = set()\n\n    # normalize: remove out-of-range and duplicates\n    cur = set(i for i in cur if 1 <= i <= 24)\n\n    # evaluation helper\n    def score(solset):\n        w = sum(items[i][0] for i in solset)\n        v = sum(items[i][1] for i in solset)\n        if w > capacity:\n            return -1e6\n        return v\n\n    # repair function: remove low-value-density items until feasible\n    def repair(solset):\n        while True:\n            w = sum(items[i][0] for i in solset)\n            if w <= capacity:\n                return solset\n            densities = [(items[i][1]\/items[i][0], i) for i in solset]\n            densities.sort()\n            _, rem = densities[0]\n            solset.remove(rem)\n            if not solset:\n                return solset\n\n    # choose perturbation\n    universe = set(items.keys())\n    ops = [\"add\",\"remove\",\"swap\",\"replace\",\"random_restart\"]\n    op = random.choices(ops, weights=[30,20,25,20,5], k=1)[0]\n\n    new = set(cur)\n    candidates = list(universe - new)\n    present = list(new)\n    if op == \"add\" and candidates:\n        new.add(random.choice(candidates))\n    elif op == \"remove\" and present:\n        new.remove(random.choice(present))\n    elif op == \"swap\" and present and candidates:\n        new.remove(random.choice(present))\n        new.add(random.choice(candidates))\n    elif op == \"replace\" and present and candidates:\n        present_sorted = sorted(present, key=lambda i: items[i][1]\/items[i][0])\n        absent_sorted = sorted(candidates, key=lambda i: -items[i][1]\/items[i][0])\n        for p in present_sorted:\n            for a in absent_sorted:\n                trial = set(new)\n                trial.remove(p)\n                trial.add(a)\n                if sum(items[i][0] for i in trial) <= capacity:\n                    new = trial\n                    break\n            else:\n                continue\n            break\n        if new == set(cur) and present and candidates:\n            new.remove(random.choice(present))\n            new.add(random.choice(candidates))\n    else:\n        # random restart: greedy by density\n        new = set()\n        pool = sorted(universe, key=lambda i: -items[i][1]\/items[i][0])\n        curw = 0\n        for i in pool:\n            if curw + items[i][0] <= capacity:\n                new.add(i)\n                curw += items[i][0]\n\n    # repair if overweight\n    if sum(items[i][0] for i in new) > capacity:\n        new = repair(new)\n\n    # produce canonical sorted comma-separated string\n    result_list = sorted(new)\n    if not result_list:\n        return \"\"\n    return \",\".join(str(int(x)) for x in result_list)\n"},"SolucionPrueba":"24\n\n1 22 4\n2 22 2\n3 4 11\n4 5 2\n5 6 24\n6 14 5\n7 15 12\n8 12 24\n9 3 21\n10 10 20\n11 7 21\n12 3 23\n13 23 13\n14 21 21\n15 7 5\n16 19 8\n17 20 5\n18 22 8\n19 6 20\n20 19 9\n21 14 4\n22 24 15\n23 24 8\n24 1 6\n\n80\n","Version":2}
