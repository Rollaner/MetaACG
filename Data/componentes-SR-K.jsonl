{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: list of strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as tiny epsilon: smaller INDEX_LIST preferred\n    # Create deterministic lex rank: base-25 positional weight\n    lex_hash = 0\n    base = 25\n    n = len(solution)\n    for pos, idx in enumerate(solution):\n        power = n - pos\n        lex_hash += idx * (base ** power)\n    # Lower cost is better; maximize total_value => minimize -total_value\n    # Add tiny epsilon to prefer lexicographically smaller solutions when values equal\n    return (-float(total_value)) + (1e-6 * float(lex_hash))\n","Vecindad":"import math, random, typing as t\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    # Helpers\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    # Normalize\/repair input\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        # Reset to empty feasible solution deterministically\n        return [], (\"repaired\", \"reset\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - tw\n\n    # 1) Try ADD: choose best ratio item that fits (tie: lighter, then smaller index)\n    add_candidates = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_candidates:\n        add_candidates.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_candidates[0][0]\n        new_sol = canonical(cur + [pick])\n        return new_sol, (\"feasible\", \"add\")\n\n    # 2) Try SWAP for an improving move: best delta value subject to feasibility\n    best_swap = None  # (delta_v, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                if delta_v > 0:\n                    # Prefer highest delta_v, then lexicographically smaller resulting list\n                    cand = canonical([x for x in cur if x != i_in] + [i_out])\n                    # Lex key is the tuple itself\n                    key = tuple(cand)\n                    if best_swap is None:\n                        best_swap = (delta_v, key, i_out, i_in)\n                    else:\n                        if delta_v > best_swap[0] or (delta_v == best_swap[0] and key < best_swap[1]):\n                            best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 3) If no improving swap, try best feasible non-worsening\/worst-minimizing swap\n    best_swap2 = None  # (delta_v, key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]\n        vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]\n            vo = v[i_out-1]\n            new_w = tw - wi + wo\n            if new_w <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap2 is None:\n                    best_swap2 = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap2[0]) or (delta_v == best_swap2[0] and key < best_swap2[1]):\n                        best_swap2 = (delta_v, key, i_out, i_in)\n    if best_swap2 is not None:\n        _, _, i_out, i_in = best_swap2\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        return new_sol, (\"feasible\", \"swap\")\n\n    # 4) Fallback: DROP worst ratio item (tie: largest index)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio, then smaller index\n        # To prefer lexicographically smaller list, drop the item with lowest ratio; if multiple, drop the largest index among those minimal ratios\n        min_ratio = ratios[0][1]\n        worst_items = [i for i, r in ratios if r == min_ratio]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and cannot add (shouldn't happen), return same\n    return cur, (\"feasible\", \"none\")\n","Perturbacion":"import math, random, typing as t\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    # Start from repaired canonical solution\n    cur = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation\n    k = random.randint(3, 6)\n\n    # Drop up to k items with lowest value\/weight (ties: larger index first)\n    if cur:\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        # Prefer dropping larger indices among equal ratios\n        for i in sorted(to_drop, reverse=True):\n            if i in cur:\n                cur.remove(i)\n\n    # Then greedily add up to k best ratio items that fit\n    remaining = [i for i in range(1, 25) if i not in cur]\n    residual = capacity - total_weight(cur)\n    add_cands = [(i, v[i-1]\/w[i-1], w[i-1]) for i in remaining]\n    add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n    added = 0\n    for i, _, wi in add_cands:\n        if added >= k:\n            break\n        if wi <= residual:\n            cur.append(i)\n            cur = canonical(cur)\n            residual -= wi\n            added += 1\n\n    # Final feasibility guard (trim heaviest items if overweight; should not trigger)\n    while valid(cur) is False and cur:\n        # remove worst ratio then largest index\n        ratios = [(i, v[i-1]\/w[i-1]) for i in cur]\n        ratios.sort(key=lambda x: (x[1], x[0]))\n        drop_i = max([i for i, r in ratios if r == ratios[0][1]])\n        cur.remove(drop_i)\n        cur = canonical(cur)\n\n    return canonical(cur)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    # eps term strictly < 1e-9 and never dominates the -value component\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    # Try 2-1: replace two current items by one remaining\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    # Try 1-2: replace one current item by two remaining\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add (should not occur), rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        tw = 0\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard (rare)\n    while not valid(cur) and cur:\n        # remove currently worst ratio then largest index\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst)\n        cur.remove(drop_i)\n        cur = canonical(cur)\n        cur = greedy_refill(cur)\n\n    return canonical(cur)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_standard","Representacion":"INDEX_LIST","Evaluacion":"import math, random, typing as t\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST: strictly increasing unique 1-based ints within [1,24]\n    if not isinstance(solution, list):\n        return float('inf')\n    if not all(isinstance(i, int) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > 24 for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    for a, b in zip(solution, solution[1:]):\n        if not (a < b):\n            return float('inf')\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n    # Feasibility and objective\n    total_weight = 0\n    total_value = 0\n    for idx in solution:\n        wi = w[idx - 1]\n        total_weight += wi\n        if total_weight > capacity:\n            return float('inf')\n        total_value += v[idx - 1]\n    # Lexicographic tie-break encoded as bounded epsilon\n    eps = 1e-9\n    base = 32.0\n    lex_term = 0.0\n    for pos, idx in enumerate(solution):\n        lex_term += idx \/ (base ** (pos + 1))\n    # Minimize cost; maximize value via negative value\n    return (-float(total_value)) + eps * lex_term\n","Vecindad":"import math, random, typing as t\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def total_value(lst: t.List[int]) -> int:\n        return sum(v[i-1] for i in lst)\n\n    def greedy_fill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Normalize\/repair input -> feasible greedy base if invalid\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = greedy_fill([])\n        return cur, (\"repaired\", \"rebuild\")\n\n    tw = total_weight(cur)\n    tv = total_value(cur)\n    residual = capacity - tw\n\n    # Move 0: randomized ADD best-ratio item that fits, then greedy fill (no-op if full)\n    remaining = [i for i in range(1, 25) if i not in cur]\n    add_cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining if w[i-1] <= residual]\n    if add_cands:\n        random.shuffle(add_cands)\n        add_cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        pick = add_cands[0][0]\n        new_sol = canonical(cur + [pick])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"add\")\n\n    # Precompute for swaps\n    cur_set = set(cur)\n\n    # Move 1: 1-1 swap (best improving; randomized tie-breaking)\n    best_swap = None  # (delta_v, lex_key, i_out, i_in)\n    for i_in in cur:\n        wi = w[i_in-1]; vi = v[i_in-1]\n        for i_out in remaining:\n            wo = w[i_out-1]; vo = v[i_out-1]\n            if tw - wi + wo <= capacity:\n                delta_v = vo - vi\n                cand = canonical([x for x in cur if x != i_in] + [i_out])\n                key = tuple(cand)\n                if best_swap is None:\n                    best_swap = (delta_v, key, i_out, i_in)\n                else:\n                    if (delta_v > best_swap[0]) or (delta_v == best_swap[0] and key < best_swap[1]):\n                        best_swap = (delta_v, key, i_out, i_in)\n    if best_swap is not None and best_swap[0] >= 0:\n        _, _, i_out, i_in = best_swap\n        new_sol = canonical([x for x in cur if x != i_in] + [i_out])\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swap1-1\")\n\n    # Move 2: 1-2 or 2-1 exchange with bounded search\n    best_k = None  # (delta_v, key, add, rem_list)\n    if len(cur) >= 2:\n        pairs = list()\n        idxs = cur[:]\n        for a in range(len(idxs)):\n            for b in range(a+1, len(idxs)):\n                pairs.append((idxs[a], idxs[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for r1, r2 in pairs:\n            wr = w[r1-1] + w[r2-1]\n            vr = v[r1-1] + v[r2-1]\n            for add in remaining:\n                wa = w[add-1]; va = v[add-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x not in (r1, r2)] + [add])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add], [r1, r2])\n    rem_list = remaining[:]\n    if len(remaining) >= 2:\n        pairs = []\n        for a in range(len(rem_list)):\n            for b in range(a+1, len(rem_list)):\n                pairs.append((rem_list[a], rem_list[b]))\n        random.shuffle(pairs)\n        pairs = pairs[:20]\n        for add1, add2 in pairs:\n            wa = w[add1-1] + w[add2-1]\n            va = v[add1-1] + v[add2-1]\n            for rem in cur:\n                wr = w[rem-1]; vr = v[rem-1]\n                new_w = tw - wr + wa\n                if new_w <= capacity:\n                    delta_v = va - vr\n                    cand = canonical([x for x in cur if x != rem] + [add1, add2])\n                    key = tuple(cand)\n                    if (best_k is None) or (delta_v > best_k[0]) or (delta_v == best_k[0] and key < best_k[1]):\n                        best_k = (delta_v, key, [add1, add2], [rem])\n    if best_k is not None and best_k[0] >= 0:\n        _, _, adds, rems = best_k\n        new_sol = canonical([x for x in cur if x not in rems] + adds)\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"swapk\")\n\n    # Move 3: DROP worst ratio item (tie: larger index), then greedy fill\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        min_ratio = min(r for _, r in ratios)\n        worst_items = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n        drop_i = max(worst_items)\n        new_sol = [x for x in cur if x != drop_i]\n        new_sol = greedy_fill(new_sol)\n        return new_sol, (\"feasible\", \"drop\")\n\n    # If empty and nothing to add, rebuild\n    rebuilt = greedy_fill([])\n    return rebuilt, (\"repaired\", \"rebuild\")\n","Perturbacion":"import math, random, typing as t\n\n\ndef perturb_solution(solution):\n    # Embedded data\n    w = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    v = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    capacity = 304\n\n    def canonical(lst: t.List[int]) -> t.List[int]:\n        return sorted(lst)\n\n    def valid(lst: t.List[int]) -> bool:\n        if not isinstance(lst, list):\n            return False\n        if not all(isinstance(i, int) for i in lst):\n            return False\n        if any(i < 1 or i > 24 for i in lst):\n            return False\n        if len(lst) != len(set(lst)):\n            return False\n        for a, b in zip(lst, lst[1:]):\n            if not (a < b):\n                return False\n        tw = 0\n        for i in lst:\n            tw += w[i-1]\n            if tw > capacity:\n                return False\n        return True\n\n    def total_weight(lst: t.List[int]) -> int:\n        return sum(w[i-1] for i in lst)\n\n    def greedy_refill(cur: t.List[int]) -> t.List[int]:\n        cur = canonical(cur)\n        residual = capacity - total_weight(cur)\n        remaining = [i for i in range(1, 25) if i not in cur]\n        cands = [(i, v[i-1] \/ w[i-1], w[i-1]) for i in remaining]\n        random.shuffle(cands)\n        cands.sort(key=lambda x: (-x[1], x[2], x[0]))\n        for i, _, wi in cands:\n            if wi <= residual:\n                cur.append(i)\n                cur = canonical(cur)\n                residual -= wi\n        return cur\n\n    # Start from repaired canonical solution\n    cur: t.List[int] = []\n    if isinstance(solution, list):\n        cur = [int(i) for i in solution if isinstance(i, int) and 1 <= int(i) <= 24]\n        cur = canonical(list(sorted(set(cur))))\n    if not valid(cur):\n        cur = []\n\n    # Adaptive-strength perturbation: drop k items (2..5) biased to worst ratios\n    k = random.randint(2, 5)\n    if cur:\n        ratios = [(i, v[i-1] \/ w[i-1]) for i in cur]\n        random.shuffle(ratios)\n        ratios.sort(key=lambda x: (x[1], x[0]))  # ascending ratio then index\n        to_drop = [i for i, _ in ratios[:min(k, len(ratios))]]\n        for i in to_drop:\n            if i in cur:\n                cur.remove(i)\n        cur = canonical(cur)\n\n    # Greedy refill\n    cur = greedy_refill(cur)\n\n    # Final feasibility guard\n    def ensure_feasible(cur_list: t.List[int]) -> t.List[int]:\n        while not valid(cur_list) and cur_list:\n            ratios = [(i, v[i-1] \/ w[i-1]) for i in cur_list]\n            min_ratio = min(r for _, r in ratios)\n            worst = [i for i, r in ratios if abs(r - min_ratio) < 1e-12]\n            drop_i = max(worst)\n            cur_list.remove(drop_i)\n            cur_list = canonical(cur_list)\n            cur_list = greedy_refill(cur_list)\n        return canonical(cur_list)\n\n    return ensure_feasible(cur)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> large positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n    # Type\/domain checks\n    if not isinstance(solution, list):\n        return 10**12\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**12\n        if x < 1 or x > n:\n            return 10**12\n        if x in seen:\n            return 10**12\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n    if total_cost > B:\n        # Penalize proportional to violation\n        return 10**9 + (total_cost - B)\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type). May be infeasible; evaluation handles feasibility.\n    # Includes add, drop, swap (1-1), 2-1 and 1-2 exchanges. Optionally repairs feasibility with probability p_repair.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique(solution)\n\n    sol_set = set(current)\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    # Determine feasible move types given current composition\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    move = random.choice(feasible_moves)\n    neighbor = current[:]\n\n    if move == \"add\":\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        if candidates:\n            neighbor.append(random.choice(candidates))\n\n    elif move == \"drop\":\n        if neighbor:\n            idx = random.randrange(len(neighbor))\n            neighbor.pop(idx)\n\n    elif move == \"swap\":\n        if neighbor and len(sol_set) < n:\n            out_idx = random.randrange(len(neighbor))\n            out_item = neighbor[out_idx]\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            if candidates:\n                in_item = random.choice(candidates)\n                neighbor[out_idx] = in_item\n\n    elif move == \"2-1\":\n        # drop two, add one not in solution\n        if len(neighbor) >= 2 and len(sol_set) < n:\n            outs = random.sample(neighbor, 2)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n            if cand_in:\n                in_item = random.choice(cand_in)\n                neighbor = [x for x in neighbor if x not in outs]\n                neighbor.append(in_item)\n\n    else:  # \"1-2\"\n        # drop one, add two not in solution\n        if len(neighbor) >= 1 and (n - len(sol_set)) >= 2:\n            out_item = random.choice(neighbor)\n            cand_in = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n            if len(cand_in) >= 2:\n                ins = random.sample(cand_in, 2)\n                neighbor = [x for x in neighbor if x != out_item]\n                neighbor.extend(ins)\n\n    neighbor = normalize_unique(neighbor)\n\n    # Capacity-aware repair with probability p_repair\n    p_repair = 0.7\n    if random.random() < p_repair:\n        while total_cost(neighbor) > B and neighbor:\n            # Drop worst density item to regain feasibility\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n\n    return neighbor, move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Apply k random moves to diversify. Uses add\/drop\/swap\/2-1\/1-2 with feasibility repair at the end.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        out.sort()\n        return out\n\n    def total_cost(lst):\n        return sum(costs[i] for i in lst)\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        sol_set = set(sol)\n        moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n        feasible_moves = []\n        if len(sol) < n:\n            feasible_moves.append(\"add\")\n        if len(sol) > 0:\n            feasible_moves.append(\"drop\")\n        if 0 < len(sol) < n:\n            feasible_moves.append(\"swap\")\n        if len(sol) >= 2 and len(sol) < n:\n            feasible_moves.append(\"2-1\")\n        if len(sol) >= 1 and (n - len(sol)) >= 2:\n            feasible_moves.append(\"1-2\")\n        if not feasible_moves:\n            feasible_moves = moves\n        move = random.choice(feasible_moves)\n\n        if move == \"add\":\n            cand = [i for i in range(1, n + 1) if i not in sol_set]\n            if cand:\n                sol.append(random.choice(cand))\n        elif move == \"drop\":\n            if sol:\n                sol.pop(random.randrange(len(sol)))\n        elif move == \"swap\":\n            if sol and len(sol) < n:\n                out_idx = random.randrange(len(sol))\n                out_item = sol[out_idx]\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if cand:\n                    sol[out_idx] = random.choice(cand)\n        elif move == \"2-1\":\n            if len(sol) >= 2 and len(sol) < n:\n                outs = random.sample(sol, 2)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i not in outs]\n                if cand:\n                    sol = [x for x in sol if x not in outs]\n                    sol.append(random.choice(cand))\n        else:  # \"1-2\"\n            if len(sol) >= 1 and (n - len(sol)) >= 2:\n                out_item = random.choice(sol)\n                cand = [i for i in range(1, n + 1) if i not in sol_set and i != out_item]\n                if len(cand) >= 2:\n                    ins = random.sample(cand, 2)\n                    sol = [x for x in sol if x != out_item]\n                    sol.extend(ins)\n\n        sol = normalize_unique(sol)\n\n    # Final feasibility repair by dropping worst densities\n    while total_cost(sol) > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        # Scaled penalty to keep gradient informative yet dominant over objective scale\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    # Feasible: return negative value (since lower is better)\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Preserves order; deduplicates only.\n    # Returns (neighbor_solution, movement_type). Ensures deterministic feasibility repair and greedy refill.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    # Bias weights by heuristic expectation (add\/swap generally stronger)\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        # Choose best density item that fits slack; fallback to random if none fits (will be repaired)\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            # Drop worst density item\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            # Remove worst density, insert best density not in solution (prefer fitting slack + freed cost)\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            # Drop two worst densities, add best outsider that fits\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            # Drop worst, add two best that fit greedily\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    # Normalize after move\n    neighbor = normalize_unique_order(neighbor)\n\n    # Deterministic repair + greedy refill; track movement drift\n    movement_type = move\n\n    # Make feasible by dropping worst densities while updating cumulative cost\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        # Efficiently drop worst-density items until feasible\n        # Use simple loop with recomputation due to small n\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    # Greedy refill to utilize slack\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then greedy epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items (if available)\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed (rare after drops)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Greedy epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        # With probability epsilon, sample a random candidate from the top-m window to diversify\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    # Final normalization (order preserved) and ensure feasibility (should already hold)\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Cost-style fitness: lower is better. Feasible -> negative total value; Infeasible -> positive penalty.\n    # Expects: list of unique integers in [1,24].\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n = 24\n\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return 10**9\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n        total_cost += costs[x]\n        total_value += values[x]\n\n    if total_cost > B:\n        violation = total_cost - B\n        return 10**6 + 1000 * violation\n\n    return -total_value\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Density- and capacity-aware neighbor generator. Returns (neighbor_solution, movement_type)\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    # Input normalization\n    if not isinstance(solution, list):\n        current = []\n    else:\n        current = normalize_unique_order(solution)\n\n    # Candidate move selection with simple adaptive bias\n    moves = [\"add\", \"drop\", \"swap\", \"2-1\", \"1-2\"]\n    feasible_moves = []\n    if len(current) < n:\n        feasible_moves.append(\"add\")\n    if len(current) > 0:\n        feasible_moves.append(\"drop\")\n    if 0 < len(current) < n:\n        feasible_moves.append(\"swap\")\n    if len(current) >= 2 and len(current) < n:\n        feasible_moves.append(\"2-1\")\n    if len(current) >= 1 and (n - len(current)) >= 2:\n        feasible_moves.append(\"1-2\")\n    if not feasible_moves:\n        feasible_moves = moves\n\n    base_weights = {\"add\": 3.0, \"swap\": 2.5, \"drop\": 1.0, \"2-1\": 1.5, \"1-2\": 1.5}\n    move_weights = [base_weights[m] for m in feasible_moves]\n    totw = sum(move_weights)\n    r = random.random() * totw\n    acc = 0.0\n    move = feasible_moves[-1]\n    for m, w in zip(feasible_moves, move_weights):\n        acc += w\n        if r <= acc:\n            move = m\n            break\n\n    neighbor = list(current)\n\n    # Helper to compute remaining capacity\n    cur_cost = total_cost_of(neighbor)\n    slack = B - cur_cost\n\n    # Execute move with density guidance\n    if move == \"add\":\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        chosen = None\n        for i in candidates:\n            if costs[i] <= slack:\n                chosen = i\n                break\n        if chosen is None and candidates:\n            chosen = candidates[0]\n        if chosen is not None:\n            neighbor.append(chosen)\n\n    elif move == \"drop\":\n        if neighbor:\n            worst = min(neighbor, key=density)\n            neighbor = [x for x in neighbor if x != worst]\n\n    elif move == \"swap\":\n        if neighbor and len(neighbor) < n:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            if chosen is None and candidates:\n                chosen = candidates[0]\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    elif move == \"2-1\":\n        if len(neighbor) >= 2:\n            worst_two = sorted(neighbor, key=density)[:2]\n            neighbor_tmp = [x for x in neighbor if x not in set(worst_two)]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            chosen = None\n            for i in candidates:\n                if costs[i] <= budget:\n                    chosen = i\n                    break\n            neighbor = neighbor_tmp\n            if chosen is not None:\n                neighbor.append(chosen)\n\n    else:  # \"1-2\"\n        if len(neighbor) >= 1 and (n - len(neighbor)) >= 2:\n            worst = min(neighbor, key=density)\n            neighbor_tmp = [x for x in neighbor if x != worst]\n            sol_set = set(neighbor_tmp)\n            budget = B - total_cost_of(neighbor_tmp)\n            candidates = [i for i in range(1, n + 1) if i not in sol_set]\n            candidates.sort(key=lambda i: density(i), reverse=True)\n            added = 0\n            for i in candidates:\n                if costs[i] <= budget:\n                    neighbor_tmp.append(i)\n                    budget -= costs[i]\n                    added += 1\n                    if added == 2:\n                        break\n            neighbor = neighbor_tmp\n\n    neighbor = normalize_unique_order(neighbor)\n\n    movement_type = move\n\n    cur_cost = total_cost_of(neighbor)\n    if cur_cost > B:\n        movement_type = move + \"+repair_drop\"\n        while cur_cost > B and neighbor:\n            worst = min(neighbor, key=density)\n            neighbor.remove(worst)\n            cur_cost -= costs[worst]\n\n    slack = B - cur_cost\n    if slack > 0:\n        sol_set = set(neighbor)\n        candidates = [i for i in range(1, n + 1) if i not in sol_set]\n        candidates.sort(key=lambda i: density(i), reverse=True)\n        added_any = False\n        for i in candidates:\n            if costs[i] <= slack:\n                neighbor.append(i)\n                slack -= costs[i]\n                added_any = True\n        if added_any and movement_type == move:\n            movement_type = move + \"+refill\"\n        elif added_any and movement_type.endswith(\"repair_drop\"):\n            movement_type = movement_type + \"+refill\"\n\n    return neighbor, movement_type\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Adaptive k-shake: drop t lowest-density items, then epsilon-greedy refill by density within capacity.\n    n = 24\n    B = 3040\n    costs = [None,110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    values = [None,19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def normalize_unique_order(lst):\n        seen = set()\n        out = []\n        for x in lst:\n            if isinstance(x, int) and 1 <= x <= n and x not in seen:\n                seen.add(x)\n                out.append(x)\n        return out\n\n    def density(i):\n        return values[i] \/ costs[i]\n\n    def total_cost_of(lst):\n        return sum(costs[i] for i in lst)\n\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        sol = normalize_unique_order(solution)\n\n    # Determine t based on current size\n    t = max(1, min(3, int(len(sol) * 0.1)))\n\n    # Drop t worst-density items\n    if sol:\n        worst_sorted = sorted(sol, key=density)[:t]\n        sol = [x for x in sol if x not in set(worst_sorted)]\n\n    # Repair if needed\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    # Epsilon-greedy refill by density\n    epsilon = 0.15\n    slack = B - cur_cost\n    sol_set = set(sol)\n    candidates = [i for i in range(1, n + 1) if i not in sol_set]\n    candidates.sort(key=lambda i: density(i), reverse=True)\n\n    idx = 0\n    while idx < len(candidates):\n        m = max(1, min(5, len(candidates)))\n        pick_idx = idx\n        if random.random() < epsilon:\n            pick_idx = random.randrange(0, m)\n        cand = candidates[pick_idx]\n        if costs[cand] <= slack:\n            sol.append(cand)\n            slack -= costs[cand]\n        idx += 1\n\n    sol = normalize_unique_order(sol)\n    cur_cost = total_cost_of(sol)\n    while cur_cost > B and sol:\n        worst = min(sol, key=density)\n        sol.remove(worst)\n        cur_cost -= costs[worst]\n\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Returns a numeric cost (lower is better). Feasible: -revenue. Infeasible: large penalty.\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, \"INDEX_LIST\", movement_type)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Uniquify, bound-check, then drop lowest density until feasible\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        # stochastic tie-breaking among equal density to reduce bias\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur_set = set(cur)\n    cur = sorted(cur_set)\n\n    move_type = \"None\"\n\n    # Define candidate operations with probabilities\n    op = random.random()\n    nbr = cur[:]\n\n    # Precompute not-in list efficiently\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n\n    if op < 0.2 and cur:\n        # Remove 1\n        r = random.choice(cur)\n        nbr = [x for x in cur if x != r]\n        move_type = \"Remove1\"\n    elif op < 0.4:\n        # Add 1 (if full, fallback to remove)\n        if not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n    elif op < 0.6 and cur and not_in:\n        # Swap 1-1\n        r = random.choice(cur)\n        a = random.choice(not_in)\n        nbr = [x for x in cur if x != r] + [a]\n        move_type = \"Swap1\"\n    elif op < 0.8:\n        # Add2-Remove1 or Remove2-Add1 depending on feasibility\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            nbr_try = cur + adds\n            if total_weight(nbr_try) <= capacity or len(cur) >= 1:\n                if total_weight(nbr_try) <= capacity:\n                    nbr = nbr_try\n                    move_type = \"Add2\"\n                else:\n                    r = random.choice(cur) if cur else None\n                    if r is not None:\n                        nbr = [x for x in cur if x != r] + adds\n                        move_type = \"Add2Remove1\"\n                    else:\n                        nbr = cur[:]\n                        move_type = \"None\"\n            else:\n                nbr = cur[:]\n                move_type = \"None\"\n        elif len(cur) >= 2:\n            rs = random.sample(cur, 2)\n            nbr = [x for x in cur if x not in rs]\n            move_type = \"Remove2\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n    else:\n        # Swap2 (2-2 exchange) if possible, else fallback to single swap\/add\/remove\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rs = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rs] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            r = random.choice(cur)\n            a = random.choice(not_in)\n            nbr = [x for x in cur if x != r] + [a]\n            move_type = \"Swap1\"\n        elif not_in:\n            a = random.choice(not_in)\n            nbr = cur + [a]\n            move_type = \"Add1\"\n        elif cur:\n            r = random.choice(cur)\n            nbr = [x for x in cur if x != r]\n            move_type = \"Remove1\"\n        else:\n            nbr = cur[:]\n            move_type = \"None\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, \"INDEX_LIST\", move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Multi-move random kick with feasible repair\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        dens = {i: (prices[i-1] \/ gallons[i-1]) for i in uniq}\n        rem = sorted(uniq, key=lambda i: (dens[i], prices[i-1], gallons[i-1], random.random()))\n        keep = set(uniq)\n        for i in rem:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    # Intensity: proportional to problem size\n    k = max(3, n \/\/ 8)\n    nbr = cur[:]\n    for _ in range(k):\n        # Randomly choose among remove, add, swap\n        op = random.randrange(3)\n        in_set = set(nbr)\n        not_in = [i for i in range(1, n+1) if i not in in_set]\n        if op == 0 and nbr:\n            # remove\n            r = random.choice(nbr)\n            nbr = [x for x in nbr if x != r]\n        elif op == 1:\n            # add\n            if not_in:\n                a = random.choice(not_in)\n                nbr.append(a)\n        else:\n            # swap\n            if nbr and not_in:\n                r = random.choice(nbr)\n                a = random.choice(not_in)\n                nbr = [x for x in nbr if x != r] + [a]\n        nbr = repair_feasible(nbr)\n\n    return repair_feasible(nbr)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Maximize total price with capacity constraint; return cost (lower is better)\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        return -float(revenue)\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, movement_type) with INDEX_LIST representation\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        # Enforce INDEX_LIST canonical form: unique, in-range, sorted asc\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        # Deterministic removal by lowest density, tie-break by price, weight, index\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    cur_set = set(cur)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    not_in = [i for i in range(1, n+1) if i not in cur_set]\n    r = random.random()\n\n    if r < 0.2 and cur:\n        # Remove 1\n        rem = random.choice(cur)\n        nbr = [x for x in cur if x != rem]\n        move_type = \"Remove1\"\n    elif r < 0.4:\n        # Add 1 or fallback remove\n        if not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n    elif r < 0.6 and cur and not_in:\n        # Swap 1-1\n        rem = random.choice(cur)\n        add = random.choice(not_in)\n        nbr = [x for x in cur if x != rem] + [add]\n        move_type = \"Swap1\"\n    elif r < 0.8:\n        # Add2, Remove2, or Add2Remove1\n        if len(not_in) >= 2:\n            adds = random.sample(not_in, 2)\n            trial = cur + adds\n            if total_weight(trial) <= capacity:\n                nbr = trial\n                move_type = \"Add2\"\n            elif cur:\n                rem = random.choice(cur)\n                nbr = [x for x in cur if x != rem] + adds\n                move_type = \"Add2Remove1\"\n        elif len(cur) >= 2:\n            rems = set(random.sample(cur, 2))\n            nbr = [x for x in cur if x not in rems]\n            move_type = \"Remove2\"\n    else:\n        # Swap2 if possible, else fallback\n        if len(cur) >= 2 and len(not_in) >= 2:\n            rems = set(random.sample(cur, 2))\n            adds = random.sample(not_in, 2)\n            nbr = [x for x in cur if x not in rems] + adds\n            move_type = \"Swap2\"\n        elif cur and not_in:\n            rem = random.choice(cur)\n            add = random.choice(not_in)\n            nbr = [x for x in cur if x != rem] + [add]\n            move_type = \"Swap1\"\n        elif not_in:\n            add = random.choice(not_in)\n            nbr = cur + [add]\n            move_type = \"Add1\"\n        elif cur:\n            rem = random.choice(cur)\n            nbr = [x for x in cur if x != rem]\n            move_type = \"Remove1\"\n\n    nbr = repair_feasible(nbr)\n    return (nbr, move_type)\n","Perturbacion":"import math, random\n\ndef perturb_solution(solution):\n    # Deterministic kick based on densities, then greedy refill\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def repair_feasible(lst):\n        uniq = sorted(set(i for i in lst if isinstance(i, int) and 1 <= i <= n))\n        w = total_weight(uniq)\n        if w <= capacity:\n            return uniq\n        densities = {i: prices[i-1] \/ gallons[i-1] for i in uniq}\n        order = sorted(uniq, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n        keep = set(uniq)\n        for i in order:\n            if w <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n                w -= gallons[i-1]\n        return sorted(keep)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    # Remove k lowest-density items deterministically\n    k = max(3, n \/\/ 8)\n    densities = {i: prices[i-1] \/ gallons[i-1] for i in cur}\n    rm_order = sorted(cur, key=lambda i: (densities[i], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(k, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n    base = repair_feasible(base)\n\n    # Greedy refill by highest density among items not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    densities_all = {i: prices[i-1] \/ gallons[i-1] for i in candidates}\n    # Sort by descending density, tie-break by higher price, lower weight, then lower index\n    cand_sorted = sorted(candidates, key=lambda i: (-densities_all[i], -prices[i-1], gallons[i-1], i))\n\n    w = total_weight(base)\n    sol = list(base)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    return sorted(set(sol))\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # INDEX_LIST representation: list of 1-based indices\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n\n    # Basic validation\n    if not isinstance(solution, list):\n        return 1e18\n    n = len(prices)\n    seen = set()\n    revenue = 0\n    weight = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 1e18\n        if idx < 1 or idx > n:\n            return 1e18\n        if idx in seen:\n            return 1e18\n        seen.add(idx)\n        i0 = idx - 1\n        revenue += prices[i0]\n        weight += gallons[i0]\n\n    if weight <= capacity:\n        # Lexicographic tie-break encoded as tiny offset to the cost\n        # Compute a bounded lex key in (0,1) where lexicographically smaller list has smaller key\n        lex_key = 0.0\n        base = 100.0  # base large enough to separate digits\n        for pos, idx in enumerate(solution):\n            lex_key += idx \/ (base ** (pos + 1))\n        # Lower is better: cost = -revenue + eps * lex_key\n        return -float(revenue) + 1e-9 * lex_key\n\n    overflow = weight - capacity\n    return 1e12 + 1e6 * float(overflow)\n","Vecindad":"import math, random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Deterministic, feasibility-preserving neighborhood on INDEX_LIST\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    # Canonicalize current solution\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n    in_set = set(cur)\n\n    # Deterministic RNG seeded by current solution state\n    seed_val = 1469598103934665603  # FNV offset basis\n    for x in cur:\n        seed_val ^= x + 0x9e3779b97f4a7c15\n        seed_val = (seed_val * 1099511628211) & ((1 << 64) - 1)\n    rng = random.Random(seed_val)\n\n    # Precompute helpers\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    def canonical(lst):\n        return sorted(set(lst))\n\n    w_cur = total_weight(cur)\n    slack = capacity - w_cur\n\n    # Density and candidate lists\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n    not_in = [i for i in range(1, n+1) if i not in in_set]\n\n    # Sort helpers with deterministic tie-breaks\n    def sort_in_items(lst):\n        return sorted(lst, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))  # ascending density (worst first)\n\n    def sort_out_items_desc(lst):\n        return sorted(lst, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))  # descending density (best first)\n\n    worst_in = sort_in_items(cur)\n    best_out = sort_out_items_desc(not_in)\n\n    move_type = \"None\"\n    nbr = cur[:]\n\n    # Utility to evaluate delta revenue for a prospective move\n    def delta_rev(adds, rems):\n        return sum(prices[i-1] for i in adds) - sum(prices[i-1] for i in rems)\n\n    r = rng.random()\n\n    # Attempt Add1 of best fitting item\n    if r < 0.3:\n        for j in best_out:\n            wj = gallons[j-1]\n            if slack >= wj:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        # If no add fits, try 1-for-1 targeted swap that increases revenue\n        best_gain = -1e18\n        best_pair = None\n        # Limit search windows for efficiency\n        cand_in = worst_in[:min(10, len(worst_in))]\n        cand_out = best_out[:min(14, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: remove worst to free capacity\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # Swap1: best improving or least-worse feasible swap within candidate lists\n    elif r < 0.6:\n        best_gain = -1e18\n        best_pair = None\n        cand_in = worst_in[:min(12, len(worst_in))]\n        cand_out = best_out[:min(16, len(best_out))]\n        for i in cand_in:\n            wi = gallons[i-1]\n            for j in cand_out:\n                wj = gallons[j-1]\n                if slack + wi >= wj:\n                    gain = prices[j-1] - prices[i-1]\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i) < best_pair):\n                        best_gain = gain\n                        best_pair = (j, i)\n        if best_pair is not None:\n            j, i = best_pair\n            nbr = canonical([x for x in cur if x != i] + [j])\n            move_type = \"Swap1\"\n            return (nbr, move_type)\n        # Fallback: Add1 if possible else Remove1\n        for j in best_out:\n            if slack >= gallons[j-1]:\n                nbr = canonical(cur + [j])\n                move_type = \"Add1\"\n                return (nbr, move_type)\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 2-for-1 targeted ejection chain\n    elif r < 0.8 and len(cur) >= 2 and best_out:\n        cand_in = worst_in[:min(8, len(worst_in))]\n        # Precompute pair weights and prices\n        pairs = []\n        L = len(cand_in)\n        for a in range(L):\n            for b in range(a+1, L):\n                i1, i2 = cand_in[a], cand_in[b]\n                pairs.append((i1, i2, gallons[i1-1] + gallons[i2-1], prices[i1-1] + prices[i2-1]))\n        best_gain = -1e18\n        best_tuple = None\n        for j in best_out[:min(16, len(best_out))]:\n            wj = gallons[j-1]\n            pj = prices[j-1]\n            for (i1, i2, w12, p12) in pairs:\n                if slack + w12 >= wj:\n                    gain = pj - p12\n                    if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, i1, i2) < best_tuple):\n                        best_gain = gain\n                        best_tuple = (j, i1, i2)\n        if best_tuple is not None:\n            j, i1, i2 = best_tuple\n            base = [x for x in cur if x not in (i1, i2)]\n            nbr = canonical(base + [j])\n            move_type = \"Swap2for1\"\n            return (nbr, move_type)\n        # Fallback: Remove1 of worst\n        if worst_in:\n            i = worst_in[0]\n            nbr = canonical([x for x in cur if x != i])\n            move_type = \"Remove1\"\n            return (nbr, move_type)\n\n    # 1-for-2 targeted chain (if there is slack to allow two adds after one removal)\n    if cur and len(best_out) >= 2:\n        cand_out = best_out[:min(14, len(best_out))]\n        cand_in = worst_in[:min(8, len(worst_in))]\n        best_gain = -1e18\n        best_move = None\n        for i in cand_in:\n            wi = gallons[i-1]\n            pi = prices[i-1]\n            # two adds j,k with j<k in candidate list\n            for a in range(len(cand_out)):\n                j = cand_out[a]\n                wj = gallons[j-1]\n                pj = prices[j-1]\n                for b in range(a+1, len(cand_out)):\n                    k = cand_out[b]\n                    wk = gallons[k-1]\n                    pk = prices[k-1]\n                    if slack + wi >= wj + wk:\n                        gain = (pj + pk) - pi\n                        if gain > best_gain or (abs(gain - best_gain) < 1e-12 and (j, k, i) < best_move):\n                            best_gain = gain\n                            best_move = (j, k, i)\n        if best_move is not None:\n            j, k, i = best_move\n            base = [x for x in cur if x != i]\n            nbr = canonical(base + [j, k])\n            move_type = \"Swap1for2\"\n            return (nbr, move_type)\n\n    # Final fallback: if nothing else triggered, try best Add1 else Remove1\n    for j in best_out:\n        if slack >= gallons[j-1]:\n            nbr = canonical(cur + [j])\n            move_type = \"Add1\"\n            return (nbr, move_type)\n    if cur:\n        i = worst_in[0]\n        nbr = canonical([x for x in cur if x != i])\n        move_type = \"Remove1\"\n        return (nbr, move_type)\n\n    # If empty and nothing to add (shouldn't happen), return as is\n    return (cur, \"None\")\n","Perturbacion":"import math\n\ndef perturb_solution(solution):\n    # Deterministic ruin-and-recreate based on densities with lexicographic tie-breaks\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    capacity = 304\n    n = len(prices)\n\n    cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    cur = sorted(set(cur))\n\n    if not cur:\n        return cur\n\n    densities = [prices[i]\/gallons[i] for i in range(n)]\n\n    # Remove r lowest-density items (deterministic order)\n    r = max(3, n \/\/ 6)\n    rm_order = sorted(cur, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    to_remove = set(rm_order[:min(r, len(rm_order))])\n    base = [i for i in cur if i not in to_remove]\n\n    # Greedy refill by highest density not in base\n    in_set = set(base)\n    candidates = [i for i in range(1, n+1) if i not in in_set]\n    cand_sorted = sorted(candidates, key=lambda i: (-densities[i-1], -prices[i-1], gallons[i-1], i))\n\n    # Pack while capacity allows\n    def total_weight(lst):\n        return sum(gallons[i-1] for i in lst)\n\n    sol = sorted(set(base))\n    w = total_weight(sol)\n    for i in cand_sorted:\n        wi = gallons[i-1]\n        if w + wi <= capacity:\n            sol.append(i)\n            w += wi\n\n    sol = sorted(set(sol))\n    # Ensure feasibility (should be by construction)\n    if total_weight(sol) <= capacity:\n        return sol\n    # If any rounding issue, trim by lowest density until feasible\n    trim = sorted(sol, key=lambda i: (densities[i-1], prices[i-1], gallons[i-1], i))\n    keep = set(sol)\n    w = total_weight(sol)\n    for i in trim:\n        if w <= capacity:\n            break\n        if i in keep:\n            keep.remove(i)\n            w -= gallons[i-1]\n    return sorted(keep)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list\/tuple of unique integers in [1,24], each integer denotes selecting that item.","Evaluacion":"import math\nfrom typing import Any\n\ndef evaluate_solution(solution: Any) -> float:\n    # Validate representation: INDEX_LIST (1-based)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Problem data (embedded)\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Compute totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1  # map to 0-based\n        total_time += times[j]\n        total_value += values[j]\n    # Feasibility and fitness (minimization cost; negatives for maximization)\n    if total_time > capacity:\n        excess = total_time - capacity\n        base_pen = 1_000_000.0\n        lam = 1000.0\n        return float(base_pen + lam * excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import Any, List, Tuple\n\ndef generate_neighbour(solution: Any) -> Tuple[List[int], str, str]:\n    # Representation: INDEX_LIST (1-based). Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel_set = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel_set)\n\n    # Compute current load and value\n    total_time = sum(times[i-1] for i in sel_set)\n    # total_value not needed for feasibility\n\n    # Helper: attempt to repair to feasibility by dropping worst value\/time ratio items\n    def repair_to_feasible(sset: set) -> List[int]:\n        ttime = sum(times[i-1] for i in sset)\n        if ttime <= capacity:\n            return sorted(sset)\n        ratios = [( (values[i-1] \/ max(1, times[i-1])), i) for i in sset]\n        ratios.sort()  # ascending: drop worst first\n        idx = 0\n        while ttime > capacity and idx < len(ratios):\n            _, ii = ratios[idx]\n            if ii in sset:\n                sset.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n        return sorted(sset)\n\n    # Generate up to K attempts preferring feasible direct moves\n    K = 20\n    for _ in range(K):\n        move_choice = random.random()\n        sset = set(sel_set)\n        if sset and unsel and move_choice < 0.45:\n            # 1-1 swap\n            a = random.choice(list(sset))\n            b = random.choice(list(all_items - sset))\n            new_time = total_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                sset.remove(a)\n                sset.add(b)\n                return sorted(sset), \"swap\", \"1-1\"\n            else:\n                # try repair (shouldn't be needed often for swap, but safe)\n                sset.remove(a)\n                sset.add(b)\n                repaired = repair_to_feasible(sset)\n                return repaired, \"repair\", \"swap-then-repair\"\n        elif unsel and move_choice < 0.75:\n            # add single\n            b = random.choice(list(all_items - sset))\n            new_time = total_time + times[b-1]\n            if new_time <= capacity:\n                sset.add(b)\n                return sorted(sset), \"add\", \"single\"\n            # try add two-for-one drop (2-1) by dropping worst items until feasible\n            sset.add(b)\n            repaired = repair_to_feasible(sset)\n            if set(repaired) != set(current):\n                return repaired, \"repair\", \"add-then-repair\"\n        else:\n            # drop single\n            if sset:\n                a = random.choice(list(sset))\n                sset.remove(a)\n                return sorted(sset), \"drop\", \"single\"\n            else:\n                # if empty, force add\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: ensure we return a valid feasible neighbor by dropping if needed\n    if sel_set:\n        a = random.choice(list(sel_set))\n        fallback = sorted(sel_set - {a})\n        return fallback, \"drop\", \"single\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"add\", \"single\"\n","Perturbacion":"import random\nfrom typing import Any, List\n\ndef perturb_solution(solution: Any) -> List[int]:\n    # Validate solution\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # 1) Random shake: remove r random items (r in [2,5])\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # 2) Greedy refill by value\/time ratio within capacity\n    def total_time_of(S: set) -> int:\n        return sum(times[i-1] for i in S)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    remaining = list(all_items - sel)\n    remaining.sort(key=lambda i: ratio(i), reverse=True)\n\n    ttime = total_time_of(sel)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # 3) Local improvement: try a few 1-1 swaps to increase value without exceeding capacity\n    attempts = 40\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins) if ins else None\n        if b is None:\n            break\n        new_time = ttime - times[a-1] + times[b-1]\n        delta_val = values[b-1] - values[a-1]\n        if new_time <= capacity and delta_val > 0:\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # 4) Final feasibility repair (should already be feasible)\n    if ttime > capacity:\n        items = sorted(list(sel), key=lambda i: values[i-1] \/ max(1, times[i-1]))\n        idx = 0\n        while ttime > capacity and idx < len(items):\n            ii = items[idx]\n            if ii in sel:\n                sel.remove(ii)\n                ttime -= times[ii-1]\n            idx += 1\n\n    return sorted(sel)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST(1-based). A solution is a list of unique integers in [1,24], each denoting a selected item.","Evaluacion":"import math\nfrom typing import Sequence\n\ndef evaluate_solution(solution: Sequence[int]) -> float:\n    # Validate representation: INDEX_LIST (1-based unique ints)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    # Totals\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    # Cost (minimization). Use negatives for maximization; heavy penalty if infeasible\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1_000_000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution) -> Tuple[List[int], str, str]:\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n    # cur_value not needed for feasibility\n\n    def repair_to_feasible(S: set) -> List[int]:\n        # Drop items with lowest value\/time first until feasible\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        order = sorted(list(S), key=lambda i: (values[i-1] \/ max(1, times[i-1])))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: List[int]) -> bool:\n        return set(nb) != sel\n\n    K = 60\n    for _ in range(K):\n        move_rand = random.random()\n        S = set(sel)\n        # Prefer feasibility-preserving swaps, then add if slack, else drop\n        if S and unsel and move_rand < 0.45:\n            # 1-1 swap\n            a = random.choice(list(S))\n            b = random.choice(list(all_items - S))\n            new_time = cur_time - times[a-1] + times[b-1]\n            if new_time <= capacity:\n                S.remove(a)\n                S.add(b)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"swap\", \"1-1\"\n        elif S and unsel and move_rand < 0.70:\n            # 1-2 or 2-1 exchange attempt\n            if random.random() < 0.5 and len(all_items - S) >= 2:\n                # 2-in 1-out (2-1)\n                a = random.choice(list(S))\n                cand_ins = random.sample(list(all_items - S), 2)\n                new_time = cur_time - times[a-1] + sum(times[i-1] for i in cand_ins)\n                if new_time <= capacity:\n                    S.remove(a)\n                    S.update(cand_ins)\n                    nb = sorted(S)\n                    if ensure_changed(nb):\n                        return nb, \"k-swap\", \"2-1\"\n            else:\n                # 1-in 2-out (1-2)\n                if len(S) >= 2:\n                    b = random.choice(list(all_items - S)) if (all_items - S) else None\n                    if b is not None:\n                        outs = random.sample(list(S), 2)\n                        new_time = cur_time - sum(times[i-1] for i in outs) + times[b-1]\n                        if new_time <= capacity:\n                            for o in outs:\n                                S.discard(o)\n                            S.add(b)\n                            nb = sorted(S)\n                            if ensure_changed(nb):\n                                return nb, \"k-swap\", \"1-2\"\n        elif unsel and move_rand < 0.85:\n            # Add single with repair if needed\n            b = random.choice(list(all_items - S))\n            S.add(b)\n            nb = repair_to_feasible(S)\n            if ensure_changed(nb):\n                # label based on whether repair dropped something\n                if len(nb) == len(S):\n                    return nb, \"add\", \"single\"\n                else:\n                    return nb, \"repair\", \"add-then-repair\"\n        else:\n            # Drop single\n            if S:\n                a = random.choice(list(S))\n                S.remove(a)\n                nb = sorted(S)\n                if ensure_changed(nb):\n                    return nb, \"drop\", \"single\"\n            else:\n                b = random.choice(list(all_items))\n                return [b], \"add\", \"single\"\n\n    # Fallback: force a change by drop or add\n    if sel:\n        a = random.choice(list(sel))\n        fb = sorted(sel - {a})\n        return fb, \"fallback\", \"drop\"\n    else:\n        b = random.choice(list(all_items))\n        return [b], \"fallback\", \"add\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution) -> List[int]:\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any(i < 1 or i > n for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    # Shake: remove r random items\n    r = random.randint(2, 5)\n    for _ in range(min(r, len(sel))):\n        a = random.choice(list(sel))\n        sel.remove(a)\n\n    # Greedy refill by value\/time ratio\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Local improvement via profitable 1-1 swaps\n    attempts = 60\n    for _ in range(attempts):\n        if not sel:\n            break\n        ins = list(all_items - sel)\n        if not ins:\n            break\n        outs = list(sel)\n        a = random.choice(outs)\n        b = random.choice(ins)\n        new_time = ttime - times[a-1] + times[b-1]\n        if new_time <= capacity and (values[b-1] > values[a-1]):\n            sel.remove(a)\n            sel.add(b)\n            ttime = new_time\n\n    # Final feasibility repair\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: ratio(i))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate INDEX_LIST representation\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        indices = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(indices) != len(set(indices)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in indices):\n        raise ValueError(\"OOB_INDEX\")\n    total_time = 0\n    total_value = 0\n    for i in indices:\n        j = i - 1\n        total_time += times[j]\n        total_value += values[j]\n    if total_time > capacity:\n        excess = total_time - capacity\n        return 1000000.0 + 1000.0 * float(excess)\n    return float(-total_value)\n","Vecindad":"import random\nimport math\n\n# Returns (neighbor_solution, NB_Type, Movement_Type)\n# Signature annotation as required by spec\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n    unsel = list(all_items - sel)\n\n    cur_time = sum(times[i-1] for i in sel)\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    def repair_to_feasible(S: set) -> list:\n        ttime = sum(times[i-1] for i in S)\n        if ttime <= capacity:\n            return sorted(S)\n        # Drop by (low ratio, then low value, then high time) to diversify\n        order = sorted(list(S), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            if ii in S:\n                S.remove(ii)\n                ttime -= times[ii-1]\n        return sorted(S)\n\n    def ensure_changed(nb: list) -> bool:\n        return set(nb) != sel\n\n    # Sampled best-improvement among several candidate moves\n    best_nb = None\n    best_tag = (\"none\", \"none\")\n    best_cost = math.inf\n\n    # Evaluate helper (lower is better)\n    def cost_of(indices_list: list) -> float:\n        # Embedded again to keep function self-contained\/static\n        v = 0\n        t = 0\n        for i in indices_list:\n            j = i - 1\n            t += times[j]\n            v += values[j]\n        if t > capacity:\n            return 1000000.0 + 1000.0 * float(t - capacity)\n        return float(-v)\n\n    # Generate candidate moves\n    S = set(sel)\n    A = list(S)\n    B = list(all_items - S)\n\n    candidates = []\n    # 1-1 swaps\n    for _ in range(30):\n        if not A or not B:\n            break\n        a = random.choice(A)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.add(b)\n        nb = sorted(nbS)\n        candidates.append((nb, \"swap\", \"1-1\"))\n    # 1-add (with feasibility repair if needed)\n    for _ in range(20):\n        if not B:\n            break\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"add\", \"single\"))\n    # 1-drop\n    for _ in range(10):\n        if not A:\n            break\n        a = random.choice(A)\n        nbS = set(S)\n        nbS.discard(a)\n        nb = sorted(nbS)\n        candidates.append((nb, \"drop\", \"single\"))\n    # 2-1 exchange\n    for _ in range(20):\n        if not A or len(B) < 2:\n            break\n        a = random.choice(A)\n        b1, b2 = random.sample(B, 2)\n        nbS = set(S)\n        nbS.discard(a)\n        nbS.update([b1, b2])\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"2-1\"))\n    # 1-2 exchange\n    for _ in range(20):\n        if len(A) < 2 or not B:\n            break\n        a1, a2 = random.sample(A, 2)\n        b = random.choice(B)\n        nbS = set(S)\n        nbS.discard(a1)\n        nbS.discard(a2)\n        nbS.add(b)\n        nb = repair_to_feasible(nbS)\n        candidates.append((nb, \"k-swap\", \"1-2\"))\n\n    # Always include a greedy-refill neighbor: drop one weak item then refill\n    if A:\n        drop = min(A, key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        nbS = set(S)\n        nbS.discard(drop)\n        # Greedy refill by ratio\n        ttime = sum(times[i-1] for i in nbS)\n        remaining = sorted(list(all_items - nbS), key=lambda i: ratio(i), reverse=True)\n        for i in remaining:\n            wi = times[i-1]\n            if ttime + wi <= capacity:\n                nbS.add(i)\n                ttime += wi\n        nb = sorted(nbS)\n        candidates.append((nb, \"refill\", \"drop+greedy\"))\n\n    # Pick best candidate (lowest cost), ensuring change\n    for nb, nb_type, mv in candidates:\n        if not ensure_changed(nb):\n            continue\n        c = cost_of(nb)\n        if c < best_cost:\n            best_cost = c\n            best_nb = nb\n            best_tag = (nb_type, mv)\n\n    if best_nb is None:\n        # Fallback simple random feasible move\n        if A:\n            a = random.choice(A)\n            nb = sorted(set(S) - {a})\n            return nb, \"fallback\", \"drop\"\n        else:\n            b = random.choice(list(all_items))\n            return [b], \"fallback\", \"add\"\n\n    return best_nb, best_tag[0], best_tag[1]\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    if not isinstance(solution, (list, tuple)):\n        raise ValueError(\"TYPE_NOT_LIST_OR_TUPLE\")\n    try:\n        current = [int(x) for x in solution]\n    except Exception:\n        raise ValueError(\"NON_INTEGRAL_INDEX\")\n    if len(current) != len(set(current)):\n        raise ValueError(\"DUP_INDICES\")\n    # Embedded problem data\n    values = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    capacity = 3040\n    n = len(values)\n    if any((i < 1) or (i > n) for i in current):\n        raise ValueError(\"OOB_INDEX\")\n\n    sel = set(current)\n    all_items = set(range(1, n + 1))\n\n    def ratio(i: int) -> float:\n        return values[i-1] \/ max(1, times[i-1])\n\n    # Random shake: k random edits (swap\/add\/drop)\n    k = random.randint(3, 6)\n    for _ in range(k):\n        move = random.random()\n        if move < 0.4 and sel and (all_items - sel):\n            # swap\n            a = random.choice(list(sel))\n            b = random.choice(list(all_items - sel))\n            sel.remove(a)\n            sel.add(b)\n        elif move < 0.7 and (all_items - sel):\n            # add\n            b = random.choice(list(all_items - sel))\n            sel.add(b)\n        else:\n            # drop\n            if sel:\n                a = random.choice(list(sel))\n                sel.remove(a)\n\n    # Greedy refill by ratio\n    ttime = sum(times[i-1] for i in sel)\n    remaining = sorted(list(all_items - sel), key=lambda i: ratio(i), reverse=True)\n    for i in remaining:\n        wi = times[i-1]\n        if ttime + wi <= capacity:\n            sel.add(i)\n            ttime += wi\n\n    # Final repair in case of overweight\n    if ttime > capacity:\n        order = sorted(list(sel), key=lambda i: (ratio(i), values[i-1], -times[i-1]))\n        for ii in order:\n            if ttime <= capacity:\n                break\n            sel.remove(ii)\n            ttime -= times[ii-1]\n\n    return sorted(sel)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"LIST_1BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate structure and types\n    if not isinstance(solution, list):\n        return 10**9\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n    n = 24\n    if len(solution) != len(set(solution)):\n        return 10**9\n    if any(x < 1 or x > n for x in solution):\n        return 10**9\n    # Embedded problem data\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_w = 0\n    total_v = 0\n    for i in solution:\n        idx = i - 1\n        total_w += weights[idx]\n        total_v += values[idx]\n    if total_w < 67:\n        # Large finite penalty with slight gradient by deficit\n        return 10**9 + (67 - total_w)\n    # Feasible: objective is to minimize total value\n    return total_v\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Representation: list of distinct 1-based indices (1..24)\n    n = 24\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def total_w(sol):\n        return sum(weights[i-1] for i in sol)\n\n    def repair(sol):\n        # Canonicalize and bound\n        sol = sorted(set(x for x in sol if 1 <= x <= n))\n        cw = total_w(sol)\n        if cw < 67:\n            # Min-cost cover DP to reach at least 67 with minimal added value\n            need = 67 - cw\n            available = [i for i in range(1, n+1) if i not in sol]\n            # DP on weight up to need + max_w to allow overshoot; cap for efficiency\n            max_w_add = max(weights[i-1] for i in available) if available else 0\n            cap = need + max_w_add\n            INF = 10**9\n            dp = [INF] * (cap + 1)\n            prev = [(-1, -1)] * (cap + 1)  # (prev_w, item)\n            dp[0] = 0\n            for i in available:\n                w = weights[i-1]\n                v = values[i-1]\n                for ww in range(cap, -1, -1):\n                    if dp[ww] >= INF:\n                        continue\n                    nw = min(cap, ww + w)\n                    nv = dp[ww] + v\n                    if nv < dp[nw]:\n                        dp[nw] = nv\n                        prev[nw] = (ww, i)\n            # choose best w >= need\n            best_w = None\n            best_cost = INF\n            for ww in range(need, cap + 1):\n                if dp[ww] < best_cost:\n                    best_cost = dp[ww]\n                    best_w = ww\n            # Reconstruct\n            if best_w is not None and best_cost < INF:\n                pick = []\n                ww = best_w\n                while ww > 0 and prev[ww][0] != -1:\n                    pww, item = prev[ww]\n                    pick.append(item)\n                    ww = pww\n                sol.extend(pick)\n            else:\n                # Fallback greedy by value\/weight ascending then value\n                cands = [i for i in available]\n                cands.sort(key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                for i in cands:\n                    sol.append(i)\n                    cw2 = total_w(sol)\n                    if cw2 >= 67:\n                        break\n        # Prune redundant items while staying feasible: drop highest value first, tie by lowest weight\n        changed = True\n        while changed:\n            changed = False\n            for i in sorted(sol, key=lambda j: (values[j-1], -weights[j-1]), reverse=True):\n                if total_w([x for x in sol if x != i]) >= 67:\n                    sol.remove(i)\n                    changed = True\n                    break\n        return sorted(sol)\n\n    curr = sorted(set(int(x) for x in solution if 1 <= int(x) <= n))\n    all_items = set(range(1, n+1))\n\n    move = random.choices([\"add\", \"drop\", \"swap\", \"two_swap\", \"drop_add\"], weights=[3,2,3,1,2], k=1)[0]\n    new_sol = list(curr)\n\n    if move == \"add\":\n        choices = list(all_items - set(new_sol))\n        if choices:\n            new_sol.append(random.choice(choices))\n    elif move == \"drop\":\n        if new_sol:\n            new_sol.remove(random.choice(new_sol))\n    elif move == \"swap\":\n        if new_sol and len(new_sol) < n:\n            out_item = random.choice(new_sol)\n            in_choices = list(all_items - set(new_sol))\n            if in_choices:\n                in_item = random.choice(in_choices)\n                new_sol.remove(out_item)\n                new_sol.append(in_item)\n        elif not new_sol:\n            new_sol.append(random.choice(list(all_items)))\n        else:\n            new_sol.remove(random.choice(new_sol))\n    elif move == \"two_swap\":\n        # swap up to two items\n        k = 2\n        for _ in range(k):\n            if new_sol and len(new_sol) < n:\n                out_item = random.choice(new_sol)\n                in_choices = list(all_items - set(new_sol))\n                if in_choices:\n                    in_item = random.choice(in_choices)\n                    new_sol.remove(out_item)\n                    new_sol.append(in_item)\n            else:\n                break\n    else:  # drop_add (guided)\n        if new_sol:\n            out_item = random.choice(new_sol)\n            new_sol.remove(out_item)\n        choices = list(all_items - set(new_sol))\n        if choices:\n            # prefer lower value and higher weight to help feasibility cheaply\n            choices.sort(key=lambda i: (values[i-1], -weights[i-1]))\n            new_sol.append(random.choice(choices[:min(5, len(choices))]))\n\n    repaired = repair(new_sol)\n    movement = {\n        \"add\": \"Add\",\n        \"drop\": \"Drop\",\n        \"swap\": \"Swap\",\n        \"two_swap\": \"TwoSwap\",\n        \"drop_add\": \"DropAdd\"\n    }[move]\n    return repaired, \"FeasibleRepair\", movement\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Multi-move perturbation with feasibility-preserving repair\n    n = 24\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def total_w(sol):\n        return sum(weights[i-1] for i in sol)\n\n    def repair(sol):\n        sol = sorted(set(x for x in sol if 1 <= x <= n))\n        cw = total_w(sol)\n        if cw < 67:\n            need = 67 - cw\n            available = [i for i in range(1, n+1) if i not in sol]\n            max_w_add = max(weights[i-1] for i in available) if available else 0\n            cap = need + max_w_add\n            INF = 10**9\n            dp = [INF] * (cap + 1)\n            prev = [(-1, -1)] * (cap + 1)\n            dp[0] = 0\n            for i in available:\n                w = weights[i-1]\n                v = values[i-1]\n                for ww in range(cap, -1, -1):\n                    if dp[ww] >= INF:\n                        continue\n                    nw = min(cap, ww + w)\n                    nv = dp[ww] + v\n                    if nv < dp[nw]:\n                        dp[nw] = nv\n                        prev[nw] = (ww, i)\n            best_w = None\n            best_cost = INF\n            for ww in range(need, cap + 1):\n                if dp[ww] < best_cost:\n                    best_cost = dp[ww]\n                    best_w = ww\n            if best_w is not None and best_cost < INF:\n                pick = []\n                ww = best_w\n                while ww > 0 and prev[ww][0] != -1:\n                    pww, item = prev[ww]\n                    pick.append(item)\n                    ww = pww\n                sol.extend(pick)\n            else:\n                cands = [i for i in range(1, n+1) if i not in sol]\n                cands.sort(key=lambda i: (values[i-1] \/ weights[i-1], values[i-1]))\n                for i in cands:\n                    sol.append(i)\n                    if total_w(sol) >= 67:\n                        break\n        # prune redundant items prioritizing highest value then lowest weight\n        changed = True\n        while changed:\n            changed = False\n            for i in sorted(sol, key=lambda j: (values[j-1], -weights[j-1]), reverse=True):\n                if total_w([x for x in sol if x != i]) >= 67:\n                    sol.remove(i)\n                    changed = True\n                    break\n        return sorted(sol)\n\n    new_sol = list(sorted(set(int(x) for x in solution if 1 <= int(x) <= n)))\n    all_items = list(range(1, n+1))\n\n    # Apply k random moves\n    k = random.randint(4, 7)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"])\n        if move == \"add\":\n            choices = [i for i in all_items if i not in new_sol]\n            if choices:\n                # bias towards lower value, higher weight\n                choices.sort(key=lambda i: (values[i-1], -weights[i-1]))\n                pick = random.choice(choices[:min(6, len(choices))])\n                new_sol.append(pick)\n        elif move == \"drop\":\n            if new_sol:\n                # bias to drop high value, low weight first\n                drop_order = sorted(new_sol, key=lambda j: (values[j-1], -weights[j-1]), reverse=True)\n                new_sol.remove(random.choice(drop_order[:min(6, len(drop_order))]))\n        else:  # swap\n            if new_sol and len(new_sol) < n:\n                out_item = random.choice(new_sol)\n                in_choices = [i for i in all_items if i not in new_sol]\n                if in_choices:\n                    in_choices.sort(key=lambda i: (values[i-1], -weights[i-1]))\n                    in_item = random.choice(in_choices[:min(6, len(in_choices))])\n                    new_sol.remove(out_item)\n                    new_sol.append(in_item)\n            elif not new_sol:\n                new_sol.append(random.choice(all_items))\n            else:\n                # full set, force drop\n                new_sol.remove(random.choice(new_sol))\n\n    return repair(new_sol)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"LIST_1BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate structure and types: must be list of distinct ints in [1,24]\n    if not isinstance(solution, list):\n        return 10**9\n    n = 24\n    seen = set()\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n    # Embedded problem data\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_w = 0\n    total_v = 0\n    for i in solution:\n        idx = i - 1\n        total_w += weights[idx]\n        total_v += values[idx]\n    if total_w < 67:\n        # Large finite penalty with slight gradient by deficit\n        return 10**9 + (67 - total_w)\n    # Feasible: objective is to minimize total value\n    return int(total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Returns: (new_solution, info_dict)\n    new_solution: LIST_1BASED_INDICES (sorted, unique, feasible w>=67)\n    info_dict: {\"move\": str, \"tag\": \"FeasibleRepair\"}\n    \"\"\"\n    # Validate incoming solution; if invalid, start from empty\n    if not isinstance(solution, list) or any((not isinstance(x, int)) for x in solution):\n        curr = []\n    else:\n        n = 24\n        curr = sorted(set([x for x in solution if 1 <= x <= n]))\n    n = 24\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def total_w_fast(sol):\n        tw = 0\n        for i in sol:\n            tw += weights[i-1]\n        return tw\n\n    def repair(sol):\n        # Canonicalize and bound, maintain running weight\n        sol = sorted(set([x for x in sol if 1 <= x <= n]))\n        cw = total_w_fast(sol)\n        if cw < 67:\n            need = 67 - cw\n            available = [i for i in range(1, n+1) if i not in sol]\n            # Unbounded knapsack variant to reach at least need with minimal added value (0\/1 items here)\n            max_w_add = max((weights[i-1] for i in available), default=0)\n            cap = need + max_w_add\n            INF = 10**9\n            dp = [INF] * (cap + 1)\n            prv = [(-1, -1)] * (cap + 1)  # (prev_w, item)\n            dp[0] = 0\n            for i in available:\n                w = weights[i-1]\n                v = values[i-1]\n                for ww in range(cap, -1, -1):\n                    if dp[ww] >= INF:\n                        continue\n                    nw = ww + w\n                    if nw > cap:\n                        nw = cap\n                    nv = dp[ww] + v\n                    if nv < dp[nw]:\n                        dp[nw] = nv\n                        prv[nw] = (ww, i)\n            # pick best weight >= need\n            best_w = None\n            best_cost = INF\n            for ww in range(need, cap + 1):\n                if dp[ww] < best_cost:\n                    best_cost = dp[ww]\n                    best_w = ww\n            if best_w is not None and best_cost < INF:\n                pick = []\n                ww = best_w\n                while ww > 0 and prv[ww][0] != -1:\n                    pww, item = prv[ww]\n                    pick.append(item)\n                    ww = pww\n                for it in pick:\n                    if it not in sol:\n                        sol.append(it)\n                        cw += weights[it-1]\n            else:\n                # Fallback greedy: low value, high weight\n                cands = [i for i in range(1, n+1) if i not in sol]\n                cands.sort(key=lambda i: (values[i-1], -weights[i-1]))\n                for i in cands:\n                    sol.append(i)\n                    cw += weights[i-1]\n                    if cw >= 67:\n                        break\n        # Prune redundant items while keeping feasibility; remove highest value first greedily\n        # Maintain running weight cw\n        removed = True\n        while removed:\n            removed = False\n            # candidates removable without violating constraint\n            removable = [i for i in sol if (cw - weights[i-1]) >= 67]\n            if not removable:\n                break\n            # remove the item that gives the largest value decrease; tie-break by smallest weight loss\n            removable.sort(key=lambda j: (values[j-1], -weights[j-1]), reverse=True)\n            i = removable[0]\n            sol.remove(i)\n            cw -= weights[i-1]\n            removed = True\n        return sorted(sol)\n\n    all_items = set(range(1, n+1))\n    move = random.choices([\"add\", \"drop\", \"swap\", \"two_swap\", \"drop_add\"], weights=[3, 2, 3, 1, 2], k=1)[0]\n    new_sol = list(curr)\n\n    if move == \"add\":\n        choices = list(all_items - set(new_sol))\n        if choices:\n            new_sol.append(random.choice(choices))\n    elif move == \"drop\":\n        if new_sol:\n            new_sol.remove(random.choice(new_sol))\n    elif move == \"swap\":\n        if new_sol and len(new_sol) < n:\n            out_item = random.choice(new_sol)\n            in_choices = list(all_items - set(new_sol))\n            if in_choices:\n                in_item = random.choice(in_choices)\n                new_sol.remove(out_item)\n                new_sol.append(in_item)\n        elif not new_sol:\n            new_sol.append(random.choice(list(all_items)))\n        else:\n            new_sol.remove(random.choice(new_sol))\n    elif move == \"two_swap\":\n        for _ in range(2):\n            if new_sol and len(new_sol) < n:\n                out_item = random.choice(new_sol)\n                in_choices = list(all_items - set(new_sol))\n                if in_choices:\n                    in_item = random.choice(in_choices)\n                    new_sol.remove(out_item)\n                    new_sol.append(in_item)\n            else:\n                break\n    else:  # drop_add\n        if new_sol:\n            out_item = random.choice(new_sol)\n            new_sol.remove(out_item)\n        choices = list(all_items - set(new_sol))\n        if choices:\n            # prefer lower value and higher weight\n            choices.sort(key=lambda i: (values[i-1], -weights[i-1]))\n            new_sol.append(random.choice(choices[:min(5, len(choices))]))\n\n    repaired = repair(new_sol)\n    info = {\"move\": move, \"tag\": \"FeasibleRepair\"}\n    return repaired, info\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed feasible solution in LIST_1BASED_INDICES\n    if not isinstance(solution, list) or any((not isinstance(x, int)) for x in solution):\n        base = []\n    else:\n        n = 24\n        base = sorted(set([x for x in solution if 1 <= x <= n]))\n    n = 24\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def total_w_fast(sol):\n        tw = 0\n        for i in sol:\n            tw += weights[i-1]\n        return tw\n\n    def repair(sol):\n        sol = sorted(set([x for x in sol if 1 <= x <= n]))\n        cw = total_w_fast(sol)\n        if cw < 67:\n            need = 67 - cw\n            available = [i for i in range(1, n+1) if i not in sol]\n            max_w_add = max((weights[i-1] for i in available), default=0)\n            cap = need + max_w_add\n            INF = 10**9\n            dp = [INF] * (cap + 1)\n            prv = [(-1, -1)] * (cap + 1)\n            dp[0] = 0\n            for i in available:\n                w = weights[i-1]\n                v = values[i-1]\n                for ww in range(cap, -1, -1):\n                    if dp[ww] >= INF:\n                        continue\n                    nw = ww + w\n                    if nw > cap:\n                        nw = cap\n                    nv = dp[ww] + v\n                    if nv < dp[nw]:\n                        dp[nw] = nv\n                        prv[nw] = (ww, i)\n            best_w = None\n            best_cost = INF\n            for ww in range(need, cap + 1):\n                if dp[ww] < best_cost:\n                    best_cost = dp[ww]\n                    best_w = ww\n            if best_w is not None and best_cost < INF:\n                pick = []\n                ww = best_w\n                while ww > 0 and prv[ww][0] != -1:\n                    pww, item = prv[ww]\n                    pick.append(item)\n                    ww = pww\n                for it in pick:\n                    if it not in sol:\n                        sol.append(it)\n                        cw += weights[it-1]\n            else:\n                cands = [i for i in range(1, n+1) if i not in sol]\n                cands.sort(key=lambda i: (values[i-1], -weights[i-1]))\n                for i in cands:\n                    sol.append(i)\n                    cw += weights[i-1]\n                    if cw >= 67:\n                        break\n        # Prune redundant items greedily while feasible\n        removed = True\n        while removed:\n            removed = False\n            removable = [i for i in sol if (cw - weights[i-1]) >= 67]\n            if not removable:\n                break\n            removable.sort(key=lambda j: (values[j-1], -weights[j-1]), reverse=True)\n            i = removable[0]\n            sol.remove(i)\n            cw -= weights[i-1]\n            removed = True\n        return sorted(sol)\n\n    new_sol = list(base)\n    all_items = list(range(1, n+1))\n    # Apply k random moves to diversify\n    k = random.randint(4, 7)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"]) \n        if move == \"add\":\n            choices = [i for i in all_items if i not in new_sol]\n            if choices:\n                choices.sort(key=lambda i: (values[i-1], -weights[i-1]))\n                pick = random.choice(choices[:min(6, len(choices))])\n                new_sol.append(pick)\n        elif move == \"drop\":\n            if new_sol:\n                drop_order = sorted(new_sol, key=lambda j: (values[j-1], -weights[j-1]), reverse=True)\n                new_sol.remove(random.choice(drop_order[:min(6, len(drop_order))]))\n        else:  # swap\n            if new_sol and len(new_sol) < n:\n                out_item = random.choice(new_sol)\n                in_choices = [i for i in all_items if i not in new_sol]\n                if in_choices:\n                    in_choices.sort(key=lambda i: (values[i-1], -weights[i-1]))\n                    in_item = random.choice(in_choices[:min(6, len(in_choices))])\n                    new_sol.remove(out_item)\n                    new_sol.append(in_item)\n            elif not new_sol:\n                new_sol.append(random.choice(all_items))\n            else:\n                new_sol.remove(random.choice(new_sol))\n\n    return repair(new_sol)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_textbook_inverted","Representacion":"LIST_1BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate structure and types: must be list of distinct ints in [1,24]\n    if not isinstance(solution, list):\n        return 10**9\n    n = 24\n    seen = set()\n    for x in solution:\n        if not isinstance(x, int):\n            return 10**9\n        if x < 1 or x > n:\n            return 10**9\n        if x in seen:\n            return 10**9\n        seen.add(x)\n    # Embedded problem data\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    total_w = 0\n    total_v = 0\n    for i in solution:\n        idx = i - 1\n        total_w += weights[idx]\n        total_v += values[idx]\n    if total_w < 67:\n        return 10**9 + (67 - total_w)\n    return int(total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns: (new_solution, (NB_Type, Movement_Type))\n    new_solution: LIST_1BASED_INDICES, repaired to satisfy weight >= 67 when possible\n    NB_Type: str label of neighbour generator\n    Movement_Type: str specific move used\n    \"\"\"\n    # Canonicalize input\n    n = 24\n    if not isinstance(solution, list) or any((not isinstance(x, int)) for x in solution):\n        curr = []\n    else:\n        curr = [x for x in solution if 1 <= x <= n]\n        curr = list(dict.fromkeys(curr))  # preserve order, ensure uniqueness\n\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def tot_weight(sol):\n        tw = 0\n        for i in sol:\n            tw += weights[i-1]\n        return tw\n\n    def tot_value(sol):\n        tv = 0\n        for i in sol:\n            tv += values[i-1]\n        return tv\n\n    def repair(sol):\n        # Minimal-cost repair to reach feasibility; skip if already feasible\n        sol = [x for x in sol if 1 <= x <= n]\n        sol = list(dict.fromkeys(sorted(sol)))\n        cw = tot_weight(sol)\n        if cw >= 67:\n            return sol\n        need = 67 - cw\n        available = [i for i in range(1, n+1) if i not in sol]\n        if not available:\n            return sol\n        max_w_add = max((weights[i-1] for i in available), default=0)\n        cap = need + max_w_add\n        INF = 10**9\n        dp = [INF] * (cap + 1)\n        prv = [(-1, -1)] * (cap + 1)\n        dp[0] = 0\n        for i in available:\n            w = weights[i-1]\n            v = values[i-1]\n            for ww in range(cap, -1, -1):\n                if dp[ww] >= INF:\n                    continue\n                nw = ww + w\n                if nw > cap:\n                    nw = cap\n                nv = dp[ww] + v\n                if nv < dp[nw]:\n                    dp[nw] = nv\n                    prv[nw] = (ww, i)\n        best_w = None\n        best_cost = INF\n        for ww in range(need, cap + 1):\n            if dp[ww] < best_cost:\n                best_cost = dp[ww]\n                best_w = ww\n        if best_w is not None and best_cost < INF:\n            pick = []\n            ww = best_w\n            while ww > 0 and prv[ww][0] != -1:\n                pww, item = prv[ww]\n                pick.append(item)\n                ww = pww\n            for it in pick:\n                if it not in sol:\n                    sol.append(it)\n                    cw_plus = tot_weight([it])\n                    cw += cw_plus\n        else:\n            # Greedy fallback: density-guided\n            cands = [i for i in range(1, n+1) if i not in sol]\n            cands.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            for i in cands:\n                sol.append(i)\n                cw += weights[i-1]\n                if cw >= 67:\n                    break\n        # Final prune by lowest marginal density while keeping feasibility\n        changed = True\n        while changed:\n            changed = False\n            cw = tot_weight(sol)\n            removable = [i for i in sol if (cw - weights[i-1]) >= 67]\n            if not removable:\n                break\n            removable.sort(key=lambda j: (values[j-1]\/weights[j-1], values[j-1]))\n            j = removable[0]\n            sol.remove(j)\n            changed = True\n        return list(sorted(sol))\n\n    all_items = set(range(1, n+1))\n    curr_w = tot_weight(curr)\n\n    # Select movement; enrich with feasibility-preserving variants\n    moves = [\"add\", \"drop\", \"swap\", \"two_swap\", \"drop_add\", \"feas_swap\"]\n    move = random.choices(moves, weights=[3, 2, 3, 1, 2, 3], k=1)[0]\n\n    new_sol = list(curr)\n\n    if move == \"add\":\n        choices = list(all_items - set(new_sol))\n        if choices:\n            # prefer low value per weight\n            choices.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            pick = random.choice(choices[:min(5, len(choices))])\n            new_sol.append(pick)\n    elif move == \"drop\":\n        if new_sol:\n            # drop worst density item if feasibility remains\n            cw = curr_w\n            candidates = [i for i in new_sol if (cw - weights[i-1]) >= 67]\n            if candidates:\n                candidates.sort(key=lambda j: (-(values[j-1]\/weights[j-1]), -values[j-1]))\n                drop = random.choice(candidates[:min(3, len(candidates))])\n                new_sol.remove(drop)\n            else:\n                # drop random, will repair later\n                new_sol.remove(random.choice(new_sol))\n    elif move == \"swap\":\n        if new_sol and len(new_sol) < n:\n            out_item = random.choice(new_sol)\n            in_choices = list(all_items - set(new_sol))\n            if in_choices:\n                in_choices.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n                in_item = random.choice(in_choices[:min(5, len(in_choices))])\n                new_sol.remove(out_item)\n                new_sol.append(in_item)\n        elif not new_sol:\n            new_sol.append(random.choice(list(all_items)))\n        else:\n            new_sol.remove(random.choice(new_sol))\n    elif move == \"two_swap\":\n        for _ in range(2):\n            if new_sol and len(new_sol) < n:\n                out_item = random.choice(new_sol)\n                in_choices = list(all_items - set(new_sol))\n                if in_choices:\n                    in_choices.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n                    in_item = random.choice(in_choices[:min(5, len(in_choices))])\n                    new_sol.remove(out_item)\n                    new_sol.append(in_item)\n            else:\n                break\n    elif move == \"drop_add\":\n        if new_sol:\n            out_item = random.choice(new_sol)\n            new_sol.remove(out_item)\n        choices = list(all_items - set(new_sol))\n        if choices:\n            choices.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            new_sol.append(random.choice(choices[:min(5, len(choices))]))\n    else:  # feas_swap (feasibility-preserving guided swap)\n        # Try to replace one item with another to reduce value while keeping feasibility exactly\n        if new_sol and len(new_sol) < n:\n            cw = curr_w\n            # choose removable items first to keep feasibility\n            removable = [i for i in new_sol if (cw - weights[i-1]) >= 67]\n            candidates_out = removable if removable else list(new_sol)\n            out_item = random.choice(candidates_out)\n            temp = [x for x in new_sol if x != out_item]\n            tw = tot_weight(temp)\n            in_pool = list(all_items - set(temp))\n            # Only consider inserts that keep feasibility and reduce value if possible\n            improv = [i for i in in_pool if (tw + weights[i-1]) >= 67 and values[i-1] < values[out_item-1]]\n            if improv:\n                improv.sort(key=lambda i: (values[i-1], -weights[i-1]))\n                in_item = random.choice(improv[:min(5, len(improv))])\n                new_sol = temp + [in_item]\n            else:\n                # fallback simple swap\n                if in_pool:\n                    in_item = random.choice(in_pool)\n                    new_sol = temp + [in_item]\n        elif not new_sol:\n            new_sol.append(random.choice(list(all_items)))\n\n    # If feasible already, avoid heavy repair; otherwise repair\n    if tot_weight(new_sol) >= 67:\n        # Light prune using density to reduce objective\n        changed = True\n        while changed:\n            changed = False\n            cw = tot_weight(new_sol)\n            removable = [i for i in new_sol if (cw - weights[i-1]) >= 67]\n            if not removable:\n                break\n            removable.sort(key=lambda j: (values[j-1]\/weights[j-1], values[j-1]))\n            # probabilistically prune best few\n            for j in removable[:1]:\n                new_sol.remove(j)\n                changed = True\n                break\n        result = list(sorted(dict.fromkeys([x for x in new_sol if 1 <= x <= n])))\n        return result, (\"Feasible\", move)\n    else:\n        repaired = repair(new_sol)\n        return repaired, (\"FeasibleRepair\", move)\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Returns a perturbed feasible solution in LIST_1BASED_INDICES\n    n = 24\n    if not isinstance(solution, list) or any((not isinstance(x, int)) for x in solution):\n        base = []\n    else:\n        base = [x for x in solution if 1 <= x <= n]\n        base = list(dict.fromkeys(base))\n\n    weights = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    values  = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n\n    def tot_weight(sol):\n        tw = 0\n        for i in sol:\n            tw += weights[i-1]\n        return tw\n\n    def repair(sol):\n        sol = [x for x in sol if 1 <= x <= n]\n        sol = list(dict.fromkeys(sorted(sol)))\n        cw = tot_weight(sol)\n        if cw >= 67:\n            return sol\n        need = 67 - cw\n        available = [i for i in range(1, n+1) if i not in sol]\n        if not available:\n            return sol\n        max_w_add = max((weights[i-1] for i in available), default=0)\n        cap = need + max_w_add\n        INF = 10**9\n        dp = [INF] * (cap + 1)\n        prv = [(-1, -1)] * (cap + 1)\n        dp[0] = 0\n        for i in available:\n            w = weights[i-1]\n            v = values[i-1]\n            for ww in range(cap, -1, -1):\n                if dp[ww] >= INF:\n                    continue\n                nw = ww + w\n                if nw > cap:\n                    nw = cap\n                nv = dp[ww] + v\n                if nv < dp[nw]:\n                    dp[nw] = nv\n                    prv[nw] = (ww, i)\n        best_w = None\n        best_cost = INF\n        for ww in range(need, cap + 1):\n            if dp[ww] < best_cost:\n                best_cost = dp[ww]\n                best_w = ww\n        if best_w is not None and best_cost < INF:\n            pick = []\n            ww = best_w\n            while ww > 0 and prv[ww][0] != -1:\n                pww, item = prv[ww]\n                pick.append(item)\n                ww = pww\n            for it in pick:\n                if it not in sol:\n                    sol.append(it)\n        else:\n            cands = [i for i in range(1, n+1) if i not in sol]\n            cands.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n            for i in cands:\n                sol.append(i)\n                if tot_weight(sol) >= 67:\n                    break\n        # prune\n        changed = True\n        while changed:\n            changed = False\n            cw = tot_weight(sol)\n            removable = [i for i in sol if (cw - weights[i-1]) >= 67]\n            if not removable:\n                break\n            removable.sort(key=lambda j: (values[j-1]\/weights[j-1], values[j-1]))\n            j = removable[0]\n            sol.remove(j)\n            changed = True\n        return list(sorted(sol))\n\n    new_sol = list(base)\n    all_items = list(range(1, n+1))\n\n    # Apply k random moves to diversify\n    k = random.randint(4, 7)\n    for _ in range(k):\n        move = random.choice([\"add\", \"drop\", \"swap\"]) \n        if move == \"add\":\n            choices = [i for i in all_items if i not in new_sol]\n            if choices:\n                choices.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n                pick = random.choice(choices[:min(6, len(choices))])\n                new_sol.append(pick)\n        elif move == \"drop\":\n            if new_sol:\n                # prefer dropping highest density to reduce value least per weight loss, then repair\n                drop_order = sorted(new_sol, key=lambda j: (values[j-1]\/weights[j-1], values[j-1]), reverse=True)\n                new_sol.remove(random.choice(drop_order[:min(6, len(drop_order))]))\n        else:  # swap\n            if new_sol and len(new_sol) < n:\n                out_item = random.choice(new_sol)\n                in_choices = [i for i in all_items if i not in new_sol]\n                if in_choices:\n                    in_choices.sort(key=lambda i: (values[i-1]\/weights[i-1], values[i-1]))\n                    in_item = random.choice(in_choices[:min(6, len(in_choices))])\n                    new_sol.remove(out_item)\n                    new_sol.append(in_item)\n            elif not new_sol:\n                new_sol.append(random.choice(all_items))\n            else:\n                new_sol.remove(random.choice(new_sol))\n\n    return repair(new_sol)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST (1-based). A solution is a Python list of unique integers in [1,24]; element i means x_i=1.","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Validate type\n    if not isinstance(solution, list):\n        return 10**12\n    # Embedded problem data (length 24)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    n_items = 24\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    # Sanitize and accumulate\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n_items:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n    # Constraint: total_cost >= 670. Use dynamic penalty to preserve gradient.\n    if total_cost < 670:\n        penalty = 1000 * (670 - total_cost)\n        return total_points + penalty\n    # Feasible: minimize total_points\n    return total_points\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):  # -> (\"NB_Type\", \"Movement_Type\")\n    # Sanitize input to INDEX_LIST (1..24, unique)\n    n_items = 24\n    if not isinstance(solution, list):\n        current = []\n    else:\n        uniq = []\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n_items and v not in seen:\n                uniq.append(v)\n                seen.add(v)\n        current = uniq\n    in_set = set(current)\n    # Embedded data for feasibility-aware moves\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    # Compute current cost\n    total_cost = sum(costs[i-1] for i in current)\n    move_types = []\n    # If infeasible cost, prioritize add\n    if total_cost < 670:\n        move_types = [\"add\", \"add\", \"swap\"]\n    else:\n        move_types = [\"remove\", \"swap\", \"add\"]\n    move = random.choice(move_types)\n    if move == \"add\":\n        candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n        if candidates:\n            current.append(random.choice(candidates))\n    elif move == \"remove\":\n        if current:\n            # ensure feasibility after removal if possible; try a few times\n            for _ in range(5):\n                ridx = random.randrange(len(current))\n                cand = current[:ridx] + current[ridx+1:]\n                cand_cost = sum(costs[i-1] for i in cand)\n                if cand_cost >= 670 or len(current) == 1:\n                    current = cand\n                    break\n            else:\n                # fallback remove random\n                rem = random.randrange(len(current))\n                current.pop(rem)\n    else:  # swap\n        if current:\n            rem_idx = random.randrange(len(current))\n            removed = current.pop(rem_idx)\n            in_set.discard(removed)\n            candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n            if candidates:\n                add = random.choice(candidates)\n                current.append(add)\n            else:\n                current.append(removed)\n    # Return neighbor and metadata\n    return current, \"INDEX_LIST\", move\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Sanitize to INDEX_LIST\n    n_items = 24\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        uniq = []\n        seen = set()\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n_items and v not in seen:\n                uniq.append(v)\n                seen.add(v)\n        sol = uniq\n    # Embedded data for feasibility-aware perturbation\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    # Strength proportional to size (3..7 moves)\n    k = max(3, min(7, 1 + len(sol)))\n    for _ in range(k):\n        in_set = set(sol)\n        total_cost = sum(costs[i-1] for i in sol)\n        if total_cost < 670:\n            move = \"add\"\n        else:\n            move = random.choice([\"add\", \"remove\", \"swap\"])\n        if move == \"add\":\n            candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n            if candidates:\n                sol.append(random.choice(candidates))\n        elif move == \"remove\":\n            if sol:\n                # try to keep feasibility if possible\n                for _ in range(3):\n                    ridx = random.randrange(len(sol))\n                    cand = sol[:ridx] + sol[ridx+1:]\n                    if sum(costs[i-1] for i in cand) >= 670:\n                        sol = cand\n                        break\n                else:\n                    ridx = random.randrange(len(sol))\n                    sol.pop(ridx)\n        else:  # swap\n            if sol and len(in_set) < n_items:\n                ridx = random.randrange(len(sol))\n                removed = sol.pop(ridx)\n                in_set.discard(removed)\n                candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n                if candidates:\n                    sol.append(random.choice(candidates))\n                else:\n                    sol.append(removed)\n    # Final sanitization\n    seen = set()\n    cleaned = []\n    for v in sol:\n        if v not in seen:\n            cleaned.append(v)\n            seen.add(v)\n    return cleaned\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST: a Python list of unique integers in the range 1..24; element i present implies x_i=1.","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Validate type and sanitize\n    if not isinstance(solution, list):\n        return 10**12\n    n_items = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n_items:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n    # Constraint handling: require total_cost >= 670\n    if total_cost < 670:\n        penalty = 1000 * (670 - total_cost)\n        return total_points + penalty\n    # Feasible: minimize total_points\n    return total_points\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution):  # returns (neighbor_solution, \"INDEX_LIST\")\n    n_items = 24\n    # Sanitize to INDEX_LIST\n    if not isinstance(solution, list):\n        current = []\n    else:\n        seen = set()\n        current = []\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n_items and v not in seen:\n                current.append(v)\n                seen.add(v)\n    in_set = set(current)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    total_cost = sum(costs[i-1] for i in current)\n    # Feasibility-aware move selection\n    if total_cost < 670:\n        move_choices = [\"add\", \"add\", \"swap\"]\n    else:\n        move_choices = [\"remove\", \"swap\", \"add\"]\n    move = random.choice(move_choices)\n    if move == \"add\":\n        candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n        if candidates:\n            current.append(random.choice(candidates))\n    elif move == \"remove\":\n        if current:\n            # Try to preserve feasibility; allow fallback\n            for _ in range(5):\n                ridx = random.randrange(len(current))\n                cand = current[:ridx] + current[ridx+1:]\n                if sum(costs[i-1] for i in cand) >= 670 or len(current) == 1:\n                    current = cand\n                    break\n            else:\n                current.pop(random.randrange(len(current)))\n    else:  # swap\n        if current:\n            ridx = random.randrange(len(current))\n            removed = current.pop(ridx)\n            in_set.discard(removed)\n            candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n            if candidates:\n                current.append(random.choice(candidates))\n            else:\n                current.append(removed)\n    return current, \"INDEX_LIST\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n_items = 24\n    # Sanitize input\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n_items and v not in seen:\n                sol.append(v)\n                seen.add(v)\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    # Strength: multi-move kick proportional to current size\n    k = max(3, min(7, len(sol) + 1))\n    for _ in range(k):\n        in_set = set(sol)\n        total_cost = sum(costs[i-1] for i in sol)\n        if total_cost < 670:\n            move = \"add\"\n        else:\n            move = random.choice([\"add\", \"remove\", \"swap\"]) \n        if move == \"add\":\n            candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n            if candidates:\n                sol.append(random.choice(candidates))\n        elif move == \"remove\":\n            if sol:\n                # Prefer removing while keeping feasibility if possible\n                for _ in range(3):\n                    ridx = random.randrange(len(sol))\n                    cand = sol[:ridx] + sol[ridx+1:]\n                    if sum(costs[i-1] for i in cand) >= 670:\n                        sol = cand\n                        break\n                else:\n                    sol.pop(random.randrange(len(sol)))\n        else:  # swap\n            if sol and len(in_set) < n_items:\n                ridx = random.randrange(len(sol))\n                removed = sol.pop(ridx)\n                in_set.discard(removed)\n                candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n                if candidates:\n                    sol.append(random.choice(candidates))\n                else:\n                    sol.append(removed)\n    # Deduplicate (should already be unique)\n    seen = set()\n    cleaned = []\n    for v in sol:\n        if v not in seen:\n            cleaned.append(v)\n            seen.add(v)\n    return cleaned\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_party_planning_inverted","Representacion":"INDEX_LIST: a Python list of unique integers in 1..24; i present implies x_i=1.","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Validate and sanitize\n    if not isinstance(solution, list):\n        return 10**12\n    n_items = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    points = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    seen = set()\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return 10**12\n        if idx < 1 or idx > n_items:\n            return 10**12\n        if idx in seen:\n            return 10**12\n        seen.add(idx)\n        i = idx - 1\n        total_cost += costs[i]\n        total_points += points[i]\n    # Constraint handling: require total_cost >= 670\n    if total_cost < 670:\n        # Mild, comparable penalty to objective scale\n        gap = 670 - total_cost\n        penalty_lambda = 2.5\n        return total_points + penalty_lambda * gap\n    # Feasible: minimize total_points\n    return float(total_points)\n","Vecindad":"import random, math\n\ndef generate_neighbour(solution):  # returns (neighbor_solution, \"INDEX_LIST\")\n    n_items = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Sanitize to INDEX_LIST with uniqueness and valid range\n    if not isinstance(solution, list):\n        current = []\n    else:\n        seen = set()\n        current = []\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n_items and v not in seen:\n                current.append(v)\n                seen.add(v)\n\n    # Cache current set and total cost\n    in_set = set(current)\n    total_cost = 0\n    for i in current:\n        total_cost += costs[i - 1]\n\n    # Decide move type with feasibility awareness\n    if total_cost < 670:\n        move_pool = (\"add\", \"add\", \"swap\", \"exchange\")\n    else:\n        move_pool = (\"remove\", \"swap\", \"exchange\", \"add\")\n    move = random.choice(move_pool)\n\n    # Helper: add one random feasible index not in set\n    def do_add(curr, in_s, tot_c):\n        candidates = [i for i in range(1, n_items + 1) if i not in in_s]\n        if not candidates:\n            return curr, in_s, tot_c\n        pick = random.choice(candidates)\n        curr.append(pick)\n        in_s.add(pick)\n        tot_c += costs[pick - 1]\n        return curr, in_s, tot_c\n\n    # Helper: remove one index, prefer keeping feasibility if already feasible\n    def do_remove(curr, in_s, tot_c):\n        if not curr:\n            return curr, in_s, tot_c\n        ridx = random.randrange(len(curr))\n        item = curr[ridx]\n        new_tot = tot_c - costs[item - 1]\n        # If currently feasible, try up to 3 picks to keep feasibility\n        tries = 3 if tot_c >= 670 else 1\n        for _ in range(tries):\n            if tot_c >= 670 and new_tot < 670 and len(curr) > 1:\n                # try a different removal\n                ridx = random.randrange(len(curr))\n                item = curr[ridx]\n                new_tot = tot_c - costs[item - 1]\n                continue\n            break\n        curr.pop(ridx)\n        in_s.discard(item)\n        tot_c = new_tot\n        return curr, in_s, tot_c\n\n    # Helper: 1-1 exchange\n    def do_exchange(curr, in_s, tot_c):\n        if not curr or len(in_s) == n_items:\n            return curr, in_s, tot_c\n        ridx = random.randrange(len(curr))\n        rem = curr[ridx]\n        rem_cost = costs[rem - 1]\n        not_in = [i for i in range(1, n_items + 1) if i not in in_s]\n        add = random.choice(not_in)\n        add_cost = costs[add - 1]\n        new_tot = tot_c - rem_cost + add_cost\n        # If currently feasible, avoid making infeasible when possible\n        if tot_c >= 670 and new_tot < 670:\n            # try another add up to 5 times\n            for _ in range(5):\n                add = random.choice(not_in)\n                add_cost = costs[add - 1]\n                new_tot = tot_c - rem_cost + add_cost\n                if new_tot >= 670:\n                    break\n        curr[ridx] = add\n        in_s.discard(rem)\n        in_s.add(add)\n        tot_c = new_tot\n        return curr, in_s, tot_c\n\n    # Helper: swap = remove then add (possibly same cardinality change if add fails)\n    def do_swap(curr, in_s, tot_c):\n        curr, in_s, tot_c = do_remove(curr, in_s, tot_c)\n        curr, in_s, tot_c = do_add(curr, in_s, tot_c)\n        return curr, in_s, tot_c\n\n    if move == \"add\":\n        current, in_set, total_cost = do_add(current, in_set, total_cost)\n    elif move == \"remove\":\n        current, in_set, total_cost = do_remove(current, in_set, total_cost)\n    elif move == \"exchange\":\n        current, in_set, total_cost = do_exchange(current, in_set, total_cost)\n    else:  # swap\n        current, in_set, total_cost = do_swap(current, in_set, total_cost)\n\n    # Return neighbor and representation type\n    return current, \"INDEX_LIST\"\n","Perturbacion":"import random, math\n\ndef perturb_solution(solution):\n    n_items = 24\n    costs = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n\n    # Sanitize input\n    if not isinstance(solution, list):\n        sol = []\n    else:\n        seen = set()\n        sol = []\n        for v in solution:\n            if isinstance(v, int) and 1 <= v <= n_items and v not in seen:\n                sol.append(v)\n                seen.add(v)\n\n    in_set = set(sol)\n    total_cost = 0\n    for i in sol:\n        total_cost += costs[i - 1]\n\n    # Block perturbation: k random edits biased to preserve feasibility\n    k = max(3, min(7, len(sol) + 2))\n\n    for _ in range(k):\n        move = None\n        if total_cost < 670:\n            move = \"add\"\n        else:\n            move = random.choice([\"add\", \"remove\", \"exchange\"])  # stronger than simple swap\n\n        if move == \"add\":\n            candidates = [i for i in range(1, n_items + 1) if i not in in_set]\n            if candidates:\n                pick = random.choice(candidates)\n                sol.append(pick)\n                in_set.add(pick)\n                total_cost += costs[pick - 1]\n        elif move == \"remove\":\n            if sol:\n                # Prefer removing while keeping feasibility\n                idx = random.randrange(len(sol))\n                item = sol[idx]\n                delta = costs[item - 1]\n                if total_cost - delta < 670 and len(sol) > 1:\n                    # try another up to 3 times\n                    for _try in range(3):\n                        idx2 = random.randrange(len(sol))\n                        item2 = sol[idx2]\n                        if total_cost - costs[item2 - 1] >= 670:\n                            idx = idx2\n                            item = item2\n                            delta = costs[item - 1]\n                            break\n                sol.pop(idx)\n                in_set.discard(item)\n                total_cost -= delta\n        else:  # exchange\n            if sol and len(in_set) < n_items:\n                ridx = random.randrange(len(sol))\n                rem = sol[ridx]\n                rem_cost = costs[rem - 1]\n                not_in = [i for i in range(1, n_items + 1) if i not in in_set]\n                add = random.choice(not_in)\n                add_cost = costs[add - 1]\n                new_tot = total_cost - rem_cost + add_cost\n                if total_cost >= 670 and new_tot < 670:\n                    # try to keep feasibility\n                    for _t in range(5):\n                        add = random.choice(not_in)\n                        add_cost = costs[add - 1]\n                        new_tot = total_cost - rem_cost + add_cost\n                        if new_tot >= 670:\n                            break\n                sol[ridx] = add\n                in_set.discard(rem)\n                in_set.add(add)\n                total_cost = new_tot\n\n    # Deduplicate (already ensured) and return\n    # Also ensure values are ints in range\n    cleaned = []\n    seen = set()\n    for v in sol:\n        if isinstance(v, int) and 1 <= v <= n_items and v not in seen:\n            cleaned.append(v)\n            seen.add(v)\n    return cleaned\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, bytes]) -> float:\n    \"\"\"\n    Minimization fitness. Returns total cost if feasible (gallons >= 67 and valid 24-bit string),\n    else adds dominating penalties. Lower is better.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n\n    # Normalize to str only\n    if isinstance(solution, bytes):\n        try:\n            solution = solution.decode('utf-8')\n        except Exception:\n            return float('inf')\n    if not isinstance(solution, str):\n        return float('inf')\n\n    # Length validation\n    if len(solution) != n:\n        PENALTY_BASE = 10**9\n        return float(PENALTY_BASE + 10**6 * abs(len(solution) - n))\n\n    # Evaluate and validate characters\n    cost = 0\n    total_gal = 0\n    invalid_char_count = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            cost += prices[i]\n            total_gal += gallons[i]\n        elif ch == '0':\n            continue\n        else:\n            invalid_char_count += 1\n\n    required = 67\n    shortage = max(0, required - total_gal)\n\n    if invalid_char_count == 0 and shortage == 0:\n        return float(cost)\n\n    # Dominating penalties\n    PENALTY_BASE = 10**9\n    assert PENALTY_BASE > sum(prices) + 1\n    penalty = PENALTY_BASE\n    penalty += 10**6 * invalid_char_count\n    penalty += 10**5 * shortage\n    return float(cost + penalty)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> Tuple[str, str, str]:\n    \"\"\"\n    Generate a neighbor for 24-length binary string solutions.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n      - NB_Type in {\"Flip\",\"Swap\",\"AddDrop\",\"Repair\"}\n      - Movement_Type describes the specific move\n    Feasibility-aware: performs a light repair to meet gallons >= 67 when possible.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n    required = 67\n\n    # Helper: greedy repair to feasibility (min ratio adds) and gentle pruning of excess\n    def repair(sol_list):\n        # compute cost and gallons\n        cost = 0\n        gal = 0\n        for i,ch in enumerate(sol_list):\n            if ch == '1':\n                cost += prices[i]\n                gal += gallons[i]\n        # If infeasible, add cheapest-per-gallon 0->1 until feasible\n        if gal < required:\n            idxs = [i for i,ch in enumerate(sol_list) if ch == '0']\n            idxs.sort(key=lambda i: (prices[i]\/gallons[i], prices[i]))\n            for i in idxs:\n                sol_list[i] = '1'\n                cost += prices[i]\n                gal += gallons[i]\n                if gal >= required:\n                    break\n        # If large excess, try removing worst items while keeping feasibility\n        if gal >= required:\n            ones = [i for i,ch in enumerate(sol_list) if ch == '1']\n            # Sort by increasing benefit: remove high ratio first\n            ones.sort(key=lambda i: (-(gallons[i]\/prices[i] if prices[i] != 0 else float('inf')),\n                                     prices[i]\/gallons[i]))\n            # Try a few removals safely\n            for i in ones:\n                if gal - gallons[i] >= required:\n                    sol_list[i] = '0'\n                    gal -= gallons[i]\n                    cost -= prices[i]\n        return sol_list\n\n    # Initialize\/repair invalid input\n    s = solution if isinstance(solution, str) else ''\n    if len(s) != n or any(ch not in '01' for ch in s):\n        # Construct greedy feasible seed\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (prices[i]\/gallons[i], prices[i], -gallons[i]))\n        sol_list = ['0']*n\n        total = 0\n        for i in idxs:\n            if total >= required:\n                break\n            sol_list[i] = '1'\n            total += gallons[i]\n        s = ''.join(sol_list)\n\n    sol_list = list(s)\n\n    # Choose move type\n    move_roll = random.random()\n    if move_roll < 0.4:\n        # Single flip\n        pos = random.randrange(n)\n        sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n        NB_Type, Movement_Type = 'Flip', 'SingleBit'\n    elif move_roll < 0.7:\n        # Add\/Drop prioritized by marginal ratios\n        zeros = [i for i,ch in enumerate(sol_list) if ch == '0']\n        ones = [i for i,ch in enumerate(sol_list) if ch == '1']\n        if zeros and random.random() < 0.5:\n            # Add best ratio\n            j = min(zeros, key=lambda i: (prices[i]\/gallons[i], prices[i]))\n            sol_list[j] = '1'\n            NB_Type, Movement_Type = 'AddDrop', 'AddBestRatio'\n        elif ones:\n            # Drop worst ratio that keeps feasibility if possible\n            # compute current gallons\n            cur_gal = sum(gallons[i] for i,ch in enumerate(sol_list) if ch == '1')\n            # candidates that keep feasibility\n            candidates = [i for i in ones if cur_gal - gallons[i] >= required]\n            if candidates:\n                i = max(candidates, key=lambda k: (prices[k]\/gallons[k], prices[k]))\n                sol_list[i] = '0'\n                NB_Type, Movement_Type = 'AddDrop', 'DropWorstSafe'\n            else:\n                # forced drop (may become infeasible; repair later)\n                i = max(ones, key=lambda k: (prices[k]\/gallons[k], prices[k]))\n                sol_list[i] = '0'\n                NB_Type, Movement_Type = 'AddDrop', 'DropWorstForced'\n        else:\n            # fallback flip\n            pos = random.randrange(n)\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n            NB_Type, Movement_Type = 'Flip', 'Fallback'\n    else:\n        # Swap: remove one high-ratio 1 and add one low-ratio 0\n        ones = [i for i,ch in enumerate(sol_list) if ch == '1']\n        zeros = [i for i,ch in enumerate(sol_list) if ch == '0']\n        if ones and zeros:\n            i = max(ones, key=lambda k: (prices[k]\/gallons[k], prices[k]))\n            j = min(zeros, key=lambda k: (prices[k]\/gallons[k], prices[k]))\n            sol_list[i] = '0'\n            sol_list[j] = '1'\n            NB_Type, Movement_Type = 'Swap', 'DropWorst_AddBest'\n        else:\n            # fallback flip\n            pos = random.randrange(n)\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n            NB_Type, Movement_Type = 'Flip', 'Fallback'\n\n    # Light repair to ensure feasibility and reduce excess\n    sol_list = repair(sol_list)\n\n    neighbor = ''.join(sol_list)\n    return neighbor, NB_Type, Movement_Type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    \"\"\"\n    Strong perturbation for 24-bit solutions combining multi-bit flips, block toggle, and ruin-and-recreate with repair.\n    Returns a valid 24-length binary string; applies a repair step to meet gallons >= 67.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n    required = 67\n\n    def repair(sol_list: List[str]) -> List[str]:\n        # compute totals\n        cost = 0\n        gal = 0\n        for i,ch in enumerate(sol_list):\n            if ch == '1':\n                cost += prices[i]\n                gal += gallons[i]\n        if gal < required:\n            idxs = [i for i,ch in enumerate(sol_list) if ch == '0']\n            idxs.sort(key=lambda i: (prices[i]\/gallons[i], prices[i]))\n            for i in idxs:\n                sol_list[i] = '1'\n                gal += gallons[i]\n                if gal >= required:\n                    break\n        if gal >= required:\n            ones = [i for i,ch in enumerate(sol_list) if ch == '1']\n            ones.sort(key=lambda i: (-gallons[i]\/prices[i] if prices[i] else float('inf'), prices[i]\/gallons[i]))\n            for i in ones:\n                if gal - gallons[i] >= required:\n                    sol_list[i] = '0'\n                    gal -= gallons[i]\n        return sol_list\n\n    # Normalize\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        # greedy feasible seed\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (prices[i]\/gallons[i], prices[i], -gallons[i]))\n        sol_list = ['0']*n\n        total = 0\n        for i in idxs:\n            if total >= required:\n                break\n            sol_list[i] = '1'\n            total += gallons[i]\n    else:\n        sol_list = list(solution)\n\n    # Choose a strong perturbation mode\n    mode = random.random()\n    if mode < 0.4:\n        # k random flips (k in {3,4,5})\n        k = random.choice([3,4,5])\n        positions = random.sample(range(n), k)\n        for pos in positions:\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n    elif mode < 0.75:\n        # Block toggle: pick a random contiguous block and flip all\n        a = random.randrange(n)\n        b = random.randrange(n)\n        if a > b:\n            a, b = b, a\n        if a == b:\n            b = min(n-1, a+random.randint(1, 4))\n        for pos in range(a, b+1):\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n    else:\n        # Ruin-and-recreate: drop a random subset of 1s, then greedy repair\n        ones = [i for i,ch in enumerate(sol_list) if ch == '1']\n        drop_count = max(1, int(0.3*len(ones))) if ones else 1\n        drop = set(random.sample(ones, min(drop_count, len(ones))))\n        for i in drop:\n            sol_list[i] = '0'\n        # optionally add a couple of cheap zeros\n        zeros = [i for i,ch in enumerate(sol_list) if ch == '0']\n        zeros.sort(key=lambda i: (prices[i]\/gallons[i], prices[i]))\n        for i in zeros[:random.randint(0,2)]:\n            sol_list[i] = '1'\n\n    # Repair to feasibility and trim excess\n    sol_list = repair(sol_list)\n\n    return ''.join(sol_list)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\nfrom typing import Union\n\ndef evaluate_solution(solution: Union[str, bytes]) -> float:\n    \"\"\"\n    Minimization fitness. Returns total cost if feasible (gallons >= 67 and valid 24-bit string),\n    else adds structured penalties. Lower is better.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n\n    # Normalize to str only\n    if isinstance(solution, bytes):\n        try:\n            solution = solution.decode('utf-8')\n        except UnicodeDecodeError:\n            return float('inf')\n    if not isinstance(solution, str):\n        return float('inf')\n\n    # Length validation\n    if len(solution) != n:\n        # Dominating length penalty\n        return float(1e7 + 1e5 * abs(len(solution) - n))\n\n    # Evaluate and validate characters\n    cost = 0\n    total_gal = 0\n    invalid_char_count = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            cost += prices[i]\n            total_gal += gallons[i]\n        elif ch == '0':\n            continue\n        else:\n            invalid_char_count += 1\n\n    if invalid_char_count > 0:\n        return float(cost + 1e4 * invalid_char_count)\n\n    required = 67\n    if total_gal >= required:\n        return float(cost)\n\n    shortage = required - total_gal\n    # Shortage penalty dominates any feasible cost\n    return float(cost + 1_000_000 * shortage)\n","Vecindad":"import random\nfrom typing import Tuple\n\ndef generate_neighbour(solution) -> Tuple[str, str, str]:\n    \"\"\"\n    Feasibility-aware neighbor generator for 24-length binary string solutions.\n    Returns: (neighbor_solution, NB_Type, Movement_Type)\n    NB_Type in {\"Flip\",\"Swap\",\"AddDrop\",\"Repair\"}\n    Movement_Type describes the specific move.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n    required = 67\n\n    def ratio(i):\n        g = gallons[i]\n        return (prices[i] \/ g) if g != 0 else float('inf')\n\n    def repair(sol_list):\n        # compute totals\n        gal = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                gal += gallons[i]\n        # If infeasible, add cheapest-per-gallon 0->1 until feasible\n        if gal < required:\n            zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n            zeros.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n            for idx in zeros:\n                sol_list[idx] = '1'\n                gal += gallons[idx]\n                if gal >= required:\n                    break\n        # If feasible, try to drop worst ratio items while staying feasible\n        if gal >= required:\n            ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n            # Remove by decreasing price-per-gallon (worst first)\n            ones.sort(key=lambda i: (ratio(i), -gallons[i], prices[i]), reverse=True)\n            for idx in ones:\n                if gal - gallons[idx] >= required:\n                    sol_list[idx] = '0'\n                    gal -= gallons[idx]\n        return sol_list\n\n    # Initialize\/repair invalid input\n    s = solution if isinstance(solution, str) else ''\n    if len(s) != n or any(ch not in '01' for ch in s):\n        # Construct greedy feasible seed by ratio\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n        sol_list = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total >= required:\n                break\n            sol_list[i] = '1'\n            total += gallons[i]\n        s = ''.join(sol_list)\n\n    sol_list = list(s)\n\n    # Compute current gallons to guide safe moves\n    cur_gal = sum(gallons[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    roll = random.random()\n    if roll < 0.2:\n        # Safe drop if possible else fallback flip of a random bit\n        ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n        safe = [i for i in ones if cur_gal - gallons[i] >= required]\n        if safe:\n            i = max(safe, key=lambda k: (ratio(k), -gallons[k], prices[k]))\n            sol_list[i] = '0'\n            NB_Type, Movement_Type = 'AddDrop', 'DropWorstSafe'\n        else:\n            pos = random.randrange(n)\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n            NB_Type, Movement_Type = 'Flip', 'SingleBit'\n    elif roll < 0.65:\n        # Add best ratio zero or safe drop if overfilled\n        zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n        if zeros:\n            j = min(zeros, key=lambda i: (ratio(i), prices[i], -gallons[i]))\n            sol_list[j] = '1'\n            NB_Type, Movement_Type = 'AddDrop', 'AddBestRatio'\n        else:\n            pos = random.randrange(n)\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n            NB_Type, Movement_Type = 'Flip', 'Fallback'\n    elif roll < 0.9:\n        # Swap: drop worst-safe and add best-ratio zero\n        ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n        safe = [i for i in ones if cur_gal - gallons[i] >= required]\n        if safe and zeros:\n            i = max(safe, key=lambda k: (ratio(k), -gallons[k], prices[k]))\n            j = min(zeros, key=lambda k: (ratio(k), prices[k], -gallons[k]))\n            sol_list[i] = '0'\n            sol_list[j] = '1'\n            NB_Type, Movement_Type = 'Swap', 'DropWorstSafe_AddBest'\n        else:\n            pos = random.randrange(n)\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n            NB_Type, Movement_Type = 'Flip', 'Fallback'\n    else:\n        # Light repair move (intensification)\n        sol_list = repair(sol_list)\n        NB_Type, Movement_Type = 'Repair', 'GreedyTrim'\n\n    # Ensure feasibility and gentle trimming\n    sol_list = repair(sol_list)\n    neighbor = ''.join(sol_list)\n    return neighbor, NB_Type, Movement_Type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: str) -> str:\n    \"\"\"\n    Strong perturbation: perform t in {2,3,4} iterations of (Drop worst-safe, Add best-ratio),\n    then repair to feasibility and trim excess.\n    Returns a valid 24-length binary string.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n    required = 67\n\n    def ratio(i):\n        g = gallons[i]\n        return (prices[i] \/ g) if g != 0 else float('inf')\n\n    def repair(sol_list: List[str]) -> List[str]:\n        gal = 0\n        for i, ch in enumerate(sol_list):\n            if ch == '1':\n                gal += gallons[i]\n        if gal < required:\n            zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n            zeros.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n            for idx in zeros:\n                sol_list[idx] = '1'\n                gal += gallons[idx]\n                if gal >= required:\n                    break\n        if gal >= required:\n            ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n            ones.sort(key=lambda i: (ratio(i), -gallons[i], prices[i]), reverse=True)\n            for idx in ones:\n                if gal - gallons[idx] >= required:\n                    sol_list[idx] = '0'\n                    gal -= gallons[idx]\n        return sol_list\n\n    # Normalize\/initialize\n    if not isinstance(solution, str) or len(solution) != n or any(ch not in '01' for ch in solution):\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n        sol_list = ['0'] * n\n        total = 0\n        for i in idxs:\n            if total >= required:\n                break\n            sol_list[i] = '1'\n            total += gallons[i]\n    else:\n        sol_list = list(solution)\n\n    # Perturbation strength\n    t = random.choice([2, 3, 4])\n    for _ in range(t):\n        # Drop worst-safe if possible\n        gal = sum(gallons[i] for i, ch in enumerate(sol_list) if ch == '1')\n        ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n        safe = [i for i in ones if gal - gallons[i] >= required]\n        if safe:\n            i = max(safe, key=lambda k: (ratio(k), -gallons[k], prices[k]))\n            sol_list[i] = '0'\n            gal -= gallons[i]\n        # Add best-ratio zero\n        zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n        if zeros:\n            j = min(zeros, key=lambda k: (ratio(k), prices[k], -gallons[k]))\n            sol_list[j] = '1'\n\n    # Final repair and trim\n    sol_list = repair(sol_list)\n    return ''.join(sol_list)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_lemonade_stand_inverted","Representacion":"BIN_STR_LEN_24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Minimization fitness for 24-bit binary string. Lower is better.\n    Returns exact total cost if feasible (sum gallons >= 67), else a dominating penalty.\n    Hard-rejects invalid types\/length\/chars.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n    required = 67\n\n    # Type and length validation\n    if not isinstance(solution, str):\n        return float(1e12)\n    if len(solution) != n:\n        return float(1e12)\n    if any(ch not in '01' for ch in solution):\n        return float(1e12)\n\n    cost = 0\n    gal = 0\n    for i, ch in enumerate(solution):\n        if ch == '1':\n            cost += prices[i]\n            gal += gallons[i]\n\n    if gal >= required:\n        return float(cost)\n\n    shortage = required - gal\n    # Penalty dominates any feasible cost landscape\n    return float(1e9 + 1e6 * shortage + cost)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    \"\"\"\n    Feasibility-preserving neighbor for 24-bit binaries. Returns (neighbor_str, NB_Type, Movement_Type).\n    Moves: Add\/Drop\/Flip (feasible), 1-1 Swap, 1-2 or 2-1 ejection chains. Single repair at end.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n    required = 67\n\n    def ratio(i):\n        g = gallons[i]\n        return (prices[i] \/ g) if g else float('inf')\n\n    def greedy_seed_grasp(alpha=0.3):\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n        sol = ['0'] * n\n        gal = 0\n        start = 0\n        # GRASP-style: choose among top-k candidates each iteration\n        while gal < required and start < n:\n            k = max(1, int(alpha * (n - start)))\n            cand = idxs[start:start + k]\n            j = random.choice(cand)\n            if sol[j] == '0':\n                sol[j] = '1'\n                gal += gallons[j]\n            start += 1\n        # Final trim (safe)\n        sol = repair(sol)\n        return sol\n\n    def repair(sol_list):\n        # Make feasible by adding best ratio zeros\n        gal = sum(gallons[i] for i, ch in enumerate(sol_list) if ch == '1')\n        if gal < required:\n            zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n            zeros.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n            for idx in zeros:\n                sol_list[idx] = '1'\n                gal += gallons[idx]\n                if gal >= required:\n                    break\n        # Trim unnecessary items by worst ratio while staying feasible\n        if gal >= required:\n            ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n            # Randomized tie-breaking via slight jitter\n            jitter = {i: ratio(i) + random.random() * 1e-9 for i in ones}\n            ones.sort(key=lambda i: (jitter[i], -gallons[i], prices[i]), reverse=True)\n            for idx in ones:\n                if gal - gallons[idx] >= required:\n                    sol_list[idx] = '0'\n                    gal -= gallons[idx]\n        return sol_list\n\n    # Normalize\/initialize solution\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        sol_list = greedy_seed_grasp(alpha=0.35)\n    else:\n        sol_list = list(solution)\n\n    # Precompute state\n    cur_gal = sum(gallons[i] for i, ch in enumerate(sol_list) if ch == '1')\n\n    move_r = random.random()\n    NB_Type = 'Flip'\n    Movement_Type = 'SingleBit'\n\n    if move_r < 0.5:\n        # Add best or safe drop worst, else flip random\n        zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n        ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n        safe_drops = [i for i in ones if cur_gal - gallons[i] >= required]\n        choose_add = (cur_gal < required) or (not safe_drops) or (random.random() < 0.6)\n        if choose_add and zeros:\n            j = min(zeros, key=lambda i: (ratio(i), prices[i], -gallons[i]))\n            sol_list[j] = '1'\n            NB_Type, Movement_Type = 'AddDrop', 'AddBestRatio'\n        elif safe_drops:\n            i = max(safe_drops, key=lambda k: (ratio(k), -gallons[k], prices[k]))\n            sol_list[i] = '0'\n            NB_Type, Movement_Type = 'AddDrop', 'DropWorstSafe'\n        else:\n            pos = random.randrange(n)\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n            NB_Type, Movement_Type = 'Flip', 'Fallback'\n\n    elif move_r < 0.8:\n        # 1-1 swap: drop worst-safe add best-zero\n        ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n        zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n        safe = [i for i in ones if cur_gal - gallons[i] >= required]\n        if safe and zeros:\n            i = max(safe, key=lambda k: (ratio(k), -gallons[k], prices[k]))\n            j = min(zeros, key=lambda k: (ratio(k), prices[k], -gallons[k]))\n            sol_list[i] = '0'\n            sol_list[j] = '1'\n            NB_Type, Movement_Type = 'Swap', 'DropWorstSafe_AddBest'\n        else:\n            pos = random.randrange(n)\n            sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n            NB_Type, Movement_Type = 'Flip', 'Fallback'\n\n    else:\n        # Ejection chain: 1-2 or 2-1\n        if random.random() < 0.5:\n            # 1-2: drop one safe, add two good zeros\n            ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n            zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n            safe = [i for i in ones if cur_gal - gallons[i] >= required]\n            if safe and len(zeros) >= 2:\n                i = max(safe, key=lambda k: (ratio(k), -gallons[k], prices[k]))\n                sol_list[i] = '0'\n                # choose two best zeros with randomized tie-break\n                zeros.sort(key=lambda k: (ratio(k) + random.random()*1e-9, prices[k], -gallons[k]))\n                for j in zeros[:2]:\n                    sol_list[j] = '1'\n                NB_Type, Movement_Type = 'Ejection', '1to2_DropWorst_Add2Best'\n            else:\n                pos = random.randrange(n)\n                sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n                NB_Type, Movement_Type = 'Flip', 'Fallback'\n        else:\n            # 2-1: drop two safe (sequentially safe), add one best zero\n            ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n            zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n            gal = cur_gal\n            drops = []\n            if ones:\n                # choose two worst by ratio that are sequentially safe\n                cand = sorted(ones, key=lambda k: (ratio(k), -gallons[k], prices[k]), reverse=True)\n                for idx in cand:\n                    if gal - gallons[idx] >= required:\n                        drops.append(idx)\n                        gal -= gallons[idx]\n                        if len(drops) == 2:\n                            break\n            if len(drops) >= 1 and zeros:\n                for i in drops:\n                    sol_list[i] = '0'\n                j = min(zeros, key=lambda k: (ratio(k), prices[k], -gallons[k]))\n                sol_list[j] = '1'\n                NB_Type, Movement_Type = 'Ejection', '2to1_Drop2Worst_AddBest'\n            else:\n                pos = random.randrange(n)\n                sol_list[pos] = '1' if sol_list[pos] == '0' else '0'\n                NB_Type, Movement_Type = 'Flip', 'Fallback'\n\n    # Single repair and trim to ensure feasibility and light optimality\n    sol_list = repair(sol_list)\n    neighbor = ''.join(sol_list)\n    return neighbor, NB_Type, Movement_Type\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Strong perturbation: randomized k-flip (k in [3..6]) with bias plus greedy repair+trim.\n    Returns a valid 24-length binary string.\n    \"\"\"\n    prices = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    gallons = [11,23,22,10,17,20,11,24,19,8,14,20,22,16,13,5,4,22,23,9,22,6,20,10]\n    n = 24\n    required = 67\n\n    def ratio(i):\n        g = gallons[i]\n        return (prices[i] \/ g) if g else float('inf')\n\n    def repair(sol_list):\n        gal = sum(gallons[i] for i, ch in enumerate(sol_list) if ch == '1')\n        if gal < required:\n            zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n            zeros.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n            for idx in zeros:\n                sol_list[idx] = '1'\n                gal += gallons[idx]\n                if gal >= required:\n                    break\n        if gal >= required:\n            ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n            ones.sort(key=lambda i: (ratio(i), -gallons[i], prices[i]), reverse=True)\n            for idx in ones:\n                if gal - gallons[idx] >= required:\n                    sol_list[idx] = '0'\n                    gal -= gallons[idx]\n        return sol_list\n\n    def greedy_seed():\n        idxs = list(range(n))\n        idxs.sort(key=lambda i: (ratio(i), prices[i], -gallons[i]))\n        sol = ['0'] * n\n        gal = 0\n        for i in idxs:\n            sol[i] = '1'\n            gal += gallons[i]\n            if gal >= required:\n                break\n        return sol\n\n    # Normalize input\n    if not isinstance(solution, str) or len(solution) != n or any(c not in '01' for c in solution):\n        sol_list = greedy_seed()\n    else:\n        sol_list = list(solution)\n\n    # Choose k and indices with bias: prefer flipping high ratio ones and low ratio zeros\n    k = random.choice([3, 4, 5, 6])\n    ones = [i for i, ch in enumerate(sol_list) if ch == '1']\n    zeros = [i for i, ch in enumerate(sol_list) if ch == '0']\n\n    ones_sorted = sorted(ones, key=lambda i: (ratio(i), -gallons[i], prices[i]), reverse=True)\n    zeros_sorted = sorted(zeros, key=lambda i: (ratio(i), prices[i], -gallons[i]))\n\n    flips = []\n    take_ones = min(len(ones_sorted), max(1, k \/\/ 2))\n    take_zeros = min(len(zeros_sorted), k - take_ones)\n\n    flips.extend(ones_sorted[:take_ones])\n    flips.extend(zeros_sorted[:take_zeros])\n    # If still need, fill randomly\n    remaining = k - len(flips)\n    if remaining > 0:\n        pool = list(set(range(n)) - set(flips))\n        random.shuffle(pool)\n        flips.extend(pool[:remaining])\n\n    for idx in flips:\n        sol_list[idx] = '0' if sol_list[idx] == '1' else '1'\n\n    # Final repair and trim\n    sol_list = repair(sol_list)\n    return ''.join(sol_list)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_PYLIST_ASC","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Representation validation: list of unique ascending ints within 1..n\n    if not isinstance(solution, list):\n        return float('inf')\n    if any((not isinstance(i, int)) for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(i < 1 or i > n for i in solution):\n        return float('inf')\n    if solution != sorted(solution):\n        return float('inf')\n\n    total_score = 0\n    total_time = 0\n    for i in solution:\n        idx = i - 1\n        total_score += scores[idx]\n        total_time += times[idx]\n\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        # Heavy penalty for infeasible; small tie-breaker by score\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n\n    # Feasible: minimize score; tiny tie-breaker on time to prefer larger time if same score\n    return float(total_score) + (float(total_time) * 1e-6)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Embedded problem data for adaptive move bias\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = 24\n\n    # Start from a repaired copy (ascending, unique, in-range)\n    if isinstance(solution, list):\n        cur = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    else:\n        cur = []\n    cur = sorted(set(cur))\n\n    # Compute current time to bias moves\n    cur_time = sum(times[i-1] for i in cur)\n\n    # Build fast membership set and missing list\n    present_set = set(cur)\n    missing = [i for i in range(1, n+1) if i not in present_set]\n\n    r = random.random()\n    nb = cur[:]\n\n    # Adaptive move selection: if under time, prefer add; if well over, prefer remove; else swap\n    if cur_time < TIME_REQ:\n        # Prefer add, fallback to swap\n        if missing and (r < 0.85 or not nb):\n            k = random.choice(missing)\n            nb.append(k)\n            nb.sort()\n        else:\n            if nb and missing:\n                rem = random.choice(nb)\n                add = random.choice(missing)\n                nb.remove(rem)\n                nb.append(add)\n                nb.sort()\n    else:\n        # Feasible: mostly remove or swap to try reducing score\n        if nb and (r < 0.6 or not missing):\n            # remove a random index\n            k = random.randrange(len(nb))\n            nb.pop(k)\n        else:\n            if nb and missing:\n                rem = random.choice(nb)\n                add = random.choice(missing)\n                nb.remove(rem)\n                nb.append(add)\n                nb.sort()\n\n    return nb\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Strong perturbation with bias: remove some low time\/score ratio (weak) items and add high ratio items\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    n = 24\n\n    # Repair input\n    nb = []\n    if isinstance(solution, list):\n        nb = sorted(set([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n\n    # Compute t\/s ratios\n    ratio = [(i, times[i-1] \/ scores[i-1]) for i in range(1, n+1)]\n    high = [i for i,_ in sorted(ratio, key=lambda x: -x[1])]\n    low  = [i for i,_ in sorted(ratio, key=lambda x: x[1])]\n\n    steps = 6 + random.randrange(6)  # 6..11 edits\n    for _ in range(steps):\n        move = random.random()\n        present = set(nb)\n        missing = [i for i in high if i not in present]\n        if move < 0.34:\n            # add from top of high-ratio pool\n            cand = [i for i in high[:8] if i not in present] or missing\n            if cand:\n                nb.append(random.choice(cand))\n                nb = sorted(set(nb))\n        elif move < 0.68:\n            # remove from worst present (low ratio first)\n            cand = [i for i in low[:8] if i in present] or list(present)\n            if cand:\n                k = random.choice(cand)\n                nb.remove(k)\n        else:\n            # swap: remove a low-ratio present and add a high-ratio missing\n            rem_cand = [i for i in low[:8] if i in present] or list(present)\n            add_cand = [i for i in high[:8] if i not in present] or missing\n            if rem_cand and add_cand:\n                rem = random.choice(rem_cand)\n                add = random.choice(add_cand)\n                if rem in nb:\n                    nb.remove(rem)\n                nb.append(add)\n                nb = sorted(set(nb))\n\n    return nb\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_PYLIST_ASC","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]) -> float:\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Validate representation: list of unique ascending ints within 1..n\n    if not isinstance(solution, list):\n        return float('inf')\n    if any((not isinstance(i, int)) for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(i < 1 or i > n for i in solution):\n        return float('inf')\n    if solution != sorted(solution):\n        return float('inf')\n\n    total_score = 0\n    total_time = 0\n    for i in solution:\n        idx = i - 1\n        total_score += scores[idx]\n        total_time += times[idx]\n\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        # Heavy penalty for infeasible; tiny tie-breaker on score\n        return 1_000_000.0 + float(deficit) + (float(total_score) * 1e-6)\n\n    # Feasible: minimize score; tie-breaker prefers smaller time when scores tie\n    return float(total_score) - (float(total_time) * 1e-6)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef _repair(solution: List[int], n: int) -> List[int]:\n    if not isinstance(solution, list):\n        return []\n    sol = [i for i in solution if isinstance(i, int) and 1 <= i <= n]\n    sol = sorted(set(sol))\n    return sol\n\n\ndef generate_neighbour(solution: List[int]):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = 24\n\n    cur = _repair(solution, n)\n    present = set(cur)\n    missing = [i for i in range(1, n+1) if i not in present]\n\n    cur_time = sum(times[i-1] for i in cur)\n\n    # Movement selection probabilities adapt to feasibility slack\n    deficit = max(0, TIME_REQ - cur_time)\n    slack = max(0, cur_time - TIME_REQ)\n\n    # Define helper for feasibility-preserving removal: remove worst score\/time if possible\n    def try_targeted_remove(sol: List[int]) -> Tuple[List[int], bool]:\n        if not sol:\n            return sol, False\n        # Sort present by increasing time per score to remove least efficient time for score (i.e., high score\/low time)\n        # But we need to keep feasibility: test candidates in increasing ratio of (time\/score) removal impact\n        order = sorted(sol, key=lambda k: (scores[k-1]\/max(1e-9, times[k-1]), scores[k-1]))  # higher score per time first at end\n        # Try removing items that keep time >= TIME_REQ\n        for k in order[::-1]:  # remove worst (highest score per time) first\n            new_time = cur_time - times[k-1]\n            if new_time >= TIME_REQ:\n                new_sol = sol.copy()\n                new_sol.remove(k)\n                return new_sol, True\n        return sol, False\n\n    nb = cur.copy()\n    r = random.random()\n    move_type = \"noop\"\n\n    if cur_time < TIME_REQ:\n        # Prefer add or swap-in of high time\/score items\n        if missing and (r < 0.75 or not nb):\n            # add a high t\/s candidate\n            ratio = [(i, times[i-1]\/scores[i-1]) for i in missing]\n            cand = max(ratio, key=lambda x: x[1])[0]\n            nb.append(cand)\n            nb.sort()\n            move_type = \"add\"\n        else:\n            # 1-1 swap\n            if nb and missing:\n                rem = random.choice(nb)\n                # prefer adding a better ratio than removed\n                ratio_missing = sorted(missing, key=lambda i: times[i-1]\/scores[i-1], reverse=True)\n                add = ratio_missing[0]\n                nb.remove(rem)\n                nb.append(add)\n                nb.sort()\n                move_type = \"swap1-1\"\n    else:\n        # Feasible: attempt feasibility-preserving removal, else 1-1 exchange aimed at reducing score\n        if r < 0.55:\n            cand, ok = try_targeted_remove(nb)\n            if ok:\n                nb = cand\n                move_type = \"remove\"\n            else:\n                # fallback to 1-1 exchange that reduces score if possible while keeping feasibility\n                if nb and missing:\n                    # choose rem that is expensive per time, add that is cheap per time\n                    rem = max(nb, key=lambda i: scores[i-1]\/max(1e-9, times[i-1]))\n                    add = min(missing, key=lambda i: scores[i-1]\/max(1e-9, times[i-1]))\n                    # apply swap only if time after swap >= TIME_REQ\n                    new_time = cur_time - times[rem-1] + times[add-1]\n                    if new_time >= TIME_REQ:\n                        nb.remove(rem)\n                        nb.append(add)\n                        nb.sort()\n                        move_type = \"swap1-1\"\n                    else:\n                        # minor diversification: 2-swap attempt\n                        move_type = \"noop\"\n        elif r < 0.85 and nb and missing:\n            # 1-1 exchange (diversification)\n            rem = random.choice(nb)\n            add = random.choice(missing)\n            new_time = cur_time - times[rem-1] + times[add-1]\n            if new_time >= TIME_REQ:\n                nb.remove(rem)\n                nb.append(add)\n                nb.sort()\n                move_type = \"swap1-1\"\n            else:\n                move_type = \"noop\"\n        else:\n            # Occasional add to thicken solution then future removals can prune\n            if missing:\n                add = max(missing, key=lambda i: times[i-1]\/scores[i-1])\n                nb.append(add)\n                nb.sort()\n                move_type = \"add\"\n\n    return nb, \"NB_Generic\", move_type\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = 24\n\n    # Repair\n    if not isinstance(solution, list):\n        nb = []\n    else:\n        nb = sorted(set([i for i in solution if isinstance(i, int) and 1 <= i <= n]))\n\n    rng = random\n\n    # Compute ratios once\n    ratio_ts = [(i, times[i-1]\/scores[i-1]) for i in range(1, n+1)]\n    high = [i for i, _ in sorted(ratio_ts, key=lambda x: -x[1])]\n    low = [i for i, _ in sorted(ratio_ts, key=lambda x: x[1])]\n\n    # k-move perturbation with adaptive magnitude\n    k = rng.randint(2, 4)\n    for _ in range(k):\n        present = set(nb)\n        missing = [i for i in range(1, n+1) if i not in present]\n        move = rng.random()\n        if move < 0.34 and missing:\n            # add from top high-ratio pool\n            pool = [i for i in high[:8] if i in missing] or missing\n            nb.append(rng.choice(pool))\n            nb = sorted(set(nb))\n        elif move < 0.68 and nb:\n            # remove from worst present (low ratio first)\n            pool = [i for i in low[:8] if i in present] or list(present)\n            if pool:\n                rem = rng.choice(pool)\n                if rem in nb:\n                    nb.remove(rem)\n        else:\n            # swap: low-out, high-in\n            rem_pool = [i for i in low[:8] if i in present] or list(present)\n            add_pool = [i for i in high[:8] if i in missing] or missing\n            if rem_pool and add_pool:\n                rem = rng.choice(rem_pool)\n                add = rng.choice(add_pool)\n                if rem in nb:\n                    nb.remove(rem)\n                nb.append(add)\n                nb = sorted(set(nb))\n\n    # Light repair: if infeasible, greedily add high t\/s until feasible; if far over, try one targeted removal\n    def total_time(sol: List[int]) -> int:\n        return sum(times[i-1] for i in sol)\n\n    cur_time = total_time(nb)\n    if cur_time < TIME_REQ:\n        present = set(nb)\n        missing = [i for i in range(1, n+1) if i not in present]\n        missing_sorted = sorted(missing, key=lambda i: times[i-1]\/scores[i-1], reverse=True)\n        for a in missing_sorted:\n            nb.append(a)\n            nb = sorted(set(nb))\n            if total_time(nb) >= TIME_REQ:\n                break\n    else:\n        # attempt one feasibility-preserving removal with worst score\/time\n        order = sorted(nb, key=lambda k: scores[k-1]\/max(1e-9, times[k-1]), reverse=True)\n        for rem in order:\n            new_time = cur_time - times[rem-1]\n            if new_time >= TIME_REQ:\n                nb.remove(rem)\n                break\n\n    return nb\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_8_sightseeing_inverted","Representacion":"INDEX_LIST_PYLIST_ASC","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = len(scores)\n\n    # Validate representation: list of unique ascending ints within 1..n\n    if not isinstance(solution, list):\n        return float('inf')\n    if any((not isinstance(i, int)) for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n    if any(i < 1 or i > n for i in solution):\n        return float('inf')\n    if solution != sorted(solution):\n        return float('inf')\n\n    total_score = 0\n    total_time = 0\n    for i in solution:\n        idx = i - 1\n        total_score += scores[idx]\n        total_time += times[idx]\n\n    if total_time < TIME_REQ:\n        deficit = TIME_REQ - total_time\n        # Strong penalty prioritizing closing time deficit, then increasing time, then reducing score\n        return 1_000_000.0 + float(deficit) - 1e-3*float(total_time) + 1e-6*float(total_score)\n\n    # Feasible: minimize score; tie-breaker prefers larger time very slightly (to avoid borderline)\n    return float(total_score) - (float(total_time) * 1e-6)\n","Vecindad":"import math\nimport random\n\n\ndef generate_neighbour(solution):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = 24\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            return []\n        sol2 = [i for i in sol if isinstance(i, int) and 1 <= i <= n]\n        sol2 = sorted(set(sol2))\n        return sol2\n\n    cur = repair(solution)\n\n    def current_time(sol):\n        return sum(times[i-1] for i in sol)\n\n    attempts = 0\n    nb = cur[:]\n    move_type = \"noop\"\n\n    while attempts < 8:\n        attempts += 1\n        present = set(nb)\n        missing = [i for i in range(1, n+1) if i not in present]\n        cur_time = current_time(nb)\n        deficit = max(0, TIME_REQ - cur_time)\n\n        r = random.random()\n        candidate = nb[:]\n        move_type = \"noop\"\n\n        if deficit > 0:\n            # Infeasible: prefer add or improving swap-in by high time\/score\n            if missing and (r < 0.7 or not candidate):\n                add = max(missing, key=lambda i: times[i-1]\/scores[i-1])\n                candidate.append(add)\n                candidate = sorted(set(candidate))\n                move_type = \"add\"\n            else:\n                if candidate and missing:\n                    # 1-1 swap: remove worst score per time, add best time per score\n                    rem = max(candidate, key=lambda i: scores[i-1]\/max(1e-9, times[i-1]))\n                    add = max(missing, key=lambda i: times[i-1]\/scores[i-1])\n                    candidate.remove(rem)\n                    candidate.append(add)\n                    candidate = sorted(set(candidate))\n                    move_type = \"swap1-1\"\n        else:\n            # Feasible: try to reduce score while keeping feasibility\n            if r < 0.55 and candidate:\n                # targeted removal: remove item with highest score per time if feasible\n                ordered = sorted(candidate, key=lambda k: scores[k-1]\/max(1e-9, times[k-1]), reverse=True)\n                removed = False\n                base_time = cur_time\n                for rem in ordered:\n                    if base_time - times[rem-1] >= TIME_REQ:\n                        candidate2 = candidate[:]\n                        candidate2.remove(rem)\n                        candidate = candidate2\n                        move_type = \"remove\"\n                        removed = True\n                        break\n                if not removed and missing:\n                    # try improving swap preserving feasibility\n                    rem = max(candidate, key=lambda i: scores[i-1]\/max(1e-9, times[i-1]))\n                    add = min(missing, key=lambda i: scores[i-1]\/max(1e-9, times[i-1]))\n                    if cur_time - times[rem-1] + times[add-1] >= TIME_REQ:\n                        candidate.remove(rem)\n                        candidate.append(add)\n                        candidate = sorted(set(candidate))\n                        move_type = \"swap1-1\"\n            elif r < 0.85 and candidate and missing:\n                # Diversification 1-1 swap if feasible\n                rem = random.choice(candidate)\n                add = random.choice(missing)\n                if cur_time - times[rem-1] + times[add-1] >= TIME_REQ:\n                    candidate.remove(rem)\n                    candidate.append(add)\n                    candidate = sorted(set(candidate))\n                    move_type = \"swap1-1\"\n            else:\n                # Occasionally add a good time\/score item to enable future pruning\n                if missing:\n                    add = max(missing, key=lambda i: times[i-1]\/scores[i-1])\n                    candidate.append(add)\n                    candidate = sorted(set(candidate))\n                    move_type = \"add\"\n\n        candidate = repair(candidate)\n        if candidate != cur:\n            nb = candidate\n            break\n\n    if nb == cur:\n        # force a minimal change\n        present = set(cur)\n        missing = [i for i in range(1, n+1) if i not in present]\n        if current_time(cur) < TIME_REQ and missing:\n            add = max(missing, key=lambda i: times[i-1]\/scores[i-1])\n            nb = sorted(set(cur + [add]))\n            move_type = \"forced_add\"\n        elif cur:\n            # try remove best feasibility-preserving\n            ordered = sorted(cur, key=lambda k: scores[k-1]\/max(1e-9, times[k-1]), reverse=True)\n            for rem in ordered:\n                if current_time(cur) - times[rem-1] >= TIME_REQ:\n                    tmp = cur[:]\n                    tmp.remove(rem)\n                    nb = tmp\n                    move_type = \"forced_remove\"\n                    break\n            if nb == cur and missing:\n                rem = random.choice(cur)\n                add = random.choice(missing)\n                if current_time(cur) - times[rem-1] + times[add-1] >= TIME_REQ:\n                    tmp = cur[:]\n                    tmp.remove(rem)\n                    tmp.append(add)\n                    nb = sorted(set(tmp))\n                    move_type = \"forced_swap\"\n\n    return nb, \"NB_Generic\", move_type\n","Perturbacion":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    scores = [19,21,22,13,1,9,7,10,4,11,11,12,6,15,17,8,13,11,24,10,8,18,8,9]\n    times  = [110,230,220,100,170,200,110,240,190,80,140,200,220,160,130,50,40,220,230,90,220,60,200,100]\n    TIME_REQ = 670\n    n = 24\n\n    def repair(sol):\n        if not isinstance(sol, list):\n            return []\n        sol2 = [i for i in sol if isinstance(i, int) and 1 <= i <= n]\n        sol2 = sorted(set(sol2))\n        return sol2\n\n    nb = repair(solution)\n\n    # Precompute ratio lists\n    ratio_ts = [(i, times[i-1]\/scores[i-1]) for i in range(1, n+1)]\n    high = [i for i, _ in sorted(ratio_ts, key=lambda x: -x[1])]  # high time per score\n    low = [i for i, _ in sorted(ratio_ts, key=lambda x: x[1])]    # low time per score\n\n    # Adaptive k-move (2 to 4)\n    k = random.randint(2, 4)\n    for _ in range(k):\n        present = set(nb)\n        missing = [i for i in range(1, n+1) if i not in present]\n        move = random.random()\n        if move < 0.34 and missing:\n            pool = [i for i in high[:8] if i in missing] or missing\n            nb.append(random.choice(pool))\n            nb = repair(nb)\n        elif move < 0.68 and nb:\n            pool = [i for i in low[:8] if i in present] or list(present)\n            if pool:\n                rem = random.choice(pool)\n                if rem in nb:\n                    nb.remove(rem)\n        else:\n            rem_pool = [i for i in low[:8] if i in present] or list(present)\n            add_pool = [i for i in high[:8] if i in missing] or missing\n            if rem_pool and add_pool:\n                rem = random.choice(rem_pool)\n                add = random.choice(add_pool)\n                if rem in nb:\n                    nb.remove(rem)\n                nb.append(add)\n                nb = repair(nb)\n\n    # Feasibility repair\n    def total_time(sol):\n        return sum(times[i-1] for i in sol)\n\n    cur_time = total_time(nb)\n    if cur_time < TIME_REQ:\n        present = set(nb)\n        missing = [i for i in range(1, n+1) if i not in present]\n        for a in sorted(missing, key=lambda i: times[i-1]\/scores[i-1], reverse=True):\n            nb.append(a)\n            nb = repair(nb)\n            if total_time(nb) >= TIME_REQ:\n                break\n    else:\n        # try a single feasibility-preserving removal: remove highest score per time\n        ordered = sorted(nb, key=lambda k: scores[k-1]\/max(1e-9, times[k-1]), reverse=True)\n        base = cur_time\n        for rem in ordered:\n            if base - times[rem-1] >= TIME_REQ:\n                nb.remove(rem)\n                break\n\n    return nb\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible solutions return -total_value. Infeasible\/invalid => large penalty.\n    P = 1_000_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            # reject negatives and non-digits\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        # canonicalize\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P\n    return -float(total_v)\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution_str, movement_type_str). Always feasible and canonical.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in idxs)\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = total_weight(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Define candidate generators that preserve feasibility\n    def try_add():\n        random.shuffle(absent)\n        for k in absent:\n            w = weights[k-1]\n            if W + w <= capacity:\n                return sorted(S + [k]), 'ADD'\n        return None, None\n\n    def try_drop():\n        if not S:\n            return None, None\n        k = random.choice(S)\n        T = [x for x in S if x != k]\n        return sorted(T), 'DROP'\n\n    def try_swap_1_1():\n        if not S or not absent:\n            return None, None\n        out_k = random.choice(S)\n        random.shuffle(absent)\n        w_out = weights[out_k-1]\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.append(in_k)\n                return sorted(T), 'SWAP1-1'\n        return None, None\n\n    def try_swap_2_1():\n        if len(S) < 2 or not absent:\n            return None, None\n        i, j = random.sample(range(len(S)), 2)\n        a, b = S[i], S[j]\n        w_out = weights[a-1] + weights[b-1]\n        random.shuffle(absent)\n        for in_k in absent:\n            if W - w_out + weights[in_k-1] <= capacity:\n                Tset = set(S)\n                Tset.discard(a)\n                Tset.discard(b)\n                Tset.add(in_k)\n                return sorted(Tset), 'SWAP2-1'\n        return None, None\n\n    def try_swap_1_2():\n        if not S or len(absent) < 2:\n            return None, None\n        out_k = random.choice(S)\n        w_out = weights[out_k-1]\n        in_candidates = absent[:]\n        random.shuffle(in_candidates)\n        # try a few random pairs\n        trials = 20\n        for _ in range(trials):\n            if len(in_candidates) < 2:\n                break\n            a, b = random.sample(in_candidates, 2)\n            if W - w_out + weights[a-1] + weights[b-1] <= capacity:\n                T = [x for x in S if x != out_k]\n                T.extend([a, b])\n                return sorted(set(T)), 'SWAP1-2'\n        return None, None\n\n    moves = [try_add, try_drop, try_swap_1_1, try_swap_2_1, try_swap_1_2]\n    random.shuffle(moves)\n    for mv in moves:\n        T, label = mv()\n        if T is not None:\n            return encode(T), label\n    # If no feasible change found, return original\n    return encode(S), 'NOOP'\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-shake perturbation: random removals, optional heavy insertion+repair, then greedy refill by value density.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str) or sol.strip() == '':\n            return []\n        parts = sol.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return []\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return []\n            k = int(t)\n            if 1 <= k <= n and k not in seen:\n                seen.add(k)\n                idxs.append(k)\n            else:\n                return []\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    S = sorted(set(S))\n\n    # Step 1: remove t random items (t in [1..min(3,|S|)])\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        for _ in range(t):\n            if not S:\n                break\n            S.pop(random.randrange(len(S)))\n    W = total_weight(S)\n\n    # Step 2: with 50% chance, insert a random item then repair by dropping worst density until feasible\n    if random.random() < 0.5:\n        present = set(S)\n        absent = [k for k in range(1, n+1) if k not in present]\n        if absent:\n            k = random.choice(absent)\n            S.append(k)\n            # repair if needed by removing lowest density first (value\/weight asc, then value asc, weight desc)\n            S = sorted(set(S))\n            def density_key(k):\n                return (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            while total_weight(S) > capacity and S:\n                S.sort(key=density_key)\n                S.pop(0)\n    S = sorted(set(S))\n\n    # Step 3: greedy refill by value density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated 1-based index list with no duplicates; empty string for empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Lower fitness is better. Feasible -> negative total value. Infeasible\/invalid -> large positive penalty scaled by overweight.\n    P = 1_000_000_000.0\n    ALPHA = 1_000_000.0\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Always returns a feasible, canonical neighbor string and a movement label.\n    # Prioritizes high value\/weight additions and improving swaps; avoids NOOP by forcing a change when possible.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        # order to drop: lowest density first\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    if dv > 0:\n                        return encode(T), 'SWAP1-1_IMPROVE'\n        # accept first feasible neutral\/worse swap to avoid stagnation\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    return encode(sorted(set(T))), 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Returns feasible canonical string.\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_standard","Representacion":"Comma-separated list of distinct 1-based item indices in ascending order; empty string denotes empty set. Example: \"4,8,18\"","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Fitness: lower is better. Feasible -> negative total value (to maximize value). Infeasible\/invalid -> large positive penalty scaled by overweight.\n    Representation: comma-separated 1-based indices; empty string for empty set.\n    \"\"\"\n    P = 1_000_000.0  # base penalty\n    ALPHA = 1_000.0  # overweight multiplier\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse_index_list(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if k < 1 or k > n:\n                return None\n            if k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    idxs = parse_index_list(solution)\n    if idxs is None:\n        return P\n\n    total_w = 0\n    total_v = 0\n    for k in idxs:\n        total_w += weights[k-1]\n        total_v += values[k-1]\n    if total_w > capacity:\n        return P + ALPHA * float(total_w - capacity)\n    return -float(total_v)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns (neighbour_solution_str, move_label). Ensures canonical, feasible neighbors when possible; forces a change.\n    Moves attempted in order: ADD (best density), improving SWAP1-1, non-improving SWAP1-1 (aspiration-lite), DROP worst-density, INIT best single.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def tw(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    def tv(idxs):\n        return sum(values[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n    W = tw(S)\n    V = tv(S)\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n\n    # Pre-sort candidates by value density desc, then value desc, weight asc\n    dens = [(k, values[k-1] \/ float(weights[k-1]), values[k-1], weights[k-1]) for k in absent]\n    dens.sort(key=lambda t: (-t[1], -t[2], t[3]))\n\n    # 1) Try best-feasible ADD\n    for k, _, _, w in dens:\n        if W + w <= capacity:\n            T = sorted(S + [k])\n            return encode(T), 'ADD'\n\n    # 2) Try 1-1 swap preferring improving delta value and feasibility\n    if S and absent:\n        S_sorted_by_bad = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        seen_states = set()\n        for out_k in S_sorted_by_bad:\n            w_out = weights[out_k-1]\n            v_out = values[out_k-1]\n            for in_k, _, _, w_in in dens:\n                if W - w_out + w_in <= capacity:\n                    dv = values[in_k-1] - v_out\n                    T = [x for x in S if x != out_k]\n                    if in_k not in T:\n                        T.append(in_k)\n                    T = sorted(set(T))\n                    sT = encode(T)\n                    if dv > 0:\n                        return sT, 'SWAP1-1_IMPROVE'\n                    # aspiration-lite: avoid NOOP cycles\n                    if sT not in seen_states:\n                        seen_states.add(sT)\n                        return sT, 'SWAP1-1'\n\n    # 3) If all else fails, DROP the worst-density item (forces change)\n    if S:\n        worst = min(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        T = [x for x in S if x != worst]\n        return encode(sorted(T)), 'DROP'\n\n    # 4) From empty: pick best single that fits (if any), else return empty\n    best_fit = None\n    best_key = None\n    for k in range(1, n+1):\n        if weights[k-1] <= capacity:\n            key = (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1])\n            if best_fit is None or key > best_key:\n                best_fit = k\n                best_key = key\n    if best_fit is not None:\n        return encode([best_fit]), 'ADD_INIT'\n\n    return '', 'STALEMATE'\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    \"\"\"\n    Capacity-aware t-shake: drop 1..3 lowest-density items, optional forced add, then greedy refill by density. Always returns feasible canonical string.\n    \"\"\"\n    weights = [11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    values  = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    capacity = 9\n    n = len(values)\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return None\n        s = sol.strip()\n        if s == '':\n            return []\n        parts = s.split(',')\n        idxs = []\n        seen = set()\n        for p in parts:\n            t = p.strip()\n            if t == '':\n                return None\n            if t[0] == '+':\n                t = t[1:]\n            if not t.isdigit():\n                return None\n            k = int(t)\n            if not (1 <= k <= n) or k in seen:\n                return None\n            seen.add(k)\n            idxs.append(k)\n        idxs.sort()\n        return idxs\n\n    def encode(idxs):\n        if not idxs:\n            return ''\n        return ','.join(str(k) for k in sorted(set(idxs)))\n\n    def total_weight(idxs):\n        return sum(weights[k-1] for k in idxs)\n\n    S = parse(solution)\n    if S is None:\n        S = []\n    S = sorted(set(S))\n\n    # Step 1: drop t items with lowest density (if available)\n    if S:\n        t = random.randint(1, min(3, len(S)))\n        S_sorted = sorted(S, key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n        S = S_sorted[t:]\n\n    # Step 2: with 50% chance, force-add a random absent item then repair by removing lowest-density until feasible\n    present = set(S)\n    absent = [k for k in range(1, n+1) if k not in present]\n    if absent and random.random() < 0.5:\n        k = random.choice(absent)\n        S.append(k)\n        S = sorted(set(S))\n        while total_weight(S) > capacity and S:\n            S.sort(key=lambda k: (values[k-1] \/ float(weights[k-1]), values[k-1], -weights[k-1]))\n            S.pop(0)\n\n    # Step 3: greedy refill by density until no more fit\n    present = set(S)\n    candidates = [k for k in range(1, n+1) if k not in present]\n    candidates.sort(key=lambda k: (-(values[k-1] \/ float(weights[k-1])), -values[k-1], weights[k-1]))\n    W = total_weight(S)\n    for k in candidates:\n        w = weights[k-1]\n        if W + w <= capacity:\n            S.append(k)\n            W += w\n    S = sorted(set(S))\n    return encode(S)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > 24:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        v = values[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += v\n    return -float(total_value)\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def total_cost(sol):\n        s = 0\n        for i in sol:\n            s += costs[i - 1]\n        return s\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        return total_cost(sol) <= budget\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    not_in = [i for i in range(1, 25) if i not in sol]\n\n    r = random.random()\n    # Try add when capacity remains\n    if r < 0.5 and not_in:\n        feasible = [i for i in not_in if costs[i - 1] <= remaining]\n        if feasible:\n            i = random.choice(feasible)\n            sol.append(i)\n            return list(dict.fromkeys(sol))\n\n    # Try remove\n    if sol and (not not_in or r < 0.75):\n        j = random.randrange(len(sol))\n        sol.pop(j)\n        return list(dict.fromkeys(sol))\n\n    # Try swap\n    if sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        candidates = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if candidates:\n            j = random.choice(candidates)\n            sol.remove(i_rem)\n            sol.append(j)\n            return list(dict.fromkeys(sol))\n\n    return greedy()\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if any((not isinstance(i, int)) or i < 1 or i > 24 for i in sol):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy():\n        items = list(range(1, 25))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        total = 0\n        for i in items:\n            c = costs[i - 1]\n            if total + c <= budget:\n                sol.append(i)\n                total += c\n        return sol\n\n    if not is_valid(solution):\n        sol = greedy()\n    else:\n        sol = list(solution)\n\n    k = random.randint(2, 4)\n    for _ in range(k):\n        tc = sum(costs[i - 1] for i in sol)\n        remaining = budget - tc\n        not_in = [i for i in range(1, 25) if i not in sol]\n        moved = False\n        r = random.random()\n\n        # add\n        if r < 0.4 and not_in:\n            feas = [i for i in not_in if costs[i - 1] <= remaining]\n            if feas:\n                sol.append(random.choice(feas))\n                moved = True\n\n        # remove\n        if not moved and sol and (not not_in or r < 0.8):\n            idx = random.randrange(len(sol))\n            sol.pop(idx)\n            moved = True\n\n        # swap\n        if not moved and sol and not_in:\n            tc = sum(costs[i - 1] for i in sol)\n            i_rem = random.choice(sol)\n            cand = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n            if cand:\n                sol.remove(i_rem)\n                sol.append(random.choice(cand))\n                moved = True\n\n        # repair if infeasible\n        while sum(costs[i - 1] for i in sol) > budget and sol:\n            sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            sol.pop(0)\n        sol = list(dict.fromkeys(sol))\n\n    if not is_valid(sol):\n        sol = greedy()\n\n    return sol\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution: List[int]):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\nfrom typing import List, Tuple\n\ndef generate_neighbour(solution: List[int]) -> Tuple[List[int], str, str]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        for i in sol:\n            if (not isinstance(i, int)) or i < 1 or i > n:\n                return False\n        total = 0\n        for i in sol:\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def total_cost(sol: List[int]) -> int:\n        return sum(costs[i - 1] for i in sol)\n\n    def greedy_rcl(alpha: float = 0.2) -> List[int]:\n        items = list(range(1, n + 1))\n        dens = [(i, values[i - 1] \/ costs[i - 1]) for i in items]\n        dens.sort(key=lambda x: x[1], reverse=True)\n        sol: List[int] = []\n        tc = 0\n        idx = 0\n        while idx < len(dens):\n            window = dens[idx: min(len(dens), idx + max(1, int(alpha * len(dens))))]\n            cand = [i for (i, _) in window if tc + costs[i - 1] <= budget]\n            if not cand:\n                idx += len(window)\n                continue\n            choice = random.choice(cand)\n            sol.append(choice)\n            tc += costs[choice - 1]\n            idx += 1\n        return sol\n\n    sol = list(solution) if is_valid(solution) else greedy_rcl()\n\n    tc = total_cost(sol)\n    remaining = budget - tc\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n\n    p_add, p_remove, p_swap, p_k = 0.45, 0.25, 0.25, 0.05\n    r = random.random()\n\n    # ADD\n    if r < p_add:\n        feas = [i for i in not_in if costs[i - 1] <= remaining]\n        if feas:\n            i = random.choice(feas)\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE\n    if r < p_add + p_remove and sol:\n        j = random.randrange(len(sol))\n        rem = sol.pop(j)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1\n    if r < p_add + p_remove + p_swap and sol and not_in:\n        i_rem = random.choice(sol)\n        tc = total_cost(sol)\n        feas_swaps = [j for j in not_in if tc - costs[i_rem - 1] + costs[j - 1] <= budget]\n        if feas_swaps:\n            j_add = random.choice(feas_swaps)\n            sol.remove(i_rem)\n            sol.append(j_add)\n            return sol, \"swap\", \"1-1\"\n\n    # K-EXCHANGE (2-1 or 1-2)\n    if sol and not_in:\n        move_type = None\n        if len(sol) >= 2 and random.random() < 0.5:\n            # 2-1: remove two, add one\n            rems = random.sample(sol, 2)\n            tc = total_cost(sol)\n            feas_add = [j for j in not_in if tc - costs[rems[0] - 1] - costs[rems[1] - 1] + costs[j - 1] <= budget]\n            if feas_add:\n                j_add = random.choice(feas_add)\n                for rrm in rems:\n                    sol.remove(rrm)\n                sol.append(j_add)\n                move_type = \"2-1\"\n        else:\n            # 1-2: remove one, add two\n            if len(not_in) >= 2:\n                i_rem = random.choice(sol)\n                tc = total_cost(sol)\n                feas_pairs = []\n                cand = random.sample(not_in, min(len(not_in), 10))\n                for a in cand:\n                    for b in cand:\n                        if a >= b:\n                            continue\n                        if tc - costs[i_rem - 1] + costs[a - 1] + costs[b - 1] <= budget:\n                            feas_pairs.append((a, b))\n                if feas_pairs:\n                    a, b = random.choice(feas_pairs)\n                    sol.remove(i_rem)\n                    sol.extend([a, b])\n                    move_type = \"1-2\"\n        if move_type:\n            return sol, \"k-exchange\", move_type\n\n    # fallback: randomized greedy build\n    return greedy_rcl(), \"restart\", \"greedy\"\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution: List[int]) -> List[int]:\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol: List[int]) -> bool:\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        total = 0\n        for i in sol:\n            if not (1 <= i <= n):\n                return False\n            total += costs[i - 1]\n            if total > budget:\n                return False\n        return True\n\n    def greedy_fill(sol: List[int]) -> List[int]:\n        in_set = set(sol)\n        items = [i for i in range(1, n + 1) if i not in in_set]\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        tc = sum(costs[i - 1] for i in sol)\n        res = list(sol)\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = list(solution) if is_valid(solution) else []\n    if not sol:\n        # start with cheap\/value-dense greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n\n    # remove r items with lowest contribution (by value density within current set)\n    r = random.choice([1, 2, 3]) if len(sol) > 2 else 1\n    if sol:\n        ranked = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        to_remove = ranked[: min(r, len(sol))]\n        sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # final repair (should be redundant)\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        sol.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.pop(0)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_standard","Representacion":"INDEX_LIST","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n    if not isinstance(solution, list):\n        return float('inf')\n    seen = set()\n    total_cost = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return float('inf')\n        if idx < 1 or idx > n:\n            return float('inf')\n        if idx in seen:\n            return float('inf')\n        seen.add(idx)\n        c = costs[idx - 1]\n        total_cost += c\n        if total_cost > budget:\n            return float('inf')\n        total_value += values[idx - 1]\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def total_cost(sol):\n        return sum(costs[i - 1] for i in sol)\n\n    def total_value(sol):\n        return sum(values[i - 1] for i in sol)\n\n    def density(i):\n        return values[i - 1] \/ costs[i - 1]\n\n    def greedy_build():\n        items = list(range(1, n + 1))\n        items.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        sol = []\n        tc = 0\n        for i in items:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                sol.append(i)\n                tc += c\n        return sol\n\n    def repair(sol):\n        # Remove worst densities until feasible\n        tc = total_cost(sol)\n        if tc <= budget:\n            return sol\n        # sort ascending by density, then value\n        order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        res = sol[:]\n        for i in order:\n            if tc <= budget:\n                break\n            res.remove(i)\n            tc -= costs[i - 1]\n        return res\n\n    sol = solution[:] if is_valid(solution) else greedy_build()\n    in_set = set(sol)\n    not_in = [i for i in range(1, n + 1) if i not in in_set]\n    tc = total_cost(sol)\n\n    # Adaptive operator selection based on simple random choice (lightweight)\n    ops = [\"add\", \"remove\", \"swap\", \"two_exchange\"]\n    weights = [0.4, 0.25, 0.25, 0.10]\n    op = random.choices(ops, weights=weights, k=1)[0]\n\n    # ADD: add one feasible item by best density among feasible candidates\n    if op == \"add\":\n        feas = [(i, density(i)) for i in not_in if tc + costs[i - 1] <= budget]\n        if feas:\n            feas.sort(key=lambda x: (x[1], values[x[0] - 1]), reverse=True)\n            i = random.choice(feas[: min(3, len(feas))])[0]\n            sol.append(i)\n            return sol, \"add\", \"1-0\"\n\n    # REMOVE: remove lowest density item currently selected\n    if op == \"remove\" and sol:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(rem)\n        return sol, \"remove\", \"0-1\"\n\n    # SWAP 1-1: try to swap out a low-density selected item for higher-density non-selected if feasible\n    if op == \"swap\" and sol and not_in:\n        rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        cap = budget - (tc - costs[rem - 1])\n        feas = [j for j in not_in if costs[j - 1] <= cap]\n        if feas:\n            feas.sort(key=lambda j: (values[j - 1] \/ costs[j - 1], values[j - 1]), reverse=True)\n            # pick top few candidates\n            for j in feas[: min(5, len(feas))]:\n                if values[j - 1] > values[rem - 1] or (values[j - 1] \/ costs[j - 1]) > (values[rem - 1] \/ costs[rem - 1]):\n                    sol.remove(rem)\n                    sol.append(j)\n                    return sol, \"swap\", \"1-1\"\n\n    # TWO-EXCHANGE: attempt 1-2 or 2-1 move\n    if op == \"two_exchange\" and sol and not_in:\n        # 1-2: remove one, add two if feasible\n        if len(not_in) >= 2:\n            rem = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n            base_tc = tc - costs[rem - 1]\n            # prefilter candidates by cost <= remaining capacity\n            cap = budget - base_tc\n            cand = [j for j in not_in if costs[j - 1] <= cap]\n            cand.sort(key=lambda j: costs[j - 1])\n            # two-pointer search for pair within cap, prioritizing better densities\n            best_pair = None\n            best_score = -1.0\n            l, r = 0, len(cand) - 1\n            while l < r:\n                csum = costs[cand[l] - 1] + costs[cand[r] - 1]\n                if csum <= cap:\n                    score = (values[cand[l] - 1] \/ costs[cand[l] - 1]) + (values[cand[r] - 1] \/ costs[cand[r] - 1])\n                    if score > best_score:\n                        best_score = score\n                        best_pair = (cand[l], cand[r])\n                    l += 1\n                else:\n                    r -= 1\n            if best_pair is not None:\n                sol.remove(rem)\n                sol.extend(list(best_pair))\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"1-2\"\n        # 2-1: remove two, add one\n        if len(sol) >= 2:\n            # remove two worst densities\n            worst_two = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))[:2]\n            base_tc = tc - costs[worst_two[0] - 1] - costs[worst_two[1] - 1]\n            cap = budget - base_tc\n            feas = [j for j in not_in if costs[j - 1] <= cap]\n            if feas:\n                j = max(feas, key=lambda k: (values[k - 1] \/ costs[k - 1], values[k - 1]))\n                # apply move\n                for rrm in worst_two:\n                    sol.remove(rrm)\n                sol.append(j)\n                sol = repair(sol)\n                return sol, \"k-exchange\", \"2-1\"\n\n    # fallback: randomized greedy build\n    return greedy_build(), \"restart\", \"greedy\"\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    costs = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    values = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    budget = 90\n    n = 24\n\n    def is_valid(sol):\n        if not isinstance(sol, list):\n            return False\n        if len(set(sol)) != len(sol):\n            return False\n        tc = 0\n        for i in sol:\n            if not isinstance(i, int) or i < 1 or i > n:\n                return False\n            tc += costs[i - 1]\n            if tc > budget:\n                return False\n        return True\n\n    def greedy_fill(sol):\n        in_set = set(sol)\n        cand = [i for i in range(1, n + 1) if i not in in_set]\n        cand.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = sol[:]\n        tc = sum(costs[i - 1] for i in res)\n        for i in cand:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    if not is_valid(solution):\n        # build a feasible start via greedy\n        base = list(range(1, n + 1))\n        base.sort(key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]), reverse=True)\n        res = []\n        tc = 0\n        for i in base:\n            c = costs[i - 1]\n            if tc + c <= budget:\n                res.append(i)\n                tc += c\n        return res\n\n    sol = solution[:]\n\n    # choose number of removals\n    r = 1\n    if len(sol) > 4:\n        r = random.choice([1, 2, 3])\n    # remove r worst-density items\n    remove_order = sorted(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n    to_remove = remove_order[: min(r, len(sol))]\n    sol = [i for i in sol if i not in to_remove]\n\n    # refill greedily\n    sol = greedy_fill(sol)\n\n    # ensure feasibility via light repair\n    while sum(costs[i - 1] for i in sol) > budget and sol:\n        # remove worst-density until feasible\n        worst = min(sol, key=lambda i: (values[i - 1] \/ costs[i - 1], values[i - 1]))\n        sol.remove(worst)\n\n    # deduplicate and return\n    sol = list(dict.fromkeys(sol))\n    return sol\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = 1e18\n    if not isinstance(solution, str):\n        return BAD\n    # Normalize tokens\n    raw_tokens = solution.split(',') if solution is not None else []\n    tokens = []\n    for t in raw_tokens:\n        s = t.strip()\n        if s == '':\n            continue\n        if not s.isdigit():\n            return BAD\n        tokens.append(s)\n    try:\n        ids_list = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # Duplicate and range check\n    if len(ids_list) != len(set(ids_list)):\n        return BAD\n    for i in ids_list:\n        if i < 1 or i > 24:\n            return BAD\n    # Compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids_list:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return None\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return None\n            toks.append(int(s))\n        # duplicates or out of range invalidates\n        if len(toks) != len(set(toks)):\n            return None\n        for i in toks:\n            if i < 1 or i > 24:\n                return None\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids = parse_strict(solution)\n    if ids is None:\n        ids = []\n        movement = \"reset:empty\"\n    else:\n        movement = \"\"\n\n    current_set = set(ids)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current_set]\n\n    rem = remaining_cap(current_set)\n\n    # Decide move with feasibility awareness\n    if rem <= 0 and current_set:\n        move = \"remove\"\n    else:\n        r = random.random()\n        if r < 0.45:\n            move = \"add\"\n        elif r < 0.65:\n            move = \"remove\"\n        else:\n            move = \"swap\"\n\n    if move == \"add\":\n        # capacity-aware add\n        candidates = [i for i in not_in if offers[i][1] <= rem]\n        if candidates:\n            i = random.choice(candidates)\n            current_set.add(i)\n            movement = f\"add:{i}\" if not movement else movement\n        else:\n            # fallback: try a swap that fits\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current_set:\n            i = random.choice(list(current_set))\n            current_set.remove(i)\n            movement = f\"remove:{i}\" if not movement else movement\n        else:\n            # fallback to add if nothing to remove\n            move = \"add\"\n\n    if move == \"swap\":\n        if current_set:\n            out_i = random.choice(list(current_set))\n            # capacity remaining if we remove out_i first\n            cap_after_remove = rem + offers[out_i][1]\n            add_candidates = [j for j in not_in if offers[j][1] <= cap_after_remove and j != out_i]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.remove(out_i)\n                current_set.add(in_i)\n                movement = f\"swap:out={out_i},in={in_i}\" if not movement else movement\n            else:\n                # if no feasible swap, perform a remove to stay feasible\n                current_set.remove(out_i)\n                movement = f\"remove:{out_i}\" if not movement else movement\n        else:\n            # nothing to swap, try feasible add\n            add_candidates = [j for j in not_in if offers[j][1] <= rem]\n            if add_candidates:\n                in_i = random.choice(add_candidates)\n                current_set.add(in_i)\n                movement = f\"add:{in_i}\" if not movement else movement\n\n    neighbour_solution = encode(current_set)\n    if movement == \"\":\n        movement = \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_strict(sol: str):\n        if not isinstance(sol, str):\n            return []\n        if sol.strip() == \"\":\n            return []\n        toks = []\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                return []\n            toks.append(int(s))\n        if len(toks) != len(set(toks)):\n            return []\n        toks = [i for i in toks if 1 <= i <= 24]\n        return toks\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse_strict(solution))\n\n    universe = list(range(1, 25))\n\n    # Random flips\n    flips = random.randint(3, 6)\n    for _ in range(flips):\n        i = random.choice(universe)\n        if i in current:\n            current.remove(i)\n        else:\n            current.add(i)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    # Repair overweight: drop lowest value\/weight until feasible\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Opportunistic fill\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), offers[i][1]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    # Parse tokens strictly\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    # duplicate or range invalid\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    # compute totals\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def ratio(i:int) -> float:\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def parse_and_repair(sol):\n        # Minimal-feasible repair: dedup, range filter, then drop worst ratio until feasible\n        if not isinstance(sol, str) or sol is None:\n            ids = []\n        else:\n            toks = []\n            for t in sol.split(','):\n                s = t.strip()\n                if s == '':\n                    continue\n                if not s.isdigit():\n                    # salvage nothing from non-digit tokens\n                    continue\n                toks.append(int(s))\n            # dedup preserving first occurrence\n            seen = set()\n            ids = []\n            for i in toks:\n                if 1 <= i <= 24 and i not in seen:\n                    seen.add(i)\n                    ids.append(i)\n        S = list(ids)\n        def total_w(L):\n            return sum(offers[i][1] for i in L)\n        mov_log = []\n        # repair overweight by removing worst ratio until feasible\n        while S and total_w(S) > CAP:\n            worst = min(S, key=lambda i: ratio(i))\n            S.remove(worst)\n            mov_log.append(f\"repair:remove:{worst}\")\n        return S, mov_log\n\n    def encode(ids_list):\n        # canonical order for set representation\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    ids, repair_log = parse_and_repair(solution)\n    current = set(ids)\n    movement_parts = list(repair_log)\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    def remaining_cap(S):\n        return CAP - total_w(S)\n\n    all_ids = list(range(1, 25))\n    not_in = [i for i in all_ids if i not in current]\n    rem = remaining_cap(current)\n\n    # Decide neighbourhood based on capacity\n    # Candidate neighbourhoods: add, remove, swap(1-1 best gain), two_add, two_exchange (remove1+add2)\n    moves = []\n    if rem > 0:\n        moves.append('add')\n        moves.append('swap')\n        if rem >= 2:  # allow potential two-add if feasible by weights\n            moves.append('two_add')\n    if current:\n        moves.append('remove')\n        moves.append('swap')\n        moves.append('two_exchange')\n    if not moves:\n        moves = ['remove']\n\n    move = random.choice(moves)\n\n    # Implement moves\n    if move == 'add':\n        # capacity-aware add: pick best gain by ratio among feasible\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (ratio(i), offers[i][0]))\n            current.add(j)\n            movement_parts.append(f\"add:{j}\")\n        else:\n            move = 'swap'\n\n    if move == 'remove':\n        if current:\n            # remove worst ratio to keep room\n            i = min(current, key=lambda x: ratio(x))\n            current.remove(i)\n            movement_parts.append(f\"remove:{i}\")\n\n    if move == 'swap':\n        if current:\n            # best-improvement single swap\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and (best_gain > 0 or random.random() < 0.25):\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_parts.append(f\"swap:out={out_i},in={in_j}\")\n            elif current:\n                # fallback: random feasible remove\n                out_i = random.choice(list(current))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    if move == 'two_add':\n        # try to add up to two items greedily by ratio\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        cand.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n        added = []\n        remaining = rem\n        for j in cand:\n            wj = offers[j][1]\n            if wj <= remaining:\n                current.add(j)\n                added.append(j)\n                remaining -= wj\n                if len(added) >= 2:\n                    break\n        if added:\n            movement_parts.append(\"two_add:\" + \",\".join(str(x) for x in added))\n\n    if move == 'two_exchange':\n        # remove 1, add up to 2 under capacity with best net gain\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas = [j for j in not_in if offers[j][1] <= cap_after]\n                feas.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n                # consider add best one or best pair\n                # single add\n                if feas:\n                    gain1 = offers[feas[0]][0] - offers[out_i][0]\n                    if gain1 > best_gain:\n                        best_gain = gain1\n                        best = (out_i, [feas[0]])\n                # pair add\n                for a_idx in range(len(feas)):\n                    a = feas[a_idx]\n                    wa = offers[a][1]\n                    for b_idx in range(a_idx + 1, len(feas)):\n                        b = feas[b_idx]\n                        wb = offers[b][1]\n                        if wa + wb <= cap_after:\n                            gain2 = offers[a][0] + offers[b][0] - offers[out_i][0]\n                            if gain2 > best_gain:\n                                best_gain = gain2\n                                best = (out_i, [a, b])\n                            break  # feas sorted; further b will be heavier or worse\n            if best is not None and (best_gain > 0 or random.random() < 0.2):\n                out_i, ins = best\n                current.remove(out_i)\n                for j in ins:\n                    current.add(j)\n                movement_parts.append(\"two_exchange:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in ins))\n            else:\n                # fallback small remove to diversify\n                out_i = min(current, key=lambda x: ratio(x))\n                current.remove(out_i)\n                movement_parts.append(f\"remove:{out_i}\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_parts) if movement_parts else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse(sol):\n        if not isinstance(sol, str):\n            return []\n        ids = []\n        seen = set()\n        for t in sol.split(','):\n            s = t.strip()\n            if s == '':\n                continue\n            if not s.isdigit():\n                continue\n            i = int(s)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    current = set(parse(solution))\n    universe = list(range(1, 25))\n\n    # Destroy: remove k random items\n    k = random.randint(2, 4)\n    to_remove = random.sample(list(current), k=min(k, len(current))) if current else []\n    for i in to_remove:\n        current.remove(i)\n    # Random add flips on universe for diversification\n    flips = random.randint(2, 4)\n    for _ in range(flips):\n        j = random.choice(universe)\n        if j in current:\n            current.remove(j)\n        else:\n            current.add(j)\n\n    # Repair overweight by dropping worst ratio items\n    def ratio(i):\n        v, w = offers[i]\n        return (v \/ w) if w > 0 else 0.0\n\n    def total_w(S):\n        return sum(offers[i][1] for i in S)\n\n    while current and total_w(current) > CAP:\n        worst = min(current, key=lambda i: ratio(i))\n        current.remove(worst)\n\n    # Greedy refill by ratio up to capacity\n    remaining = CAP - total_w(current)\n    candidates = [i for i in universe if i not in current and offers[i][1] <= remaining]\n    candidates.sort(key=lambda i: (-ratio(i), -offers[i][0]))\n    for i in candidates:\n        w = offers[i][1]\n        if w <= remaining:\n            current.add(i)\n            remaining -= w\n        if remaining <= 0:\n            break\n\n    return encode(current)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_standard","Representacion":"Comma-separated unique customer IDs (1..24), no spaces. Empty string \"\" denotes selecting no customers.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n    BAD = math.inf\n    if not isinstance(solution, str):\n        return BAD\n    raw = [t.strip() for t in solution.split(',')] if solution is not None else []\n    tokens = [t for t in raw if t != '']\n    for t in tokens:\n        if not t.isdigit():\n            return BAD\n    try:\n        ids = [int(t) for t in tokens]\n    except Exception:\n        return BAD\n    if len(ids) != len(set(ids)):\n        return BAD\n    for i in ids:\n        if i < 1 or i > 24:\n            return BAD\n    total_w = 0\n    total_v = 0\n    for i in ids:\n        v, w = offers[i]\n        total_w += w\n        total_v += v\n    if total_w > CAP:\n        return BAD\n    return float(-total_v)\n","Vecindad":"import random\nimport math\nimport itertools\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return None\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        if any(t != '' and not t.isdigit() for t in toks):\n            return None\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        if len(ids) != len(set(ids)):\n            return None\n        return ids\n\n    def exact_repair(ids):\n        # Given a list of ids, return a subset maximizing value under CAP using 0\/1 DP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        # reconstruct\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= items[k-1][2]\n        return set(chosen)\n\n    ids = parse_ids(solution)\n    if ids is None:\n        return \"\", \"invalid_input\"\n\n    current = set(ids)\n    # If overweight, exact repair on current set\n    if sum(offers[i][1] for i in current) > CAP:\n        repaired = exact_repair(list(current))\n        if repaired != current:\n            return encode(repaired), \"repair:exact\"\n        current = repaired\n\n    # neighborhood move selection\n    all_ids = set(range(1, 25))\n    not_in = list(all_ids - current)\n    rem = CAP - sum(offers[i][1] for i in current)\n\n    movement_log = []\n\n    def choose_best_additional(candidates, capacity):\n        # bounded enumeration up to size 2 for adds under capacity maximizing value gain\n        best_set = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(candidates, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= capacity:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_set = list(comb)\n        return best_set, (best_gain if best_set else -math.inf)\n\n    moves = []\n    if rem > 0:\n        moves.extend([\"add\", \"two_add\", \"swap\", \"one_to_two\"])\n    if current:\n        moves.extend([\"remove\", \"swap\", \"two_to_one\"]) \n    if not moves:\n        moves = [\"remove\"]\n\n    move = random.choice(moves)\n\n    if move == \"add\":\n        feas = [j for j in not_in if offers[j][1] <= rem]\n        if feas:\n            j = max(feas, key=lambda i: (offers[i][0]\/offers[i][1], offers[i][0]))\n            current.add(j)\n            movement_log.append(f\"add:{j}\")\n        else:\n            move = \"swap\"\n\n    if move == \"remove\":\n        if current:\n            i = min(current, key=lambda x: offers[x][0]\/offers[x][1])\n            current.remove(i)\n            movement_log.append(f\"remove:{i}\")\n\n    if move == \"swap\":\n        if current:\n            best_gain = -math.inf\n            best_pair = None\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                for j in feas_in:\n                    gain = offers[j][0] - offers[out_i][0]\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_pair = (out_i, j)\n            if best_pair is not None and best_gain > 0:\n                out_i, in_j = best_pair\n                current.remove(out_i)\n                current.add(in_j)\n                movement_log.append(f\"swap:out={out_i},in={in_j}\")\n\n    if move == \"two_add\":\n        cand = [j for j in not_in if offers[j][1] <= rem]\n        add_set, gain = choose_best_additional(cand, rem)\n        if add_set:\n            for j in add_set:\n                current.add(j)\n            movement_log.append(\"two_add:\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"one_to_two\":\n        # remove 1, add up to 2\n        if current:\n            best = None\n            best_gain = -math.inf\n            for out_i in current:\n                cap_after = rem + offers[out_i][1]\n                cand = [j for j in not_in if offers[j][1] <= cap_after]\n                add_set, gain = choose_best_additional(cand, cap_after)\n                net_gain = (gain if gain != -math.inf else -math.inf) - offers[out_i][0]\n                if gain != -math.inf and net_gain > best_gain:\n                    best_gain = net_gain\n                    best = (out_i, add_set)\n            if best is not None and best_gain > 0:\n                out_i, add_set = best\n                current.remove(out_i)\n                for j in add_set:\n                    current.add(j)\n                movement_log.append(\"one_to_two:out=\" + str(out_i) + \",in=\" + \",\".join(str(x) for x in sorted(add_set)))\n\n    if move == \"two_to_one\":\n        # remove up to 2, add 1\n        if current:\n            best = None\n            best_gain = -math.inf\n            current_list = list(current)\n            for r in [1, 2]:\n                for rem_set in itertools.combinations(current_list, r):\n                    cap_after = rem + sum(offers[i][1] for i in rem_set)\n                    feas_in = [j for j in not_in if offers[j][1] <= cap_after]\n                    if not feas_in:\n                        continue\n                    j = max(feas_in, key=lambda i: offers[i][0])\n                    net_gain = offers[j][0] - sum(offers[i][0] for i in rem_set)\n                    if net_gain > best_gain:\n                        best_gain = net_gain\n                        best = (list(rem_set), j)\n            if best is not None and best_gain > 0:\n                rem_set, j = best\n                for i in rem_set:\n                    current.remove(i)\n                current.add(j)\n                movement_log.append(\"two_to_one:out=\" + \",\".join(str(x) for x in sorted(rem_set)) + \",in=\" + str(j))\n\n    # final exact feasibility repair if somehow overweight\n    if sum(offers[i][1] for i in current) > CAP:\n        current = exact_repair(list(current))\n        movement_log.append(\"repair:post_exact\")\n\n    neighbour_solution = encode(current)\n    movement = \";\".join(movement_log) if movement_log else \"noop\"\n    return neighbour_solution, movement\n","Perturbacion":"import random\nimport math\nimport itertools\n\n\ndef perturb_solution(solution):\n    offers = {\n        1:(15,11), 2:(5,2), 3:(9,24), 4:(20,3), 5:(5,15), 6:(16,9), 7:(4,12), 8:(18,1),\n        9:(14,21), 10:(13,19), 11:(11,22), 12:(6,22), 13:(24,9), 14:(5,1), 15:(6,13),\n        16:(22,16), 17:(23,21), 18:(21,5), 19:(14,6), 20:(1,10), 21:(1,13), 22:(11,8),\n        23:(1,12), 24:(17,9)\n    }\n    CAP = 9\n\n    def parse_ids(sol):\n        if not isinstance(sol, str):\n            return []\n        toks = [t.strip() for t in sol.split(',')] if sol is not None else []\n        ids = []\n        seen = set()\n        for t in toks:\n            if t == '':\n                continue\n            if not t.isdigit():\n                return []\n            i = int(t)\n            if 1 <= i <= 24 and i not in seen:\n                seen.add(i)\n                ids.append(i)\n        return ids\n\n    def encode(ids_list):\n        return \",\".join(str(i) for i in sorted(ids_list))\n\n    def exact_repair(ids):\n        # Optimal subset of the given ids under CAP\n        items = [(i, offers[i][0], offers[i][1]) for i in ids]\n        n = len(items)\n        dp = [[-math.inf]*(CAP+1) for _ in range(n+1)]\n        take = [[False]*(CAP+1) for _ in range(n+1)]\n        for w in range(CAP+1):\n            dp[0][w] = 0\n        for k in range(1, n+1):\n            idx, val, wt = items[k-1]\n            for w in range(CAP+1):\n                best = dp[k-1][w]\n                took = False\n                if wt <= w and dp[k-1][w-wt] + val > best:\n                    best = dp[k-1][w-wt] + val\n                    took = True\n                dp[k][w] = best\n                take[k][w] = took\n        w = CAP\n        chosen = []\n        for k in range(n, 0, -1):\n            if take[k][w]:\n                idx, val, wt = items[k-1]\n                chosen.append(idx)\n                w -= wt\n        return set(chosen)\n\n    cur = set(parse_ids(solution))\n    universe = list(range(1, 25))\n\n    # Destroy phase: random removals and flips\n    remove_k = random.randint(1, 3)\n    if cur:\n        for i in random.sample(list(cur), k=min(remove_k, len(cur))):\n            cur.remove(i)\n    flip_k = random.randint(2, 4)\n    for _ in range(flip_k):\n        j = random.choice(universe)\n        if j in cur:\n            cur.remove(j)\n        else:\n            cur.add(j)\n\n    # Repair overweight exactly on current set\n    if sum(offers[i][1] for i in cur) > CAP:\n        cur = exact_repair(list(cur))\n    \n    # Intensify: try to add up to two items from outside exactly under remaining capacity\n    rem = CAP - sum(offers[i][1] for i in cur)\n    if rem > 0:\n        outside = [j for j in universe if j not in cur]\n        best_add = []\n        best_gain = -math.inf\n        for r in [1, 2]:\n            for comb in itertools.combinations(outside, r):\n                tw = sum(offers[j][1] for j in comb)\n                if tw <= rem:\n                    gain = sum(offers[j][0] for j in comb)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_add = list(comb)\n        for j in best_add:\n            cur.add(j)\n\n    return encode(cur)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (since we maximize value).\n    Infeasible or invalid solutions return a large positive penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1  # 24\n\n    penalty = float('inf')\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current fill level estimate.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    # Adaptive probabilities: fewer items -> prefer Add; many items -> prefer Drop; otherwise mix in Swap\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))  # discourage adds as size grows\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120]\n    capacity = 90\n    n = len(values) - 1\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sol[:]\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return keep\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_standard","Representacion":"LIST_OF_UNIQUE_1_BASED_INDICES","Evaluacion":"import math\n\n\ndef evaluate_solution(solution):\n    \"\"\"\n    Cost function (lower is better). For valid solutions within capacity, cost = -total_value (maximize value).\n    Infeasible or invalid solutions return a large finite penalty.\n    Args:\n        solution: list of unique 1-based indices in [1,24]\n    Returns:\n        float cost\n    \"\"\"\n    # Embedded problem data (1-based aligned with a dummy 0 at index 0)\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    penalty = 1e9\n    # Type and domain checks\n    if not isinstance(solution, list):\n        return penalty\n    seen = set()\n    total_time = 0\n    total_value = 0\n    for idx in solution:\n        if not isinstance(idx, int):\n            return penalty\n        if idx < 1 or idx > n:\n            return penalty\n        if idx in seen:\n            return penalty\n        seen.add(idx)\n        t = times[idx]\n        total_time += t\n        if total_time > capacity:\n            return penalty\n        total_value += values[idx]\n    # Feasible: return negative of value to convert max to min\n    return -float(total_value)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    \"\"\"\n    Returns neighbor metadata types only (operation category and movement), adhering to the required signature.\n    NB_Type in {\"Swap\",\"Add\",\"Drop\"}; Movement_Type in {\"1-1\",\"1-0\",\"0-1\"}.\n    Selection is adaptive to current list size.\n    \"\"\"\n    n = 24\n    size = len(solution) if isinstance(solution, list) else 0\n\n    if size <= 0:\n        return (\"Add\", \"0-1\")\n    if size >= n:\n        return (\"Drop\", \"1-0\")\n\n    # Heuristic weighting encouraging adds when small, swaps otherwise\n    p_add = max(0.1, 1.0 - min(1.0, size \/ 8.0))\n    p_drop = max(0.1, min(1.0, size \/ 8.0) * 0.5)\n    p_swap = 1.0 - (p_add + p_drop)\n    if p_swap < 0.1:\n        p_swap = 0.1\n        rem = 1.0 - p_swap\n        scale = rem \/ (p_add + p_drop)\n        p_add *= scale\n        p_drop *= scale\n\n    r = random.random()\n    if r < p_swap:\n        return (\"Swap\", \"1-1\")\n    elif r < p_swap + p_add:\n        return (\"Add\", \"0-1\")\n    else:\n        return (\"Drop\", \"1-0\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    \"\"\"\n    Returns a perturbed feasible solution (list of unique 1-based indices) using add\/drop\/swap with feasibility repair.\n    \"\"\"\n    values = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,12]\n    times  = [0,110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,30]\n    capacity = 90\n    n = 24\n\n    def is_feasible(sol):\n        if not isinstance(sol, list):\n            return False\n        seen = set()\n        total = 0\n        for idx in sol:\n            if not isinstance(idx, int) or idx < 1 or idx > n or idx in seen:\n                return False\n            seen.add(idx)\n            total += times[idx]\n            if total > capacity:\n                return False\n        return True\n\n    def greedy_repair(sol):\n        # Remove excess time greedily by worst value density first\n        total_time = sum(times[i] for i in sol)\n        if total_time <= capacity:\n            return sorted(set(sol))\n        order = sorted(sol, key=lambda i: (values[i] \/ max(1, times[i])))\n        keep = sol[:]\n        for i in order:\n            if sum(times[j] for j in keep) <= capacity:\n                break\n            if i in keep:\n                keep.remove(i)\n        while sum(times[j] for j in keep) > capacity and keep:\n            keep.pop(0)\n        return sorted(set(keep))\n\n    base = solution[:] if isinstance(solution, list) else []\n\n    # Random local change\n    op = random.random()\n    S = set(base)\n    if op < 0.33 and len(base) >= 1:\n        # Drop\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n    elif op < 0.66 and len(base) >= 1:\n        # Swap\n        drop_idx = random.choice(base)\n        S.discard(drop_idx)\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n    else:\n        # Add\n        add_cands = [i for i in range(1, n + 1) if i not in S]\n        if add_cands:\n            S.add(random.choice(add_cands))\n\n    perturbed = list(S)\n    perturbed = greedy_repair(perturbed)\n\n    # Greedy fill remaining capacity by best value\/time\n    current_time = sum(times[i] for i in perturbed)\n    remaining = capacity - current_time\n    if remaining > 0:\n        candidates = [i for i in range(1, n + 1) if i not in perturbed and times[i] <= remaining]\n        candidates.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        for i in candidates:\n            if sum(times[j] for j in perturbed) + times[i] <= capacity:\n                perturbed.append(i)\n\n    # Normalize\n    perturbed = sorted(set(perturbed))\n\n    # Final feasibility guarantee\n    if not is_feasible(perturbed):\n        # Build fresh greedy solution from scratch\n        items = [i for i in range(1, n + 1) if times[i] <= capacity]\n        items.sort(key=lambda i: (-values[i] \/ times[i], -values[i]))\n        total = 0\n        fresh = []\n        for i in items:\n            if total + times[i] <= capacity:\n                fresh.append(i)\n                total += times[i]\n        perturbed = fresh\n\n    return perturbed\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"LIST_ASC_INDEXES_1BASED","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Returns scalar fitness to MINIMIZE. Encodes objective, feasibility, and tie-breakers.\n    # Representation: list of strictly increasing unique 1-based indices (items selected)\n    if not isinstance(solution, list):\n        return 10**15\n    # Embedded data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and validity checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Canonical order to enforce lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: mixed radix base-32 encoding of the sorted index list\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness: minimize value, then weight, then lex key\n    if total_w >= TARGET:\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible penalty: closer to TARGET is better (smaller shortfall), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Representation: list of strictly increasing unique 1-based indices\n    n = 24\n    if not isinstance(solution, list):\n        return ([], \"1-flip\", \"toggle\")\n    sset = set()\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n:\n            sset.add(x)\n    move_type = random.random()\n    if move_type < 0.6:\n        # 1-flip toggle\n        i = random.randint(1, n)\n        if i in sset:\n            sset.remove(i)\n        else:\n            sset.add(i)\n        neigh = sorted(sset)\n        return (neigh, \"1-flip\", \"toggle\")\n    else:\n        # 2-flip swap: remove one if present, add another (distinct)\n        present = sorted(list(sset))\n        if present:\n            out_idx = random.choice(present)\n            sset.remove(out_idx)\n        else:\n            out_idx = None\n        # ensure a different index is added\n        candidates = [i for i in range(1, n+1) if i not in sset]\n        if candidates:\n            in_idx = random.choice(candidates)\n            if in_idx in sset:\n                sset.remove(in_idx)\n            else:\n                sset.add(in_idx)\n        neigh = sorted(sset)\n        return (neigh, \"2-flip\", \"swap\")\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-flip perturbation: perform k random toggles (k in [2,5])\n    n = 24\n    if not isinstance(solution, list):\n        return []\n    sset = set()\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n:\n            sset.add(x)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        i = random.randint(1, n)\n        if i in sset:\n            sset.remove(i)\n        else:\n            sset.add(i)\n    return sorted(sset)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"LIST_ASC_INDEXES_1BASED","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Returns scalar fitness to MINIMIZE. Encodes objective, feasibility, and tie-breakers.\n    # Representation: list of strictly increasing unique 1-based indices (items selected)\n    if not isinstance(solution, list):\n        return 10**15\n    # Embedded data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and validity checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Canonical order to enforce lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: mixed radix base-32 encoding of the sorted index list\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness: minimize value, then weight, then lex key\n    if total_w >= TARGET:\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible penalty: closer to TARGET is better (smaller shortfall), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","Vecindad":"import random\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Representation: list of strictly increasing unique 1-based indices\n    n = 24\n    if not isinstance(solution, list):\n        return ([], \"repair\", \"reset\")\n    # sanitize into a set within domain\n    sset = set()\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n:\n            sset.add(x)\n    r = random.random()\n    if r < 0.6:\n        # 1-flip toggle\n        i = random.randint(1, n)\n        if i in sset:\n            sset.remove(i)\n        else:\n            sset.add(i)\n        neigh = sorted(sset)\n        return (neigh, \"1-flip\", \"toggle\")\n    else:\n        # 2-flip swap-like: remove one if present, add a distinct one\n        present = sorted(sset)\n        if present:\n            out_idx = random.choice(present)\n            sset.remove(out_idx)\n            # choose an index not currently present (ensures movement)\n            while True:\n                in_idx = random.randint(1, n)\n                if in_idx not in sset:\n                    sset.add(in_idx)\n                    break\n        else:\n            # if empty, perform an add to avoid no-op\n            in_idx = random.randint(1, n)\n            sset.add(in_idx)\n        neigh = sorted(sset)\n        return (neigh, \"2-flip\", \"swap\")\n","Perturbacion":"import random\n\ndef perturb_solution(solution):\n    # Multi-flip perturbation: perform k random toggles (k in [2,5])\n    n = 24\n    if not isinstance(solution, list):\n        return []\n    sset = set()\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n:\n            sset.add(x)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        i = random.randint(1, n)\n        if i in sset:\n            sset.remove(i)\n        else:\n            sset.add(i)\n    return sorted(sset)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_textbook_inverted","Representacion":"LIST_ASC_INDEXES_1BASED","Evaluacion":"import math, random\n\ndef evaluate_solution(solution):\n    # Returns scalar fitness to MINIMIZE. Encodes objective, feasibility, and tie-breakers.\n    # Representation: list of strictly increasing unique 1-based indices (items selected)\n    if not isinstance(solution, list):\n        return 10**15\n    # Embedded data (1-based; index 0 unused)\n    W = [0,11,2,24,3,15,9,12,1,21,19,22,22,9,1,13,16,21,5,6,10,13,8,12,9]\n    V = [0,15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    n = 24\n    TARGET = 275\n    # Type and validity checks\n    if any((not isinstance(idx, int)) for idx in solution):\n        return 10**15\n    if len(solution) != len(set(solution)):\n        return 10**15\n    if any(idx < 1 or idx > n for idx in solution):\n        return 10**15\n    # Canonical order to enforce lexicographic tie-breaker\n    idxs = sorted(solution)\n    # Compute sums\n    total_w = 0\n    total_v = 0\n    for idx in idxs:\n        total_w += W[idx]\n        total_v += V[idx]\n    # Lexicographic key: mixed radix base-32 encoding of the sorted index list\n    base = 32\n    lex_key = 0\n    power = 1\n    for idx in idxs:\n        lex_key += idx * power\n        power *= base\n    # Feasible fitness: minimize value, then weight, then lex key\n    if total_w >= TARGET:\n        return total_v * 10**10 + total_w * 10**5 + lex_key\n    # Infeasible penalty: closer to TARGET is better (smaller shortfall), then lower value, then lex key\n    shortfall = TARGET - total_w\n    return 10**14 + shortfall * 10**9 + total_v * 10**5 + lex_key\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    # Representation: list of strictly increasing unique 1-based indices\n    n = 24\n    if not isinstance(solution, list):\n        return ([], \"repair\", \"reset\")\n    # sanitize into a set within domain\n    sset = set()\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n:\n            sset.add(x)\n    r = random.random()\n    if r < 0.6:\n        # 1-flip toggle\n        i = random.randint(1, n)\n        if i in sset:\n            sset.remove(i)\n        else:\n            sset.add(i)\n        neigh = sorted(sset)\n        return (neigh, \"1-flip\", \"toggle\")\n    else:\n        # 2-flip swap-like: remove one if present, add a distinct one\n        present = sorted(sset)\n        if present:\n            out_idx = random.choice(present)\n            sset.remove(out_idx)\n            # choose an index not currently present (ensures movement)\n            complement_size = n - len(sset)\n            if complement_size <= 0:\n                # fallback to toggle if full\n                i = random.randint(1, n)\n                if i in sset:\n                    sset.remove(i)\n                else:\n                    sset.add(i)\n            else:\n                while True:\n                    in_idx = random.randint(1, n)\n                    if in_idx not in sset:\n                        sset.add(in_idx)\n                        break\n        else:\n            # if empty, perform an add to avoid no-op\n            in_idx = random.randint(1, n)\n            sset.add(in_idx)\n        neigh = sorted(sset)\n        return (neigh, \"2-flip\", \"swap\")\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Multi-flip perturbation: perform k random toggles (k in [2,5])\n    n = 24\n    if not isinstance(solution, list):\n        return []\n    sset = set()\n    for x in solution:\n        if isinstance(x, int) and 1 <= x <= n:\n            sset.add(x)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        i = random.randint(1, n)\n        if i in sset:\n            sset.remove(i)\n        else:\n            sset.add(i)\n    return sorted(sset)\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"subset_list_of_unique_1based_indices_in_1..24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Validate input strictly\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return 10**15\n    n = 24\n    # Problem data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    # Sanitize: bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate totals\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Lexicographic objective encoded into a scalar fitness (lower is better)\n    # Primary: minimize total_points; tie: minimize total_cost; tie: minimize count.\n    # Feasible solutions (total_cost >= B) are strictly preferred to infeasible ones.\n    # Reserve a large block for infeasible to ensure any feasible < any infeasible.\n    BLOCK = 10**9\n    if total_cost >= B:\n        # Feasible: encode directly with priorities\n        fitness = (total_points * 10**6) + (total_cost * 10**3) + count\n        return fitness\n    else:\n        # Infeasible: penalize by deficit first, then points, then count\n        deficit = B - total_cost\n        penalty = (deficit * 10**6) + (total_points * 10**3) + count\n        return BLOCK + penalty\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: list of unique ints in [1..24]\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return solution, \"subset_list\", \"invalid\"\n    n = 24\n    # Sanitize: filter out-of-bounds and duplicates while preserving first occurrence\n    seen = set()\n    cur = [x for x in solution if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n    # Problem data for feasibility-aware moves\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    total_cost = sum(costs[i] for i in cur)\n    total_points = sum(points[i] for i in cur)\n\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Determine move type with feasibility-aware bias\n    if total_cost < B:\n        # Underfilled: bias to add or swap-in higher cost per point\n        move = random.choices([\"add\", \"swap\", \"remove\"], weights=[0.7, 0.25, 0.05])[0]\n    elif total_cost > B:\n        # Overfilled (rare due to B close to sum): try remove or swap to reduce points\n        move = random.choices([\"remove\", \"swap\", \"add\"], weights=[0.6, 0.35, 0.05])[0]\n    else:\n        # Exactly at boundary: explore swap\/removal\n        move = random.choices([\"swap\", \"remove\", \"add\"], weights=[0.6, 0.3, 0.1])[0]\n\n    new = list(cur)\n    if move == \"add\" and available:\n        # Pick item with good cost per point (maximize cost\/point; handle zero by small epsilon)\n        def score_add(j):\n            p = points[j]\n            c = costs[j]\n            return (c \/ (p + 1e-9), -p)\n        add_item = max(available, key=score_add)\n        new.append(add_item)\n    elif move == \"remove\" and new:\n        # Remove worst (highest points per cost; or highest points if tie)\n        def score_remove(j):\n            p = points[j]\n            c = costs[j]\n            return (p \/ (c + 1e-9), p)\n        rem_item = max(new, key=score_remove)\n        new.remove(rem_item)\n    elif move == \"swap\" and new and available:\n        # Swap out a relatively bad item for a relatively good one\n        def score_out(j):\n            p = points[j]\n            c = costs[j]\n            return (p \/ (c + 1e-9), p)\n        out_item = max(new, key=score_out)\n        # Prefer in-item with high cost per point\n        def score_in(j):\n            p = points[j]\n            c = costs[j]\n            return (c \/ (p + 1e-9), -p)\n        in_item = max(available, key=score_in)\n        idx = new.index(out_item)\n        new[idx] = in_item\n    else:\n        # Fallback random tweak to ensure movement\n        if available and (not new or random.random() < 0.5):\n            new.append(random.choice(available))\n        elif new:\n            new.pop(random.randrange(len(new)))\n\n    # Canonicalize order to stabilize hashing\/equality\n    new = sorted(set(new))\n    return new, \"subset_list\", move\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Stronger random perturbation with k edits\n    if not isinstance(solution, list) or any(not isinstance(i, int) for i in solution):\n        return []\n    n = 24\n    seen = set()\n    cur = [x for x in solution if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n\n    k = 4\n    for _ in range(k):\n        available = [i for i in range(1, n + 1) if i not in cur]\n        move = random.choice([\"add\", \"remove\", \"swap\"]) if cur and available else (\"add\" if not cur else (\"remove\" if not available else \"swap\"))\n        if move == \"add\" and available:\n            # Favor high cost per point\n            def score_add(j):\n                p = points[j]\n                c = costs[j]\n                return (c \/ (p + 1e-9), -p)\n            pick = max(available, key=score_add)\n            cur.append(pick)\n        elif move == \"remove\" and cur:\n            # Remove high points per cost\n            def score_remove(j):\n                p = points[j]\n                c = costs[j]\n                return (p \/ (c + 1e-9), p)\n            bad = max(cur, key=score_remove)\n            cur.remove(bad)\n        elif move == \"swap\" and cur and available:\n            out_idx = random.randrange(len(cur))\n            in_item = random.choice(available)\n            cur[out_idx] = in_item\n        # Deduplicate and bound after each edit\n        seen = set()\n        cur = [x for x in cur if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n    return sorted(cur)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"subset_list_of_unique_1based_indices_in_1..24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Strict validation\n    if not isinstance(solution, list) or any((not isinstance(i, int)) for i in solution):\n        return 10**15\n    n = 24\n    # Embedded problem data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n    # Sanitize: bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n    # Accumulate totals\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n    # Lexicographic objective encoded into scalar: lower is better\n    # Primary: minimize total_points; ties: minimize total_cost; then minimize count.\n    # Feasible strictly better than infeasible by large separation.\n    SEP = 10**12\n    if total_cost >= B:\n        return (total_points * 10**6) + (total_cost * 10**3) + count\n    else:\n        deficit = B - total_cost\n        return SEP + (deficit * 10**6) + (total_points * 10**3) + count\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: list of unique ints in [1..24]\n    if not isinstance(solution, list) or any((not isinstance(i, int)) for i in solution):\n        return [], \"invalid\"\n    n = 24\n    # Canonicalize and sanitize\n    seen = set()\n    cur = [x for x in solution if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n    cur = sorted(cur)\n\n    # Embedded data\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    total_cost = sum(costs[i] for i in cur)\n\n    available = [i for i in range(1, n + 1) if i not in cur]\n\n    # Feasibility-aware move choice\n    if total_cost < B:\n        move = random.choices([\"add\", \"swap\", \"remove\"], weights=[0.7, 0.25, 0.05])[0]\n    elif total_cost > B:\n        move = random.choices([\"remove\", \"swap\", \"add\"], weights=[0.6, 0.35, 0.05])[0]\n    else:\n        move = random.choices([\"swap\", \"remove\", \"add\"], weights=[0.6, 0.3, 0.1])[0]\n\n    new = list(cur)\n\n    if move == \"add\" and available:\n        # Prefer high cost per point to reach feasibility with minimal points\n        def score_add(j):\n            p = points[j]\n            c = costs[j]\n            return (c \/ (p + 1e-9), -p)\n        add_item = max(available, key=score_add)\n        new.append(add_item)\n    elif move == \"remove\" and new:\n        # Prefer removing items with high points per cost\n        def score_remove(j):\n            p = points[j]\n            c = costs[j]\n            return (p \/ (c + 1e-9), p)\n        rem_item = max(new, key=score_remove)\n        # Ensure we do not break feasibility too much when already feasible\n        if total_cost - costs[rem_item] >= B or total_cost > B:\n            new.remove(rem_item)\n        else:\n            # fallback: switch to add if removal would make it worse\n            if available:\n                new.append(random.choice(available))\n    elif move == \"swap\" and new and available:\n        # Replace a relatively bad item with a relatively good one\n        def score_out(j):\n            p = points[j]\n            c = costs[j]\n            return (p \/ (c + 1e-9), p)\n        out_item = max(new, key=score_out)\n        def score_in(j):\n            p = points[j]\n            c = costs[j]\n            return (c \/ (p + 1e-9), -p)\n        in_item = max(available, key=score_in)\n        idx = new.index(out_item)\n        new[idx] = in_item\n    else:\n        # Fallback tweak\n        if available and (not new or random.random() < 0.5):\n            new.append(random.choice(available))\n        elif new:\n            new.pop(random.randrange(len(new)))\n\n    # Canonicalize and deduplicate\n    new = sorted(set(new))\n    return new, move\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger multi-edit perturbation; preserves bounds\/uniqueness\n    if not isinstance(solution, list) or any((not isinstance(i, int)) for i in solution):\n        return []\n    n = 24\n    # Sanitize\n    seen = set()\n    cur = [x for x in solution if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n    cur = sorted(cur)\n\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    k = 5  # intensity\n    for _ in range(k):\n        available = [i for i in range(1, n + 1) if i not in cur]\n        total_cost = sum(costs[i] for i in cur)\n        if total_cost < B:\n            # Bias to add high cost per point\n            if available:\n                def score_add(j):\n                    p = points[j]\n                    c = costs[j]\n                    return (c \/ (p + 1e-9), -p)\n                pick = max(available, key=score_add)\n                cur.append(pick)\n            elif cur:\n                cur.pop(random.randrange(len(cur)))\n        else:\n            move = random.choice([\"remove\", \"swap\"]) if (cur and available) else (\"remove\" if cur else \"add\")\n            if move == \"remove\" and cur:\n                def score_remove(j):\n                    p = points[j]\n                    c = costs[j]\n                    return (p \/ (c + 1e-9), p)\n                bad = max(cur, key=score_remove)\n                cur.remove(bad)\n            elif move == \"swap\" and cur and available:\n                out_idx = random.randrange(len(cur))\n                in_item = random.choice(available)\n                cur[out_idx] = in_item\n        # Deduplicate and bound after each edit\n        seen = set()\n        cur = [x for x in cur if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n        cur = sorted(cur)\n    return cur\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_party_planning_inverted","Representacion":"subset_list_of_unique_1based_indices_in_1..24","Evaluacion":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Representation: list of unique ints in [1..24]\n    if not isinstance(solution, list) or any((not isinstance(i, int)) for i in solution):\n        return 10**15\n    n = 24\n    # Embedded problem data (1-based; index 0 unused)\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    # Sanitize: bounds and uniqueness\n    if any((i < 1) or (i > n) for i in solution):\n        return 10**15\n    if len(set(solution)) != len(solution):\n        return 10**15\n\n    total_cost = 0\n    total_points = 0\n    for idx in solution:\n        total_cost += costs[idx]\n        total_points += points[idx]\n    count = len(solution)\n\n    # Lexicographic scalarization constants (feasible strictly better)\n    SEP = 10**12\n    SCALE_P = 10**6\n    SCALE_C = 10**3\n\n    if total_cost >= B:\n        return (total_points * SCALE_P) + (total_cost * SCALE_C) + count\n    else:\n        deficit = B - total_cost\n        return SEP + (deficit * SCALE_P) + (total_points * SCALE_C) + count\n","Vecindad":"import random\nimport math\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Representation: list of unique ints in [1..24]\n    if not isinstance(solution, list) or any((not isinstance(i, int)) for i in solution):\n        return [], \"invalid\"\n    n = 24\n\n    # Embedded data\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    # Canonicalize and sanitize\n    seen = set()\n    cur = [x for x in solution if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n\n    # Helpers\n    def totals(sol):\n        tc = 0\n        tp = 0\n        for i in sol:\n            tc += costs[i]\n            tp += points[i]\n        return tc, tp\n\n    total_cost, total_points = totals(cur)\n\n    present = set(cur)\n    available = [i for i in range(1, n + 1) if i not in present]\n\n    # Choose move depending on feasibility and diversity\n    if total_cost < B:\n        move = random.choices([\"add\", \"swap\", \"two_in_one_out\"], weights=[0.6, 0.3, 0.1])[0]\n    else:\n        move = random.choices([\"swap\", \"remove\", \"one_in_one_out\"], weights=[0.5, 0.3, 0.2])[0]\n\n    new = list(cur)\n\n    def score_add(j):\n        # Prefer high cost per point to reach feasibility with minimal point increase\n        p = points[j]\n        c = costs[j]\n        return (c \/ (p + 1e-9), -p, -c)\n\n    def score_remove(j):\n        # Prefer removing high points per cost when needing to reduce points\/cost\n        p = points[j]\n        c = costs[j]\n        return (p \/ (c + 1e-9), p, -c)\n\n    if move == \"add\" and available:\n        add_item = max(available, key=score_add)\n        new.append(add_item)\n        move_desc = \"add:{}\".format(add_item)\n\n    elif move == \"remove\" and new:\n        # Only remove if we remain feasible or if currently overfeasible and swap unavailable\n        rem_item = max(new, key=score_remove)\n        if total_cost - costs[rem_item] >= B:\n            new.remove(rem_item)\n            move_desc = \"remove:{}\".format(rem_item)\n        else:\n            # fall back to add if removal breaks feasibility too much\n            if available:\n                add_item = max(available, key=score_add)\n                new.append(add_item)\n                move_desc = \"fallback_add:{}\".format(add_item)\n            else:\n                move_desc = \"noop\"\n\n    elif move in (\"swap\", \"one_in_one_out\") and new and available:\n        # Pick a bad item out and a good item in\n        out_item = max(new, key=score_remove)\n        in_item = max(available, key=score_add)\n        idx = new.index(out_item)\n        cand = list(new)\n        cand[idx] = in_item\n        # Ensure feasibility preference: if currently feasible, avoid breaking it unless improves cost towards B\n        c_cost, _ = totals(cand)\n        if (total_cost >= B and c_cost >= B) or (total_cost < B):\n            new = cand\n            move_desc = \"swap_out:{}_in:{}\".format(out_item, in_item)\n        else:\n            # try alternative: keep feasibility by choosing different in if possible\n            feasible_ins = [j for j in available if (total_cost - costs[out_item] + costs[j]) >= B]\n            if feasible_ins:\n                best_in = max(feasible_ins, key=score_add)\n                new[idx] = best_in\n                move_desc = \"swap_feasible_out:{}_in:{}\".format(out_item, best_in)\n            else:\n                move_desc = \"noop\"\n\n    elif move == \"two_in_one_out\" and available:\n        # Add two items that are strong on cost\/point, then remove one weak item if needed to control size\n        add_candidates = sorted(available, key=score_add, reverse=True)[:2]\n        for a in add_candidates:\n            new.append(a)\n        move_desc = \"two_add:{}\".format(\"-\".join(map(str, add_candidates)))\n        # If far over B, try removing one worst item by p\/c while staying feasible\n        total_cost, _ = totals(new)\n        if total_cost > B and len(new) >= 2:\n            bad = max(new, key=score_remove)\n            if total_cost - costs[bad] >= B:\n                new.remove(bad)\n                move_desc += \"_rem:{}\".format(bad)\n\n    else:\n        # Fallback small tweak\n        if available and (not new or random.random() < 0.5):\n            pick = random.choice(available)\n            new.append(pick)\n            move_desc = \"fallback_add:{}\".format(pick)\n        elif new:\n            rem = random.choice(new)\n            if total_cost - costs[rem] >= B:\n                new.remove(rem)\n                move_desc = \"fallback_remove:{}\".format(rem)\n            else:\n                move_desc = \"noop\"\n        else:\n            move_desc = \"noop\"\n\n    # Deduplicate, bounds, and canonical ordering for stability\n    seen = set()\n    new = [x for x in new if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n    new.sort()\n    return new, move_desc\n","Perturbacion":"import random\nimport math\n\n\ndef perturb_solution(solution):\n    # Stronger multi-edit perturbation with feasibility repair\n    if not isinstance(solution, list) or any((not isinstance(i, int)) for i in solution):\n        return []\n    n = 24\n    # Embedded data\n    costs  = [0, 110, 20, 240, 30, 150, 90, 120, 10, 210, 190, 220, 220, 90, 10, 130, 160, 210, 50, 60, 100, 130, 80, 120, 90]\n    points = [0,  15,  5,   9, 20,   5, 16,   4,  18,  14,  13,  11,   6, 24,   5,   6,  22,  23,  21,  14,   1,   1,  11,   1,  17]\n    B = 2750\n\n    # Sanitize\n    seen = set()\n    cur = [x for x in solution if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n    cur.sort()\n\n    def totals(sol):\n        tc = 0\n        for i in sol:\n            tc += costs[i]\n        return tc\n\n    def score_add(j):\n        p = points[j]\n        c = costs[j]\n        return (c \/ (p + 1e-9), -p, -c)\n\n    def score_remove(j):\n        p = points[j]\n        c = costs[j]\n        return (p \/ (c + 1e-9), p, -c)\n\n    k = 4  # intensity\n    for _ in range(k):\n        present = set(cur)\n        available = [i for i in range(1, n + 1) if i not in present]\n        tc = totals(cur)\n\n        op = None\n        if tc < B:\n            # bias to add; choose strong cost\/point items\n            if available:\n                pick = max(available, key=score_add)\n                cur.append(pick)\n                op = \"add\"\n            else:\n                # nothing to add, attempt swap\n                if cur:\n                    out = max(cur, key=score_remove)\n                    if available:\n                        inn = random.choice(available)\n                        idx = cur.index(out)\n                        cur[idx] = inn\n                        op = \"swap\"\n        else:\n            # feasible: perform 1-out-1-in exchanges or selective removals maintaining feasibility\n            choice = random.random()\n            if choice < 0.5 and cur and available:\n                out = max(cur, key=score_remove)\n                inn = max(available, key=score_add)\n                idx = cur.index(out)\n                candidate = list(cur)\n                candidate[idx] = inn\n                if totals(candidate) >= B:\n                    cur = candidate\n                    op = \"swap\"\n            else:\n                # remove worst if still feasible after removal\n                if cur:\n                    bad = max(cur, key=score_remove)\n                    if totals(cur) - costs[bad] >= B:\n                        cur.remove(bad)\n                        op = \"remove\"\n        # Deduplicate and order\n        seen = set()\n        cur = [x for x in cur if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n        cur.sort()\n\n    # Final feasibility repair: if infeasible, greedily add best cost\/point items\n    if totals(cur) < B:\n        present = set(cur)\n        avail = [i for i in range(1, n + 1) if i not in present]\n        avail.sort(key=score_add, reverse=True)\n        for j in avail:\n            cur.append(j)\n            if totals(cur) >= B:\n                break\n        # sanitize\n        seen = set()\n        cur = [x for x in cur if (1 <= x <= n) and (x not in seen and not seen.add(x))]\n        cur.sort()\n\n    return cur\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"ASC_LIST_IDX.INTS_IN_[1..24].UNIQUE.SORTED.ASCENDING","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data: offers = (index, price, gallons)\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    # Validate and normalize input\n    if not isinstance(solution, list):\n        return 10**12\n    try:\n        idxs = sorted(set(int(i) for i in solution))\n    except Exception:\n        return 10**12\n    if any(i < 1 or i > 24 for i in idxs):\n        return 10**12\n    # Build maps\n    price_map = {i: p for (i, p, g) in offers}\n    gallon_map = {i: g for (i, p, g) in offers}\n    # Compute totals\n    cost = sum(price_map[i] for i in idxs)\n    gallons = sum(gallon_map[i] for i in idxs)\n    # Adaptive penalty to preserve landscape shape\n    total_price = sum(p for _, p, _ in offers)\n    total_gallons = sum(g for _, _, g in offers)\n    avg_price_per_gallon = total_price \/ max(1, total_gallons)\n    deficit = max(0, 275 - gallons)\n    if deficit > 0:\n        alpha = 12.0  # penalty multiplier\n        return cost + alpha * avg_price_per_gallon * deficit\n    return cost\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns: (new_solution, (NB_Type, Movement_Type))\n    # Normalize input\n    if not isinstance(solution, list):\n        current = []\n    else:\n        try:\n            current = sorted(set(int(i) for i in solution if 1 <= int(i) <= 24))\n        except Exception:\n            current = []\n    universe = list(range(1, 25))\n    # Embedded data for directed moves\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    p_map = {i: p for i, p, g in offers}\n    g_map = {i: g for i, p, g in offers}\n    def gallons_of(sol):\n        return sum(g_map[i] for i in sol)\n    gallons = gallons_of(current)\n    # Decide move policy with feasibility bias\n    if gallons < 275:\n        weights = (0.8, 0.1, 0.1)  # ADD, DROP, SWAP\n    else:\n        weights = (0.2, 0.5, 0.3)\n    moves = [\"ADD\", \"DROP\", \"SWAP\"]\n    if len(current) == 0:\n        move = \"ADD\"\n    elif len(current) == 24:\n        move = \"DROP\"\n    else:\n        move = random.choices(moves, weights=weights, k=1)[0]\n    s = set(current)\n    if move == \"ADD\":\n        candidates = [i for i in universe if i not in s]\n        if not candidates:\n            move = \"DROP\"\n        else:\n            # Prefer low price-per-gallon additions\n            candidates.sort(key=lambda i: (p_map[i] \/ g_map[i], p_map[i]))\n            pick = random.choice(candidates[:max(1, len(candidates)\/\/3)])\n            s.add(pick)\n            new_sol = sorted(s)\n            return new_sol, (\"SET\", \"ADD\")\n    if move == \"DROP\":\n        if not s:\n            pick = random.choice(universe)\n            new_sol = [pick]\n            return new_sol, (\"SET\", \"ADD\")\n        # Prefer dropping high price-per-gallon with low gallon impact when feasible\n        drops = sorted(list(s), key=lambda i: (-(p_map[i] \/ g_map[i]), g_map[i]))\n        for d in drops:\n            trial = sorted(x for x in s if x != d)\n            if gallons_of(trial) >= 275 or gallons < 275:\n                new_sol = trial\n                return new_sol, (\"SET\", \"DROP\")\n        # Fallback: drop random\n        d = random.choice(list(s))\n        new_sol = sorted(x for x in s if x != d)\n        return new_sol, (\"SET\", \"DROP\")\n    # SWAP (directed): drop worst, add best\n    if not s:\n        add = random.choice(universe)\n        return [add], (\"SET\", \"ADD\")\n    out = [i for i in universe if i not in s]\n    if not out:\n        # fallback to DROP\n        d = random.choice(list(s))\n        new_sol = sorted(x for x in s if x != d)\n        return new_sol, (\"SET\", \"DROP\")\n    worst = max(s, key=lambda i: (p_map[i] \/ g_map[i], -g_map[i]))\n    best_out = min(out, key=lambda i: (p_map[i] \/ g_map[i], p_map[i]))\n    s.remove(worst)\n    s.add(best_out)\n    new_sol = sorted(s)\n    return new_sol, (\"SET\", \"SWAP\")\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Feasibility-preserving k-swap\/repair perturbation\n    if not isinstance(solution, list):\n        base = []\n    else:\n        try:\n            base = sorted(set(int(i) for i in solution if 1 <= int(i) <= 24))\n        except Exception:\n            base = []\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    p_map = {i: p for i, p, g in offers}\n    g_map = {i: g for i, p, g in offers}\n    def gallons(sol):\n        return sum(g_map[i] for i in sol)\n    def repair(sol):\n        # Ensure feasibility by adding cheapest per gallon until >= 275, then try dropping expensive per gallon\n        s = set(sol)\n        if gallons(s) < 275:\n            needed = 275 - gallons(s)\n            candidates = [i for i, _, _ in offers if i not in s]\n            candidates.sort(key=lambda i: (p_map[i] \/ g_map[i], p_map[i]))\n            for i in candidates:\n                s.add(i)\n                if gallons(s) >= 275:\n                    break\n        # Light drop-improvement: remove items that keep feasibility and reduce cost\n        improved = True\n        while improved:\n            improved = False\n            items = sorted(list(s), key=lambda i: (-(p_map[i] \/ g_map[i]), g_map[i]))\n            for i in items:\n                t = set(s)\n                t.remove(i)\n                if gallons(t) >= 275:\n                    # remove i if feasible\n                    s = t\n                    improved = True\n                    break\n        return sorted(s)\n    n_swaps = random.randint(2, 5)\n    s = set(base)\n    universe = set(range(1, 25))\n    for _ in range(n_swaps):\n        if len(s) == 0:\n            add = random.choice(list(universe))\n            s.add(add)\n            continue\n        # perform either flip or swap\n        if random.random() < 0.5 or len(s) == 24:\n            # flip\n            i = random.choice(list(universe))\n            if i in s:\n                s.remove(i)\n            else:\n                s.add(i)\n        else:\n            # swap\n            inside = random.choice(list(s))\n            outside_candidates = list(universe - s)\n            if outside_candidates:\n                outside = random.choice(outside_candidates)\n                s.remove(inside)\n                s.add(outside)\n    perturbed = sorted(s)\n    return repair(perturbed)\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"ASC_LIST_IDX.INTS_IN_[1..24].UNIQUE.SORTED.ASCENDING","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Strict validator for representation: list of unique, sorted ints in [1..24]\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    if not isinstance(solution, list):\n        return 10**12\n    # All elements must be ints\n    if any(not isinstance(x, int) for x in solution):\n        return 10**12\n    # Sorted ascending, unique, within bounds\n    if solution != sorted(solution):\n        return 10**12\n    if len(solution) != len(set(solution)):\n        return 10**12\n    if any(x < 1 or x > 24 for x in solution):\n        return 10**12\n    price_map = {i: p for (i, p, g) in offers}\n    gallon_map = {i: g for (i, p, g) in offers}\n    cost = sum(price_map[i] for i in solution)\n    gallons = sum(gallon_map[i] for i in solution)\n    if gallons < 275:\n        # Heavy penalty to enforce feasibility-first\n        deficit = 275 - gallons\n        return 10**9 + deficit * 10**6 + cost\n    return cost\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution):\n    # Returns: (new_solution, (\"SET\", Movement_Type)) where Movement_Type in {\"ADD\",\"DROP\",\"SWAP\"}\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    p_map = {i: p for i, p, g in offers}\n    g_map = {i: g for i, p, g in offers}\n    universe = list(range(1, 25))\n    # Validate current solution; if invalid, reset to empty\n    cur = []\n    if isinstance(solution, list) and all(isinstance(x, int) for x in solution):\n        cand = sorted(solution)\n        if len(cand) == len(set(cand)) and all(1 <= x <= 24 for x in cand):\n            cur = cand\n    s = set(cur)\n\n    def gallons(sol):\n        return sum(g_map[i] for i in sol)\n\n    def cost(sol):\n        return sum(p_map[i] for i in sol)\n\n    # Rank helpers\n    ratio = {i: (p_map[i] \/ g_map[i]) for i in universe}\n    out = [i for i in universe if i not in s]\n    inside = list(s)\n\n    cur_g = gallons(s)\n    feasible = cur_g >= 275\n\n    # Epsilon-greedy selection among ranked candidates\n    def pick_from_sorted(cands, key, epsilon=0.2):\n        if not cands:\n            return None\n        ranked = sorted(cands, key=key)\n        if random.random() < epsilon:\n            return random.choice(ranked)\n        # softly prefer top-k (k ~ sqrt(n))\n        k = max(1, int(math.sqrt(len(ranked))))\n        return random.choice(ranked[:k])\n\n    # If infeasible, prioritize ADD or feasibility-increasing SWAP\n    if not feasible:\n        # Try ADD best per-gallon from outside\n        add = pick_from_sorted(out, key=lambda i: (ratio[i], p_map[i]))\n        if add is not None:\n            s2 = set(s)\n            s2.add(add)\n            return (sorted(s2), (\"SET\", \"ADD\"))\n        # If no outside, try a swap that increases gallons\n        if inside and out:\n            worst_in = max(inside, key=lambda i: (ratio[i], -g_map[i]))\n            best_out = min(out, key=lambda i: (ratio[i], p_map[i]))\n            if g_map[best_out] > g_map[worst_in]:\n                s2 = set(s)\n                s2.remove(worst_in)\n                s2.add(best_out)\n                return (sorted(s2), (\"SET\", \"SWAP\"))\n        # Fallback: random add (should rarely happen)\n        if out:\n            a = random.choice(out)\n            s2 = set(s)\n            s2.add(a)\n            return (sorted(s2), (\"SET\", \"ADD\"))\n        return (sorted(s), (\"SET\", \"ADD\"))\n\n    # Feasible: prefer DROP that keeps feasibility, else SWAP; occasional ADD for diversification\n    move_choice = random.random()\n    if move_choice < 0.5 and inside:\n        # DROP: drop highest ratio while keeping feasibility\n        candidates = sorted(inside, key=lambda i: (-ratio[i], g_map[i]))\n        for d in candidates:\n            s2 = set(s)\n            s2.remove(d)\n            if gallons(s2) >= 275:\n                return (sorted(s2), (\"SET\", \"DROP\"))\n        # If none maintain feasibility, try SWAP\n    if move_choice < 0.9 and inside and out:\n        # SWAP: drop worst-in, add best-out, require feasibility\n        worst_in = max(inside, key=lambda i: (ratio[i], -g_map[i]))\n        best_out = min(out, key=lambda i: (ratio[i], p_map[i]))\n        s2 = set(s)\n        s2.remove(worst_in)\n        s2.add(best_out)\n        if gallons(s2) >= 275 and cost(s2) <= cost(s):\n            return (sorted(s2), (\"SET\", \"SWAP\"))\n        # Try alternative: pick from top-k best_out to reduce cost while feasible\n        ranked_out = sorted(out, key=lambda i: (ratio[i], p_map[i]))\n        k = max(1, int(math.sqrt(len(ranked_out))))\n        for cand_out in ranked_out[:k]:\n            s2 = set(s)\n            s2.remove(worst_in)\n            s2.add(cand_out)\n            if gallons(s2) >= 275:\n                return (sorted(s2), (\"SET\", \"SWAP\"))\n    # Diversification ADD (keeps feasibility but expands set)\n    if out:\n        add = pick_from_sorted(out, key=lambda i: (ratio[i], p_map[i]))\n        if add is not None:\n            s2 = set(s)\n            s2.add(add)\n            return (sorted(s2), (\"SET\", \"ADD\"))\n    # Fallback: return current\n    return (sorted(s), (\"SET\", \"ADD\"))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # k-edit with feasibility-preserving repair and post-drop tightening\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    p_map = {i: p for i, p, g in offers}\n    g_map = {i: g for i, p, g in offers}\n    universe = set(range(1,25))\n\n    # Normalize input to a valid set; if invalid, start from empty\n    base = []\n    if isinstance(solution, list) and all(isinstance(x, int) for x in solution):\n        cand = sorted(solution)\n        if len(cand) == len(set(cand)) and all(1 <= x <= 24 for x in cand):\n            base = cand\n    s = set(base)\n\n    def gallons(sol):\n        return sum(g_map[i] for i in sol)\n\n    ratio = {i: (p_map[i] \/ g_map[i]) for i in universe}\n\n    def repair(sol_set):\n        s2 = set(sol_set)\n        # If infeasible, add best price-per-gallon until feasible\n        if gallons(s2) < 275:\n            candidates = [i for i in universe if i not in s2]\n            candidates.sort(key=lambda i: (ratio[i], p_map[i]))\n            for i in candidates:\n                s2.add(i)\n                if gallons(s2) >= 275:\n                    break\n        # Tighten by dropping expensive-per-gallon items while remaining feasible\n        improved = True\n        while improved:\n            improved = False\n            drops = sorted(list(s2), key=lambda i: (-ratio[i], g_map[i]))\n            for d in drops:\n                t = set(s2)\n                t.remove(d)\n                if gallons(t) >= 275:\n                    s2 = t\n                    improved = True\n                    break\n        return s2\n\n    # k edits (mix of flips and swaps)\n    k = random.randint(2, 5)\n    for _ in range(k):\n        if not s:\n            s.add(random.choice(list(universe)))\n            continue\n        if random.random() < 0.5 or len(s) == 24:\n            i = random.choice(list(universe))\n            if i in s:\n                s.remove(i)\n            else:\n                s.add(i)\n        else:\n            inside = list(s)\n            outside = list(universe - s)\n            if inside and outside:\n                i = random.choice(inside)\n                o = random.choice(outside)\n                s.remove(i)\n                s.add(o)\n    repaired = repair(s)\n    return sorted(repaired)\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_lemonade_stand_inverted","Representacion":"ASC_LIST_IDX.UNIQUE.SORTED.ASCENDING.IN_RANGE_1_24","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data: (index, price p_i, gallons g_i)\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    REQUIRED_GALLONS = 275\n    # Validate representation\n    if not isinstance(solution, list):\n        return 10**8\n    if any(not isinstance(x, int) for x in solution):\n        return 10**8\n    if solution != sorted(solution):\n        return 10**8\n    if len(solution) != len(set(solution)):\n        return 10**8\n    if any(x < 1 or x > 24 for x in solution):\n        return 10**8\n    price_map = {i: p for (i, p, g) in offers}\n    gallon_map = {i: g for (i, p, g) in offers}\n    cost = sum(price_map[i] for i in solution)\n    gallons = sum(gallon_map[i] for i in solution)\n    if gallons < REQUIRED_GALLONS:\n        deficit = REQUIRED_GALLONS - gallons\n        # Feasibility-first penalty: linear in deficit with moderate scale\n        return 10**7 + deficit * (10**5) + cost\n    return cost\n","Vecindad":"import random\nimport math\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns: (new_solution, (\"SET\", move_type)) with move_type in {\"ADD\",\"DROP\",\"SWAP\",\"K-EX\"}\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    REQUIRED_GALLONS = 275\n    p_map = {i: p for i, p, g in offers}\n    g_map = {i: g for i, p, g in offers}\n    universe = list(range(1, 25))\n\n    # Normalize input to a valid sorted-unique-in-range list\n    cur = []\n    if isinstance(solution, list) and all(isinstance(x, int) for x in solution):\n        cand = sorted(solution)\n        if len(cand) == len(set(cand)) and all(1 <= x <= 24 for x in cand):\n            cur = cand\n    s = set(cur)\n\n    def gallons(S):\n        return sum(g_map[i] for i in S)\n\n    def cost(S):\n        return sum(p_map[i] for i in S)\n\n    ratio = {i: (p_map[i] \/ g_map[i]) for i in universe}\n    inside = sorted(list(s))\n    outside = [i for i in universe if i not in s]\n\n    cur_g = gallons(s)\n    feasible = cur_g >= REQUIRED_GALLONS\n\n    # Greedy feasibility repair ADD when infeasible\n    if not feasible:\n        if outside:\n            add = min(outside, key=lambda i: (ratio[i], p_map[i]))\n            s2 = set(s)\n            s2.add(add)\n            return (sorted(s2), (\"SET\", \"ADD\"))\n        else:\n            return (sorted(s), (\"SET\", \"ADD\"))\n\n    # Feasible regime: DROP-first best-improvement\n    best_drop = None\n    best_drop_delta = 0\n    for d in inside:\n        s2 = set(s)\n        s2.remove(d)\n        if gallons(s2) >= REQUIRED_GALLONS:\n            delta = cost(s) - cost(s2)  # positive is improvement\n            if delta > best_drop_delta:\n                best_drop_delta = delta\n                best_drop = d\n    if best_drop is not None and best_drop_delta > 0:\n        s2 = set(s)\n        s2.remove(best_drop)\n        return (sorted(s2), (\"SET\", \"DROP\"))\n\n    # 1-1 SWAP: try improving cost while keeping feasibility\n    best_pair = None\n    best_pair_delta = 0\n    # Limit candidate sets by ranking to keep it efficient\n    drop_cands = sorted(inside, key=lambda i: (-ratio[i], g_map[i]))[:min(8, len(inside))]\n    add_cands = sorted(outside, key=lambda i: (ratio[i], p_map[i]))[:min(10, len(outside))]\n    base_cost = cost(s)\n    for d in drop_cands:\n        for a in add_cands:\n            if a in s:\n                continue\n            s2 = set(s)\n            s2.remove(d)\n            s2.add(a)\n            if gallons(s2) >= REQUIRED_GALLONS:\n                delta = base_cost - cost(s2)\n                if delta > best_pair_delta:\n                    best_pair_delta = delta\n                    best_pair = (d, a)\n    if best_pair is not None and best_pair_delta > 0:\n        d, a = best_pair\n        s2 = set(s)\n        s2.remove(d)\n        s2.add(a)\n        return (sorted(s2), (\"SET\", \"SWAP\"))\n\n    # Light diversification: try 1-2 or 2-1 exchange with small neighborhoods\n    # 1-2: drop 1, add 2\n    if len(outside) >= 2 and inside:\n        d = max(inside, key=lambda i: (ratio[i], -g_map[i]))\n        add_pool = sorted(outside, key=lambda i: (ratio[i], p_map[i]))[:min(6, len(outside))]\n        for i in range(len(add_pool)):\n            for j in range(i+1, len(add_pool)):\n                a1, a2 = add_pool[i], add_pool[j]\n                s2 = set(s)\n                s2.remove(d)\n                s2.add(a1)\n                s2.add(a2)\n                if gallons(s2) >= REQUIRED_GALLONS and cost(s2) < base_cost:\n                    return (sorted(s2), (\"SET\", \"K-EX\"))\n    # 2-1: drop 2, add 1\n    if len(inside) >= 2 and outside:\n        drop_pool = sorted(inside, key=lambda i: (-ratio[i], g_map[i]))[:min(6, len(inside))]\n        a = min(outside, key=lambda i: (ratio[i], p_map[i]))\n        for i in range(len(drop_pool)):\n            for j in range(i+1, len(drop_pool)):\n                d1, d2 = drop_pool[i], drop_pool[j]\n                s2 = set(s)\n                s2.remove(d1)\n                s2.remove(d2)\n                s2.add(a)\n                if gallons(s2) >= REQUIRED_GALLONS and cost(s2) < base_cost:\n                    return (sorted(s2), (\"SET\", \"K-EX\"))\n\n    # Fallback: mild ADD for exploration (keep feasibility by design)\n    if outside:\n        a = min(outside, key=lambda i: (ratio[i], p_map[i]))\n        s2 = set(s)\n        s2.add(a)\n        return (sorted(s2), (\"SET\", \"ADD\"))\n    return (sorted(list(s)), (\"SET\", \"ADD\"))\n","Perturbacion":"import random\nimport math\n\ndef perturb_solution(solution):\n    # Randomized drop of r worst ratio items, then greedy repair and tighten\n    offers = [\n        (1,15,11),(2,5,2),(3,9,24),(4,20,3),(5,5,15),(6,16,9),(7,4,12),(8,18,1),\n        (9,14,21),(10,13,19),(11,11,22),(12,6,22),(13,24,9),(14,5,1),(15,6,13),\n        (16,22,16),(17,23,21),(18,21,5),(19,14,6),(20,1,10),(21,1,13),(22,11,8),\n        (23,1,12),(24,17,9)\n    ]\n    REQUIRED_GALLONS = 275\n    p_map = {i: p for i, p, g in offers}\n    g_map = {i: g for i, p, g in offers}\n    universe = set(range(1,25))\n\n    # Normalize input\n    base = []\n    if isinstance(solution, list) and all(isinstance(x, int) for x in solution):\n        cand = sorted(solution)\n        if len(cand) == len(set(cand)) and all(1 <= x <= 24 for x in cand):\n            base = cand\n    s = set(base)\n\n    def gallons(S):\n        return sum(g_map[i] for i in S)\n\n    ratio = {i: (p_map[i] \/ g_map[i]) for i in universe}\n\n    # Randomized drop r items among worst ratios (expensive per gallon)\n    inside = sorted(list(s), key=lambda i: (ratio[i], -g_map[i]))\n    if inside:\n        r_max = min(5, len(inside))\n        r = random.randint(1, r_max)\n        worst_pool = sorted(list(s), key=lambda i: (-ratio[i], g_map[i]))[:max(1, min(8, len(inside)))]\n        to_drop = set(random.sample(worst_pool, k=min(r, len(worst_pool))))\n        s.difference_update(to_drop)\n\n    # Greedy repair to feasibility\n    if gallons(s) < REQUIRED_GALLONS:\n        outside = list(universe - s)\n        outside.sort(key=lambda i: (ratio[i], p_map[i]))\n        for a in outside:\n            s.add(a)\n            if gallons(s) >= REQUIRED_GALLONS:\n                break\n\n    # Tighten: iteratively drop any item whose removal keeps feasibility and reduces cost-per-gallon burden\n    improved = True\n    while improved:\n        improved = False\n        drops = sorted(list(s), key=lambda i: (-ratio[i], g_map[i]))\n        for d in drops:\n            t = set(s)\n            t.remove(d)\n            if gallons(t) >= REQUIRED_GALLONS:\n                s = t\n                improved = True\n                break\n\n    return sorted(list(s))\n","Version":2}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"list_of_unique_1_based_indices","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    # Type and value validation\n    if not isinstance(solution, list):\n        return float('inf')\n    if any((not isinstance(i, int)) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > n for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n\n    # Feasibility check\n    total_time = sum(times[i-1] for i in solution)\n    if total_time < 2750:\n        return float('inf')\n\n    # Objective: minimize total score\n    total_score = sum(scores[i-1] for i in solution)\n    return float(total_score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    # Helpers\n    def sanitize(lst):\n        if not isinstance(lst, list):\n            return []\n        out = []\n        seen = set()\n        for v in lst:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                out.append(v)\n                seen.add(v)\n        return out\n\n    def total_time_of(lst):\n        return sum(times[i-1] for i in lst)\n\n    def total_score_of(lst):\n        return sum(scores[i-1] for i in lst)\n\n    def repair_to_feasible(cur):\n        cur = sanitize(cur)\n        if total_time_of(cur) >= 2750:\n            return cur\n        remaining = [i for i in range(1, n+1) if i not in set(cur)]\n        # prioritize high time per score to reach constraint with minimal score growth\n        remaining.sort(key=lambda i: (-(times[i-1] \/ max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        for i in remaining:\n            cur.append(i)\n            if total_time_of(cur) >= 2750:\n                break\n        return sanitize(cur)\n\n    def tightening(cur):\n        # Try removing items while keeping feasibility and improving score\n        cur = sanitize(cur)\n        improved = True\n        while improved and cur:\n            improved = False\n            best_idx = None\n            best_gain = 0  # score reduction\n            cur_time = total_time_of(cur)\n            for idx in cur:\n                if cur_time - times[idx-1] >= 2750:\n                    gain = scores[idx-1]\n                    # Prefer larger score gain; tie-break by smallest time loss\n                    if gain > best_gain or (gain == best_gain and (best_idx is not None and times[idx-1] < times[best_idx-1])):\n                        best_gain = gain\n                        best_idx = idx\n                    if gain > best_gain:\n                        best_idx = idx\n            if best_idx is not None and best_gain > 0:\n                cur = [x for x in cur if x != best_idx]\n                improved = True\n        return sanitize(cur)\n\n    # Sanitize input\n    base = sanitize(solution)\n    if not base:\n        # initialize with a few random items then repair\n        k = random.randint(2, 5)\n        base = random.sample(range(1, n+1), k=k)\n    base = repair_to_feasible(base)\n    base = tightening(base)\n\n    sel = set(base)\n    unselected = [i for i in range(1, n+1) if i not in sel]\n\n    # Surplus-based move selection\n    surplus = total_time_of(base) - 2750\n    moves = []\n    if surplus > 200:\n        moves = [\"remove\"]*5 + [\"swap\"]*3 + [\"drop2add2\"]*2\n    elif surplus > 0:\n        moves = [\"swap\"]*5 + [\"remove\"]*3 + [\"add\"]*2 + [\"drop2add2\"]*2\n    else:\n        moves = [\"add\"]*5 + [\"swap\"]*4 + [\"drop2add2\"]*1\n\n    move = random.choice(moves)\n    neighbour = list(base)\n    movement = move\n\n    if move == \"swap\" and sel and unselected:\n        a = random.choice(list(sel))\n        b = random.choice(unselected)\n        neighbour = [x for x in neighbour if x != a] + [b]\n        neighbour = repair_to_feasible(neighbour)\n    elif move == \"add\" and unselected:\n        b = random.choice(unselected)\n        neighbour = neighbour + [b]\n        neighbour = repair_to_feasible(neighbour)\n    elif move == \"remove\" and sel:\n        # remove the worst item by score per time if feasible\n        worst = None\n        worst_key = None\n        for i in sel:\n            key = (scores[i-1]\/max(1, times[i-1]), -times[i-1], scores[i-1])\n            if worst_key is None or key > worst_key:\n                worst_key = key\n                worst = i\n        tentative = [x for x in neighbour if x != worst]\n        if total_time_of(tentative) >= 2750:\n            neighbour = tentative\n        else:\n            # fallback to swap to maintain feasibility\n            cand = [i for i in range(1, n+1) if i not in set(neighbour)]\n            if cand:\n                b = random.choice(cand)\n                neighbour = tentative + [b]\n                neighbour = repair_to_feasible(neighbour)\n    elif move == \"drop2add2\":\n        drop = random.sample(list(sel), k=min(2, len(sel))) if sel else []\n        neighbour = [x for x in neighbour if x not in set(drop)]\n        add_cand = [i for i in range(1, n+1) if i not in set(neighbour)]\n        add_k = min(2, len(add_cand))\n        if add_k > 0:\n            add = random.sample(add_cand, k=add_k)\n            neighbour += add\n        neighbour = repair_to_feasible(neighbour)\n    else:\n        # noop fallback -> small random tweak\n        if unselected:\n            b = random.choice(unselected)\n            neighbour = repair_to_feasible(neighbour + [b])\n\n    # Final sanitize, repair, and tightening to ensure feasibility and minimize score\n    neighbour = sanitize(neighbour)\n    neighbour = repair_to_feasible(neighbour)\n    neighbour = tightening(neighbour)\n\n    return (neighbour, movement)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    def sanitize(lst):\n        out = []\n        seen = set()\n        if isinstance(lst, list):\n            for v in lst:\n                if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                    out.append(v)\n                    seen.add(v)\n        return out\n\n    def total_time_of(lst):\n        return sum(times[i-1] for i in lst)\n\n    def repair_to_feasible(cur):\n        cur = sanitize(cur)\n        if total_time_of(cur) >= 2750:\n            return cur\n        remaining = [i for i in range(1, n+1) if i not in set(cur)]\n        remaining.sort(key=lambda i: (-(times[i-1] \/ max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        for i in remaining:\n            cur.append(i)\n            if total_time_of(cur) >= 2750:\n                break\n        return sanitize(cur)\n\n    def tightening(cur):\n        cur = sanitize(cur)\n        improved = True\n        while improved and cur:\n            improved = False\n            cur_time = total_time_of(cur)\n            best_idx = None\n            best_gain = 0\n            for idx in cur:\n                if cur_time - times[idx-1] >= 2750:\n                    gain = scores[idx-1]\n                    if gain > best_gain or (gain == best_gain and (best_idx is not None and times[idx-1] < times[best_idx-1])):\n                        best_gain = gain\n                        best_idx = idx\n            if best_idx is not None and best_gain > 0:\n                cur = [x for x in cur if x != best_idx]\n                improved = True\n        return sanitize(cur)\n\n    base = sanitize(solution)\n    if not base:\n        base = random.sample(range(1, n+1), k=min(5, n))\n    base = repair_to_feasible(base)\n\n    # Adaptive perturbation strength\n    k = max(1, min(4, len(base)\/\/10 + 1))\n\n    # Drop-k: target items with highest score per time to escape local minima\n    ranked = sorted(base, key=lambda i: (scores[i-1]\/max(1, times[i-1]), -times[i-1], scores[i-1]), reverse=True)\n    drop = ranked[:k]\n    shaken = [x for x in base if x not in set(drop)]\n\n    # Random ejection chain: swap a few times to diversify\n    ops = random.randint(2, 5)\n    cur = list(shaken)\n    for _ in range(ops):\n        if not cur:\n            break\n        if random.random() < 0.5 and len(cur) > 0:\n            # remove random\n            a = random.choice(cur)\n            cur = [x for x in cur if x != a]\n        else:\n            # add random\n            cand = [i for i in range(1, n+1) if i not in set(cur)]\n            if cand:\n                cur.append(random.choice(cand))\n\n    # Repair and tighten\n    cur = repair_to_feasible(cur)\n    cur = tightening(cur)\n    return cur\n","Version":0}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"list_of_unique_1_based_indices","Evaluacion":"import math\nfrom typing import List\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    # Type and value validation\n    if not isinstance(solution, list):\n        return float('inf')\n    if any((not isinstance(i, int)) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > n for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n\n    # Feasibility check\n    total_time = 0\n    for i in solution:\n        total_time += times[i-1]\n    if total_time < 2750:\n        return float('inf')\n\n    # Objective: minimize total score\n    total_score = 0\n    for i in solution:\n        total_score += scores[i-1]\n    return float(total_score)\n","Vecindad":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    # Helpers\n    def sanitize(lst: List[int]) -> List[int]:\n        if not isinstance(lst, list):\n            return []\n        out = []\n        seen = set()\n        for v in lst:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                out.append(v)\n                seen.add(v)\n        return out\n\n    def greedy_seed() -> List[int]:\n        # Build by descending time\/score ratio\n        order = sorted(range(1, n+1), key=lambda i: (-(times[i-1]\/max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        sel = []\n        t = 0\n        for i in order:\n            sel.append(i)\n            t += times[i-1]\n            if t >= 2750:\n                break\n        return sel\n\n    def repair_to_feasible(cur: List[int]) -> List[int]:\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        if t >= 2750:\n            return cur\n        remaining = [i for i in range(1, n+1) if i not in set(cur)]\n        remaining.sort(key=lambda i: (-(times[i-1]\/max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        for i in remaining:\n            cur.append(i)\n            t += times[i-1]\n            if t >= 2750:\n                break\n        return cur\n\n    def tightening(cur: List[int]) -> List[int]:\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        if not cur:\n            return cur\n        while True:\n            best_idx = None\n            best_gain = -1\n            best_t = None\n            for idx in cur:\n                ti = times[idx-1]\n                if t - ti >= 2750:\n                    gain = scores[idx-1]\n                    if gain > best_gain or (gain == best_gain and (best_t is None or ti < best_t)):\n                        best_gain = gain\n                        best_idx = idx\n                        best_t = ti\n            if best_idx is not None and best_gain > 0:\n                cur.remove(best_idx)\n                t -= times[best_idx-1]\n            else:\n                break\n        return cur\n\n    # Start from sanitized input or greedy seed\n    base = sanitize(solution)\n    if not base:\n        base = greedy_seed()\n    base = repair_to_feasible(base)\n    base = tightening(base)\n\n    sel_set = set(base)\n    unselected = [i for i in range(1, n+1) if i not in sel_set]\n\n    # Surplus-based move selection\n    current_time = sum(times[i-1] for i in base)\n    surplus = current_time - 2750\n    moves = []\n    if surplus > 200:\n        moves = [\"remove\"]*5 + [\"swap\"]*3 + [\"drop2add2\"]*2\n    elif surplus > 0:\n        moves = [\"swap\"]*5 + [\"remove\"]*3 + [\"add\"]*2 + [\"drop2add2\"]*2\n    else:\n        moves = [\"add\"]*5 + [\"swap\"]*4 + [\"drop2add2\"]*1\n\n    move = random.choice(moves) if moves else \"swap\"\n    neighbour = list(base)\n\n    if move == \"swap\" and sel_set and unselected:\n        a = random.choice(list(sel_set))\n        b = random.choice(unselected)\n        neighbour = [x for x in neighbour if x != a] + [b]\n        neighbour = repair_to_feasible(neighbour)\n    elif move == \"add\" and unselected:\n        b = random.choice(unselected)\n        neighbour = neighbour + [b]\n        neighbour = repair_to_feasible(neighbour)\n    elif move == \"remove\" and sel_set:\n        # remove the worst by score\/time if feasible; else try swap fallback\n        worst = None\n        worst_key = None\n        for i in sel_set:\n            key = (scores[i-1]\/max(1, times[i-1]), -times[i-1], scores[i-1])\n            if worst_key is None or key > worst_key:\n                worst_key = key\n                worst = i\n        tentative = [x for x in neighbour if x != worst]\n        if sum(times[i-1] for i in tentative) >= 2750:\n            neighbour = tentative\n        else:\n            cand = [i for i in range(1, n+1) if i not in set(neighbour)]\n            if cand:\n                b = random.choice(cand)\n                neighbour = tentative + [b]\n                neighbour = repair_to_feasible(neighbour)\n    elif move == \"drop2add2\" and sel_set:\n        kdrop = min(2, len(sel_set))\n        drop = random.sample(list(sel_set), k=kdrop) if kdrop > 0 else []\n        remain = [x for x in neighbour if x not in set(drop)]\n        cand = [i for i in range(1, n+1) if i not in set(remain)]\n        kadd = min(2, len(cand))\n        add = random.sample(cand, k=kadd) if kadd > 0 else []\n        neighbour = remain + add\n        neighbour = repair_to_feasible(neighbour)\n    else:\n        # minimal tweak fallback\n        if unselected:\n            neighbour = repair_to_feasible(neighbour + [random.choice(unselected)])\n\n    neighbour = sanitize(neighbour)\n    neighbour = repair_to_feasible(neighbour)\n    neighbour = tightening(neighbour)\n\n    return (neighbour, move)\n","Perturbacion":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    def sanitize(lst: List[int]) -> List[int]:\n        out = []\n        seen = set()\n        if isinstance(lst, list):\n            for v in lst:\n                if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                    out.append(v)\n                    seen.add(v)\n        return out\n\n    def repair_to_feasible(cur: List[int]) -> List[int]:\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        if t >= 2750:\n            return cur\n        remaining = [i for i in range(1, n+1) if i not in set(cur)]\n        remaining.sort(key=lambda i: (-(times[i-1] \/ max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        for i in remaining:\n            cur.append(i)\n            t += times[i-1]\n            if t >= 2750:\n                break\n        return cur\n\n    def tightening(cur: List[int]) -> List[int]:\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        while True:\n            best_idx = None\n            best_gain = -1\n            best_t = None\n            for idx in cur:\n                ti = times[idx-1]\n                if t - ti >= 2750:\n                    gain = scores[idx-1]\n                    if gain > best_gain or (gain == best_gain and (best_t is None or ti < best_t)):\n                        best_gain = gain\n                        best_idx = idx\n                        best_t = ti\n            if best_idx is not None and best_gain > 0:\n                cur.remove(best_idx)\n                t -= times[best_idx-1]\n            else:\n                break\n        return cur\n\n    base = sanitize(solution)\n    if not base:\n        # Seed using greedy ratio if empty\n        order = sorted(range(1, n+1), key=lambda i: (-(times[i-1]\/max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        t = 0\n        base = []\n        for i in order:\n            base.append(i)\n            t += times[i-1]\n            if t >= 2750:\n                break\n    base = repair_to_feasible(base)\n\n    # Adaptive drop size\n    k = max(2, min(4, max(1, len(base)\/\/8)))\n\n    # Drop-k: highest score per time\n    ranked = sorted(base, key=lambda i: (scores[i-1]\/max(1, times[i-1]), -times[i-1], scores[i-1]), reverse=True)\n    drop = set(ranked[:k])\n    shaken = [x for x in base if x not in drop]\n\n    # Random ejection\/insertion chain\n    steps = random.randint(3, 6)\n    cur = list(shaken)\n    for _ in range(steps):\n        if random.random() < 0.5 and cur:\n            a = random.choice(cur)\n            cur = [x for x in cur if x != a]\n        else:\n            cand = [i for i in range(1, n+1) if i not in set(cur)]\n            if cand:\n                cur.append(random.choice(cand))\n\n    cur = repair_to_feasible(cur)\n    cur = tightening(cur)\n    return cur\n","Version":1}
{"ID_Problema":"knapsack_hard_dataset_in_house_24_9_sightseeing_inverted","Representacion":"list[int] of unique 1-based indices (sorted ascending), representing selected items S \u2286 {1..24}.","Evaluacion":"import math\n\ndef evaluate_solution(solution):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    # Validate type and values\n    if not isinstance(solution, list):\n        return float('inf')\n    if any((not isinstance(i, int)) for i in solution):\n        return float('inf')\n    if any(i < 1 or i > n for i in solution):\n        return float('inf')\n    if len(solution) != len(set(solution)):\n        return float('inf')\n\n    # Feasibility check\n    total_time = 0\n    for i in solution:\n        total_time += times[i-1]\n    if total_time < 2750:\n        return float('inf')\n\n    # Objective: minimize total score\n    total_score = 0\n    for i in solution:\n        total_score += scores[i-1]\n    return float(total_score)\n","Vecindad":"import random\n\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    # Helpers\n    def sanitize(lst):\n        if not isinstance(lst, list):\n            return []\n        seen = set()\n        out = []\n        for v in lst:\n            if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                seen.add(v)\n                out.append(v)\n        out.sort()\n        return out\n\n    def greedy_seed():\n        order = sorted(range(1, n+1), key=lambda i: (-(times[i-1]\/max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        sel = []\n        t = 0\n        for i in order:\n            sel.append(i)\n            t += times[i-1]\n            if t >= 2750:\n                break\n        sel.sort()\n        return sel\n\n    def repair_to_feasible(cur):\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        if t >= 2750:\n            return cur\n        remaining = [i for i in range(1, n+1) if i not in set(cur)]\n        # diversify among top-3 by ratio\n        remaining.sort(key=lambda i: (-(times[i-1] \/ max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        while t < 2750 and remaining:\n            k = min(3, len(remaining))\n            pick = random.choice(remaining[:k])\n            cur.append(pick)\n            t += times[pick-1]\n            remaining.remove(pick)\n        cur.sort()\n        return cur\n\n    def tightening(cur):\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        changed = True\n        while changed:\n            changed = False\n            best_idx = None\n            best_key = None\n            for idx in cur:\n                ti = times[idx-1]\n                if t - ti >= 2750:\n                    si = scores[idx-1]\n                    key = (si\/ti, si, -ti)  # prioritize high score per time, then score\n                    if best_key is None or key > best_key:\n                        best_key = key\n                        best_idx = idx\n            if best_idx is not None:\n                cur.remove(best_idx)\n                t -= times[best_idx-1]\n                changed = True\n        return cur\n\n    base = sanitize(solution)\n    if not base:\n        base = greedy_seed()\n    base = repair_to_feasible(base)\n    base = tightening(base)\n\n    sel_set = set(base)\n    unselected = [i for i in range(1, n+1) if i not in sel_set]\n\n    current_time = sum(times[i-1] for i in base)\n    surplus = current_time - 2750\n    avg_t = max(1.0, sum(times)\/len(times))\n    # proportional move selection\n    p_remove = 1.0\/(1.0 + pow(2.718281828, -surplus\/avg_t))  # sigmoid\n    moves = []\n    if random.random() < p_remove:\n        moves += [\"remove\"]*5 + [\"swap\"]*3 + [\"dropKaddK\"]*2\n    else:\n        moves += [\"add\"]*5 + [\"swap\"]*4 + [\"dropKaddK\"]*1\n    move = random.choice(moves) if moves else \"swap\"\n\n    neighbour = list(base)\n\n    if move == \"swap\" and sel_set and unselected:\n        a = random.choice(list(sel_set))\n        b = random.choice(unselected)\n        neighbour = [x for x in neighbour if x != a]\n        neighbour.append(b)\n        neighbour = repair_to_feasible(neighbour)\n    elif move == \"add\" and unselected:\n        b = random.choice(unselected)\n        neighbour = neighbour + [b]\n        neighbour = repair_to_feasible(neighbour)\n    elif move == \"remove\" and sel_set:\n        # remove worst by score\/time if feasible\n        worst = None\n        worst_key = None\n        for i in sel_set:\n            key = (scores[i-1]\/max(1, times[i-1]), -times[i-1], scores[i-1])\n            if worst_key is None or key > worst_key:\n                worst_key = key\n                worst = i\n        tentative = [x for x in neighbour if x != worst]\n        if sum(times[i-1] for i in tentative) >= 2750:\n            neighbour = tentative\n        else:\n            cand = [i for i in range(1, n+1) if i not in set(neighbour)]\n            if cand:\n                b = random.choice(cand)\n                neighbour = tentative + [b]\n                neighbour = repair_to_feasible(neighbour)\n    elif move == \"dropKaddK\" and sel_set:\n        # adaptive K based on surplus\n        K = min(5, max(1, int(abs(surplus)\/avg_t) + 2))\n        kdrop = min(K, len(sel_set))\n        # drop highest score\/time\n        drop_order = sorted(list(sel_set), key=lambda i: (scores[i-1]\/max(1, times[i-1]), -times[i-1], scores[i-1]), reverse=True)\n        drop = set(drop_order[:kdrop])\n        remain = [x for x in neighbour if x not in drop]\n        cand = [i for i in range(1, n+1) if i not in set(remain)]\n        # add up to K using diversified greedy top-3\n        cand.sort(key=lambda i: (-(times[i-1]\/max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        cur = list(remain)\n        t = sum(times[i-1] for i in cur)\n        j = 0\n        while j < K and cand:\n            pick = random.choice(cand[:min(3, len(cand))])\n            cur.append(pick)\n            t += times[pick-1]\n            cand.remove(pick)\n            j += 1\n        neighbour = repair_to_feasible(cur)\n    else:\n        # minimal tweak fallback\n        if unselected:\n            neighbour = repair_to_feasible(neighbour + [random.choice(unselected)])\n\n    neighbour = sanitize(neighbour)\n    neighbour = repair_to_feasible(neighbour)\n    neighbour = tightening(neighbour)\n\n    return (neighbour, move)\n","Perturbacion":"import random\n\n\ndef perturb_solution(solution):\n    # Embedded problem data\n    scores = [15,5,9,20,5,16,4,18,14,13,11,6,24,5,6,22,23,21,14,1,1,11,1,17]\n    times  = [110,20,240,30,150,90,120,10,210,190,220,220,90,10,130,160,210,50,60,100,130,80,120,90]\n    n = 24\n\n    def sanitize(lst):\n        out = []\n        seen = set()\n        if isinstance(lst, list):\n            for v in lst:\n                if isinstance(v, int) and 1 <= v <= n and v not in seen:\n                    out.append(v)\n                    seen.add(v)\n        out.sort()\n        return out\n\n    def repair_to_feasible(cur):\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        if t >= 2750:\n            return cur\n        remaining = [i for i in range(1, n+1) if i not in set(cur)]\n        remaining.sort(key=lambda i: (-(times[i-1] \/ max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        while t < 2750 and remaining:\n            pick = random.choice(remaining[:min(3, len(remaining))])\n            cur.append(pick)\n            t += times[pick-1]\n            remaining.remove(pick)\n        cur.sort()\n        return cur\n\n    def tightening(cur):\n        cur = sanitize(cur)\n        t = sum(times[i-1] for i in cur)\n        changed = True\n        while changed:\n            changed = False\n            best_idx = None\n            best_key = None\n            for idx in cur:\n                ti = times[idx-1]\n                if t - ti >= 2750:\n                    si = scores[idx-1]\n                    key = (si\/ti, si, -ti)\n                    if best_key is None or key > best_key:\n                        best_key = key\n                        best_idx = idx\n            if best_idx is not None:\n                cur.remove(best_idx)\n                t -= times[best_idx-1]\n                changed = True\n        return cur\n\n    base = sanitize(solution)\n    if not base:\n        # Seed using greedy ratio if empty\n        order = sorted(range(1, n+1), key=lambda i: (-(times[i-1]\/max(1, scores[i-1])), scores[i-1], -times[i-1]))\n        t = 0\n        base = []\n        for i in order:\n            base.append(i)\n            t += times[i-1]\n            if t >= 2750:\n                break\n    base = repair_to_feasible(base)\n\n    # Determine perturbation strength\n    cur_time = sum(times[i-1] for i in base)\n    surplus = max(0, cur_time - 2750)\n    r = max(1, min(5, max(1, len(base)\/\/3)))\n    if surplus > 300:\n        r = min(5, r + 1)\n\n    # Drop r items with highest score per time\n    ranked = sorted(base, key=lambda i: (scores[i-1]\/max(1, times[i-1]), -times[i-1], scores[i-1]), reverse=True)\n    drop = set(ranked[:r])\n    shaken = [x for x in base if x not in drop]\n\n    # Random ejection\/insertion chain\n    steps = random.randint(3, 6)\n    cur = list(shaken)\n    for _ in range(steps):\n        if random.random() < 0.5 and cur:\n            a = random.choice(cur)\n            cur = [x for x in cur if x != a]\n        else:\n            cand = [i for i in range(1, n+1) if i not in set(cur)]\n            if cand:\n                cur.append(random.choice(cand))\n\n    cur = repair_to_feasible(cur)\n    cur = tightening(cur)\n    return cur\n","Version":2}
