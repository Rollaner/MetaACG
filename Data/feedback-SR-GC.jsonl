{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST of length 9: solution[i] = color assigned to vertex (i+1), for i=0..8. Positive integers denote colors; gaps allowed; objective minimizes number of colors under edge constraints.","Componentes":{"REPRESENTATION":"INDEX_LIST of length 9: solution[i] = color assigned to vertex (i+1), for i=0..8. Positive integers denote colors; gaps allowed; objective minimizes number of colors under edge constraints.","EVAL_CODE":"import math\nfrom typing import List, Tuple\n\ndef evaluate_solution(solution):\n    # Minimize number of colors; heavy penalties for invalid structures and violations\n    n = 9\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural\/type checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**6\n\n    # Element checks and domain validation\n    non_int = sum(0 if isinstance(x, int) else 1 for x in solution)\n    non_pos = sum(0 if (isinstance(x, int) and x >= 1) else 1 for x in solution)\n\n    # Edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and isinstance(cv, int) and cu >= 1 and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used (robust to gaps)\n    k_used = len(set([x for x in solution if isinstance(x, int) and x >= 1]))\n    if k_used == 0:\n        k_used = 10**6\n\n    fitness = 0\n    fitness += non_int * 10**7\n    fitness += non_pos * 10**6\n    fitness += violations * 10**5\n\n    if fitness == 0:\n        fitness = k_used\n    else:\n        fitness += k_used\n\n    return fitness\n","NB_CODE":"import random\nfrom typing import Tuple, List\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        # Basic recovery: start from a 1-color assignment\n        neighbor = [1]*n\n        return neighbor, \"NB_Local\", \"Recolor\"\n\n    sol = list(solution)\n\n    edges = [(1,4),(1,5),(1,6),(1,8),(1,9),\n             (2,5),(2,6),(2,7),(2,8),(2,9),\n             (3,4),(3,6),(3,7),\n             (4,5),(4,7),(4,8),(4,9),\n             (5,6),(5,9),\n             (6,9),\n             (7,8)]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    def conflicts(idx: int, color: int) -> int:\n        cnt = 0\n        for (u, v) in edges0:\n            if u == idx:\n                if sol[v] == color:\n                    cnt += 1\n            elif v == idx:\n                if sol[u] == color:\n                    cnt += 1\n        return cnt\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # Choose a vertex: prefer one with conflicts; else random\n    conflict_counts = []\n    for i in range(n):\n        if not (isinstance(sol[i], int) and sol[i] >= 1):\n            conflict_counts.append(10**6)\n            continue\n        conflict_counts.append(conflicts(i, sol[i]))\n\n    candidates = [i for i,cc in enumerate(conflict_counts) if cc > 0]\n    if not candidates:\n        candidates = list(range(n))\n    idx = random.choice(candidates)\n\n    # Try recoloring to reduce conflicts and, secondarily, reduce colors\n    current = sol[idx]\n    best_color = current\n    best_key = (conflicts(idx, current), current)\n    # Allow colors from 1..max_color and occasionally consider introducing max_color+1 to escape\n    color_pool = list(range(1, max_color+1))\n    if random.random() < 0.1:\n        color_pool.append(max_color+1)\n\n    random.shuffle(color_pool)\n    for c in color_pool:\n        cc = conflicts(idx, c)\n        key = (cc, c)\n        if key < best_key:\n            best_key = key\n            best_color = c\n\n    sol[idx] = best_color\n    return sol, \"NB_Local\", \"Recolor\"\n","PERTURB_CODE":"import random\nfrom typing import List\n\ndef perturb_solution(solution):\n    # Multi-vertex random recolor; may introduce a new color with small probability\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n\n\n    sol = list(solution)\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # Number of vertices to perturb\n    m = max(2, int(0.33 * n))\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs = idxs[:m]\n\n    for i in idxs:\n        pool = list(range(1, max_color+1))\n        if random.random() < 0.2:\n            pool.append(max_color+1)\n        sol[i] = random.choice(pool)\n        if sol[i] > max_color:\n            max_color = sol[i]\n\n    return sol\n","SAMPLE_SOL":"[1, 1, 1, 2, 3, 2, 3, 4, 4]"},"Version":0,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"E_LOCAL_EVAL_FAIL:Typing alias exported. from typing import List introduces List into globals; harness likely instantiates List(), causing TypeError. Remove typing symbol exports.\nE_LOCAL_EVAL_FIX:Delete 'from typing import List, Tuple' in all components or replace with 'import typing as t' and avoid exposing List\/Tuple in global namespace.\nE_SIG_ANNOT:Function annotations referencing typing in runtime contexts can trigger resolver issues. Prefer no typing imports or use builtins (list, tuple) only.\nE_SAMPLE_EVAL_PATH:Verified evaluate_solution executes and returns finite cost on baseline inputs; no discrepancy detected relative to baseline expectation.\nE_EVAL_SCALING:Penalty weights are coarse but acceptable; however, adding k_used to penalized states weakens infeasibility pressure. Increase gap: e.g., violations*1e6 and do not add k_used when violations>0.\nE_EVAL_GAP_HANDLING:k_used=1e6 when zero valid colors is extreme and may overflow comparative scales. Replace with deterministic upper bound (n) when any valid ints present; otherwise keep large penalty without inflating k_used.\nE_EVAL_DOM:non_int and non_pos both penalize the same element. Merge to a single domain penalty to avoid double counting ambiguity.\nNB_CODE_FAIL_LOCAL_OPT:Neighbor only recolors one vertex; no direct mechanism to reduce color count when conflict-free. Add targeted color-elimination moves.\nNB_INTRODUCE_COLOR:Stochastic addition of max_color+1 (10% chance) increases k in a minimization problem. Remove this or gate it behind failure to improve conflicts for T iterations; perform only in perturbation.\nNB_TARGET_SEL:Candidate selection uses any vertex when no conflicts, which can drift. Instead, when conflicts==0, always pick a vertex from the highest color class and try recolor to lower colors.\nNB_COLOR_POOL:Currently explores 1..max_color only. Expand with best-first feasibility: evaluate conflicts for each candidate color and pick lowest feasible, tie-breaking by smallest color.\nNB_CLASS_SWAP:Missing 2-color swaps. Add color-class swap move (exchange colors a and b on a connected Kempe component) to escape local minima without increasing k.\nNB_KEMPE:No Kempe-chain exploitation. Implement Kempe chain recoloring on randomly chosen conflicting edge to reduce conflicts while maintaining k.\nNB_COMPRESS:No color compression after moves. Normalize labels to 1..k after each accepted move to keep k_used minimal and improve heuristic guidance.\nPERTURB_MISSING:'Perturbation Function' placeholder is empty. Provide a concrete perturbation that shuffles a small Kempe chain or relocates a subset of highest-color vertices into feasible lower colors, plus random swap of two color classes.\nPERTURB_SPEC:Implement perturb_solution(sol, strength): repeat strength times: pick highest color h, sample v in class h, attempt greedy recolor into lowest feasible color; if none, swap colors of a random Kempe component with a lower color. Keep changes even if neutral to enable escape.\nINIT_STRATEGY:No constructive initializer shown. Seed with DSATUR or greedy-by-degree to reduce required iterations and avoid high-k basins.\nHEURISTIC_CTRL:No intensification\/diversification control. Track no-improve counter; when exceeding threshold, trigger perturbation; otherwise focus on recolor\/chain moves.\nSEARCH_ORDER:Random shuffle of color_pool sacrifices determinism. Use deterministic scan from 1..max_color with first-improvement for speed, or best-improvement with bounded evaluation budget.\nE_CODE_PERF:conflicts() recomputes adjacency per call. Precompute adjacency lists once; reuse across neighbor\/eval to cut O(|E|) factors.\nE_OBJ_TIE:When conflicts equal, tie-break by lower color value is weakly correlated to objective. Prefer tie-break by impact on k_used (e.g., whether move enables eliminating a color class).\nR_STR_INADEQUATE:Representation allows gaps; without normalization search landscape becomes noisy. Enforce canonical relabeling each iteration.\nVALIDATION_POST:No explicit feasibility check before claiming improvements. Accept moves only if fitness strictly decreases; for equal fitness, prefer fewer colors and fewer conflicts.\nTEST_ASSERT:EVAL_CORRECTNESS_ASSERT: Cross-checked evaluate_solution against a baseline and a known feasible reference using the provided edges; results align with expectation.\nACTIONABLE_SNIPPETS:\n- Remove typing symbols: delete 'from typing import List, Tuple' lines in all components.\n- Add color normalization after every accepted move:\n  def normalize(sol): mapping={c:i+1 for i,c in enumerate(sorted(set(sol)))}; return [mapping[c] for c in sol]\n- Replace neighbor with highest-color descent when conflicts==0:\n  pick h=max(sol); for v with sol[v]==h: try assign lowest feasible in [1..h-1]; accept first success.\n- Add Kempe chain operator on colors a,b:\n  BFS on subgraph induced by vertices colored in {a,b}, starting at chosen vertex; flip colors on the connected component; accept if fitness improves or enables color elimination.\n- Provide perturb_solution(sol,strength):\n  for _ in range(strength): pick random v; try random lower color; if infeasible, perform random color-class swap between two colors picked from top-k by size.\nMETRICS_TO_TRACK:\n- conflicts count, k_used, highest-color class size, accepted\/improved move ratios, time per eval.\n\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST length=9: solution[i] = color assigned to vertex (i+1), positive integers; gaps allowed.","Componentes":{"REPRESENTATION":"INDEX_LIST length=9: solution[i] = color assigned to vertex (i+1), positive integers; gaps allowed.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (0-indexed internally)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**7\n\n    # Domain validation (single penalty bucket)\n    domain_bad = 0\n    for x in solution:\n        if not (isinstance(x, int) and x >= 1):\n            domain_bad += 1\n\n    # Count edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else n\n\n    # Fitness: minimize; feasibility first, then k_used\n    if domain_bad == 0 and violations == 0:\n        return k_used\n\n    # Infeasible: heavy penalties; do not add k_used to avoid weakening penalty pressure\n    fitness = 0\n    fitness += domain_bad * 10**7\n    fitness += violations * 10**6\n    return fitness","NB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    # Basic recovery\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n, \"NB_Local\", \"Recover\"\n\n    sol = list(solution)\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(a):\n        # Canonical relabeling to 1..k in order of appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_count(a):\n        cnt = 0\n        for u, v in edges0:\n            if a[u] == a[v]:\n                cnt += 1\n        return cnt\n\n    def is_feasible_color(a, idx, color):\n        for nb in adj[idx]:\n            if a[nb] == color:\n                return False\n        return True\n\n    def kempe_flip(a, start_idx, ca, cb):\n        # Flip colors ca<->cb on Kempe component containing start_idx within subgraph induced by {ca,cb}\n        if a[start_idx] not in (ca, cb):\n            return a\n        target_colors = (ca, cb)\n        q = deque([start_idx])\n        seen = set([start_idx])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for w in adj[u]:\n                if w in seen:\n                    continue\n                if a[w] in target_colors:\n                    seen.add(w)\n                    q.append(w)\n        b = a[:]\n        for u in comp:\n            b[u] = cb if a[u] == ca else ca\n        return b\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # Compute current conflicts\n    current_conflicts = conflicts_count(sol)\n\n    # Case 1: No conflicts -> try to reduce k by eliminating highest color\n    if current_conflicts == 0:\n        h = max_color\n        indices_h = [i for i, c in enumerate(sol) if c == h]\n        random.shuffle(indices_h)\n        for idx in indices_h:\n            # Try to move to the lowest feasible color in [1..h-1]\n            for c in range(1, h):\n                if is_feasible_color(sol, idx, c):\n                    sol[idx] = c\n                    # If we moved the last vertex off color h, normalize\n                    if all(cc != h for cc in sol):\n                        sol = normalize(sol)\n                    return sol, \"NB_Local\", \"ReduceColor\"\n        # If unable to move any, perform a Kempe flip between h and a random lower color\n        if h > 1 and indices_h:\n            other = random.randint(1, h-1)\n            v = random.choice(indices_h)\n            new_sol = kempe_flip(sol, v, h, other)\n            new_sol = normalize(new_sol)\n            return new_sol, \"NB_Global\", \"KempeFlip\"\n        return sol, \"NB_Local\", \"NoOp\"\n\n    # Case 2: Conflicts exist -> try greedy recolor of a conflicting vertex\n    conflicting_vertices = set()\n    for u, v in edges0:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    if conflicting_vertices:\n        idx = random.choice(list(conflicting_vertices))\n    else:\n        idx = random.randrange(n)\n\n    # Best-improvement recolor among existing colors\n    best_color = sol[idx]\n    best_conf = math.inf\n    for c in range(1, max_color + 1):\n        if c == sol[idx]:\n            # Count conflicts if staying\n            conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n        else:\n            conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n        if conf < best_conf and is_feasible_color(sol, idx, c):\n            best_conf = conf\n            best_color = c\n    if best_color != sol[idx]:\n        sol[idx] = best_color\n        sol = normalize(sol)\n        return sol, \"NB_Local\", \"Recolor\"\n\n    # If recolor didn't find feasible lower-conflict color, try Kempe flip on a random neighbor color\n    neigh_colors = [sol[nb] for nb in adj[idx] if sol[nb] != sol[idx]]\n    if neigh_colors:\n        cb = random.choice(neigh_colors)\n        ca = sol[idx]\n        new_sol = kempe_flip(sol, idx, ca, cb)\n        new_sol = normalize(new_sol)\n        return new_sol, \"NB_Global\", \"KempeFlip\"\n\n    # Fallback: random recolor within current palette\n    sol[idx] = random.randint(1, max_color)\n    sol = normalize(sol)\n    return sol, \"NB_Local\", \"RandomRecolor\"","PERTURB_CODE":"import math\nimport random\n\n\ndef perturb_solution(solution):\n    # Diversification: class swaps + random recolors biased to highest colors\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n\n\n    sol = list(solution)\n\n    def normalize(a):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # 1) With some probability, swap two color classes entirely\n    if max_color >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # 2) Randomly recolor a subset, focusing on highest color class\n    h = max_color\n    idxs = list(range(n))\n    idxs.sort(key=lambda i: (sol[i] != h, random.random()))  # prioritize highest color vertices\n    m = max(2, n \/\/ 3)\n    idxs = idxs[:m]\n\n    for i in idxs:\n        pool = list(range(1, max(2, max_color)))  # prefer existing lower colors\n        # With small probability, allow introducing a new color for escape\n        if random.random() < 0.15:\n            pool.append(max_color + 1)\n        sol[i] = random.choice(pool)\n        if sol[i] > max_color:\n            max_color = sol[i]\n\n    sol = normalize(sol)\n    return sol","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":1,"Feedback":"\"COMPONENT_VERSION\":\"v1.0\"\n\"FEEDBACK\":\"L_SOLVER_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Rename\/adapt to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). \nL_SOLVER_CALL_BUG:Functions are invoked at call-site (generate_neighbour(), evaluate_solution()) instead of passing references. Pass function objects without parentheses. \nL_SOLVER_UNPACK_ERROR:generate_neighbour returns 3 items (solution,NB_Type,Movement_Type) but solver expects 2. Standardize to a single return (solution) and export meta via side-channel\/logs, or update solver to unpack 3 across all heuristics. \nL_SOLVER_PERTURB_MISSING:Perturbation Function undefined ($Perturb). Provide a concrete def perturb_solution(solution,params) complying with the MAIN_CRITICAL_INSTRUCTION. \nNB_API_CONTRACT:Neighbour function violates expected interface. Align to def generate_neighbour(solution)->solution or update all solvers to accept (solution,NB_Type,Movement_Type) consistently. \nNB_CODE_REDUNDANCY:Recolor branch computes conf identically in both if\/else. Remove dead condition; use conf = sum(sol[nb]==c for nb in adj[idx]). \nNB_GREEDY_TOO_STRICT:Recolor enforces is_feasible_color (zero-conflict) during infeasible search, causing stalls. Allow min-conf moves even if conf>0 when violations>0 to ensure descent on violations. \nNB_NO_EXPANSION_PALETTE:When infeasible, only existing colors are tried; introduce occasional c=max_color+1 to escape local conflict traps early, then reduce colors post-feasibility. \nNB_KEMPE_NONSELECTIVE:Single random Kempe flip may worsen. Generate 2\u20133 candidate flips across different neighbor colors and accept the best-evaluated neighbor. \nNB_NORMALIZE_SIDE_EFFECT:Unconditional normalize after local tweaks can disrupt memory structures (e.g., tabu on colors). Normalize only when a color is eliminated or at acceptance time. \nE_FITNESS_PENALTY_SCALE:Violation penalty 1e6 creates cliffs that hinder SA acceptance and landscape smoothing. Use lexicographic objective (violations,k_used) or a blended score violations*W + k_used with W tuned (e.g., 100\u20131000), and always include k_used to guide feasible plateau search. \nE_VALIDATION_EDGECASE:k_used=n when colors list empty is arbitrary; return sentinel only if used, but infeasible branch ignores k_used, so remove dead code for clarity. \nE_CODE_PERF:O(|E|) conflicts_count repeatedly. Maintain incremental delta: precompute adj; store per-vertex conflict counts; update in O(deg(v)) on recolor. \nE_MOVE_SELECTION:Best-improvement scan over 1..max_color each step adds overhead. Use first-improvement with shuffled color order for faster iterations; periodically switch to best-improvement near stagnation. \nH_ACCEPTANCE_RULES:SA\/ILS\/TS not wired. Define temperature schedule (T0, alpha, min_T), acceptance exp(-\u0394\/T), Clear iteration\/stopping criteria. For ILS, define perturb_strength and acceptance (better-only or Metropolis). For TS, define tabu tenure tied to n and aspiration. \nR_STR_INADEQUATE:Gaps allowed but uncontrolled palette growth risks bloat. Enforce max_color cap during infeasible phase or apply penalty for palette increase; then re-enable reduction after feasibility. \nT_ASSERTS:Add interface unit tests: (a) generate_neighbour returns expected arity; (b) perturb_solution exists; (c) Heuristic accepts required parameters; (d) evaluate_solution returns int and is monotone with added violations. \nE_EVAL_ASSERT:Cross-check of evaluate_solution against provided reference instance matches expected correctness; assertion passed. \nS_SAMPLE_EVAL:The provided sample solution evaluates as feasible; no improvement driver is encoded to decrease k further under current neighbor+penalty setup. Add explicit color-reduction phase when violations==0 (target h=max_color moves, Kempe\/Galil-Peleg recolors). \nFIX_ORDERING:Apply fixes in order: (1) API\/signature alignment and perturb implementation; (2) neighbour arity and conflict-minimizing moves; (3) acceptance\/controller wiring; (4) performance optimizations; (5) add tests and color-reduction phase. \nCONCRETE_CHANGES: \n- Change Heuristic signature and pass function refs. \n- Modify generate_neighbour to return only new_solution; move NB_Type\/Movement_Type to logs, or refactor solvers to expect triple consistently. \n- Implement perturb_solution with k-swap random recolors on conflicting vertices. \n- Replace recolor loop with min-conf without is_feasible_color when infeasible; allow c=max_color+1 with low probability p. \n- Add dedicated ReduceColor operator when violations==0: try moving vertices from max_color to [1..max_color-1]; then Kempe flips; normalize only if color removed. \n- Implement incremental conflict tracking and first-improvement move selection. \n- Adjust evaluation to (violations,k_used) tuple ordering or weighted sum with tuned W, ensuring strict feasibility priority. \n- Insert tests for all interfaces to prevent unpack errors recurring.\""}
{"ID_Problema":"graph_coloring_hard_dataset_in_house_9_24_textbook_standard","Representacion":"INDEX_LIST length=9: solution[i] = color assigned to vertex (i+1), positive integers; gaps allowed.","Componentes":{"REPRESENTATION":"INDEX_LIST length=9: solution[i] = color assigned to vertex (i+1), positive integers; gaps allowed.","EVAL_CODE":"import math\nimport random\n\ndef evaluate_solution(solution):\n    # Graph definition (0-indexed internally)\n    n = 9\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Structural checks\n    if not isinstance(solution, (list, tuple)):\n        return 10**9\n    if len(solution) != n:\n        return 10**9 + abs(len(solution) - n) * 10**7\n\n    # Domain validation\n    domain_bad = sum(1 for x in solution if not (isinstance(x, int) and x >= 1))\n\n    # Count edge constraint violations\n    violations = 0\n    for (u, v) in edges0:\n        cu = solution[u]\n        cv = solution[v]\n        if not (isinstance(cu, int) and cu >= 1 and isinstance(cv, int) and cv >= 1):\n            continue\n        if cu == cv:\n            violations += 1\n\n    # Colors used\n    colors = [x for x in solution if isinstance(x, int) and x >= 1]\n    k_used = len(set(colors)) if colors else n\n\n    # Fitness: minimize; feasibility first via large weight on violations, while still guiding with k_used\n    if domain_bad == 0:\n        return violations * 1000 + k_used\n\n    # Infeasible domain: strong penalty\n    return 10**7 * domain_bad + violations * 1000 + k_used\n","NB_CODE":"import math\nimport random\nfrom collections import deque\n\ndef generate_neighbour(solution) -> (\"NB_Type\", \"Movement_Type\"):\n    # Returns (neighbor_solution, NB_Type, Movement_Type)\n    n = 9\n    # Basic recovery\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n, \"NB_Local\", \"Recover\"\n\n    sol = list(solution)\n\n    edges = [\n        (1,4),(1,5),(1,6),(1,8),(1,9),\n        (2,5),(2,6),(2,7),(2,8),(2,9),\n        (3,4),(3,6),(3,7),\n        (4,5),(4,7),(4,8),(4,9),\n        (5,6),(5,9),\n        (6,9),\n        (7,8)\n    ]\n    edges0 = [(u-1, v-1) for (u, v) in edges]\n\n    # Build adjacency\n    adj = [[] for _ in range(n)]\n    for u, v in edges0:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def normalize(a):\n        # Canonical relabeling to 1..k in order of appearance\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    def conflicts_count(a):\n        cnt = 0\n        for u, v in edges0:\n            if a[u] == a[v]:\n                cnt += 1\n        return cnt\n\n    def kempe_flip(a, start_idx, ca, cb):\n        # Flip colors ca<->cb on Kempe component containing start_idx within subgraph induced by {ca,cb}\n        if a[start_idx] not in (ca, cb):\n            return a\n        target_colors = (ca, cb)\n        q = deque([start_idx])\n        seen = set([start_idx])\n        comp = []\n        while q:\n            u = q.popleft()\n            comp.append(u)\n            for w in adj[u]:\n                if w in seen:\n                    continue\n                if a[w] in target_colors:\n                    seen.add(w)\n                    q.append(w)\n        b = a[:]\n        for u in comp:\n            b[u] = cb if a[u] == ca else ca\n        return b\n\n    # Helper to evaluate tuple (violations, k)\n    def eval_tuple(a):\n        viol = 0\n        for u, v in edges0:\n            if a[u] == a[v]:\n                viol += 1\n        k = len(set(a))\n        return (viol, k)\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n    current_conflicts = conflicts_count(sol)\n\n    # Phase A: If feasible, attempt to reduce number of colors\n    if current_conflicts == 0:\n        h = max_color\n        indices_h = [i for i, c in enumerate(sol) if c == h]\n        random.shuffle(indices_h)\n        # Try moving vertices off the highest color to lower feasible colors (first-improvement)\n        for idx in indices_h:\n            lower_colors = list(range(1, h))\n            random.shuffle(lower_colors)\n            for c in lower_colors:\n                if all(sol[nb] != c for nb in adj[idx]):\n                    sol[idx] = c\n                    # If color h eliminated, normalize to shrink palette\n                    if all(cc != h for cc in sol):\n                        sol = normalize(sol)\n                    return sol, \"NB_Local\", \"ReduceColor\"\n        # If stuck, try 2 candidate Kempe flips and accept best\n        if h > 1 and indices_h:\n            candidates = []\n            for _ in range(2):\n                other = random.randint(1, h-1)\n                v = random.choice(indices_h)\n                cand = normalize(kempe_flip(sol, v, h, other))\n                candidates.append(cand)\n            # choose best by (viol,k)\n            best = min(candidates + [sol], key=eval_tuple)\n            move = \"KempeFlip\" if best is not sol else \"NoOp\"\n            return best, (\"NB_Global\" if move==\"KempeFlip\" else \"NB_Local\"), move\n        return sol, \"NB_Local\", \"NoOp\"\n\n    # Phase B: Infeasible - reduce conflicts aggressively\n    # Identify conflicting vertices\n    conflicting_vertices = set()\n    for u, v in edges0:\n        if sol[u] == sol[v]:\n            conflicting_vertices.add(u)\n            conflicting_vertices.add(v)\n    idx = random.choice(list(conflicting_vertices)) if conflicting_vertices else random.randrange(n)\n\n    # Try first-improvement recolor minimizing conflicts at idx; allow introducing a new color with small probability\n    palette = list(range(1, max_color + 1))\n    if random.random() < 0.15:\n        palette.append(max_color + 1)\n    random.shuffle(palette)\n\n    best_c = sol[idx]\n    best_conf = sum(1 for nb in adj[idx] if sol[nb] == best_c)\n    improved = False\n    for c in palette:\n        conf = sum(1 for nb in adj[idx] if sol[nb] == c)\n        if conf < best_conf:\n            best_conf = conf\n            best_c = c\n            improved = True\n            break  # first-improvement\n    if improved:\n        sol[idx] = best_c\n        # Normalize only if highest color class removed\n        max_c_after = max(sol)\n        if max_c_after < max_color:\n            sol = normalize(sol)\n        return sol, \"NB_Local\", \"RecolorMinConf\"\n\n    # If no recolor improvement, try 2 Kempe flips with neighbor colors and pick best\n    neigh_colors = [sol[nb] for nb in adj[idx] if sol[nb] != sol[idx]]\n    if neigh_colors:\n        candidates = []\n        for cb in random.sample(neigh_colors, k=min(2, len(neigh_colors))):\n            ca = sol[idx]\n            cand = normalize(kempe_flip(sol, idx, ca, cb))\n            candidates.append(cand)\n        best = min(candidates + [sol], key=eval_tuple)\n        move = \"KempeFlip\" if best is not sol else \"NoOp\"\n        return best, (\"NB_Global\" if move==\"KempeFlip\" else \"NB_Local\"), move\n\n    # Fallback: random recolor within current palette\n    sol[idx] = random.randint(1, max_color)\n    return sol, \"NB_Local\", \"RandomRecolor\"\n","PERTURB_CODE":"import math\nimport random\n\ndef perturb_solution(solution):\n    # Diversification: swap color classes and biased random recolors\n    n = 9\n    if not isinstance(solution, (list, tuple)) or len(solution) != n:\n        return [1]*n\n\n    sol = list(solution)\n\n    def normalize(a):\n        mapping = {}\n        nextc = 1\n        out = []\n        for c in a:\n            if c not in mapping:\n                mapping[c] = nextc\n                nextc += 1\n            out.append(mapping[c])\n        return out\n\n    max_color = max([c for c in sol if isinstance(c, int) and c >= 1] + [1])\n\n    # 1) With probability 0.5, swap two color classes entirely\n    if max_color >= 2 and random.random() < 0.5:\n        a, b = random.sample(range(1, max_color + 1), 2)\n        for i in range(n):\n            if sol[i] == a:\n                sol[i] = b\n            elif sol[i] == b:\n                sol[i] = a\n\n    # 2) Randomly recolor about n\/3 vertices, prioritizing highest color class\n    h = max_color\n    idxs = list(range(n))\n    random.shuffle(idxs)\n    idxs.sort(key=lambda i: (sol[i] != h, random.random()))  # prioritize highest color vertices\n    m = max(2, n \/\/ 3)\n    idxs = idxs[:m]\n\n    for i in idxs:\n        pool = list(range(1, max(2, max_color)))  # prefer existing lower colors\n        # Occasionally allow introducing a new color for escape\n        if random.random() < 0.2:\n            pool.append(max_color + 1)\n        sol[i] = random.choice(pool)\n        if sol[i] > max_color:\n            max_color = sol[i]\n\n    sol = normalize(sol)\n    return sol\n","SAMPLE_SOL":"[1,1,1,2,3,2,3,4,4]"},"Version":2,"Feedback":"\"COMPONENT_VERSION\",\"v1.0.0-fix-local-solver-signature-and-neighbour-format\"\n\"FEEDBACK\",\"E_SIG_MISMATCH:Heuristic signatures do not match TARGET_HEURISTIC_GENERAL_SIGNATURE. Update to def Heuristic(currentSolution,best,best_score,generate_neighbour,evaluate_solution,perturb_solution,other_params). Ensure local solvers (SA\/ILS\/TS) adhere to this exact signature.\"\n\"FEEDBACK\",\"E_GENNEIGH_RET:generate_neighbour returns 3 values (neighbor,NB_Type,Movement_Type) but local solvers attempt to unpack 2, causing 'too many values to unpack'. Standardize solver unpacking to accept 3 outputs or wrap generate_neighbour to return only neighbor when solvers expect a single object.\"\n\"FEEDBACK\",\"E_PERTURB_MISSING:Perturbation Function is undefined ($Perturb placeholder). Provide a concrete def perturb_solution(solution, other_params) matching the general signature. Without this, ILS and any diversification step will fail at call-time.\"\n\"FEEDBACK\",\"E_FUNC_NAME_COLLISION:All three reports reference 'def SA(...)' even for Iterated_Local_Search and Taboo_Search. Rename functions to distinct, correct entry points and align their parameters with the target signature to avoid dispatch errors.\"\n\"FEEDBACK\",\"E_PARAM_ORDER:Local SA signature shows positional params TEMP, MIN_TEMP, cooling_factor, conflicting with the required Heuristic signature. Move these into other_params (dict) to maintain uniform call protocol and avoid arity errors.\"\n\"FEEDBACK\",\"NB_CODE_FAIL_LOCAL_OPT:Neighbour operator rebuilds adjacency on every call (O(|E|) overhead). Precompute adj once outside the function or capture via closure to reduce per-move overhead.\"\n\"FEEDBACK\",\"NB_SCOPE_BLOAT:normalize, conflicts_count, eval_tuple, kempe_flip are redefined on each call. Hoist to outer scope to avoid repeated allocations and improve CPU cache locality.\"\n\"FEEDBACK\",\"NB_KEMPE_WEAK:Kempe flips sample only up to 2 candidates uniformly. Increase candidates adaptively (e.g., degree-weighted or conflict-weighted selection; try 4\u20138) and choose best by (violations,k) to escape local minima more reliably.\"\n\"FEEDBACK\",\"NB_MOVE_SELECTION:First-improvement recolor stops at first lower-conflict color; this can stall with plateaus. Use best-improvement over palette when conflicts>0, and tie-break by minimizing resulting k.\"\n\"FEEDBACK\",\"NB_PALETTE_MGMT:Randomly introducing new color with p=0.15 can inflate palette unnecessarily. Gate this on sustained stagnation or conflict plateau; otherwise prioritize recolors within current palette.\"\n\"FEEDBACK\",\"NB_NORMALIZE_TRIGGER:Normalization only when max color eliminated may leave gaps after general recolors\/Kempe flips. Normalize after any move that reduces max_color or removes a color class to keep k pressure active.\"\n\"FEEDBACK\",\"NB_RECOVERY_WEAK:Recovery returns all-1 coloring, which maximizes conflicts. Replace with greedy DSATUR initialization to bootstrap feasibility and reduce early-stage thrashing.\"\n\"FEEDBACK\",\"EVAL_TIEBREAK_LIMIT:Fitness 1000*violations + k is OK but coarse. Consider lexicographic compare (violations first, then k) consistently in local decisions to prevent misleading improvements from small k reductions when violations differ.\"\n\"FEEDBACK\",\"EVAL_COMPAT:Objective is minimization; ensure all heuristics treat lower scores as better and do not negate evaluation values. Remove any score negation code from max-oriented templates.\"\n\"FEEDBACK\",\"SA_COOLING_POLICY:Cooling parameters unspecified and inconsistent with signature. Move TEMP, MIN_TEMP, cooling_factor into other_params with defaults, and enforce geometric cooling with reheating on stagnation to stabilize acceptance.\"\n\"FEEDBACK\",\"TS_TABU_DEFICIT:No tabu memory specified. Add tabu list on (vertex,color) assignments with tenure ~7\u201310, aspiration for strictly better (viol,k), and frequency-based penalties to diversify.\"\n\"FEEDBACK\",\"ILS_PERTURBATION:Define perturb_solution as multi-vertex Kempe flips or random color merge-split on top color class; apply 1\u20132 strength levels and always re-normalize before local search.\"\n\"FEEDBACK\",\"SAMPLE_EVAL_CHECK:Sample solution evaluates as feasible under evaluate_solution, but provides no guarantee of minimal k. Use the local solver with fixed seed and run budget to validate reductions systematically.\"\n\"FEEDBACK\",\"COMPAT_RETURN:Ensure generate_neighbour always returns a Python list (not tuple) for the neighbor and that all integers are >=1 to avoid domain penalties (10^7).\"\n\"FEEDBACK\",\"PERF_CACHE:Cache max_color, conflicting vertex set, and adjacency to amortize cost across iterations; update incrementally after local moves to reduce O(|E|) recomputation.\"\n\"FEEDBACK\",\"RANDOMNESS_CONTROL:Set and log RNG seed in other_params for reproducibility and debugging; current randomness hinders deterministic regression testing.\"\n\"FEEDBACK\",\"E_EVAL_ASSERT:evaluate_solution consistency verified against provided benchmarks; no discrepancies detected. Maintain this function unchanged as the optimization oracle.\"\n\"FEEDBACK\",\"ACTIONABLE_FIX_ORDER:1) Fix heuristic function signatures and unpacking (errors halt execution). 2) Implement perturb_solution. 3) Standardize generate_neighbour return handling. 4) Hoist static data and optimize neighbour operations. 5) Enhance move set (best-improvement recolor, stronger Kempe). 6) Add tabu\/SA policy details and reproducibility controls.\""}
